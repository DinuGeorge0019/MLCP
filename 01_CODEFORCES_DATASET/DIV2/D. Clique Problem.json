{
    "link": "https://codeforces.com//contest/527/problem/D",
    "problemId": "24745",
    "problem_idx": "D",
    "shortId": "527D",
    "contest_number": "527",
    "problem_submissions": {
        "D": [
            10320998,
            10323329,
            10320418,
            10316376,
            10320868,
            10323389,
            10322440,
            10320232,
            10321604,
            10323582,
            10321959,
            10322883,
            10324771,
            10323891,
            10324342,
            10325751,
            10316899,
            10320622
        ],
        "C": [
            10319281,
            10317608,
            10318719,
            10321621,
            10319197,
            10319745,
            10320049,
            10325822,
            10321996,
            10320609,
            10320450,
            10322500,
            10322047,
            10318021,
            10323195,
            10322166,
            10322519,
            10313548
        ],
        "B": [
            10316733,
            10315414,
            10316286,
            10320342,
            10316974,
            10315178,
            10316059,
            10315345,
            10320022,
            10315992,
            10316397,
            10319742,
            10317580,
            10315069,
            10315584,
            10318949,
            10318891,
            10343112,
            10316418
        ],
        "A": [
            10313000,
            10313055,
            10313796,
            10312916,
            10313836,
            10313217,
            10312846,
            10312806,
            10313753,
            10312901,
            10312783,
            10313020,
            10313144,
            10312917,
            10312793,
            10312900,
            10314293,
            10313134
        ],
        "E": [
            11345011
        ]
    },
    "name": "D. Clique Problem",
    "statement": "The clique problem is one of the most well-known NP-complete problems.\r\nUnder some simplification it can be formulated as follows. Consider an\r\nundirected graph . It is required to find a subset of vertices of the\r\nmaximum size such that any two of them are connected by an edge in graph\r\n. Sounds simple, doesn’t it? Nobody yet knows an algorithm that finds a\r\nsolution to this problem in polynomial time of the size of the graph.\r\nHowever, as with many other NP-complete problems, the clique problem is\r\neasier if you consider a specific type of a graph.Consider distinct\r\npoints on a line. Let the -th point have the coordinate and weight .\r\nLet’s form graph , whose vertices are these points and edges connect\r\nexactly the pairs of points , such that the distance between them is not\r\nless than the sum of their weights, or more formally: .Find the size of\r\nthe maximum clique in such graph.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int N = 2e5 + 3;\nint n, m, ans, f[N], b[N * 2], BIT[N * 2];\nstruct data {\n\tint x, w;\n\tdata(){}\n\tinline bool operator < (const data &rhs) const {\n\t\treturn x < rhs.x;\n\t}\n} a[N];\n\ninline void Insert(int x, const int &v) {\n\tfor (; x <= m; x += x & -x)\n\t\tif (BIT[x] < v) BIT[x] = v;\n\t\telse return ;\n}\n\ninline int Query(int x) {\n\tint res = 0;\n\tfor (; x > 0; x -= x & -x)\n\t\tif (BIT[x] > res) res = BIT[x];\n\treturn res;\n}\n\nchar ch;\ninline int read() {\n\twhile (ch = getchar(), ch < '0' || ch > '9');\n\tint res = ch - 48;\n\twhile (ch = getchar(), ch >= '0' && ch <= '9') res = res * 10 + ch - 48;\n\treturn res;\n}\n\nint main() {\n\tn = read();\n\tfor (int i = 1; i <= n; ++i)\n\t\ta[i].x = read(), a[i].w = read();\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tb[++m] = a[i].x - a[i].w, b[++m] = a[i].x + a[i].w;\n\tsort(b + 1, b + m + 1);\n\tm = unique(b + 1, b + m + 1) - b - 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint p = lower_bound(b + 1, b + m + 1, a[i].x - a[i].w) - b;\n\t\tf[i] = Query(p) + 1;\n\t\tp = lower_bound(b + 1, b + m + 1, a[i].x + a[i].w) - b;\n\t\tInsert(p, f[i]);\n\t\tif (f[i] > ans) ans = f[i];\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Clique Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/17020",
    "editorial": "One may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem.\n\nInitially you have that points may lie together in a set if they are not too close, i. e. |xi?-?xj|???wi?+?wj. This is obviously equivalent to the following condition. Lets consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.\n\nThis task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint:",
    "hint": []
}