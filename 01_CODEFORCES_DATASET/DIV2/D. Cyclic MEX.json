{
    "link": "https://codeforces.com//contest/1905/problem/D",
    "problemId": "2384303",
    "problem_idx": "D",
    "shortId": "1905D",
    "contest_number": "1905",
    "problem_submissions": {
        "F": [
            237519503,
            237518706,
            237482920,
            237522705,
            237524131,
            237602806,
            237553489,
            237539816,
            237539559,
            237531355,
            238226356,
            238226333
        ],
        "E": [
            237505954,
            237497832,
            237495453,
            237512642,
            237513385,
            237508924,
            237511733,
            237515516,
            237508774,
            237502235,
            237513715,
            237519547,
            237522468,
            237711000,
            237515591,
            237507153,
            237518502,
            237520768,
            237516891,
            237516610
        ],
        "D": [
            237492749,
            237504330,
            237509326,
            237501351,
            237508164,
            237500145,
            237500325,
            237496593,
            237501654,
            237512862,
            237494885,
            237497599,
            237495760,
            237710975,
            237503073,
            237516000,
            237505850,
            237496346,
            237504183,
            237504223
        ],
        "C": [
            237484859,
            237486387,
            237514010,
            237484118,
            237485834,
            237477056,
            237481640,
            237480170,
            237483989,
            237484101,
            237482806,
            237484400,
            237487254,
            237710962,
            237490113,
            237487402,
            237483252,
            237485864,
            237495090,
            237491635
        ],
        "B": [
            237476673,
            237478416,
            237514764,
            237473227,
            237475996,
            237480677,
            237471243,
            237471572,
            237474579,
            237471819,
            237473855,
            237474076,
            237478005,
            237710941,
            237481035,
            237481302,
            237473092,
            237475685,
            237477792,
            237477297
        ],
        "A": [
            237470661,
            237474004,
            237515478,
            237470037,
            237470853,
            237487781,
            237469382,
            237469477,
            237471099,
            237469459,
            237470679,
            237470317,
            237471411,
            237710923,
            237474857,
            237474763,
            237469530,
            237469890,
            237472488,
            237474669
        ]
    },
    "name": "D. Cyclic MEX",
    "statement": "For an array a, define its as\r\nsum_{i=1}^{n}\r\noperatorname{mex} ^\r\ndagger ([a_1,a_2,\r\nldots,a_i]).You are given a permutation^\r\nddagger p of the set\r\n{0,1,2,\r\nldots,n-1\r\n}. Find the maximum cost across all cyclic shifts of p.^\r\ndagger\r\noperatorname{mex}([b_1,b_2,\r\nldots,b_m]) is the smallest non-negative integer x such that x does not\r\noccur among b_1,b_2,\r\nldots,b_m.^\r\nddaggerA permutation of the set\r\n{0,1,2,...,n-1\r\n} is an array consisting of n distinct integers from 0 to n-1 in\r\narbitrary order. For example, [1,2,0,4,3] is a permutation, but [0,1,1]\r\nis not a permutation (1 appears twice in the array), and [0,2,3] is also\r\nnot a permutation (n=3 but there is 3 in the array).\r\n",
    "solutions": [
        "// Problem: D. Cyclic MEX\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/D\n// Memory Limit: 512 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n// #pragma GCC optimize(\"Ofast,inline,unroll-loops\")\n// #define _GLIBCXX_DEBUG //交题前记得注释掉不然容易T。\n#include<bits/stdc++.h>\n#define File(s) freopen(#s\".in\",\"r\",stdin),freopen(#s\".out\",\"w\",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<\"@\"<<__LINE__<<\"=\"<<(x)<<'\\n')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=-2023,M=1000000007;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\n\nsigned main(){\n\t//std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tint n=g90;\n\t\tvi p=rvec(n);\n\t\tstd::rotate(p.begin(),std::find(all(p),0),p.end());\n\t\t// for(auto x:p)std::cerr<<x;\n\t\t// std::cerr<<'\\n';\n\t\tvi st;\n\t\tll sum=0,ans=0;\n\t\tauto calc=[&](){\n\t\t\tif(st.size()<=1)return 0ll;\n\t\t\treturn ll(st.back()-st[st.size()-2])*p[st.back()];\n\t\t};\n\t\tfor(int i=0;i<n;++i){\n\t\t\twhile(!st.empty()&&p[st.back()]>p[i]){\n\t\t\t\tsum-=calc();\n\t\t\t\tst.pop_back();\n\t\t\t}\n\t\t\t\n\t\t\tst.eb(i);\n\t\t\tsum+=calc();\n\t\t\tans=std::max(ans,sum);\n\t\t\t// for(auto x:st){\n\t\t\t\t// std::cerr<<x<<' ';\n\t\t\t// }\n\t\t\t// std::cerr<<'\\n';\n\t\t}\n\t\tprintf(\"%lld\\n\",ans+n);\n\t}();\n}//main()"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Cyclic MEX.json",
    "editorial_link": "https://codeforces.com//blog/entry/123384",
    "editorial": "SolutionLetâs analyze how the values of each prefix mex changes upon\r\nperforming a cyclic shift to the left: The first prefix mex is popped.\r\nEach prefix mex with a value less than doesnât change. Each prefix mex\r\nwith a value greater than becomes . is appended to the back. Letâs keep\r\nour prefix mexes compressed ( meaning that we keep the value and its\r\nfrequency instead of keeping multiple same values ). After that, we can\r\nsimulate the above process naively with a deque, because the potential\r\nwill decrease by the number of performed operations. This solution works\r\nin time.\r\n",
    "hint": []
}