{"link": "https://codeforces.com//contest/427/problem/C", "problemId": "9095", "problem_idx": "C", "shortId": "427C", "contest_number": "427", "problem_submissions": {"E": [6529676, 6527850, 6529995, 6528507, 6529891, 6528022, 6531554, 6531662, 6531650, 6531698, 6531712, 6530455, 6532065, 6527906, 6531472, 6533495, 6528109, 6530245, 6529960, 6530613], "D": [6527983, 6529398, 6528326, 6530702, 6534291, 6529012, 6529644, 6529417, 6530366, 6530850, 6529777, 6528806, 6532098, 6529134, 8322622, 6531820, 6528330], "C": [6526456, 6526319, 6526893, 6528943, 6526905, 6526400, 6528201, 6526648, 6527081, 6527815, 6530569, 6528401, 6530942, 6525719, 6528319, 6527086, 6526075, 6526591, 6526667, 6525971], "B": [6524329, 6524628, 6525243, 6524515, 6525057, 6524940, 6525765, 6524924, 6525305, 6528525, 6525911, 6525634, 6525338, 6523816, 6528718, 6524445, 6524359, 6525504, 6525432, 6526909], "A": [6523077, 6523845, 6524661, 6523545, 6523918, 6523933, 6523978, 6523356, 6523252, 6524775, 6525360, 6523618, 6524309, 6523039, 6524259, 6523009, 6523402, 6523741, 6523222, 6524142]}, "name": "C. Checkposts", "statement": "Your city has junctions. There are roads between the junctions. As a\r\nmayor of the city, you have to ensure the security of all the\r\njunctions.To ensure the security, you have to build some police\r\ncheckposts. Checkposts can only be built in a junction. A checkpost at\r\njunction can protect junction if either or the police patrol car can go\r\nto from and then come back to .Building checkposts costs some money. As\r\nsome areas of the city are more expensive than others, building\r\ncheckpost at some junctions might cost more money than other\r\njunctions.You have to determine the minimum possible money needed to\r\nensure the security of all the junctions. Also you have to find the\r\nnumber of ways to ensure the security in minimum price and . Two ways\r\nare different if any of the junctions contains a checkpost in one of\r\nthem and do not contain in the other.\r\n", "solutions": ["#include <stdio.h>\n#include <string.h>\n\ntypedef long long LL;\nconst LL MOD = 1000000007LL;\n\nstruct edge\n{\n  int b;\n  edge* next;\n};\nedge ea[1000000];\nint nea = 0;\nedge* ealloc()\n{\n  return &ea[nea++];\n}\n\nint vc[120000];\nedge* ve[120000];\nedge* vr[120000];\nvoid add(int a, int b)\n{\n  edge* e = ealloc();\n  e->b = b; e->next = ve[a]; ve[a] = e;\n  e = ealloc();\n  e->b = a; e->next = vr[b]; vr[b] = e;\n}\n\nint vis[120000];\nint vo[120000];\nint nvo = 0;\n\nvoid dfs1(int v)\n{\n  vis[v] = 1;\n  for (edge* e = ve[v]; e; e = e->next)\n    if (!vis[e->b])\n      dfs1(e->b);\n  vo[nvo++] = v;\n}\n\nint bestv = 0;\nint bestn = 0;\nvoid dfs2(int v)\n{\n  vis[v] = 1;\n  if (vc[v] < bestv)\n    bestv = vc[v], bestn = 0;\n  if (vc[v] == bestv)\n    bestn++;\n  for (edge* e = vr[v]; e; e = e->next)\n    if (!vis[e->b])\n      dfs2(e->b);\n}\n\nint main()\n{\n  //freopen(\"input.txt\", \"rt\", stdin);\n  //freopen(\"output.txt\", \"wt\", stdout);\n\n  memset(ve, 0, sizeof ve);\n  memset(vr, 0, sizeof vr);\n\n  int n, m;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &vc[i]);\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++)\n  {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    add(a - 1, b - 1);\n  }\n\n  memset(vis, 0, sizeof vis);\n  for (int i = 0; i < n; i++)\n    if (!vis[i])\n      dfs1(i);\n  \n  memset(vis, 0, sizeof vis);\n  LL total = 0;\n  LL count = 1;\n  for (int i = n - 1; i >= 0; i--)\n  {\n    int v = vo[i];\n    if (!vis[v])\n    {\n      bestv = 1000000001;\n      bestn = 0;\n      dfs2(v);\n      total += LL(bestv);\n      count = (count * LL(bestn)) % MOD;\n    }\n  }\n  printf(\"%I64d %I64d\", total, count);\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "two pointers"], "dificulty": "1700", "interactive": false}