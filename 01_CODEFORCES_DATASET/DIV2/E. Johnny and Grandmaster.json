{
    "link": "https://codeforces.com//contest/1362/problem/E",
    "problemId": "640966",
    "problem_idx": "E",
    "shortId": "1362E",
    "contest_number": "1362",
    "problem_submissions": {
        "E": [
            82533242,
            82534444,
            82537740,
            82514250,
            82533930,
            82533069,
            82537596,
            82539990,
            82540242,
            82538471,
            82539682,
            82530965,
            82542614,
            82539643,
            82539283,
            82546202,
            82528337,
            82546467
        ],
        "D": [
            82510668,
            82507788,
            82509488,
            82531898,
            82514757,
            82515389,
            82522345,
            82516278,
            82518522,
            82519426,
            82519224,
            82768835,
            82595629,
            82522253,
            82524305,
            82523832,
            82521456,
            82543796,
            82520171
        ],
        "C": [
            82499455,
            82498958,
            82501198,
            82493857,
            82499687,
            82506922,
            82499891,
            82507219,
            82505247,
            82500067,
            82504471,
            82506074,
            82507172,
            82504835,
            82510757,
            82507288,
            82510259
        ],
        "B": [
            82495744,
            82495722,
            82497194,
            82492324,
            82495262,
            82500116,
            82495247,
            82495676,
            82498396,
            82494894,
            82501982,
            82494238,
            82501685,
            82493927,
            82498961,
            82504636,
            82504999
        ],
        "A": [
            82492673,
            82492696,
            82492707,
            82492807,
            82492452,
            82496773,
            82492476,
            82492710,
            82493556,
            82492430,
            82494321,
            82492417,
            82493444,
            82492319,
            82493342,
            82492942,
            82498191
        ],
        "F": [
            99790549,
            99789950,
            99789855,
            99786615,
            99786490,
            99783918,
            99783396,
            99783108,
            99779312,
            99779011,
            99778620,
            99777308,
            99776727,
            99776430,
            99776080,
            99775979,
            99775398,
            99023034,
            99020809,
            99014011,
            99012603,
            82568961,
            82562279,
            82589807
        ]
    },
    "name": "E. Johnny and Grandmaster",
    "statement": "Johnny has just found the new, great tutorial: \"\". The tutorial tells\r\nmany strange and unexpected for Johnny things, such as you have to be\r\npatient or that very important is solving many harder and harder\r\nproblems. The boy has found an online judge with tasks divided by topics\r\nthey cover. He has picked p^{k_i} problems from i-th category (p is his\r\nfavorite number). He wants to solve them in two weeks (the patience\r\ncondition is too hard for Johnny, so for simplicity, he looks only at\r\neasy tasks, which can be solved in such a period). Now our future\r\ngrandmaster has to decide which topics to cover first and which the\r\nsecond week. Help him assign topics in such a way, that workload is\r\nbalanced.Formally, given n numbers p^{k_i}, the boy wants to divide them\r\ninto two disjoint sets, minimizing the absolute difference between sums\r\nof numbers in each set. Find the minimal absolute difference. Output the\r\nresult modulo 10^{9}+7.\r\n",
    "solutions": [
        "#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\n\nll power(ll x, ll p) {\n\tif (p == 0) { return 1ll; }\n\tx %= mod;\n\tll temp = power(x, p / 2) % mod;\n\ttemp *= temp; temp %= mod;\n\tif (p & 1) { temp *= x; temp %= mod; }\n\treturn temp;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint t; cin >> t;\n\n\twhile (t--) {\n\t\tint n, p; cin >> n >> p;\n\t\tvector<int> nums(n);\n\t\tfor (auto &x : nums) { cin >> x; }\n\t\tif (p == 1) {\n\t\t\tif (n % 2 == 0) { cout << 0 << '\\n'; }\n\t\t\telse { cout << 1 << '\\n'; }\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(nums.rbegin(), nums.rend());\n\n\t\tvector<int> set1, set2;\n\t\tbool reset = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (reset) { set1.push_back(nums[i]); reset = false; continue; }\n\t\t\tif (set1.back() == nums[i]) { set2.push_back(nums[i]); reset = true; continue; }\n\n\t\t\tint target = set1.back();\n\t\t\tvector<pair<int, int>> s;\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tif (s.empty()) { s.push_back({ nums[i], 1 }); continue; }\n\n\t\t\t\tint curNum = nums[i]; bool done = false;\n\t\t\t\twhile(!s.empty() && s.back().first == curNum){\n\t\t\t\t\tpair<int, int> curP = s.back();\ts.pop_back();\n\t\t\t\t\tif (curP.second + 1 < p) { s.push_back({ curP.first, curP.second + 1 }); done = true; break; }\n\t\t\t\t\telse { curNum++; }\n\t\t\t\t}\n\t\t\t\tif (!done) { s.push_back({ curNum, 1 }); }\n\n\t\t\t\tif (!s.empty() && s.back().first == target) { reset = true; break; }\n\t\t\t}\n\n\t\t\twhile (!s.empty()) {\n\t\t\t\tpair<int, int> curP = s.back();\ts.pop_back();\n\t\t\t\tfor (int mm = 0; mm < curP.second; mm++) {\n\t\t\t\t\tset2.push_back(curP.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll res = 0;\n\t\tfor (int i = 0; i < set1.size(); i++) { res += power(p, set1[i]); res %= mod; }\n\t\tfor (int i = 0; i < set2.size(); i++) { res -= power(p, set2[i]); res %= mod; }\n\n\t\twhile (res < 0) { res += mod; res %= mod; }\n\n\t\tcout << res << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation",
        "math",
        "number theory",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Johnny and Grandmaster.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "The solution for the case p=1\n is trivial, the answer is 1\n for odd n\n and 0\n for even n\n. From now on, I will assume that p>1\n. Instead of partitioning the elements into two sets, I will think of placing plus and minus signs before them to minimize the absolute value of the resulting expression.\n\nWe will process the exponents in non-increasing order and maintain the invariant that the current sum is nonnegative. Say we are processing ki.\n In such cases, we will know the current sum modulo 109+7\n and its exact value divided by pki\n (denoted as v\n) or information that it's too big.\n\nInitially, the sum (I will denote it s\n) equals 0\n. While processing elements:\n\nIf s>0\n, subtract the current element from the sum (it easy to show that it won't be negative after this operation).\n\nIf s=0\n, add the current element to the sum.\n\nIf at any point of the algorithm, v=spki>n\n, there is no need to store the exact value of v\n anymore, because it is so big that all the elements from this moment on will be subtracted. Thus, it is enough to store this information and the current sum modulo 109+7\n.\n\nWhen we move to the next element, the exponent may change, and v\n needs to be multiplied by a power of p\n. Since the exponents can be large, we use fast multiplication.\n\nThe time complexity of this solution is O(nlogn+nlogmaxki)\n.",
    "hint": []
}