{
    "link": "https://codeforces.com//contest/1944/problem/F1",
    "problemId": "2535054",
    "problem_idx": "F1",
    "shortId": "1944F1",
    "contest_number": "1944",
    "problem_submissions": {
        "E": [
            251782515,
            251752198,
            251760134,
            251765767,
            251780123,
            251755818,
            251785307,
            251786773,
            251774041,
            251782215,
            251788365,
            251768261,
            251786805,
            251786877
        ],
        "D": [
            251774395,
            251745809,
            251734994,
            251735975,
            251741617,
            251753993,
            251816452,
            251754858,
            251782010,
            251751610,
            251760683,
            251760131,
            251771429,
            251757991,
            251756622,
            251757761,
            251764901,
            251792696,
            251771886,
            251771626
        ],
        "F2": [
            251750838,
            251716813,
            251789175,
            252177387
        ],
        "F1": [
            251747784,
            251709303,
            251789140,
            251765369,
            252064569,
            251778632,
            251783727,
            251776370,
            252190323,
            251778029,
            251787478
        ],
        "C": [
            251727192,
            251748340,
            251720353,
            251717607,
            251744834,
            251719448,
            251721344,
            251728728,
            251723190,
            251722648,
            251720271,
            251715992,
            251711499,
            251727997,
            251722342,
            251754221,
            251727857,
            251727380,
            251734830,
            251734204
        ],
        "B": [
            251714769,
            251743002,
            251717270,
            251713265,
            251751112,
            251715501,
            251712246,
            251715265,
            251717723,
            251714892,
            251714867,
            251712443,
            251720698,
            251717033,
            251737965,
            251714389,
            251717278,
            251719138,
            251727691,
            251724161
        ],
        "A": [
            251705704,
            251744128,
            251703581,
            251703048,
            251747005,
            251704719,
            251705040,
            251701932,
            251706171,
            251701886,
            251705757,
            251701530,
            251704051,
            251712020,
            251711838,
            251705512,
            251702145,
            251704041,
            251711450,
            251703284
        ]
    },
    "name": "F1. Counting Is Fun  Easy Version ",
    "statement": "An array b of m non-negative integers is said to be if all the elements\r\nof b can be made equal to 0 using the following operation some\r\n(possibly, zero) times: Select two indices l and r (1\r\nleq l\r\ncolor{red}{<} r\r\nleq m) and subtract 1 from all b_i such that l\r\nleq i\r\nleq r. You are given two positive integers n, k and a prime number\r\np.Over all (k+1)^n arrays of length n such that 0\r\nleq a_i\r\nleq k for all 1\r\nleq i\r\nleq n, count the number of good arrays.Since the number might be too\r\nlarge, you are only required to find it modulo p.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl '\\n'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nconst int N=410;\nint n,m,M;\nll f[N][N];\nvoid work() {\n\tcin>>n>>m>>M;\n\tFor(i,0,n+1) For(j,0,m) f[i][j]=0;\n\tf[0][0]=1;\n\tFor(i,0,m) f[1][i]=1;\n\tFor(i,2,n+1) {\n\t\tll s=0;\n\t\tFor(j,0,m) s+=f[i-1][j]; s%=M;\n\t\tFor(j,0,m) {\n\t\t\tf[i][j]=s;\n\t\t\tFor(k,0,m-j) f[i][j]-=f[i-2][k]*(m-j-k);\n\t\t\tf[i][j]=(f[i][j]%M+M)%M;\n\t\t}\n\t}\n\tcout<<f[n+1][0]<<endl;\n}\nint main() {\n#ifdef LOCAL\n\tfreopen(\".in\",\"r\",stdin);\n\t// freopen(\".out\",\"w\",stdout);\n\t// freopen(\".debug\",\"w\",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Counting Is Fun  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "All operations which include i\n must also either include i?1\n or i+1\n. Hence ai?ai?1+ai+1\n must hold. Throughout the editorial treat ai=0\n for (i?0)\n or (i>n)\n.\n\nBut, is this sufficient? Infact, it is and we can prove it by strong induction.\n\nProof\nNow that we have the condition, we can define a dynamic programming as follows :\n\ndp(i,a,b)\n = number of ways to make an array upto the i\n-th index with ai?1=a\n, ai=b\n (since only the last 2\n elements are relevant).\n\nLet the new element be c\n, then it is a valid way iff b?a+c\n. So we have a O(n4)\n by iterating over all possibilities.\n\nAs a final optimization, we can speed it up to O(n3)\n by using prefix sums. Note that the valid values of a\n for fixed b\n and c\n satisfy a?max(0,b?c)\n, and hence maintaining prefix sums over a\n, we can speed it up.",
    "hint": []
}