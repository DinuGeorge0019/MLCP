{
    "link": "https://codeforces.com//contest/1391/problem/E",
    "problemId": "694519",
    "problem_idx": "E",
    "shortId": "1391E",
    "contest_number": "1391",
    "problem_submissions": {
        "E": [
            89439040,
            89441228,
            89441499,
            89447005,
            89455919,
            89448964,
            89450402,
            89450314,
            89451586,
            89450891,
            89451401,
            89477045,
            89456884,
            89551553,
            89455517,
            134448846
        ],
        "D": [
            89432700,
            89481054,
            89433875,
            89429170,
            89437115,
            89436985,
            89437929,
            89442877,
            89440195,
            89442618,
            89441518,
            89427031,
            89429794,
            89432423,
            89430800,
            89431789,
            89433956,
            89433503,
            89434575,
            89434257,
            89434975
        ],
        "C": [
            89426750,
            89420513,
            89434144,
            89429566,
            89425760,
            89427285,
            89429714,
            89432343,
            89427996,
            89426533,
            89417430,
            89420352,
            89419759,
            89418803,
            89424047,
            89424699,
            89425111,
            89422696,
            89425810,
            89422948
        ],
        "B": [
            89410454,
            89413605,
            89410503,
            89414269,
            89414715,
            89415761,
            89415369,
            89418138,
            89419682,
            89414189,
            89411200,
            89409436,
            89412062,
            89413310,
            89415929,
            89412884,
            89413208,
            89414045,
            89413779,
            89419197
        ],
        "A": [
            89406971,
            89407448,
            89407070,
            89407023,
            89410266,
            89408876,
            89408557,
            89413085,
            89412622,
            89407815,
            89407257,
            89406922,
            89406883,
            89407981,
            89408687,
            89407102,
            89407091,
            89409131,
            89415228,
            89408988
        ]
    },
    "name": "E. Pairs of Pairs",
    "statement": "You have a simple and connected undirected graph consisting of n nodes\r\nand m edges.Consider any way to pair some subset of these n nodes such\r\nthat no node is present in more than one pair. This pairing is if for\r\nevery pair of pairs, the induced subgraph containing all 4 nodes, two\r\nfrom each pair, has at most 2 edges (out of the 6 possible edges). More\r\nformally, for any two pairs, (a,b) and (c,d), the induced subgraph with\r\nnodes\r\n{a,b,c,d\r\n} should have at most 2 edges. Please note that the subgraph induced by\r\na set of nodes contains nodes only from this set and edges which have\r\nboth of its end points in this set.Now, do one of the following: Find a\r\nsimple path consisting of at least nodes. Here, a path is called simple\r\nif it does not visit any node multiple times. Find a valid pairing in\r\nwhich at least nodes are paired. It can be shown that it is possible to\r\nfind at least one of the two in every graph satisfying constraints from\r\nthe statement.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int k_N = 5e5 + 3;\n\nint n, m;\nvector<int> adj[k_N];\nbool vis[k_N];\n\nvector<int> path_to_root;\nvector<int> d[k_N];\n\nbool dfs(int u){\n    path_to_root.push_back(u);\n    vis[u] = true;\n    if(2 * path_to_root.size() >= n)\n        return true;\n\n    d[path_to_root.size()].push_back(u);\n\n    for(int to: adj[u]){\n        if(vis[to]) continue;\n        if(dfs(to)) return true;\n    }\n\n    path_to_root.pop_back();\n    return false;\n}\n\nvoid solve(){\n    cin >> n >> m;\n    for(int i = 1; i <= n; ++i)\n        adj[i].clear();\n\n    for(int i = 0; i < m; ++i){\n        int u, v;\n        cin >> u >> v;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for(int i = 1; i <= n; ++i){\n        vis[i] = false;\n        d[i].clear();\n    }\n    path_to_root.clear();\n\n    if(dfs(1)){\n        cout << \"PATH\\n\";\n        cout << path_to_root.size() << \"\\n\";\n        for(int u: path_to_root)\n            cout << u << \" \";\n        cout << \"\\n\";\n        return;\n    }\n\n    cout << \"PAIRING\\n\";\n    vector<pair<int, int>> pairs;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 0; j < (int)d[i].size() - 1; j += 2){\n            pairs.push_back({d[i][j], d[i][j + 1]});\n        }\n    }\n\n    cout << pairs.size() << \"\\n\";\n    for(auto [a, b]: pairs)\n        cout << a << \" \" << b << \"\\n\";\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Pairs of Pairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/81265",
    "editorial": "Letâs build the DFS tree of the given graph, and let denote the depth of\r\nnode in the tree.If holds for any node , we have found a path.\r\nOtherwise, the maximum depth is at most , and we can find a valid\r\npairing as follows: For every depth (), keep pairing nodes at this depth\r\nuntil or remain. Clearly, at most node from each depth will remain\r\nunpaired, so, in total, we have paired at least nodes. Finally, letâs\r\nprove that every subgraph induced from some pairs has at most edges.\r\nConsider arbitrary pairs, () and (), where and . W.L.O.G, let\r\n.Obviously, the edges () and () cannot exist because edges can only go\r\nfrom a descendant to an ancestor. We can, further, show that each of and\r\ncan have an edge to at most one of and . For example, if has an edge to\r\nboth and , we can conclude that and are ancestor-descendants, which is\r\nnot possible because both of them are at the same depth. Time\r\nComplexity:\r\n",
    "hint": []
}