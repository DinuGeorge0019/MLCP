{
    "link": "https://codeforces.com//contest/1797/problem/D",
    "problemId": "1868416",
    "problem_idx": "D",
    "shortId": "1797D",
    "contest_number": "1797",
    "problem_submissions": {
        "B": [
            205419034,
            201275977,
            201268460,
            202344188,
            201271807,
            201275386,
            201273112,
            201272415,
            201269513,
            201276897,
            201277640,
            201269175,
            201275166,
            202145333,
            201276000,
            201267831,
            201270551,
            201276485,
            201289099,
            201272649,
            201271253,
            201272124,
            201270606
        ],
        "A": [
            205418993,
            201265764,
            201267671,
            202344137,
            201265725,
            201267108,
            201266341,
            201266676,
            201266049,
            201269061,
            201271927,
            201266144,
            201269858,
            202145345,
            201267522,
            201265871,
            201265945,
            201268294,
            201268304,
            201268572,
            201266365,
            201267763,
            201266314
        ],
        "C": [
            201304931,
            201299785,
            202344275,
            201282998,
            201300736,
            201289854,
            201285491,
            201299725,
            201282788,
            201290162,
            201283371,
            201295706,
            202145313,
            201292638,
            201281179,
            201287038,
            201297132,
            201271589,
            201298508,
            201283505,
            201292123,
            201308055
        ],
        "E": [
            201300187,
            201295260,
            201299598,
            201320286,
            202381158,
            201379930,
            201379655,
            201379250,
            201325544,
            201325138,
            201320528,
            201338561,
            201331085,
            201338593,
            201334166,
            202145221,
            201331849,
            201345570,
            201338770,
            201329752,
            201334417,
            201332873,
            201342334,
            201330509,
            201327922
        ],
        "D": [
            201273188,
            201286495,
            202344347,
            201311226,
            201292800,
            201301138,
            201293532,
            201309768,
            201303093,
            201302579,
            201300376,
            201317473,
            202145285,
            201313643,
            201313719,
            201306889,
            201311824,
            201310494,
            201312575,
            201304976,
            201303632,
            201307784
        ],
        "F": [
            201422339,
            201658184,
            201413786
        ]
    },
    "name": "D. Li Hua and Tree",
    "statement": "Li Hua has a tree of n vertices and n-1 edges. The root of the tree is\r\nvertex 1. Each vertex i has importance a_i. Denote the of a subtree as\r\nthe number of vertices in it, and the as the sum of the importance of\r\nvertices in it. Denote the of a non-leaf vertex as the son with the\r\nsubtree . If multiple of them exist, the is the one with the index.Li\r\nHua wants to perform m operations: \"1 x\" (1\r\nleq x\r\nleq n) calculate the of the subtree whose root is x. \"2 x\" (2\r\nleq x\r\nleq n) rotate the of x up. Formally, denote son_x as the of x, fa_x as\r\nthe father of x. He wants to remove the edge between x and fa_x and\r\nconnect an edge between son_x and fa_x. It is guaranteed that x is not\r\nroot, but guaranteed that x is not a leaf. If x is a leaf, please ignore\r\nthe operation. Suppose you were Li Hua, please solve this problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pa pair <int, int>\n#define fi first\n#define se second\nint n, m, a[100005];\nbasic_string <int> G[100005];\nstruct cmp {\n\tbool operator () (const pa x, const pa y) const {\n\t\treturn x.fi > y.fi or x.fi == y.fi && x.se < y.se;\n\t}\n};\nmultiset <pa, cmp> s[100005];\nll w[100005];\nint siz[100005], father[100005];\nvoid dfs(int u, int fa) {\n\tw[u] = a[u], siz[u] = 1, father[u] = fa, s[u].clear();\n\tfor (auto v : G[u]) if (v != fa) {\n\t\tdfs(v, u), w[u] += w[v], siz[u] += siz[v];\n\t\ts[u].insert({siz[v], v});\n\t}\n}\nint main() {\n\tios :: sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v; cin >> u >> v, G[u] += v, G[v] += u;\n\t}\n\tdfs(1, 0);\n\twhile (m--) {\n\t\tint opt, x; cin >> opt >> x;\n\t\tif (opt == 1) {\n\t\t\tcout << w[x] << '\\n';\n\t\t}\n\t\telse {\n\t\t\tif (s[x].size()) {\n\t\t\t\tint fa = father[x], son = s[x].begin() -> se;\n\t\t\t\ts[fa].erase(s[fa].find({siz[x], x}));\n\t\t\t\tsiz[x] -= siz[son], siz[son] += siz[x];\n\t\t\t\tw[x] -= w[son], w[son] += w[x], s[x].erase(s[x].begin());\n\t\t\t\ts[son].insert({siz[x], x}), s[fa].insert({siz[son], son});\n\t\t\t\tfather[son] = fa, father[x] = son;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dp",
        "implementation",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Li Hua and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/114890",
    "editorial": "Denote as the subtree of .The \"rotate\" operation doesn\u00e2\u0080\u0099t change the tree\r\nmuch. More specifically, only the of changes. We can use the brute force\r\nmethod to maintain useful information about each vertex when the\r\noperations are performed.What we need to do next is to find the of a\r\nvertex in a reasonable time. We can use a set to maintain the and index\r\nof all the sons of each vertex.Time complexity: .\r\n"
}