{
    "link": "https://codeforces.com//contest/1673/problem/C",
    "problemId": "1385665",
    "problem_idx": "C",
    "shortId": "1673C",
    "contest_number": "1673",
    "problem_submissions": {
        "E": [
            155426965,
            155417061,
            155442389,
            155435971,
            155444716,
            155445002,
            155444871,
            155514328,
            155514309,
            155514225,
            155443263,
            155444297,
            155443581,
            155433854
        ],
        "F": [
            155419208,
            155424822,
            155430193,
            155426235,
            155421394,
            155428770,
            155436120,
            155468393,
            155433714,
            155432038,
            155436911,
            155434672,
            155436663,
            155437291,
            155437403,
            155444380,
            155421502,
            155466705,
            155436336
        ],
        "D": [
            155415117,
            155435345,
            155420108,
            155439489,
            155431441,
            155419630,
            155415726,
            155421120,
            155422405,
            155419806,
            155421729,
            155424346,
            155424705,
            155419720,
            155443639,
            155434940,
            155418827,
            155423765
        ],
        "C": [
            155404978,
            155404876,
            155407310,
            155404678,
            155403723,
            155410318,
            155407177,
            155407649,
            155410425,
            155412404,
            155411432,
            155412241,
            155405106,
            155408638,
            155409170,
            155443684,
            155416480,
            155405320,
            155408554
        ],
        "B": [
            155402768,
            155402072,
            155401370,
            155411423,
            155405962,
            155405267,
            155404158,
            155402546,
            155402518,
            155406241,
            155407263,
            155417097,
            155402117,
            155403200,
            155414493,
            155417214,
            155402941,
            155413813
        ],
        "A": [
            155398139,
            155398122,
            155398102,
            155398465,
            155398314,
            155398797,
            155398162,
            155398613,
            155398972,
            155398376,
            155400350,
            155398178,
            155398450,
            155400124,
            155418014,
            155398258,
            155398425
        ]
    },
    "name": "C. Palindrome Basis",
    "statement": "You are given a positive integer n. Let\u2019s call some positive integer a\r\nwithout leading zeroes palindromic if it remains the same after\r\nreversing the order of its digits. Find the number of distinct ways to\r\nexpress n as a sum of positive palindromic integers. Two ways are\r\nconsidered different if the frequency of at least one palindromic\r\ninteger is different in them. For example, 5=4+1 and 5=3+1+1 are\r\nconsidered different but 5=3+1+1 and 5=1+3+1 are considered the same.\r\nFormally, you need to find the number of distinct multisets of positive\r\npalindromic integers the sum of which is equal to n.Since the answer can\r\nbe quite large, print it modulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nconst int N=40005;\nconst int mod=1e9+7;\n\nint dp[N],n=40000;\n\nbool check(int x){\n    static int a[10],len;\n    len=0;while(x)a[++len]=x%10,x/=10;\n    for(int i=1,j=len;i<j;i++,j--)if(a[i]!=a[j])return false;\n    return true;\n}\n\nint main(){\n    dp[0]=1;\n    for(int i=1;i<=n;i++){\n        if(check(i)){\n            for(int j=i;j<=n;j++)\n                dp[j]=(dp[j]+dp[j-i])%mod;\n        }\n    }\n    int T=read();\n    while(T--)print(dp[read()],'\\n');\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Palindrome Basis.json",
    "editorial_link": "https://codeforces.com//blog/entry/102389",
    "editorial": "TutorialFirst, we need to observe that the number of palindromes less\r\nthan is relatively very small. The number of -digit palindromes are\r\n(enumerate all -digit numbers less than and append the first two digits\r\nin the reverse order). Similarly, the number of -digit, -digit, -digit\r\nand -digit palindromes are , , and respectively, giving a total of\r\npalindromes.Now, the problem can be solved just like the classical\r\npartitions problem which can be solved using Dynamic Programming.Let\r\nNumber of ways to partition the number using only the first palindromes.\r\nIt is not hard to see that where denotes the palindrome. The first term\r\ncorresponds to the partitions of using only the first palindromes and\r\nthe second term corresponds to those partitions of in which the\r\npalindrome has been used atleast once. As base cases, and . The final\r\nanswer for any will be .The time and space complexity is .\r\n"
}