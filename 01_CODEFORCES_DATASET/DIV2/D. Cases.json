{
    "link": "https://codeforces.com//contest/1995/problem/D",
    "problemId": "2772828",
    "problem_idx": "D",
    "shortId": "1995D",
    "contest_number": "1995",
    "problem_submissions": {
        "D": [
            272131872,
            272130569,
            272133863,
            272134415,
            272137449,
            272131543,
            272154573,
            272151706,
            272151276,
            272141813,
            272139057,
            272151246,
            272151986,
            272153217,
            272157571,
            272148679,
            272149814,
            272486180,
            272157625
        ],
        "C": [
            272114157,
            272113319,
            272111654,
            272121111,
            272111819,
            272119019,
            272113803,
            272118860,
            272116736,
            272123439,
            272121989,
            272122933,
            272112629,
            272120005,
            272111612,
            272116249,
            272108377,
            272486053,
            272120187
        ],
        "B2": [
            272102449,
            272103267,
            272100652,
            272099671,
            272128930,
            272108225,
            272104913,
            272104116,
            272101309,
            272106328,
            272112408,
            272104562,
            272129604,
            272109901,
            272102807,
            272107257,
            272115397,
            272485973,
            272104395
        ],
        "B1": [
            272096864,
            272101887,
            272104047,
            272103720,
            272094726,
            272108617,
            272105391,
            272104979,
            272103341,
            272103459,
            272111706,
            272103650,
            272098283,
            272103066,
            272101216,
            272107954,
            272116416,
            272485941,
            272098022
        ],
        "A": [
            272090620,
            272090574,
            272092410,
            272090882,
            272090527,
            272090716,
            272091404,
            272090846,
            272090748,
            272091332,
            272090661,
            272091173,
            272091300,
            272090978,
            272091057,
            272091479,
            272092003,
            272485907,
            272092660
        ],
        "E1": [
            272173791,
            272497229,
            272245140
        ],
        "E2": [
            272497185,
            272274307
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131851",
    "editorial": "Solution(Read the hints.) is bad if there exists stored such that which\r\nis equivalent to being a submask of . All such b can be found using\r\nsimple dp on bitmasks. The rest are good.Time complexity:\r\n",
    "name": "D. Cases",
    "statement": "You’re a linguist studying a mysterious ancient language. You know that\r\nIts words consist only of the first c letters of the Latin alphabet.\r\nEach word has a which can be unambiguously determined by its last letter\r\n(different letters correspond to different cases). For example, words\r\nand (if they exist) have the same case in this language because they\r\nboth have the same ending , whereas and have different cases. If the\r\nlanguage does not have a case corresponding to some letter, it means\r\nthat the word cannot end with this letter. The length of each word is k\r\nor less. You have a single text written in this language. Unfortunately,\r\nas the language is really ancient, spaces between words are missing and\r\nall letters are uppercase. You wonder what is the minimum number of\r\ncases the language can have. Can you find this out?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/trie_policy.hpp>using namespace std;using namespace __gnu_pbds;typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;#ifndef ONLINE_JUDGE    #include \"debug.h\"#else    #define dbg(...) 42    template<typename T>ostream&operator<<(ostream&os,vector<T>&vec){for(signed i=0;i+1<vec.size();++i){os<<vec[i]<<\" \";}if(vec.size()>0)os<<vec.back();return os;}#endif #define all(x) x.begin(), x.end()#define rall(x) x.rbegin(), x.rend() template<typename T>istream&operator>>(istream&is,vector<T>&vec){for(T&element:vec){is>>element;}return is;}template<typename T>void chmin(T&x,T y){x=min(x,y);}template<typename T>void chmax(T&x,T y){x=max(x,y);} #define int int64_t void test_case(signed ___) {    int n, c, k;    cin >> n >> c >> k;    string s;    cin >> s;     bool blocked[1<<c]={};    int cnt[c]={};    for (int i = 0; i < n; ++i) {        s[i] -= 'A';    }     int tot = 0;    bool have[c]={};    for (int i = 0; i < n; ++i) {        if (!have[s[i]]) have[s[i]]=true, ++tot;    }     int curmask = 0;     auto add = [&] (int num) {        cnt[num]++;        if (cnt[num] == 1) curmask += 1 << num;    };     auto rem = [&] (int num) {        cnt[num]--;        if (cnt[num] == 0) curmask -= 1 << num;    };     for (int i = 0; i < k; ++i) {        add(s[i]);    }     blocked[curmask] = true;     for (int i = k; i < n; ++i) {        add(s[i]);        rem(s[i - k]);        blocked[curmask] = true;    }     int res = tot;     for (int m = 0; m < (1 << c); ++m) {        int here = tot - __popcount(m);        bool bad = false;        for (int j = 0; j < c; ++j) {            if (!have[j] && (m & (1 << j)) > 0) {                bad = true;                break;            }        }        if ((m & (1 << s.back())) > 0) continue;        if (bad) continue;        for (int subm = m; subm>0; subm = (subm - 1) & m) {            if (blocked[subm]) {                bad = true;                break;            }        }        if (!bad) {            res = min(res, here);        }    }    cout << res << \"\\n\";} signed main(void) {    cin.tie(0)->sync_with_stdio(false);     signed tt = 1;    cin >> tt;    while (tt--)     test_case(69420);}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Cases.json",
    "hint": [
        "Hint 1 If letter is chosen as an ending to some case, each occurrence of this letter may in the text can be considered an ending?",
        "Hint 2 The length of the word is something too complex. How can you simplify the restriction?",
        "Hint 3 Now you don't need the text because you can store bitmasks instead of substrings of length . To calculate the bitmasks you can use prefix sums for each of the characters (it will take overall).",
        "Hint 4 Now you need to find a bitmask with a minimal number of ones which intersects all the stored bitmasks.",
        "Hint 5 Identify \"bad\" bitmask instead of \"good\" ones."
    ]
}