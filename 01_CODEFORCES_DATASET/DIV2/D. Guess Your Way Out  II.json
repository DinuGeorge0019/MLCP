{
    "link": "https://codeforces.com//contest/558/problem/D",
    "problemId": "31489",
    "problem_idx": "D",
    "shortId": "558D",
    "contest_number": "558",
    "problem_submissions": {
        "D": [
            12060370,
            12056527,
            12059090,
            12059491,
            12059065,
            12054778,
            12056387,
            12055925,
            12063869,
            12072214
        ],
        "C": [
            12053633,
            12055512,
            12048548,
            12064102,
            12052329,
            12052749,
            12048409,
            12055315,
            12050109,
            12052282,
            12069418,
            12069387,
            12050188,
            12050328,
            12050475,
            12050277
        ],
        "B": [
            12048746,
            12050659,
            12043934,
            12044434,
            12044575,
            12045422,
            12043956,
            12057039,
            12045386,
            12043738,
            12048369,
            12046762,
            12054080,
            12044823,
            12046619,
            12044825,
            12045463,
            12046006,
            12046134
        ],
        "A": [
            12047744,
            12049996,
            12057160,
            12043771,
            12049018,
            12043976,
            12045019,
            12057924,
            12043847,
            12045136,
            12045173,
            12044161,
            12052769,
            12050459,
            12044438,
            12043911,
            12044045,
            12043813,
            12044484
        ],
        "E": [
            12046569,
            12048494,
            12053809,
            12056713,
            12054492,
            12054844,
            12048063,
            12064379,
            12046497,
            12054488,
            12050859,
            12055637,
            12056916,
            12071603
        ]
    },
    "name": "D. Guess Your Way Out  II",
    "statement": "Amr bought a new video game \"Guess Your Way Out! II\". The goal of the\r\ngame is to find an exit from the maze that looks like a perfect binary\r\ntree of height . The player is initially standing at the root of the\r\ntree and the exit from the tree is located at some leaf node.Let’s index\r\nall the nodes of the tree such that The root is number Each internal\r\nnode () will have a left child with index = and a right child with index\r\n= The level of a node is defined as for a root, or + level of parent of\r\nthe node otherwise. The vertices of the level are called leaves. The\r\nexit to the maze is located at some leaf node , the player doesn’t know\r\nwhere the exit is so he has to guess his way out! In the new version of\r\nthe game the player is allowed to ask questions on the format \"Does the\r\nnode number belong to the range ?\". Here is the ancestor of a node that\r\nlocated in the level . The game will answer with \"Yes\" or \"No\" only. The\r\ngame is designed such that it doesn’t always answer correctly, and\r\nsometimes it cheats to confuse the player!.Amr asked a lot of questions\r\nand got confused by all these answers, so he asked you to help him.\r\nGiven the questions and its answers, can you identify whether the game\r\nis telling contradictory information or not? If the information is not\r\ncontradictory and the exit node can be determined uniquely, output its\r\nnumber. If the information is not contradictory, but the exit node isn’t\r\ndefined uniquely, output that the number of questions is not sufficient.\r\nOtherwise output that the information is contradictory.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << \" --> \" << (x) << ' '\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl '\\n'\n#define pii pair< int , int >\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\n#define int ll\n\nll i, j, k, n, m, h, q, x, y, z, dp[N], dp2[N], t, q1;\n\nll tt[N];\n\nmap< ll , int > hh, w;\n\nvector< pair< pii , int > > v;\n\nll L(ll x,ll y) { FOR(i,x+1,h) y *= 2; return y; } \nll R(ll x, ll y) { FOR(i,x+1,h) y = y * 2 + 1; return y; }\n\nmultiset< pair< ll , ll > > S;\n\nmultiset< pair< ll , ll > > :: iterator it, it2;\n\nvoid add(int x,int y,int l,int r) {\n    if(l <= x && y <= r) return ;\n    if(x > r || y < l) { S.insert(mp(x,y)); return ; } \n    if(x < l) S.insert(mp(x,l-1));\n    if(y > r) S.insert(mp(r+1,y));\n}\n\nvoid rem(int x,int y) {\n    it = S.lower_bound(mp(x,0)); \n    if(it != S.begin()) it--;\n    for(;it != S.end() && it->st <= y;){\n        it2 = it; it2++;\n        add(it->st,it->nd,x,y);\n        S.erase(it);it = it2;       \n    }    \n}\n\n main() {\n       \n   scanf(\"%lld %lld\",&h,&q);\n   \n   hh[1LL<<h-1LL] = 1; hh[(1ll << h) - 1] = 1;\n   hh[(1LL<<h-1LL)-1] = 1; hh[(1ll << h)] = 1;\n   \n   S.insert(mp(1ll<<h-1,(1ll<<h)-1));\n   \n   \n   FOR(i,1,q) {\n       \n       scanf(\"%lld %lld %lld %lld\",&x,&y,&z,&t);\n       ll l = L(x,y);\n       ll r = R(x,z);\n       \n      if(t == 0) rem(l,r);\n      else rem(0,l-1), rem(r+1,1ll<<h);\n       \n   }\n   \n   if(!S.size()) cout << \"Game cheated!\" << endl;\n   else if(S.size() != 1 || S.begin()->st != S.begin()->nd) { cout << \"Data not sufficient!\\n\"; }\n   else cout << S.begin()->st << endl;\n    \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Guess Your Way Out  II.json",
    "editorial_link": "https://codeforces.com//blog/entry/19212",
    "editorial": "First, each query in the level from to can be transmitted into level\r\nfrom to , so, we can transform each query to the last level. Letâs\r\nmaintain a set of correct ranges such that the answer is contained in\r\none of them. At the beginning we will assume that the answer is in the\r\nrange inclusive. Now Letâs process the queries. If the queryâs answer is\r\nyes, then we want to get the intersection of this queryâs range with the\r\ncurrent set of correct ranges, and update the set with the resulting\r\nset. If the queryâs answer is no, we want to exclude the queryâs range\r\nfrom the current set of correct ranges, and update the set with the\r\nresulting set. After we finish processing the queries, if the set of\r\ncorrect ranges is empty, then clearly the game cheated. Else if the set\r\nhas only one correct range such that then weâve got an answer. Otherwise\r\nthere are multiple exit candidates and the answer canât be determined\r\nuniquely using the current data. We will have to use stl::set data\r\nstructure to make updating the ranges faster. In each yes query we\r\ndelete zero or more ranges. In each no query we may add one range if we\r\nsplit a correct range, so worst case will be linear in queries count.\r\nTime complexity: Implementation\r\n",
    "hint": []
}