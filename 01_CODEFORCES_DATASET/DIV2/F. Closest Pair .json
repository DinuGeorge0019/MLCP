{
    "link": "https://codeforces.com//contest/1635/problem/F",
    "problemId": "1304252",
    "problem_idx": "F",
    "shortId": "1635F",
    "contest_number": "1635",
    "problem_submissions": {
        "F": [
            147074799,
            147095752,
            147102178,
            147104275
        ],
        "E": [
            147062187,
            147069534,
            147070601,
            147071820,
            147072661,
            147071018,
            147073981,
            147068936,
            147074142,
            147080760,
            147076462,
            147075385,
            147083209,
            147071491,
            147078900,
            147071624,
            147081688,
            147079690,
            147084319
        ],
        "D": [
            147053217,
            147052386,
            147056630,
            147057231,
            147060557,
            147060631,
            147061935,
            147063792,
            147060134,
            147103502,
            147102937,
            147062678,
            147065535,
            147062609,
            147060941,
            147064885,
            147067705,
            147078835,
            147068792,
            147065392,
            147061320
        ],
        "C": [
            147045170,
            147044912,
            147046365,
            147045126,
            147049650,
            147049621,
            147048160,
            147047404,
            147047609,
            147047366,
            147047254,
            147054268,
            147048212,
            147053384,
            147048532,
            147046997,
            147047963,
            147049441,
            147044930
        ],
        "B": [
            147039520,
            147040113,
            147040251,
            147041870,
            147044628,
            147040558,
            147042641,
            147039735,
            147042175,
            147042000,
            147041459,
            147043659,
            147041936,
            147043726,
            147040154,
            147042155,
            147041291,
            147040938,
            147041038
        ],
        "A": [
            147036699,
            147037179,
            147036802,
            147037015,
            147036879,
            147036847,
            147037144,
            147036925,
            147036758,
            147037118,
            147036774,
            147037869,
            147036975,
            147036790,
            147036876,
            147036819,
            147036907,
            147037053,
            147036783
        ]
    },
    "name": "F. Closest Pair ",
    "statement": "There are n weighted points on the OX-axis. The coordinate and the\r\nweight of the i-th point is x_i and w_i, respectively. All points have\r\ndistinct coordinates and positive weights. Also, x_i < x_{i + 1} holds\r\nfor any 1\r\nleq i < n. The weighted distance between i-th point and j-th point is\r\ndefined as |x_i - x_j|\r\ncdot (w_i + w_j), where |val| denotes the absolute value of val.You\r\nshould answer q queries, where the i-th query asks the following: Find\r\nthe weighted distance among all pairs of distinct points among the\r\npoints in subarray [l_i,r_i].\r\n",
    "solutions": [
        "// Problem: F. Closest Pair \n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/F\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nint ans[1200003];\nvoid update(int l,int r,int x,int id,int val)\n{\n\tif(l==r) \n\t{\n\t\tans[id]=min(ans[id],val);\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid) update(l,mid,x,id<<1,val);\n\telse update(mid+1,r,x,(id<<1)+1,val);\n\tans[id]=min(ans[(id<<1)],ans[(id<<1)+1]);\n\treturn ;\n}\nint query(int l,int r,int L,int R,int id)\n{\n\tif(L<=l && r<=R) return ans[id];\n\tint mid=(l+r)>>1;\n\tint res=0x3f3f3f3f3f3f3f3f;\n\tif(L<=mid) res=min(res,query(l,mid,L,R,id<<1));\n\tif(R>=mid+1) res=min(res,query(mid+1,r,L,R,(id<<1)+1));\n\treturn res;\n}\nstruct node\n{\n\tint l,id;\n};\nvector<node> e[300003];\nint Ans[300003],a[300003],w[300003];\nsigned main()\n{\n\tmemset(ans,0x3f,sizeof(ans));\n\tint n=read(),m=read();\n\tfor(int i=1; i<=n; ++i) a[i]=read(),w[i]=read();\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\tint l=read(),r=read();\n\t\te[r].push_back((node){l,i});\n\t}\n\tstack<int> stk;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\twhile(!stk.empty())\n\t\t{\n\t\t\tint A=stk.top();\n\t\t\tupdate(1,n,A,1,(a[i]-a[A])*(w[i]+w[A]));\n\t\t\tif(w[A]>w[i])//i\u66f4\u4f18\n\t\t\t\tstk.pop();\n\t\t\telse break;\n\t\t}\n\t\tstk.push(i);\n\t\tfor(node j:e[i])\n\t\t\tAns[j.id]=query(1,n,j.l,i,1);\n\t}\n\tfor(int i=1; i<=m; ++i) printf(\"%lld\\n\",Ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Closest Pair .json",
    "editorial_link": "https://codeforces.com//blog/entry/100153",
    "editorial": "First of all, let\u00e2\u0080\u0099s solve the problem for the whole array.Define as the\r\nbiggest satisfying and , and as the smallest satisfying and . Then, we\r\nconsider pairs of points: and for each . In conclusion, the closest pair\r\n(the pair with the minimum weighted distance) must be among them.Proof:\r\nAssume that is the closest pair and . If holds, then must holds,\r\notherwise would obviously be a better pair.Similarly, if holds, then\r\nmust holds, otherwise would obviously be a better pair.The lemma above\r\nalso applies to range queries by the exact same proof. So now, we first\r\nneed to find and for each , this could be simply done with a stack.\r\nThen, imagine we draw lines between the endpoints of each pair, and the\r\nproblem could be reduced to: given weighted segments, for each query\r\nfind the one with the minimum weight that is totally covered by . This\r\nis actually a classic problem, which could be solved by sweep line\r\ntrick + any data structure able to maintain prefix-minimum with single\r\npoint updates, like BIT or segment tree.Total Complexity: .\r\n"
}