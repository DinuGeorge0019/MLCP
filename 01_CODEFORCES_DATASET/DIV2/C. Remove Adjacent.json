{"link": "https://codeforces.com//contest/1321/problem/C", "problemId": "551762", "problem_idx": "C", "shortId": "1321C", "contest_number": "1321", "problem_submissions": {"F": [72202118, 72198416], "C": [72190499, 72170310, 72171527, 72174502, 72175483, 72175401, 72175000, 72176189, 72171238, 72175883, 72177727, 72183189, 72179214, 72177328, 72279003, 72174053, 72178214, 72178070, 72179504, 72179152, 72178320], "D": [72183268, 72175184, 72177797, 72179168, 72180779, 72181426, 72180644, 72182068, 72185885, 72181701, 72186041, 72179938, 72186063, 72181326, 72178168, 72183258, 72185462, 72184740, 72187220, 72184221], "E": [72180529, 72186287, 72184508, 72188609, 72188377, 72190998, 72191625, 72192736, 72180513, 72191278, 72214882, 72192856, 72193973, 72192866, 72196349, 72194892, 72194887, 72194595, 72195594, 72195787], "A": [72173172, 72167016, 72167934, 72167935, 72169001, 72167363, 72167505, 72167646, 72189321, 72167844, 72168400, 72167413, 72168727, 72167365, 72278985, 72168080, 72169683, 72169011, 72168321, 72167972, 72167569], "B": [72168656, 72168025, 72169238, 72170413, 72171089, 72169057, 72169880, 72170679, 72187620, 72171095, 72171827, 72169625, 72172515, 72169721, 72170650, 72172323, 72173484, 72170425, 72174186, 72171595]}, "name": "C. Remove Adjacent", "statement": "You are given a string s consisting of lowercase Latin letters. Let the\r\nlength of s be |s|. You may perform several operations on this string.In\r\none operation, you can choose some index i and the i-th character of s\r\n(s_i) if of its adjacent characters is the letter in the Latin alphabet\r\nfor s_i. For example, the letter for is , the letter for is , the letter\r\nhas no letters. Note that after each removal the length of the string\r\ndecreases by one. So, the index i should satisfy the condition 1\r\nle i\r\nle |s| during each operation.For the character s_i adjacent characters\r\nare s_{i-1} and s_{i+1}. The first and the last characters of s both\r\nhave only one adjacent character (unless |s| = 1).Consider the following\r\nexample. Let s= . During the first move, you can remove the first\r\ncharacter s_1= because s_2= . Then the string becomes s= . During the\r\nsecond move, you can remove the fifth character s_5= because s_4= . Then\r\nthe string becomes s= . During the third move, you can remove the sixth\r\ncharacter s_6=\u201d because s_5= . Then the string becomes s= . During the\r\nfourth move, the only character you can remove is s_4= , because s_3=\r\n(or s_5= ). The string becomes s= and you cannot do anything with it.\r\nYour task is to find the maximum possible number of characters you can\r\nremove if you choose the sequence of operations optimally.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r){return l+rng()%(r-l+1);}\n#define fasty ios_base::sync_with_stdio(0),cin.tie(0);\n#define forinc(a,b,c) for(int a=b,_c=c;a<=_c;++a)\n#define fordec(a,b,c) for(int a=b,_c=c;a>=_c;--a)\n#define forv(a,b) for(auto&a:b)\n#define fi first\n#define se second\n#define pb push_back\n#define ii pair<int,int>\n#define mt make_tuple\n#define all(a) a.begin(),a.end()\n#define reset(f, x) memset(f, x, sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define on(x,i) (x|(1ll<<(i-1)))\n#define off(x,i) (x&~(1<<(i-1)))\n#define gg exit(0);\n\nmain(){\n    #define task \"TASK\"\n    //freopen(task\".inp\",\"r\",stdin);\n    //freopen(task\".out\",\"w\",stdout);\n    fasty;\n\n    int n; cin>>n;\n    vector<ii> a;\n    forinc(i,1,n){\n        char ch; cin>>ch;\n        a.pb({ch-'a',0});\n    }\n    int okay=0;\n    for(;;){\n        int best=0,j=-1;\n        forinc(i,0,a.size()-1){\n            if(!a[i].se && best<a[i].fi)\n                best=a[i].fi, j=i;\n        }\n        if(j<0)\n            break;\n        if(j && a[j-1].fi+1==a[j].fi || j+1<a.size() && a[j+1].fi+1==a[j].fi){\n            a.erase(a.begin()+j);\n            forv(t,a)\n                t.se=0;\n        }\n        else\n            a[j].se=1;\n\n    }\n    cout<<n-a.size();\n}\n\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "greedy", "strings"], "dificulty": "1600", "interactive": false}