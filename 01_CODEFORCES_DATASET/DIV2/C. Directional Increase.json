{
    "link": "https://codeforces.com//contest/1694/problem/C",
    "problemId": "1430896",
    "problem_idx": "C",
    "shortId": "1694C",
    "contest_number": "1694",
    "problem_submissions": {
        "E": [
            160856186,
            160866174,
            160873008,
            160869335,
            160868951,
            160877330,
            160898676,
            160877174,
            160875442,
            160876502,
            160879470,
            160875237,
            160876355,
            160882396,
            160879879,
            160879629,
            160876481,
            160881373,
            160884964,
            160881275
        ],
        "D": [
            160848272,
            160842517,
            160849905,
            160853063,
            160857057,
            160853921,
            160854624,
            160847127,
            160845187,
            160855341,
            160850688,
            160860686,
            160857001,
            160853657,
            160862452,
            160862852,
            160864038,
            160855376,
            160858063
        ],
        "C": [
            160836570,
            160829494,
            160839678,
            160844593,
            160847177,
            160836731,
            160843728,
            160843693,
            160838092,
            160845965,
            160845179,
            160854286,
            160843446,
            160844276,
            160856430,
            160857207,
            160844960,
            160846963,
            160849978
        ],
        "B": [
            160832238,
            160835941,
            160831844,
            160834416,
            160835663,
            160829339,
            160834030,
            160840102,
            160851072,
            160836730,
            160864814,
            160845534,
            160830377,
            160835010,
            160833897,
            160845509,
            160927414,
            160837907,
            160860824,
            160841779
        ],
        "A": [
            160832046,
            160833611,
            160826245,
            160824355,
            160825264,
            160825514,
            160825648,
            160826360,
            160852110,
            160825530,
            160855429,
            160829525,
            160824626,
            160825478,
            160825695,
            160824627,
            160922182,
            160921765,
            160830254,
            160825318,
            160825557
        ],
        "F": [
            160914915
        ]
    },
    "name": "C. Directional Increase",
    "statement": "We have an array of length n. Initially, each element is equal to 0 and\r\nthere is a pointer located on the first element.We can do the following\r\ntwo kinds of operations any number of times (possibly zero) in any\r\norder: If the pointer is not on the last element, increase the element\r\nthe pointer is currently on by 1. Then move it to the next element. If\r\nthe pointer is not on the first element, decrease the element the\r\npointer is currently on by 1. Then move it to the previous element.But\r\nthere is one additional rule. You are given an array a. Determine\r\nwhether it\u2019s possible to obtain a after some operations or not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\ntemplate <typename Fun>\nstruct y_combinator {\n    const Fun fun;\n\n    explicit y_combinator(const Fun&& fun) : fun(std::forward<const Fun>(fun)) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) const {\n        return fun(std::ref(*this), std::forward<Args>(args)...);\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int nw = 0;\n    bool ch = true;\n    int pos = n;\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nw > a[i]) {\n            ch = false;\n            break;\n        } else if (nw == a[i]) {\n            pos = i;\n            nw = 0;\n            break;\n        }\n        nw = -(a[i] - nw);\n    }\n    for (int j = pos + 1; j < n; ++j) {\n        if (a[j] != 0) {\n            ch = false;\n            break;\n        }\n    }\n    if (!ch || nw != a[n - 1]) {\n        cout << \"No\\n\";\n    } else {\n        cout << \"Yes\\n\";\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Directional Increase.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "First of all the sum of the elements has to be 0\n because the pointer has to end up on the first element.\n\nDenote the number of times you do the first operation while the pointer is on the i\n-th element as bi\n. And the number of times you do the second operation while the pointer is on the i\n-th element as ci\n.\n\nai=bi?ci\n and ci=bi?1\n because the pointer has to end up on the first element.\n\nSo ai=bi?bi?1?bi=ai+bi?1\n and b1=a1\n.\n\nNow that we have calculated b\n, we need to determine whether it's possible to perform the operations like so.\n\nThere are two conditions.\n\nbi?0\n (1?i?n\n).\nIf bi=0\n for each j\n, i<j\n, bj=0\n. Because the pointer couldn't reach the j\n-th element.\nYou can always construct a\n if these two conditions hold.\n\nProof by induction. Perform the first operation and the second operation b1?1\n times in a row. Then perform the first operation. Construct the rest by induction and then perform the second operation.\n\nTime complexity: O(n)"
}