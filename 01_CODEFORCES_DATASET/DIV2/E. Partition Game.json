{
    "link": "https://codeforces.com//contest/1527/problem/E",
    "problemId": "990898",
    "problem_idx": "E",
    "shortId": "1527E",
    "contest_number": "1527",
    "problem_submissions": {
        "D": [
            116815110,
            116809404,
            116791032,
            116828575,
            116792418,
            116804682,
            116790154,
            116835794,
            116845531,
            116905646,
            116813710,
            116859388,
            117355591,
            116924969,
            116847643
        ],
        "E": [
            116803777,
            116781667,
            116811124,
            116796120,
            116809821,
            116778009,
            116805495,
            116805635,
            116810211,
            116816164,
            116795407,
            116798117,
            116858484,
            116831292,
            116785094,
            123210634,
            116826695,
            116821286,
            116806456,
            116822934,
            116825433
        ],
        "B2": [
            116779583,
            116824497,
            116839392,
            116808334,
            116863718,
            116773876,
            116814004,
            116802164,
            116826569,
            116803739,
            116800671,
            116833299,
            116836369,
            116807478
        ],
        "C": [
            116768817,
            116763349,
            116757962,
            116777964,
            116765975,
            116809173,
            116768519,
            116774311,
            116777675,
            116761218,
            116817305,
            116773251,
            116794638,
            116759497,
            116781691,
            116771054,
            116772322,
            116802912
        ],
        "B1": [
            116758740,
            116815267,
            116826483,
            116782539,
            116761604,
            116831651,
            116786152,
            116771964,
            116779790,
            116822211,
            116765970,
            116802975,
            116804039,
            116787374,
            116833209,
            116785198,
            116777321
        ],
        "A": [
            116752292,
            116752502,
            116752724,
            116753777,
            116753108,
            116820306,
            116752554,
            116757169,
            116752471,
            116755373,
            116825258,
            116752544,
            116831071,
            116753774,
            116752394,
            116754330,
            116756044,
            116754569
        ]
    },
    "name": "E. Partition Game",
    "statement": "You are given an array a of n integers. Define the cost of some array t\r\nas follows:cost(t) =\r\nsum_{x\r\nin set(t) } last(x) - first(x), where set(t) is the set of all values in\r\nt without repetitions, first(x), and last(x) are the indices of the\r\nfirst and last occurrence of x in t, respectively. In other words, we\r\ncompute the distance between the first and last occurrences for each\r\ndistinct element and sum them up.You need to split the array a into k\r\nconsecutive segments such that each element of a belongs to exactly one\r\nsegment and the sum of the cost of individual segments is minimum.\r\n",
    "solutions": [
        "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC optimize(\"fast-math\")\n//#pragma GCC target(\"avx2\")\n// if avx2 not supported, use this instead\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n// something\n//#pragma GCC optimize(\"O3\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n//#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n//#pragma GCC target(\"avx\")  //Enable AVX\n\n#include <bits/stdc++.h>\n#ifdef ONPC\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n#define all(x) (x).begin(), (x).end()\n#define fr first\n#define sc second\n#define m_p make_pair\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define low_bo(a, x) ((int)(lower_bound(a.begin(), a.end(), x) - a.begin()))\n#define up_bo(a, x) ((int)(upper_bound(a.begin(), a.end(), x) - a.begin()))\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define popcnt(x) __builtin_popcount(x)\n#define shuffle(a) shuffle(a.begin(), a.end(), rnd)\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nusing namespace std;\n\n/*\nconst int MEMSIZE = 1e9;\nchar memory[MEMSIZE];\nint memorypos;\ninline void * operator new(size_t n){\n    if (memorypos + n >= MEMSIZE)\n        memorypos = MEMSIZE / 3;\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\ninline void operator delete(void *){}\n*/\n\nusing ll = long long;\n\n#ifndef ONPC\n#define cerr cerr_maksim\nstruct Cerr : public ostream {\n    template<typename T>\n    Cerr& operator<<(T const&) {\n        return *this;\n    }\n} cerr;\n#endif\n\n#ifdef ONPC\nmt19937 rnd(223);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n\ntemplate<typename T>\nvoid setmin(T &x, T y) {\n    x = min(x, y);\n}\n\ntemplate<typename T>\nvoid setmax(T &x, T y) {\n    x = max(x, y);\n}\n\nnamespace Ment {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n\n    template<typename T>\n    class Modular {\n    public:\n        using Type = typename decay<decltype(T::value)>::type;\n\n        constexpr Modular() : value() {}\n\n        template<typename U>\n        Modular(const U &x) {\n            value = normalize(x);\n        }\n\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n\n        const Type &operator()() const { return value; }\n\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n\n        constexpr static Type mod() { return T::value; }\n\n        Modular &operator+=(const Modular &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n\n        Modular &operator-=(const Modular &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n\n        template<typename U>\n        Modular &operator+=(const U &other) { return *this += Modular(other); }\n\n        template<typename U>\n        Modular &operator-=(const U &other) { return *this -= Modular(other); }\n\n        Modular &operator++() { return *this += 1; }\n\n        Modular &operator--() { return *this -= 1; }\n\n        Modular operator++(int) {\n            Modular result(*this);\n            *this += 1;\n            return result;\n        }\n\n        Modular operator--(int) {\n            Modular result(*this);\n            *this -= 1;\n            return result;\n        }\n\n        Modular operator-() const { return Modular(-value); }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n#ifdef _WIN32\n            uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n            uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n            asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n            );\n            value = m;\n#else\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n\n        Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n        template<typename U>\n        friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\n    private:\n        Type value;\n    };\n\n    template<typename T>\n    bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\n\n    template<typename T, typename U>\n    bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\n\n    template<typename T, typename U>\n    bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\n    template<typename T>\n    bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T>\n    bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\n    template<typename T>\n    Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T>\n    Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T>\n    Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T>\n    Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> power(const Modular<T> &a, const U &b) {\n        assert(b >= 0);\n        Modular<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    string to_string(const Modular<T> &number) {\n        return to_string(number());\n    }\n\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n        return stream << number();\n    }\n\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n        typename common_type<typename Modular<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = Modular<T>::normalize(x);\n        return stream;\n    }\n\n    constexpr int md = 1e9 + 7;\n    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n}\nusing Ment::Mint;\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\n#define TIME (clock() * 1.0 / CLOCKS_PER_SEC)\n\n// WARNING!!!!!!\n// Maksim reads solution\n// be careful!!!!\n\n// solution starts here\n\nusing ld = double;\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 1e5 + 100, maxw = (1 << 20) + 5, inf = 1e9 + 100;\nstruct Val {\n    ll v;\n    Val() : v(0) {}\n    Val(ll x) : v(x) {}\n\n    friend Val operator+(Val a, Val b);\n\n    Val& operator+=(Val a) {\n        return *this = *this + a;\n    }\n};\n\nVal operator+(Val a, Val b) {\n    return Val(a.v + b.v);\n}\n\nbool operator==(Val a, Val b) {\n    return a.v == b.v;\n}\n\nbool operator!=(Val a, Val b) {\n    return !(a == b);\n}\n\nstruct Segtree {\n\n    static Val calc(Val a, Val b) {\n        return min(a.v, b.v);\n    }\n\n    Val q[4 * maxn], up[4 * maxn];\n    int n;\n\n    void build(int v, int l, int r, vector<ll> &who) {\n        up[v] = 0;\n        if (l == r) {\n            q[v] = who[l];\n            return;\n        }\n        int m = (l + r) / 2;\n        build(2 * v, l, m, who);\n        build(2 * v + 1, m + 1, r, who);\n        q[v] = calc(q[2 * v], q[2 * v + 1]);\n    }\n    void build(int n_, vector<ll> &who) {\n        n = n_;\n        build(1, 0, n - 1, who);\n    }\n\n    void push(int v, int l, int r) {\n        if (up[v] != Val(0)) {\n            q[v] += up[v];\n            if (l != r) {\n                up[2 * v] += up[v];\n                up[2 * v + 1] += up[v];\n            }\n            up[v] = 0;\n        }\n    }\n\n    void update(int v, int tl, int tr, int l, int r, Val w) {\n        push(v, tl, tr);\n        if (l > r)\n            return;\n        if (tl == l && tr == r) {\n            up[v] += w;\n            push(v, tl, tr);\n            return;\n        }\n        int m = (tl + tr) / 2;\n        update(2 * v, tl, m, l, min(r, m), w);\n        update(2 * v + 1, m + 1, tr, max(l, m + 1), r, w);\n        q[v] = calc(q[2 * v], q[2 * v + 1]);\n    }\n\n    void update(int l, int r, ll w) {\n        update(1, 0, n - 1, l, r, w);\n    }\n\n    Val get(int v, int tl, int tr, int l, int r) {\n        push(v, tl, tr);\n        if (l > r)\n            return llinf;\n        if (tl == l && tr == r)\n            return q[v];\n        int m = (tl + tr) / 2;\n        return calc(get(2 * v, tl, m, l, min(r, m)),\n                    get(2 * v + 1, m + 1, tr, max(l, m + 1), r));\n    }\n\n    Val get(int l, int r) {\n        return get(1, 0, n - 1, l, r);\n    }\n\n};\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int &i : a)\n        cin >> i;\n    vector<ll> dp(n + 1);\n#define prev maxim\n    vector<int> nxt(n), prev(n);\n    {\n        map<int, int> go;\n        for (int i = n - 1; i >= 0; i--) {\n            int x = a[i];\n            if (!go.count(x))\n                nxt[i] = n;\n            else\n                nxt[i] = go[x];\n            go[x] = i;\n        }\n        go.clear();\n        for (int i = 0; i < n; i++) {\n            int x = a[i];\n            if (!go.count(x))\n                prev[i] = -1;\n            else\n                prev[i] = go[x];\n            go[x] = i;\n        }\n    }\n    for (int iter = 0; iter < k; iter++) {\n        Segtree q;\n        q.build(n + 1, dp);\n        // (l, r) +w\n        vector<ll> pd(n + 1);\n        for (int i = 0; i <= n; i++) {\n            pd[i] = q.get(0, i - 1).v;\n            if (i < n) {\n                if (prev[i] != -1) {\n                    q.update(0, prev[i], (i - prev[i]));\n                }\n                if (nxt[i] != n) {\n                    q.update(0, i, -(nxt[i] - i));\n                }\n            }\n        }\n        swap(dp, pd);\n        //for (int i = 0; i <= n; i++)\n        //    cerr << dp[i] << ' ';\n        //cerr << '\\n';\n    }\n    ll tot = 0;\n    map<int, int> q;\n    for (int i = 0; i < n; i++) {\n        int x = a[i];\n        if (q.find(x) != q.end()) {\n            tot += i - q[x];\n        }\n        q[x] = i;\n    }\n    cout << tot + dp.back() << '\\n';\n}\n\n// check test counter\n\nint main() {\n#ifdef ONPC\n    freopen(\"../a.in\", \"r\", stdin);\n    freopen(\"../a.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(20);\n    //precalc();\n    if (false) {\n        int te = 0;\n        while (1) {\n            cerr << ++te << '\\n';\n            solve();\n        }\n    }\n    int ts;\n    ts = 1;\n    //cin >> ts;\n    for (int its = 1; its <= ts; its++) {\n        //cerr << \"\\nts \" << its << '\\n';\n        //cout << \"Case #\" << its << \": \";\n        solve();\n    }\n#ifdef ONPC\n    cerr << \"\\n\\nConsumed \" << TIME << '\\n';\n#endif\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Partition Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/90939",
    "editorial": "Letâs use dynamic programming to solve this problem. Consider be the\r\nanswer for prefix with subsegments. Transitions are fairly\r\nstraightforward. Let be the cost of subarray starting at index and\r\nending at index.If we calculate it naively, it would result in solution\r\nwhich would not be enough for given constraints.We need some data\r\nstructure to maintain for every . Consider the example . We can write\r\ncost as . Except for the first occurrence, we just need a sum of in the\r\nrange, where is the index of the last occurrence of just before index .\r\nWe can maintain this in some segment tree. Letâs say our segment tree is\r\nbuilt for prefix , we can transition to prefix by adding in range .This\r\nwill result in a solution.\r\n",
    "hint": []
}