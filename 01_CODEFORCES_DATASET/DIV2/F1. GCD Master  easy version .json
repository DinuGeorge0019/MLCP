{
    "link": "https://codeforces.com//contest/1806/problem/F1",
    "problemId": "1836411",
    "problem_idx": "F1",
    "shortId": "1806F1",
    "contest_number": "1806",
    "problem_submissions": {
        "F2": [
            197973089,
            198042031,
            198041907
        ],
        "F1": [
            197947040,
            197980157,
            198042001,
            198041678
        ],
        "C": [
            197937230,
            197916115,
            197928489,
            197944944,
            197938210,
            197926089,
            197926689,
            197929494,
            197933106,
            197948564,
            197926881,
            197937572,
            197932222,
            197941848,
            199801603,
            197957943,
            197942490,
            197930745,
            197946610,
            197928372,
            197924952
        ],
        "E": [
            197933006,
            197929125,
            197915365,
            197935988,
            197962774,
            197948774,
            197963264,
            197949722,
            197943372,
            197943303,
            197949562,
            197950582,
            197950806,
            240170072,
            197967439,
            199801822,
            199801762,
            197952145,
            197987791,
            197987740,
            197972228,
            201450127,
            197970212,
            197959737,
            197938806,
            197943810
        ],
        "B": [
            197912589,
            197908884,
            197909602,
            197911369,
            197910208,
            197914190,
            197910559,
            197911156,
            197917129,
            197921982,
            197914483,
            197917557,
            197912987,
            197915302,
            197915210,
            197914864,
            197912863,
            197911859,
            197911664,
            197911113
        ],
        "A": [
            197912419,
            197906490,
            197911639,
            197906984,
            197907218,
            197908571,
            197907286,
            197906740,
            197907744,
            197907020,
            197928349,
            197908011,
            197912765,
            197906883,
            197908367,
            197906657,
            197906703,
            197906672,
            197907002,
            197906587
        ],
        "D": [
            197942295,
            197971270,
            197966565,
            197946069,
            197958331,
            197952013,
            197968711,
            197966060,
            197967070,
            197965611,
            197969051,
            197967288,
            197953250,
            199801511,
            197971493,
            197965795,
            197972473,
            197971611,
            198035510,
            198035241
        ]
    },
    "name": "F1. GCD Master  easy version ",
    "statement": "You are given an array a of length n and two integers m and k. Each\r\nelement in a satisfies 1\r\nle a_i\r\nle m.In one operation, you choose two indices i and j such that 1\r\nle i < j\r\nle |a|, then append\r\ngcd(a_i,a_j) to the back of the array and delete a_i and a_j from the\r\narray. Note that the length of the array decreases by one after this\r\noperation.Find the maximum possible sum of the array after performing k\r\noperations.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\nlong long n, x,m,K;\nint k;\nconst long long MAXEL = 1000LL * 1000LL * 1000LL * 1000LL;\nlong long nwd(long long a, long long b)\n{\n    while (a != 0)\n    {\n        b %= a;\n        std::swap(a, b);\n    }\n    return b;\n}\nvoid work()\n{\n    std::cin >> n>>m>>K;\n\tstd::vector<long long> li, result;\n\tstd::vector<std::pair<long long, int>> kro;\n    result.resize(n + 2);\n    for (int i = 0; i < n; i++)\n    {\n        std::cin >> x;\n        li.emplace_back(x);\n    }\n    sort(li.begin(), li.end());\n    int ile = 0;\n    long long last = li.front();\n    for (auto l : li)\n    {\n        if (l == last)\n        {\n            ile++;\n        }\n        else\n        {\n            kro.emplace_back(last, ile);\n            ile = 1;\n            last = l;\n        }\n    }\n    kro.emplace_back(last, ile);\n    long long nw = 0;\n    long long sum = 0;\n    for (auto x : kro)\n        sum += x.first;\n    for (std::size_t i = 0; i < kro.size(); i++)\n    {\n        long long tmp = nwd(nw, kro[i].first);\n        if (tmp != nw)\n        {\n            long long max = -MAXEL;\n            for (std::size_t j = i; j < kro.size(); j++)\n                max = std::max(max, nwd(nw, kro[j].first) - kro[j].first);\n            long long sum2 = sum + max;\n            int ite = 0;\n            int poz = kro.size() - 1;\n            std::vector<long long> str;\n            while (true)\n            {\n                result[kro.size() - i + ite] = std::max(result[kro.size() - i + ite], sum2);\n                result[kro.size() - i + ite + 1] = std::max(result[kro.size() - i + ite + 1], sum2 - max + nw);\n                while (poz >= int(i) && kro[poz].second == 1)\n                    poz--;\n                if (poz < int(i))\n                    break;\n                kro[poz].second--;\n                str.emplace_back(poz);\n                ite++;\n                sum2 += kro[poz].first;\n            }\n            for (auto x : str)\n                kro[x].second++;\n            nw = tmp;\n        }\n        sum -= kro[i].first;\n    }\n    sum = 0;\n    for (auto x : li)\n        sum += x;\n    nw = 0;\n    for (std::size_t i = 0; i < li.size(); i++)\n    {\n\n        long long tmp = nwd(nw, li[i]);\n        sum -= li[i];\n\n        if (tmp != nw)\n        {\n            long long max = -MAXEL;\n            for (std::size_t j = i; j < li.size(); j++)\n                max = std::max(max, nwd(li[i], nw));\n            result[li.size() - i] = std::max(result[li.size() - i], sum + max);\n        }\n        else\n        {\n            result[li.size() - i] = std::max(result[li.size() - i], sum + nw);\n        }\n\n        nw = tmp;\n    }\n\n    // for (int i = 1; i <= n; i++)\n    // {\n        std::cout << result[n-K] << \"\\n\";\n    // }\n}\nsigned main()\n{\n    std::ios_base::sync_with_stdio(0);\n\tint T=1;\n\tstd::cin>>T;\n\twhile (T--)\n\t{\n\t\twork();\n\t}\n}\n\t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. GCD Master  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/114048",
    "editorial": "Hint 1: There is a easy strategy for dealing with repeated elements. Suppose that all elements in a\n are pairwise distinct in the following hints.\n\nHint 2: We will always perform an operation on the minimum element.\n\nHint 3: The best way is to choose k+1\n elements, delete them, and add the gcd of them to the sequence.\n\nHint 4: After sorting the sequence, you may guess that choosing a prefix is optimal. But actually it is wrong. Try fixing the strategy!\n\nSolution for F1:\n\nFirst, suppose that all elements in a\n are pairwise distinct.\n\nThe problem can be rewritten as: Divide the sequence into n?k\n groups to maximize the sum of the gcd of each group. Let Si\n represent the elements of a group.\n\nLemma 1\n: When k>0\n, the group which the minimum element of the original sequence belongs to satisfies |Sa|>1\n.\n\nProof:\n\nIf |Sa|=1\n, we can find a group Sx\n such that |Sx|>1\n. Then replacing the maximum element of Sx\n with the minimum element of the original sequence makes the answer greater.\n\nLet a\n be the minimum of the sequence and b\n be the maximum of Sx\n.\n\nthe original answer is a+gcd(Sx)\n.\nreplacing the maximum element of Sx\n with the minimum element, the answer is b+gcd(Sx?{b}?{a})>b\n.\ngcd(Sx)?maxSx?minSx=b?minSx<b?a\n, so a+gcd(Sx)<a+b?a=b<b+gcd(Sx?{b}?{a})\n. Q.E.D.\n\nTips: When maxSx=minSx\n, gcd(Sx)?maxSx?minSx\n. That's why all elements in a\n need to be pairwise distinct.\n\nLemma 2\n: When k>0\n, there's only one Sx\n such that |Sx|>1\n ?\n\nProof:\n\nLet Sa\n be the group with the minimum element.\n\nReferring to Lemma 1\n, we know |Sa|>1\n. Then we remove all the elements of Sa\n from the sequence, add gcd(Sa)\n to the sequence and subtract |Sa|?1\n from k\n. It's obvious that gcd(Sa)\n is the minimum element of the newly formed sequence. We can continue the process until k=0\n, which tells us that only |Sa|=k+1>1\n. Q.E.D.\n\nWe can enumerate gcd(Sa)\n to solve it in O(n+mlnm)\n so far.\n\nHow about repeated elements?\n\nWe can find that for those repeated elements, the best strategy is to merge them with the same element. In other word, a repeated element x\n only decreases the answer by x\n. So it's independent of the previous part. We just need to enumerate the number of operations we perform for repeated elements.\n\nSolution for F2:\n\nStill suppose that all elements in a\n are pairwise distinct.\n\nSuppose a\n is sorted.\n\nLemma 3\n: When k>0\n, we will choose the first k\n elements, and an element from the remaining elements.\n\nThat is, S={a1,a2,\u0085,ak,ax}\n, where k<x?n\n, is the only group with more than one element.\n\nProof:\n\nSuppose T={a1,a2,\u0085,ap,ac1,ac2,\u0085,act}\n, where p+1<c1<c2<?<ct\n, t?2\n and p+t=k+1\n. Then we can prove that T?={a1,a2,\u0085,ap,ap+1,ac1,ac2,\u0085,act?1}\n is always a better choice.\n\nLet g=gcd(T)\n and g?=gcd(T?)\n. We have act?ap+1>act?act?1?g\n.\n\n?=ans(T?)?ans(T)=act?ap+1+g??g>g?>0\n.\n\nSo repeating the process, finally we will know that S={a1,a2,\u0085,ak,ax}\n, where k<x?n\n. Q.E.D.\n\nWhen there're repeated elements, we need to calculate the answer for k\n prefixes. Note that there're only O(logm)\n different prefix gcd. So we can do it in O(nlog2m)\n (another O(logm)\n comes from calculating gcd). Let gi\n be the prefix gcd. When finding the best pair, we calculate gcd(gi,aj)\n, which leads to O(nlog2m)\n. gi?gi?1\n, so gcd(gi,aj)=gcd(gi,gcd(gi?1,aj))\n. The gcd is non-increasing so the total complexity is O(nlogm)\n."
}