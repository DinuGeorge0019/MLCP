{"link": "https://codeforces.com//contest/1806/problem/F1", "problemId": "1836411", "problem_idx": "F1", "shortId": "1806F1", "contest_number": "1806", "problem_submissions": {"F2": [197973089, 198042031, 198041907], "F1": [197947040, 197980157, 198042001, 198041678], "C": [197937230, 197916115, 197928489, 197944944, 197938210, 197926089, 197926689, 197929494, 197933106, 197948564, 197926881, 197937572, 197932222, 197941848, 199801603, 197957943, 197942490, 197930745, 197946610, 197928372, 197924952], "E": [197933006, 197929125, 197915365, 197935988, 197962774, 197948774, 197963264, 197949722, 197943372, 197943303, 197949562, 197950582, 197950806, 240170072, 197967439, 199801822, 199801762, 197952145, 197987791, 197987740, 197972228, 201450127, 197970212, 197959737, 197938806, 197943810], "B": [197912589, 197908884, 197909602, 197911369, 197910208, 197914190, 197910559, 197911156, 197917129, 197921982, 197914483, 197917557, 197912987, 197915302, 197915210, 197914864, 197912863, 197911859, 197911664, 197911113], "A": [197912419, 197906490, 197911639, 197906984, 197907218, 197908571, 197907286, 197906740, 197907744, 197907020, 197928349, 197908011, 197912765, 197906883, 197908367, 197906657, 197906703, 197906672, 197907002, 197906587], "D": [197942295, 197971270, 197966565, 197946069, 197958331, 197952013, 197968711, 197966060, 197967070, 197965611, 197969051, 197967288, 197953250, 199801511, 197971493, 197965795, 197972473, 197971611, 198035510, 198035241]}, "name": "F1. GCD Master  easy version ", "statement": "You are given an array a of length n and two integers m and k. Each\r\nelement in a satisfies 1\r\nle a_i\r\nle m.In one operation, you choose two indices i and j such that 1\r\nle i < j\r\nle |a|, then append\r\ngcd(a_i,a_j) to the back of the array and delete a_i and a_j from the\r\narray. Note that the length of the array decreases by one after this\r\noperation.Find the maximum possible sum of the array after performing k\r\noperations.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <algorithm>\nlong long n, x,m,K;\nint k;\nconst long long MAXEL = 1000LL * 1000LL * 1000LL * 1000LL;\nlong long nwd(long long a, long long b)\n{\n    while (a != 0)\n    {\n        b %= a;\n        std::swap(a, b);\n    }\n    return b;\n}\nvoid work()\n{\n    std::cin >> n>>m>>K;\n\tstd::vector<long long> li, result;\n\tstd::vector<std::pair<long long, int>> kro;\n    result.resize(n + 2);\n    for (int i = 0; i < n; i++)\n    {\n        std::cin >> x;\n        li.emplace_back(x);\n    }\n    sort(li.begin(), li.end());\n    int ile = 0;\n    long long last = li.front();\n    for (auto l : li)\n    {\n        if (l == last)\n        {\n            ile++;\n        }\n        else\n        {\n            kro.emplace_back(last, ile);\n            ile = 1;\n            last = l;\n        }\n    }\n    kro.emplace_back(last, ile);\n    long long nw = 0;\n    long long sum = 0;\n    for (auto x : kro)\n        sum += x.first;\n    for (std::size_t i = 0; i < kro.size(); i++)\n    {\n        long long tmp = nwd(nw, kro[i].first);\n        if (tmp != nw)\n        {\n            long long max = -MAXEL;\n            for (std::size_t j = i; j < kro.size(); j++)\n                max = std::max(max, nwd(nw, kro[j].first) - kro[j].first);\n            long long sum2 = sum + max;\n            int ite = 0;\n            int poz = kro.size() - 1;\n            std::vector<long long> str;\n            while (true)\n            {\n                result[kro.size() - i + ite] = std::max(result[kro.size() - i + ite], sum2);\n                result[kro.size() - i + ite + 1] = std::max(result[kro.size() - i + ite + 1], sum2 - max + nw);\n                while (poz >= int(i) && kro[poz].second == 1)\n                    poz--;\n                if (poz < int(i))\n                    break;\n                kro[poz].second--;\n                str.emplace_back(poz);\n                ite++;\n                sum2 += kro[poz].first;\n            }\n            for (auto x : str)\n                kro[x].second++;\n            nw = tmp;\n        }\n        sum -= kro[i].first;\n    }\n    sum = 0;\n    for (auto x : li)\n        sum += x;\n    nw = 0;\n    for (std::size_t i = 0; i < li.size(); i++)\n    {\n\n        long long tmp = nwd(nw, li[i]);\n        sum -= li[i];\n\n        if (tmp != nw)\n        {\n            long long max = -MAXEL;\n            for (std::size_t j = i; j < li.size(); j++)\n                max = std::max(max, nwd(li[i], nw));\n            result[li.size() - i] = std::max(result[li.size() - i], sum + max);\n        }\n        else\n        {\n            result[li.size() - i] = std::max(result[li.size() - i], sum + nw);\n        }\n\n        nw = tmp;\n    }\n\n    // for (int i = 1; i <= n; i++)\n    // {\n        std::cout << result[n-K] << \"\\n\";\n    // }\n}\nsigned main()\n{\n    std::ios_base::sync_with_stdio(0);\n\tint T=1;\n\tstd::cin>>T;\n\twhile (T--)\n\t{\n\t\twork();\n\t}\n}\n\t"], "input": "", "output": "", "tags": ["greedy", "math", "number theory", "sortings"], "dificulty": "2900", "interactive": false}