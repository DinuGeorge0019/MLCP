{
    "link": "https://codeforces.com//contest/1185/problem/G2",
    "problemId": "360328",
    "problem_idx": "G2",
    "shortId": "1185G2",
    "contest_number": "1185",
    "problem_submissions": {
        "G2": [
            55788875,
            55790981,
            55805220,
            55805211,
            55805181,
            55805110,
            55805072,
            55792804,
            55790893,
            55798346,
            55839723
        ],
        "F": [
            55780405,
            55784226,
            55779797,
            55790435,
            55783948,
            55774453,
            55775306,
            55787301,
            55787239,
            55780510,
            55776902,
            55778347,
            55775969,
            55787695,
            55787943,
            55780581,
            55779230,
            55782760,
            55786882,
            55789076
        ],
        "G1": [
            55775590,
            55777444,
            55773026,
            55772290,
            55770464,
            55777149,
            55766017,
            55779783,
            55780697,
            55775163,
            55781086,
            55781273,
            55783475,
            55770087,
            55781658,
            55783057,
            55787570,
            55776249,
            55782788,
            55780634
        ],
        "E": [
            55773709,
            55771675,
            55770836,
            55777430,
            55780309,
            55781282,
            55788835,
            55774037,
            55773565,
            55789637,
            55786175,
            55787728,
            55781452,
            55776381,
            55777447,
            55775569,
            55774578,
            55788543,
            55772414,
            55777859
        ],
        "D": [
            55764805,
            55765160,
            55763333,
            55764561,
            55767970,
            55767077,
            55763517,
            55765643,
            55766955,
            55766963,
            55766612,
            55765495,
            55757519,
            55767392,
            55769540,
            55767234,
            55769033,
            55770802,
            55765015,
            55772029
        ],
        "C1": [
            55760617,
            55761184,
            55760176,
            55760890,
            55765300,
            55759868,
            55766915,
            55759835,
            55763415,
            55762227,
            55760086,
            55765957,
            55763972,
            55762753,
            55765982,
            55761920,
            55763575,
            55762040,
            55779786,
            55761686
        ],
        "C2": [
            55760448,
            55761127,
            55759974,
            55760758,
            55765213,
            55759811,
            55767080,
            55761513,
            55763197,
            55762148,
            55760260,
            55762050,
            55763657,
            55765005,
            55765960,
            55761757,
            55779613,
            55763567,
            55779964,
            55761855
        ],
        "B": [
            55757432,
            55757400,
            55757118,
            55756714,
            55760856,
            55756979,
            55757746,
            55757494,
            55758775,
            55757209,
            55756807,
            55758385,
            55768633,
            55758969,
            55760948,
            55757700,
            55756899,
            55760037,
            55759228,
            55756676
        ],
        "A": [
            55755278,
            55754991,
            55754916,
            55754981,
            55758172,
            55754952,
            55755176,
            55754923,
            55755064,
            55755117,
            55755166,
            55754951,
            55770975,
            55755955,
            55755304,
            55755094,
            55755216,
            55755238,
            55756678,
            55754929
        ]
    },
    "name": "G2. Playlist for Polycarp  hard version ",
    "statement": "Polycarp loves to listen to music, so he never leaves the player, even\r\non the way home from the university. Polycarp overcomes the distance\r\nfrom the university to the house in exactly T minutes.In the player,\r\nPolycarp stores n songs, each of which is characterized by two\r\nparameters: t_i and g_i, where t_i is the length of the song in minutes\r\n(1\r\nle t_i\r\nle 50), g_i is its genre (1\r\nle g_i\r\nle 3).Polycarp wants to create such a playlist so that he can listen to\r\nmusic all the time on the way from the university to his home, and at\r\nthe time of his arrival home, the playlist is over. Polycarp never\r\ninterrupts songs and always listens to them from beginning to end. Thus,\r\nif he started listening to the i-th song, he would spend exactly t_i\r\nminutes on its listening. Polycarp also does not like when two songs of\r\nthe same genre play in a row (i.e. successively/adjacently) or when the\r\nsongs in his playlist are repeated.Help Polycarpus count the number of\r\ndifferent sequences of songs (their order matters), the total duration\r\nis exactly T, such that there are no two consecutive songs of the same\r\ngenre in them and all the songs in the playlist are different.\r\n",
    "solutions": [
        "///Mn kotr el labawy mb2t4 nawy\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nusing ll = long long;\nint dp[55][55][55][4];\nint solve(int x, int y, int z, int lst){\n  if(x+y+z==0)return 1;\n  int &ret = dp[x][y][z][lst];\n  if(~ret)return ret;\n  ret = 0;\n  if(lst!=0&&x)\n    ret += 1ll * x * solve(x-1,y,z,0) % MOD;\n  if(lst!=1&&y)\n    ret += 1ll * y * solve(x,y-1,z,1) % MOD;\n  if(ret>=MOD)ret-=MOD;\n  if(lst!=2&&z)\n    ret += 1ll * z * solve(x,y,z-1,2) % MOD;\n  if(ret>=MOD)ret-=MOD;\n  return ret;\n}\nvector<pair<int,int>> go[3][55];\nint dp2[55][2505];\nvector<int> v[3];\nvector<pair<pair<int,int>,int>> sE(vector<int> v){\n  memset(dp2,0,sizeof dp2);\n  dp2[0][0] = 1;\n  for(int k = 0; k < v.size(); k++){\n    for(int j = k + 1; j >= 1; --j){\n      for(int val = (k + 1) * 50; val >= v[k]; --val){\n        dp2[j][val] += dp2[j-1][val - v[k]];\n        if(dp2[j][val]>= MOD)dp2[j][val]-=MOD;\n      }\n    }\n  }\n\n  vector<pair<pair<int,int>,int>>ret;\n  for(int k = 0; k <= v.size(); k++){\n    for(int val = 0; val <= 2500; val++)\n      if(dp2[k][val])\n      ret.push_back(make_pair(make_pair(k,val),dp2[k][val]));\n\n  }\n\n  return ret;\n\n}\nint main(){\n//  ios_base::sync_with_stdio(0);cin.tie(0);\n  int n, T;\n  cin >> n >>T;\n\n  for(int k = 0; k <n; k++){\n    int x, y; cin >> x >> y;\n    v[y-1].push_back(x);\n  }\n\n  for(int k = 0; k < 3; k++){\n    auto x = sE(v[k]);\n    for(auto y : x){\n      go[k][y.first.first].push_back(make_pair(y.first.second,y.second));\n    }\n  }\n  memset(dp,-1,sizeof dp);\n  int ans = 0;\n  for(int sz1 = 0; sz1 <= v[0].size(); sz1++)\n    for(int sz2=0; sz2 <= v[1].size(); sz2++)\n      for(int sz3= 0; sz3 <= v[2].size(); sz3++)\n        if(solve(sz1,sz2,sz3,3)){\n//            cout <<sz1 << ' ' << sz2 <<\" \" << sz3 << '\\n';\n          for(auto x : go[0][sz1])\n          for(auto y : go[1][sz2]){\n            if(x.first+y.first>T)break;\n            ans += 1ll * solve(sz1,sz2,sz3,3) * x.second %MOD * y.second % MOD * dp2[sz3][T-x.first-y.first] % MOD;\n            if(ans>=MOD)ans-=MOD;\n          }\n        }\n\n    cout << ans << \"\\n\";\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G2. Playlist for Polycarp  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/67829",
    "editorial": "Consider all genres are from to instead of from to . It will be easier\r\nto deal with 0-based indices.Letâs find two arrays: = number of ways to\r\nchoose a subset of exactly songs of the genre with total duration of\r\nexactly ; = number of ways to choose a subset of exactly songs of the\r\ngenre and songs of the genre with total duration of exactly . You can\r\neasily do it with DP. Here is the sample code to do it while reading the\r\ninput:This part works in with a really small constant factor.Letâs\r\ncalculate the array = number of ways to put zeroes, ones and twos in a\r\nrow (its length is ) in such a way that no two equal values go\r\nconsecutive and the row ends on . You can also use DP to find the\r\nvalues:This part works in with a really small constant factor.And now if\r\nthe final part of the solution. Letâs iterate over all possible ways how\r\nsongs with the genre can be in a playlist. It means that we try all\r\npossible counts of such songs ( in the code below) and their total\r\nduration ( in the code below). Now we know the total time for genres and\r\n, it equals to . Letâs iterate over all possible counts of songs with\r\ngenre= and songs with genre= (say, and ). For fixed , , and there are\r\nways to choose songs, where . To count all possible orders of songs,\r\nletâs multiply on: number of permutations of songs with genre=; number\r\nof permutations of songs with genre=; number of permutations of songs\r\nwith genre=; - number ways to order them in the required way. After all\r\nthe multiplications add the result to the answer.The following code\r\nillustrates this part of the solution:This part works in with a really\r\nsmall constant factor.So the total complexity is (the constant factor is\r\nsignificantly less than ).\r\n",
    "hint": []
}