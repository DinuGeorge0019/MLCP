{
    "link": "https://codeforces.com//contest/558/problem/A",
    "problemId": "31486",
    "problem_idx": "A",
    "shortId": "558A",
    "contest_number": "558",
    "problem_submissions": {
        "D": [
            12060370,
            12056527,
            12059090,
            12059491,
            12059065,
            12054778,
            12056387,
            12055925,
            12063869,
            12072214
        ],
        "C": [
            12053633,
            12055512,
            12048548,
            12064102,
            12052329,
            12052749,
            12048409,
            12055315,
            12050109,
            12052282,
            12069418,
            12069387,
            12050188,
            12050328,
            12050475,
            12050277
        ],
        "B": [
            12048746,
            12050659,
            12043934,
            12044434,
            12044575,
            12045422,
            12043956,
            12057039,
            12045386,
            12043738,
            12048369,
            12046762,
            12054080,
            12044823,
            12046619,
            12044825,
            12045463,
            12046006,
            12046134
        ],
        "A": [
            12047744,
            12049996,
            12057160,
            12043771,
            12049018,
            12043976,
            12045019,
            12057924,
            12043847,
            12045136,
            12045173,
            12044161,
            12052769,
            12050459,
            12044438,
            12043911,
            12044045,
            12043813,
            12044484
        ],
        "E": [
            12046569,
            12048494,
            12053809,
            12056713,
            12054492,
            12054844,
            12048063,
            12064379,
            12046497,
            12054488,
            12050859,
            12055637,
            12056916,
            12071603
        ]
    },
    "name": "A. Lala Land and Apple Trees",
    "statement": "Amr lives in Lala Land. Lala Land is a very beautiful country that is\r\nlocated on a coordinate line. Lala Land is famous with its apple trees\r\ngrowing everywhere.Lala Land has exactly apple trees. Tree number is\r\nlocated in a position and has apples growing on it. Amr wants to collect\r\napples from the apple trees. Amr currently stands in position. At the\r\nbeginning, he can choose whether to go right or left. He’ll continue in\r\nhis direction until he meets an apple tree he didn’t visit before. He’ll\r\ntake all of its apples and then reverse his direction, continue walking\r\nin this direction until he meets another apple tree he didn’t visit\r\nbefore and so on. In the other words, Amr reverses his direction when\r\nvisiting each new apple tree. Amr will stop collecting apples when there\r\nare no more trees he didn’t visit in the direction he is facing.What is\r\nthe maximum number of apples he can collect?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << \" --> \" << (x) << ' '\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl '\\n'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 1e5+5;\n\nint i, j, k, n, m;\n\nint x, y;\n\nvector< pii > l, r;\n\nint main(){\n\n\tcin >> n;\n\n\tFOR(i,1,n) {\n\t\t\n\t\tcin >> x >> y;\n\t\t\n\t\tif(x < 0) l.pb(mp(x,y));\n\t\telse r.pb(mp(x,y));\n\n\t}\n\n\tsort(l.begin(),l.end(),greater< pii > ());\n\n\tsort(r.begin(),r.end());\n\n\tint mn = min(l.size(), r.size());\n\n\tmn--;\n\n\tint ans = 0;\n\n\tFOR(i,0,mn) ans += l[i].nd + r[i].nd;\n\n\tint t = 0;\n\n\tif(l.size() > mn + 1) t = max(t, l[mn + 1].nd);\n\tif(r.size() > mn + 1) t = max(t, r[mn + 1].nd);\n\n\tcout << ans + t << endl;\n\n   return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Lala Land and Apple Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/19212",
    "editorial": "Letâs divide all the trees into two different groups, trees with a\r\npositive position and trees with a negative position. Now There are\r\nmainly two cases: So we can sort each group of trees by the absolute\r\nvalue of the trees position and calculate the answer as mentioned above.\r\nTime complexity: Implementation .\r\n",
    "hint": []
}