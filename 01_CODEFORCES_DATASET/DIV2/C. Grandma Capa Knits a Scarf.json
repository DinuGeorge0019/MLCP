{
    "link": "https://codeforces.com//contest/1582/problem/C",
    "problemId": "1156633",
    "problem_idx": "C",
    "shortId": "1582C",
    "contest_number": "1582",
    "problem_submissions": {
        "G": [
            133300654,
            132904411,
            132903819,
            132921500,
            132938189,
            132915561,
            132904925,
            132893999,
            132930384,
            132930246,
            132930119,
            132929885,
            132929830,
            132917984,
            132923122,
            132922486,
            132909943,
            132922580,
            132929375,
            132930555,
            133312799,
            132969396
        ],
        "F2": [
            132908314,
            132865018,
            132905309,
            132899324,
            132901682,
            132900235,
            132911727,
            132926934,
            132906558,
            132909549,
            132893391,
            132884523,
            132901241,
            132906554,
            132898256,
            133312622,
            132970055,
            132969976,
            132904321
        ],
        "F1": [
            132881252,
            132864382,
            132880627,
            132888291,
            132872964,
            132880051,
            132887180,
            132892561,
            132900410,
            132897751,
            132862757,
            132872739,
            132870584,
            132888250,
            132889092,
            132882038,
            132891013,
            132872187,
            132887941,
            133312616,
            132891504
        ],
        "E": [
            132874913,
            132878099,
            132874176,
            132880923,
            132882227,
            132876672,
            132871740,
            132883982,
            132905776,
            132893914,
            132871055,
            132859358,
            132881562,
            132870144,
            132885086,
            132894857,
            132869674,
            132887914,
            132877059,
            133312375,
            132888626
        ],
        "D": [
            132866716,
            132891541,
            132886280,
            132871648,
            132863103,
            132871610,
            132863993,
            132875189,
            132911684,
            132876113,
            132889182,
            132879862,
            132890109,
            132872530,
            132875475,
            132891337,
            132884986,
            132886500,
            132884112,
            133312126,
            132970973,
            132882901
        ],
        "C": [
            132859265,
            132871828,
            132860284,
            132861165,
            132856817,
            132935747,
            132866931,
            132863031,
            132863018,
            132893464,
            132893294,
            132866549,
            132861428,
            132858872,
            132861957,
            132863927,
            132861005,
            132863860,
            132868896,
            133312107,
            132858386
        ],
        "B": [
            132856790,
            132867123,
            132856747,
            132855505,
            132854485,
            132859085,
            132858770,
            132858595,
            132856173,
            132857637,
            132856186,
            132859468,
            132855951,
            132855099,
            132854810,
            132855351,
            132856357,
            132855765,
            132859435,
            133312040,
            132970544,
            132854847
        ],
        "A": [
            132855030,
            132855528,
            132854523,
            132892082,
            132854129,
            132904251,
            132854758,
            132854419,
            132906994,
            132854763,
            132856077,
            132854737,
            132984138,
            132854196,
            132859118,
            132854306,
            132855186,
            132865041,
            132857131,
            133311808,
            132970350,
            132854128
        ]
    },
    "name": "C. Grandma Capa Knits a Scarf",
    "statement": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make\r\na pattern for it, a pattern is a string consisting of lowercase English\r\nletters. Grandpa Sher wrote a string s of length n.Grandma Capa wants to\r\nknit a beautiful scarf, and in her opinion, a beautiful scarf can only\r\nbe knit from a string that is a palindrome. She wants to change the\r\npattern written by Grandpa Sher, but to avoid offending him, she will\r\nchoose one lowercase English letter and erase some (at her choice,\r\npossibly none or all) occurrences of that letter in string s.She also\r\nwants to minimize the number of erased symbols from the pattern. Please\r\nhelp her and find the minimum number of symbols she can erase to make\r\nstring s a palindrome, or tell her that it\u2019s impossible. Notice that she\r\ncan only erase symbols equal to the letter she chose.A string is a\r\npalindrome if it is the same from the left to the right and from the\r\nright to the left. For example, the strings , , and are palindromes,\r\nwhile the strings and are not.\r\n",
    "solutions": [
        "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"c.in\", \"r\", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring a;\n\t\tcin >> n >> a;\n\t\tint r = n + 1;\n\t\tfor (char c = 'a'; c <= 'z'; ++c) {\n\t\t\tint tot = 0;\n\t\t\tint s = 0;\n\t\t\tint t = n - 1;\n\t\t\twhile (s < t) {\n\t\t\t\tif (a[s] == a[t]) {\n\t\t\t\t\t++s;\n\t\t\t\t\t--t;\n\t\t\t\t}\n\t\t\t\telse if (a[s] == c) {\n\t\t\t\t\t++tot;\n\t\t\t\t\t++s;\n\t\t\t\t}\n\t\t\t\telse if (a[t] == c) {\n\t\t\t\t\t++tot;\n\t\t\t\t\t--t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttot = n + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = min(r, tot);\n\t\t}\n\t\tif (r > n) {\n\t\t\tr = -1;\n\t\t}\n\t\tprintf(\"%d\\n\", r);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "strings",
        "two pointers"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Grandma Capa Knits a Scarf.json",
    "editorial_link": "https://codeforces.com//blog/entry/96267",
    "editorial": "Let\u00e2\u0080\u0099s iterate over the letter that we will erase from the string (from\r\n\u00e2\u0080\u0099a\u00e2\u0080\u0099 to \u00e2\u0080\u0099z\u00e2\u0080\u0099), and for each letter independently find the minimal number\r\nof erased symbols required to make the string a palindrome.Let\u00e2\u0080\u0099s say we\r\nare currently considering a letter . Let\u00e2\u0080\u0099s use the two pointers method:\r\nwe will maintain two pointers , , initially points at the beginning of\r\nthe string, and points at the end of the string. Now we will form a\r\npalindrome: each time we will compare and , if they are equal, then we\r\ncan add both of them to the palindrome at corresponding positions and\r\niterate to symbols and . If , then we need to erase one of these symbols\r\n(otherwise, we won\u00e2\u0080\u0099t get a palindrome), if , let\u00e2\u0080\u0099s erase it (we\u00e2\u0080\u0099ll add\r\nto the number of erased symbols and iterate to -th symbol), similarly,\r\nif , we\u00e2\u0080\u0099ll add to the number of the erased symbols and iterate to -th\r\nsymbol. And the last case, if and , then it\u00e2\u0080\u0099s impossible to get a\r\npalindrome from by erasing only letters equal to .The asymptotic\r\nbehaviour of this solution is , where is the size of the alphabet, i.e.\r\n.\r\n"
}