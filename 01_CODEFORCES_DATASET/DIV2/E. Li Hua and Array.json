{
    "link": "https://codeforces.com//contest/1797/problem/E",
    "problemId": "1868417",
    "problem_idx": "E",
    "shortId": "1797E",
    "contest_number": "1797",
    "problem_submissions": {
        "B": [
            205419034,
            201275977,
            201268460,
            202344188,
            201271807,
            201275386,
            201273112,
            201272415,
            201269513,
            201276897,
            201277640,
            201269175,
            201275166,
            202145333,
            201276000,
            201267831,
            201270551,
            201276485,
            201289099,
            201272649,
            201271253,
            201272124,
            201270606
        ],
        "A": [
            205418993,
            201265764,
            201267671,
            202344137,
            201265725,
            201267108,
            201266341,
            201266676,
            201266049,
            201269061,
            201271927,
            201266144,
            201269858,
            202145345,
            201267522,
            201265871,
            201265945,
            201268294,
            201268304,
            201268572,
            201266365,
            201267763,
            201266314
        ],
        "C": [
            201304931,
            201299785,
            202344275,
            201282998,
            201300736,
            201289854,
            201285491,
            201299725,
            201282788,
            201290162,
            201283371,
            201295706,
            202145313,
            201292638,
            201281179,
            201287038,
            201297132,
            201271589,
            201298508,
            201283505,
            201292123,
            201308055
        ],
        "E": [
            201300187,
            201295260,
            201299598,
            201320286,
            202381158,
            201379930,
            201379655,
            201379250,
            201325544,
            201325138,
            201320528,
            201338561,
            201331085,
            201338593,
            201334166,
            202145221,
            201331849,
            201345570,
            201338770,
            201329752,
            201334417,
            201332873,
            201342334,
            201330509,
            201327922
        ],
        "D": [
            201273188,
            201286495,
            202344347,
            201311226,
            201292800,
            201301138,
            201293532,
            201309768,
            201303093,
            201302579,
            201300376,
            201317473,
            202145285,
            201313643,
            201313719,
            201306889,
            201311824,
            201310494,
            201312575,
            201304976,
            201303632,
            201307784
        ],
        "F": [
            201422339,
            201658184,
            201413786
        ]
    },
    "name": "E. Li Hua and Array",
    "statement": "Li Hua wants to solve a problem about\r\nvarphi Euler\u2019s totient function. Please recall that\r\nvarphi(x)=\r\nsum\r\nlimits_{i=1}^x[\r\ngcd(i,x)=1].^{\r\ndagger,\r\nddagger}He has a sequence a_1,a_2,\r\ncdots,a_n and he wants to perform m operations: \"1 l r\" (1\r\nle l\r\nle r\r\nle n) for x\r\nin[l,r], change a_x into\r\nvarphi(a_x). \"2 l r\" (1\r\nle l\r\nle r\r\nle n) find out the minimum changes needed to make sure a_l=a_{l+1}=\r\ncdots=a_r. In each change, he chooses x\r\nin[l,r], change a_x into\r\nvarphi(a_x). Each operation of this type is independent, which means the\r\narray doesn\u2019t actually change. Suppose you were Li Hua, please solve\r\nthis problem.^\r\ndagger\r\ngcd(x,y) denotes the greatest common divisor (GCD) of integers x and y.\r\n^\r\nddagger The notation [\r\ntextrm{cond}] equals 1 if the condition\r\ntextrm{cond} is true, and 0 otherwise.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int inf = 1e9;\nint n, m, a[100005], phi[5000005], prime[5000005], len = 0;\nbool vis[5000005];\nstruct edge {\n\tint to, nxt;\n} e[5000005];\nint head[5000005], tot = 0, hson[5000005], top[5000005], siz[5000005], dep[5000005], father[5000005];\nint dfn[5000005], timer = 0, to[5000005];\nvoid add(int u, int v) {\n\te[ ++tot ] = (edge){v, head[u]}, head[u] = tot;\n}\nvoid dfs1(int u, int fa) {\n\tfather[u] = fa, dep[u] = dep[fa] + 1, siz[u] = 1, hson[u] = 0;\n\tdfn[u] = ++timer, to[timer] = u;\n\tfor (int i = head[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].to; if (v == fa) continue;\n\t\tdfs1(v, u), siz[u] += siz[v];\n\t\tif (siz[ hson[u] ] < siz[v]) hson[u] = v;\n\t}\n}\nvoid dfs2(int u) {\n\tif (hson[u]) {\n\t\ttop[ hson[u] ] = top[u], dfs2(hson[u]);\n\t}\n\tfor (int i = head[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif (v == father[u] or v == hson[u]) continue;\n\t\ttop[v] = v, dfs2(v);\n\t}\n}\nint lca(int x, int y) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[ top[x] ] < dep[ top[y] ]) swap(x, y);\n\t\tx = father[ top[x] ];\n\t}\n\tif (dep[x] > dep[y]) swap(x, y);\n\treturn x;\n}\nstruct node {\n\tint l, r, Min, Max, sum;\n} tr[400005];\n#define ls (p * 2)\n#define rs (p * 2 + 1)\nvoid pushup(int p) {\n\ttr[p].Min = min(tr[ls].Min, tr[rs].Min);\n\ttr[p].Max = max(tr[ls].Max, tr[rs].Max);\n\ttr[p].sum = tr[ls].sum + tr[rs].sum;\n}\nvoid build(int p, int l, int r) {\n\ttr[p].l = l, tr[p].r = r;\n\tif (l == r) return tr[p].Min = tr[p].Max = dfn[ a[l] ], tr[p].sum = dep[ a[l] ], void();\n\tint mid = (l + r) / 2;\n\tbuild(ls, l, mid), build(rs, mid + 1, r);\n\tpushup(p);\n}\nvoid update(int p, int x, int y) {\n\tif (tr[p].Min == 1 && tr[p].Max == 1) return ;\n\tif (tr[p].l == tr[p].r) {\n\t\ta[ tr[p].l ] = phi[ a[ tr[p].l ] ];\n\t\ttr[p].Min = tr[p].Max = dfn[ a[ tr[p].l ] ];\n\t\ttr[p].sum = dep[ a[ tr[p].l ] ];\n\t\treturn ;\n\t}\n\tif (tr[p].l >= x && tr[p].r <= y) {\n\t\tupdate(ls, x, y), update(rs, x, y);\n\t\treturn pushup(p), void();\n\t}\n\tint mid = (tr[p].l + tr[p].r) / 2;\n\tif (x <= mid) update(ls, x, y);\n\tif (mid < y) update(rs, x, y);\n\tpushup(p);\n}\nint qryMin(int p, int x, int y) {\n\tif (tr[p].l >= x && tr[p].r <= y) return tr[p].Min;\n\tint mid = (tr[p].l + tr[p].r) / 2, ans = inf;\n\tif (x <= mid) ans = min(ans, qryMin(ls, x, y));\n\tif (mid < y) ans = min(ans, qryMin(rs, x, y));\n\treturn ans;\n}\nint qryMax(int p, int x, int y) {\n\tif (tr[p].l >= x && tr[p].r <= y) return tr[p].Max;\n\tint mid = (tr[p].l + tr[p].r) / 2, ans = -inf;\n\tif (x <= mid) ans = max(ans, qryMax(ls, x, y));\n\tif (mid < y) ans = max(ans, qryMax(rs, x, y));\n\treturn ans;\n}\nint qrySum(int p, int x, int y) {\n\tif (tr[p].l >= x && tr[p].r <= y) return tr[p].sum;\n\tint mid = (tr[p].l + tr[p].r) / 2, ans = 0;\n\tif (x <= mid) ans += qrySum(ls, x, y);\n\tif (mid < y) ans += qrySum(rs, x, y);\n\treturn ans;\n}\n#undef ls\n#undef rs\nint main() {\n\tios :: sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\tmemset(vis, true, sizeof vis);\n\tvis[1] = false, phi[1] = 1;\n\tfor (int i = 2; i <= 5e6; ++i) {\n\t\tif (vis[i]) prime[ ++len ] = i, phi[i] = i - 1;\n\t\tfor (int j = 1; j <= len && i * prime[j] <= 5e6; ++j) {\n\t\t\tvis[ i * prime[j] ] = false;\n\t\t\tif (i % prime[j] == 0) {\n\t\t\t\tphi[ i * prime[j] ] = phi[i] * prime[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphi[ i * prime[j] ] = phi[i] * phi[ prime[j] ];\n\t\t}\n\t}\n\tfor (int i = 2; i <= 5e6; ++i) add(phi[i], i);\n\tdfs1(1, 0), top[1] = 1, dfs2(1), build(1, 1, n);\n\twhile (m--) {\n\t\tint opt, l, r; cin >> opt >> l >> r;\n\t\tif (opt == 1) {\n\t\t\tupdate(1, l, r);\n\t\t}\n\t\telse {\n\t\t\tint x = qryMin(1, l, r), y = qryMax(1, l, r);\n\t\t\tint c = lca(to[x], to[y]);\n\t\t\tcout << qrySum(1, l, r) - dep[c] * (r - l + 1) << '\\n';\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dsu",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Li Hua and Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/114890",
    "editorial": "Denote . Also denote .It can be proven that after operations, any will\r\nbecome and more operations are useless. In other words, .Let\u00e2\u0080\u0099s construct\r\na tree of size , where is the root and the father of is . The height of\r\nthe tree is . After some precalculating, we can find the LCA of two\r\nvertices within .We can use a dsu to maintain the next not- element of\r\neach and use a segment tree to maintain the LCA, minimal depth, and\r\nanswer in the range. We can brute force the changes using the dsu and\r\nmeanwhile do point update on the segment tree. The queries can be solved\r\nusing a range query on the segment tree.With the potential method, we\r\ndenote as the minimum integer which satisfies . Since each successful\r\noperation on will decrease by , the maximum number of successful\r\noperations we can perform on is . Therefore, the maximum number of\r\nsuccessful operations is .For each successful operation, we visit nodes\r\non the segment tree and merge the information of two subtrees for times.\r\nBecause of the time complexity of calculating LCA, We need time to merge\r\nthe information. So all the operations will take up time. We need to\r\ninitialize within time and binary lifting the ancestors on the tree\r\nwithin time. We also need for each query.In conclusion, the time\r\ncomplexity is .The above algorithm is enough to pass this problem.\r\nHowever, it has a mass number of information merging operations, so it\r\nruns quite slowly.We use the segment tree not only to maintain the LCA,\r\nminimal depth, and answer of the ranges, but also whether . If we enter\r\na node whose , we can just ignore it. Otherwise, we recursively work on\r\nthe segment tree until leaf and brute force update its information.Time\r\ncomplexity is the same but it\u00e2\u0080\u0099s much more efficient.Bonus: Can you solve\r\nthis problem within ?\r\n"
}