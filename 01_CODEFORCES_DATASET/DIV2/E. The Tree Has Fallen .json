{"link": "https://codeforces.com//contest/1778/problem/E", "problemId": "1760990", "problem_idx": "E", "shortId": "1778E", "contest_number": "1778", "problem_submissions": {"F": [191602138, 191602532, 191585447, 191594114, 191608712, 191599535, 191655210, 191599057, 191639606, 191639396, 194532248, 191803468], "E": [191585870, 191584814, 191630281, 191592729, 191585095, 191596251, 191595141, 191596106, 191592952, 191595620, 191594841, 191592544, 191599842, 192093615, 191596381, 191597065, 191595454], "D": [191578502, 191573421, 191565024, 191574576, 191564042, 191573088, 191575933, 191584703, 191563224, 191573409, 191579570, 191582926, 191579755, 191563101, 191580474, 191576462, 192093593, 191580965, 191580785, 191581424], "C": [191564515, 191569583, 191570422, 191567662, 191567630, 191565698, 191566998, 191565471, 191569851, 191564933, 191565678, 191572047, 191565438, 191575434, 191578186, 191570415, 192093564, 191571887, 191568771, 191569498], "B": [191559138, 191557434, 191555391, 191555255, 191553335, 191555438, 191554286, 191555414, 191559515, 191556063, 191555690, 191562726, 191558781, 191582547, 191561046, 191559475, 192093542, 191562296, 191558152, 191563075], "A": [191546307, 191548742, 191545919, 191546220, 191545819, 191546256, 191546020, 191545963, 191558184, 191545949, 191545987, 191550651, 191554728, 191565464, 191546734, 191548201, 192093519, 191547332, 191546175, 191551024]}, "name": "E. The Tree Has Fallen ", "statement": "Recently, a tree has fallen on Bob\u2019s head from the sky. The tree has n\r\nnodes. Each node u of the tree has an integer number a_u written on it.\r\nBut the tree has no fixed root, as it has fallen from the sky.Bob is\r\ncurrently studying the tree. To add some twist, Alice proposes a game.\r\nFirst, Bob chooses some node r to be the root of the tree. After that,\r\nAlice chooses a node v and tells him. Bob then can pick one or more\r\nnodes from the subtree of v. His score will be the bitwise XOR of all\r\nthe values written on the nodes picked by him. Bob has to find the\r\nmaximum score he can achieve for the given r and v.As Bob is not a good\r\nproblem-solver, he asks you to help him find the answer. Can you help\r\nhim? You need to find the answers for several combinations of r and v\r\nfor the same tree.Recall that a tree is a connected undirected graph\r\nwithout cycles. The subtree of a node u is the set of all nodes y such\r\nthat the simple path from y to the root passes through u. Note that u is\r\nin the subtree of u.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\nconst int N=2e5+5;\nint Bas[N][30],suf[N][30],Out[N][30],ans[N][2];\nint fa[N][20],dep[N],a[N],tmp[30];\nvector<int> G[N];\nint T,n,q,u,v,rt;\nvoid Insert(int* a, int x){\n\tfor (int j=29; ~j; j--)\n\t\tif (x&(1<<j)){\n\t\t\tif (!a[j]){ a[j]=x; break; }\n\t\t\tx^=a[j];\n\t\t}\n}\nint query(int* a){\n\tint ans=0;\n\tfor (int j=29; ~j; j--)\n\t\tif ((ans^a[j])>ans) ans^=a[j];\n\treturn ans;\n}\nvoid dfs(int u, int f){\n\tdep[u]=dep[f]+1; fa[u][0]=f;\n\tfor (int i=1; i<=18; i++) fa[u][i]=fa[fa[u][i-1]][i-1];\n\tvector<int> son;\n\tfor (int v:G[u]){\n\t\tif (v==f) continue;\n\t\tson.push_back(v);\n\t\tdfs(v,u);\n\t\tfor (int i=0; i<30; i++) Out[v][i]=Bas[u][i];\n\t\tfor (int i=0; i<30; i++) Insert(Bas[u],Bas[v][i]);\n\t}\n\tInsert(Bas[u],a[u]); ans[u][0]=query(Bas[u]);\n\tfor (int i=0; i<30; i++) tmp[i]=0;\n\tfor (int i=son.size()-1; ~i; i--){\n\t\tfor (int j=0; j<30; j++) suf[son[i]][j]=tmp[j];\n\t\tfor (int j=0; j<30; j++) Insert(tmp,Bas[son[i]][j]);\n\t}\n}\nvoid dfs2(int u, int f){\n\tfor (int v:G[u]){\n\t\tif (v==f) continue;\n\t\tfor (int i=0; i<30; i++) Insert(Out[v],suf[v][i]),Insert(Out[v],Out[u][i]);\n\t\tInsert(Out[v],a[u]);\n\t\tdfs2(v,u);\n\t}\n}\nint Jump(int u, int d){\n\tfor (int i=18; ~i; i--)\n\t\tif (d&(1<<i)) u=fa[u][i];\n\treturn u;\n}\nint LCA(int u, int v){\n\tif (u==v) return u;\n\tif (dep[u]<dep[v]) swap(u,v);\n\tint d=dep[u]-dep[v];\n\tfor (int i=18; ~i; i--)\n\t\tif (d&(1<<i)) u=fa[u][i];\n\tif (u==v) return u;\n\tfor (int i=18; ~i; i--)\n\t\tif (fa[u][i]^fa[v][i]) u=fa[u][i],v=fa[v][i];\n\treturn fa[u][0];\n}\nint main(){\n\tfor (cin>>T; T; T--){\n\t\tscanf(\"%d\",&n);\n\t\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\t\tfor (int i=1; i<n; i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tG[u].push_back(v),G[v].push_back(u);\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\t\tdfs2(1,0);\n\t\tfor (int i=1; i<=n; i++) ans[i][1]=query(Out[i]);\n\t\t\n\t\tfor (cin>>q; q; q--){\n\t\t\tscanf(\"%d%d\",&rt,&u);\n\t\t\tif (rt==u) printf(\"%d\\n\",ans[1][0]);\n\t\t\telse if (LCA(rt,u)==u) printf(\"%d\\n\",ans[Jump(rt,dep[rt]-dep[u]-1)][1]);\n\t\t\telse printf(\"%d\\n\",ans[u][0]);\n\t\t}\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tans[i][0]=ans[i][1]=0; G[i].clear();\n\t\t\tfor (int j=0; j<30; j++) Bas[i][j]=suf[i][j]=Out[i][j]=0;\n\t\t}\n\t}\n}"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar", "math", "trees"], "dificulty": "2500", "interactive": false}