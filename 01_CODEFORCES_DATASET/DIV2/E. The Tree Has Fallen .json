{
    "link": "https://codeforces.com//contest/1778/problem/E",
    "problemId": "1760990",
    "problem_idx": "E",
    "shortId": "1778E",
    "contest_number": "1778",
    "problem_submissions": {
        "F": [
            191602138,
            191602532,
            191585447,
            191594114,
            191608712,
            191599535,
            191655210,
            191599057,
            191639606,
            191639396,
            194532248,
            191803468
        ],
        "E": [
            191585870,
            191584814,
            191630281,
            191592729,
            191585095,
            191596251,
            191595141,
            191596106,
            191592952,
            191595620,
            191594841,
            191592544,
            191599842,
            192093615,
            191596381,
            191597065,
            191595454
        ],
        "D": [
            191578502,
            191573421,
            191565024,
            191574576,
            191564042,
            191573088,
            191575933,
            191584703,
            191563224,
            191573409,
            191579570,
            191582926,
            191579755,
            191563101,
            191580474,
            191576462,
            192093593,
            191580965,
            191580785,
            191581424
        ],
        "C": [
            191564515,
            191569583,
            191570422,
            191567662,
            191567630,
            191565698,
            191566998,
            191565471,
            191569851,
            191564933,
            191565678,
            191572047,
            191565438,
            191575434,
            191578186,
            191570415,
            192093564,
            191571887,
            191568771,
            191569498
        ],
        "B": [
            191559138,
            191557434,
            191555391,
            191555255,
            191553335,
            191555438,
            191554286,
            191555414,
            191559515,
            191556063,
            191555690,
            191562726,
            191558781,
            191582547,
            191561046,
            191559475,
            192093542,
            191562296,
            191558152,
            191563075
        ],
        "A": [
            191546307,
            191548742,
            191545919,
            191546220,
            191545819,
            191546256,
            191546020,
            191545963,
            191558184,
            191545949,
            191545987,
            191550651,
            191554728,
            191565464,
            191546734,
            191548201,
            192093519,
            191547332,
            191546175,
            191551024
        ]
    },
    "name": "E. The Tree Has Fallen ",
    "statement": "Recently, a tree has fallen on Bob’s head from the sky. The tree has n\r\nnodes. Each node u of the tree has an integer number a_u written on it.\r\nBut the tree has no fixed root, as it has fallen from the sky.Bob is\r\ncurrently studying the tree. To add some twist, Alice proposes a game.\r\nFirst, Bob chooses some node r to be the root of the tree. After that,\r\nAlice chooses a node v and tells him. Bob then can pick one or more\r\nnodes from the subtree of v. His score will be the bitwise XOR of all\r\nthe values written on the nodes picked by him. Bob has to find the\r\nmaximum score he can achieve for the given r and v.As Bob is not a good\r\nproblem-solver, he asks you to help him find the answer. Can you help\r\nhim? You need to find the answers for several combinations of r and v\r\nfor the same tree.Recall that a tree is a connected undirected graph\r\nwithout cycles. The subtree of a node u is the set of all nodes y such\r\nthat the simple path from y to the root passes through u. Note that u is\r\nin the subtree of u.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\nconst int N=2e5+5;\nint Bas[N][30],suf[N][30],Out[N][30],ans[N][2];\nint fa[N][20],dep[N],a[N],tmp[30];\nvector<int> G[N];\nint T,n,q,u,v,rt;\nvoid Insert(int* a, int x){\n\tfor (int j=29; ~j; j--)\n\t\tif (x&(1<<j)){\n\t\t\tif (!a[j]){ a[j]=x; break; }\n\t\t\tx^=a[j];\n\t\t}\n}\nint query(int* a){\n\tint ans=0;\n\tfor (int j=29; ~j; j--)\n\t\tif ((ans^a[j])>ans) ans^=a[j];\n\treturn ans;\n}\nvoid dfs(int u, int f){\n\tdep[u]=dep[f]+1; fa[u][0]=f;\n\tfor (int i=1; i<=18; i++) fa[u][i]=fa[fa[u][i-1]][i-1];\n\tvector<int> son;\n\tfor (int v:G[u]){\n\t\tif (v==f) continue;\n\t\tson.push_back(v);\n\t\tdfs(v,u);\n\t\tfor (int i=0; i<30; i++) Out[v][i]=Bas[u][i];\n\t\tfor (int i=0; i<30; i++) Insert(Bas[u],Bas[v][i]);\n\t}\n\tInsert(Bas[u],a[u]); ans[u][0]=query(Bas[u]);\n\tfor (int i=0; i<30; i++) tmp[i]=0;\n\tfor (int i=son.size()-1; ~i; i--){\n\t\tfor (int j=0; j<30; j++) suf[son[i]][j]=tmp[j];\n\t\tfor (int j=0; j<30; j++) Insert(tmp,Bas[son[i]][j]);\n\t}\n}\nvoid dfs2(int u, int f){\n\tfor (int v:G[u]){\n\t\tif (v==f) continue;\n\t\tfor (int i=0; i<30; i++) Insert(Out[v],suf[v][i]),Insert(Out[v],Out[u][i]);\n\t\tInsert(Out[v],a[u]);\n\t\tdfs2(v,u);\n\t}\n}\nint Jump(int u, int d){\n\tfor (int i=18; ~i; i--)\n\t\tif (d&(1<<i)) u=fa[u][i];\n\treturn u;\n}\nint LCA(int u, int v){\n\tif (u==v) return u;\n\tif (dep[u]<dep[v]) swap(u,v);\n\tint d=dep[u]-dep[v];\n\tfor (int i=18; ~i; i--)\n\t\tif (d&(1<<i)) u=fa[u][i];\n\tif (u==v) return u;\n\tfor (int i=18; ~i; i--)\n\t\tif (fa[u][i]^fa[v][i]) u=fa[u][i],v=fa[v][i];\n\treturn fa[u][0];\n}\nint main(){\n\tfor (cin>>T; T; T--){\n\t\tscanf(\"%d\",&n);\n\t\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\t\tfor (int i=1; i<n; i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tG[u].push_back(v),G[v].push_back(u);\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\t\tdfs2(1,0);\n\t\tfor (int i=1; i<=n; i++) ans[i][1]=query(Out[i]);\n\t\t\n\t\tfor (cin>>q; q; q--){\n\t\t\tscanf(\"%d%d\",&rt,&u);\n\t\t\tif (rt==u) printf(\"%d\\n\",ans[1][0]);\n\t\t\telse if (LCA(rt,u)==u) printf(\"%d\\n\",ans[Jump(rt,dep[rt]-dep[u]-1)][1]);\n\t\t\telse printf(\"%d\\n\",ans[u][0]);\n\t\t}\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tans[i][0]=ans[i][1]=0; G[i].clear();\n\t\t\tfor (int j=0; j<30; j++) Bas[i][j]=suf[i][j]=Out[i][j]=0;\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "math",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Tree Has Fallen .json",
    "editorial_link": "https://codeforces.com//blog/entry/112149",
    "editorial": "At first, we can think of another problem. Given an array. You need to\r\nfind the maximum subset . How can we solve it? We can solve this problem\r\nvery efficiently using a technique called \" Basis\". You can read about\r\nit from here.In problem E, at first, we can fix any node as the root of\r\nthe tree. Letâs call this rooted tree the base tree. After that, start\r\nan Euler tour from the root and assign discovery time and finishing time\r\nto each node . In each query, three types of cases can occur (node and\r\nnode are from the query format): . In this case, we need to calculate\r\nthe maximum subset of the whole tree. Node is an ancestor of node in the\r\nbase tree. So, the subtree of node will remain the same. Node is an\r\nancestor of node in the base tree. What will be the new subtree of node\r\nin this case? This is a bit tricky. Letâs denote such a node that is a\r\nchild of node and an ancestor of node in the base tree. Then the new\r\nsubtree of node will contain the whole tree except the subtree (in the\r\nbase tree) of node . Letâs say, is the basis of all the values in node\r\nâs subtree (in the base tree). We can build by inserting the value to\r\nand merging it with all of its children âs basis . Two basis can be\r\nmerged in complexity, where is their dimension. If we can build the\r\nbasis for each node , we are able to answer the case and case . To\r\nanswer case , we need to find the maximum subset in the corresponding\r\nbasis. To answer case , we need to do a similar thing in the basis ,\r\nwhere is the root node of the base tree.For case , letâs say is the\r\nbasis of all the values of the base tree except the node âs subtree (in\r\nthe base tree). Then the answer of the case will be the maximum subset\r\nin the basis . To build the basis for each node , we can utilize the\r\nproperties of the discovery time and finishing time . Which nodes will\r\nbe outside the subtree of node ? The nodes that have either or . To\r\nmerge their basis easily, we can pre-calculate two basis arrays and\r\nwhere the basis includes all the values of the nodes such that and the\r\nbasis includes all the values of the nodes such that .To find the node\r\nin the case , we can perform a binary search on the children of node .\r\nWe can use the fact that the order of the discovery times follows the\r\norder of the children and a node is only an ancestor of a node iff &&\r\n.Time complexity: , where\r\n",
    "hint": []
}