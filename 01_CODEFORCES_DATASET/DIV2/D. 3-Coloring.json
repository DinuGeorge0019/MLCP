{
    "link": "https://codeforces.com//contest/1504/problem/D",
    "problemId": "945466",
    "problem_idx": "D",
    "shortId": "1504D",
    "contest_number": "1504",
    "problem_submissions": {
        "F": [
            111935045
        ],
        "E": [
            111919537,
            111908818,
            111915476,
            111922174,
            111919354,
            111912277,
            111926667,
            111933626,
            111923368,
            111927972,
            111922895,
            111929837,
            111918921,
            111930705,
            111931199,
            111927831,
            111933167,
            111936231,
            111927723
        ],
        "D": [
            111903831,
            111898035,
            111906622,
            111906753,
            111900341,
            111920726,
            111905882,
            111889202,
            111908288,
            111906401,
            111899954,
            111909419,
            111914558,
            111906091,
            111907496,
            111910516,
            111906791,
            111899242,
            111913796
        ],
        "C": [
            111894612,
            111888998,
            111897074,
            111891045,
            111894960,
            111894678,
            111893967,
            111898677,
            111898779,
            111894676,
            111891710,
            111887088,
            111899272,
            111894062,
            111898183,
            111901135,
            111896065,
            111907589,
            111899883
        ],
        "B": [
            111886123,
            111877937,
            111882311,
            111876691,
            111883851,
            111877415,
            111875995,
            111877870,
            111879515,
            111885430,
            111904265,
            111879266,
            111878112,
            111883768,
            111877486,
            111882773,
            111887115,
            111878394,
            111891154
        ],
        "A": [
            111877837,
            111872895,
            111873662,
            111872585,
            111875452,
            111883020,
            111872169,
            111872988,
            111873021,
            111873751,
            111907400,
            111872188,
            111872713,
            111872621,
            111882814,
            111875730,
            111872954,
            111872953,
            111883462
        ]
    },
    "name": "D. 3-Coloring",
    "statement": "Alice and Bob are playing a game. There is n\r\ntimes n grid, initially empty. We refer to the cell in row i and column\r\nj by (i, j) for 1\r\nle i, j\r\nle n. There is an infinite supply of tokens that come in 3 colors\r\nlabelled 1, 2, and 3.The game proceeds with turns as follows. Each turn\r\nbegins with Alice naming one of the three colors, let\u2019s call it a. Then,\r\nBob chooses a color b\r\nne a, chooses an empty cell, and places a token of color b on that\r\ncell.We say that there is a if there exist two adjacent cells containing\r\ntokens of the same color. Two cells are considered adjacent if they\r\nshare a common edge.If at any moment there is a conflict, Alice wins.\r\nOtherwise, if n^2 turns are completed (so that the grid becomes full)\r\nwithout any conflicts, Bob wins.We have a proof that Bob has a winning\r\nstrategy. Play the game as Bob and win.The interactor is . That is,\r\nAlice\u2019s color choices can depend on Bob\u2019s previous moves.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n    char ch;\n    while(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n    if (ch=='-'){\n        int s=0;\n        while(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n        return -s;\n    }\n    int s=ch-'0';\n    while(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n    return s;\n}\n\nconst int N = 105;\n\nint n;\nint a[N][N];\nbool filled[N][N];\n\nint main(){\n    scanf(\"%d\",&n);\n    fo(t,1,n*n){\n        int A;\n        scanf(\"%d\",&A);\n        A=A-1;\n        if (t==1){\n            if (A)a[1][1]=0;\n            else a[1][1]=1;\n            printf(\"%d 1 1\\n\",a[1][1]+1);fflush(stdout);\n            filled[1][1]=1;\n        }\n        else if (t==2){\n            fo(c,0,2)\n                if (c!=A&&c!=a[1][1]){\n                    a[1][2]=c;\n                    break;\n                }\n            printf(\"%d 1 2\\n\",a[1][2]+1);fflush(stdout);\n            filled[1][2]=1;\n        }\n        else{\n            bool can0=(a[1][1]!=A), can1=(a[1][2]!=A);\n            bool done=false;\n            if (can0){\n                int ki=-1,kj=-1;\n                fo(i,1,n)\n                    fo(j,1,n)\n                    if ((i+j)%2==0){\n                        if (!filled[i][j])ki=i,kj=j;\n                    }\n                if(ki!=-1){\n                    done=1;\n                    filled[ki][kj]=1;\n                    a[ki][kj]=a[1][1];\n                    printf(\"%d %d %d\\n\",a[1][1]+1,ki,kj);fflush(stdout);\n                }\n                else{\n                    int B=3 xor A xor a[1][1];\n                    fo(i,1,n)\n                        fo(j,1,n)\n                        if (!filled[i][j]){\n                            ki=i,kj=j;\n                        }\n                    done=1;\n                    filled[ki][kj]=1;\n                    a[ki][kj]=B;\n                    printf(\"%d %d %d\\n\",B+1,ki,kj);fflush(stdout);\n                }\n            }\n            else{\n                //can1\n                int ki=-1,kj=-1;\n                fo(i,1,n)\n                    fo(j,1,n)\n                    if ((i+j)%2==1){\n                        if (!filled[i][j])ki=i,kj=j;\n                    }\n                if(ki!=-1){\n                    done=1;\n                    filled[ki][kj]=1;\n                    a[ki][kj]=a[1][2];\n                    printf(\"%d %d %d\\n\",a[1][2]+1,ki,kj);fflush(stdout);\n                }\n                else{\n                    int B=3 xor A xor a[1][2];\n                    fo(i,1,n)\n                        fo(j,1,n)\n                        if (!filled[i][j]){\n                            ki=i,kj=j;\n                        }\n                    done=1;\n                    filled[ki][kj]=1;\n                    a[ki][kj]=B;\n                    printf(\"%d %d %d\\n\",B+1,ki,kj);fflush(stdout);\n                }\n            }\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "graphs",
        "interactive"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. 3-Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/89319",
    "editorial": "Imagine the grid is colored like a checkerboard with black and white\r\nsquares. Then Bob\u00e2\u0080\u0099s strategy is to put tokens on white squares and\r\ntokens on black squares as long as he is able. If he is unable, this\r\nmeans all squares of one color are filled, and he can start placing\r\ntokens without making an invalid coloring. More specifically, this is\r\nhis strategy: If Alice chooses : If a black square is free, place a\r\nthere. Otherwise, place a on a white cell. If Alice chooses : If a white\r\nsquare is free, place a there. Otherwise, place a on a black cell. If\r\nAlice chooses : If a white square is free, place a there. Otherwise,\r\nplace a on a black cell.\r\n"
}