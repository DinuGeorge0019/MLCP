{
    "link": "https://codeforces.com//contest/1957/problem/D",
    "problemId": "2603602",
    "problem_idx": "D",
    "shortId": "1957D",
    "contest_number": "1957",
    "problem_submissions": {
        "F2": [
            257624433,
            257624489,
            257628560,
            257621420,
            257758223,
            257757604,
            257757158,
            257717832,
            257717730,
            257717258,
            257717094,
            257702987,
            257702893,
            257653582,
            257653503,
            257653382,
            257648260,
            257648200,
            257641190,
            257634868,
            258552083,
            257634246,
            257634091,
            257829923,
            257637903,
            257630367,
            257637563,
            257640902,
            257704441,
            257700658,
            257703241,
            257675512
        ],
        "F1": [
            257621694,
            257624482,
            257625658,
            257622086,
            257648013,
            257642139,
            257635215,
            257625683,
            257633642,
            258551844,
            257633990,
            257634721,
            257829841,
            257638057,
            257627166,
            257647697,
            257636396,
            257640746,
            257705007,
            257704891,
            257704777,
            257704536,
            257700768,
            257627958
        ],
        "E": [
            257613753,
            257614244,
            257616954,
            257640621,
            257621102,
            257640619,
            257640273,
            257640555,
            259401179,
            257624465,
            258075127,
            258075029,
            257758887,
            257629108,
            257623748,
            257629560,
            257710288,
            257703200,
            257629906
        ],
        "D": [
            257596630,
            257598457,
            257598487,
            257603992,
            257647200,
            257596253,
            257607704,
            257604728,
            257613557,
            257603006,
            257615450,
            257603399,
            257750188,
            257750155,
            257615591,
            257640469,
            257600270,
            257625077,
            257609428,
            257606452,
            257699780,
            257597686,
            257607920
        ],
        "C": [
            257588829,
            257601875,
            257591094,
            257606559,
            257647316,
            257588836,
            257594613,
            257599149,
            257595684,
            257596544,
            257603207,
            257596444,
            257750051,
            257601967,
            257593914,
            257592224,
            257605529,
            257595109,
            257707171,
            257596812,
            257597956
        ],
        "B": [
            257581790,
            257579250,
            257586196,
            257583617,
            257579912,
            257584731,
            257593706,
            257593301,
            257585131,
            257584270,
            257581125,
            257750016,
            257588415,
            257583409,
            257582823,
            257585712,
            257597823,
            257594421,
            257595763,
            257581837
        ],
        "A": [
            257576275,
            257575809,
            257577678,
            257575791,
            257575498,
            257575836,
            257579145,
            257575454,
            257576815,
            257575470,
            257575437,
            257749968,
            257582519,
            257575927,
            257575935,
            257576650,
            257596800,
            257590104,
            257582071,
            257575937
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128716",
    "editorial": "Letâs start by first solving the problem for , and extend the idea to\r\nlater. To solve for , weâll find the smallest value that occurs with\r\ndifferent frequencies on the two paths.Weâll solve an easier version by\r\nsolving for two static arrays, instead of solving the problem of two\r\npaths. To find the smallest value that has a different frequency between\r\nthe two arrays, we can have a segment tree on the frequency array for\r\neach static array. Then, we can store the hash of each segment tree node\r\nand perform a descent to find the first point at which the hashes in the\r\ntwo segment trees differ. The hash of a node is the polynomial hash of\r\nthe subarray it corresponds to.Now, in order to use the same technique\r\non the path, we want the frequency array of the path . To achieve this,\r\nwe can use persistent segment trees. We define to be the segment tree\r\nthat corresponds to the frequency array of the values on the path . With\r\nthe idea of persistence, we can quickly compute for all , when we root\r\nat .To compute , we can use this: for every node in the segment tree\r\nthat we want.Hence, we are able to get the segment tree for the two\r\npaths we need to compare in a query. In our solution with the static\r\narrays, we used the polynomial hash to find the first point of\r\ndifference between the two frequency arrays. So, we need a way to\r\nquickly compute the hash of the pseudo node we computed for .If we have\r\ntwo frequency arrays , , , where the hash of a node is the polynomial\r\nhash of the subarray that corresponds to that node.Hence, we can\r\nsay:Hence, we can perform the same descent that we talked about earlier\r\non the derived segment tree.Now to solve this for , you can perform a\r\ndfs on , and keep entering nodes of the segment tree which have\r\ndiffering hashes, until we find values.The total time complexity comes\r\nout to\r\n",
    "name": "D. A BIT of an Inequality",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n. Find the number of tuples (x, y, z) such that: 1\r\nleq x\r\nleq y\r\nleq z\r\nleq n, and f(x, y)\r\noplus f(y, z) > f(x, z). We define f(l, r) = a_l\r\noplus a_{l + 1}\r\noplus\r\nldots\r\noplus a_{r}, where\r\noplus denotes the bitwise XOR operation.\r\n",
    "solutions": [
        "/*在发觉那一天 在那一天潮汛泛上高筑城墙时间请将一切证明*/#include<bits/stdc++.h>using namespace std;const int maxn=500005;int n,m,T,ans,flg;int a[maxn],s[maxn],h[maxn],tot[2][maxn];int main(){\tscanf(\"%d\",&T);\twhile(T--){\t\tlong long ans=0;\t\tscanf(\"%d\",&n);\t\tfor(int i=0;i<=1;i++)\t\t\tfor(int j=0;j<30;j++)\t\t\t\ttot[i][j]=0;\t\tfor(int i=1;i<=n;i++){\t\t\tscanf(\"%d\",&a[i]),s[i]=s[i-1]^a[i];\t\t\th[i]=31-__builtin_clz(a[i]);\t\t\tfor(int j=0;j<30;j++)\t\t\t\tif((s[i]>>j)&1)\t\t\t\t\ttot[1][j]++;\t\t}//\t\t(s[x-1]^s[y])^(s[y-1]^s[z])>s[x-1]^s[z]//\t\ts[x]^a[x]^a[y]^s[z]>s[x-1]^s[z]\t\tfor(int i=1;i<=n;i++){\t\t\tint u=tot[0][h[i]],v=tot[1][h[i]];\t\t\tans+=1ll*u*v+1ll*(i-u)*(n-i+1-v);\t\t\tfor(int j=0;j<30;j++)\t\t\t\tif((s[i]>>j)&1)\t\t\t\t\ttot[0][j]++,tot[1][j]--;\t\t}\t\t/*for(int i=1;i<=n;i++)\t\t\tfor(int j=i;j<=n;j++)\t\t\t\tfor(int k=j;k<=n;k++)\t\t\t\t\tif((((s[i-1]^s[k])>>h[j])&1)==0)\t\t\t\t\t\tans++;*/\t\tprintf(\"%lld\\n\",ans);\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. A BIT of an Inequality.json",
    "hint": [
        "Hint 1 How can you simplify the given inequality? Use the fact that the XOR of a number with itself is 0.",
        "Hint 2 The inequality simplifies to . For a given what subarrays (that include ) would satisfy this?"
    ]
}