{
    "link": "https://codeforces.com//contest/849/problem/E",
    "problemId": "120648",
    "problem_idx": "E",
    "shortId": "849E",
    "contest_number": "849",
    "problem_submissions": {
        "E": [
            29984627
        ],
        "D": [
            29980380,
            29984713,
            29987113,
            29987678,
            29986479,
            29988201,
            29987208,
            29988755,
            29987991,
            29987817,
            29987769,
            29988339,
            29988247,
            29989621,
            29986927,
            29988632,
            29990118,
            29990720,
            29989058,
            29990251
        ],
        "B": [
            29979684,
            29977657,
            29978977,
            29978484,
            29979095,
            29977894,
            29979276,
            29977973,
            29982859,
            29980015,
            29979892,
            29979449,
            29979975,
            29979216,
            29978971,
            29979346,
            29979237,
            29979525,
            29984295,
            29979922
        ],
        "C": [
            29976407,
            29980612,
            29981370,
            29975801,
            29981874,
            29980020,
            29981577,
            29978884,
            29980292,
            29982740,
            29981839,
            29981519,
            29982769,
            29982080,
            29982993,
            29981923,
            29980470,
            29981447,
            29979227,
            29982562
        ],
        "A": [
            29974883,
            29975173,
            29974854,
            29979296,
            29975395,
            29982064,
            29975326,
            29974873,
            29976333,
            29975161,
            29977076,
            29975568,
            29977504,
            29975431,
            29977059,
            29976536,
            29974950,
            29974966,
            29980055,
            29977173
        ]
    },
    "name": "E. Goodbye Souvenir",
    "statement": "A string of beads is left as the message of leaving. The beads are\r\nnumbered from to from left to right, each having a shape numbered by\r\nintegers between and inclusive. Some beads may have the same shapes.The\r\nof a shape in a certain subsegment of beads, is defined to be the\r\ndifference between the last position and the first position that shape\r\nappears in the segment. The of a subsegment is the sum of over all\r\nshapes that occur in it.From time to time, shapes of beads change as\r\nwell as the . Sometimes, the past secreted in subsegments are being\r\nrecalled, and you are to find the for each of them.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define MN 100000\n#define N 131072\n#define It set<int>::iterator\n#define ll long long\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,tot=0,a[MN+5],last[MN+5],mark[MN+5];long long Ans[MN+5],T[N*2+5];\nset<int> st[MN+5];\nstruct ques{int kind,x,y,v,ad,p;}q[MN*7+5],s[MN*14+5];\nbool cmp(const ques&a,const ques&b){return a.p==b.p?a.kind<b.kind:a.p<b.p;}\nvoid Renew(int x,int v){for(T[x+=N]+=v,x>>=1;x;x>>=1)T[x]=T[x<<1]+T[x<<1|1];}\nll Query(int l,int r)\n{\n//\tcout<<\"Query\"<<l<<\" \"<<r<<endl;\n\tll sum=0;\n\tfor(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1)\n\t{\n\t\tif(~l&1) sum+=T[l+1];\t\n\t\tif( r&1) sum+=T[r-1];\n\t}\n\treturn sum;\n}\n\nvoid Solve(int l,int r)\n{\n\tif(l==r) return;\n\tint mid=l+r>>1,top=0;Solve(l,mid);Solve(mid+1,r);\t\n\tfor(int i=l;i<=mid;++i)\n\t\tif(!q[i].kind) s[++top]=q[i],s[top].p=s[top].x;\n\tfor(int i=mid+1;i<=r;++i) if(q[i].kind==1) \n\t{\n\t\ts[++top]=q[i];s[top].ad=-1;s[top].p=s[top].x-1;\n\t\ts[++top]=q[i];s[top].ad= 1;s[top].p=s[top].y;\n\t}\n\tsort(s+1,s+top+1,cmp);\n//\tcout<<endl<<\" Solve \"<<l<<\" \"<<r<<endl;\n//\tfor(int i=1;i<=top;++i) printf(\"%d %d %d %d %d\\n\",s[i].kind,s[i].x,s[i].y,s[i].v,s[i].p);\n\tfor(int i=1;i<=top;++i)\n\t\tif(!s[i].kind) Renew(s[i].y,s[i].v);\n\t\telse Ans[s[i].v]+=s[i].ad*Query(s[i].x,s[i].y);\n\tfor(int i=1;i<=top;++i) if(!s[i].kind) Renew(s[i].y,-s[i].v);\n}\n\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();\n\t\tif(last[a[i]]) q[++tot]=(ques){0,i,last[a[i]],i-last[a[i]]}; \n\t\tlast[a[i]]=i;st[a[i]].insert(i);\n\t}\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint op=read();\n\t\tif(op==2) {int l=read(),r=read();q[++tot]=(ques){1,l,r,i,0,0};mark[i]=1;} \n\t\telse \n\t\t{\n\t\t\tint x=read(),v=read(),f=0;if(a[x]==v) continue;\n\t\t\tIt it=st[a[x]].lower_bound(x),it2;\n\t\t\tif(it!=st[a[x]].begin())\n\t\t\t{\n\t\t\t\tit2=it;--it2;f=*it2;\n\t\t\t\tq[++tot]=(ques){0,x,f,-(x-f),0,0};\n\t\t\t}\n\t\t\tif(it2=it,++it2!=st[a[x]].end()) \n\t\t\t{\n\t\t\t\tq[++tot]=(ques){0,*it2,x,-(*it2-x),0,0};\n\t\t\t\tif(f) q[++tot]=(ques){0,*it2,f,*it2-f,0,0};\n\t\t\t}\n\t\t\tst[a[x]].erase(it);f=0;\n\t\t\ta[x]=v;st[a[x]].insert(x);\n\t\t\tit=st[a[x]].lower_bound(x);\n\t\t\tif(it!=st[a[x]].begin())\n\t\t\t{\n\t\t\t\tit2=it;--it2;f=*it2;\n\t\t\t\tq[++tot]=(ques){0,x,f,x-f,0,0};\n\t\t\t}\n\t\t\tif(it2=it,++it2!=st[a[x]].end()) \n\t\t\t{\n\t\t\t\tq[++tot]=(ques){0,*it2,x,*it2-x,0,0};\n\t\t\t\tif(f) q[++tot]=(ques){0,*it2,f,-(*it2-f),0,0};\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=tot;++i) printf(\"%d %d %d %d\\n\",q[i].kind,q[i].x,q[i].y,q[i].v);\n\tSolve(1,tot);\n\tfor(int i=1;i<=m;++i) if(mark[i]) printf(\"%lld\\n\",Ans[i]); \n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Goodbye Souvenir.json",
    "editorial_link": "https://codeforces.com//blog/entry/54233",
    "editorial": "Let's look at segment [l,?r]. Let's p1x?<?p2x?<?...?<?pkx  positions of all occurences of shape x at segment [l,?r]. Then memory of shape x at segment [l,?r] is pkx?-?p1x?=?(pkx?-?pk?-?1x)?+?(pk?-?1x?-?pk?-?2x)?+?...?+?(p2x?-?p1x).\n\nThen we can build array of pairs b: bi?=?(prev(i),?i?-?prev(i)), where prev(i)  previous occurence of shape ai . A query transforms to: , which is variation of counting numbers of greater on segment.\n\nQueries of change in position can be proccessed by recounting values prev(p) for ap and next occurence of that shape before and after changing shape.\n\nProcessing of all queries can be done by building segment tree, which every node contains Fenwick tree by types of shape. For reducing memory usage we can, for every node, save only shapes, which appeared in any query for this node. Then Fenwick tree can be build only on this shapes by coordinate compressing.\n\nResult complexity  O(n·log2(n)).",
    "hint": []
}