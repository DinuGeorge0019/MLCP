{
    "link": "https://codeforces.com//contest/1480/problem/E",
    "problemId": "889623",
    "problem_idx": "E",
    "shortId": "1480E",
    "contest_number": "1480",
    "problem_submissions": {
        "E": [
            106815202,
            106829295,
            106831975,
            106809004,
            106829806,
            106819321
        ],
        "A": [
            106788901,
            106763609,
            106753484,
            106750112,
            106751527,
            106754769,
            106750125,
            106749992,
            106750591,
            106751832,
            106750843,
            106752181,
            106751591,
            106750114,
            106751859,
            106763776,
            106750109,
            106751576,
            106750047
        ],
        "B": [
            106787623,
            106771665,
            106761993,
            106764148,
            106756896,
            106759373,
            106760371,
            106757851,
            106763699,
            106762465,
            106762683,
            106765834,
            106771235,
            106765823,
            106763977,
            106769634,
            106760777,
            106760996,
            106762894
        ],
        "D2": [
            106784450,
            106807928,
            106805609,
            106826801,
            106798277,
            106796852,
            106798333,
            106810992,
            106800784,
            106809989,
            106808304,
            106811925,
            106820358,
            106815498,
            106828841,
            106811617,
            106816566,
            106820373,
            106831701
        ],
        "D1": [
            106783553,
            106789621,
            106794420,
            106828218,
            106785923,
            106787471,
            106782777,
            106790234,
            106791782,
            106791560,
            106802581,
            106787920,
            106797964,
            106789713,
            106805344,
            106803882,
            106796851,
            106808232,
            106798013
        ],
        "C": [
            106763339,
            106759660,
            106769859,
            106771866,
            106840559,
            106871120,
            106772068,
            106767886,
            106771470,
            106778796,
            106778516,
            106806146,
            106779019,
            106800993,
            106782589,
            106787042,
            106778247,
            106779906,
            106777631
        ]
    },
    "name": "E. Continuous City",
    "statement": "Some time ago Homer lived in a beautiful city. There were n blocks\r\nnumbered from 1 to n and m directed roads between them. Each road had a\r\npositive length, and each road went from the block with the smaller\r\nindex to the block with the larger index. For every two (different)\r\nblocks, there was at most one road between them. Homer discovered that\r\nfor some two numbers L and R the city was (L, R)-. The city is said to\r\nbe (L, R)-continuous, if all paths from block 1 to block n are of length\r\nbetween L and R (inclusive); and for every L\r\nleq d\r\nleq R, there is path from block 1 to block n whose length is d. A path\r\nfrom block u to block v is a sequence u = x_0\r\nto x_1\r\nto x_2\r\nto\r\ndots\r\nto x_k = v, where there is a road from block x_{i-1} to block x_{i} for\r\nevery 1\r\nleq i\r\nleq k. The length of a path is the sum of lengths over all roads in the\r\npath. Two paths x_0\r\nto x_1\r\nto\r\ndots\r\nto x_k and y_0\r\nto y_1\r\nto\r\ndots\r\nto y_l are different, if k\r\nneq l or x_i\r\nneq y_i for some 0\r\nleq i\r\nleq\r\nmin\r\n{k, l\r\n}. After moving to another city, Homer only remembers the two special\r\nnumbers L and R but forgets the numbers n and m of blocks and roads,\r\nrespectively, and how blocks are connected by roads. However, he\r\nbelieves the number of blocks should be no larger than 32 (because the\r\ncity was small).As the best friend of Homer, please tell him whether it\r\nis possible to find a (L, R)-continuous city or not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nvoid print(vector<int> x){for(int i=0;i<(int)x.size();i++) printf(\"%d%c\",x[i],\" \\n\"[i==(int)x.size()-1]);}\n#define N 55\nstruct Edge\n{\n\tint u,v,w;\n\tEdge(int a=0,int b=0,int c=0) {u=a,v=b,w=c;}\n};\nvector<Edge> ans;\nint id[N];\nvoid get(int val) // 1~val\n{\n\tval--;\n\tfor(int i=2;i<=21;i++)\n\t{\n\t\tfor(int j=1;j<=i-1;j++) ans.eb(i,j,1<<max(j-2,0));\n\t}\n\tfor(int i=0;i<(int)ans.size();i++) ans[i].u=32-ans[i].u+1,ans[i].v=32-ans[i].v+1;\n\tfor(int i=0;i<=19;i++) id[i]=32-i-1;\n\tint tmp=1;\n\tfor(int i=0;i<=19;i++)\n\t{\n\t\tif(val>>i&1)\n\t\t{\n\t\t\t// printf(\"* %d %d %d\\n\",id[i],tmp);\n\t\t\tans.eb(11,id[i],tmp),tmp+=1<<i;\n\t\t}\n\t}\n\tans.eb(11,32,1);\n}\nsigned main()\n{\n\tint l=read(),r=read();\n\tget(r-l+1);\n\tcout<<\"YES\"<<endl;\n\tif(l==1)\n\t{\n\t\tprintf(\"%d %d\\n\",32,(int)ans.size());\n\t\tfor(auto [u,v,w]:ans)\n\t\t{\n\t\t\tprintf(\"%d %d %d\\n\",u==11?1:u,v==11?1:v,w);\n\t\t}\n\t}\n\telse\n\t{\n\t\tans.eb(1,11,l-1);\n\t\tprintf(\"%d %d\\n\",32,(int)ans.size());\n\t\tfor(auto [u,v,w]:ans) printf(\"%d %d %d\\n\",u,v,w);\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Continuous City.json",
    "editorial_link": "https://codeforces.com//blog/entry/87598",
    "editorial": "The answer is always \"YES\". For convenience, we write (x,y,z)\n for a directed road from block x\n to block y\n of length z\n.\n\nStep 1. We can solve the case L=1\n and R=2k\n for k?0\n inductively. The case for k=0\n is trivial, i.e. only one edge (1,2,1)\n.\n\nSuppose there is a city of k+2\n blocks for L=1\n and R=2k\n for some k?0\n, and the induced city from block 1\n to block x\n is (1,2x?2)\n-continuous for every 2?x?k+2\n. Let block k+3\n be a new block, and add (1,k+3,1)\n and (x,k+3,2x?2)\n for 2?x?k+2\n. We can see that the new city containing block k+3\n is (1,2k+1)\n-continuous.\n\nStep 2. Suppose L=1\n and R>1\n. Let R?1=?ki=0Ri2i\n be the binary representation of R?1\n, where 0?Ri?1\n. Let Gk\n be the (1,2k)\n-continuous city constructed in Step 1. Let block k+3\n be a new block. Connect (1,k+3,1)\n, and then for every 0?i?k\n, if Ri=1\n, then connect (i+2,k+3,1+?kj=i+1Rj2j)\n. We can see that the new city containing block k+3\n is (1,R)\n-continuous.\n\nStep 3. Suppose 1<L?R\n. Consider HR?L+1\n, where HR\n denotes the (1,R)\n-continuous city constructed in Step 2 and there are k\n blocks in HR?L+1\n. Connect (k,k+1,L?1)\n. We can see that the new city containing block k+1\n is (L,R)\n-continuous.\n\nWe note that there is at most 23\n blocks in our constructed city.",
    "hint": []
}