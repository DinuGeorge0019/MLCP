{
    "link": "https://codeforces.com//contest/1542/problem/E2",
    "problemId": "1034814",
    "problem_idx": "E2",
    "shortId": "1542E2",
    "contest_number": "1542",
    "problem_submissions": {
        "E2": [
            121219799,
            121223040,
            121227052,
            121233469,
            121239326,
            121234301,
            121236580,
            121235420,
            121216663,
            121238675,
            121273656,
            121296078,
            121315568
        ],
        "E1": [
            121219525,
            121218312,
            121219863,
            121224427,
            121223323,
            121227183,
            121236464,
            121219719,
            121216224,
            121238504,
            121230738,
            121231671,
            121233917,
            121231813,
            121237944,
            121234549,
            121237990,
            121237975,
            121239554,
            121315761,
            121236416
        ],
        "B": [
            121207778,
            121207035,
            121196176,
            121198996,
            121193641,
            121199916,
            121198331,
            121209692,
            121227899,
            121202669,
            121195965,
            121201409,
            121210300,
            121201851,
            121197314,
            121210832,
            121203725,
            121200105,
            121198365,
            121315719,
            121204232
        ],
        "A": [
            121204300,
            121188597,
            121188711,
            121189593,
            121188837,
            121209408,
            121188670,
            121192287,
            121228704,
            121189765,
            121189512,
            121188741,
            121190699,
            121190274,
            121188622,
            121206448,
            121191911,
            121188947,
            121188840,
            121315670,
            121198667
        ],
        "D": [
            121203495,
            121202907,
            121210273,
            121212521,
            121209354,
            121208537,
            121211787,
            121232171,
            121222572,
            121218612,
            121213056,
            121211998,
            121216674,
            121217696,
            121216064,
            121219789,
            121217032,
            121218049,
            121218313,
            121350905,
            121217984
        ],
        "C": [
            121193499,
            121197254,
            121200250,
            121203739,
            121204080,
            121201004,
            121202808,
            121205437,
            121226710,
            121208971,
            121203678,
            121205267,
            121206135,
            121204211,
            121205127,
            121202814,
            121209801,
            121207441,
            121209898,
            121315741,
            121209076
        ]
    },
    "name": "E2. Abnormal Permutation Pairs  hard version ",
    "statement": "A permutation of 1, 2,\r\nldots, n is a sequence of n integers, where each integer from 1 to n\r\nappears exactly once. For example, [2,3,1,4] is a permutation of 1, 2,\r\n3, 4, but [1,4,2,2] isn\u2019t because 2 appears twice in it.Recall that the\r\nnumber of inversions in a permutation a_1, a_2,\r\nldots, a_n is the number of pairs of indices (i, j) such that i < j and\r\na_i > a_j.Let p and q be two permutations of 1, 2,\r\nldots, n. Find the number of permutation pairs (p,q) that satisfy the\r\nfollowing conditions: p is lexicographically smaller than q. the number\r\nof inversions in p is greater than the number of inversions in q. Print\r\nthe number of such pairs modulo mod. Note that mod may not be a prime.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-'0');\n\tx*=f;\n}\nint MOD;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=505,MAXM=500005;\n\nint n;\nint s[MAXM],f[MAXN],d[MAXM],g[MAXM],h[MAXM];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n),readint(MOD);\n\ts[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=1ll*i*f[i-1]%MOD;\n\t\tg[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)g[j]=(g[j-1]+1ll*s[j]*(j+1))%MOD;\n\t\th[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)h[j]=dmy(h[j-1]+s[j]);\n\t\tfor(int j=0;j<=(i-1)*(i-2)/2;j++)\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tif(j>=2)inc(tmp,g[j-2]),inc(tmp,MOD-1ll*(j-i+MOD)*h[j-2]%MOD);\n\t\t\tif(j-i-1>=0)inc(tmp,MOD-g[j-i-1]),inc(tmp,1ll*(j-i+MOD)*h[j-i-1]%MOD);\n\t\t\tinc(f[i],1ll*d[j]*tmp%MOD);\n\t\t}\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)d[j]=0;\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)\n\t\t{\n\t\t\td[j]=s[j];\n\t\t\tif(j>=i)inc(d[j],MOD-s[j-i]);\n\t\t}\n\t\ts[0]=d[0];\n\t\tfor(int j=1;j<=i*(i+1)/2;j++)s[j]=dmy(s[j-1]+d[j]);\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Abnormal Permutation Pairs  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/92492",
    "editorial": "Let's directly count the number of permutation pairs (p,q)\n of length n\n with inv(p)?inv(q)=k\n, instead of counting it indirectly from \"the number of permutation p\ns of length i\n such that inv(p)=j\n.\". Call this number f(n,k)\n.\n\nWe have an n4\n transition: f(n,k)=?|i|<nf(n?1,k?i)\u00d7(n?|i|)\n (Consider where to insert n\n in the first and second permutation. If the two places are indices (I,J)\n, then the delta of inv(p)\n is n?I\n, the other is n?J\n, so the delta of difference is J?I\n. In [1,n]\n there are n?|J?I|\n pairs of integers with difference J?I\n.)\n\nLet's speed it up. When f(n,k)\n moves to f(n,k+1)\n, it looks like this: (n=4\n, as an example)\n\nf(n?1,k?3)\u00d71+f(n?1,k?2)\u00d72+f(n?1,k?1)\u00d73+f(n?1,k)\u00d74+f(n?1,k+1)\u00d73+f(n?1,k+2)\u00d72+f(n?1,k+3)\u00d71\nf(n?1,k?2)\u00d71+f(n?1,k?1)\u00d72+f(n?1,k)\u00d73+f(n?1,k+1)\u00d74+f(n?1,k+2)\u00d73+f(n?1,k+3)\u00d72+f(n?1,k+4)\u00d71\nSo with prefix sums s\n (s(i,j)=?k?jf(i,k)\n) we can write f(n,k+1)=f(n,k)?(s(n?1,k)?s(n?1,k?n))+(s(n?1,k+n)?s(n?1,k))\n.\n\nNote that the second indice of the array might be negative, so we should shift it by 130000\n.\n\nThe memory complexity is O(n3)\n, so we should only keep two layers of transition to optimize it to O(n2)\n (If implemented well, O(n3)\n memory solutions can also pass.)"
}