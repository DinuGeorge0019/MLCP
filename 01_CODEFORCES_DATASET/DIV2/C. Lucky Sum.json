{"link": "https://codeforces.com//contest/122/problem/C", "problemId": "639", "problem_idx": "C", "shortId": "122C", "contest_number": "122", "problem_submissions": {"E": [804119, 810208, 803742, 804906, 805053, 805535, 805395, 806278, 806048, 805630, 806062, 806110, 807439, 805646, 806935, 805348, 805292, 807148, 803308], "D": [802482, 810206, 802395, 802956, 803158, 802902, 802962, 803118, 803510, 803885, 803728, 803980, 803776, 806452, 804671, 807608, 806313, 807465, 804059, 807952], "C": [800923, 810203, 801356, 801235, 801284, 802077, 801764, 801779, 801639, 801891, 801899, 801697, 801979, 801645, 801654, 802889, 808508, 803366, 802586, 801728], "B": [799762, 810199, 799636, 800167, 799922, 800682, 800298, 799652, 799602, 800265, 800137, 800018, 800096, 799947, 799741, 801185, 801074, 799786, 801520], "A": [799077, 810197, 799191, 799050, 799146, 799438, 799389, 799108, 799052, 799014, 799373, 799207, 799220, 799284, 799168, 799106, 799481, 799192, 799054]}, "name": "C. Lucky Sum", "statement": "Let be the minimum lucky number which is larger than or equals . Petya\r\nis interested what is the value of the expression . Help him solve this\r\nproblem.\r\n", "solutions": ["#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <string> vs;\ntypedef istringstream iss;\ntypedef ostringstream oss;\n\nconst int INF = (int) 1E9 + 5;\nconst ll LINF = (ll) 4E18 + 5;\n\nconst ld PI = acos(-1.0);\nconst ld E = 2.718281828459045L;\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define REPD(i, a) for (int i = ((a) - 1); i >= 0; i--)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); ++it)\n#define FITD(it, v) for (typeof((v).rbegin())it = (v).rbegin(); it != (v).rend(); ++it)\n\n#define VAR(a, b) typeof(b) a(b)\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SIZE(a) ((int)(a).size())\n\n#define EXIST(a, b) (find(ALL(a), (b)) != (a).end())\n#define SORT(x) sort(ALL(x))\n#define GSORT(x) sort(ALL(x), greater<typeof(*((x).begin()))>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n#define ENUM(v) FIT(it, (v)) cout << *it << \" \"; cout << endl\n\n#define PF push_front\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntemplate<typename T> T gcd(T a, T b) { return (b == 0) ? abs(a) : gcd(b, a % b); }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> inline T mod(T a, T b) { return (a % b + b) % b; }\ntemplate<typename T> inline T sqr(T x) { return x * x; }\n\ntemplate<typename T> inline string toString(const T& x) { oss os; os << x; return os.str(); }\ninline ll toInt(const string& s) { iss is(s); ll x; is >> x; return x; }\ninline ld toDouble(const string& s) { iss is(s); ld x; is >> x; return x; }\ninline string toLower(string s) { FIT(it, s) *it = tolower(*it); return s; }\ninline string toUpper(string s) { FIT(it, s) *it = toupper(*it); return s; }\n\nconst char DEBUG_PARAM[] = \"__LOCAL_TESTING\";\n\nconst char IN[] = \"_.in\";\nconst char OUT[] = \"_.out\";\n\ninline void init();\ninline void run();\n\nint ntest = 0, test;\n\nint main(int argc, char* argv[]) {\n\tif (argc > 1 && strcmp(argv[1], DEBUG_PARAM) == 0) {\n\t\tfreopen(IN, \"r\", stdin);\n\t\t//freopen(OUT, \"w\", stdout);\n\t}\n\tinit();\n\tif (ntest == 0) { puts(\"ntest = ?\"); return 0; }\n\tfor (test = 1; test <= ntest; test++) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\ninline void stop() {\n\tntest = test - 1;\n}\n\n/* IMPLEMENTATION */\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\nconst ld EPS = 1E-9;\nconst ll MODULE = 1000000007LL;\n\nvector<ll> v;\n\nvoid dfs(ll x) {\n\tif (x > INF * 10LL) {\n\t\treturn;\n\t}\n\tv.PB(x);\n\tdfs(x * 10 + 4);\n\tdfs(x * 10 + 7);\n}\n\ninline void init() {\n\tntest = 1;\n\tdfs(4LL), dfs(7LL);\n\tSORT(v);\n}\n\ninline void run() {\n\tll l, r;\n\tcin >> l >> r;\n\tll last = l, ret = 0;\n\tFIT(it, v) {\n\t\tll x = *it;\n\t\tif (x >= last) {\n\t\t\tll bound = min(x, r);\n\t\t\tll num = (bound - last + 1);\n\t\t\tret += num * x;\n\t\t\tlast = x + 1;\n\t\t\tif (last > r) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n"], "input": "", "output": "", "tags": ["brute force", "math"], "dificulty": "1100", "interactive": false}