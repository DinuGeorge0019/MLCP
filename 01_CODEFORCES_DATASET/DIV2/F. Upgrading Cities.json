{
    "link": "https://codeforces.com//contest/1062/problem/F",
    "problemId": "254599",
    "problem_idx": "F",
    "shortId": "1062F",
    "contest_number": "1062",
    "problem_submissions": {
        "E": [
            45734560,
            45726248,
            45732249,
            45733619,
            45730195,
            45731475,
            45731239,
            45726325,
            45734429,
            45732687,
            45728510,
            45736860,
            45736172,
            45733982,
            45737130,
            45738771,
            45733014,
            45736808,
            45722467,
            45738588
        ],
        "D": [
            45726634,
            45730736,
            45724741,
            45725065,
            45723696,
            45724136,
            45725257,
            45730810,
            45727060,
            45726669,
            45731523,
            45727302,
            45728487,
            45722718,
            45726364,
            45726645,
            45723445,
            45727784,
            45736639,
            45727419
        ],
        "C": [
            45721626,
            45717978,
            45722013,
            45722920,
            45725107,
            45723347,
            45723217,
            45731817,
            45722296,
            45725538,
            45721997,
            45722995,
            45721715,
            45726048,
            45722887,
            45716980,
            45725662,
            45723495,
            45730894,
            45720161
        ],
        "B": [
            45719368,
            45728287,
            45719414,
            45719514,
            45718037,
            45718991,
            45720410,
            45716157,
            45718932,
            45720927,
            45719221,
            45719468,
            45718546,
            45719917,
            45718393,
            45721972,
            45719490,
            45718006,
            45726769,
            45717530
        ],
        "A": [
            45714856,
            45714050,
            45715684,
            45718665,
            45717504,
            45716696,
            45714768,
            45714213,
            45714103,
            45715993,
            45714126,
            45714813,
            45714920,
            45732371,
            45714819,
            45723775,
            45732706,
            45719793,
            45724251,
            45714073
        ],
        "F": [
            45751027,
            45989276,
            46585917
        ]
    },
    "name": "F. Upgrading Cities",
    "statement": "There are n cities in the kingdom X, numbered from 1 through n. People\r\ntravel between cities by some roads. As a passenger, JATC finds it weird\r\nthat from any city u, he can’t start a trip in it and then return back\r\nto it using the roads of the kingdom. That is, the kingdom can be viewed\r\nas an acyclic graph.Being annoyed by the traveling system, JATC decides\r\nto meet the king and ask him to do something. In response, the king says\r\nthat he will upgrade some cities to make it easier to travel. Because of\r\nthe budget, the king will only upgrade those cities that are important\r\nor semi-important. A city u is called if for every city v\r\nneq u, there is either a path from u to v or a path from v to u. A city\r\nu is called if it is not important and we can destroy exactly one city v\r\nneq u so that u becomes important.The king will start to act as soon as\r\nhe finds out all those cities. Please help him to speed up the process.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n#define N 300050\nint head[N],to[N],nxt[N],cnt,n,m,xx[N],yy[N],du[N];\nint tot[2][N],Q[N];\ninline void add(int u,int v) {\n\tto[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;\n}\nvoid Topsort(int opt) {\n\tint i,x;\n\tint l=0,r=0;\n\tfor(i=1;i<=n;i++) if(!du[i]) {\n\t\tQ[r++]=i;\n\t}\n\twhile(l<r) {\n\t\tx=Q[l++];\n\t\tif(r-l==0) tot[opt][x]=n-r;\n\t\telse if(r-l==1) {\n\t\t\tint flg=1,y=Q[l];\n\t\t\tfor(i=head[y];i;i=nxt[i]) {\n\t\t\t\tif(du[to[i]]==1) {flg=0; break;}\n\t\t\t}\n\t\t\tif(flg) tot[opt][x]=n-r;\n\t\t\telse tot[opt][x]=-n;\n\t\t}else tot[opt][x]=-n;\n\t\tfor(i=head[x];i;i=nxt[i]) {\n\t\t\tdu[to[i]]--;\n\t\t\tif(!du[to[i]]) {\n\t\t\t\tQ[r++]=to[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tint i,x,y;\n\tfor(i=1;i<=m;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\txx[i]=x; yy[i]=y;\n\t\tadd(x,y); du[y]++;\n\t}\n\tTopsort(0);\n\tmemset(du,0,sizeof(du));\n\tmemset(head,0,sizeof(head)); cnt=0;\n\tfor(i=1;i<=m;i++) {\n\t\tadd(yy[i],xx[i]); du[xx[i]]++;\n\t}\n\tTopsort(1);\n\tint ans=0;\n\tfor(i=1;i<=n;i++) {\n\t\tif(tot[0][i]+tot[1][i]>=n-2) {\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Upgrading Cities.json",
    "editorial_link": "https://codeforces.com/blog/entry/63199",
    "editorial": "The main idea of this problem is to calculate and for every node , where\r\ndenotes the number of nodes that can reach and denotes the number of\r\nnodes that can be reached by . If then is important or if is\r\nsemi-important.However, it may not possible to calculate and for every\r\nnode in given time (please tell me if itâs possible) so we have to do\r\nsome tricks.First of all, we need to find an arbitrary longest path ()\r\non the graph ( is the number of nodes on this path). If a node is\r\nimportant then it must lie on this path (). Proof: Assume there is a\r\nnode that is important and doesnât lie on (). Let be the rightmost node\r\non () and can reach . Itâs true that , because if then we have a longer\r\npath than the one we found so itâs not possible. By definition of ,\r\ncannot reach . Therefore must be able to reach (because is important).\r\nThis leads to a conflict: We have a path that is longer than the one we\r\nfound: . Therefore statement () is proved. It takes to find ().Letâs\r\ndeal with important nodes first. Because all important nodes lie on the\r\npath () so it makes no sense to calculate and for those nodes that donât\r\nbelong to (). We can calculate by iterate through from to . At each node\r\n, we just need to use bfs or dfs to search for the nodes that can be\r\nreached by . Because we visit each node time then it takes to do this.\r\nTo calculate we just need to reverse the direction of the edges and do\r\nsimilarly.Now we need to find the semi nodes. There are two types of\r\nsemi nodes: those belong to () and those donât. For the ones belong to\r\n(), we just need to check if . For the ones donât belong to (), suppose\r\nwe are dealing with node . Let be the rightmost node on () that can\r\nreach and be the leftmost node on () that can be reached by . Itâs\r\nobvious that . Let and , let equal . If then u is not a semi node\r\n(because we have to delete all nodes between i and j not inclusive), or\r\nelse we must erase to make a semi important node. We can see that the\r\npath from to contains only and , and the path from to contains only and\r\n, because otherwise there exists a longer path than (), which is false.\r\nSo we consider as a candidate. Moreover, if exists a node that is a\r\ncandidate and (also leads to ) then both and are not semi important\r\nnodes. Proof: After we delete , for , exists a path that is as long as\r\n() and does not go through (it goes through ) so is not a important\r\nnode, based on statement (). Same for . Briefly, at this point we have\r\nthe path () and a list of nodes . For every , is a candidate and . For\r\nevery , , .So now we are going to calculate and for those candidate\r\nnodes. We can do this similarly as when we find the important nodes. To\r\ncalculate , iterate through to . At each node , bfs or dfs to search for\r\nnodes that can be reached by . Additionally, if there is a candidate\r\nnode that , we start a search from to find those nodes that can be\r\nreached by , we have . After that we pop those nodes from the stack (or\r\nwhatever), mark them as not visited and continue to iterate to . To\r\ncalculate we reverse the directs of the edges and do the same. Because\r\neach node is visited time by nodes on () and at most times by candidate\r\nnodes so it takes .The total complexity is .\r\n",
    "hint": []
}