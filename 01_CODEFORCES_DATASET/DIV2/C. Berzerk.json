{"link": "https://codeforces.com//contest/787/problem/C", "problemId": "99624", "problem_idx": "C", "shortId": "787C", "contest_number": "787", "problem_submissions": {"E": [25747805, 25769219, 25744553, 26717332, 25755415, 25762542], "B": [25745774, 25737596, 25738540, 25745875, 25737776, 25744359, 25738056, 25737770, 25738864, 25741107, 25738246, 25737616, 25739109, 25738592, 25739173, 25738726, 25737800, 25737780, 25738984, 25738382], "D": [25744630, 25741896, 25745115, 25749718, 25746276, 25756806, 25761778, 25761748], "C": [25741086, 25747033, 25750675, 25741659, 25745560, 25745890, 25749024, 25741922, 25743935, 25744643, 25745202, 25745392, 25745995, 25746453, 25745702, 25745999, 25746587], "A": [25736581, 25736552, 25743791, 25736575, 25739966, 25736705, 25736522, 25736956, 25738154, 25736876, 25736540, 25736830, 25737058, 25737179, 25737189, 25736539, 25736641, 25737439, 25736572]}, "name": "C. Berzerk", "statement": "Rick and Morty are playing their own version of Berzerk (which has\r\nnothing in common with the famous Berzerk game). This game needs a huge\r\nspace, so they play it with a computer.In this game there are objects\r\nnumbered from to arranged in a circle (in clockwise order). Object\r\nnumber is a black hole and the others are planets. There\u2019s a monster in\r\none of the planet. Rick and Morty don\u2019t know on which one yet, only that\r\nhe\u2019s not initially in the black hole, but Unity will inform them before\r\nthe game starts. But for now, they want to be prepared for every\r\npossible scenario. Each one of them has a set of numbers between and\r\n(inclusive). Rick\u2019s set is with elements and Morty\u2019s is with elements.\r\nOne of them goes first and the player changes alternatively. In each\r\nplayer\u2019s turn, he should choose an arbitrary number like from his set\r\nand the monster will move to his -th next object from its current\r\nposition (clockwise). If after his move the monster gets to the black\r\nhole he wins.Your task is that for each of monster\u2019s initial positions\r\nand who plays first determine if the starter wins, loses, or the game\r\nwill stuck in an infinite loop. In case when player can lose or make\r\ngame infinity, it more profitable to choose infinity game.\r\n", "solutions": ["#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 7070, Win = 1, Lose = 2;\nint n, k[2], s[2][MAXN];\nint f[2][MAXN];\nint num[2][MAXN];\nvoid update(int x, int y, int v)\n{\n//\tprintf(\"update %d %d %s\\n\", x, y, v == Win ? \"Win\" : \"Lose\");\n\tif(f[x][y])\n\t\treturn;\n\tf[x][y] = v;\n\tif(v == Lose)\n\t{\n\t\tfor(int i = 1; i <= k[!x]; i++)\n\t\t\tupdate(!x, (y + s[!x][i]) % n, Win);\n\t}\n\telse\n\t{\n\t\tfor(int i = 1; i <= k[!x]; i++)\n\t\t\tif(!--num[!x][(y + s[!x][i]) % n])\n\t\t\t\tupdate(!x, (y + s[!x][i]) % n, Lose);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i <= 1; i++)\n\t{\n\t\tscanf(\"%d\", &k[i]);\n\t\tfor(int j = 1; j <= k[i]; j++)\n\t\t\tscanf(\"%d\", &s[i][j]);\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tnum[i][j] = k[i];\n\t}\n\tmemset(f, 0, sizeof(f));\n\tf[0][0] = f[1][0] = Lose;\n//\tupdate(0, 0, Lose);\n//\tupdate(1, 0, Lose);\n\tfor(int x = 0; x <= 1; x++)\n\t\tfor(int i = 1; i <= k[x]; i++)\n\t\t\tupdate(x, s[x][i], Win);\n\tfor(int i = 0; i <= 1; i++)\n\t{\n\t\tfor(int j = n - 1; j >= 1; j--)\n\t\t\tif(f[i][j] == Win)\n\t\t\t\tprintf(\"Win \");\n\t\t\telse if(f[i][j] == Lose)\n\t\t\t\tprintf(\"Lose \");\n\t\t\telse\n\t\t\t\tprintf(\"Loop \");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["dp", "games"], "dificulty": "2000", "interactive": false}