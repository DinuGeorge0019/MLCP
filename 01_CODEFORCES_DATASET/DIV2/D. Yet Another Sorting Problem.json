{
    "link": "https://codeforces.com//contest/1591/problem/D",
    "problemId": "1225716",
    "problem_idx": "D",
    "shortId": "1591D",
    "contest_number": "1591",
    "problem_submissions": {
        "E": [
            138939759,
            138896286,
            138892087,
            138904906,
            138899099,
            138912542,
            138905319,
            138942968,
            138922159,
            138917295,
            138909678,
            138916267,
            138912773,
            142180374,
            138919614,
            138909983,
            141705495,
            138930168,
            138928555,
            138925316,
            138913022,
            138892012,
            138926540,
            138931077,
            138931064,
            138930963,
            138930485,
            138930038,
            138902474,
            138912155
        ],
        "F": [
            138896881,
            138908816,
            138884874,
            138909478,
            138884427,
            138908517,
            138891044,
            138904560,
            138893395,
            138899285,
            138915632,
            142180394,
            138899469,
            138921469,
            138919710,
            138905703,
            138891520,
            138877610,
            138877802,
            138894139
        ],
        "D": [
            138884909,
            138887502,
            138910689,
            138885286,
            138904549,
            138890635,
            138896357,
            138890254,
            138899856,
            138910347,
            138894967,
            142180350,
            138908889,
            138894185,
            138899015,
            138918606,
            138885986,
            138899645,
            138900772
        ],
        "C": [
            138879406,
            138882062,
            138878466,
            138879202,
            138893756,
            138887313,
            138887413,
            138881365,
            138897506,
            138896182,
            138887184,
            142180334,
            138892648,
            138885173,
            138883573,
            138910386,
            138882034,
            138887438,
            138893006,
            138887255
        ],
        "B": [
            138872954,
            138874823,
            138871917,
            138872565,
            138874131,
            138872675,
            138878614,
            138874098,
            138894802,
            138876267,
            138881546,
            142180302,
            138877235,
            138875059,
            138878573,
            138912046,
            138876941,
            138876177,
            138883593,
            138876483
        ],
        "A": [
            138869941,
            138869454,
            138869620,
            138869532,
            138871744,
            138869648,
            138874054,
            138870679,
            138872074,
            138872428,
            138873158,
            142180273,
            138870902,
            138870272,
            138873798,
            138910683,
            138871332,
            138872992,
            138880205,
            138869700
        ]
    },
    "name": "D. Yet Another Sorting Problem",
    "statement": "Petya has an array of integers a_1, a_2,\r\nldots, a_n. He only likes sorted arrays. Unfortunately, the given array\r\ncould be arbitrary, so Petya wants to sort it.Petya likes to challenge\r\nhimself, so he wants to sort array using only 3-cycles. More formally,\r\nin one operation he can pick 3 indices i, j, and k (1\r\nleq i, j, k\r\nleq n) and apply i\r\nto j\r\nto k\r\nto i cycle to the array a. It simultaneously places a_i on position j,\r\na_j on position k, and a_k on position i, without changing any other\r\nelement.For example, if a is [10, 50, 20, 30, 40, 60] and he chooses i =\r\n2, j = 1, k = 5, then the array becomes [\r\nunderline{50},\r\nunderline{40}, 20, 30,\r\nunderline{10}, 60].Petya can apply arbitrary number of 3-cycles\r\n(possibly, zero). You are to determine if Petya can sort his array a, i.\r\ne. make it non-decreasing.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nconst int N=500005;\n\nint n;\n\nstruct fen{\n    int c[N];\n    void ini(int n){\n        memset(c,0,4*(n+1));\n    }\n    void add(int x,int dlt){\n        while(x<=n){\n            c[x]^=dlt;\n            x+=x&-x;\n        }\n    }\n    int qry(int x){\n        int ret=0;\n        while(x){\n            ret^=c[x];\n            x^=x&-x;\n        }\n        return ret;\n    }\n}bit;\nint a[N],b[N];\n\nvoid solve(){\n    n=read();\n    rep(i,1,n)a[i]=read();\n    if(n<=2){\n        int ok=1;\n        rep(i,2,n)ok&=a[i-1]<=a[i];\n        puts(ok?\"YES\":\"NO\");\n        return;\n    }\n    rep(i,1,n)b[i]=a[i];sort(b+1,b+n+1);\n    rep(i,2,n)if(b[i]==b[i-1]){\n        puts(\"YES\");\n        return;\n    }\n    bit.ini(n);\n    int fuck=0;\n    rep(i,1,n){\n        fuck^=(i-1-bit.qry(a[i]))&1;\n        bit.add(a[i],1);\n    }\n    puts(fuck?\"NO\":\"YES\");\n}\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "math",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Yet Another Sorting Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/97845",
    "editorial": "Set of all 3\n-cycles generates a group of even permuations An\n. So the answer is \"YES\" if and only if there is an even permutation that sorts array a\n.\n\nIf all elements of a\n are distinct, then there is unique sorting permutation that has the same parity as a\n.\n\nIf there are identic elements in a\n, let's look at arbitrary sorting permutation. If it's odd, then we can add transposition of identic elements to it, after this permutation remains sorting, but becomes even. So in this case, even sorting permutation always exists.\n\nOverall, we need to check if all elements of a\n are distinct. If it's not true, then answer is \"YES\". Otherwise, we need to check that permutation a\n is even. This can be done in many ways, including some with O(n)\n complexity.",
    "hint": []
}