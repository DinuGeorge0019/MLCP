{
    "link": "https://codeforces.com//contest/1748/problem/F",
    "problemId": "1632968",
    "problem_idx": "F",
    "shortId": "1748F",
    "contest_number": "1748",
    "problem_submissions": {
        "F": [
            180651535,
            180677196,
            181105630,
            180664800,
            181374019,
            180658674,
            180695681,
            180655443,
            180742899
        ],
        "E": [
            180637637,
            180628826,
            180634324,
            180638179,
            180642534,
            180644596,
            180636672,
            181374010,
            180641599,
            180630018,
            180635790,
            180636019,
            180643172,
            180645795,
            180743214,
            180638578,
            180968480,
            180635598,
            180635749,
            180647581,
            180646430,
            180647569,
            180646469
        ],
        "D": [
            180633726,
            180624258,
            180629104,
            180634928,
            180631821,
            180631702,
            180639756,
            181373997,
            180632286,
            180647106,
            180647136,
            180632247,
            180695817,
            180636057,
            180743200,
            180643463,
            180968348,
            180645591,
            180644512,
            180637600,
            180635174,
            180636597,
            180633591
        ],
        "C": [
            180627069,
            180617304,
            180624008,
            180625748,
            180621980,
            180623459,
            180622660,
            181373988,
            180628239,
            180625933,
            180628451,
            180622380,
            180627739,
            180622385,
            180743249,
            180625569,
            180968325,
            180627789,
            180629833,
            180622612,
            180628495,
            180626202,
            180630095
        ],
        "B": [
            180622705,
            180613102,
            180624297,
            180615500,
            180617761,
            180619392,
            180619994,
            181373974,
            180622730,
            180621189,
            180616618,
            180613628,
            180622929,
            180618545,
            180743160,
            180616164,
            180968311,
            180615958,
            180614803,
            180618593,
            180622095,
            180621136
        ],
        "A": [
            180613831,
            180610319,
            180610882,
            180610734,
            180612490,
            180611586,
            180619768,
            181373957,
            180612666,
            180610632,
            180610694,
            180610429,
            180620047,
            180612131,
            180743129,
            180611466,
            180968275,
            180611045,
            180610310,
            180612188,
            180613830,
            180610743
        ]
    },
    "name": "F. Circular Xor Reversal",
    "statement": "You have an array a_0, a_1,\r\nldots, a_{n-1} of length n. Initially, a_i = 2^i for all 0\r\nle i\r\nlt n. Note that array a is zero-indexed. You want to reverse this array\r\n(that is, make a_i equal to 2^{n-1-i} for all 0\r\nle i\r\nlt n). To do this, you can perform the following operation no more than\r\n250\r\n,000 times: Select an integer i (0\r\nle i\r\nlt n) and replace a_i by a_i\r\noplus a_{(i+1)\r\nbmod n}. Here,\r\noplus denotes the bitwise XOR operation.Your task is to find sequence of\r\noperations that will result in the array a being reversed. It can be\r\nshown that under the given constraints, a solution always exists.\r\n",
    "solutions": [
        "# include <cstdlib>\n# include <vector>\n# include <algorithm>\n# include <cstdio>\n\nnamespace khin {\n  using namespace std;\n  namespace main {\n    inline namespace source {\n      typedef unsigned long int ulong;\n      typedef unsigned short int ushort;\n      typedef unsigned int uint;\n    }\n    namespace f { void main(); }\n  }\n}\n\nint main() { khin::main::f::main(); }\n\nnamespace khin::main::f {\n  constexpr uint n_max(400);\n  uint n; vector<uint> i;\n  void main() {\n    scanf(\"%u\", &n);\n    for (uint x(0), y(n - 1); x < y; ++x, --y) {\n      for (uint j(y); j != x; j = (j + n - 1) % n)\n        i.push_back((j + n - 1) % n);\n      for (uint j((x + 1) % n); j != y; j = (j + 1) % n)\n        i.push_back(j);\n      if ((y - x + n) % n > 1) {\n        for (uint j((y + n - 1) % n); j != x; j = (j + n - 1) % n)\n          i.push_back((j + n - 1) % n);\n        for (uint j((x + 1) % n); j != (y + n - 1) % n; j = (j + 1) % n)\n          i.push_back(j);\n      }\n    }\n    for (uint x(0), y(n - 1); x < y; ++x, --y) {\n      swap(x, y);\n      if ((y - x + n) % n > 1) {\n        for (uint j((y + n - 1) % n); j != x; j = (j + n - 1) % n)\n          i.push_back((j + n - 1) % n);\n        for (uint j((x + 1) % n); j != (y + n - 1) % n; j = (j + 1) % n)\n          i.push_back(j);\n      }\n      for (uint j(y); j != x; j = (j + n - 1) % n)\n        i.push_back((j + n - 1) % n);\n      for (uint j((x + 1) % n); j != y; j = (j + 1) % n)\n        i.push_back(j);\n      swap(x, y);\n    }\n    for (uint x(0), y(n - 1); x < y; ++x, --y) {\n      for (uint j(y); j != x; j = (j + n - 1) % n)\n        i.push_back((j + n - 1) % n);\n      for (uint j((x + 1) % n); j != y; j = (j + 1) % n)\n        i.push_back(j);\n      if ((y - x + n) % n > 1) {\n        for (uint j((y + n - 1) % n); j != x; j = (j + n - 1) % n)\n          i.push_back((j + n - 1) % n);\n        for (uint j((x + 1) % n); j != (y + n - 1) % n; j = (j + 1) % n)\n          i.push_back(j);\n      }\n    }\n    do {\n      vector<uint> t;\n      for (uint const i: i)\n        if (t.empty() || t.back() != i) t.push_back(i);\n        else t.pop_back();\n      i = t;\n    } while (false);\n    printf(\"%zu\\n\", i.size());\n    for (uint const i: i) printf(\"%u \", i);\n    putchar('\\n');\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Circular Xor Reversal.json",
    "editorial_link": "https://codeforces.com//blog/entry/108319",
    "editorial": "SolutionIf , and , let be a sequence of operations that performs: ; ; ;\r\nIf is even, we can reverse array by performing , and , in this\r\norder.Otherwise, if is odd, we can perform , and , in this order.One\r\npossible way to construct is as follows: Perform an operation on every\r\nfrom to : Perform an operation on every from to : Perform an operation\r\non every from to : Perform an operation on every from to : The last step\r\nis to perform an operation on every from to : Here, denotes .The number\r\nof operations needed for is equal to , therefore the total number of\r\noperations needed to reverse the array is . Since , .Time complexity per\r\ntestcase:\r\n",
    "hint": []
}