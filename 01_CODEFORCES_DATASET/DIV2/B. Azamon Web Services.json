{
    "link": "https://codeforces.com//contest/1281/problem/B",
    "problemId": "495767",
    "problem_idx": "B",
    "shortId": "1281B",
    "contest_number": "1281",
    "problem_submissions": {
        "E": [
            66919654,
            66920588,
            66925092,
            66923975,
            66921225,
            66926039,
            66924486,
            66925911,
            66919753,
            66924443,
            66921735,
            66926640,
            66923762,
            66928689,
            66923984,
            66929347,
            66922347,
            66925800,
            66926136,
            66926785
        ],
        "D": [
            66913905,
            66912980,
            66914351,
            66914888,
            66918186,
            66917312,
            66919310,
            66913455,
            66927167,
            66918040,
            66916917,
            66918767,
            66920615,
            66919931,
            66917311,
            66920679,
            66926946,
            66921289,
            66921368,
            66915749
        ],
        "C": [
            66910411,
            66909108,
            66910083,
            66911847,
            66912648,
            66912093,
            66912420,
            66917797,
            66912812,
            66913195,
            66926185,
            66911123,
            66913114,
            66915044,
            66929796,
            66916101,
            66915614,
            66912997,
            66913346,
            66920684
        ],
        "B": [
            66903686,
            66904970,
            66904261,
            66905849,
            66904183,
            70825921,
            66906323,
            66905017,
            66906316,
            66904966,
            66910332,
            66906601,
            66907853,
            66908474,
            66905210,
            66905588,
            66906778,
            66904477,
            66905850,
            66914866,
            66908783
        ],
        "A": [
            66901264,
            66901388,
            66900754,
            66900661,
            66900790,
            70825928,
            66900330,
            66900663,
            66904497,
            66901649,
            66900680,
            66901270,
            66900668,
            66900286,
            66902138,
            66900321,
            66900528,
            66900477,
            66900340,
            66913834,
            66903613
        ],
        "F": [
            66933294,
            67581587
        ]
    },
    "name": "B. Azamon Web Services",
    "statement": "Your friend Jeff Zebos has been trying to run his new online company,\r\nbut it\u2019s not going very well. He\u2019s not getting a lot of sales on his\r\nwebsite which he decided to call . His big problem, you think, is that\r\nhe\u2019s not ranking high enough on the search engines. If only he could\r\nrename his products to have better names than his competitors, then\r\nhe\u2019ll be at the top of the search results and will be a\r\nmillionaire.After doing some research, you find out that search engines\r\nonly sort their results lexicographically. If your friend could rename\r\nhis products to lexicographically smaller strings than his competitor\u2019s,\r\nthen he\u2019ll be at the top of the rankings!To make your strategy less\r\nobvious to his competitors, you decide to swap no more than two letters\r\nof the product names.Please help Jeff to find improved names for his\r\nproducts that are lexicographically smaller than his competitor\u2019s!Given\r\nthe string s representing Jeff\u2019s product name and the string c\r\nrepresenting his competitor\u2019s product name, find a way to swap of\r\ncharacters in s (that is, find two distinct indices i and j and swap s_i\r\nand s_j) such that the resulting new name becomes strictly\r\nlexicographically smaller than c, or determine that it is impossible.\r\nString a is than string b if and only if one of the following holds: a\r\nis a of b, that is, a is a of b such that a\r\nneq b; There exists an integer 1\r\nle i\r\nle\r\nmin{(|a|, |b|)} such that a_i < b_i and a_j = b_j for 1\r\nle j < i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    for (int tt = 0; tt < t; tt++) {\n        string s, c;\n        cin >> s >> c;\n        if (s < c) {\n            cout << s << \"\\n\";\n            continue;\n        }\n        string t = s;\n        sort(t.begin(), t.end());\n        int a = 0;\n        for (int i = 0; i < (int) s.size(); i++) {\n            if (s[i] > t[i]) {\n                for (int j = i + 1; j < (int) s.size(); j++) {\n                    swap(s[i], s[j]);\n                    if (s < c) {\n                        cout << s << \"\\n\";\n                        a = 1;\n                        i = s.size();\n                        break;\n                    }\n                    swap(s[i], s[j]);\n                }\n            }\n        }\n        if (a == 0) {\n            cout << \"---\\n\";\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Azamon Web Services.json",
    "editorial_link": "https://codeforces.com//blog/entry/72212",
    "editorial": "The problem becomes a bit easier if we try to answer a different\r\nquestion: We then simply compare this string with . This works because\r\nif the string we can form is not smaller than , then clearly no other\r\nstring we can form will be smaller than .To find the lexicographically\r\nsmallest string we can form, we can be greedy. We sort and find the\r\nfirst letter that isn\u00e2\u0080\u0099t in its correct sorted position. In other words,\r\nfind the first position where and doesn\u00e2\u0080\u0099t match. We then find the letter\r\nthat should be in that position and put it in its correct position. If\r\nthere are multiple choices, it is better to take the one that occurs\r\nlast, since it makes the resulting string smallest.A special case is\r\nwhen is already sorted. In this case, we can\u00e2\u0080\u0099t make any smaller, so we\r\nshould not swap at all.The solution runs in , but solutions running in\r\nare also accepted. (There are other, different solutions that run in .)\r\nThis can be improved to by replacing the sorting step with simpler\r\noperations, since we don\u00e2\u0080\u0099t actually need the full sorted version of .\r\n"
}