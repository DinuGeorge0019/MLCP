{
    "link": "https://codeforces.com//contest/816/problem/A",
    "problemId": "110364",
    "problem_idx": "A",
    "shortId": "816A",
    "contest_number": "816",
    "problem_submissions": {
        "E": [
            27863231,
            27863827,
            27863029,
            27860461,
            27863136,
            27865351,
            27864615,
            27864468,
            27888047,
            27887967,
            27937085
        ],
        "C": [
            27850215,
            27861317,
            27854036,
            27851177,
            27862299,
            27857090,
            27854650,
            27852662,
            27850415,
            27853530,
            27854524,
            27855938,
            27852726,
            27856877,
            27849179,
            27853471,
            27855491,
            27856929,
            27856486
        ],
        "B": [
            27848642,
            27849640,
            27850149,
            27848668,
            27849856,
            27851634,
            27849204,
            27854414,
            27848329,
            27850570,
            27851030,
            27849936,
            27849151,
            27848884,
            27852810,
            27850464,
            27851714,
            27851843,
            27851131
        ],
        "A": [
            27848027,
            27848026,
            27848067,
            27848089,
            27848256,
            27849615,
            27848022,
            27851364,
            27847966,
            27848494,
            27847999,
            27848587,
            27848127,
            27847967,
            27851375,
            27849723,
            27848224,
            27848952,
            27848135
        ],
        "D": [
            27863292,
            28057801,
            28341325,
            27862819,
            27861012,
            27860728,
            27886034,
            27863751,
            27864128
        ]
    },
    "name": "A. Karen and Morning",
    "statement": "Karen is getting ready for a new school day! It is currently , given in\r\na 24-hour format. As you know, Karen loves , and she believes that it is\r\ngood luck to wake up when the time is a palindrome.What is the minimum\r\nnumber of minutes she should sleep, such that, when she wakes up, the\r\ntime is a palindrome?Remember that a palindrome is a string that reads\r\nthe same forwards and backwards. For instance, is not a palindrome,\r\nbecause backwards is . On the other hand, is a palindrome, because\r\nbackwards is .\r\n",
    "solutions": [
        "//#pragma comment(linker,\"/STACK:16777216\") /*16Mb*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <time.h>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\n\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define RFOR(i,a,b) for(int (i)=(a)-1;(i)>=(b);--(i))\n#define MP make_pair\n#define I insert\n#define mod 1000000007\n#define INF 2000000007\n#define PB push_back\n#define x0 sdfhrthrth\n#define x1 fdhttrlhn\n#define y0 kihrbdb\n#define y1 ugvrrtgtrg\n#define eps 1e-5\n#define X first\n#define Y second\n\nconst int MAXN = 10007;\n\nstring s;\nint h, m;\nchar ch;\n\nint main()\n{\n    cin >> h >> ch >> m;\n    int ans = 0;\n    while (h/10 != m%10 || h%10 != m/10)\n    {\n        m++;\n        if (m == 60) m = 0, h++;\n        if (h == 24) h = 0;\n        ans++;\n    }\n    cout << ans;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Karen and Morning.json",
    "editorial_link": "https://codeforces.com//blog/entry/52742",
    "editorial": "This is a rather straightforward implementation problem.The only\r\nobservation here is that there are only different possible times. It is\r\nenough to iterate through all of them until we encounter a palindromic\r\ntime, and count the number of times we had to check before we reached a\r\npalindromic time.How do we iterate through them? The most\r\nstraightforward way is to simply convert the given string into two\r\nintegers and . We can do this manually or maybe use some functions\r\nspecific to your favorite language. It is good to be familiar with how\r\nyour language deals with strings. It is also possible, though\r\ninadvisable, to try to work with the string directly.To go to the next\r\ntime, we simply increment . If becomes , then make it and increment . If\r\nbecomes , then make it .To check whether a given time is palindromic, we\r\nsimply need to check if the tens digit of is the same as the ones digit\r\nof , and if the ones digit of is the same as the tens digit of . This\r\ncan be done like so: check if and .Another way is to simply cross-check\r\nagainst a list of palindromic times. Just be careful not to miss any of\r\nthem, and not to add any extraneous values. There are palindromic times,\r\nnamely: , , , , , , , , , , , , , , and .\r\n"
}