{
    "link": "https://codeforces.com//contest/1993/problem/F2",
    "problemId": "2795987",
    "problem_idx": "F2",
    "shortId": "1993F2",
    "contest_number": "1993",
    "problem_submissions": {
        "C": [
            274402188,
            274358757,
            274374996,
            274374747,
            274368652,
            274357644,
            274365562,
            274356432,
            274379356,
            274367132,
            274372055,
            274371076,
            274363983,
            274370693,
            274369864,
            274367679,
            274363345,
            274405366,
            274364436
        ],
        "B": [
            274397223,
            274346884,
            274361191,
            274359127,
            274350863,
            274346370,
            274355668,
            274347298,
            274365588,
            274350765,
            274364310,
            274350846,
            274352824,
            274355191,
            274352816,
            274350915,
            274351222,
            274395841,
            274351441
        ],
        "A": [
            274391220,
            274335769,
            274358967,
            274335712,
            274338856,
            274337195,
            274340094,
            274335737,
            274356689,
            274336110,
            274349520,
            274336792,
            274342378,
            274342208,
            274335539,
            274352863,
            274335926,
            274386754,
            274342173
        ],
        "D": [
            274387898,
            274378476,
            274479687,
            274386087,
            274394516,
            274379793,
            274384145,
            274380644,
            274383004,
            274432739,
            274365274,
            274383568,
            274381874,
            274380805,
            274387445,
            274383605,
            274390133,
            275106936,
            274388789,
            274469604,
            274391022,
            274416385,
            274388682
        ],
        "E": [
            274380482,
            274416572,
            274415942,
            274406977,
            274400748,
            275106863,
            274409594,
            281997956,
            274569827
        ],
        "F2": [
            274361444,
            274397454,
            274414076,
            274417256,
            274415219,
            276095739,
            274383447
        ],
        "F1": [
            274349830,
            274385685,
            274402182,
            274415340,
            274413779,
            274417154,
            274400648,
            274391762,
            274403361,
            274395449,
            274405171,
            274404884,
            274415155,
            274426602,
            274426556,
            274426256,
            274400601,
            274403335,
            274384119,
            274407161
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132185",
    "editorial": "SolutionThe idea of this version is almost the same as F1: counting the\r\nnumber of pairs that satisfies: , and However, as is increased to we\r\ncannot brute-force the same way as the previous version. Luckily, there\r\nis a more efficient way. We need to modify these equivalences a bit: As\r\nwe can see, these two equivalences have the same format . To solve this\r\nequivalence for , one way to hang around is to divide , and by . If is\r\nnot divisible, there is no solution! Otherwise, we come up with: Where\r\nis the modular inverse of . We can always calculate it because the\r\ncondition is satisfied.Letâs define , and (similar for and ). Then, the\r\nsolutions of the equivalences at are: This system of equivalences can be\r\nsolved using Chinese Remainder Theorem. After some calculations, we come\r\nup with: ( is a non-negative integer). can be solved for the same way as\r\n. Now we know the solution is , the last thing to do is to count number\r\nof such value doesnât exceed and weâre done!Time complexity:\r\n",
    "name": "F2. Dyn-scripted Robot  Hard Version ",
    "statement": "Given a w\r\ntimes h rectangle on the Oxy plane, with points (0, 0) at the\r\nbottom-left and (w, h) at the top-right of the rectangle.You also have a\r\nrobot initially at point (0, 0) and a script s of n characters. Each\r\ncharacter is either , , , or , which tells the robot to move left,\r\nright, up, or down respectively.The robot can only move inside the\r\nrectangle; otherwise, it will change the script s as follows: If it\r\ntries to move outside a vertical border, it changes all characters to ’s\r\n(and vice versa, all ’s to ’s). If it tries to move outside a horizontal\r\nborder, it changes all characters to ’s (and vice versa, all ’s to ’s).\r\nThen, it will execute the changed script starting from the character\r\nwhich it couldn’t execute. The script s will be executed for k times\r\ncontinuously. All changes to the string s will be retained even when it\r\nis repeated. During this process, how many times will the robot move to\r\nthe point (0, 0) in total? .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}int exgcd(int a,int b,int &x,int &y){\t//x*a+y*b=gcd(a,b)\tif(b==0){\t\tx=1,y=0;\t\tre a;\t}\tint g=exgcd(b,a%b,x,y);\tswap(x,y);\ty-=a/b*x;\tre g;}pii get(int x,int y,int md){\tint es,et,g=exgcd(x,md,es,et);\tif(y%g)re {-1,-1};\tx/=g,y/=g,md/=g;\t(es*=y)%=md;\tif(es<0)es+=md;\tre {es,md};}int n,k,h,w;string s;void run(){\tcin>>n>>k>>h>>w>>s;\tint cx=0,cy=0;\tmap<pii,int>pp,pp2;\th+=h,w+=w;\tfor(char c:s){\t\tif(c=='L')cx--;\t\tif(c=='R')cx++;\t\tif(c=='D')cy--;\t\tif(c=='U')cy++;\t\t(cx+=h)%=h;\t\t(cy+=w)%=w;\t\tpp[{cx,cy}]++;\t}\tint ans=0;\tfor(auto it:pp){\t\tint x=(h-it.F.F)%h,y=(w-it.F.S)%w;\t\tpii dx=get(cx,x,h),dy=get(cy,y,w);\t\tif(dx.F<0||dy.F<0||dx.F>=k||dy.F>=k)continue;\t\t//xF+xS*t=yF(mod yS)\t\tpii dz=get(dx.S,(dy.F+dy.S-dx.F%dy.S)%dy.S,dy.S);\t\tint t_lim=(k-dx.F-1)/dx.S+1;\t\tif(dz.F<0||dz.F>=t_lim)continue;\t\tans+=((t_lim-dz.F-1)/dz.S+1)*it.S;\t}\tcout<<ans<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "math",
        "number theory"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Dyn-scripted Robot  Hard Version .json",
    "hint": []
}