{
    "link": "https://codeforces.com//contest/505/problem/C",
    "problemId": "20817",
    "problem_idx": "C",
    "shortId": "505C",
    "contest_number": "505",
    "problem_submissions": {
        "C": [
            9462976,
            9461898,
            9459707,
            9460323,
            9475230,
            9461474,
            9461128,
            9460598,
            9463476,
            9462889,
            9462051,
            9463671,
            9462825,
            9465572,
            9465481,
            9462466,
            9464504,
            9463286,
            9463626,
            9462651,
            9461631
        ],
        "D": [
            9460671,
            9463777,
            9464008,
            9474989,
            9464501,
            9744902
        ],
        "B": [
            9456425,
            9457631,
            9456673,
            22609961,
            9456565,
            9458361,
            9457629,
            9458613,
            9458858,
            9457628,
            9457194,
            9457755,
            9457863,
            9458685,
            9458451,
            9458743,
            9457349,
            9458774,
            9459522,
            9459663,
            9461689
        ],
        "A": [
            9456096,
            9456444,
            9456105,
            9456129,
            9456125,
            9456286,
            9457000,
            9456383,
            9456164,
            9456547,
            9456739,
            9457117,
            9457263,
            9456225,
            9456374,
            9456854,
            9456408,
            9460374,
            9456267
        ]
    },
    "name": "C. Mr. Kitayuta, the Treasure Hunter",
    "statement": "The Shuseki Islands are an archipelago of small islands in the Yutampo\r\nSea. The islands are evenly spaced along a line, numbered from to from\r\nthe west to the east. These islands are known to contain many treasures.\r\nThere are gems in the Shuseki Islands in total, and the -th gem is\r\nlocated on island .Mr. Kitayuta has just arrived at island . With his\r\ngreat jumping ability, he will repeatedly perform jumps between islands\r\nto the east according to the following process: First, he will jump from\r\nisland to island . After that, he will continue jumping according to the\r\nfollowing rule. Let be the length of the previous jump, that is, if his\r\nprevious jump was from island to island , let . He will perform a jump\r\nof length , or to the east. That is, he will jump to island , or (if\r\nthey exist). The length of a jump must be positive, that is, he cannot\r\nperform a jump of length when . If there is no valid destination, he\r\nwill stop jumping. Mr. Kitayuta will collect the gems on the islands\r\nvisited during the process. Find the maximum number of gems that he can\r\ncollect.\r\n",
    "solutions": [
        "#include<cstdio>\n//#include<map>\n#include<queue>\nusing namespace std;\n//map<pair<int,int>,int> dp;\nint dp[30010][2100];\npriority_queue<pair<int,int> >Q;\nint gems[40000];\nint N,D;\nint bktk(int a,int b)\n{\n\tif(a>30000 || b==0) return 0;\n\treturn gems[a]+max(max(bktk(a+b,b),bktk(a+b+1,b+1)),bktk(a+b-1,b-1));\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&D);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tgems[t]++;\n\t}\n\tif(D>2020)\n\t{\n\t\tprintf(\"%d\",bktk(D,D));\n\t\treturn 0;\n\t}\n\tint maxv=gems[D]+1;\n\tdp[D][D]=gems[D]+1;\n\tfor(int i=D+1;i<=30000;i++)\n\t{\n\t\t//if(i%10==0) printf(\"%d\",i);\n\t\tfor(int j=1;j<2050;j++)\n\t\t{\n\t\t\tif(i-j<0) break;\n\t\t\tdp[i][j]=0;\n\t\t\tif(dp[i-j][j-1]) dp[i][j]=dp[i-j][j-1];\n\t\t\tif(dp[i-j][j]) dp[i][j]=max(dp[i][j],dp[i-j][j]);\n\t\t\tif(dp[i-j][j+1]) dp[i][j]=max(dp[i][j],dp[i-j][j+1]);\n\t\t\tif(dp[i][j]>0) dp[i][j]+=gems[i];\n\t\t\tmaxv=max(maxv,dp[i][j]);\n\t\t\t//printf(\"%d\",dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\",maxv-1);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Mr. Kitayuta, the Treasure Hunter.json",
    "editorial_link": "https://codeforces.com/blog/entry/15889",
    "editorial": "[Problem] Since it is hard to summarize this problem, please refer to\r\nthe official statement. (Problem by yosupo) Below is the explanation\r\nfrom yosupo, translated by me. [From here] Let be the number of the\r\nislands (that is, ). First, let us describe a solution with time and\r\nmemory complexity of . We will apply Dynamic Programming. let be the\r\nnumber of the gems that Mr. Kitayuta can collect after he jumps to\r\nisland , when the length of his previous jump is (let us assume that he\r\nhave not collect the gems on island ). Then, you can calculate the\r\nvalues of the table by the following: This solution is unfeasible in\r\nterms of both time and memory. However, the following observation makes\r\nit an Accepted solution: there are only values of that we have to\r\nconsider, which are and . Why? First, let us find the upper bound of .\r\nSuppose Mr. Kitayuta always performs the \"\" jump (: the length of the\r\nprevious jump). Then, he will reach the end of the islands before he\r\nperforms a jump of length , because. Thus, he will never be able to\r\nperform a jump of length or longer. Next, let us consider the lower\r\nbound of in a similar way. If , then obviously he will not be able to\r\nperform a jump of length or shorter, because the length of a jump must\r\nbe positive. Suppose Mr. Kitayuta always performs the \"\" jump, where .\r\nThen, again he will reach the end of the islands before he performs a\r\njump of length , because. Thus, he will never be able to perform a jump\r\nof length or shorter. Therefore, we have obtained a working solution:\r\nsimilar to the one, but we will only consider the value of between and .\r\nThe time and memory complexity of this solution will be , since the\r\nvalue \"\" is slightly larger than . This solution can be implemented by,\r\nfor example, using a \"normal\" two dimensional array with a offset like\r\nthis: dp[i][j - offset]. The time limit is set tight in order to fail\r\nmost of naive solutions with search using std::map or something, so\r\nusing hash maps (unordered_map) will be risky although the complexity\r\nwill be the same as the described solution. [End] The writer\u00e2\u0080\u0099s code\r\n(memoized recursion, C++)\r\n"
}