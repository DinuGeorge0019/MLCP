{
    "link": "https://codeforces.com//contest/1058/problem/E",
    "problemId": "223737",
    "problem_idx": "E",
    "shortId": "1058E",
    "contest_number": "1058",
    "problem_submissions": {
        "F": [
            43329652,
            43322741,
            43327075,
            43339320,
            43397318
        ],
        "E": [
            43317169,
            43335127,
            43311536,
            43318971,
            43319046,
            43349236,
            43325041,
            43322181,
            43322626,
            43309860,
            43322794,
            43327406,
            43321904,
            43323656,
            43323747,
            43323713,
            43316209,
            43327281,
            43327505
        ],
        "B": [
            43314909,
            43299015,
            43298589,
            43304743,
            43300553,
            43310414,
            43301962,
            43300188,
            43303702,
            43317695,
            43301396,
            43299393,
            43301629,
            43300037,
            43301041,
            43302979,
            43330380,
            43303019,
            43303281
        ],
        "C": [
            43311113,
            43302266,
            43300372,
            43301786,
            43303858,
            43309140,
            43303996,
            43302098,
            43308312,
            43301537,
            43306280,
            43302496,
            43303833,
            43303884,
            43307063,
            43311748,
            43303475,
            43307737,
            43305316
        ],
        "D": [
            43306998,
            43306866,
            43307236,
            43307768,
            43312416,
            43307189,
            43309783,
            43309198,
            43312128,
            43330363,
            43309334,
            43310807,
            43315529,
            43315808,
            43314759,
            43307976,
            43322616,
            43315377,
            43313629
        ],
        "A": [
            43304464,
            43296152,
            43295312,
            43296932,
            43295838,
            43311418,
            43296719,
            43295347,
            43301760,
            43297317,
            43296398,
            43295888,
            43295686,
            43295956,
            43297191,
            43296417,
            43297679,
            43297174,
            43295748
        ]
    },
    "name": "E. Vasya and Good Sequences",
    "statement": "Vasya has a sequence a consisting of n integers a_1, a_2,\r\ndots, a_n. Vasya may pefrom the following operation: choose some number\r\nfrom the sequence and swap any pair of bits in its binary\r\nrepresentation. For example, Vasya can transform number 6 (\r\ndots 00000000110_2) into 3 (\r\ndots 00000000011_2), 12 (\r\ndots 000000001100_2), 1026 (\r\ndots 10000000010_2) and many others. Vasya can use this operation any\r\n(possibly zero) number of times on any number from the sequence.Vasya\r\nnames a sequence as one, if, using operation mentioned above, he can\r\nobtain the sequence with bitwise exclusive or of all elements equal to\r\n0.For the given sequence a_1, a_2,\r\nldots, a_n Vasya\u2019d like to calculate number of integer pairs (l, r) such\r\nthat 1\r\nle l\r\nle r\r\nle n and sequence a_l, a_{l + 1},\r\ndots, a_r is good.\r\n",
    "solutions": [
        "//Williams Wu\n/*#include <EGE.h> //\ufffd\ufffd\u037c\u0377\ufffd\u013c\ufffd\n#define SHOW_CONSOLE*/\n/*#include <cstdio> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <iostream> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <algorithm> //STL\u0368\ufffd\ufffd\ufffd\u3de8\n#include <cmath> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0467\ufffd\ufffd\ufffd\ufffd\n#include <cstdlib> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ueeaf\ufffd\ufffd\ufffd\ufffd\ufffd\u06b4\ufffd\ufffd\ufffd\u4eaf\ufffd\ufffd\n#include <cstring> //\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <string> //\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <ctime> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02b1\ufffd\ufffd\u013a\ufffd\ufffd\ufffd*/\n/*#include <bitset> //STL\u03bb\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <cstype> //\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <cerrno> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <complex> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <clocale> //\ufffd\ufffd\ufffd\u5c7e\ufffd\u063b\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <deque> //STL\u02eb\ufffd\u02f6\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <exception> //\ufffd\ucce3\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <fstream> //\ufffd\u013c\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <functional> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u3eaf\ufffd\ufffd(\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd)\n#include <limits> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u05b5\ufffd\ufffd\ufffd\ufffd\n#include <listt> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\u0431\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <mapp> //STL\u04f3\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <iomanip> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <ios> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\u05a7\ufffd\ufffd\n#include <iosfwd> //\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\u03f5\u0373\u02b9\ufffd\u00f5\ufffd\u01f0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <istream> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <ostream> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <queue> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <sett> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <sstream> //\ufffd\ufffd\ufffd\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <stackk> //STL\ufffd\ufffd\u057b\ufffd\ufffd\ufffd\ufffd\n#include <stdexcept> //\ufffd\ufffd\u05fc\ufffd\ucce3\ufffd\ufffd\n#include <streambuf> //\ufffd\u05f2\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\u05a7\ufffd\ufffd\n#include <utility> //STL\u0368\ufffd\ufffd\u0123\ufffd\ufffd\ufffd\ufffd\n#include <vector> //STL\ufffd\ufffd\u032c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <cwchar.h> //\ufffd\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <cwctype.h> //\ufffd\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(u,v,nxt) for(int u=(v);(u)<=(nxt);(u)++)\n#define rep_(u,v,nxt) for(int u=(v);(u)<(nxt);(u)++)\n#define repf(u,v,nxt) for(int u=(v);(u)>=(nxt);(u)--)\n#define repf_(u,v,nxt) for(int u=(v);(u)>(nxt);(u)--)\n#define inf 0x3f3f3f3f  //0x7fffffff\n#define cle(u) memset(u,0,sizeof(u))\n#define clemin(u) memset(u,-1,sizeof(u))\n#define clemax(u) memset(u,0x3f,sizeof(u))  //127\nconst double PI=3.14159265358979323846264338327950288419716939937510;\nconst double E=2.7182818284590452353602874713526624977572470936999596;\nconst double eps=0.000000001;\ntypedef long long LL;\ninline int max(int u,int v){return u>v?u:v;}\ninline int min(int u,int v){return u<v?u:v;}\ninline LL gcd(LL u,LL v){return v?gcd(v,u%v):u;}\n///////////////////////optimize//////////////////////////\ntemplate <typename T>\ninline void read(T& u){char id;u=0;bool used=0;id=getchar();\nwhile(id>'9'||id<'0'){if(id=='-')used=1;id=getchar();}\nwhile((id<='9'&&id>='0')){u=u*10+id-'0';id=getchar();}if(used)u*=-1;}\ntemplate <typename T>\ninline void read(T& u,T& v){read(u);read(v);}\ntemplate <typename T>\ninline void read(T& u,T& v,T& tmp){read(u);read(v);read(tmp);}\n/////////////////variables&functions/////////////////////\n\nint dp[500100][2],a[500100],b[500100];\nLL ans=0;\n\nint main()\n{\n    int n;\n    read(n);\n    rep(i,1,n)\n    {\n        LL x;\n        read(x);\n        while(x) \n        {\n            a[i]+=(x&1);\n            x>>=1;\n        }\n        b[i]=b[i-1]+a[i];\n    }\n    dp[0][0]=1;\n    rep(i,1,n)\n    {\n        dp[i][0]=dp[i-1][0];\n        dp[i][1]=dp[i-1][1];\n        dp[i][b[i]&1]++;\n    }\n    rep(i,1,n)\n    {\n        int tmp=max(1,i-119);\n        int sum=0,maxx=0;\n        repf(j,i,tmp)\n        {\n            maxx=max(maxx,a[j]);\n            sum+=a[j];\n            if((!(sum&1))&&maxx<=(sum>>1)) ++ans;\n        }\n        if(tmp>=2) ans+=dp[tmp-2][b[i]&1];\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Vasya and Good Sequences.json",
    "editorial_link": "https://codeforces.com/blog/entry/62013",
    "editorial": "Since we can swap any pair of bits in the number, so all we need to know is just the number of ones in its binary representation. Let create array b1,b2,\u0085,bn\n, where bi\n is number of ones in binary representation of ai\n. Forget about array a\n, we will work with array b\n.\n\nLet's find a way to decide whether fixed segment is good or not. It can be proven that two conditions must be met. At first, sum of bi\n at this segment should be even. At second, maximal element should be lower or equal to the sum of all other elements.\n\nWe will iterate over left borders of subsegments in descending order and for each left border l\n calculate number of right borders r\n such that [l,r]\n is good.\n\nLet's, as first, \"forget\" about condition on maximum and calculate cntAll(l)\n \u0097 number of right borders r\n, such that sum on segment [l,r]\n is even and left border l\n is fixed. We can calculate it by counting S0\n and S1\n \u0097 the number of suffixes of array with even sum of bi\n and number of suffixes with odd sum. If the current sum ?i=lnbi\n is even then cntAll(l)=S0\n since ?i=lrbi=?i=lnbi??i=r+1nbi\n. If ?i=lnbi\n is odd then cntAll(l)=S1\n.\n\nSince we forgot about condition on maximum, some bad segments were counted. Since ai?1018\n then bi<61\n. That's why if length of the segment ?61\n, condition on the maximum is always true. So, for a fixed l\n we can iterate over all right borders in the [l,l+61]\n and subtract number of segments with even sum and too large maximum (since these segments were counted in the answer)."
}