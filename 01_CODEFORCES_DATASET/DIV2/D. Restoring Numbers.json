{
    "link": "https://codeforces.com//contest/509/problem/D",
    "problemId": "21540",
    "problem_idx": "D",
    "shortId": "509D",
    "contest_number": "509",
    "problem_submissions": {
        "F": [
            9650295,
            9648525,
            9652941,
            66412652,
            9656510,
            9654779,
            9656634
        ],
        "D": [
            9649357,
            9654774,
            17987388,
            9655232,
            9650962,
            9652519,
            9653543,
            9654747,
            9652061,
            9654982,
            9653984,
            9647661,
            9657026,
            9650855
        ],
        "E": [
            9647331,
            9646822,
            9648254,
            9648062,
            9650747,
            9650969,
            9652383,
            9648899,
            9651327,
            9650674,
            9650867,
            9649973,
            9651180,
            9649729,
            9651615,
            9648041,
            9654967,
            9654814,
            9654669,
            9653966,
            9647539
        ],
        "C": [
            9645828,
            9652330,
            9645693,
            9644588,
            9646725,
            9649235,
            9647186,
            9656672,
            9648094,
            9645838,
            9646105,
            9648771,
            9647552,
            9649596,
            9652387,
            9650184,
            9650446
        ],
        "B": [
            9642318,
            9650812,
            9644457,
            9646310,
            9647229,
            9643332,
            9648725,
            9645322,
            9642950,
            9643872,
            9643385,
            9643757,
            9643187,
            9643245,
            9644721,
            9645020,
            9642364,
            9643723,
            9651476
        ],
        "A": [
            9640468,
            9644536,
            9640418,
            9640550,
            9640578,
            9642285,
            9643656,
            9644283,
            9640433,
            9640454,
            9641139,
            9641249,
            9640654,
            9640465,
            9642716,
            9641084,
            9640702,
            9640994,
            9640877
        ]
    },
    "name": "D. Restoring Numbers",
    "statement": "Vasya had two arrays consisting of non-negative integers: of size and of\r\nsize . Vasya chose a positive integer and created an matrix using the\r\nfollowing formula:Vasya wrote down matrix on a piece of paper and put it\r\nin the table.A year later Vasya was cleaning his table when he found a\r\npiece of paper containing an matrix . He remembered making a matrix one\r\nday by the rules given above but he was not sure if he had found the\r\npaper with the matrix from those days. Your task is to find out if the\r\nmatrix that youâ€™ve found could have been obtained by following these\r\nrules and if it could, then for what numbers it is possible.\r\n",
    "solutions": [
        "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\n#define N 110\n#define INF 1100000000\nlong long n,m,pp,w[N][N],a[N],b[N];\nint main(){\n    cin>>n>>m;\n    pp=-1;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)cin>>w[i][j];\n    for(int i=2;i<=n;i++){\n      long long t1=INF,t2=INF;\n      for(int j=1;j<=m;j++){\n              long long t=w[i][j]-w[i-1][j];\n              if(t>=0){\n                if(t1!=INF && t1!=t){printf(\"NO\\n\");return 0;}\n                t1=t;\n                }\n              else{\n                if(t2!=INF && t2!=t){printf(\"NO\\n\");return 0;}\n                t2=t;\n                }\n              }\n      if(t1!=INF && t2!=INF){\n        long long t=t1-t2;\n        if(pp!=-1 && pp!=t){printf(\"NO\\n\");return 0;}\n        pp=t;\n        a[i]=t1;\n      }\n      else\n      if(t1!=INF)a[i]=t1;\n      else a[i]=t2;\n    }\n    for(int i=2;i<=n;i++)a[i]+=a[i-1];\n    long long t=0;\n    for(int i=1;i<=n;i++)t=min(t,a[i]);\n    for(int i=1;i<=n;i++)a[i]-=t;\n    \n    for(int j=2;j<=m;j++){\n      long long t1=INF,t2=INF;\n      for(int i=1;i<=n;i++){\n              long long t=w[i][j]-w[i][j-1];\n              if(t>=0){\n                if(t1!=INF && t1!=t){printf(\"NO\\n\");return 0;}\n                t1=t;\n                }\n              else{\n                if(t2!=INF && t2!=t){printf(\"NO\\n\");return 0;}\n                t2=t;\n                }\n              }\n      if(t1!=INF && t2!=INF){\n        long long t=t1-t2;\n        if(pp!=-1 && pp!=t){printf(\"NO\\n\");return 0;}\n        pp=t;\n        b[j]=t1;\n      }\n      else\n      if(t1!=INF)b[j]=t1;\n      else b[j]=t2;\n    }\n    for(int j=2;j<=m;j++)b[j]+=b[j-1];\n    t=0;\n    for(int i=1;i<=m;i++)t=min(t,b[i]);\n    for(int i=1;i<=m;i++)b[i]-=t;\n    if(a[1]+b[1]>w[1][1]){printf(\"NO\\n\");return 0;}\n    t=w[1][1]-a[1]-b[1];\n    for(int i=1;i<=m;i++)b[i]+=t;\n    \n    if(pp==-1)pp=INF;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=m;j++)\n        if((a[i]+b[j])%pp!=w[i][j]){printf(\"NO\\n\");return 0;}\n    printf(\"YES\\n\");\n    cout<<pp<<endl;\n    for(int i=1;i<=n;i++)cout<<a[i]<<\" \";cout<<endl;\n    for(int i=1;i<=m;i++)cout<<b[i]<<\" \";cout<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Restoring Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/16119",
    "editorial": "First we note that if the sequences and are a valid solution, then so\r\nare the sequences and for any integer . This means that we can consider\r\nto be equal to 0 which allows us to recover the sequence by simply\r\ntaking the first row of the matrix. Knowing we can also recover (for\r\nexample by subtracting from the first column of the matrix) At this\r\nstage we allow and to contain negative numbers, which can be later fixed\r\nby adding a sufficient amount of times. Now we consider the error matrix\r\n: . If consists entirely of 0s, then we ve found our solution by taking\r\na sufficiently large . That is: . Otherwise, we note that which implies\r\nthat is a divisor of . The greatest such number is itself, so all that\r\nremains is to check if is strictly greater than all the elements of the\r\nmatrix . If that is the case, then we ve found our solution by setting\r\nUnable to parse markup [type=CF_TEX] Prepared by: Kostroma,\r\nriadwawAuthor of editorial: riadwaw\r\n",
    "hint": []
}