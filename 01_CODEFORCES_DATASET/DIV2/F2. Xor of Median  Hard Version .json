{
    "link": "https://codeforces.com//contest/2056/problem/F2",
    "problemId": "3150798",
    "problem_idx": "F2",
    "shortId": "2056F2",
    "contest_number": "2056",
    "problem_submissions": {
        "F2": [
            301545587,
            301509040,
            301738450,
            302033567
        ],
        "F1": [
            301461815,
            301455964,
            301458356,
            301426872,
            301434246,
            302031432,
            302030623,
            301580078,
            301600084
        ],
        "E": [
            301439440,
            301447920,
            301443059,
            301433627,
            301428331,
            301444669,
            301439558,
            301439957,
            301443503,
            301447455,
            301451147,
            301446991,
            301456228,
            301452444,
            301427254,
            301456788,
            301448385
        ],
        "D": [
            301411463,
            301430952,
            301426584,
            301413553,
            301414046,
            301415062,
            301415941,
            301414692,
            301446695,
            301418999,
            301418932,
            301422889,
            301412134,
            301417642,
            301411530,
            301417000,
            301444048,
            301424366,
            301426240
        ],
        "C": [
            301399544,
            301411500,
            301416896,
            301418700,
            301401301,
            301404995,
            301400708,
            301399472,
            301417939,
            301403985,
            301402887,
            301398665,
            301399127,
            301403882,
            301404504,
            301408969,
            301407435,
            301401039,
            301402939
        ],
        "B": [
            301393848,
            301392518,
            301400501,
            301395217,
            301391544,
            301398396,
            301394970,
            301396057,
            301401319,
            301397018,
            301398125,
            301391015,
            301394435,
            301395913,
            301394898,
            301392345,
            301400120,
            301395871,
            301401973
        ],
        "A": [
            301388610,
            301388749,
            301390918,
            301392589,
            301387805,
            301391122,
            301388287,
            301390050,
            301390421,
            301388003,
            301389658,
            301387952,
            301388733,
            301389417,
            301387733,
            301388087,
            301390776,
            301389692,
            301388580
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138487",
    "editorial": "SolutionThe order of the sequence doesn’t matter, so let’s fix the\r\nsequence and calculate its contribution to the answer.For a fixed , the\r\nnumber of ways to order is . By Lucas’s theorem the contribution is odd\r\niff for each set bit in there is exactly one such that has this bit set,\r\nand . In other words, has to partition all set bits in .Since partitions\r\nthe bits of , there will be which has it’s most significant bit. This\r\nmeans that , so will always be the median.Suppose there are non-zero\r\nelements in . We can partition all set bits of into non-empty\r\nsubsequences and then choose which of the numbers will occur.The only\r\ntime we use the value of is when we partition all of it’s set bits into\r\nsubsequences. That means that the answer only depends on the number of\r\nset bits in , not on itself.So let’s fix as the number of non-zero\r\nelements in and as the median. Denote as the number of set bits in .\r\nThere are ways to partition the bits into non-empty subsequences, where\r\ndenotes Stirling number of the second kind. There are ways to choose\r\nwhich other elements will have non-zero , because the median will always\r\nhave the largest value and non-zero must be non-decreasing.The answer is\r\nthen , which we can calculate in , which solves the easy version.To\r\nsolve the hard version we can use Lucas’s theorem again to get that the\r\ncontribution of to the answer is the XOR of over all submasks of . We\r\ncan limit to be between and .That means that only last bits of determine\r\nwhether contributes something to the answer. We can find which of of\r\nthem will have an odd contribution by setting , and calculating it’s\r\nSOS-dp. Then for fixed last bits it is easy to find the XOR of all with\r\nthose bits. Note that is odd iff , which we can derive from the\r\nrecurrence, combinatorics, google or OEIS.This solves the problem in .\r\n",
    "name": "F2. Xor of Median  Hard Version ",
    "statement": "A sequence a of n integers is called if the following condition holds:\r\nLet\r\ntext{cnt}_x be the number of occurrences of x in sequence a. For all\r\npairs 0\r\nle i < j < m, at least one of the following has to be true:\r\ntext{cnt}_i = 0,\r\ntext{cnt}_j = 0, or\r\ntext{cnt}_i\r\nle\r\ntext{cnt}_j. In other words, if both i and j are present in sequence a,\r\nthen the number of occurrences of i in a is less than or equal to the\r\nnumber of occurrences of j in a. You are given integers n and m.\r\nCalculate the value of the bitwise XOR of the median^{\r\ntext{ }} of all good sequences a of length n with 0\r\nle a_i < m. Note that the value of n can be very large, so you are given\r\nits binary representation instead.^{\r\ntext{ }}The median of a sequence a of length n is defined as the\r\nleft\r\nlfloor\r\nfrac{n + 1}{2}\r\nright\r\nrfloor-th smallest value in the sequence.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define N 200005#define M 505#define LL long long#define inf 21474836477777777ll#define LD long double#define eps 1e-6using namespace std;int n,K,m,a[N],pre[N][2],suf[N][2];char s[N];const int p=998244353;// inline void add(int x,int y){son[++tot]=y,nxt[tot]=fir[x],fir[x]=tot;} inline int P(int x,int y){int z=1;while(y){if(y&1) z=1ll*z*x%p;y>>=1,x=1ll*x*x%p;} return z;}// inline void A(int &x,int y){x+=y,(x>=p)&&(x-=p,0),(x<0)&&(x+=p,0);}// inline void mul(int &x,int y){x=1ll*x*y%p;}inline void solve(int tc){    cin>>K>>m>>(s+1),n=0;for(int i=1;i<=K;i++) n+=s[i]-'0';int ans=0;    m--;for(int i=0;i<=min(n-1,m);i++) if(!((n-i-1)&(i>>1))){        pre[30][0]=1,pre[30][1]=0;for(int j=29;~j;j--) if((1<<j)&i) if(!((1<<j)&m)) pre[j][0]=0,pre[j][1]=pre[j+1][1];else pre[j][0]=pre[j+1][0],pre[j][1]=pre[j+1][1];        else pre[j][0]=pre[j+1][0],pre[j][1]=(pre[j+1][1]<<1)+(((m>>j)&1)&pre[j][0]);        if((i&1)&&(!(m&1))) suf[0][0]=0;else suf[0][0]=1;if((!(i&1))&&(m&1)) suf[0][1]=1;else suf[0][1]=0;        int res=(i&1)?0:1;for(int j=1;j<=29;res++,j++) if((1<<j)&i){a[j]=res,res--;if(!((1<<j)&m)) suf[j][0]=suf[j][1]=0;else suf[j][0]=suf[j-1][0],suf[j][1]=suf[j-1][1];}        else a[j]=res,suf[j][0]=suf[j-1][0],suf[j][1]=suf[j-1][1]+(((1<<j)&m)?(1<<res):0);        // cout<<i<<' '<<suf[0][0]<<' '<<suf[0][1]<<'\\n';        for(int j=0;j<=29&&(1<<j)<=m;j++) if(((1<<j)&m)){            if(!j){if(pre[j+1][0]^(pre[j+1][1]&1)) ans^=1;continue;}             if(((a[j]?0:1)&pre[j+1][1])^(pre[j+1][0]&((suf[j-1][1]&1)^suf[j-1][0]))) ans^=(1<<j);        }        else{if(!j){if(pre[j+1][1]&1) ans^=1;continue;} if((a[j]?0:1)&pre[j+1][1]) ans^=(1<<j);}        // cout<<i<<' '<<ans<<'\\n';    } cout<<ans<<'\\n';}//{n,i} 第二类斯特林数 parity:!((n-i)&((i-1)/2))int main(){    // freopen(\"data.in\",\"r\",stdin);    ios::sync_with_stdio(false);    cin.tie(0); cout.tie(0);    int tc=1;    cin>>tc;    while(tc--) solve(tc);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Xor of Median  Hard Version .json",
    "hint": [
        "Hint 1 The order of the sequence doesn't matter. What if we fix the sequence and then calculate its contribution to the answer?",
        "Hint 2 By Lucas's theorem the contribution is odd iff for each set bit in there is exactly one such that has this bit set, and . In other words, has to partition all set bits in . For a fixed with an odd contribution, what will be the median?",
        "Hint 3 There is a very big element in .",
        "Hint 4 Since partitions the bits of , there will be which has it's most significant bit. This means that , so will always be the median.",
        "Hint 5 Suppose there are non-zero elements in . We can partition all set bits of into non-empty subsequences and then choose which of the numbers will occur. How can we calculate the answer now?",
        "Hint 6 The only time we use the value of is when we partition all of it's set bits into subsequences. That means that the answer only depends on the number of set bits in , not on itself. This allows us to solve the easy version by fixing the value of and the value of the median.",
        "Hint 7 To solve the hard version use Lucas's theorem again and do digit dp or SOS-dp."
    ]
}