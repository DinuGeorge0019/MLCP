{
    "link": "https://codeforces.com//contest/1139/problem/B",
    "problemId": "317127",
    "problem_idx": "B",
    "shortId": "1139B",
    "contest_number": "1139",
    "problem_submissions": {
        "F": [
            51641186,
            51646762,
            109435140,
            51647787,
            51858420,
            51784923,
            51643584,
            51652352
        ],
        "E": [
            51636168,
            51644116,
            51640560,
            51642622,
            51644323,
            51644757,
            51643892,
            51845610,
            51647025,
            51647374,
            51647485,
            51647776,
            51635005,
            51638235,
            51639153,
            51639250,
            51638517,
            72001197,
            51662877
        ],
        "D": [
            51642032,
            51635420,
            51636603,
            51637368,
            51636440,
            51639381,
            51643782,
            51845601,
            51642527,
            51640197,
            51643918,
            51642858,
            51827413,
            51649480,
            51908875,
            51638589,
            51637429
        ],
        "C": [
            51630148,
            51629252,
            51628342,
            51628293,
            51633819,
            51633228,
            51629514,
            51845597,
            51631001,
            51631632,
            51635078,
            51636507,
            51631091,
            51631860,
            51631510,
            51630390,
            51632287,
            51636060,
            51629126,
            51630229
        ],
        "B": [
            51627583,
            51626711,
            51625352,
            51626461,
            51626658,
            51627929,
            51626015,
            51845593,
            51628451,
            51628233,
            51627332,
            51628138,
            51627935,
            51626813,
            51626814,
            51626137,
            51629187,
            51627498,
            51626295,
            51627320
        ],
        "A": [
            51623887,
            51624025,
            51623702,
            51623814,
            51624826,
            51624571,
            51623799,
            51845581,
            51625089,
            51624357,
            51625210,
            51626607,
            51624278,
            51623873,
            51625020,
            51624141,
            51624276,
            51623680,
            51624248,
            51623966
        ]
    },
    "name": "B. Chocolates",
    "statement": "You went to the store, selling n types of chocolates. There are a_i\r\nchocolates of type i in stock.You have unlimited amount of cash (so you\r\nare not restricted by any prices) and want to buy as many chocolates as\r\npossible. However if you buy x_i chocolates of type i (clearly, 0\r\nle x_i\r\nle a_i), then for all 1\r\nle j < i at least one of the following must hold: x_j = 0 (you bought\r\nzero chocolates of type j) x_j < x_i (you bought less chocolates of type\r\nj than of type i) For example, the array x = [0, 0, 1, 2, 10] satisfies\r\nthe requirement above (assuming that all a_i\r\nge x_i), while arrays x = [0, 1, 0], x = [5, 5] and x = [3, 2]\r\ndon\u2019t.Calculate the maximum number of chocolates you can buy.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef long long llong;\ntypedef pair<int, int> pii;\n\nint n;\nint A[200001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> A[i];\n    llong sum = 0;\n    int mx = 1e9 + 1;\n    for (int i = n; i > 0; --i) {\n        --mx;\n        mx = min(mx, A[i]);\n        if (mx <= 0) break;\n        sum += mx;\n    }\n    printf(\"%lld\\n\", sum);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Chocolates.json",
    "editorial_link": "https://codeforces.com//blog/entry/66101",
    "editorial": "It is optimal to proceed greedily from the back of the array. If we have\r\ntaken candies of the type, then we can only take candies for type . If\r\nthis value is less than zero, we take from here.Overall Complexity:\r\n"
}