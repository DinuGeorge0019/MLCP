{"link": "https://codeforces.com//contest/1332/problem/C", "problemId": "578663", "problem_idx": "C", "shortId": "1332C", "contest_number": "1332", "problem_submissions": {"G": [74991585, 75037266, 77351427], "F": [74972207, 74968358, 74971720, 74973348, 74978859, 74982724, 74982735, 74986275, 74983269, 74987837, 74986665, 74991793, 74983515, 74979782, 74972196, 74981046, 74990576, 74985479, 74988801, 74990228], "E": [74961161, 74955523, 74954162, 74962710, 74964351, 74963597, 74954423, 74965477, 74965579, 74964400, 74967235, 74963711, 74965887, 74966494, 74989155, 74967207, 74974070, 74976881, 74974061, 74976693], "D": [74952985, 74945715, 74946665, 74947888, 74950207, 74948751, 74939741, 74946829, 74947089, 74946824, 74948968, 74945728, 74948946, 74959413, 74956458, 74959082, 74952408, 74962224, 74953788, 74952090], "C": [74942005, 74937624, 74936343, 74941037, 74943187, 74945247, 74948388, 74939023, 74936776, 74940250, 74942517, 74933392, 74937059, 74947682, 74933984, 74947387, 74935824, 74944324, 74945827, 74930594], "B": [74937320, 74934172, 74933187, 74935530, 74936050, 74936599, 74943429, 74933909, 74931708, 74932124, 74935133, 74939689, 74933624, 74939412, 74938935, 74936225, 74945372, 74938477, 74936882, 74941959], "A": [74930167, 74929341, 74931394, 74930114, 74930077, 74932449, 74934529, 74928977, 74928761, 74928547, 74928820, 74928500, 74928970, 74929648, 74959446, 74929583, 74931416, 74933421, 74928735, 74938510]}, "name": "C. K-Complete Word", "statement": "Word s of length n is called k-complete if s is a palindrome, i.e.\r\ns_i=s_{n+1-i} for all 1\r\nle i\r\nle n; s has a period of k, i.e. s_i=s_{k+i} for all 1\r\nle i\r\nle n-k. For example, \"\" is a 3-complete word, while \"\" is not.Bob is\r\ngiven a word s of length n consisting of only lowercase Latin letters\r\nand an integer k, such that n is divisible by k. He wants to convert s\r\nto any k-complete word.To do this Bob can choose some i (1\r\nle i\r\nle n) and replace the letter at position i with some other lowercase\r\nLatin letter.So now Bob wants to know the minimum number of letters he\r\nhas to replace to convert s to any k-complete word.Note that Bob can do\r\nzero changes if the word s is already k-complete.You are required to\r\nanswer t test cases .\r\n", "solutions": ["#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\nconst int N = 2e5 + 5;\n\nint n, k, cnt[N][26], ans;\nchar s[N];\n\nvoid work()\n{\n\tread(n); read(k); ans = n;\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= k; i++) memset(cnt[i], 0, sizeof(cnt[i]));\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint len = (i - 1) % k + 1;\n\t\tif (k - len + 1 < len) len = k - len + 1;\n\t\tcnt[len][s[i] - 'a']++;\n\t}\n\tfor (int i = 1; i <= (k + 1 >> 1); i++)\n\t{\n\t\tint d = 0;\n\t\tfor (int c = 0; c < 26; c++) d = std::max(d, cnt[i][c]);\n\t\tans -= d;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tint T; read(T);\n\twhile (T--) work();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "greedy", "implementation", "strings"], "dificulty": "1500", "interactive": false}