{
    "link": "https://codeforces.com//contest/1554/problem/C",
    "problemId": "1061273",
    "problem_idx": "C",
    "shortId": "1554C",
    "contest_number": "1554",
    "problem_submissions": {
        "E": [
            124159772,
            124162157,
            124167652,
            124165214,
            124231575,
            124169217,
            124380405,
            124171964,
            124171215,
            124172755,
            124172343,
            124148786,
            124173544,
            124173029,
            124172156,
            124722686,
            124178015,
            124181128,
            124171059,
            124379676,
            124174188,
            124167350,
            124176198,
            124182633
        ],
        "C": [
            124139083,
            124143057,
            124140544,
            124149111,
            124145223,
            124380376,
            124143439,
            124145496,
            124139702,
            124142795,
            124144864,
            124142215,
            124143699,
            124149801,
            124722675,
            124143912,
            124138305,
            124142838,
            124379535,
            124143555,
            124137768,
            124156436,
            124140590
        ],
        "D": [
            124138945,
            124146593,
            124147043,
            124143497,
            124147282,
            124380395,
            124147023,
            124143045,
            124146870,
            124147125,
            124165711,
            124147949,
            124154200,
            124153233,
            124722679,
            124147474,
            124150406,
            124141042,
            124379671,
            124146642,
            124143310,
            124148096,
            124148678
        ],
        "B": [
            124134751,
            124135695,
            124133759,
            124135797,
            124133509,
            124380367,
            124137647,
            124131777,
            124134150,
            124255622,
            124137477,
            124153106,
            124136364,
            124136471,
            124137060,
            124722664,
            124134959,
            124141246,
            124133658,
            124379482,
            124138040,
            124170775,
            124151266,
            124133287
        ],
        "A": [
            124132044,
            124128630,
            124128905,
            124135949,
            124129333,
            124380302,
            124134132,
            124133855,
            124129278,
            124128741,
            124153971,
            124131823,
            124130363,
            124130846,
            124722661,
            124128707,
            124142173,
            124128567,
            124379467,
            124129604,
            124168196,
            124139115,
            124128957
        ]
    },
    "name": "C. Mikasa",
    "statement": "You are given two integers n and m. Find the\r\noperatorname{MEX} of the sequence n\r\noplus 0, n\r\noplus 1,\r\nldots, n\r\noplus m. Here,\r\noplus is the bitwise XOR operator.\r\noperatorname{MEX} of the sequence of non-negative integers is the\r\nsmallest non-negative integer that doesn’t appear in this sequence. For\r\nexample,\r\noperatorname{MEX}(0, 1, 2, 4) = 3, and\r\noperatorname{MEX}(1, 2021) = 0.\r\n",
    "solutions": [
        "#include<cstdio>\n\nusing namespace std;\n\nint main()\n{\n\tint T=0;scanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tint n=0,m=0;scanf(\"%d%d\",&n,&m);m++;\n\t\tint ans=0;\n\t\tfor(int i=30;i>=0;i--)\n\t\t{\n\t\t\tif((m&(1<<i))&&!(n&(1<<i)))ans|=1<<i;\n\t\t\telse if((n&(1<<i))&&!(m&(1<<i)))break;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Mikasa.json",
    "editorial_link": "https://codeforces.com//blog/entry/93321",
    "editorial": "How can we check if is present in the sequence ? Think.If is present in\r\nthe sequence, then there must be some such that and , right?Did you know\r\nthat is equivalent to ?So we can just check if or not! Pretty simple!So\r\nthe modified problem is to find the smallest non-negative integer such\r\nthat . Can you solve it now?Think using bits.Let and be the -th bit of .\r\nWe will find the smallest such that .Letâs build greedily from the\r\nhighest bit to the lowest bit. Letâs say we will find the -th bit of and\r\nthe higher bits have already been generated. Obviously, we will try to\r\nmake this bit off if possible. When will it be impossible? Think.If , we\r\ncan set as . If and , we can break here by setting the remaining bits of\r\noff as no matter what the remaining bits of are, will always be greater\r\nthan . Finally, if and , we must set , as we have no other options.Check\r\nmy solution for more clarity. per test case.\r\n",
    "hint": []
}