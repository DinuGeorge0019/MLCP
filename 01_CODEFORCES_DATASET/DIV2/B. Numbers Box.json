{
    "link": "https://codeforces.com//contest/1447/problem/B",
    "problemId": "797263",
    "problem_idx": "B",
    "shortId": "1447B",
    "contest_number": "1447",
    "problem_submissions": {
        "F1": [
            98482074,
            98493054,
            99700638,
            99700288,
            98507770,
            98535197
        ],
        "E": [
            98471672,
            98487762,
            98462641,
            98467656,
            98474856,
            98475468,
            98466748,
            98471089,
            98474335,
            98473016,
            98472819,
            98475501,
            98476100,
            98473152,
            98480927,
            98480063,
            98483273,
            98472232,
            98484816
        ],
        "D": [
            98465943,
            98460161,
            98460032,
            98460272,
            98457345,
            98456392,
            98459724,
            98462491,
            98458555,
            98456607,
            98463156,
            98464783,
            98463338,
            98468636,
            98460203,
            98469147,
            98464911,
            98463572,
            98466107
        ],
        "C": [
            98461616,
            98454149,
            98456198,
            98455102,
            98451609,
            98450909,
            98449636,
            98454179,
            98454951,
            98450139,
            98456033,
            98456615,
            98452367,
            98462699,
            98462915,
            98451741,
            98459164,
            98457799,
            98456088
        ],
        "B": [
            98459424,
            98448840,
            98451090,
            98683205,
            98449593,
            98453136,
            98446655,
            98474948,
            98449629,
            98450999,
            98461566,
            98449722,
            98448167,
            106347351,
            98672986,
            98448001,
            98455222,
            98451056,
            98457032,
            98449675,
            98477349,
            98451673
        ],
        "A": [
            98453484,
            98445641,
            98444797,
            98683165,
            98445393,
            98446357,
            98444563,
            98446885,
            98447224,
            98445951,
            98458580,
            98444650,
            98444710,
            135934878,
            135934648,
            135925416,
            135925369,
            135925314,
            135925279,
            135925096,
            135925047,
            135924862,
            135924832,
            135924797,
            135924764,
            135924707,
            135924661,
            135924602,
            135924566,
            135924526,
            135924432,
            135924298,
            135924179,
            106344775,
            98672850,
            98445798,
            98445995,
            98446080,
            98454545,
            98452405,
            98445713,
            98447399
        ],
        "F2": [
            100134501,
            99704090
        ]
    },
    "name": "B. Numbers Box",
    "statement": "You are given a rectangular grid with n rows and m columns. The cell\r\nlocated on the i-th row from the top and the j-th column from the left\r\nhas a value a_{ij} written in it.You can perform the following operation\r\nany number of times (possibly zero): Choose any two adjacent cells and\r\nmultiply the values in them by -1. Two cells are called adjacent if they\r\nshare a side. Note that you can use a cell more than once in different\r\noperations.You are interested in X, the of all the numbers in the grid.\r\nWhat is the maximum X you can achieve with these operations?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T,N,M;\nint a[110][110];\n\nint solve(vector<int> &v, int d) {\n    sort(v.begin(), v.end());\n    int N = v.size();\n    int max_delta = 0, S = 0;\n    if (d == 1) {\n        S = v[0];\n        max_delta = -2 * v[0];\n    }\n    for (int i=d;i<N;i+=2) {\n        S += v[i];\n        if (i == N - 1) continue;\n        S += v[i + 1];\n        max_delta = max(max_delta, -2 * S);\n    }\n    //printf(\"%d %d\\n\",d,max_delta);\n    return S + max_delta;\n}\n\nint main() {\n    scanf(\"%d\",&T);\n    while(T--) {\n        scanf(\"%d%d\",&N,&M);\n        vector<int>v1,v2;\n        for (int i=1;i<=N;i++) {\n            for (int j=1;j<=M;j++) {\n                scanf(\"%d\",&a[i][j]);\n                if ((i + j) % 2 == 1) {\n                    v1.push_back(a[i][j]);\n                } else {\n                    v2.push_back(a[i][j]);\n                }\n            }\n        }\n        printf(\"%d\\n\", max(solve(v1, 0) + solve(v2, 0), solve(v1, 1) + solve(v2, 1)));\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Numbers Box.json",
    "editorial_link": "https://codeforces.com//blog/entry/82067",
    "editorial": "SolutionLet be the number of non-zero numbers in the grid, and letâs see\r\nwhat happens in different scenarios. both cells have negative numbers,\r\nthen goes down by . both cells have positive numbers, then goes up by .\r\none cell has a positive number while the other one has a negative\r\nnumber, then stays the same. It is important to notice that we can apply\r\nthis operation not only for the two neighboring cells, but for any two\r\nto achieve this effect we apply this operation on any path between the\r\ncells consecutively.The parity of never changes. So, for even the answer\r\nis the sum of the absolute value of all numbers, . Otherwise, one\r\nelement will not be positive in the end â so itâs best to choose the one\r\nwith minimum absolute value, , and subtract from the sum.The existence\r\nof zeroes doesnât really change anything, both formulas output the same\r\nvalue in such a case.This gives us a solution in\r\n",
    "hint": [
        "Hint We want to minimize the number of negative numbers as much as we can by applying the operations. What is the minimum possible number of those negatives?"
    ]
}