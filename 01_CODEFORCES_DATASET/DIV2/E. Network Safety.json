{
    "link": "https://codeforces.com//contest/1040/problem/E",
    "problemId": "215709",
    "problem_idx": "E",
    "shortId": "1040E",
    "contest_number": "1040",
    "problem_submissions": {
        "C": [
            42525959,
            42516403,
            42520218,
            42509951
        ],
        "E": [
            42518563,
            42515513,
            42516608,
            42523906,
            42523822,
            42524914,
            42516929,
            42524932,
            42514503,
            42511196,
            42518320,
            42524442,
            42528537
        ],
        "B": [
            42514292,
            42503342,
            42502589,
            42503781,
            42507515,
            42504172,
            42504545,
            42506438,
            42505683,
            42503118,
            42546497,
            42508433,
            42507210,
            42502341,
            42521565,
            42507357,
            42501900,
            42505960,
            42504857
        ],
        "A": [
            42508408,
            42500521,
            42500426,
            42504655,
            42500575,
            42500946,
            42519886,
            42500455,
            42501027,
            42501547,
            42500337,
            42501761,
            42500387,
            42500370,
            42517380,
            42500340,
            42502900,
            42500738,
            42500745
        ],
        "D": [
            42506377,
            42520704,
            42524366,
            42520672,
            42517604,
            42513292,
            42525930,
            42524271,
            42524410,
            42522170,
            42511068,
            42514990,
            42523580,
            42531287,
            42513155
        ]
    },
    "name": "E. Network Safety",
    "statement": "The Metropolis computer network consists of n servers, each has an\r\nencryption key in the range from 0 to 2^k - 1 assigned to it. Let c_i be\r\nthe encryption key assigned to the i-th server. Additionally, m pairs of\r\nservers are directly connected via a data communication channel. Because\r\nof the encryption algorithms specifics, a data communication channel can\r\nonly be considered safe if the two servers it connects have encryption\r\nkeys. The initial assignment of encryption keys is guaranteed to keep\r\nall data communication channels safe.You have been informed that a new\r\nvirus is actively spreading across the internet, and it is capable to\r\nchange the encryption key of any server it infects. More specifically,\r\nthe virus body contains some unknown number x in the same aforementioned\r\nrange, and when server i is infected, its encryption key changes from\r\nc_i to c_i\r\noplus x, where\r\noplus denotes the bitwise XOR operation.Sadly, you know neither the\r\nnumber x nor which servers of Metropolis are going to be infected by the\r\ndangerous virus, so you have decided to count the number of such\r\nsituations in which all data communication channels remain safe.\r\nFormally speaking, you need to find the number of pairs (A, x), where A\r\nis some (possibly empty) subset of the set of servers and x is some\r\nnumber in the range from 0 to 2^k - 1, such that when all servers from\r\nthe chosen subset A and none of the others are infected by a virus\r\ncontaining the number x, all data communication channels remain safe.\r\nSince this number can be quite big, you are asked to find its remainder\r\nmodulo 10^9 + 7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nmap<ll, int> MP;\nint Q = 1;\nvector<pii> adj[500005];\nll C[500005];\nset<int> S;\nint p[500005];\n\nll pw(int x) {\n   if(!x) return 1LL;\n   if(x & 1) return 2 * pw(x - 1) % MOD;\n   ll hf = pw(x / 2);\n   return hf * hf % MOD;\n}\n\nint par(int x) {\n   if(p[x] == x) return x;\n   return p[x] = par(p[x]);\n}\n\nint main() {\n   int N, M, K; scanf(\"%d%d%d\", &N, &M, &K);\n   ll X = (1LL << K);\n   for(int i = 1; i <= N; i++) scanf(\"%lld\", &C[i]);\n\n   for(int i = 0; i < M; i++) {\n      int u, v; scanf(\"%d%d\", &u, &v);\n      //printf(\"si%d %d\\n\", u, v);\n      ll x = C[u] ^ C[v];\n\n      int t = MP[x];\n      if(!t) {\n         MP[x] = Q;\n         adj[Q].push_back(pii(u, v));\n         Q++;\n      }\n      else {\n         adj[t].push_back(pii(u, v));\n      }\n   }\n\n   int ans = 0;\n   for(int i = 1; i <= N; i++) p[i] = i;\n\n   for(int i = 1; i < Q; i++) {\n      int sz = N;\n      for(pii j : adj[i]) {\n         int u = j.first, v = j.second;\n         S.insert(u); S.insert(v);\n         if(par(u) != par(v)) {\n            sz--;\n            p[p[v]] = p[u];\n         }\n      }\n\n      ans = (ans + pw(sz)) % MOD;\n      while(S.size()) {\n         int now = *(S.begin());\n         p[now] = now;\n         S.erase(S.begin());\n      }\n   }\n   //printf(\"%d\\n\", ans);\n\n   printf(\"%lld\\n\", ((X - Q + 1) % MOD * pw(N) % MOD + ans) % MOD);\n   return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Network Safety.json",
    "editorial_link": "https://codeforces.com//blog/entry/61668",
    "editorial": "Consider a virus containing a fixed number x\n. Let's investigate two servers connected by a data communication channel, denoting their encryption keys equal as a\n and b\n respectively. Since a?b\n, it follows that a?x?b?x\n. Therefore, if the servers are infected simultaneously the channel remains safe. The same can be said if neither of the servers is infected. When the virus infects exactly one of the two servers the channel between them can cease to be safe only when x=(a?b)\n (since a?x=b\n, it follows that x=x?(a?a)=(x?a)?a=(a?x)?a=b?a=a?b\n). Define a?b\n as the value of the respective data channel (connecting servers with keys a\n and b\n). From this it can be inferred that all servers connected by a path of channels with value x\n can only be infected simultaneously. Thus the answer when the parameter x\n is fixed is equal to 2q\n, where q\n is the number of connected components in a graph where servers are considered vertices and data channels with value x are considered edges. This value can be computed in time linearly proportional to the number of edges with value x. When processing the values which are not found on any edge separately this gives us a solution in total time O(E).",
    "hint": []
}