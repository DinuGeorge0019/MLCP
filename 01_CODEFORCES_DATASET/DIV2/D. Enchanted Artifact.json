{
    "link": "https://codeforces.com//contest/1282/problem/D",
    "problemId": "502551",
    "problem_idx": "D",
    "shortId": "1282D",
    "contest_number": "1282",
    "problem_submissions": {
        "E": [
            67546320,
            67540524,
            67541446,
            67546303,
            67546008,
            67555357,
            67546940,
            67554692,
            67554152,
            67544350,
            67536466,
            67548692,
            67540027,
            67545669,
            67549313,
            67547161,
            67559435,
            67546463
        ],
        "D": [
            67539652,
            67544407,
            67549747,
            67552213,
            67545569,
            67553744,
            67546954,
            67547692,
            67559514,
            67555818,
            67556694,
            67549779,
            67598315,
            67547666,
            67544808,
            67560465,
            67548234,
            67564097,
            67563835,
            67550417,
            67558326
        ],
        "C": [
            67534787,
            67533541,
            67536568,
            67540389,
            67537852,
            67536983,
            67539275,
            67539714,
            67541087,
            67545744,
            67547743,
            67539703,
            67555448,
            67535851,
            67539752,
            67537500,
            67540009,
            67540608,
            67537965,
            67542806
        ],
        "B1": [
            67530651,
            67528820,
            67529188,
            67532639,
            67529290,
            67531855,
            67532183,
            67532128,
            67536143,
            67531195,
            67544224,
            67536607,
            67547534,
            67532778,
            67535678,
            67530911,
            67533223,
            67529828,
            67532257,
            67532690
        ],
        "B2": [
            67530568,
            67528747,
            67529121,
            67532572,
            67529220,
            67531772,
            67532043,
            67532055,
            67536010,
            67535218,
            67544175,
            67536559,
            67747743,
            67553996,
            67532837,
            67535576,
            67530786,
            67533144,
            67529811,
            67532146,
            67532632
        ],
        "A": [
            67527639,
            67527588,
            67527631,
            67528416,
            67527601,
            67528381,
            67527986,
            67528304,
            67530259,
            67527611,
            67537517,
            67551469,
            67529352,
            67527672,
            67527752,
            67527928,
            67529147,
            67527871,
            67528083
        ]
    },
    "name": "D. Enchanted Artifact",
    "statement": "After completing the last level of the enchanted temple, you received a\r\npowerful artifact of the 255th level. Do not rush to celebrate, because\r\nthis artifact has a powerful rune that can be destroyed with a single s,\r\nwhich you are going to find. We define the spell as some consisting only\r\nof the letters and .At any time, you can cast an arbitrary non-empty\r\nspell t, and the rune on the artifact will begin to resist. of the rune\r\nis the edit distance between the strings that specify the casted spell t\r\nand the rune-destroying spell s.Edit distance of two strings s and t is\r\na value equal to the minimum number of one-character operations of\r\nreplacing, inserting and deleting characters in s to get t. For example,\r\nthe distance between and is 2, the distance between and is 1, the\r\ndistance between and is 3. The edit distance is 0 if and only if the\r\nstrings are equal.It is also worth considering that the artifact has a\r\nresistance limit if you cast more than n + 2 spells, where n is the\r\nlength of spell s, the rune will be blocked.Thus, it takes n + 2 or\r\nfewer spells to destroy the rune that is on your artifact. Keep in mind\r\nthat the required destructive spell s must also be counted among these\r\nn + 2 spells.Note that the length n of the rune-destroying spell s is\r\nnot known to you in advance. It is only known that its length n does not\r\nexceed 300.\r\n",
    "solutions": [
        "#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nll b[MAXN], c[MAXN];\npii a[MAXN];\nvector<ll> f;\nvector<ll> g[MAXN];\nstring s;\nll ask(string s) {\n    cout << s << endl;\n    fflush(stdout);\n    ll x;\n    cin >> x;\n    if (x == 0) {\n        exit(0);\n    }\n    return x;\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll numa, numb;\n    for (int i = 0; i < 300; i++) {\n        cout << \"a\";\n    }\n    cout << endl;\n    fflush(stdout);\n    cin >> numa;\n    if (numa == 0) {\n        return 0;\n    }\n\n    numa = 300 - numa;\n\n    for (int i = 0; i < 300; i++) {\n        cout << \"b\";\n    }\n    cout << endl;\n    fflush(stdout);\n    cin >> numb;\n    if (numb == 0) {\n        return 0;\n    }\n\n    numb = 300 - numb;\n\n    ll n = numa + numb;\n    string pat;\n    for (int i = 0; i < n; i++) {\n        s.push_back('a');\n        pat.push_back('a');\n    }\n\n    ll cur_ans = n - numa;\n    for (int i = 0; i < n - 1; i++) {\n        pat[i] = 'b';\n        ll x = ask(pat);\n        if (x < cur_ans) {\n            s[i] = 'b';\n        }\n        cur_ans = x;\n    }\n    if (n - numb < cur_ans) {\n        s[n-1] = 'b';\n    }\n    ll x = ask(s);\n\n\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Enchanted Artifact.json",
    "editorial_link": "https://codeforces.com/blog/entry/72461?locale=en",
    "editorial": "Firstly, let\u00e2\u0080\u0099s find out the number of letters and in the hidden string\r\nin two queries. This can be done, for example, using queries and of\r\nlength . Let the answers to these queries be and , then the number of\r\nletters and would be and respectively. These answers are explained by\r\nthe fact that i. e. for string it takes steps to remove the letters at\r\nthe end of the string and then replace letters with to change the string\r\ninto the string .Now we know the length . Consider an arbitrary string\r\nof length and let the answer to its query be . Then if we replace the\r\nletter with the opposite one (from to or from to ), then we may have one\r\nof two situations: decreased by , then the letter after the change\r\ncoincides with the letter . otherwise the letter before the change\r\nmatches the letter . Thus, you can loop from left to right and for each\r\nposition find out the character , starting, for example, from the string\r\nof length .The current algorithm guesses the string in queries. In order\r\nto get rid of one unnecessary query, note that we do not need to make a\r\nquery to find out the character in the last position. If the number of\r\nletters whose location we know is equal to , then the last character\r\ncannot be , which means it is . Similarly for the symmetric case.Thus,\r\nwe can guess the string in queries.Similarly, it is possible to solve\r\nfor an arbitrary alphabet in queries, where is the size of the alphabet.\r\nFor an arbitrary alphabet, there is also a solution using random which\r\nsolves the problem on average in queries, but it will not work in this\r\ntask, since the chance to spend more than queries is quite large.\r\n"
}