{
    "link": "https://codeforces.com//contest/580/problem/C",
    "problemId": "35997",
    "problem_idx": "C",
    "shortId": "580C",
    "contest_number": "580",
    "problem_submissions": {
        "E": [
            13169027,
            13165630,
            13172362,
            13172239,
            13276228,
            13276220,
            13181451,
            13180453
        ],
        "D": [
            13158152,
            13153446,
            13153124,
            13152837,
            13153644,
            13153078,
            13152233,
            13150734,
            13158863,
            13154097,
            13154459,
            13155410,
            13154153,
            13153936,
            13153904,
            13151772,
            13154328,
            13155366
        ],
        "C": [
            13152496,
            13147124,
            13149562,
            13149833,
            13149612,
            13149260,
            13148537,
            13148215,
            13150353,
            13147522,
            13151581,
            13150500,
            13149659,
            13151388,
            13150099,
            13149113,
            13149776,
            13150107
        ],
        "B": [
            13148061,
            13167252,
            13146021,
            13147235,
            13171070,
            13146699,
            13146714,
            13146413,
            13145854,
            13146150,
            13150066,
            13148456,
            13146468,
            13147058,
            13148187,
            13147219,
            13146687,
            13147097,
            13148044
        ],
        "A": [
            13145130,
            13166155,
            13143931,
            13143879,
            13144120,
            13143774,
            13143862,
            13143852,
            13143834,
            13144014,
            13143978,
            13143875,
            13144293,
            13145295,
            13145825,
            13143916,
            13144739,
            13143807
        ]
    },
    "name": "C. Kefa and Park",
    "statement": "Kefa decided to celebrate his first big salary by going to the\r\nrestaurant. He lives by an unusual park. The park is a rooted tree\r\nconsisting of vertices with the root at vertex . Vertex also contains\r\nKefa’s house. Unfortunaely for our hero, the park also contains cats.\r\nKefa has already found out what are the vertices with cats in them.The\r\nleaf vertices of the park contain restaurants. Kefa wants to choose a\r\nrestaurant where he will go, but unfortunately he is very afraid of\r\ncats, so there is no way he will go to the restaurant if the path from\r\nthe restaurant to his house contains more than vertices with cats. Your\r\ntask is to help Kefa count the number of restaurants where he can go.\r\n",
    "solutions": [
        "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\n#include<bitset>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5;\nstruct Edge\n{\n    int v,next;\n    Edge(){}\n    Edge(int v,int next):v(v),next(next){}\n}edge[N];\nqueue<int> q;\nint p[N],edn,MAXN[N],now[N],a[N];\nbool used[N];\nvoid addedge(int u,int v)\n{\n    edge[edn]=Edge(v,p[u]);\n    p[u]=edn++;\n}\nint main() {\n    int n,m;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    memset(p,-1,sizeof(p));\n    edn=0;\n    for(int i=1;i<=n-1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        addedge(u,v);\n        addedge(v,u);\n    }\n    memset(used,0,sizeof(used));\n    MAXN[1]=a[1];\n    now[1]=a[1];\n    q.push(1);\n    used[1]=1;\n    int ans=0;\n    while (!q.empty())\n    {\n        int x=q.front();\n        q.pop();\n        bool flag=1;\n        for(int i=p[x];~i;i=edge[i].next)\n        {\n            int y=edge[i].v;\n            if (used[y]==0)\n            {\n                \n                flag=0;\n                used[y]=1;\n                if (a[y]==1) now[y]=now[x]+1;\n                else now[y]=0;\n                MAXN[y]=max(MAXN[x],now[y]);\n                q.push(y);\n            }\n        }\n        \n        if (flag && MAXN[x]<=m) ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Kefa and Park.json",
    "editorial_link": "https://codeforces.com//blog/entry/20468",
    "editorial": "Letâs go down the tree from the root, supporting additional parameter\r\nthe number of vertices in a row met with cats. If exceeds , then leave.\r\nThen the answer is the number of leaves, which we were able to reach.\r\nAsymptotics . Solution\r\n",
    "hint": []
}