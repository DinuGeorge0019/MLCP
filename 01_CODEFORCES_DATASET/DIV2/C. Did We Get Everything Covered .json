{
    "link": "https://codeforces.com//contest/1925/problem/C",
    "problemId": "2447853",
    "problem_idx": "C",
    "shortId": "1925C",
    "contest_number": "1925",
    "problem_submissions": {
        "F": [
            243635672,
            243648922,
            243652277,
            243654463,
            243696386
        ],
        "E": [
            243616564,
            243621263,
            243626621,
            243628373,
            243642423,
            243636417,
            243643693,
            243633557,
            243638778,
            243637771,
            243645710,
            243648841,
            243629267,
            243713101,
            243632960,
            243654973,
            243648168,
            243647861,
            243652611,
            243647183,
            243650906
        ],
        "D": [
            243592234,
            243594869,
            243599958,
            243596486,
            243624513,
            243610640,
            243600801,
            243608352,
            243605500,
            243665895,
            243608581,
            243587140,
            243614894,
            243606314,
            243649266,
            243604378,
            243609277,
            243609750,
            243623206,
            243609456,
            249399690,
            243606073
        ],
        "C": [
            243570353,
            243577698,
            243576709,
            243576761,
            243588406,
            243564488,
            243578879,
            243585269,
            243576848,
            243595639,
            243608536,
            243585312,
            243573744,
            243571216,
            243580792,
            243582138,
            243591440,
            243576695,
            243587225,
            249717100,
            243587500
        ],
        "B": [
            243565143,
            243557943,
            243563278,
            243563287,
            243557566,
            243563680,
            243568156,
            243559337,
            243561416,
            243559345,
            243566711,
            243558705,
            243561296,
            243561403,
            243570584,
            243570498,
            243563900,
            243563678,
            243565505
        ],
        "A": [
            243556584,
            243556225,
            243557446,
            243557520,
            243556082,
            243557771,
            243560727,
            243556392,
            243556560,
            243556879,
            243556644,
            243556058,
            243556214,
            243556452,
            243557610,
            243558322,
            243556372,
            243556420,
            243556133
        ]
    },
    "name": "C. Did We Get Everything Covered ",
    "statement": "You are given two integers n and k along with a string s.Your task is to\r\ncheck whether all possible strings of length n that can be formed using\r\nthe first k lowercase English alphabets occur as a subsequence of s. If\r\nthe answer is , you also need to print a string of length n that can be\r\nformed using the first k lowercase English alphabets which does not\r\noccur as a subsequence of s.If there are multiple answers, you may print\r\nany of them. A string a is called a subsequence of another string b if a\r\ncan be obtained by deleting some (possibly zero) characters from b\r\nwithout changing the order of the remaining characters.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool __hack = ios::sync_with_stdio(false);\nauto __hack1 = cin.tie(nullptr);\n\ntemplate<typename T>\nT next() {\n    T x;\n    cin >> x;\n    return x;\n}\n\nint main() {\n    int tests = next<int>();\n    for (int test = 0; test < tests; ++test) {\n        int n = next<int>();\n        int k = next<int>();\n        int m = next<int>();\n        string s = next<string>();\n        bool good = true;\n        int i = 0;\n        string counter = \"\";\n        for (int it = 0; it < n; ++it) {\n            int mask = 0;\n            while (i < s.length() && mask != ((1 << k) - 1)) {\n                mask |= 1 << (s[i++] - 'a');\n            }\n            if (mask == ((1 << k) - 1)) {\n                counter += s[i - 1];\n            } else {\n                good = false;\n                int c = 0;\n                while (mask & (1 << c)) {\n                    c++;\n                }\n                counter += (char)('a' + c);\n            }\n        }\n        if (good) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\" << counter << '\\n';\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Did We Get Everything Covered .json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "We will try to construct a counter-case. If we can't the answer is YES otherwise NO.\n\nWe will greedily construct the counter-case. It is always optimal to choose the first character of our counter-case as the character (among the first k\n English alphabets) whose first index of occurrence in s\n is the highest. Add this character to our counter-case, remove the prefix up to this character from s\n and repeat until the length of the counter-case reaches n\n or we reach the end of s\n.\n\nIf the length of the counter-case is less than n\n, find a character which does not appear in the last remaining suffix of s\n. Keep adding this character to the counter-case until its length becomes n\n. This is a valid string which does not occur as a subsequence of s\n.\n\nOtherwise, all possible strings of length n\n formed using the first k\n English alphabets occur as a subsequence of s\n.",
    "hint": []
}