{
    "link": "https://codeforces.com//contest/1805/problem/F1",
    "problemId": "1861356",
    "problem_idx": "F1",
    "shortId": "1805F1",
    "contest_number": "1805",
    "problem_submissions": {
        "F1": [
            200439106,
            200443524,
            200424069,
            200446588,
            200467490,
            200437348,
            200464508,
            200464351,
            200463340,
            209038123,
            200557576,
            200463298
        ],
        "C": [
            200413348,
            200408313,
            200430286,
            200414727,
            200402344,
            200408784,
            200395896,
            200428904,
            200404720,
            200402863,
            200404086,
            200425916,
            200413389,
            200409508,
            200408670,
            200409948,
            200401611,
            200399297,
            200403669
        ],
        "B": [
            200409525,
            200389992,
            200432442,
            200395023,
            200391231,
            200403848,
            200389421,
            200391233,
            200390818,
            200392560,
            200392816,
            200391784,
            200391655,
            200392657,
            200391007,
            200395691,
            200393122,
            200390776,
            200392459
        ],
        "A": [
            200408080,
            200387988,
            200433504,
            200390983,
            200388843,
            200402551,
            200387906,
            200388117,
            200387935,
            200388566,
            200388387,
            200388650,
            200388558,
            200388007,
            200388011,
            200389948,
            200389103,
            200388194,
            200388689
        ],
        "D": [
            200406761,
            200528793,
            200401484,
            200399149,
            200420505,
            200419712,
            200416986,
            200406203,
            200414310,
            200416697,
            200410720,
            200413945,
            200420475,
            200409512,
            200419982,
            200414162,
            200411839,
            200411433,
            200405601,
            200415016
        ],
        "E": [
            200397032,
            200427084,
            200411961,
            200433750,
            200593267,
            200592726,
            200467387,
            200400294,
            200428962,
            200409350,
            200426292,
            200428409,
            200434434,
            200414709,
            200432234,
            214976359,
            200427846,
            200430477,
            200431439,
            200435575,
            200437915,
            200434896
        ],
        "F2": [
            200479147,
            200478731,
            200478432,
            200478085,
            200477991,
            200477963,
            200476470,
            200447442,
            209038798
        ]
    },
    "name": "F1. Survival of the Weakest  easy version ",
    "statement": "Let a_1, a_2,\r\nldots, a_n be an array of non-negative integers. Let F(a_1, a_2,\r\nldots, a_n) be the sorted in the non-decreasing order array of n - 1\r\nsmallest numbers of the form a_i + a_j, where 1\r\nle i < j\r\nle n. In other words, F(a_1, a_2,\r\nldots, a_n) is the sorted in the non-decreasing order array of n - 1\r\nsmallest sums of all possible pairs of elements of the array a_1, a_2,\r\nldots, a_n. For example, F(1, 2, 5, 7) = [1 + 2, 1 + 5, 2 + 5] = [3, 6,\r\n7].You are given an array of non-negative integers a_1, a_2,\r\nldots, a_n. Determine the single element of the array\r\nunderbrace{F(F(F\r\nldots F}_{n-1}(a_1, a_2,\r\nldots, a_n)\r\nldots)). Since the answer can be quite large, output it modulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"yes\");\n\telse\n\t\tputs(\"no\");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"Yes\");\n\telse\n\t\tputs(\"No\");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tif(c=='-')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar('-'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+'0');\n//\tputchar('\\n');\n}\ninline void fre()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n}\nconstexpr int mod=1000000007;\nstruct node\n{\n\tint px,py,v;\n\tfriend bool operator<(node x,node y)\n\t{\n\t\treturn x.v>y.v;\n\t}\n};\nint ans=0;\nvector<int>f(vector<int>a)\n{\n\tvector<int>res;\n\tpriority_queue<node>q;\n\tfor(int i=1;i<a.size();i++)\n\t\tq.push({i-1,i,a[i-1]+a[i]});\n\tint t=a.size()-1;\n\twhile(t--)\n\t{\n\t\tres.push_back(q.top().v);\n\t\tnode x=q.top();\n\t\tq.pop();\n\t\tif(x.py+1<a.size())\n\t\t\tq.push({x.px,x.py+1,a[x.px]+a[x.py+1]});\n\t}\n\tans=(ans*2+res[0])%mod;\n\tint x=res[0];\n\tfor(int i=0;i<res.size();i++)\n\t\tres[i]-=x;\n\treturn res;\n}\nvoid work()\n{\n\tint n;\n\tvector<int>v;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tv.push_back(x);\n\t}\n\tsort(v.begin(),v.end());\n\twhile(v.size()>1)\n\t\tv=f(v);\n\tcout<<(ans)%mod;\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n//\tcases();\n\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Survival of the Weakest  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/114644",
    "editorial": "Firstly, we will sort the array a1,a2,\u0085,an\n, and in the future we will always assume that all arrays in this problem are sorted.\n\nLet's solve the problem for n?200\n.\n\nIt may seem that with such constraints, the problem is solved quite trivially: we implement the function F\n for O(n2logn)\n, and run it n?1\n times to get an answer. But there is one nuance, with each iteration of F\n, the numbers in the array can increase by 2\n times (for example, if the array consists entirely of identical numbers), which means that after only 40\n operations, we may have an overflow. Note that it is impossible to take the numbers by modulo in the function F\n itself, since then the sorted order will be lost, and it will be impossible (or very difficult) to restore it using the remainder when dividing by 109+7\n instead of the numbers themselves.\n\nTo avoid this, we note an important property of the function F\n:\n\nF([a1,a2,\u0085,an])=F([a1?x,a2?x,\u0085,an?x])+x?2n?1\n\nThe intuition of this property is that if you subtract the same number from all the elements, then the relative order of the elements will not change, and will not change when using the F\n function. Just after the first iteration of F\n, 2x\n will be subtracted from all the numbers, then 4x\n, 8x\n, etc., in the end, the original answer will be minus x?2n?1\n. This property can be proved more strictly by induction on n\n.\n\nWhat does this wonderful property give us? Now we can subtract the same number x\n from all the elements by first adding x?2n?1\n to the answer. It would be logical enough in any situation to subtract the minimum of the array from all its elements. Thanks to this, the minimum of the array will always be 0\n, and now we can work only with arrays whose minimum element is 0\n, which greatly simplifies our life. This is one of the two key ideas in this problem.\n\nSo let's notice something interesting about the array F([0,a1,a2,\u0085,an])\n.\n\nObservation: (F([0,a1,a2,\u0085,an]))1=a1\n. The proof is obvious (let me remind you that the array is sorted).\n\nObservation: (F([0,a1,a2,\u0085,an]))n?an\n.\n\nProof: since [0,a1,a2,\u0085,an]\n has length n+1\n, F([0,a1,a2,\u0085,an])\n has length n\n. Among all pairs of array elements [0,a1,a2,\u0085,an]\n there are n\n pairs of the form 0+ai\n, and a1?a2?\u0085?an\n. This means that the original array has n\n pairs in which the sum is ?an\n. So, observation is proved.\n\nThese two observations give us that F([0,a1,a2,\u0085,an])=[a1,\u0085,?an]\n. And after subtracting the minimum (a1)\n ?[0,\u0085,?an?a1]\n.\n\nThus, if we always subtract the minimum, each time after applying the F\n function, the maximum in the array will be not increase. Which allows us to work only with arrays of numbers from 0\n to 109\n, where there naturally can be no problems with overflow.\n\nSo, we got the solution for O(n3logn)\n. Let's improve it to O(n2logn)\n.\n\nThe cornerstone in our previous solution is that we implement the function F\n for O(n2logn)\n, which is pretty slow. Let's learn how to implement it for O(nlogn)\n. This is a fairly standard problem.\n\nNote that if some pair of the form ai+aj\n is included in the array F([a1,a2,\u0085,an])\n, then all pairs ai+ai+1,ai+ai+2,\u0085,ai+aj?1\n will also be included in the array F([a1,a2,\u0085,an])\n, since the sum in these pairs is no more than ai+aj\n.\n\nWe will build the array F([a1,a2,\u0085,an])\n one element at a time, starting with the smallest. Let's denote the array in which we will add these numbers for B\n, initially B\n is empty. For each index i\n, we will store the minimum index ji>i\n such that the pair ai+aj\n is still not taken in B\n. Initially, ji=i+1\n.\n\nWe will mantain all numbers of the form ai+aji\n in std::priority_queue. Then to add the next element to B\n, we will remove the minimum element from the queue, then increase the corresponding ji\n by one and add the element ai+aji\n to the queue again. After n?1\n of such iteration we will get F([a1,a2,\u0085,an])\n. Each iteration takes O(logn)\n, which means that the asymptotics of finding the function F\n is O(nlogn)\n.\n\nIn total, we learned how to solve the problem in O(n2logn)\n.\n\nNow we move on to the full solution, for n?2?105\n.\n\nFirst we will show what the solution looks like and intuition behind it, and a more strict proof will be at the end.\n\nLet's ask ourselves: when does the last element of the array 0,a1,a2,\u0085,an\n affect the answer to the problem?\n\nVery often we will lose any mention of the an\n element after the first transition: [0,a1,\u0085,an]?F([0,a1,\u0085,an])\n.\n\nThe minimum sum of a pair of elements including an\n is 0+an\n. And there is an n?1\n pair with not bigger sum: 0+a1\n, 0+a2\n, ..., 0+an?1\n.\n\nSo the only case when an\n will enter the array F([0,a1,\u0085,an])\n is if a1+a2?an\n, because otherwise the pair a1+a2\n will be less than 0+an\n, and there will be n\n pairs with a sum less than an\n \u0097 n?1\n pairs of the form 0+ai\n and the pair a1+a2\n.\n\nWell, let's assume it really happened that a1+a2?an\n. Then F([0,a1,\u0085,an])=[0+a1,0+a2,\u0085,0+an]\n.\n\nAfter subtracting the minimum: [0,a2?a1,a3?a1,\u0085,an?a1]\n.\n\nIf we run F\n on this array again, we get: [a2?a1,\u0085,?an?a1]\n. After subtracting the minimum: [0,\u0085,?an?a2]\n.\n\nBut remember that a1+a2?an\n. Which means 2?a2?an\n. Which means an?a2?an2\n.\n\nIt turns out that if an\n somehow remains in the array after two applications of the F\n functions, then the last element of the array will be reduced by at least half!\n\nThis means that after just 2?log2an\n iterations of the F\n function, either the an\n element will be completely evicted from the array, or the array will shrink into [0,0,\u0085,0]\n! In both cases, the original element an\n in no way will be taken into account in the final answer. In no way!\n\nThe total number of times when the maximum is halved is no more than log2an\n, which means intuitively it is approximately clear that elements with indexes greater than 2?log2an\n will not affect the answer in any way.\n\nTherefore, the full solution would be to leave the first K=64\n elements of the array a\n. (a little more than 2?log2109\n).\n\nThen apply the function F\n to this array n?K\n times, but writing out K\n minimal elements, not K?1\n.\n\nAfter that, the length of the real array will also be equal to K\n, and it remains only to run the function F\n K?1\n times to get the final answer.\n\nFinal asymptotics: O(n?(KlogK))\n, where K=2log2an+2?64\n.\n\nNow let's give a strict proof that this solution works.\n\nWe are following K\n minimal elements \u0097[0,a1,\u0085,aK?1]\n.\n\nTechnically, there are also [aK,\u0085,alen]\n elements in the array. But we have no information about their values. However, we know that all these elements are ?aK?1\n since we maintain sorted order. This means that the minimum sum of a pair of elements about which we have no information is also ?aK?1\n. The whole proof is based on this simple observation.\n\nFirstly, it is not difficult to understand that K\n minimum elements are exactly enough to recalculate K?1\n minimum element in F(a)\n. Since we have pairs of elements 0+a1\n, 0+a2\n, ..., 0+aK?1\n. And the sum in each of these pairs is no more than aK?1\n, which means no more than the sum in any pair about which we have no information.\n\nTherefore, in any incomprehensible situation, we can recalculate with the loss of one of the elements. Let's see when it is possible to recalculate all K\n minimal elements.\n\nAgain, the minimum element about which we have no information from [0,a1,\u0085,aK?1]\n is 0+aK?0+aK?1\n. So if we find K\n elements that ?aK?1\n, then we can recalculate K\n minimal elements of F(a)\n through K\n minimal elements of a\n. We have a K?1\n pair of the form 0+ai\n, as well as a pair a1+a2\n. So if a1+a2<aK?1\n, then we can recalculate all K\n minimal elements.\n\nAnd if recalculation is not possible, then a1+a2?aK?1\n is executed. Then, having encountered such a situation, we will recalculate twice with the loss of the last element, thus reducing K\n by 2\n. After such a recalculation, the last element will be at least half as small as it was before (this is part of the main tutorial). So after 2log2(A)\n of such element removals, the array will slide into [0,0,\u0085,0]\n and everything is clear. And if the number of removals is less than 2log2(A)\n, then one of the K\n elements will certainly live to the end, and will be the answer to the problem. Thus, the correctness of the solution has been successfully proved.\n\nBonus for those who are still alive: find a more accurate estimate for K\n and build a test on which this solution, but keeping track of the K?1\n minimum element (one less than necessary), will give the wrong answer."
}