{"link": "https://codeforces.com//contest/1805/problem/F1", "problemId": "1861356", "problem_idx": "F1", "shortId": "1805F1", "contest_number": "1805", "problem_submissions": {"F1": [200439106, 200443524, 200424069, 200446588, 200467490, 200437348, 200464508, 200464351, 200463340, 209038123, 200557576, 200463298], "C": [200413348, 200408313, 200430286, 200414727, 200402344, 200408784, 200395896, 200428904, 200404720, 200402863, 200404086, 200425916, 200413389, 200409508, 200408670, 200409948, 200401611, 200399297, 200403669], "B": [200409525, 200389992, 200432442, 200395023, 200391231, 200403848, 200389421, 200391233, 200390818, 200392560, 200392816, 200391784, 200391655, 200392657, 200391007, 200395691, 200393122, 200390776, 200392459], "A": [200408080, 200387988, 200433504, 200390983, 200388843, 200402551, 200387906, 200388117, 200387935, 200388566, 200388387, 200388650, 200388558, 200388007, 200388011, 200389948, 200389103, 200388194, 200388689], "D": [200406761, 200528793, 200401484, 200399149, 200420505, 200419712, 200416986, 200406203, 200414310, 200416697, 200410720, 200413945, 200420475, 200409512, 200419982, 200414162, 200411839, 200411433, 200405601, 200415016], "E": [200397032, 200427084, 200411961, 200433750, 200593267, 200592726, 200467387, 200400294, 200428962, 200409350, 200426292, 200428409, 200434434, 200414709, 200432234, 214976359, 200427846, 200430477, 200431439, 200435575, 200437915, 200434896], "F2": [200479147, 200478731, 200478432, 200478085, 200477991, 200477963, 200476470, 200447442, 209038798]}, "name": "F1. Survival of the Weakest  easy version ", "statement": "Let a_1, a_2,\r\nldots, a_n be an array of non-negative integers. Let F(a_1, a_2,\r\nldots, a_n) be the sorted in the non-decreasing order array of n - 1\r\nsmallest numbers of the form a_i + a_j, where 1\r\nle i < j\r\nle n. In other words, F(a_1, a_2,\r\nldots, a_n) is the sorted in the non-decreasing order array of n - 1\r\nsmallest sums of all possible pairs of elements of the array a_1, a_2,\r\nldots, a_n. For example, F(1, 2, 5, 7) = [1 + 2, 1 + 5, 2 + 5] = [3, 6,\r\n7].You are given an array of non-negative integers a_1, a_2,\r\nldots, a_n. Determine the single element of the array\r\nunderbrace{F(F(F\r\nldots F}_{n-1}(a_1, a_2,\r\nldots, a_n)\r\nldots)). Since the answer can be quite large, output it modulo 10^9+7.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"yes\");\n\telse\n\t\tputs(\"no\");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"Yes\");\n\telse\n\t\tputs(\"No\");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tif(c=='-')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar('-'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+'0');\n//\tputchar('\\n');\n}\ninline void fre()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n}\nconstexpr int mod=1000000007;\nstruct node\n{\n\tint px,py,v;\n\tfriend bool operator<(node x,node y)\n\t{\n\t\treturn x.v>y.v;\n\t}\n};\nint ans=0;\nvector<int>f(vector<int>a)\n{\n\tvector<int>res;\n\tpriority_queue<node>q;\n\tfor(int i=1;i<a.size();i++)\n\t\tq.push({i-1,i,a[i-1]+a[i]});\n\tint t=a.size()-1;\n\twhile(t--)\n\t{\n\t\tres.push_back(q.top().v);\n\t\tnode x=q.top();\n\t\tq.pop();\n\t\tif(x.py+1<a.size())\n\t\t\tq.push({x.px,x.py+1,a[x.px]+a[x.py+1]});\n\t}\n\tans=(ans*2+res[0])%mod;\n\tint x=res[0];\n\tfor(int i=0;i<res.size();i++)\n\t\tres[i]-=x;\n\treturn res;\n}\nvoid work()\n{\n\tint n;\n\tvector<int>v;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tv.push_back(x);\n\t}\n\tsort(v.begin(),v.end());\n\twhile(v.size()>1)\n\t\tv=f(v);\n\tcout<<(ans)%mod;\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n//\tcases();\n\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "implementation", "math", "sortings"], "dificulty": "2600", "interactive": false}