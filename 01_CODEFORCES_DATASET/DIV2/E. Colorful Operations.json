{
    "link": "https://codeforces.com//contest/1638/problem/E",
    "problemId": "1297619",
    "problem_idx": "E",
    "shortId": "1638E",
    "contest_number": "1638",
    "problem_submissions": {
        "E": [
            146394309,
            146388037,
            146392264,
            146392799,
            146383148,
            146391230,
            146412303,
            146401025,
            146403078,
            146402136,
            179550421,
            146406748,
            146402980,
            146407733,
            146480267,
            146392395,
            146416198,
            146408751,
            146407567,
            146399245,
            146416242,
            146413814
        ],
        "D": [
            146373961,
            146380846,
            146385038,
            146375477,
            146392500,
            146381733,
            146401310,
            146378870,
            146384454,
            146387386,
            146387880,
            146390053,
            146382176,
            146480222,
            146406431,
            146388651,
            146388267,
            146392625,
            146412206,
            146374640,
            146389515
        ],
        "C": [
            146366299,
            146372352,
            146371729,
            146367670,
            146366106,
            146373666,
            146370507,
            146365761,
            146370642,
            146376834,
            146376510,
            146371594,
            146370051,
            146480186,
            146375503,
            146369319,
            146374946,
            146378437,
            146373206,
            146367076,
            146373277
        ],
        "B": [
            146362311,
            146363442,
            146362707,
            146365725,
            146364605,
            146363885,
            146366228,
            146383066,
            146364746,
            146368584,
            146368423,
            146367380,
            146366091,
            146480117,
            146369102,
            146364936,
            146367883,
            146370547,
            146366764,
            146364119,
            146368017
        ],
        "A": [
            146361810,
            146361860,
            146361937,
            146362725,
            146362534,
            146362379,
            146363944,
            146381318,
            146362119,
            146362820,
            146362493,
            146479991,
            146363108,
            146363259,
            146480100,
            146363531,
            146362617,
            146363968,
            146362163,
            146363256,
            146362105,
            146365613
        ],
        "F": [
            154464206,
            146479912,
            146613983,
            146474726,
            146640126
        ]
    },
    "name": "E. Colorful Operations",
    "statement": "You have an array a_1,a_2,\r\ndots, a_n. Each element initially has value 0 and color 1. You are also\r\ngiven q queries to perform: : Change the color of elements a_l,a_{l+1},\r\ncdots,a_r to c (1\r\nle l\r\nle r\r\nle n, 1\r\nle c\r\nle n). : Add x to values of all elements a_i (1\r\nle i\r\nle n) of color c (1\r\nle c\r\nle n, -10^9\r\nle x\r\nle 10^9). : Print a_i (1\r\nle i\r\nle n).\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\nconst int N=1000005;\nconst ll inf=1e18;\n\nstruct node{\n\tint l,r;\n\tmutable int c,tim;\n\tnode (int _l=0,int _r=0,int _c=0,int _tim=0){\n\t\tl=_l,r=_r,c=_c,tim=_tim;\n\t}\n\tfriend bool operator < (const node&a,const node&b){\n\t\treturn a.l!=b.l?a.l<b.l:a.r<b.r;\n\t}\n};\nset<node> s;\nvector<pair<int,ll>> color[N];\nint n,q;\n\nstruct SMT{\n\t#define ls (u<<1)\n\t#define rs (u<<1|1)\n\tint L[N<<2],R[N<<2];\n\tll tag[N<<2],sum[N<<2];\n\tvoid pushtag(int u,ll dlt){\n\t\ttag[u]+=dlt,sum[u]+=(R[u]-L[u]+1)*dlt;\n\t}\n\tvoid pushdown(int u){\n\t\tif(tag[u]){\n\t\t\tpushtag(ls,tag[u]),pushtag(rs,tag[u]);\n\t\t\ttag[u]=0;\n\t\t}\n\t}\n\tvoid build(int u,int l,int r){\n\t\tL[u]=l,R[u]=r;\n\t\tif(l==r)return;\n\t\tint mid=l+r>>1;\n\t\tbuild(ls,l,mid),build(rs,mid+1,r);\n\t}\n\tvoid update(int u,int l,int r,int ql,int qr,ll dlt){\n\t\tif(ql<=l&&r<=qr){\n\t\t\tpushtag(u,dlt);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=l+r>>1;\n\t\tif(ql<=mid)update(ls,l,mid,ql,qr,dlt);\n\t\tif(qr>mid)update(rs,mid+1,r,ql,qr,dlt);\n\t\tsum[u]=sum[ls]+sum[rs];\n\t}\n\tll query(int u,int l,int r,int pos){\n\t\tif(l==r){\n\t\t\treturn sum[u];\n\t\t}\n\t\tpushdown(u);\n\t\tint mid=l+r>>1;\n\t\tif(pos<=mid)return query(ls,l,mid,pos);\n\t\telse return query(rs,mid+1,r,pos);\n\t}\n}smt;\n\nset<node>::iterator split(int pos){\n\tauto it=s.lower_bound((node)(pos));\n\tif(it!=s.end()&&it->l==pos)return it;\n\tit--;\n\tint l=it->l,r=it->r,c=it->c,tim=it->tim;\n\ts.erase(it);\n\ts.insert(node(l,pos-1,c,tim));\n\treturn s.insert(node(pos,r,c,tim)).fir;\n}\n\nvoid print(){\n\tprintf(\"*** print\\n\");\n\tfor(auto it:s){\n\t\tprintf(\"(l = %d, r = %d, c = %d, tim = %d)\\n\",it.l,it.r,it.c,it.tim);\n\t}\n}\n\nint main(){\n\tn=read(),q=read();\n\ts.insert(node(1,n+1,1,0));\n\t// print();\n\trep(i,1,q){\n\t\tchar opt[10];scanf(\"%s\",opt);\n\t\tif(opt[0]=='C'){\n\t\t\tint l=read(),r=read(),c=read();\n\t\t\tauto itr=split(r+1),it=split(l);\n\t\t\t// print();\n\t\t\twhile(it!=itr){\n\t\t\t\tint tim=it->tim,col=it->c;\n\t\t\t\tint k1=lower_bound(color[col].begin(),color[col].end(),make_pair(tim,-inf))-color[col].begin();\n\t\t\t\tif(SZ(color[col]))\n\t\t\t\t\tsmt.update(1,1,n,it->l,it->r,color[col].back().sec-(k1?color[col][k1-1].sec:0ll));\n\t\t\t\tit=s.erase(it);\n\t\t\t}\n\t\t\ts.insert(node(l,r,c,i));\n\t\t}else if(opt[0]=='A'){\n\t\t\tint c=read(),x=read();\n\t\t\tll las=x;\n\t\t\tif(color[c].size())las+=color[c].back().sec;\n\t\t\tcolor[c].pb({i,las});\n\t\t}else{\n\t\t\tint l=read();\n\t\t\tauto it=split(l);\n\t\t\tint tim=it->tim,col=it->c;\n\t\t\tint k1=lower_bound(color[col].begin(),color[col].end(),make_pair(tim,-inf))-color[col].begin();\n\t\t\tll extra=SZ(color[col])?color[col].back().sec-(k1?color[col][k1-1].sec:0ll):0;\n\t\t\tprint(smt.query(1,1,n,l)+extra,'\\n');\n\t\t}\n\t\t// print();\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Colorful Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/99942",
    "editorial": "In the first part, letâs consider that for all update operations . The\r\nidea is not to update each element in an operation and instead, keeping\r\nan array which stores for each color the total sum we must add to it\r\n(because we didnât do it when we had to).Letsâs discuss each operation:\r\n:We will use the notation . In this operation we change the color of\r\nelement from to . First, remember that we have the sum that we havenât\r\nadded to any of the elements of color (including ), so we better do it\r\nnow because the color changes: . Now we can change the color to .But\r\nwait, what about ? It says that we will need to add some value to\r\nelement , but this is obviously false, since now it is up to date. We\r\ncan compensate by subtracting now from element , repairing the mistake\r\nwe will do later: . Finally, donât forget to set . :This is as simple as\r\nit gets: . :The query operation is also not very complicated. We print\r\nthe value and donât forget about : .The time complexity is per query.Now\r\nwe get back to the initial problem and remove the restriction . Letâs\r\nkeep an array of maximal intervals of elements with the same color. We\r\nwill name them . By doing so, we can keep the value for the a whole\r\ncolor interval. When we change the color of all elements in , there are\r\ntwo kinds of color intervals that interest us in our array: :In this\r\ncase the whole interval changes its color. First, we add the values to\r\neach interval. Then, after changing the color of all these intervals\r\ninto the same one, we can merge them all. Now we update the resulting\r\ninterval similar to how we would update a single element. or (or\r\nboth):These are the two (or one) intervals that contain the endpoints\r\nand . Here we will first split the color interval into two (or three)\r\nsmaller ones: outside and inside . Then, we just update the one inside\r\nas before.Notice that in contrast to the solution for , here we have to\r\nadd some value on a range. We can do this using a data structure such as\r\nFenwick tree or segment tree in . Also, for storing the color intervals\r\nwe can use a set. This allows insertions and deletions, as well as\r\nquickly finding the range of intervals modified in a coloring.The time\r\ncomplexity is a bit tricky to determine because at first it might seem\r\nlike it is , but if we analyze the effect each update has on the long\r\nterm, it turns out to be much better.We will further refer to the number\r\nof intervals in our array as the of the current state. Letâs consider\r\nthat in our update we found color intervals contained in the update\r\ninterval, the potential decreases by and then it grows by at most\r\n(because of the two splits). The number of steps our program performs is\r\nproportional to the total changes in potential.In one operation, the\r\npotential can decrease by a lot, but luckily, it can only grow by .\r\nBecause the potential is always positive, it decreases in total at most\r\nas much as it increases. Thus, the total change in potential is\r\n.Although not described here, there exists another solution to this\r\nproblem using only a segment tree with lazy propagation. In this\r\nsolution, our data structure stops only on monochrome segments. The time\r\ncomplexity is the same.Time complexity: .\r\n",
    "hint": [
        "Hint 1 First, solve the problem for single-element updates.",
        "Hint 2 Don't actually add to all elements of some color in an update. Instead, just set a reminder that you have to do so. When do you have to be careful?",
        "Hint 3 When you change color, remember to do the addition. Also, don't forget about the already set reminder on the new color. This is currently wrong because you are up to date. How do you fix it?",
        "Hint 4 Moving to the range update problem, use a data structure to maintain maximal ranges colored in a single color. How do these color intervals change during a color operation? What's the actual time complexity?"
    ]
}