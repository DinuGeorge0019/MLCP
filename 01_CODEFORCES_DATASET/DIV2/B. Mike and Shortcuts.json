{"link": "https://codeforces.com//contest/689/problem/B", "problemId": "64398", "problem_idx": "B", "shortId": "689B", "contest_number": "689", "problem_submissions": {"D": [18930229, 18929436, 18930879, 18930235, 18926161, 18928733, 18925280, 18927418, 18929085, 18929212, 18929942, 18930645, 18931175, 18924428, 18930801, 18934009, 18927074, 18932083, 18931447], "E": [18927271, 18927820, 18923666, 18931272, 18929873, 18930514, 18922905, 18924072, 18931242, 18932135, 18931664, 18935299, 18933488, 18930284, 18935230, 18930474, 18929312, 18934284, 18932460], "C": [18924941, 18925234, 18926474, 18924949, 18927430, 18926086, 18927497, 18929616, 18924880, 18926717, 18932481, 18925981, 18926886, 18931951, 18926746, 18931682, 18931981, 18925951, 18922736], "B": [18923236, 18923653, 18926920, 18923889, 18924142, 18923587, 18927964, 18931269, 18923788, 18925427, 18926540, 18924110, 18924747, 18932852, 18923583, 18924738, 18930576, 18923854, 18932827], "A": [18922333, 18922086, 18921966, 18921847, 18936511, 18922920, 18935750, 18932978, 18922085, 18924781, 18922834, 18922553, 18922739, 18933881, 18922408, 18925800, 18922272, 18933705]}, "name": "B. Mike and Shortcuts", "statement": "Recently, Mike was very busy with studying for exams and contests. Now\r\nhe is going to chill a bit by doing some sight seeing in the city.City\r\nconsists of intersections numbered from to . Mike starts walking from\r\nhis house located at the intersection number and goes along some\r\nsequence of intersections. Walking from intersection number to\r\nintersection requires units of energy. The spent by Mike to visit a\r\nsequence of intersections is equal to units of energy.Of course, walking\r\nwould be boring if there were no shortcuts. A is a special path that\r\nallows Mike walking from one intersection to another requiring only unit\r\nof energy. There are exactly shortcuts in Mike\u2019s city, the of them\r\nallows walking from intersection to intersection () (but not in the\r\nopposite direction), thus there is exactly one shortcut starting at each\r\nintersection. Formally, if Mike chooses a sequence then for each\r\nsatisfying and Mike will spend instead of walking from the intersection\r\nto intersection . For example, if Mike chooses a sequence , he spends\r\nexactly units of total energy walking around them.Before going on his\r\nadventure, Mike asks you to find the minimum amount of energy required\r\nto reach each of the intersections from his home. Formally, for each\r\nMike is interested in finding minimum possible total energy of some\r\nsequence .\r\n", "solutions": ["#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 200100;\n\n\n\nint n, a[N], D[N], viz[N];\nqueue<int> q;\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n;\n    FOR(i,1,n) {\n        cin >> a[i];\n    }\n    q.push(1);\n    viz[1] = 1;\n    while(!q.empty()) {\n        int x = q.front();\n        q.pop();\n        if (!viz[x + 1] && x + 1 <= n) {\n            viz[x + 1] = 1;\n            D[x + 1] = D[x] + 1;\n            q.push(x + 1);\n        }\n        if (!viz[x - 1] && x - 1 >= 1) {\n            viz[x - 1] = 1;\n            D[x - 1] = D[x] + 1;\n            q.push(x - 1);\n        }\n        if (!viz[a[x]] && a[x] != x) {\n            viz[a[x]] = 1;\n            D[a[x]] = D[x] + 1;\n            q.push(a[x]);\n        }\n    }\n    FOR(i,1,n) {\n        cout << D[i] << \" \";\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "greedy", "shortest paths"], "dificulty": "1600", "interactive": false}