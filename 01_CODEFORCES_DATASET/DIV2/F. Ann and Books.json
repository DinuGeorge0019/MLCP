{
    "link": "https://codeforces.com//contest/877/problem/F",
    "problemId": "130133",
    "problem_idx": "F",
    "shortId": "877F",
    "contest_number": "877",
    "problem_submissions": {
        "F": [
            31654167,
            31653139,
            31655134,
            31656955,
            31639931,
            31650204,
            31648622,
            31651887,
            33479364,
            31655646,
            31694169,
            31893110
        ],
        "E": [
            31643937,
            31646320,
            31646382,
            31649500,
            31641532,
            31645322,
            31640350,
            31645337,
            31641515,
            31644016,
            31652300,
            31648164,
            31648540,
            31649482,
            31644271,
            31648366,
            31646891,
            31648638,
            31653283,
            31654866
        ],
        "D": [
            31641155,
            31644336,
            31643884,
            31647657,
            31665021,
            31739883,
            31649498,
            31650176,
            31649638,
            31639062,
            31644913,
            31645497,
            31649880,
            31645363,
            31666561,
            31654457,
            31648925,
            31649435
        ],
        "C": [
            31638971,
            31647846,
            31638928,
            31641413,
            31644732,
            31639320,
            31637367,
            31649045,
            31644989,
            31640032,
            31639911,
            31643252,
            31638722,
            31638437,
            31636874,
            31639305,
            31642602,
            31642153,
            31643991,
            31641659
        ],
        "B": [
            31638394,
            31636212,
            31636559,
            31636226,
            31644604,
            31636106,
            31634815,
            31636547,
            31636242,
            31637676,
            31679870,
            31636958,
            31645807,
            31636913,
            31635284,
            31638201,
            31637074,
            31636966,
            31638021,
            31639655,
            31639274
        ],
        "A": [
            31635408,
            31634914,
            31634587,
            31634665,
            31664979,
            31634608,
            31634317,
            31634960,
            31650654,
            31634394,
            31634371,
            31644024,
            31634639,
            31634521,
            31634889,
            31634575,
            31635175,
            31640619,
            31635186,
            31635511
        ]
    },
    "name": "F. Ann and Books",
    "statement": "In Ann’s favorite book shop are as many as books on math and economics.\r\nBooks are numbered from to . Each of them contains non-negative number\r\nof problems.Today there is a sale: any subsegment of a segment from to\r\ncan be bought at a fixed price. Ann decided that she wants to buy such\r\nnon-empty subsegment that the sale operates on it and the number of math\r\nproblems is greater than the number of economics problems by . Note that\r\nmay be positive, negative or zero.Unfortunately, Ann is not sure on\r\nwhich segment the sale operates, but she has assumptions. For each of\r\nthem she wants to know the number of options to buy a subsegment\r\nsatisfying the condition (because the time she spends on choosing\r\ndepends on that).Currently Ann is too busy solving other problems, she\r\nasks you for help. For each her assumption determine the number of\r\nsubsegments of the given segment such that the number of math problems\r\nis greaten than the number of economics problems on that subsegment\r\nexactly by .\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=100005,M=100005;\ninline int read(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(long long a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(long long a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\nint sum,b[N],k,n,len,m,i,ll,rr,qian[N],hou[N];\nlong long tong[N],a[N],c[N],kind,an[N];\nmap<long long,int>Ma;\nstruct data{\n\tint l,r,id,num;\n}q[M];\ninline void del1(int p){\n\ttong[a[p]]--;\n\tif(hou[a[p]])kind-=tong[hou[a[p]]];\n}\ninline void del2(int p){\n\ttong[a[p]]--;\n\tif(qian[a[p]])kind-=tong[qian[a[p]]];\n}\ninline void ins1(int p){\n\tif(hou[a[p]])kind+=tong[hou[a[p]]];\n\ttong[a[p]]++;\n}\ninline void ins2(int p){\n\tif(qian[a[p]])kind+=tong[qian[a[p]]];\n\ttong[a[p]]++;\n}\ninline bool cmp(data a,data b){\n\treturn a.id<b.id||(a.id==b.id&&a.r<b.r);\n}\nint main(){\n\tn=read(); k=read(); len=sqrt(n);\n\tfor(i=1;i<=n;i++)b[i]=read();\n\tfor(i=1;i<=n;i++)c[i]=a[i]=read()*(b[i]==1?1:-1)+a[i-1];\n\tsort(&c[1],&c[n+1]); c[0]=c[1]-1;\n\tfor(i=1;i<=n;i++){\n\t\tif(c[i]!=c[i-1]){\n\t\t\tMa[c[i]]=++sum;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tqian[Ma[c[i]]]=Ma[c[i]-k];\n\t\thou[Ma[c[i]]]=Ma[c[i]+k];\n\t\ta[i]=Ma[a[i]];\n\t}\n\thou[0]=Ma[k];\n\tm=read();\n\tfor(i=1;i<=m;i++){\n\t\tq[i].l=read(); q[i].r=read();\n\t\tq[i].id=q[i].l/len; q[i].num=i;\n\t}\n\tsort(&q[1],&q[m+1],cmp);\n\tll=q[1].l; rr=q[1].l-1;\n\tfor(i=1;i<=m;i++){\n\t\twhile(ll>q[i].l)ins1(--ll);\n\t\twhile(rr<q[i].r)ins2(++rr);\n\t\twhile(ll<q[i].l)del1(ll++);\n\t\twhile(rr>q[i].r)del2(rr--);\n\t\tan[q[i].num]=kind+tong[hou[a[ll-1]]];\n\t}\n\tfor(i=1;i<=m;i++)writeln(an[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "flows",
        "hashing"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Ann and Books.json",
    "editorial_link": "https://codeforces.com//blog/entry/55362",
    "editorial": "If -th book is on economics, . Now problem is to calculate count of\r\nsegments of sum .Calculate prefix sums: . Then . Now we can solve it in\r\n. Weâll go along the segment and calculate number of occurences of in\r\nsegment. Then weâll add to answer. can be big enought, so we should use\r\nsomething like . This is where the logarithm comes from.Note, that we\r\ncan easily move both borders to the left and to the right. Then we can\r\nsolve it using Moâs algorhitm in . Unfortunatelly, itâs still too\r\nslow.Letâs use coordinate compression. For each prefsum calculate\r\ncompressed value of , compressed value and compressed value . It allows\r\nus to get rid of logarithm.\r\n",
    "hint": []
}