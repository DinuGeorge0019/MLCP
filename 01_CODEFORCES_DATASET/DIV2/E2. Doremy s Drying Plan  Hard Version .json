{
    "link": "https://codeforces.com//contest/1890/problem/E2",
    "problemId": "2253931",
    "problem_idx": "E2",
    "shortId": "1890E2",
    "contest_number": "1890",
    "problem_submissions": {
        "E2": [
            230243672,
            230240480,
            230297470,
            230254767,
            230258587,
            230244180,
            230254845,
            230249864,
            230263075,
            230246186
        ],
        "E1": [
            230239375,
            230240649,
            230254904,
            230258446,
            230244551,
            230252707,
            230254758,
            230249708,
            230262781,
            230215711,
            230246708,
            230241675,
            230236999,
            230227194,
            230225604,
            230238862,
            230234772,
            230232052,
            230239219
        ],
        "C": [
            230215281,
            230206393,
            230208934,
            230208092,
            230206406,
            230204020,
            230204003,
            230208271,
            230220692,
            230199138,
            230200556,
            230196035,
            230205630,
            230204581,
            230205712,
            230207645,
            230206074,
            230200943
        ],
        "D": [
            230200794,
            230211914,
            230214420,
            230213956,
            230250838,
            230215130,
            230243357,
            230434274,
            230253613,
            230238740,
            230207739,
            230228283,
            230207522,
            230211617,
            230214234,
            230212438,
            230213769,
            230217205,
            230221587,
            230210557
        ],
        "B": [
            230187228,
            230188639,
            230191975,
            230193314,
            230189140,
            230192487,
            230190081,
            230430791,
            230190255,
            230203446,
            230188113,
            230219697,
            230186542,
            230187036,
            230191039,
            230188308,
            230187745,
            230188740,
            230190731,
            230189120
        ],
        "A": [
            230183445,
            230183838,
            230195995,
            230187748,
            230183292,
            230186367,
            230183250,
            230430735,
            230183529,
            230188990,
            230184115,
            230213790,
            230183853,
            230183272,
            230185989,
            230183632,
            230183856,
            230183304,
            230184663,
            230511197,
            230183134
        ],
        "F": [
            230416243,
            230223460,
            232061512,
            232061382,
            232061156,
            230258558,
            230434262,
            230438215
        ]
    },
    "name": "E2. Doremy s Drying Plan  Hard Version ",
    "statement": "Doremy lives in a rainy country consisting of n cities numbered from 1\r\nto n.The weather broadcast predicted the distribution of rain in the\r\nnext m days. In the i-th day, it will rain in the cities in the interval\r\n[l_i, r_i]. A city is called dry if it will never rain in that city in\r\nthe next m days.It turns out that Doremy has a special power. She can\r\nchoose k days, and during these days it will not rain. Doremy wants to\r\ncalculate the maximum number of dry cities after using the special\r\npower.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define mp make_pair\n#define ll long long\n#define il inline\nusing namespace std;\nconst int maxn=200010;\nconst int MAXN=maxn<<2;\nconst int inf=1<<30;\nconst int maxk=15;\nil int read(){\n\tint x=0;\n\tchar c=getchar();\n\tfor(;!(c>='0'&&c<='9');c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\treturn x;\n}\nil void chkmax(int &x,int y){if(y>x)x=y;}\nstruct seg{\n\tint l,r;\n}a[maxn];\nstruct info{\n\tint st[maxk],top;\n\tint op;\n}b[maxn];\nset<pair<int,int> >s;\nbool cmp(seg a,seg b){return a.l<b.l;}\nbool cmpp(int x,int y){return a[x].l>a[y].l;}\nint T,n,m,k;\nint f[maxk][maxn];\nint g[maxk][maxn];\nint d[maxk][MAXN];\nvoid build(int t,int i,int l,int r){\n\td[t][i]=-inf;\n\tif(l==r) return ;\n\tint mid=l+r>>1;\n\tbuild(t,i<<1,l,mid);\n\tbuild(t,i<<1|1,mid+1,r);\n}\nvoid Add(int t,int i,int l,int r,int x,int k){\n\tif(l==r){\n\t\td[t][i]=k;\n\t\treturn ;\n\t}int mid=l+r>>1;\n\tif(mid>=x) Add(t,i<<1,l,mid,x,k);\n\telse Add(t,i<<1|1,mid+1,r,x,k);\n\td[t][i]=max(d[t][i<<1],d[t][i<<1|1]);\n}\nint Q(int t,int i,int l,int r,int L,int R){\n\tif(L>R) return -inf;\n\tif(l>=L&&r<=R) return d[t][i];\n\tif(l>R||r<L) return -inf;\n\tint mid=l+r>>1;\n\treturn max(Q(t,i<<1,l,mid,L,R),Q(t,i<<1|1,mid+1,r,L,R));\n}\nint Mx(int t,int l,int r){\n\treturn Q(t,1,0,n,l,r);\n}\nvoid renew(int t,int x,int k){\n\tif(k<0) return ;\n\tAdd(t,1,0,n,x,k);\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\ts.clear();\n\t\tn=read(),m=read(),k=read();\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tfor(int j=0;j<=n;j++) \n\t\t\t\tf[i][j]=g[i][j]=-inf;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\ta[i].l=read(),a[i].r=read();\n\t\t}sort(a+1,a+1+m,cmp);\n\t\tfor(int i=1,j=1;i<=n;i++){\n\t\t\twhile(j<=m&&a[j].l<=i)\n\t\t\t\ts.insert(mp(a[j].r,j)),j++;\n\t\t\twhile(!s.empty()&&s.begin()->first<i)\n\t\t\t\ts.erase(s.begin());\n\t\t\tif(s.size()<=k){\n\t\t\t\tb[i].op=1,b[i].top=0;\n\t\t\t\tfor(auto it=s.begin();it!=s.end();it++)\n\t\t\t\t\tb[i].st[++b[i].top]=it->second;\n\t\t\t\tsort(b[i].st+1,b[i].st+1+b[i].top,cmpp);\n\t\t\t}\n\t\t\telse b[i].op=0;\n\t\t}\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tbuild(i,1,0,n);\n\t\tf[0][0]=0,renew(0,0,f[0][0]);\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tfor(int j=1;j<=n;renew(i,j,f[i][j]),j++){\n\t\t\t\tif(!b[j].op)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(!b[j].top){\n\t\t\t\t\tf[i][j]=Mx(i,0,j-1)+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i>=b[j].top) chkmax(f[i][j],Mx(i-b[j].top,0,j-1)+1);\n\t\t\t\tfor(int u=0;u<b[j].top&&i>=u;u++)\n\t\t\t\t\tchkmax(f[i][j],Mx(i-u,a[b[j].st[u+1]].l,j-1)+1);\n\t\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tans=max(ans,f[i][j]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Doremy s Drying Plan  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/121813",
    "editorial": "k\n is bigger in this version. However, it is still small, which leads us to a DP approach.\n\nLet dpi,j\n be the number of uncovered positions in [1,i]\n, and the last uncovered position is i\n, and the number of deleted intervals is j\n.\n\nFor transition, we need to get all the intervals that covers position i\n. We've mentioned this in the editorial of the easy version.\n\nLet's iterate the last uncovered position t\n, and calculate the number of intervals that need to be deleted in this transition. Let it be dt\n and it is the number of interval [l,r]\n such that t<l?i?r\n. Check this for example:\n\n\n\nAnd the transition goes:\n\ndpi,j?1+maxt=0i?1dpt,j?dt\n\nThe time complexity is O(n2k)\n now. We need to speed the transition up.\n\nNote that dt\n is increasing while t\n is decreasing, and dt\n is at most k\n. It actually splits the transition interval [0,i?1]\n into at most k+1\n intervals [s0,s1],[s1+1,s2],?,[sl?1+1,sl]\n such that 0=s0?s1<s2<?<sl=i?1\n and for t\n in the same interval, dt\n is the same.\n\nSo the sparse table can be used for transition.\n\nTime complexity O(nk2)\n. Memory complexity O(knlogn)\n."
}