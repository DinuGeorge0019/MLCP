{"link": "https://codeforces.com//contest/460/problem/E", "problemId": "12992", "problem_idx": "E", "shortId": "460E", "contest_number": "460", "problem_submissions": {"D": [7530164, 7529507, 7528611, 7531906, 9930337, 7527593, 7534014], "C": [7526812, 7524766, 7521791, 7520756, 7523061, 7523333, 7519930, 7524625, 7521906, 7524675, 7526387, 7519659, 7530606, 7536442, 7525938, 7537429, 7537409, 7528296, 7527111, 7533847], "B": [7521233, 7521796, 7519529, 7518861, 7531950, 7520294, 7521371, 7521865, 7520350, 7521538, 7521105, 7520402, 7520462, 7520767, 7520287, 7520787, 7523620], "A": [7518028, 7517645, 7517427, 7517408, 7518105, 7517647, 7522206, 7517963, 7518604, 7517479, 7517687, 7521876, 7518378, 7518558, 7517897, 7517534, 7517657, 7521651], "E": [7532772, 7533008, 7530765]}, "name": "E. Roland and Rose", "statement": "Roland loves growing flowers. He has recently grown a beautiful rose at\r\npoint of the Cartesian coordinate system. The rose is so beautiful that\r\nRoland is afraid that the evil forces can try and steal it. To protect\r\nthe rose, Roland wants to build watch towers. Let\u2019s assume that a tower\r\nis a point on the plane at the distance of at most from the rose.\r\nBesides, Roland assumes that the towers should be built at points with\r\ninteger coordinates and the sum of squares of distances between all\r\npairs of towers must be as large as possible. Note, that Roland may\r\nbuild several towers at the same point, also he may build some of them\r\nat point .Help Roland build the towers at the integer points so that the\r\nsum of squares of distances between all towers is maximum possible. Note\r\nthat the distance in this problem is defined as the Euclidian distance\r\nbetween points.\r\n", "solutions": ["// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n// }}}\n// #defines {{{\n#define MP(x,y) make_pair(x,y)\n#define PB(x) push_back(x)\n#define POP() pop_back()\n#define F first\n#define S second\n#define PR printf\nvoid RI() {}\ntemplate<typename... T>\nvoid RI(int& head,T&... tail) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nvoid PRI(int x) {\n    printf(\"%d\\n\",x);\n}\ntemplate<typename... Args>\nvoid PRI(int head,Args... tail) {\n    printf(\"%d \",head);\n    PRI(tail...);\n}\n#define RF(x) scanf(\"%lf\",&(x))\n#define RS(x) scanf(\"%s\",x)\n#define DPRI(x) fprintf(stderr,\"<\"#x\"=%d>\\n\",x)\n#define DPRII(x,y) fprintf(stderr,\"<\"#x\"=%d, \"#y\"=%d>\\n\",x,y)\n#define DPRIII(x,y,z) fprintf(stderr,\"<\"#x\"=%d, \"#y\"=%d, \"#z\"=%d>\\n\",x,y,z)\n#define DPRIIII(x,y,z,w) fprintf(stderr,\"<\"#x\"=%d, \"#y\"=%d, \"#z\"=%d \"#w\"=%d>\\n\",x,y,z,w)\n#define DPRF(x) fprintf(stderr,\"<\"#x\"=%lf>\\n\",x)\n#define DPRS(x) fprintf(stderr,\"<\"#x\"=%s>\\n\",x)\n#define DPRMSG(x) fprintf(stderr,#x\"\\n\")\n#define DPRPII(x) fprintf(stderr,\"<\"#x\"=(%d,%d)>\\n\",x.F,x.S)\ntypedef pair<int,int> pii;\n// }}}\n// #functions {{{\npii operator+(const pii &a,const pii &b) { return MP(a.F+b.F,a.S+b.S); }\npii operator-(const pii &a,const pii &b) { return MP(a.F-b.F,a.S-b.S); }\npii& operator+=(pii &a,const pii &b) { a.F+=b.F; a.S+=b.S; return a; }\npii& operator-=(pii &a,const pii &b) { a.F-=b.F; a.S-=b.S; return a; }\ntemplate <class T,class U>\nbool cmp_second(const pair<T,U> &a,const pair<T,U> &b) { return a.second<b.second; }\ntemplate <class T>\nT gcd(T a,T b) { a=abs(a); b=abs(b); while(b) { T t=b; b=a%b; a=t; } return a; }\ntemplate <class T>\npair<T,T> ext_gcd(T a,T b) {\n   T a0=1,a1=0,b0=0,b1=1;\n   if(a<0) { a=-a; a0=-1; }\n   if(b<0) { b=-b; b1=-1; }\n   while(b) {\n      T t,q=a/b;\n      t=b; b=a-b*q; a=t;\n      t=b0; b0=a0-b0*q; a0=t;\n      t=b1; b1=a1-b1*q; a1=t;\n   }\n   return MP(a0,a1);\n}\ninline int sg(int x) { return x>=0?1:-1; }\ninline string concatenate_strings(vector<string> ss) {\n   string s;\n   for(int i=0;i<ss.size();i++)\n      s+=ss[i];\n   return s;\n}\ntemplate <class T>\ninline vector<T> read_from_string(string s) {\n   vector<T> ret; stringstream ss(s,stringstream::in);\n   while(1) { T x; ss>>x; ret.push_back(x); if(ss.eof()) break; }\n   return ret;\n}\n// }}}\n\n#define MAXN 8\n#define MAXS 240\n#define MAXV 200\n\nconst int inf=1000000000;\n\nint n,r,pn;\nvector<pii> pts;\nint dp[MAXN+1][MAXS+1][MAXS+1];\npair<pair<int,pii>,pii> pred[MAXN+1][MAXS+1][MAXS+1];\n\nvoid solve() {\n    pn = pts.size();\n    for(int i=0;i<=n;i++)\n        for(int xs=0;xs<=MAXS;xs++)\n            for(int ys=0;ys<=MAXS;ys++)\n                dp[i][xs][ys] = -inf;\n    dp[0][0][0] = 0;\n    for(int i=0;i<n;i++) {\n        for(int xs=0;xs<=MAXS;xs++) {\n            for(int ys=0;ys<=MAXS;ys++) {\n                int old = dp[i][xs][ys];\n                //printf(\"%d %d %d = %d\\n\",i,xs,ys,dp[i][xs][ys]);\n                if(old<0) continue;\n                for(int v=0;v<pn;v++) {\n                    int x = pts[v].F;\n                    int y = pts[v].S;\n                    int val = old + (n-1)*(x*x+y*y) - 2*x*xs - 2*y*ys;\n                    int nxs = abs(xs+x);\n                    int nys = abs(ys+y);\n                    if(val>dp[i+1][nxs][nys]) {\n                        dp[i+1][nxs][nys] = val;\n                        pred[i+1][nxs][nys] = MP(MP(v,MP(sg(xs+x),sg(ys+y))),MP(xs,ys));\n                    }\n                }\n            }\n        }\n    }\n    //\n    pair<int,pii> ss(-inf,MP(0,0));\n    for(int xs=0;xs<=MAXS;xs++)\n        for(int ys=0;ys<=MAXS;ys++)\n            ss = max(ss,MP(dp[n][xs][ys],MP(xs,ys)));\n    int sol = ss.F;\n    int xs = ss.S.F;\n    int ys = ss.S.S;\n    printf(\"%d\\n\",sol);\n    int gx=1;\n    int gy=1;\n    for(int i=n;i>0;i--) {\n        int v = pred[i][xs][ys].F.F;\n        int sgx = pred[i][xs][ys].F.S.F;\n        int sgy = pred[i][xs][ys].F.S.S;\n        //printf(\">> %d %d %d\\n\",v,sgx,sgy);\n        int pxs = pred[i][xs][ys].S.F;\n        int pys = pred[i][xs][ys].S.S;\n        gx*=sgx;\n        gy*=sgy;\n        xs = pxs;\n        ys = pys;\n        printf(\"%d %d\\n\",gx*pts[v].F,gy*pts[v].S);\n    }\n}\n\nint main(void)\n{\n    RI(n,r);\n    for(int x=-r;x<=r;x++)\n        for(int y=-r;y<=r;y++)\n            if(x*x+y*y<=r*r&&x*x+y*y>(r-1)*(r-1)) pts.PB(MP(x,y));\n    //printf(\"%d\\n\",(int)pts.size());\n    solve();\n    return 0;\n}\n\n// vim: fdm=marker:commentstring=//\\ %s:nowrap:autoread\n\n"], "input": "", "output": "", "tags": ["brute force", "geometry", "math", "sortings"], "dificulty": "2700", "interactive": false}