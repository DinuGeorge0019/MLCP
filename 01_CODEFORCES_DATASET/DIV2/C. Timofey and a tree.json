{
    "link": "https://codeforces.com//contest/764/problem/C",
    "problemId": "91416",
    "problem_idx": "C",
    "shortId": "764C",
    "contest_number": "764",
    "problem_submissions": {
        "D": [
            24382753,
            24383563,
            24382081,
            24374931,
            24375041,
            24375093,
            24373708,
            24376744,
            24377867,
            24377929,
            24378185,
            24376005,
            24379286,
            24378043,
            24377942,
            24377157,
            24380370,
            24374162
        ],
        "E": [
            24380405,
            24382432,
            24384524,
            24420260
        ],
        "C": [
            24376879,
            24379112,
            24375507,
            24370485,
            24371412,
            24372508,
            24373003,
            24373881,
            24373841,
            24372549,
            24373871,
            24374797,
            24374793,
            24376282,
            24375770,
            24375553,
            24373514,
            24380277
        ],
        "B": [
            24369314,
            24368165,
            24369397,
            24368034,
            24366949,
            24368393,
            24369703,
            24368061,
            24367890,
            24369939,
            24368308,
            24367782,
            24370026,
            24368365,
            24368260,
            24372318,
            24368539,
            24372008
        ],
        "A": [
            24367006,
            24365605,
            24367841,
            24366813,
            24366252,
            24365584,
            24365987,
            24365600,
            24366244,
            24365380,
            24366762,
            24365531,
            24366184,
            24365911,
            24365534,
            24366078,
            24366527,
            24365842
        ]
    },
    "name": "C. Timofey and a tree",
    "statement": "Each New Year Timofey and his friends cut down a tree of vertices and\r\nbring it home. After that they paint all the its vertices, so that the\r\n-th vertex gets color .Now it’s time for Timofey birthday, and his\r\nmother asked him to remove the tree. Timofey removes the tree in the\r\nfollowing way: he takes some vertex in hands, while all the other\r\nvertices move down so that the tree becomes rooted at the chosen vertex.\r\nAfter that Timofey brings the tree to a trash can.Timofey doesn’t like\r\nit when many colors are mixing together. A subtree annoys him if there\r\nare vertices of different color in it. Timofey wants to find a vertex\r\nwhich he should take in hands so that there are no subtrees that annoy\r\nhim. He doesn’t consider the whole tree as a subtree since he can’t see\r\nthe color of the root vertex.A subtree of some vertex is a subgraph\r\ncontaining that vertex and all its descendants.Your task is to determine\r\nif there is a vertex, taking which in hands Timofey wouldn’t be annoyed.\r\n",
    "solutions": [
        "//It is made by ljh2000\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <complex>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200011;\nconst int MAXM = 400011;\nint n,first[MAXN],ecnt,next[MAXM],to[MAXM],col[MAXN],cnt;\nint id[MAXN],pre[MAXN],last[MAXN];\nint ans,yan,ql,qr;\n\nstruct node{\n\tint tag;\n}a[MAXN*3];\n\ninline void link(int x,int y){\n\tnext[++ecnt]=first[x]; first[x]=ecnt; to[ecnt]=y;\n}\n\ninline int getint(){\n    int w=0,q=0; char c=getchar(); while((c<'0'||c>'9') && c!='-') c=getchar();\n    if(c=='-') q=1,c=getchar(); while (c>='0'&&c<='9') w=w*10+c-'0',c=getchar(); return q?-w:w;\n}\n\ninline void dfs(int x,int fa){\n\tid[x]=++cnt; pre[cnt]=x;\n\tfor(int i=first[x];i;i=next[i]) {\n\t\tint v=to[i]; if(v==fa) continue;\n\t\tdfs(v,x);\n\t}\n\tlast[x]=cnt;\n}\n\ninline void build(int root,int l,int r){\n\tif(l==r) { a[root].tag=col[pre[l]]; return ; }\n\tint mid=(l+r)>>1; int lc=root*2,rc=lc+1;\n\tbuild(lc,l,mid); build(rc,mid+1,r);\n\tif(a[lc].tag==a[rc].tag && a[lc].tag!=-1) {\n\t\ta[root].tag=a[lc].tag;\n\t}\n\telse a[root].tag=-1;\n}\n\ninline void query(int root,int l,int r){\n\tif(ql<=l && r<=qr) {\n\t\tif(yan==0) { yan=a[root].tag; return ; }\n\t\telse if(yan==-1) return ;\n\t\telse {\n\t\t\tif(a[root].tag==-1) { yan=-1; return ; }\t\n\t\t\tif(a[root].tag==yan) return;\n\t\t\telse { yan=-1; return ; }\n\t\t}\n\t}\n\tint mid=(l+r)>>1; int lc=root*2,rc=lc+1;\n\tif(ql<=mid) query(lc,l,mid); if(qr>mid) query(rc,mid+1,r);\n}\n\ninline void solve(int x,int fa){\n\tbool ok=true;\n\tfor(int i=first[x];i;i=next[i]) {\n\t\tint v=to[i]; if(v==fa) continue;\n\t\tsolve(v,x); if(ans!=(-1)) return ;\n\t\tql=id[v]; qr=last[v]; yan=0;\n\t\tquery(1,1,n); \n\t\tif(yan==-1) ok=false;\n\t}\n\tif(ok) {\n\t\tql=1; qr=id[x]-1; yan=0;\n\t\tif(ql<=qr) {\n\t\t\tquery(1,1,n);\n\t\t\tif(yan==-1) return ;\n\t\t\tint cun=yan;\n\t\t\tql=last[x]+1; qr=n; yan=0;\n\t\t\tif(ql>qr) { ans=x; return ; }\n\t\t\tquery(1,1,n); \n\t\t\tif(yan==-1) return ;\n\t\t\tif(cun==yan) { ans=x; return ; }\n\t\t}\n\t\telse{\n\t\t\tql=last[x]+1; qr=n; yan=0;\n\t\t\tif(ql>qr) { ans=x; return ; }\n\t\t\tquery(1,1,n); \n\t\t\tif(yan==-1) return ;\n\t\t\tans=x; return ;\n\t\t}\n\t}\n}\n\ninline void work(){\n\tn=getint(); int x,y;\n\tfor(int i=2;i<=n;i++) {\n\t\tx=getint(); y=getint();\n\t\tlink(x,y);\n\t\tlink(y,x);\n\t}\n\tfor(int i=1;i<=n;i++) col[i]=getint();\n\tdfs(1,0);\n\tbuild(1,1,n);\n\tans=-1;\n\tsolve(1,0);\n\tif(ans==-1) {\n\t\tprintf(\"NO\");\n\t}\n\telse {\n\t\tprintf(\"YES\\n\");\n\t\tprintf(\"%d\",ans);\n\t}\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Timofey and a tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/50205",
    "editorial": "Take any edge which vertices are colored in different colors. If such edge doesn't exist you can print any vertex, because all the tree is colored in the same color. Otherwise, try to make a root from each of these vertices. Check if is possible with simple dfs. If it succeedes for one of them, print \"YES\" and this vertex. If it fails for both vertices, the answer is \"NO\". Indeed, if both of them cannot be the root, they lay in the same subtree and they are colored differently. So the condition isn't fulfilled. The asymptotics of this solution is O(n?+?m).\n",
    "hint": []
}