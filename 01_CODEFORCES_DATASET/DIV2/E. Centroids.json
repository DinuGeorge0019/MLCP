{"link": "https://codeforces.com//contest/709/problem/E", "problemId": "68949", "problem_idx": "E", "shortId": "709E", "contest_number": "709", "problem_submissions": {"E": [20130641, 20124651, 20127494, 20128647, 20134582, 20126856, 20131635], "D": [20124898, 20125348, 20125590, 20127651, 20134541, 20123785, 20123545, 20128259, 20122648, 20123757, 20124877, 20126002, 20125331, 20135343, 20147031, 20127080, 20127410], "A": [20115354, 20109861, 20109752, 20110920, 20109926, 20111099, 20110022, 20111671, 20109642, 20109791, 20110166, 20112527, 20111078, 20111468, 20109878, 20109709, 20111812, 20111626, 20110794], "B": [20113833, 20112032, 20112031, 20115708, 20113141, 20117610, 20114244, 20113474, 20115654, 20113525, 20115877, 20114171, 20127022, 20116909, 20114086, 20127412, 20114624, 20117349, 20114057], "C": [20111159, 20114853, 20115377, 20110581, 20114157, 20114293, 20114683, 20116230, 20114209, 20116228, 20114971, 20116431, 20115960, 20116412, 20115647, 20114195, 20117301, 20114265, 20116593]}, "name": "E. Centroids", "statement": "is a connected acyclic graph. Suppose you are given a tree consisting of\r\nvertices. The vertex of this tree is called if the size of each\r\nconnected component that appears if this vertex is removed from the tree\r\ndoesn\u2019t exceed .You are given a tree of size and can perform no more\r\nthan one edge replacement. is the operation of removing one edge from\r\nthe tree (without deleting incident vertices) and inserting one new edge\r\n(without adding new vertices) in such a way that the graph remains a\r\ntree. For each vertex you have to determine if it\u2019s possible to make it\r\ncentroid by performing no more than one edge replacement.\r\n", "solutions": ["#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=4e5+10;\nconst int M=N;\nconst int INF=1e8;\nstruct Edge {\n    int v,next;\n    Edge(int v=-1,int next=-1):v(v),next(next){}\n}e[M*2];\nint head[N],total;\nvoid init(){\n    memset(head,-1,sizeof(head));total=0;\n}\nvoid adde(int u,int v){\n    e[total]=Edge(v,head[u]);head[u]=total++;\n}\nint sz[N];\nint dp[N];\nint n;\nvoid dfs(int u,int f){\n    sz[u]=1;\n    dp[u]=0;\n    for(int i=head[u];i!=-1;i=e[i].next){\n        int v=e[i].v;\n        if(v==f)continue;\n        dfs(v,u);\n        sz[u]+=sz[v];\n        dp[u]=max(dp[v],dp[u]);\n        if(sz[v]<=n/2){\n            dp[u]=max(dp[u],sz[v]);\n        }\n    }\n}\nint ans[N];\nint fun(int u){\n    if(u<0)return 0;\n    int x=dp[u];\n    if(sz[u]<=n/2)x=sz[u];\n    return x;\n}\n\nvoid dfs(int u,int f,int x){\n    if(n-sz[u]-x>n/2)ans[u]=0;\n    else {\n        for(int i=head[u];i!=-1;i=e[i].next){\n            int v=e[i].v;\n            if(v==f)continue;\n            if(sz[v]-dp[v]>n/2){\n                ans[u]=0;break;\n            }\n        }\n    }\n    if(n-sz[u]<=n/2)x=n-sz[u];\n    int a=-1,b=-1;\n    for(int i=head[u];i!=-1;i=e[i].next){\n        int v=e[i].v;\n        if(v==f)continue;\n        if(a==-1||fun(a)<fun(v)){\n            b=a;\n            a=v;\n        }\n        else if(b==-1||fun(b)<fun(v))b=v;\n    }\n    for(int i=head[u];i!=-1;i=e[i].next){\n        int v=e[i].v;\n        if(v==f)continue;\n        if(v!=a){\n            dfs(v,u,max(x,fun(a)));\n        }\n        else dfs(v,u,max(x,fun(b)));\n    }\n}\n\nint main(){\n    #ifdef DouBi\n    freopen(\"in.cpp\",\"r\",stdin);\n    #endif // DouBi\n    while(scanf(\"%d\",&n)!=EOF){\n        init();\n        for(int i=0;i<n-1;i++){\n            int u,v;scanf(\"%d%d\",&u,&v);\n            adde(u,v);\n            adde(v,u);\n        }\n        dfs(1,0);\n        memset(ans,-1,sizeof(ans));\n        dfs(1,0,0);\n        for(int i=1;i<=n;i++){\n            if(ans[i])printf(\"1\");\n            else printf(\"0\");\n            if(i==n)printf(\"\\n\");\n            else printf(\" \");\n        }\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "trees"], "dificulty": "2300", "interactive": false}