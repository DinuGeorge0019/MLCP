{
    "link": "https://codeforces.com//contest/1395/problem/E",
    "problemId": "697393",
    "problem_idx": "E",
    "shortId": "1395E",
    "contest_number": "1395",
    "problem_submissions": {
        "E": [
            89703350,
            89708810,
            89714112,
            89712317,
            89710869,
            89721292,
            89717279,
            89724356,
            89790658,
            89720352,
            89754109,
            89972468,
            89742493
        ],
        "D": [
            89680583,
            89688575,
            89687431,
            89686132,
            89714959,
            89699868,
            89694770,
            89698961,
            89690630,
            89691297,
            89679330,
            89689190,
            89686103,
            89687862,
            89691233,
            89685139,
            89691247,
            89695821,
            89694043,
            89690135
        ],
        "C": [
            89667862,
            89671025,
            89670163,
            89676747,
            89709040,
            89680699,
            89672427,
            89678496,
            89680762,
            89680781,
            89671144,
            89671940,
            89675222,
            89675842,
            89668159,
            89667746,
            89679969,
            89674140,
            89676822,
            89680839
        ],
        "B": [
            89662013,
            89665422,
            89664182,
            89669305,
            89705735,
            89669721,
            89665457,
            89671085,
            89672065,
            89669758,
            89663771,
            89663206,
            89664323,
            89667048,
            89663548,
            89692219,
            89670175,
            89666811,
            89668290,
            89675614
        ],
        "A": [
            89659448,
            89659999,
            89659595,
            89659674,
            89701947,
            89663005,
            89660051,
            89663077,
            89666442,
            89661809,
            89659697,
            89659449,
            89659558,
            89661691,
            89659464,
            89660991,
            89660634,
            89661384,
            89662258,
            89660765
        ],
        "F": [
            89730004,
            89698501,
            89836189,
            89729687
        ]
    },
    "name": "E. Boboniu Walks on Graph",
    "statement": "Boboniu has a graph with n vertices and m edges.The out-degree of each\r\nvertex is at most k.Each edge has an integer weight between 1 and m. No\r\ntwo edges have equal weights.Boboniu likes to walk on the graph with\r\nsome specific rules, which is represented by a tuple (c_1,c_2,\r\nldots,c_k). If he now stands on a vertex u with out-degree i, then he\r\nwill go to the next vertex by the edge with the c_i-th (1\r\nle c_i\r\nle i) smallest weight among all edges outgoing from u.Now Boboniu asks\r\nyou to calculate the number of tuples (c_1,c_2,\r\nldots,c_k) such that 1\r\nle c_i\r\nle i for all i (1\r\nle i\r\nle k). Starting from any vertex u, it is possible to go back to u in\r\nfinite time by walking on the graph under the described rules.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,k,num[20],g[100][100],f[100];\nvector<pair<int,int> >v[200100];\nvector<int>u[200100];\nint cnt[100],res,a[20];\nbool ok[100];\nvoid dfs(int pos){\n\tif(pos==k+1){res++;return;}\n\tfor(int i=0;i<pos;i++){\n\t\tif(ok[num[pos]+i])continue;\n\t\tbool fl=true;\n\t\tfor(int j=1;j<pos;j++)fl&=g[a[j]][num[pos]+i];\n\t\tif(!fl)continue;\n\t\ta[pos]=num[pos]+i;\n\t\tdfs(pos+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=2;i<=k+1;i++)num[i]=num[i-1]+i-1;\n//\tfor(int i=1;i<=k;i++)printf(\"%d \",num[i]);puts(\"\");\n\tfor(int i=1,x,y,z;i<=m;i++)scanf(\"%d%d%d\",&x,&y,&z),v[x].push_back(make_pair(z,y));\n\tfor(int i=1;i<=n;i++)sort(v[i].begin(),v[i].end());\n\tfor(int i=1;i<=n;i++)for(int j=0;j<v[i].size();j++)u[v[i][j].second].push_back(num[v[i].size()]+j);\n\tfor(int i=1;i<=k;i++)for(int j=i+1;j<=k;j++)for(int k=0;k<i;k++)for(int l=0;l<j;l++)g[num[i]+k][num[j]+l]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<num[k+1];j++)cnt[j]=0;\n//\t\tfor(auto j:u[i])printf(\"%d \",j);puts(\"\");\n\t\tfor(auto j:u[i])cnt[j]++;\n\t\tvector<int>vv;\n\t\tfor(int j=0;j<num[k+1];j++){\n\t\t\tif(cnt[j]>=2)ok[j]=true;\n\t\t\telse if(cnt[j]==1)vv.push_back(j);\n\t\t}\n\t\tfor(auto j:vv)for(auto k:vv)g[j][k]=false;\n\t}\n\tdfs(1);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "hashing"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Boboniu Walks on Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/81355",
    "editorial": "Let degu\n denote the out degree of u\n. Let nexu,i\n denote the vertex, which the edge with the i\n-the smallest weight among all edges start from u\n ends at.\n\nFor a fixed tuple (t1,t2,,tk)\n, if {nexi,tdegi|1?i?n}={1,2,,n}\n (i. e. each vertex appears exactly once), then it is a correct tuple.\n\nLet Si,j\n denote if ci=j\n, the set for vertex with out degree i\n, which is {nexu,j|degu=i}\n. Thus the condition above can be changed to: S1,t1?S2,t2??Sk,tk={1,2,,n}\n.\n\nLet's enumerate all k!\n situations and use hash to check if it's correct.\n\nThe hash function is diverse. For example, for a integer set T\n, we can use h(T)=?x?Tvalxmodp\n or h(T)=?x?Tvalxmodp\n. Just make sure it has associative property. Here valx\n may be a random number. Let alone using multiple hash.\n\nThe total time complexity is O(n+m+k!)\n.",
    "hint": []
}