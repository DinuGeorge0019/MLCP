{"link": "https://codeforces.com//contest/228/problem/C", "problemId": "1857", "problem_idx": "C", "shortId": "228C", "contest_number": "228", "problem_submissions": {"D": [2261902, 2260756, 2262084, 2263037, 2262295, 2262513, 2267122], "E": [2260963, 2258057, 2257897, 2258974, 2259887, 2261215, 2260752, 2260117, 2260870, 2262062, 2262069, 2259543, 2261908, 2259655, 2259999, 2259991, 2260321, 2260196, 2260295], "C": [2260163, 2263333, 2260878, 2261707, 2259668, 2261949, 2262461, 2260423, 2262627, 2261069, 2261515, 2272185], "B": [2257986, 2258545, 2258475, 2257641, 2258627, 2257501, 2258104, 2259075, 2257831, 2258346, 2258655, 2258262, 2258816, 2257667, 2258656, 2258407, 2259171, 2258869], "A": [2256975, 2258646, 2256552, 2256842, 2256376, 2256560, 2257820, 2256816, 2256677, 2257146, 2256648, 2257004, 2256374, 2256749, 2256802, 2257128, 2257247, 2257318]}, "name": "C. Fractal Detector", "statement": "Little Vasya likes painting fractals very much.He does it like this.\r\nFirst the boy cuts out a -cell square out of squared paper. Then he\r\npaints some cells black. The boy calls the cut out square a fractal .\r\nThen he takes a clean square sheet of paper and paints a fractal by the\r\nfollowing algorithm: He divides the sheet into four identical squares. A\r\npart of them is painted black according to the fractal pattern. Each\r\nsquare that remained white, is split into 4 lesser white squares, some\r\nof them are painted according to the fractal pattern. Each square that\r\nremained black, is split into 4 lesser black squares. In each of the\r\nfollowing steps step 2 repeats. To draw a fractal, the boy can make an\r\narbitrary positive number of steps of the algorithm. But he need to make\r\nat least two steps. In other words step 2 of the algorithm . The\r\nresulting picture (the square with painted cells) will be a fractal. The\r\nfigure below shows drawing a fractal (here boy made three steps of the\r\nalgorithm). One evening Vasya got very tired, so he didn\u2019t paint the\r\nfractal, he just took a sheet of paper, painted a -cell field. Then\r\nVasya paint some cells black. Now he wonders, how many squares are on\r\nthe field, such that there is a fractal, which can be obtained as\r\ndescribed above, and which is equal to that square. Square is considered\r\nequal to some fractal if they consist of the same amount of elementary\r\nnot divided cells and for each elementary cell of the square\r\ncorresponding elementary cell of the fractal have the same color.\r\n", "solutions": ["// AntiFate\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define fab(i,a,b) for(int i=(a);i<=(b);++i)\n#define fba(i,b,a) for(int i=(b);i>=(a);--i)\n#define clr(a) memset(a,0,sizeof(a))\n#define fec(i,a) for(__typeof((a).end())i=(a).begin();i!=(a).end();++i)\n#define fpc(i,j,v) for(int i=a[v],j;j=to[i],i;i=nx[i])\n\n#define N 555\n\nint a[N][N], s[N][N], d[N][N][12], n, m;\nchar ss[N];\n\nint p[17][2][2];\n\nint main()\n{\n    scanf(\"%d%d\\n\", &n, &m);\n    rep(i,n)\n    {\n        gets(ss+1);\n        rep(j,m)\n        {\n            a[i+1][j+1] = ss[j+1]=='*';\n            s[i+1][j+1] = a[i+1][j+1]+s[i+1][j]+s[i][j+1]-s[i][j];\n        }\n    }\n\n\n    int top = 0;\n    rep(c,16) \n    {\n        ++top;\n        rep(i,2)rep(j,2)\n            p[top][i][j] = c>>(i*2+j)&1;\n    }\n\n    fab(i,2,n) fab(j,2,m)\n        fab(c,1,top)\n        {\n            d[i][j][1] = c;\n            bool ok = true;\n            rep(x,2) rep(y,2)\n                if (p[c][x][y] != a[i-x][j-y])\n                    ok = false;\n            if (ok)\n            {\n//                    cerr<<i<<\",\"<<j<<\",\"<<1<<\",\"<<d[i][j][1]<<endl;\n                break;\n            }\n        }\n    int ans = 0;\n    for (int l = 4, c=2; l <= n && l <= m; l <<= 1,++c)\n    {\n        int k = l/2;\n        fab(i,l,n)\n            fab(j,l,m)\n            {\n                fab(o,1,top)\n                {\n                    bool ok = true;\n                    rep(x,2) rep(y,2)\n                    {\n                        if (p[o][x][y])\n                        {\n                            if (s[i-x*k][j-y*k]-s[i-x*k-k][j-y*k]-s[i-x*k][j-y*k-k]+s[i-x*k-k][j-y*k-k] != k*k)\n                                ok = false;\n                        } else\n                            if (d[i-x*k][j-y*k][c-1]!=o)\n                                ok = false;\n                    }\n                        \n                    if (ok)\n                    {\n                        d[i][j][c] = o;\n                        break;\n                    }\n                }\n                if (d[i][j][c])\n                {\n                    //cerr<<i<<\",\"<<j<<\",\"<<c<<\",\"<<d[i][j][c]<<endl;\n                    ++ans;\n                }\n            }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "hashing"], "dificulty": "2000", "interactive": false}