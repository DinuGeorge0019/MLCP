{
    "link": "https://codeforces.com//contest/1990/problem/C",
    "problemId": "2766778",
    "problem_idx": "C",
    "shortId": "1990C",
    "contest_number": "1990",
    "problem_submissions": {
        "E2": [
            271608671,
            271607138,
            271614388,
            271623848,
            271611159,
            271612390,
            271624654,
            271606284,
            271618767,
            271968367,
            271632009,
            271670295,
            271670041,
            271669953,
            271631571,
            271628300,
            271628735,
            271594502,
            271625522,
            271630429,
            271657508,
            271657312,
            271656848,
            271656620,
            271656329,
            271656057,
            271655884,
            271651026,
            271650811,
            271629403,
            271633667
        ],
        "E1": [
            271608290,
            271606824,
            271613580,
            271620803,
            271612480,
            271607245,
            271626074,
            271605565,
            271618674,
            271617329,
            271631880,
            271630922,
            271628223,
            271626847,
            271593184,
            271625989,
            271629147,
            271621610,
            271633499
        ],
        "D": [
            271584964,
            271585839,
            271588228,
            271580018,
            271775642,
            271574070,
            271621395,
            271597835,
            276025328,
            271618139,
            271579386,
            271580161,
            271592306,
            271593113,
            271583094,
            271588957,
            271599530,
            271586840,
            271606900,
            271582390,
            271597556,
            271601916
        ],
        "C": [
            271573202,
            271574801,
            271573394,
            271562726,
            271563640,
            271558919,
            271563245,
            276025316,
            271572711,
            271573247,
            271567920,
            271567517,
            271556748,
            271561905,
            271578677,
            271614383,
            271580098,
            271585887,
            271628007,
            271582340,
            271582612
        ],
        "B": [
            271544838,
            271560423,
            271562782,
            271545814,
            271553448,
            271544083,
            271550614,
            271557693,
            271552078,
            271550946,
            271576591,
            271554451,
            271552855,
            271607828,
            271555492,
            271573754,
            271547063,
            271567926,
            271553335
        ],
        "A": [
            271536644,
            271538330,
            271540486,
            271536626,
            271537675,
            271536719,
            271540682,
            271537637,
            271536282,
            271542554,
            271544093,
            271538945,
            271539444,
            271610786,
            271544740,
            271545994,
            271537196,
            271539275,
            271540687
        ],
        "F": [
            271738112,
            271736701,
            271736437,
            271736279,
            271732364,
            271623141
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131716",
    "editorial": "Let's consider only non-decreasing arrays. Observe a continuous segments a[l...r]=x(l<r,x>0)\n, after one operation, we get a[l+1,min(r+1,n)]=x\n holds. We can conclude that if, for all non-zero contiguous segments in the array (except the last one), their lengths are all greater than 1\n, then the array follows the \"right shift\" parttern. Let's say this kind of array \"good\".\n\nThe last problem is when will the array become \"good\". Let's assume we get the array b\n after one operation on array a\n, we get bi<bi+1<bi+2\n. We can infer that bi=ai,bi+1=ai+1\n and there is at least aj=ai+1(j?i)\n, which shows that a\n is not non-decreasing. In other words, after two operations, we can always get a \"good\" array. Then the calculating is trival.\n\nTime complexity: O(n)\n.",
    "name": "C. Mad MAD Sum",
    "statement": "We define the\r\noperatorname{MAD} (Maximum Appearing Duplicate) in an array as the\r\nlargest number that appears at least twice in the array. Specifically,\r\nif there is no number that appears at least twice, the\r\noperatorname{MAD} value is 0.For example,\r\noperatorname{MAD}([1, 2, 1]) = 1,\r\noperatorname{MAD}([2, 2, 3, 3]) = 3,\r\noperatorname{MAD}([1, 2, 3, 4]) = 0.You are given an array a of size n.\r\nInitially, a variable sum is set to 0.The following process will be\r\nexecuted in a sequential loop until all numbers in a become 0: Set sum\r\n:= sum +\r\nsum_{i=1}^{n} a_i; Let b be an array of size n. Set b_i :=\r\noperatorname{MAD}([a_1, a_2,\r\nldots, a_i]) for all 1\r\nle i\r\nle n, and then set a_i := b_i for all 1\r\nle i\r\nle n. Find the value of sum after the process.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; using ll = long long;#define int ll #define endl '\\n'#define pb push_backusing pi = array<int, 2>; void skibidi_sigma() {  int n;  cin >> n;    vector<int> a(n + 2);  for (int i = 1; i <= n; ++i) {    cin >> a[i];  }    ll ans = 0;  for (int rep = 0; rep < 2; ++rep) {    int mad = 0;    vector<int> f(n + 1);    for (int i = 1; i <= n; ++i) {      ans += a[i];            if (f[a[i]]) {        mad = max(mad, a[i]);      }      ++f[a[i]];      a[i] = mad;    }  }    int i = 1;  while (i <= n) {    if (a[i] == 0) {      ++i;      continue;    }        int ptr = i + 1;    while (a[ptr] == a[i]) {      ++ptr;    }        int cnt = ptr - i;    int rem = n - ptr + 1;    ll here = (ll)cnt * (rem + 1) + (ll)cnt * (cnt - 1) / 2;    if (cnt == 1) {      here = 1;    }    ans += here * a[i];        i = ptr;  }    cout << ans;} int32_t main() {  ios_base::sync_with_stdio(false);  cin.tie(NULL);    int T;  cin >> T;    while (T--) {    skibidi_sigma();    cout << endl;  }} /* 176 5 5 7 6 7 3 should be: 121 */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Mad MAD Sum.json",
    "hint": []
}