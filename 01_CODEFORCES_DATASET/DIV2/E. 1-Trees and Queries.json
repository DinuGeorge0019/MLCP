{
    "link": "https://codeforces.com//contest/1304/problem/E",
    "problemId": "540881",
    "problem_idx": "E",
    "shortId": "1304E",
    "contest_number": "1304",
    "problem_submissions": {
        "F2": [
            71153662,
            71152758,
            71152225,
            71157272,
            71159942,
            71160337,
            71152268,
            71164565,
            71154293,
            71154692,
            71162717,
            71159530,
            71162560,
            71166676,
            71162579,
            71158531,
            71165317,
            71164377,
            71163973
        ],
        "F1": [
            71153447,
            71152867,
            71152180,
            71151661,
            71153091,
            71154085,
            71149583,
            71154537,
            71154276,
            71154806,
            71156318,
            71151191,
            71154828,
            71149041,
            71160757,
            71162740,
            71158430,
            71158819,
            71164218,
            71159683
        ],
        "A": [
            71141804,
            71123780,
            71124247,
            71124384,
            71123709,
            71123734,
            71133014,
            71123605,
            71123682,
            71125835,
            71124122,
            71125469,
            71123778,
            71125797,
            71123883,
            71124957,
            71124272,
            71124584,
            71125887
        ],
        "B": [
            71141077,
            71127745,
            71130904,
            71129813,
            71129002,
            71129323,
            71131933,
            71128951,
            71128799,
            71129490,
            71131971,
            71130601,
            71128231,
            71131633,
            71131054,
            71131655,
            71131218,
            71131770,
            71130665
        ],
        "C": [
            71139292,
            71131382,
            71132670,
            71132117,
            71132267,
            71132849,
            71127878,
            71132933,
            71133726,
            71136633,
            71134870,
            71133707,
            71131661,
            71135936,
            71133295,
            71134276,
            71135200,
            71134880,
            71134692
        ],
        "D": [
            71135174,
            71139070,
            71140467,
            71140425,
            71138874,
            71140258,
            71140794,
            71137521,
            71136980,
            71141949,
            71140004,
            71141241,
            71141696,
            71140892,
            71143691,
            71147524,
            71140481,
            71142776,
            71142040
        ],
        "E": [
            71129417,
            71143322,
            71144172,
            71144650,
            71144907,
            71145653,
            71155565,
            71142523,
            71145871,
            71145649,
            71146288,
            71152807,
            71148538,
            71135583,
            71146697,
            71149801,
            71151693,
            71149896,
            71147231,
            71153923
        ]
    },
    "name": "E. 1-Trees and Queries",
    "statement": "Gildong was hiking a mountain, walking by millions of trees. Inspired by\r\nthem, he suddenly came up with an interesting idea for trees in data\r\nstructures: Then he found that such tree-like graphs are called . Since\r\nGildong was bored of solving too many tree problems, he wanted to see if\r\nsimilar techniques in trees can be used in 1-trees as well. Instead of\r\nsolving it by himself, he\u2019s going to test you by providing queries on\r\n1-trees.First, he\u2019ll provide you a tree (not 1-tree) with n vertices,\r\nthen he will ask you q queries. Each query contains 5 integers: x, y, a,\r\nb, and k. This means you\u2019re asked to determine if there exists a path\r\nfrom vertex a to b that contains exactly k edges after adding a\r\nbidirectional edge between vertices x and y. . All queries are\r\nindependent of each other; i.e. the added edge in a query is removed in\r\nthe next query.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nconst int _ = 1e5 + 7;\nstruct Edge{int end , upEd;}Ed[_ << 1];\nint N , Q , head[_] , cntEd;\nvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\nint up[_][20] , dep[_];\nvoid dfs(int x , int p){\n\tdep[x] = dep[p] + 1; up[x][0] = p;\n\tfor(int i = 1 ; up[x][i - 1] ; ++i) up[x][i] = up[up[x][i - 1]][i - 1];;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd)\n\t\tif(Ed[i].end != p) dfs(Ed[i].end , x);\n}\n\nint LCA(int x , int y){\n\tif(dep[x] < dep[y]) swap(x , y);\n\tfor(int i = 19 ; i >= 0 ; --i)\n\t\tif(dep[x] - (1 << i) >= dep[y]) x = up[x][i];\n\tif(x == y) return x;\n\tfor(int i = 19 ; i >= 0 ; --i)\n\t\tif(up[x][i] != up[y][i]) {x = up[x][i]; y = up[y][i];}\n\treturn up[x][0];\n}\n\nint dist(int p , int q){return dep[p] + dep[q] - 2 * dep[LCA(p , q)];;}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\tfor(int i = 1 ; i < N ; ++i){int x , y; scanf(\"%d %d\" , &x , &y); addEd(x , y); addEd(y , x);}\n\tdfs(1 , 0); int Q , x , y , a , b , k;\n\tfor(scanf(\"%d\" , &Q) ; Q ; --Q){\n\t\tscanf(\"%d %d %d %d %d\" , &x , &y , &a , &b , &k);\n\t\tint l1 = dist(a , b) , l2 = dist(a , x) + dist(y , b) + 1 , l3 = dist(a , y) + dist(b , x) + 1;\n\t\tbool flg = 0;\n\t\tif(l1 <= k && (k - l1) % 2 == 0) flg = 1;\n\t\tif(l2 <= k && (k - l2) % 2 == 0) flg = 1;\n\t\tif(l3 <= k && (k - l3) % 2 == 0) flg = 1;\n\t\tputs(flg ? \"YES\" : \"NO\");\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. 1-Trees and Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/73934",
    "editorial": "Assume that the length of a path from to is . It is obvious that for\r\nevery non-negative integer , there exists a path from to of length since\r\nwe can go back and forth any edge along the path any number of times.\r\nSo, we want to find the shortest path from to where the parity (odd or\r\neven) of its length is same as the parity of .Since it is a tree, the\r\nparity of the length of every paths from to is unique. However, if we\r\nadd another edge, we can possibly find a path of length with different\r\nparity. The parity is changed only if you use the added edge odd number\r\nof times and the length of the simple path from to is even. Since there\r\nis no reason to take the path multiple times to find the shortest path\r\nof same parity, let\u00e2\u0080\u0099s assume we use it only once. If it doesn\u00e2\u0080\u0099t change\r\nthe parity, we can think of it as trying to find a shorter path with\r\nsame parity of length.Then there are three paths we need to check: The\r\nsimple path from to without using the added edge. The simple path from\r\nto without using the added edge, plus the added edge, plus the simple\r\npath from to without using the added edge. The simple path from to\r\nwithout using the added edge, plus the added edge, plus the simple path\r\nfrom to without using the added edge. Finding the length of each simple\r\npath can be done in time using the well-known LCA (Lowest Common\r\nAncestor) algorithm with pre-processing.Now for the ones that have the\r\nsame parity of length as , we need to determine if the minimum of them\r\nis less than or equal to . If there are no such paths, the answer is\r\n\"NO\". Otherwise the answer is \"YES\".Time complexity: .\r\n"
}