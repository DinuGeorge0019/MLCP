{
    "link": "https://codeforces.com//contest/1789/problem/B",
    "problemId": "1798638",
    "problem_idx": "B",
    "shortId": "1789B",
    "contest_number": "1789",
    "problem_submissions": {
        "F": [
            194969357,
            195749340,
            195084999,
            195084860,
            195102578,
            194979229,
            194979047,
            194978962,
            194975838,
            194975550,
            194975302,
            194975124,
            194974900,
            194974650,
            194974382
        ],
        "D": [
            194964382,
            194946537,
            194952763,
            194935429,
            194953178,
            194957319,
            194960327,
            194955667,
            194955471,
            194960858,
            194960296,
            194949046,
            194949101,
            194950239,
            194953216,
            194952742,
            194952699,
            194953612
        ],
        "E": [
            194946702,
            194955457,
            194962685,
            194950894,
            194964730,
            194965836,
            229633905,
            194969144,
            194969007,
            194970553,
            194969010,
            194970681,
            194953500,
            194973828,
            198576217,
            194953882
        ],
        "C": [
            194930840,
            194935056,
            194937930,
            194962744,
            194937423,
            194944977,
            194941284,
            194940844,
            194947791,
            194945071,
            194938899,
            194933727,
            194937235,
            194936393,
            194947382,
            194937385,
            194938714,
            194934789,
            194942194,
            194939314
        ],
        "B": [
            194927201,
            194928996,
            194933855,
            194950809,
            194928726,
            194933032,
            194930991,
            194927953,
            194937472,
            194934025,
            194928695,
            194928070,
            194927782,
            194930745,
            194932397,
            194929156,
            194930083,
            194929116,
            194929527,
            194930695
        ],
        "A": [
            194926083,
            194926207,
            194930860,
            194952002,
            194926224,
            194926968,
            194926650,
            194926242,
            194934078,
            194927544,
            194926614,
            194926667,
            194926050,
            194926065,
            194927300,
            194926584,
            194927455,
            194927037,
            194926659,
            194927083
        ]
    },
    "name": "B. Serval and Inversion Magic",
    "statement": "Serval has a string s that only consists of and of length n. The i-th\r\ncharacter of s is denoted as s_i, where 1\r\nleq i\r\nleq n.Serval can perform the following operation called Inversion Magic\r\non the string s: Choose an segment [l, r] (1\r\nleq l\r\nleq r\r\nleq n). For l\r\nleq i\r\nleq r, change s_i into if s_i is , and change s_i into if s_i is . For\r\nexample, let s be and the segment [2,5] is chosen. The string s will be\r\nafter performing the Inversion Magic.Serval wants to make s a palindrome\r\nafter performing Inversion Magic . Help him to determine whether it is\r\npossible.A string is a palindrome iff it reads the same backwards as\r\nforwards. For example, is a palindrome but is not.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n    int n; cin >> n;\n    string s; cin >> s;\n    int i = 0;\n    while (i < n && s[i] == s[n - 1 - i]) i++;\n    int r = i;\n    while (r < n / 2 && s[r] != s[n - 1 - r]) r++;\n    for(int j = r; j < n / 2; ++j) {\n        if (s[j] != s[n - 1 - j]) {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"Yes\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "strings",
        "two pointers"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Serval and Inversion Magic.json",
    "editorial_link": "https://codeforces.com//blog/entry/113246",
    "editorial": "If is palindromic initially, we can\noperate on the interval , the answer is Yes.Let\u00e2\u0080\u0099s consider the other\ncase. In a palindrome , for each in , must hold. For those , we may\ncheck whether is true in the initial string. For all the illegal\npositions , the operation must contain either or , but not both. For the\nlegal positions, the operation must contain neither of nor , or both of\nthem.If the illegal positions is continuous (which means that they are\nfor some and ), we may operate on the interval (or ), making the string\npalindromic. The answer is Yes.Otherwise, there must be some legal\npositions that lie between the illegal ones. Suppose the illegal\npositions range between (but not continuous), and the operation is .\nWithout loss of generality, let the operation lies in the left part of\nthe string. Then must hold to correct all the illegal positions. This\ninterval covers all the legal positions that lie between the illegal\nones but does not cover their symmetrical positions. Thus, such kind of\noperation will produce new illegal positions. In other words, there are\nno valid operations in this situation. The answer is No.Time complexity:\n.\n"
}