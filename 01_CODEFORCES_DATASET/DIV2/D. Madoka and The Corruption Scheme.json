{
    "link": "https://codeforces.com//contest/1717/problem/D",
    "problemId": "1527572",
    "problem_idx": "D",
    "shortId": "1717D",
    "contest_number": "1717",
    "problem_submissions": {
        "F": [
            170628195,
            170631297,
            170636621,
            170638786,
            170642998,
            170642114,
            170636113,
            170640846,
            170643077,
            170643996,
            170641292,
            170639769,
            170690219,
            170646621,
            170646461,
            170679476,
            170679133,
            170639635
        ],
        "E": [
            170609804,
            170616589,
            170615870,
            170622633,
            170610853,
            170628228,
            170623924,
            170617172,
            170622667,
            170627714,
            170627468,
            170624918,
            170630751,
            170634625,
            170598060,
            170611863,
            170622101,
            170626877,
            170623213,
            170615426
        ],
        "D": [
            170607171,
            170605005,
            170609922,
            170610949,
            170622497,
            170609050,
            170615733,
            170627107,
            170617123,
            170612935,
            170623602,
            170628949,
            170618958,
            170628847,
            170611626,
            170607221,
            170605022,
            170607463,
            170648316,
            170620005
        ],
        "C": [
            170601766,
            170595872,
            170600515,
            170604005,
            170603370,
            170603689,
            170597455,
            170603675,
            170604089,
            170603783,
            170612791,
            170614880,
            170609148,
            170602273,
            170598587,
            170598491,
            170604850,
            170597420
        ],
        "B": [
            170595706,
            170594734,
            170596230,
            170601030,
            170598846,
            170599230,
            170600372,
            170596828,
            170597841,
            170615090,
            170608022,
            170603542,
            170597876,
            170599659,
            170595411,
            170595780,
            170599224,
            170595920
        ],
        "A": [
            170594341,
            170594250,
            170594713,
            170598166,
            170594912,
            170595202,
            170594533,
            170594589,
            170594840,
            170594292,
            170596316,
            170595526,
            170594805,
            170598577,
            170594243,
            170594388,
            170596942,
            170594653
        ]
    },
    "name": "D. Madoka and The Corruption Scheme",
    "statement": "Madoka decided to entrust the organization of a major computer game\r\ntournament \"\"!In this tournament, matches are held according to the\r\n\"Olympic system\". In other words, there are 2^n participants in the\r\ntournament, numbered with integers from 1 to 2^n. There are n rounds in\r\ntotal in the tournament. In the i-th round there are 2^{n - i} matches\r\nbetween two players (one of whom is right, the other is left), after\r\nwhich the winners go further along the tournament grid, and the losing\r\nparticipants are eliminated from the tournament. Herewith, the relative\r\norder in the next round does not change. And the winner of the\r\ntournament is the last remaining participant.But the smaller the\r\nparticipant\u2019s number, the more he will pay Madoka if he wins, so Madoka\r\nwants the participant with the lowest number to win. To do this, she can\r\narrange the participants in the first round as she likes, and also\r\ndetermine for each match who will win the participant on the left or\r\nright.But Madoka knows that tournament sponsors can change the winner in\r\nmatches no more than k times. (That is, if the participant on the left\r\nwon before the change, then the participant on the right will win after\r\nthe change, and if the participant on the right won, then the\r\nparticipant on the left will win after the change). Print the minimum\r\npossible number of the winner in the tournament, which Madoka can get\r\nregardless of changes in sponsors. But since the answer can be very\r\nlarge, output it modulo 10^9 + 7. Note that we need to minimize the\r\nanswer, and only then take it modulo.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst int P = 1e9 + 7;\ntemplate<class T>\ninline T power(T a, i64 b) {\n\tT res = 1;\n\tfor (; b; b >>= 1, a *= a)\n\t\tif (b & 1) res *= a;\n\treturn res;\n}\ninline int norm(int x) {\n\tif (x < 0) x += P;\n\tif (x >= P) x -= P;\n\treturn x;\n}\nstruct Z {\n\tint x;\n\tZ(int _x = 0) : x(norm(_x)) {}\n\tinline Z operator-() const {\n\t\tif (!x) return 0;\n\t\treturn Z(P - x);\n\t}\n\tinline Z &operator+=(const Z &rhs) {\n\t\tx += rhs.x;\n\t\tif (x >= P) x -= P;\n\t\treturn *this;\n\t}\n\tinline Z &operator-=(const Z &rhs) {\n\t\tx -= rhs.x;\n\t\tif (x < 0) x += P;\n\t\treturn *this;\n\t}\n\tinline Z &operator*=(const Z &rhs) {\n\t\tx = 1ull * x * rhs.x % P;\n\t\treturn *this;\n\t}\n\tinline Z inv() const {\n\t\treturn power(*this, P - 2);\n\t}\n\tinline Z &operator/=(const Z &rhs) {\n\t\t*this *= rhs.inv();\n\t\treturn *this;\n\t}\n\tinline friend Z operator+(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res += rhs, res;\n\t}\n\tinline friend Z operator-(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res -= rhs, res;\n\t}\n\tinline friend Z operator*(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res *= rhs, res;\n\t}\n\tinline friend Z operator/(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res /= rhs, res;\n\t}\n};\nconst int N = 100005;\nZ fac[N], ifac[N], pw[N];\nvoid init(int n) {\n\tfac[0] = pw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tpw[i] = pw[i - 1] * 2;\n\t}\n\tifac[n] = fac[n].inv();\n\tfor (int i = n; i; --i) {\n\t\tifac[i - 1] = ifac[i] * i;\n\t}\n}\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tinit(n);\n\tif (k >= n) {\n\t\tcout << pw[n].x << \"\\n\";\n\t\treturn 0;\n\t}\n\tZ ans = 0;\n\tfor (int i = 0; i <= k; ++i) {\n\t\tans += fac[n] * ifac[i] * ifac[n - i];\n\t}\n\tcout << ans.x << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Madoka and The Corruption Scheme.json",
    "editorial_link": "https://codeforces.com//blog/entry/106553",
    "editorial": "The problem can be reformulated as follows. We've got a complete binary tree with 2n\n leaves. There's a marked edge from each intermediate node to one of its children. The winner is the leaf reachable from the root via marked edges. Changes modify the outgoing marked edge of a node.\n\nNow it should be fairly obvious that there's no reason to change more than one node per level, because only one node matters per level--the one on the path from the root to the answer node. So, the winner only depends on the subset of levels we perform changes on, and vice versa: different subsets always yield different winners.\n\nSponsors can change exactly i\n nodes in (ni)\n ways. Summing this over i\n, we get ?min(n,k)i=0(ni)\n. Call this number m\n. m\n is the number of winners the sponsors choose between--let's call them candidates for brevity. It's easy to see that m\n is the answer to the problem, because a) sponsors can guarantee the winner is at least m\n, as, independent of the list of candidate winners \"provided\" by Madoka, at least one of them must be at least m\n, and b) Madoka can guarantee the winner is at most m\n by firstly marking edges arbitrarily, then computing the list of candidate nodes, and only then fill them with numbers from 1\n to m\n (and the other nodes arbitrarily)."
}