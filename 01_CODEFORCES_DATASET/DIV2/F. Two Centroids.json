{
    "link": "https://codeforces.com//contest/1828/problem/F",
    "problemId": "1922408",
    "problem_idx": "F",
    "shortId": "1828F",
    "contest_number": "1828",
    "problem_submissions": {
        "E": [
            205928976,
            205900019,
            205882115,
            205895924,
            205892096,
            205891436,
            205893344
        ],
        "F": [
            205895469
        ],
        "D2": [
            205889438,
            205883240,
            205883734,
            205896618,
            206159170,
            205894825,
            205895793,
            205893893,
            205897477,
            227549028,
            205896300
        ],
        "D1": [
            205878026,
            205883337,
            205866040,
            205882122,
            205875506,
            205886552,
            205886122,
            205895740,
            205872312,
            205897439,
            227549130,
            205896247,
            205864334,
            205871289,
            205871040,
            205870968,
            205880756,
            205879364
        ],
        "C": [
            205856261,
            205854711,
            205855088,
            205857693,
            205852246,
            205857010,
            205863890,
            205863938,
            205866888,
            205861344,
            205875792,
            205859789,
            205857545,
            205862873,
            205854617,
            205857622,
            205861133,
            205854364,
            205855992,
            205858999
        ],
        "B": [
            205851848,
            205854227,
            205848826,
            205865189,
            205847163,
            205851029,
            205851540,
            205857305,
            205865622,
            205851306,
            205878139,
            205854556,
            205860197,
            205853496,
            205849725,
            205848581,
            205854845,
            205849749,
            205849027,
            205848392
        ],
        "A": [
            205844206,
            205843332,
            205843301,
            205858624,
            205843073,
            205843188,
            205845089,
            205849854,
            205854254,
            205843004,
            205878944,
            205844207,
            205862200,
            205845877,
            205843927,
            205843783,
            205843659,
            205846739,
            205843197,
            205843308
        ]
    },
    "name": "F. Two Centroids",
    "statement": "You are given a tree (an undirected connected acyclic graph) which\r\ninitially only contains vertex 1. There will be several queries to the\r\ngiven tree. In the i-th query, vertex i + 1 will appear and be connected\r\nto vertex p_i (1\r\nle p_i\r\nle i). After each query, please find out the least number of operations\r\nrequired to make the current tree has centroids. In one operation, you\r\ncan add vertex and edge to the tree such that it remains a tree.A vertex\r\nis called a centroid if its removal splits the tree into subtrees with\r\nat most\r\nlfloor\r\nfrac{n}{2}\r\nrfloor vertices each, with n as the number of vertices of the tree. For\r\nexample, the centroid of the following tree is 3 because the biggest\r\nsubtree after removing the centroid has 2 vertices. In the next tree,\r\nvertex 1 and 2 are both centroids.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, d, u) for(int i = d; i <= u; ++i)\n#define dep(i, u, d) for(int i = u; i >= d; --i)\n#define cep(n) while(n--)\n#define gep(i, a) for(int i = firs[a]; i; i = neig[i])\nint ured() {\n\tint re = 0;\n\tchar ch;\n\tdo {\n\t\tch = getchar();\n\t} while('9' < ch || ch < '0');\n\tdo {\n\t\tre = re * 10 + (ch ^ '0');\n\t} while('0' <= (ch = getchar()) && ch <= '9');\n\treturn re;\n}\nvoid uwit(int da) {\n\tint ch[21], cn = 0;\n\tdo {\n\t\tch[++cn] = da - da / 10 * 10;\n\t} while(da /= 10);\n\tdo {\n\t\tputchar('0' ^ ch[cn]);\n\t} while(--cn);\n}\nconst int _maxn = 500011;\nint t, n, p[_maxn], firs[_maxn], neig[_maxn], sizs[_maxn], dfsn[_maxn], cnts, tree[_maxn], atle, maxa, bztb[_maxn][21], dept[_maxn];\nvoid dfs1(int at) {\n\tfor(int i = 0; bztb[bztb[at][i]][i]; ++i) {\n\t\tbztb[at][i + 1] = bztb[bztb[at][i]][i];\n\t}\n\tsizs[at] = 1, dfsn[at] = ++cnts;\n\tgep(i, at) {\n\t\tdept[i] = dept[at] + 1, bztb[i][0] = at, dfs1(i), sizs[at] += sizs[i];\n\t}\n}\nvoid modi(int at) {\n\tfor(; at <= n; at += at & -at) {\n\t\t++tree[at];\n\t}\n}\nint quer(int at) {\n\tint re = 0;\n\tfor(; at; at -= at & -at) {\n\t\tre += tree[at];\n\t}\n\treturn re;\n}\nint qsiz(int at) {\n\treturn quer(dfsn[at] + sizs[at] - 1) - quer(dfsn[at] - 1);\n}\nint atfa(int so) {\n\tif(!so || dept[so] <= dept[atle]) {\n\t\treturn p[atle];\n\t}\n\tfor(int i = dept[so] - dept[atle] - 1, j = 0; i; i >>= 1, ++j) {\n\t\tif(i & 1) {\n\t\t\tso = bztb[so][j];\n\t\t}\n\t}\n\tif(p[so] == atle) {\n\t\treturn so;\n\t} else {\n\t\treturn p[atle];\n\t}\n}\nint asiz(int so) {\n\tif(!so || dept[so] <= dept[atle]) {\n\t\treturn quer(n) - qsiz(atle);\n\t}\n\tfor(int i = dept[so] - dept[atle] - 1, j = 0; i; i >>= 1, ++j) {\n\t\tif(i & 1) {\n\t\t\tso = bztb[so][j];\n\t\t}\n\t}\n\tif(p[so] == atle) {\n\t\treturn qsiz(so);\n\t} else {\n\t\treturn quer(n) - qsiz(atle);\n\t}\n}\nint main() {\n\tt = ured();\n\tcep(t) {\n\t\tn = ured();\n\t\trep(i, 1, n) {\n\t\t\tfirs[i] = tree[i] = 0;\n\t\t\trep(j, 0, 20) {\n\t\t\t\tbztb[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, 2, n) {\n\t\t\tp[i] = ured(), neig[i] = firs[p[i]], firs[p[i]] = i;\n\t\t}\n\t\tcnts = 0, dfs1(1), atle = 1, maxa = 0, modi(1);\n\t\trep(i, 2, n) {\n\t\t\tmodi(dfsn[i]);\n\t\t\tif(asiz(i) > asiz(maxa)) {\n\t\t\t\tmaxa = atfa(i);\n\t\t\t}\n\t\t\tif(asiz(maxa) << 1 > i) {\n\t\t\t\tswap(maxa, atle);\n\t\t\t}\n\t\t\tuwit(abs((asiz(maxa) << 1) - i)), putchar(i == n ? '\\n' : ' ');\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Two Centroids.json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "Observation: The answer for the tree with n\n vertices equals n?2?mx\n where mx\n is the largest subtree among the centroid's children.\n\nLemma: After one query, the centroid will move at most one edge, and when the centroid move, the tree before the query already has two centroids.\n\nProof:\n\n \n\nSuppose the tree before the query has n\n vertices and the current centroid is u\n. Let v1,v2,\u0085,vk\n are the children of u\n and the next query vertex x\n is in subtree v1\n. Clearly, the centroid is either u\n or in the subtree v1\n. Consider the latter case, because the size of subtree v1\n does not greater than ?n2?\n, the size of newly formed subtree including u\n is greater or equal to ?n2?\n. Moving one or more edges away from v1\n will increase the size of this new subtree by one or more, and the vertex can not become centroid because ?n2?+1>?n+12?\n.\n\nThe second part is easy to deduce from the above proof.\n\nWe will solve this problem offline. First, we compute the Euler tour of the final tree and use \"range add query\" data structures like Binary indexed tree (BIT) or Segment tree to maintain each subtree's size. We will maintain the size of the largest subtree among the centroid's children mx\n. In the case where the centroid does not move, we just update mx\n with the size of the subtree including the newly added vertex, otherwise, we set mx\n to ?n2?\n due to the lemma. The time complexity is O(nlogn)\n."
}