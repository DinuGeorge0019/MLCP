{
    "link": "https://codeforces.com//contest/1461/problem/F",
    "problemId": "829211",
    "problem_idx": "F",
    "shortId": "1461F",
    "contest_number": "1461",
    "problem_submissions": {
        "E": [
            100932966,
            100936269,
            100990346,
            100969491,
            100936672,
            100935997,
            100939174,
            100940524,
            100941594,
            101253968,
            100980986,
            100938127,
            100939775,
            100939746,
            100939282,
            100946150,
            100942054,
            100947167,
            100942687,
            100943260,
            100946250,
            100984712,
            100939780
        ],
        "D": [
            100927713,
            100927975,
            100930388,
            100930108,
            100929403,
            100928752,
            100927167,
            101253940,
            100929699,
            100925599,
            100929844,
            100930435,
            100928868,
            100927280,
            100929168,
            100927059,
            100928373,
            100929241,
            100929027,
            100931581
        ],
        "C": [
            100924332,
            100922434,
            100924379,
            100925587,
            100923163,
            100923132,
            100922302,
            101253910,
            100924116,
            100920852,
            100924402,
            100925009,
            100923233,
            100921503,
            100923858,
            100922215,
            100922547,
            100922569,
            100922801,
            100924266
        ],
        "B": [
            100920627,
            100919068,
            100920131,
            100923667,
            100919688,
            100918122,
            100916912,
            101253882,
            100919837,
            100916872,
            100919874,
            100921340,
            100919650,
            100918083,
            100918896,
            100918448,
            100932425,
            100918174,
            100919207,
            100918935
        ],
        "A": [
            100911403,
            100911220,
            100912022,
            100911829,
            100911757,
            100911131,
            100911094,
            101253862,
            100911574,
            100910965,
            100911506,
            100912093,
            100912000,
            100911450,
            100911077,
            100911732,
            100912598,
            100910886,
            100911279,
            100911559
        ],
        "F": [
            101254013,
            101253423,
            100951392,
            101467849,
            126697052
        ]
    },
    "name": "F. Mathematical Expression",
    "statement": "Barbara was late for her math class so as a punishment the teacher made\r\nher solve the task on a sheet of paper. Barbara looked at the sheet of\r\npaper and only saw n numbers a_1, a_2,\r\nldots, a_n without any mathematical symbols. The teacher explained to\r\nBarbara that she has to place the available symbols between the numbers\r\nin a way that would make the resulting expression’s value as large as\r\npossible. To find out which symbols were available the teacher has given\r\nBarbara a string s which contained that information. It’s easy to notice\r\nthat Barbara has to place n - 1 symbols between numbers in total. The\r\nexpression must start with a number and all symbols must be allowed\r\n(i.e. included in s). Note that multiplication takes precedence over\r\naddition or subtraction, addition and subtraction have the same priority\r\nand performed from left to right. Help Barbara and create the required\r\nexpression!\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <string>\n\nconstexpr int N = 100005;\n\nint n;\nint a[N];\nstd::string s;\nbool vis[3], ans[N];\nint last[N], pre[N];\nlong long mul[N], f[N];\n\ninline void solve(int l, int r) {\n    while (l <= r && a[l] == 1) ans[l++] = 1;\n    while (l <= r && a[r] == 1) ans[--r] = 1;\n    if (l >= r) return;\n    mul[l - 1] = 1;\n    for (int i = l; i <= r; ++i) {\n        mul[i] = mul[i - 1] * a[i];\n        if (mul[i] > 1e16) return;\n    }\n    for (int i = l; i <= r; ++i)\n        if (a[i] == 1) {\n            last[i] = i;\n            if (i > l && a[i - 1] == 1) last[i] = last[i - 1];\n        }\n    std::vector<int> id;\n    id.push_back(l);\n    for (int i = l + 1; i < r; ++i)\n        if (a[i] > 1) id.emplace_back(i);\n        else if (a[i + 1] > 1) id.emplace_back(i);\n    id.push_back(r);\n    f[id[0]] = a[l];\n    pre[id[0]] = 0;\n    for (int i = 1; i < id.size(); ++i) {\n        f[id[i]] = mul[id[i]];\n        pre[id[i]] = 0;\n        if (last[id[i]] && f[id[i - 1]] + id[i] - id[i - 1] > f[id[i]]) {\n            f[id[i]] = f[id[i - 1]] + id[i] - id[i - 1];\n            pre[id[i]] = id[i - 1];\n        }\n        for (int j = 0; j < i; ++j)\n            if (f[id[j]] + mul[id[i]] / mul[id[j]] > f[id[i]]) {\n                f[id[i]] = f[id[j]] + mul[id[i]] / mul[id[j]];\n                pre[id[i]] = id[j];\n            }\n    }\n    for (int i = r; pre[i]; i = pre[i]) {\n        ans[pre[i]] = 1;\n        if (last[i] && pre[i] == last[i] - 1) for (int j = pre[i]; j <= i; ++j) ans[j] = 1;\n    }\n}\n\nint main() {\n    std::cin >> n;\n    for (int i = 1; i <= n; ++i) std::cin >> a[i];\n    std::cin >> s;\n    for (char i : s)\n        if (i == '+') vis[0] = 1;\n        else if (i == '*') vis[1] = 1;\n        else vis[2] = 1;\n    if (vis[0] && !vis[1]) {\n        for (int i = 1; i < n; ++i) std::cout << a[i] << '+';\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    if (vis[1] && !vis[0] && !vis[2]) {\n        for (int i = 1; i < n; ++i) std::cout << a[i] << '*';\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    if (vis[2] && !vis[0] && !vis[1]) {\n        for (int i = 1; i < n; ++i) std::cout << a[i] << '-';\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    if (vis[1] && vis[2] && !vis[0]) {\n        for (int i = 1; i <= n; ++i)\n            if (!a[i])\n                ans[i - 1] = 1;\n        for (int i = 1; i < n; ++i) std::cout << a[i] << (ans[i] ? '-' : '*');\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    int last = 0;\n    for (int i = 1; i <= n; ++i)\n        if (!a[i]) {\n            ans[i - 1] = ans[i] = 1;\n            solve(last + 1, i - 1);\n            last = i;\n        }\n    solve(last + 1, n);\n    for (int i = 1; i < n; ++i) std::cout << a[i] << (ans[i] ? '+' : '*');\n    std::cout << a[n] << '\\n';\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mathematical Expression.json",
    "editorial_link": "https://codeforces.com//blog/entry/85491",
    "editorial": "First, letâs solve the problem without the multiplication sign. It is\r\nalways beneficial for us to put a plus or a minus, if there is no plus\r\nsign.Now we will solve the problem when there is a sign to multiply. The\r\ncase when the plus sign is missing is very easy to solve. We put the\r\nsign to multiply to the first zero, then we put a minus sign in front of\r\nthe zero, and after the multiplication signs. Letâs consider the case\r\nwhen there is a plus sign and multiply.Note that it is never beneficial\r\nfor us to use the minus sign. If there are zeros in the expression, then\r\nwe simply put plus signs between them and the expressions are split into\r\nother independent expressions.Now you need to be able to solve an\r\nexpression that has no zeros. To begin with, we take out all units at\r\nthe beginning and at the end separately with plus signs. The following\r\nsolution is now proposed. If the product of numbers is greater than or\r\nequal to , then it is beneficial for us to put the multiplication sign\r\neverywhere. Otherwise, we can use dynamic programming, because the\r\nnumber of numbers greater than one is no more than . Dynamic programming\r\nwill be one dimension. is the most profitable answer if you put signs on\r\nthe prefix. Let us now stand at and want to go to , this means that\r\nbetween the numbers at the -th and -th positions there will be a sign to\r\nmultiply, and after the -th position there will be a sign a plus.\r\n",
    "hint": []
}