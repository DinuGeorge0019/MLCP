{
    "link": "https://codeforces.com//contest/2032/problem/C",
    "problemId": "2994606",
    "problem_idx": "C",
    "shortId": "2032C",
    "contest_number": "2032",
    "problem_submissions": {
        "F": [
            289267915,
            289277706,
            289232912,
            289267377,
            291314197,
            289416021
        ],
        "E": [
            289238022,
            289262776,
            289255223,
            289258448,
            289250787,
            289260574,
            289261929,
            289227660,
            289263018,
            289263597,
            289263187,
            289266715,
            289259935,
            289271752,
            289266962,
            289268830,
            289269008,
            289265714
        ],
        "D": [
            289731015,
            289233613,
            289264637,
            289214258,
            289228700,
            289223391,
            289226883,
            289280487,
            289241431,
            289231526,
            289229626,
            289234786,
            289242007,
            289228890,
            289240630,
            289239305,
            289231442,
            289232355
        ],
        "B": [
            289203679,
            289271925,
            289191670,
            289200056,
            289196726,
            289200003,
            289197742,
            289196982,
            289194362,
            289197275,
            289201147,
            289202156,
            289199141,
            289200655,
            289202275,
            289195764
        ],
        "C": [
            289193496,
            289267532,
            289198910,
            289207633,
            289201326,
            289203591,
            289285062,
            289204577,
            289220034,
            289205439,
            289204433,
            289208681,
            289194187,
            289211250,
            289206397,
            289208627,
            289215203
        ],
        "A": [
            289187421,
            289273450,
            289186675,
            289187594,
            289186664,
            289189130,
            289187996,
            289189265,
            289187088,
            289189596,
            289187843,
            289188574,
            289187095,
            289189623,
            289187877,
            289187863
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135622",
    "editorial": "Without loss of generality, we assume that every array mentioned below\r\nis sorted in non-descending order.An array of elements () will satisfy\r\nthe problemâs criteria iff . The proof is that is the minimum sum\r\npossible of any pair of distinct elements of array , and if it is larger\r\nthan the largest element of , every pair of distinct elements of will be\r\nlarger than any element of on its own.The upper bound for our answer is\r\n. This can be done as follows: we will turn every value from to to this\r\nway, we only have two types of triangles: and . Since , we have , which\r\nmeans the former type of triangles is non-degenerate. The latter is also\r\ntrivially one, as it is a regular/equilateral triangle.Otherwise, weâll\r\nneed a pair of indices (, ), so that in the final array after applying\r\noperations to , and will be respectively the smallest and second\r\nsmallest element, and will be the largest element. Such indices must\r\nsatisfy .Letâs consider a pair that satisfies the above condition, then\r\nwe need to turn elements outside of it (i.e. those before or after )\r\ninto some elements within the range , and indeed we can change them into\r\nthis way, we have everything in place while keeping the relative\r\nrankings of , and as what they are initially. Therefore, for such a\r\npair, the number of operations needed is . This means that for every ,\r\nwe need to find the largest that satisfies the condition, which can\r\neasily be done using two pointers.Sorting complexity: .Two-pointer\r\ncomplexity: .\r\n",
    "name": "C. Trinity",
    "statement": "You are given an array a of n elements a_1, a_2,\r\nldots, a_n.You can perform the following operation any number (possibly\r\n0) of times: Choose two integers i and j, where 1\r\nle i, j\r\nle n, and assign a_i := a_j. Find the minimum number of operations\r\nrequired to make the array a satisfy the condition: For every pairwise\r\ndistinct triplet of indices (x, y, z) (1\r\nle x, y, z\r\nle n, x\r\nne y, y\r\nne z, x\r\nne z), there exists a non-degenerate triangle with side lengths a_x, a_y\r\nand a_z, i.e. a_x + a_y > a_z, a_y + a_z > a_x and a_z + a_x > a_y.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define ll long longusing namespace std;long long read(){\tlong long x=0,f=1;char ch=getchar();\twhile(!isdigit(ch))\t{if(ch=='-') f=-1;ch=getchar();}\twhile(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\treturn x*f;}void write(long long x){    if(x<0) putchar('-'),x=-x;    if(x>9) write(x/10);    putchar(x%10+'0');}const int N=2e5+10;int T,n;int a[N];int find1(int x,int r){\t//if(a[1]+a[2]>x)return 0;\tint l=1;\twhile(l<r){\t\tint mid=(l+r)>>1;\t\tif(a[mid]+a[mid+1]>x)r=mid;\t\telse l=mid+1;\t}\treturn l;}int main(){\t//freopen(\".in\",\"r\",stdin);\t//freopen(\".out\",\"w\",stdout);\tT=read();\twhile(T--){\t\tn=read();\t\tfor(int i=1;i<=n;i++){\t\t\ta[i]=read();\t\t}\t\tsort(a+1,a+n+1);\t\tint ans=1e9;\t\tfor(int i=n;i>=2;i--){\t\t\tint x=find1(a[i],i-1);\t\t\tans=min(ans,n-i+x-1);\t\t}\t\tcout<<ans<<endl;\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Trinity.json",
    "hint": [
        "Hint #1 Without loss of generality, you can rewrite the triangle inequality into a much more compacted form if the side lengths are properly ordered.",
        "Hint #3 To make a sorted array satisfy the problem, we must ensure that .",
        "Hint #4 Fix the result array to have two minimas and one maxima at respectively , and . How many operations are required to do so?",
        "Hint #5 Is there a fast and optimal way to try all possible triplets?"
    ]
}