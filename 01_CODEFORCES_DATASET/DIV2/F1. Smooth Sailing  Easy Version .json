{
    "link": "https://codeforces.com//contest/1920/problem/F1",
    "problemId": "2424505",
    "problem_idx": "F1",
    "shortId": "1920F1",
    "contest_number": "1920",
    "problem_submissions": {
        "F2": [
            241519708,
            242461640,
            241499605,
            241499150,
            241499121,
            241526798,
            241677520,
            242000469
        ],
        "F1": [
            241460299,
            241470662,
            241472660,
            241471905,
            241452735,
            241475361,
            241451154,
            241473438,
            241479153,
            241478315,
            241484928,
            241465563,
            241477422,
            241477811,
            241688562,
            241479348,
            241481887,
            241485652,
            241484576,
            241481175
        ],
        "E": [
            241449808,
            241450749,
            250647629,
            250647603,
            250646809,
            241453536,
            241456702,
            241468503,
            241457240,
            241473848,
            241459615,
            241448891,
            241462905,
            241455611,
            241473828,
            241462340,
            241463447,
            241688611,
            241464804,
            241470317,
            241459879,
            241463678,
            241464099
        ],
        "D": [
            241440349,
            241444733,
            241443927,
            241444084,
            241461216,
            241445290,
            241465918,
            241452364,
            241443025,
            241445939,
            241448263,
            241452666,
            241453380,
            241452851,
            241446075,
            241446900,
            241450746,
            241452656,
            241457511
        ],
        "C": [
            241424760,
            241434849,
            241435347,
            241432571,
            241426106,
            241430363,
            241433735,
            241436246,
            241435590,
            241433210,
            241428829,
            241435049,
            241436115,
            241439877,
            241436063,
            241433607,
            241435067,
            241438107,
            241435335
        ],
        "B": [
            241420376,
            241425242,
            241428830,
            241429674,
            241419228,
            241425601,
            241423672,
            241427964,
            241426457,
            241429604,
            241423387,
            241427147,
            241430484,
            241428576,
            241428228,
            241423313,
            241427602,
            241429162,
            241430149
        ],
        "A": [
            241418935,
            241420574,
            241419051,
            241419262,
            241421587,
            241419112,
            241419031,
            241419259,
            241421308,
            241419216,
            241419840,
            241421070,
            241419328,
            241428462,
            241421467,
            241419238,
            241420328,
            241420339,
            241423810
        ]
    },
    "name": "F1. Smooth Sailing  Easy Version ",
    "statement": "Thomas is sailing around an island surrounded by the ocean. The ocean\r\nand island can be represented by a grid with n rows and m columns. The\r\nrows are numbered from 1 to n from top to bottom, and the columns are\r\nnumbered from 1 to m from left to right. The position of a cell at row r\r\nand column c can be represented as (r, c). Below is an example of a\r\nvalid grid. There are three types of cells: island, ocean and underwater\r\nvolcano. Cells representing the island are marked with a \u201d, cells\r\nrepresenting the ocean are marked with a \u201d, and cells representing an\r\nunderwater volcano are marked with a \u201d. It is guaranteed that there is\r\nat least one island cell and at least one underwater volcano cell. It is\r\nalso guaranteed that the set of all island cells forms a single\r\nconnected component^{\r\ndagger} and the set of all ocean cells and underwater volcano cells\r\nforms a single connected component. Additionally, it is guaranteed that\r\nthere are no island cells at the edge of the grid (that is, at row 1, at\r\nrow n, at column 1, and at column m).Define a starting from cell (x, y)\r\nas a path Thomas takes which satisfies the following conditions: The\r\npath starts and ends at (x, y). If Thomas is at cell (i, j), he can go\r\nto cells (i+1, j), (i-1, j), (i, j-1), and (i, j+1) as long as the\r\ndestination cell and is still inside the grid. Note that it is allowed\r\nfor Thomas to visit the same cell multiple times in the same round trip.\r\nThe path must go around the island and fully encircle it. Some path p\r\nfully encircles the island if it is impossible to go from an island cell\r\nto a cell on the grid border by only traveling cells without visiting a\r\ncell on path p. In the image below, the path starting from (2, 2), going\r\nto (1, 3), and going back to (2, 2) the other way does fully encircle\r\nthe island and is not considered a round trip. The of a round trip is\r\nthe minimum Manhattan distance^{\r\nddagger} from a cell on the round trip to an underwater volcano (note\r\nthat the presence of island cells does not impact this distance).You\r\nhave q queries. A query can be represented as (x, y) and for every\r\nquery, you want to find the maximum safety of a round trip starting from\r\n(x, y). It is guaranteed that (x, y) is an ocean cell or an underwater\r\nvolcano cell.^{\r\ndagger}A set of cells forms a single connected component if from any\r\ncell of this set it is possible to reach any other cell of this set by\r\nmoving only through the cells of this set, each time going to a cell .^{\r\nddagger}Manhattan distance between cells (r_1, c_1) and (r_2, c_2) is\r\nequal to |r_1 - r_2| + |c_1 - c_2|.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int dx[]={1, -1, 0, 0}, dy[]={0, 0, 1, -1};\nint n, m, Q;\n\nvoid solve(){\n   cin >> n >> m >> Q;\n   vector<vector<char>> a(n+1, vector<char>(m+1));\n   int ix=-1, iy=-1;\n   vector<vector<int>> dist(n+1, vector<int>(m+1, -1));\n   queue<pair<int, int>> q;\n   for (int i=1; i<=n; ++i) for (int j=1; j<=m; ++j){\n      cin >> a[i][j];\n      if (a[i][j]=='#') ix=i, iy=j;\n      if (a[i][j]=='v'){\n         q.emplace(i, j);\n         dist[i][j]=0;\n      }\n   }\n   while (q.size()){\n      int x=q.front().first, y=q.front().second;\n      q.pop();\n      for (int k=0; k<4; ++k){\n         int u=x+dx[k], v=y+dy[k];\n         if (u<1 || v<1 || u>n || v>m || dist[u][v]!=-1) continue;\n         dist[u][v]=dist[x][y]+1;\n         q.emplace(u, v);\n      }\n   }\n   while (Q--){\n      int xs, ys; cin >> xs >> ys;\n      int l=0, r=dist[xs][ys];\n      while (l<=r){\n         int mid=(l+r)>>1;\n         queue<pair<pair<int, int>, int>> qq;\n         vector<vector<vector<int>>> f(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\n         qq.push({{xs, ys}, 0});\n         f[xs][ys][0]=1;\n         while (qq.size()){\n            int x=qq.front().first.first, y=qq.front().first.second, z=qq.front().second;\n            qq.pop();\n            for (int k=0; k<4; ++k){\n               int u=x+dx[k], v=y+dy[k], z2=z;\n               if (u<1 || v<1 || u>n || v>m || dist[u][v]<mid || a[u][v]=='#') continue;\n               if (y<=iy && iy<v && ix<=x) z2^=1;\n               else if (v<=iy && iy<y && ix<=x) z2^=1;\n               if (f[u][v][z2]) continue;\n               f[u][v][z2]=1;\n               qq.push({{u, v}, z2});\n            }\n         }\n         if (f[xs][ys][1]) l=mid+1;\n         else r=mid-1;\n      }\n      cout << r << '\\n';\n   }\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   // cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Smooth Sailing  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/122560",
    "editorial": "For each non-island cell (i,j)\n, let di,j\n be the minimum Manhattan distance of cell (i,j)\n to an underwater volcano. We can find all di,j\n with a multisource BFS from all underwater volcanos. The danger of a round trip is the smallest value of du,v\n over all (u,v)\n in the path.\n\nFor each query, binary search on the answer k\n \u0097 we can only visit cell (i,j\n) if di,j?k\n. Now, let's mark all cells (i,j\n) (di,j?k\n) reachable from (x,y\n). There exists a valid round trip if it is not possible to go from an island cell to a border cell without touching a marked cell.\n\nThe time complexity of this solution is O(nmlog(n+m))\n."
}