{
    "link": "https://codeforces.com//contest/1735/problem/A",
    "problemId": "1564415",
    "problem_idx": "A",
    "shortId": "1735A",
    "contest_number": "1735",
    "problem_submissions": {
        "B": [
            177889662,
            177889589,
            174382271,
            174383359,
            174378958,
            174381714,
            174380678,
            174381284,
            174379449,
            174381236,
            174383409,
            174380794,
            174386997,
            174380696,
            174383029,
            174388681,
            174388918,
            174381361,
            174381492,
            174380657
        ],
        "C": [
            177889461,
            174387237,
            174388475,
            174385426,
            174386634,
            174386940,
            174388812,
            174387047,
            174386729,
            174389951,
            174392206,
            174395309,
            174395650,
            174392066,
            174399201,
            174396076,
            174396038,
            174408989,
            174396383
        ],
        "D": [
            177889264,
            177889136,
            174395610,
            174396308,
            174396251,
            174394725,
            174402042,
            174395692,
            174394285,
            174419012,
            174399212,
            175815897,
            174399788,
            174408325,
            174404931,
            174401396,
            174409441,
            174402400,
            174412649,
            174401383,
            174405540
        ],
        "E": [
            177889081,
            174408134,
            174405644,
            174412472,
            174412292,
            174413019,
            174414458,
            174417521,
            174411011,
            174419212,
            175815464,
            174463147,
            174421324,
            174420863,
            174423975,
            174427537,
            174420606,
            174423899,
            174420778,
            174422936,
            174422611
        ],
        "F": [
            177888879,
            174528121,
            174463614,
            174586382
        ],
        "A": [
            177888485,
            174377614,
            174378788,
            174377462,
            174377792,
            174377956,
            174378462,
            174377717,
            174377806,
            174378861,
            174382247,
            174379109,
            174377781,
            174377528,
            174379924,
            174379851,
            174378283,
            174383584,
            174377997
        ]
    },
    "name": "A. Working Week",
    "statement": "Your working week consists of n days numbered from 1 to n, after day n\r\ngoes day 1 again. And 3 of them are days off. One of the days off is the\r\nlast day, day n. You have to decide when the other two are.Choosing days\r\noff, you pursue two goals: No two days should go one after the other.\r\nNote that you can’t make day 1 a day off because it follows day n.\r\nWorking segments framed by days off should be as dissimilar as possible\r\nin duration. More specifically, if the segments are of size l_1, l_2,\r\nand l_3 days long, you want to maximize\r\nmin(|l_1 - l_2|, |l_2 - l_3|, |l_3 - l_1|). Output the maximum value of\r\nmin(|l_1 - l_2|, |l_2 - l_3|, |l_3 - l_1|) that can be obtained.\r\n",
    "solutions": [
        "// LUOGU_RID: 91546394\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+'0');\n}\n#define writesp(x) write(x),putchar(' ')\n#define writeln(x) write(x),putchar('\\n')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nvoid solve() {\n\tint n=read();\n\twriteln((n-6)/3);\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Working Week.json",
    "editorial_link": "https://codeforces.com//blog/entry/107533",
    "editorial": "SolutionLetâs consider that , , and are sorted working segments.If is\r\nnot equal to then we can decrease by and increase by . So weâll increase\r\nthe answer.Weâve got that and we have to work just with and .Now, our\r\nproblem can be rewritten as:, maximize .And as we know that ,\r\njust:maximize .If we increase both values under the minimum scope by\r\none, solutions donât change:maximize .If we choose , then .If the answer\r\nis greater, then and , and it means that but .The only thing is left to\r\ndo is to calculate final answer. And it is or just .It was a\r\nmathematician way of solving. As itâs pretty obvious that is\r\napproximately , you could check and choose the best among them.\r\n",
    "hint": [
        "Hint1 Let's consider that , , and are sorted working segments. Can we explicitly say something about one of them?"
    ]
}