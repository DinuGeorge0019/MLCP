{
    "link": "https://codeforces.com//contest/2055/problem/E",
    "problemId": "3141118",
    "problem_idx": "E",
    "shortId": "2055E",
    "contest_number": "2055",
    "problem_submissions": {
        "E": [
            300746486,
            300849536,
            300761124
        ],
        "D": [
            300696033,
            300705238,
            300701008,
            300702007,
            300702452,
            300703784,
            300699187,
            300704114,
            300709175,
            300707029,
            300707549,
            300710969,
            300708967,
            300711888,
            300708148,
            300708052,
            300708173,
            300705738
        ],
        "C": [
            300672652,
            300668358,
            300677522,
            300677196,
            300683675,
            300681011,
            300678376,
            300681393,
            300678777,
            300680600,
            300678839,
            300677980,
            300671004,
            300679220,
            300687159,
            300684321,
            300687531,
            300683543
        ],
        "B": [
            300657881,
            300656820,
            300666935,
            300663382,
            300655553,
            300662689,
            300671074,
            300665092,
            300657486,
            300665581,
            300668563,
            300655341,
            300661161,
            300658795,
            300659826,
            300665475,
            300658513,
            300662771
        ],
        "A": [
            300651053,
            300651601,
            300652364,
            300654430,
            300651022,
            300652195,
            300652888,
            300655299,
            300650941,
            300654319,
            300652932,
            300651006,
            300651149,
            300651992,
            300652147,
            300652006,
            300652172,
            300650990
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/138343",
    "editorial": "SolutionLet’s say we fixed some permutation of such that we empty\r\nhaystacks in the order . Notice that a choice of is possible if and only\r\nif the final stack can be cleared, which is equivalent to the constraint\r\nWith this added constraint, the optimal sequence of moves is as follows:\r\nIterate through . For each , try to move its haybales to haystacks , and\r\nif they are all full then move haybales to haystack . Once this process\r\nterminates, move all haystacks from back onto arbitrary haystacks ,\r\nbeing careful to not overflow the height limits. The key observation is\r\nthat the number of extra haybales that must be moved onto haystack is To\r\nshow this, consider the last time that a haybale is moved onto haystack\r\n. At this time, all haybales from haystacks have found a home, either on\r\nthe height limited haystacks or on haystack , from which the identity\r\nimmediately follows. Now, every haystack that wasn’t moved onto haystack\r\nwill get moved once, and every haystack that did gets moved twice.\r\nTherefore, our task becomes the following: Compute for satisfying Notice\r\nthat the term is constant, and we will omit it for the rest of this\r\ntutorial. We will first solve the task with no restriction on to gain\r\nsome intuition. Denote the ordering of pairs corresponding to . Consider\r\nadjacent pairs . Then, if the choice of is optimal, it must not be\r\nbetter to swap their ordering, i.e. As a corollary, there exists an\r\noptimal satisfying the following properties:Claim [Optimality conditions\r\nof $\\\\sigma$]. All pairs with come first. Then, all pairs with come\r\nnext. Then, all pairs with . The pairs with are in ascending order of .\r\nThe pairs with are in descending order of . It is not hard to show that\r\nall such satisfying these properties are optimal by following similar\r\nlogic as above. We leave it as an exercise for the reader.Now, we add in\r\nthe constraint on the final term of the ordering. We will perform\r\ncasework on this final haystack. Notice that for any fixed , if is\r\nmaximized, then so is So, if we were to fix any last haystack , the\r\noptimality conditions tell us that we should still order the remaining\r\nhaystacks as before. Now, we may iterate over all valid and compute the\r\nanswer efficiently as follows: maintain a segment tree with leaves\r\nrepresenting pairs and range queries for This gives an solution.Note\r\nthat it is possible to implement this final step using prefix and suffix\r\nsums to yield an solution, but it is not necessary to do so.\r\n",
    "name": "E. Haystacks",
    "statement": "There are n haystacks labelled from 1 to n, where haystack i contains\r\na_i haybales. One of the haystacks has a needle hidden beneath it, but\r\nyou do not know which one. Your task is to move the haybales so that\r\neach haystack is emptied at least once, allowing you to check if the\r\nneedle is hidden under that particular haystack.However, the process is\r\nnot that simple. Once a haystack i is emptied for the first time, it\r\nwill be assigned a height limit and can no longer contain more than b_i\r\nhaybales. More formally, a move is described as follows: Choose two\r\nhaystacks i and j. If haystack i has not been emptied before, or\r\nhaystack i contains strictly less than b_i haybales, you may move\r\nexactly 1 haybale from haystack j to haystack i. : Before a haystack is\r\nemptied, it has no height limit, and you can move as many haybales as\r\nyou want onto that haystack.Compute the minimum number of moves required\r\nto ensure that each haystack is emptied at least once, or report that it\r\nis impossible.\r\n",
    "solutions": [
        "#include <algorithm>#include <array>#include <bitset>#include <cassert>#include <chrono>#include <cmath>#include <complex>#include <cstring>#include <functional>#include <iomanip>#include <iostream>#include <map>#include <numeric>#include <queue>#include <random>#include <set>#include <vector>#include <climits>using namespace std;using ll=long long;using db=long double;using pi=pair<int,int>;using pl=pair<ll,ll>;using vi=vector<int>;using vl=vector<ll>;using vpi=vector<pi>;using vpl=vector<pl>;#define mp make_pair#define eb emplace_back#define pb push_back#define x first#define y second#define sz(x)int((x).size())#define bg(x) begin(x)#define all(x)(x).begin(),(x).end()#define rall(x) x.rbegin(), x.rend() #define rep(i,a,b)for(int i=(a);i<(b);i++)#define per(i,a,b)for(int i=(b)-1;i>=(a);i--)#define ft front()#define bk back()#define rsz resize#define ins insert#define each(a,x)for(auto&a:x)bool ckmin(auto&a,auto b){return b<a?a=b,1:0;}bool ckmax(auto&a,auto b){return b>a?a=b,1:0;}#ifdef LOCALtemplate<class A, class B>ostream&operator<<(ostream&o,pair<A,B>p){return o<<\"(\"<<p.x<<\", \"<<p.y<<\")\";}template<class A, class B, class C>ostream&operator<<(ostream&o,tuple<A,B,C>t){    return o<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\", \"<<\")\";}auto operator<<(auto&o,auto x)->decltype(x.end(),o){    o<<\"{\";int i=0;for(auto&e:x)o<<\",\"+!i++<<e;return o<<\"}\";}#define debug(X...)cerr<<\"[\"#X\"]: \",[](auto...$){((cerr<<$<<\"; \"),...)<<endl;}(X);#else#define debug(...){}#endif const pi MOVES[] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}; // #include <ext/pb_ds/assoc_container.hpp>// #include <ext/pb_ds/tree_policy.hpp>// using namespace __gnu_pbds;// template<class T>// using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; template<int MOD, int RT> struct mint {    static const int mod = MOD;    static constexpr mint rt() { return RT; }    int v; explicit operator int() const { return v; }    mint() : v(0) {}    mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);        if (v < 0) v += MOD; }    bool operator==(const mint& o) const {        return v == o.v; }    friend bool operator!=(const mint& a, const mint& b) {         return !(a == b); }    friend bool operator<(const mint& a, const mint& b) {         return a.v < b.v; }     mint& operator+=(const mint& o) {         if ((v += o.v) >= MOD) v -= MOD;         return *this; }    mint& operator-=(const mint& o) {         if ((v -= o.v) < 0) v += MOD;         return *this; }    mint& operator*=(const mint& o) {         v = int((ll)v*o.v%MOD); return *this; }    mint& operator/=(const mint& o) { return (*this) *= inv(o); }    friend mint pow(mint a, ll p) {        mint ans = 1; assert(p >= 0);        for (; p; p /= 2, a *= a) if (p&1) ans *= a;        return ans; }    friend mint inv(const mint& a) { assert(a.v != 0);         return pow(a,MOD-2); }            mint operator-() const { return mint(-v); }    mint& operator++() { return *this += 1; }    mint& operator--() { return *this -= 1; }    friend mint operator+(mint a, const mint& b) { return a += b; }    friend mint operator-(mint a, const mint& b) { return a -= b; }    friend mint operator*(mint a, const mint& b) { return a *= b; }    friend mint operator/(mint a, const mint& b) { return a /= b; }    friend ostream& operator<<(ostream& o, const mint& a) { return o << a.v; }    friend istream& operator>>(istream& i, mint& a) {        ll x; i >> x; a = x;        return i;    }}; const int MOD = 998244353;using mi = mint<MOD,5>;using vmi = vector<mi>;using pmi = pair<mi,mi>;using vpmi = vector<pmi>; const int INF = 1e9+2137; pair<ll, vpl> lowest_point(const vpl &p) {    vpl positive;    vpl rest;    for (auto [x, y] : p) {        if (y > x) positive.eb(x, y);        else rest.eb(x, y);    }    ll cur = 0;    ll res = 0;    sort(all(positive));    vpl vres;    for (auto [x, y] : positive) {        cur -= x;        ckmin(res, cur);        cur += y;        vres.eb(x, y);    }    vpl vres_rev;    sort(all(rest), [&](const pl& a, const pl& b) { return a.y < b.y; });    ll cur_rest = 0;    ll res_rest = 0;    for (auto [x, y] : rest) {        cur_rest -= y;        ckmin(res_rest, cur_rest);        cur_rest += x;        vres_rev.eb(x, y);    }    per(i,0,sz(vres_rev)) {        vres.eb(vres_rev[i]);    }    // cur_rest += cur_rest - cur;    res_rest += cur - cur_rest; // przesuniecie odpowiednio    ckmin(res, res_rest);    return {-res, vres};} void solve() {    int n;    cin >> n;    vpl p(n);    rep(i,0,n) cin >> p[i].x >> p[i].y;    sort(all(p), [&](pl a, pl b) { return a.y < b.y; }); // na pewno tak?    debug(p);    ll Y = 0;    ll X = 0;    rep(i,0,n) Y += p[i].y;    rep(i,0,n) X += p[i].x;    if (Y - p[0].y < X) {        cout << \"-1\\n\";        return;    }    ll res = X;     auto [delta, vec] = lowest_point(p);    // debug(delta, vec);     vl minpref(n+1);    vl minsuff(n+1);    minpref[0]=0;    minsuff[n]=0;     ll cur = 0;    rep(i,0,n) {        auto [x, y] = vec[i];        cur -= x;        minpref[i+1] = min(minpref[i], cur);        cur += y;    }    minsuff[n] = cur;    per(i,0,n) {        auto [x, y] = vec[i];        cur -= y;        minsuff[i] = min(minsuff[i+1], cur);        cur += x;    }     ll best_delta = LLONG_MAX;    rep(i,0,n) {        auto [x, y] = vec[i];        if (Y - y < X) continue;        ll later = minsuff[i+1];        later -= y - x;        ll cur_res = max(-minpref[i], -later);        // debug(i, x, y, minpref[i], minsuff[i+1], later, cur_res);        ckmin(best_delta, cur_res);    }     // debug(res, delta, best_delta);    delta = best_delta;     res += delta;    cout << res << '\\n';} signed main() {    cin.tie(0)->sync_with_stdio(0);     int t;    cin >> t;    while (t--) solve();     return 0;} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Haystacks.json"
}