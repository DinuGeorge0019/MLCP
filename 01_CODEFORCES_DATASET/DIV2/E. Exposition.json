{"link": "https://codeforces.com//contest/6/problem/E", "problemId": "26", "problem_idx": "E", "shortId": "6E", "contest_number": "6", "problem_submissions": {"E": [26175, 26385, 26342, 26418, 26467, 26465, 26505, 26312, 26410, 26503, 26782, 26628, 26550, 26677, 26607, 26539, 26533, 26735, 26936], "C": [25891, 25921, 25930, 25897, 25978, 25997, 26089, 26070, 26100, 26052, 25937, 26061, 25992, 26173, 26244, 25966, 26354, 25996], "B": [25826, 25819, 25838, 25999, 25888, 25890, 25968, 25955, 25976, 25834, 25830, 25878, 25825, 25998, 26069, 25874, 25975, 26190], "A": [25745, 25746, 25756, 25758, 25781, 25768, 25956, 25861, 25763, 25747, 25767, 25761, 25753, 25813, 25837, 25764, 25755, 25792], "D": [2822667, 27721, 2820593, 28387]}, "name": "E. Exposition", "statement": "There are several days left before the fiftieth birthday of a famous\r\nBerland\u2019s writer Berlbury. In this connection the local library decided\r\nto make an exposition of the works of this famous science-fiction\r\nwriter. It was decided as well that it is necessary to include into the\r\nexposition only those books that were published during a particular time\r\nperiod. It is obvious that if the books differ much in size, the\r\nvisitors will not like it. That was why the organizers came to the\r\nopinion, that the difference between the highest and the lowest books in\r\nthe exposition should be not more than millimeters.The library has\r\nvolumes of books by Berlbury, arranged in chronological order of their\r\nappearance. The height of each book in millimeters is know, it is . As\r\nBerlbury is highly respected in the city, the organizers want to include\r\ninto the exposition as many books as possible, and to find out what\r\nperiods of his creative work they will manage to cover. You are asked to\r\nhelp the organizers cope with this hard task.\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int N = 100*1001;\nint n,k,h[N],e[N];\n\nmultiset<int> s;\n\nbool ok() {\n    if (s.empty()) return true;\n    return ( (*s.rbegin())-(*s.begin()) <= k );\n}\n\nint main() {\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0;i<n;i++)\n        scanf(\"%d\",&h[i]);\n    for(int i=0;i<n;i++) {\n        if (i==0) e[i]=0; else e[i]=e[i-1];\n        while(e[i]<n && ok()) {\n            s.insert(h[e[i]]);\n            e[i]++;\n        }\n        if (!ok()) {\n            e[i]--;\n            s.erase(s.find(h[e[i]]));\n        }\n        s.erase(s.find(h[i]));\n    }\n   // for(int i=0;i<n;i++) printf(\"%d\\n\",e[i]);\n    int best = 1;\n    for(int i=0;i<n;i++) best=max(best,e[i]-i);\n    int c=0;\n    for(int i=0;i<n;i++) if (e[i]-i==best) c++;\n    printf(\"%d %d\\n\",best,c);\n    for(int i=0;i<n;i++)\n        if (e[i]-i==best) printf(\"%d %d\\n\",i+1,e[i]);\n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dsu", "trees", "two pointers"], "dificulty": "1900", "interactive": false}