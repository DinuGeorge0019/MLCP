{
    "link": "https://codeforces.com//contest/454/problem/E",
    "problemId": "11932",
    "problem_idx": "E",
    "shortId": "454E",
    "contest_number": "454",
    "problem_submissions": {
        "E": [
            7317497
        ],
        "D": [
            7315165,
            7316655,
            7315850,
            7316966,
            7316988,
            7316976,
            7317778,
            7318354,
            7318456,
            7317666,
            7317555,
            7318543,
            7319222,
            7318726,
            7317841,
            7320896,
            7320849,
            7319120,
            7319784,
            7318403,
            7318794
        ],
        "C": [
            7312738,
            7311706,
            7313880,
            7309986,
            7311157,
            7313294,
            7311115,
            7311374,
            7312788,
            7314689,
            7313048,
            7310594,
            7313465,
            7311432,
            7315295,
            7315016,
            7313938,
            7313281,
            7316560
        ],
        "B": [
            7309947,
            7310409,
            7311046,
            7311468,
            7312031,
            7310861,
            7312086,
            7311916,
            7309623,
            7310693,
            7312314,
            7312987,
            7310239,
            7313802,
            7311790,
            7310408,
            7312163,
            7311161,
            7312424
        ],
        "A": [
            7308622,
            7310283,
            7309770,
            7312107,
            7308641,
            7308657,
            7312828,
            7309446,
            7308673,
            7309245,
            7309405,
            7313814,
            7308860,
            7311907,
            7309469,
            7311125,
            7309147,
            7309374,
            7309615
        ]
    },
    "name": "E. Little Pony and Summer Sun Celebration",
    "statement": "Twilight Sparkle learnt that the evil Nightmare Moon would return during\r\nthe upcoming Summer Sun Celebration after one thousand years of\r\nimprisonment on the moon. She tried to warn her mentor Princess\r\nCelestia, but the princess ignored her and sent her to Ponyville to\r\ncheck on the preparations for the celebration. Twilight Sparkle wanted\r\nto track the path of Nightmare Moon. Unfortunately, she didnâ€™t know the\r\nexact path. What she knew is the parity of the number of times that each\r\nplace Nightmare Moon visited. Can you help Twilight Sparkle to restore\r\nany path that is consistent with this information?Ponyville can be\r\nrepresented as an undirected graph (vertices are places, edges are roads\r\nbetween places) without self-loops and multi-edges. The path can start\r\nand end at any place (also it can be empty). Each place can be visited\r\nmultiple times. The path must not visit more than places.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n\n#define inf 0x3f3f3f3f\n#define Inf 0x3FFFFFFFFFFFFFFFLL\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define Rep(i, n) for (int i = 1; i <= (n); ++i)\n#define clr(x, a) memset(x, (a), sizeof x)\nusing namespace std;\ntypedef long long ll;\nint const N = 101010;\nint const M = 1001000;\nint parents[N];\nint Find(int a) {\n    return parents[a] < 0 ? a : parents[a] = Find(parents[a]);\n}\nvoid Union(int a,int b) {\n    if (parents[a] < parents[b]) parents[a] += parents[b], parents[b] = a;\n    else parents[b] += parents[a], parents[a] = b;\n}\nint n, m;\nstruct edges{ int u, next; } e[M];\nint p[N], idx;\nvoid addedge(int u, int v) {\n\te[idx].u = v, e[idx].next = p[u], p[u] = idx++;\n}\nvoid init() { idx = 0; clr(p, 0xff); clr(parents, 0xff); }\nint v[N];\nvector <int> ans;\n\nvoid dfs(int u, int pre) {\n\t//printf(\"dfs(%d,%d)\\n\",u,pre);\n\tans.push_back(u);\n\tv[u] ^= 1;\n\tfor (int i = p[u]; ~i; i = e[i].next) {\n\t\tint t = e[i].u;\n\t\tif (t != pre) dfs(t, u);\n\t}\n\tif (v[u] == 1) {\n\t\tif (pre == -1) {\n\t\t\tfor (int i = p[u]; ~i; i = e[i].next) {\n\t\t\t\tint t = e[i].u;\n\t\t\t\tans.push_back(t);\n\t\t\t\tans.push_back(u);\n\t\t\t\tans.push_back(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tans.push_back(pre);\n\t\t\tans.push_back(u);\n\t\t\tans.push_back(pre);\n\t\t}\n\t} else if (pre != -1) {\n\t\tans.push_back(pre);\n\t\tv[pre] ^= 1;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tinit();\n\tint a, b;\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tint ra = Find(a), rb = Find(b);\n\t\tif (ra != rb) {\n\t\t\tUnion(ra, rb);\n\t\t\taddedge(a, b);\n\t\t\taddedge(b, a);\n\t\t}\n\t}\n\tRep(i, n) scanf(\"%d\", &v[i]);\n\tRep(i, n) Find(i);\n\t\n\tint g = -1, root = -1;\n\t\n\tRep(i, n) {\n\t\tint r = Find(i);\n\t\tif (v[i] == 1) {\n\t\t\tif (r == g) continue;\n\t\t\tif (g != -1) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tg = r;\n\t\t\troot = i;\n\t\t}\n\t}\n\tif (root == -1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tdfs(root, -1);\n\tprintf(\"%d\\n\", ans.size());\n\tint sz = ans.size();\n\trep(i, sz) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Little Pony and Summer Sun Celebration.json",
    "editorial_link": "https://codeforces.com//blog/entry/13190",
    "editorial": "Brief description:\nGiven a undirected graph with n nodes and the parity of the number of times that each place is visited. Construct a consistent path.\n\nAnalysis:\nThere is no solution if there is more than 1 connected component which have odd node (because we can't move between two component), otherwise it is always solvable.\n\nThis fact is not obvious, let's focus on one component. You can select any node to start, denoted it as r (root). Start from r, you can go to any other odd node then back. Each time you can eliminate one odd node. After that, if r itself is odd, you can simply delete the first or last element in your path (it must be r).\n\nThe only spot of the above method is the size of the path can been large as O(n2). We need a more local observation. Let's check the following dfs() function:\nThis dfs() maintain the following loop invariant: before we leave a node u, we clear all odd node in the sub-tree rooted at u as well as u itself.\n\nThe only u can break the invariant is the root itself. So after dfs(), we use O(1) time to check weather root is still a odd node, if yes, delete the first or last element of the path (it must be r).\n\nAfter that, all the node will been clear, each node can involve at most 4 items in the path. So the size of the path will less than or equal to 4n. Thus the overall complexity is O(n?+?m).",
    "hint": []
}