{"link": "https://codeforces.com//contest/719/problem/E", "problemId": "72549", "problem_idx": "E", "shortId": "719E", "contest_number": "719", "problem_submissions": {"E": [20857732, 20855529, 20857648, 20855213, 20863812, 20863755, 20863994, 20863152, 20865084, 24756348, 20863823], "C": [20849024, 20848386, 20862586, 20849914, 20851187, 20849594, 20854381, 20851294, 20851826, 20854890, 20857785, 20864901, 20852146, 20863089, 20850894, 20856089, 20855488, 20853880, 20871997, 20860028, 20857169], "B": [20843137, 20842011, 20842324, 20842639, 20842442, 20842617, 20844099, 20845184, 20845449, 20842596, 20840279, 20843610, 20841821, 20857950, 20841093, 20846281, 20843045, 20844261, 20853010, 20851104], "A": [20838260, 20837974, 20839081, 20840845, 20849048, 20838199, 20843109, 20840343, 20837834, 20838967, 20838053, 20841248, 20838212, 20838080, 20838256, 20839341, 20838731, 20839029, 20849067]}, "name": "E. Sasha and Array", "statement": "Sasha has an array of integers . You have to perform queries. There\r\nmight be queries of two types: increase all integers on the segment from\r\nto by values ; find , where is the -th Fibonacci number. As this number\r\nmay be large, you only have to find it modulo . In this problem we\r\ndefine Fibonacci numbers as follows: , , for all .Sasha is a very\r\ntalented boy and he managed to perform all queries in five seconds. Will\r\nyou be able to write the program that performs as well as Sasha?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint a[100010];\n\nstruct Mat {\n    int a[2][2];\n    void clear() {\n        memset(a, 0, sizeof(a));\n    }\n    void one() {\n        a[0][0] = a[1][1] = 1;\n        a[0][1] = a[1][0] = 0;\n    }\n    Mat operator + (const Mat &b) const {\n        Mat tmp;\n        tmp.clear();\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                tmp.a[i][j] = a[i][j] + b.a[i][j];\n                if (tmp.a[i][j] >= MOD) {\n                    tmp.a[i][j] -= MOD;\n                }\n            }\n        }\n        return tmp;\n    }\n    Mat operator * (const Mat &b) const {\n        Mat tmp;\n        tmp.clear();\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                for (int k = 0; k < 2; k++) {\n                    tmp.a[i][k] += (long long)a[i][j] * b.a[j][k] % MOD;\n                    if (tmp.a[i][k] >= MOD) {\n                        tmp.a[i][k] -= MOD;\n                    }\n                }\n            }\n        }\n        return tmp;\n    }\n    Mat pw(int x) {\n        Mat ans, num = *this;\n        ans.one();\n        while (x > 0) {\n            if (x & 1) {\n                ans = ans * num;\n            }\n            num = num * num;\n            x >>= 1;\n        }\n        return ans;\n    }\n};\n\nstruct Tree {\n    int l, r;\n    Mat sum;\n    Mat mult;\n};\n\nTree seg[400010];\n\nMat fibo, tmp;\n\nvoid build(int id, int l, int r) {\n    seg[id].l = l;\n    seg[id].r = r;\n    seg[id].sum.clear();\n    seg[id].mult.one();\n    if (l == r) {\n        seg[id].sum = fibo.pw(a[l] - 1);\n    } else {\n        int mid = (l + r) >> 1;\n        build(id * 2, l, mid);\n        build(id * 2 + 1, mid + 1, r);\n        seg[id].sum = seg[id * 2].sum + seg[id * 2 + 1].sum;\n    }\n}\n\nvoid Down(int id) {\n    seg[id * 2].sum = seg[id * 2].sum * seg[id].mult;\n    seg[id * 2].mult = seg[id * 2].mult * seg[id].mult;\n    seg[id * 2 + 1].sum = seg[id * 2 + 1].sum * seg[id].mult;\n    seg[id * 2 + 1].mult = seg[id * 2 + 1].mult * seg[id].mult;\n\n    seg[id].mult.one();\n}\n\nvoid update(int id, int l, int r) {\n    if (seg[id].r < l || seg[id].l > r) return;\n    if (seg[id].l >= l && seg[id].r <= r) {\n        seg[id].sum = seg[id].sum * tmp;\n        seg[id].mult = seg[id].mult * tmp;\n        return;\n    }\n    Down(id);\n    update(id * 2, l, r);\n    update(id * 2 + 1, l, r);\n    seg[id].sum = seg[id * 2].sum + seg[id * 2 + 1].sum;\n}\n\nMat query(int id, int l, int r) {\n    if (seg[id].r < l || seg[id].l > r) {\n        Mat res;\n        res.clear();\n        return res;\n    }\n    if (seg[id].l >= l && seg[id].r <= r) {\n        return seg[id].sum;\n    }\n    Down(id);\n    return query(id * 2, l, r) + query(id * 2 + 1, l, r);\n}\n\nint main() {\n    fibo.a[0][0] = fibo.a[0][1] = fibo.a[1][0] = 1;\n    fibo.a[1][1] = 0;\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    build(1, 1, n);\n    for (int i = 0; i < m; i++) {\n        int ope;\n        scanf(\"%d\", &ope);\n        if (ope == 1) {\n            int l, r, x;\n            scanf(\"%d%d%d\", &l, &r, &x);\n            tmp = fibo;\n            tmp = tmp.pw(x);\n            update(1, l, r);\n        } else {\n            int l, r;\n            scanf(\"%d%d\", &l, &r);\n            Mat res = query(1, l, r);\n            printf(\"%d\\n\", (res.a[1][0] + res.a[1][1]) % MOD);\n        }\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "math", "matrices"], "dificulty": "2300", "interactive": false}