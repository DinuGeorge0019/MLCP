{"link": "https://codeforces.com//contest/467/problem/D", "problemId": "13811", "problem_idx": "D", "shortId": "467D", "contest_number": "467", "problem_submissions": {"D": [7834909, 7835438, 7836074, 7839180, 7840905, 7839272, 7841167, 7841073, 7840587, 7837720, 7843047, 7843018, 7842881, 7841429], "B": [7829550, 7830678, 7829249, 7829723, 7829417, 7832664, 7830103, 7831256, 7830256, 7839394, 7831541, 7829075, 7831182, 7833602, 7829553, 7831084, 7831150, 7831114], "C": [7829448, 7830619, 7831831, 7832345, 7832107, 7831414, 7832445, 7849938, 7833649, 7834054, 7831686, 7835057, 7832606, 7832750, 7835657, 7830837, 7832681, 7833554, 7834610, 7838020], "A": [7827537, 7827380, 7827697, 7827343, 7827487, 7831859, 7828592, 7827610, 7827679, 7840381, 7827513, 7827429, 7827326, 7831348, 7827641, 8494956, 7828703, 7827713, 7829389], "E": [7852679]}, "name": "D. Fedor and Essay", "statement": "After you had helped Fedor to find friends in the Call of Soldiers 3\r\ngame, he stopped studying completely. Today, the English teacher told\r\nhim to prepare an essay. Fedor didn\u2019t want to prepare the essay, so he\r\nasked Alex for help. Alex came to help and wrote the essay for Fedor.\r\nBut Fedor didn\u2019t like the essay at all. Now Fedor is going to change the\r\nessay using the synonym dictionary of the English language.Fedor does\r\nnot want to change the meaning of the essay. So the only change he would\r\ndo: change a word from essay to one of its synonyms, basing on a\r\nreplacement rule from the dictionary. Fedor may perform this operation\r\nany number of times.As a result, Fedor wants to get an essay which\r\ncontains as little letters (the case doesn\u2019t matter) as possible. If\r\nthere are multiple essays with minimum number of s he wants to get the\r\none with minimum length (length of essay is the sum of the lengths of\r\nall the words in it). Help Fedor get the required essay.Please note that\r\nin this problem . For example, if the synonym dictionary says that word\r\ncan be replaced with word , then it is allowed to replace the word with\r\nthe word .\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nstruct node {\n\tnode *next;\n\tint where;\n} *first[200001], a[200001];\n\nmap<string, int> events;\n\nint c[200001], w[200001][2], in[200001], total, n, m, l, A[200001][2],\n\t\tv[200001][2], dfn[200001], low[200001], pos[200001], len, cnt, num,\n\t\tcolor[200001];\nstring str[100001];\n\ninline void makelist(int x, int y) {\n\ta[++l].where = y;\n\ta[l].next = first[x];\n\tfirst[x] = &a[l];\n}\n\ninline void tarjan(int now) {\n\tdfn[now] = low[now] = ++cnt;\n\tc[++len] = now;\n\tpos[now] = len;\n\tfor (node *x = first[now]; x; x = x->next)\n\t\tif (!dfn[x->where])\n\t\t\ttarjan(x->where), low[now] = min(low[now], low[x->where]);\n\t\telse if (!color[x->where])\n\t\t\tlow[now] = min(low[now], dfn[x->where]);\n\tif (low[now] == dfn[now]) {\n\t\t++num;\n\t\tfor (int i = pos[now]; i <= len; i++)\n\t\t\tcolor[c[i]] = num;\n\t\tlen = pos[now] - 1;\n\t}\n}\n\nint calc(string str) {\n\tint len = str.size();\n\tfor (int i = 0; i < len; i++)\n\t\tif (str[i] >= 'A' && str[i] <= 'Z')\n\t\t\tstr[i] = str[i] - 'A' + 'a';\n\tif (events.find(str) != events.end())\n\t\treturn events[str];\n\tevents[str] = ++total;\n\tA[total][0] = 0;\n\tA[total][1] = len;\n\tfor (int i = 0; i < len; i++)\n\t\tif (str[i] == 'r')\n\t\t\t++A[total][0];\n\treturn total;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> str[i];\n\tscanf(\"%d\", &m);\n\tmemset(first, 0, sizeof(first));\n\tl = 0;\n\tevents.clear();\n\ttotal = 0;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tint x = calc(str);\n\t\tcin >> str;\n\t\tint y = calc(str);\n\t\tmakelist(x, y);\n\t\tw[i][0] = x;\n\t\tw[i][1] = y;\n\t}\n\tmemset(color, 0, sizeof(color));\n\tmemset(dfn, 0, sizeof(dfn));\n\tmemset(low, 0, sizeof(low));\n\tcnt = len = num = 0;\n\tfor (int i = 1; i <= total; i++)\n\t\tif (!dfn[i])\n\t\t\ttarjan(i);\n\tfor (int i = 1; i <= num; i++)\n\t\tv[i][0] = v[i][1] = 1 << 30;\n\tfor (int i = 1; i <= total; i++) {\n\t\tint j = color[i];\n\t\tif (A[i][0] < v[j][0] || (A[i][0] == v[j][0] && A[i][1] < v[j][1]))\n\t\t\tv[j][0] = A[i][0], v[j][1] = A[i][1];\n\t}\n\tmemset(first, 0, sizeof(first));\n\tl = 0;\n\tmemset(in, 0, sizeof(in));\n\tfor (int i = 1; i <= m; i++)\n\t\tif (color[w[i][0]] != color[w[i][1]])\n\t\t\tmakelist(color[w[i][0]], color[w[i][1]]), ++in[color[w[i][1]]];\n\tint k = 0;\n\tfor (int i = 1; i <= num; i++)\n\t\tif (!in[i])\n\t\t\tc[++k] = i;\n\tfor (int l = 1; l <= k; l++) {\n\t\tint m = c[l];\n\t\tfor (node *x = first[m]; x; x = x->next)\n\t\t\tif (!--in[x->where])\n\t\t\t\tc[++k] = x->where;\n\t}\n\tfor (int i = num; i; i--) {\n\t\tint m = c[i];\n\t\tfor (node *x = first[m]; x; x = x->next) {\n\t\t\tint j = x->where;\n\t\t\tif (v[j][0] < v[m][0] || (v[j][0] == v[m][0] && v[j][1] < v[m][1]))\n\t\t\t\tv[m][0] = v[j][0], v[m][1] = v[j][1];\n\t\t}\n\t}\n\tlong long ans1 = 0, ans2 = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint Q = str[i].size();\n\t\tfor (int j = 0; j < Q; j++)\n\t\t\tif (str[i][j] >= 'A' && str[i][j] <= 'Z')\n\t\t\t\tstr[i][j] = str[i][j] - 'A' + 'a';\n\t\tif (events.find(str[i]) == events.end()) {\n\t\t\tans2 += Q;\n\t\t\tfor (int j = 0; j < Q; j++)\n\t\t\t\tif (str[i][j] == 'r')\n\t\t\t\t\t++ans1;\n\t\t} else {\n\t\t\tint j = color[events[str[i]]];\n\t\t\tans1 += v[j][0];\n\t\t\tans2 += v[j][1];\n\t\t}\n\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "hashing", "strings"], "dificulty": "2400", "interactive": false}