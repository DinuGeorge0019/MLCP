{
    "link": "https://codeforces.com//contest/1537/problem/C",
    "problemId": "1020034",
    "problem_idx": "C",
    "shortId": "1537C",
    "contest_number": "1537",
    "problem_submissions": {
        "F": [
            119857657,
            119865425,
            119870905,
            119869709,
            119878489,
            119841761,
            119876881,
            119827052,
            119888747,
            119879106,
            119880915,
            119859997,
            119866305,
            119891935,
            119902585,
            119888207,
            119905201
        ],
        "E2": [
            119835892,
            119833759,
            119835378,
            119850866,
            119864462,
            119850270,
            119848823,
            119846727,
            119864146,
            119866899,
            119862789,
            119890309,
            119915102,
            119899495,
            119871715,
            119862744,
            119873692,
            119862189
        ],
        "E1": [
            119835645,
            119833327,
            119834682,
            119850640,
            119850149,
            119850091,
            119849196,
            119847381,
            119863846,
            119866683,
            119861833,
            119862580,
            119843723,
            119853461,
            119862505,
            119872582,
            119862557
        ],
        "C": [
            119829240,
            119814686,
            119839941,
            119823683,
            119824487,
            119855572,
            119826402,
            119863416,
            119822210,
            119816816,
            119835116,
            119830407,
            119824166,
            119824127,
            119821757,
            119820808,
            119828361
        ],
        "D": [
            119827244,
            119843258,
            119855094,
            119838364,
            119835110,
            119859731,
            119840938,
            119859070,
            119842821,
            119845056,
            119849019,
            119838171,
            119834738,
            119848959,
            119837547,
            119830929,
            119842836
        ],
        "B": [
            119806043,
            119808907,
            119822215,
            119810718,
            119813042,
            119826639,
            119819938,
            119868704,
            119815398,
            119811429,
            119818874,
            119840047,
            119815192,
            119806896,
            119810508,
            119848797,
            119816830
        ],
        "A": [
            119804349,
            119804485,
            119818462,
            119804932,
            119804259,
            119830936,
            119816677,
            119871286,
            119815557,
            119804275,
            119808687,
            119804663,
            119806484,
            119804635,
            119804555,
            119843057,
            119806262
        ]
    },
    "name": "C. Challenging Cliffs",
    "statement": "You are a game designer and want to make an obstacle course. The player\r\nwill walk from left to right. You have n heights of mountains already\r\nselected and want to arrange them so that the absolute difference of the\r\nheights of the first and last mountains is as small as possible. In\r\naddition, you want to make the game difficult, and since walking uphill\r\nor flat is harder than walking downhill, the difficulty of the level\r\nwill be the number of mountains i (1\r\nleq i < n) such that h_i\r\nleq h_{i+1} where h_i is the height of the i-th mountain. You don\u2019t want\r\nto waste any of the mountains you modelled, so you have to use all of\r\nthem. From all the arrangements that minimize |h_1-h_n|, find one that\r\nis the most difficult. If there are multiple orders that satisfy these\r\nrequirements, you may find any.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include \"map\"\ntypedef double ld;\ntypedef long long ll;\n#define all(x) x.begin(), x.end()\nusing namespace std;\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto &i : a)\n        cin >> i;\n    int p = n - 1;\n    sort(all(a));\n    for (int i = 0; i < n - 1; ++i) {\n        if (abs(a[i + 1] - a[i]) < abs(a[(p + 1) % n] - a[p]))\n            p = i;\n    }\n    for (int i = p + 1; i < n; ++i) {\n        cout << a[i] << ' ';\n    }\n    for (int i = 0; i < p + 1; ++i) {\n        cout << a[i] << ' ';\n    }\n    cout << '\\n';\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q;\n    cin >> q;\n    while (q--) solve();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Challenging Cliffs.json",
    "editorial_link": "https://codeforces.com//blog/entry/91381",
    "editorial": "We claim that the maximum difficulty is at least . Assume the array is\r\nsorted. We first need to find the two mountains which go on the ends. To\r\ndo this, we can iterate through every mountain in the sorted array and\r\ncheck the difference between a mountain and its neighbours in the array.\r\nLet and be the mountains with the smallest height difference. We can\r\nachieve at least a difficulty of by arranging the mountains as . To get\r\ndifficulty , we need to be the shortest mountain and to be the tallest\r\nmountain. This will only happen if .\r\n"
}