{
    "link": "https://codeforces.com//contest/1573/problem/D",
    "problemId": "1113072",
    "problem_idx": "D",
    "shortId": "1573D",
    "contest_number": "1573",
    "problem_submissions": {
        "D": [
            129211729,
            129206759,
            129197164,
            129194726,
            129186807,
            129296553,
            129201143,
            129198553,
            129200951,
            129204017,
            129203484,
            129203960,
            129200720,
            129203477,
            129203437,
            129205853
        ],
        "E": [
            129195381,
            129194363,
            129199429,
            129179637,
            129197397,
            129196652
        ],
        "C": [
            129184190,
            129188576,
            129188704,
            129201501,
            129185674,
            129198766,
            129196140,
            129200201,
            129228180,
            129201620,
            129186651,
            129189132,
            129188899,
            129187320,
            129192678,
            129192241,
            129184572,
            129199512,
            129191618,
            129190718
        ],
        "B": [
            129172862,
            129196906,
            129176190,
            129203844,
            129172298,
            129171523,
            129174991,
            129187627,
            129183320,
            129178269,
            129185994,
            129182784,
            129179822,
            129174918,
            129183834,
            129199069,
            129172947,
            129197456,
            129180823
        ],
        "A": [
            129167486,
            129167526,
            129168431,
            129168344,
            129167107,
            129167895,
            129167756,
            129167152,
            129174946,
            129168601,
            129168318,
            129169357,
            129170825,
            129173901,
            129168162,
            129170465,
            129167770,
            129167307,
            129177822,
            129167367
        ],
        "F": [
            132459885
        ]
    },
    "name": "D. Xor of 3",
    "statement": "You are given a sequence a of length n consisting of 0s and 1s.You can\r\nperform the following operation on this sequence: Pick an index i from 1\r\nto n-2 (inclusive). Change all of a_{i}, a_{i+1}, a_{i+2} to a_{i}\r\noplus a_{i+1}\r\noplus a_{i+2} simultaneously, where\r\noplus denotes the bitwise XOR operation Find a sequence of n operations\r\nthat changes all elements of a to 0s or report that it\u2019s impossible.We\r\ncan prove that if there exists a sequence of operations of any length\r\nthat changes all elements of a to 0s, then there is also such a sequence\r\nof length not greater than n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nint i,j,k,n,m,t,a[200500],b[200500],res,s[200500],it,kk,sb,vis[200500];\n \nvoid show(){\n\tfor(int i=1;i<=n;i++){printf(\"%d \",b[i]);}puts(\"\");\n}\n \nbool chk(int i){\n\tif(vis[i]>2&&a[i])return 0;\n\tvis[i]++;\n\tif(!a[i]){\n\t\tif((a[i+1]+a[i+2])==2){\n\t\t\ts[++it]=i;\n\t\t\ta[i]=a[i+1]=a[i+2]=0;\n\t\t}\n\t\t//show();\n\t\treturn 1;\n\t}\n\tif(i+2>n)return 0;\n\tif(a[i]){\n\t\tif((a[i+1]+a[i+2])==1){\n\t\t\ts[++it]=i;\n\t\t\ta[i]=a[i+1]=a[i+2]=0;\n\t\t\t//show();\n\t\t\treturn 1;\n\t\t}\n\t\tif(!(a[i+1]+a[i+2])){\n\t\t\ts[++it]=i;\n\t\t\ta[i]=a[i+1]=a[i+2]=1;\n\t\t\t//show();\n\t\t}\n\t\tif(chk(i+2)){\n\t\t\ts[++it]=i;\n\t\t\ta[i]=a[i+1]=a[i+2]=0;\n\t\t\t//show();\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n \nint main(){\n\tmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()+1);\n\tuniform_int_distribution<int>lim(1,2);\n\t\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%d\",&n);\n\t\tres=0;\n\t\tk=0;it=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\tk+=a[i];\n\t\t}\n\t\t\n\t\tit=0;\n\t\tif(k&1){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\t//show();\n\t\tmemset(vis,0,n*4+50);\n\t\tfor(i=1;i<=n-2;i++){\n\t\t\t//printf(\"A %d\\n\",i);\n\t\t\tif(!chk(i))break;\n\t\t}\n\t\tmemset(vis,0,n*4+50);\n\t\tfor(i=1;i<=n-2;i++){\n\t\t\t//printf(\"A %d\\n\",i);\n\t\t\tif(!chk(i)){\n\t\t\t\tputs(\"NO\");\n\t\t\t\t//show();\n\t\t\t\tgoto aaa;\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t\tprintf(\"%d\\n\",it);\n\t\tfor(i=1;i<=it;i++){\n\t\t\tprintf(\"%d \",s[i]);\n\t\t}puts(\"\");\n\t\taaa:;\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Xor of 3.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "If the xor of all numbers in the array equals 1\n it is impossible to make everything equal to 0\n, since the parity of all numbers doesn't change after an operation. From now on we will assume that the xor of all numbers equals 0\n.\n\nLets consider the case when n\n is odd. We can perform operations on positions 1,3,...n?4,n?2\n. After this for every even i\n, ai?1=ai\n. Additionally, an=an?1=an?2=0\n. Second one is true since the xor of all numbers equals 0\n. Now we can perform operations on positions n?4,n?6,...3,1\n. This will make the array equal to 0\n.\n\nIn the case of even n\n we will find a prefix of odd length and even xor of numbers and call the above solution on it and its respective suffix. If there is no such prefix, the solution doesn't exist. Here is a proof of it. Assume that every prefix of odd length has an odd xor. This means that a1=an=1\n and for every even i<n\n, ai=ai+1\n. Consider an operation on an even position i\n (odd is analogous). We know that ai=ai+1\n so after this operation ai\n and ai+1\n will be set to ai+2\n. This means that after every operation for every even i<n\n, ai=ai+1\n still holds. Thus we will never be able to make a1\n equal to 0\n since performing an operation on it won't change it."
}