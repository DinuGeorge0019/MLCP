{
    "link": "https://codeforces.com//contest/1038/problem/C",
    "problemId": "216023",
    "problem_idx": "C",
    "shortId": "1038C",
    "contest_number": "1038",
    "problem_submissions": {
        "F": [
            42582709,
            42588924
        ],
        "E": [
            42575080,
            42578573,
            42575208,
            42576431,
            42577789,
            42580719,
            42575666,
            42580571,
            42583311,
            42581396,
            42582088,
            42580954,
            42583334,
            42579643,
            42582008,
            42580920,
            42583129,
            42582580,
            42583754
        ],
        "D": [
            42573485,
            42569896,
            42569634,
            42567012,
            42572149,
            42570113,
            42576120,
            42571013,
            42565752,
            42571052,
            42574327,
            42570312,
            42567294,
            42575127,
            42575057,
            42572394,
            42574539,
            42573852,
            42573051
        ],
        "C": [
            42566710,
            42563399,
            42564810,
            42563947,
            42567501,
            42564966,
            42562683,
            42566829,
            42562396,
            42564608,
            42563976,
            42565121,
            42570852,
            42564983,
            42565516,
            42568404,
            42566048,
            42568514,
            42566544
        ],
        "B": [
            42560979,
            42561635,
            42561921,
            42561073,
            42563881,
            42561586,
            42565172,
            42563091,
            42560475,
            42561602,
            42561362,
            42562336,
            42564791,
            42568121,
            42563027,
            42564081,
            42563007,
            42563149,
            42562895
        ],
        "A": [
            42559251,
            42559046,
            42559189,
            42559233,
            42563411,
            42559174,
            42559467,
            42559825,
            42558982,
            42559283,
            42559010,
            42559078,
            42560087,
            42561636,
            42561187,
            42559807,
            42559670,
            42559820,
            42559436
        ]
    },
    "name": "C. Gambling",
    "statement": "Two players A and B have a list of n integers each. They both want to\r\nmaximize the subtraction between their score and their opponent’s score.\r\nIn one turn, a player can either add to his score any element from his\r\nlist (assuming his list is not empty), the element is removed from the\r\nlist afterward. Or remove an element from his opponent’s list (assuming\r\nhis opponent’s list is not empty).Note, that in case there are equal\r\nelements in the list only one of them will be affected in the operations\r\nabove. For example, if there are elements\r\n{1, 2, 2, 3\r\n} in a list and you decided to choose 2 for the next turn, only a single\r\ninstance of 2 will be deleted (and added to the score, if necessary).\r\nThe player A starts the game and the game stops when both lists are\r\nempty. Find the difference between A’s score and B’s score at the end of\r\nthe game, if both of the players are playing optimally.Optimal play\r\nbetween two players means that both players choose the best possible\r\nstrategy to achieve the best possible outcome for themselves. In this\r\nproblem, it means that each player, each time makes a move, which\r\nmaximizes the final difference between his score and his opponent’s\r\nscore, knowing that the opponent is doing the same.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(\"%lld\", &x); return x;}\nvoid read(char *s){scanf(\"%s\", s);}\nvoid no(){printf(\"No\"); exit(0);}\n\n#define maxn 120000\n#define maxm\n\nmultiset<LL, greater<int> > a, b;\n\nint main(){\n\tLL ans = 0;\n\tint n = read();\n\tfor(int i = 0; i < n; i += 1) a.insert(read());\n\tfor(int i = 0; i < n; i += 1) b.insert(read());\n\tfor(int i = 0; i < n; i += 1){\n\t\tif(a.empty()) b.erase(b.begin());\n\t\telse{\n\t\t\tif(b.empty()){\n\t\t\t\tans += *a.begin();\n\t\t\t\ta.erase(a.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(*a.begin() < *b.begin()) b.erase(b.begin());\n\t\t\t\telse{\n\t\t\t\t\tans += *a.begin();\n\t\t\t\t\ta.erase(a.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(b.empty()) a.erase(a.begin());\n\t\telse{\n\t\t\tif(a.empty()){\n\t\t\t\tans -= *b.begin();\n\t\t\t\tb.erase(b.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(*b.begin() < *a.begin()) a.erase(a.begin());\n\t\t\t\telse{\n\t\t\t\t\tans -= *b.begin();\n\t\t\t\t\tb.erase(b.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Gambling.json",
    "editorial_link": "https://codeforces.com/blog/entry/61692",
    "editorial": "This problem was greedy.First, it is obvious that both the players will\r\ntry to either take their own maximum value or remove the opponentâs\r\nmaximum value. Hence, the arrays should be sorted and two pointers\r\nshould be maintained to keep track of how many elements from each array\r\nhave been counted/removed already.In every move, if the person has a\r\nchoice to either take his own value or remove his opponentâs value ,\r\nthen he will make the choice dependent on the values of and . In fact,\r\nit turns out that it is optimal just to select the choice with a greater\r\nnumber (in case of tie any will do).How to prove it? One can show by\r\ninduction that it does the same as the dynamic programming of size .\r\nHowever, there is a more nice way.Letâs say that initially each player\r\ngets of all numbers in his list. This way when you choose a number from\r\nyour own list you add the rest of it to the score. And when you remove\r\nthe number from opponentâs list you remove the of it from your\r\nopponentâs score. Clearly, all moves become symmetrical to both players\r\nnow! So each player can make a decision just based on which of the moves\r\nis greater. If , then he will take his number. If , he will discard the\r\nopponentâs number . If , he can make either of the above moves, it will\r\nnot make a difference.Complexity:\r\n",
    "hint": []
}