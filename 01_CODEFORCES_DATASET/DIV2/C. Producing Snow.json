{
    "link": "https://codeforces.com//contest/948/problem/C",
    "problemId": "164145",
    "problem_idx": "C",
    "shortId": "948C",
    "contest_number": "948",
    "problem_submissions": {
        "E": [
            36168620,
            36172204,
            36251405,
            36251326,
            36173384,
            36169252,
            36404487,
            36183304
        ],
        "D": [
            36163433,
            36167670,
            36167120,
            36164480,
            36164445,
            36162609,
            36165068,
            36162200,
            36164897,
            36162927,
            36164670,
            36161208,
            36169789,
            36165340,
            36163154,
            36157640,
            36165228,
            36165543,
            36161744,
            36165169
        ],
        "B": [
            36163096,
            36159675,
            36159702,
            36174211,
            36158845,
            36165864,
            36161702,
            36167381,
            36159372,
            36164193,
            36184907,
            36158822,
            36161863,
            36169531,
            36169227,
            36162688,
            36159710,
            36169741,
            36162780
        ],
        "C": [
            36159863,
            36162632,
            36162843,
            36159971,
            36160946,
            36158478,
            36159665,
            36159515,
            36161458,
            36161320,
            36162443,
            36163093,
            36159021,
            36158894,
            36174132,
            36201237,
            36164405,
            36159793,
            36161953,
            36158807,
            36162111
        ],
        "A": [
            36156394,
            36155837,
            36155755,
            36155535,
            36178220,
            36155392,
            36158997,
            36155227,
            36155148,
            36155311,
            36155229,
            36155259,
            36162558,
            36155502,
            36155114,
            36170875,
            36158967,
            36155326,
            36155358,
            36163726,
            36155813
        ]
    },
    "name": "C. Producing Snow",
    "statement": "Alice likes snow a lot! Unfortunately, this year\u2019s winter is already\r\nover, and she can\u2019t expect to have any more of it. Bob has thus bought\r\nher a gift a large snow maker. He plans to make some amount of snow\r\nevery day. On day he will make a pile of snow of volume and put it in\r\nher garden.Each day, every pile will shrink a little due to melting.\r\nMore precisely, when the temperature on a given day is , each pile will\r\nreduce its volume by . If this would reduce the volume of a pile to or\r\nbelow zero, it disappears forever. All snow piles are independent of\r\neach other. Note that the pile made on day already loses part of its\r\nvolume on the same day. In an extreme case, this may mean that there are\r\nno piles left at the end of a particular day.You are given the initial\r\npile sizes and the temperature on each day. Determine the total volume\r\nof snow melted on each day.\r\n",
    "solutions": [
        "#include <stdio.h>\n\nint N;\nlong long V[100005];\nlong long T[100005];\nlong long S[100005];\nint D[100005];\nlong long E[100005];\nint X[100005];\n\nlong long sum(int s, int e) {\n\treturn S[e] - S[s - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) scanf(\"%lld\", &V[i]);\n\tfor(int i = 1; i <= N; i++) scanf(\"%lld\", &T[i]);\n\tfor(int i = 1; i <= N; i++) S[i] = S[i - 1] + T[i];\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tint l = i, r = N;\n\t\twhile(l <= r) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif(V[i] < sum(i, m)) r = m - 1;\n\t\t\telse l = m + 1;\n\t\t}\n\t\t//r\n\t\t//printf(\"%d %d\\n\", i, r);\n\t\tD[i]++; D[l]--;\n\t\tE[l] += V[i] - sum(i, r);\n\t}\n\tfor(int i = 1; i <= N; i++) X[i] = X[i - 1] + D[i];\n\tfor(int i = 1; i <= N; i++) {\n\t\tprintf(\"%lld \", X[i] * T[i] + E[i]);\n\t}\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Producing Snow.json",
    "editorial_link": "https://codeforces.com//blog/entry/58286",
    "editorial": "We can directly simulate the process, but it takes  time, which is too slow. There are multiple approaches how to make this simulation faster. We present two of them.\n\nIn the first solution, instead of calculating the total volume of the snow melted, we first calculate two quantities: F[i] \u0097 the number of piles left after day i, and M[i] \u0097 the total volume of piles that disappear on day i. The answer will then be F[i]?*?T[i]?+?M[i].\nCalculate prefix sums of the temperatures. This way, when a snow pile is formed on day i, we can use binary search to determine on which day it will disappear completely. Denote this day by j and put j?=?N?+?1 if the pile survives. We can note that on every day k between i and j?-?1 inclusive, this pile will lose T[k] of its volume, which corresponds to increasing F[k] by one. Furthermore, we add the remaining volume to M[j].\n\nTo calculate all F[i]'s fast, we can again use prefix sums \u0097 adding 1 to interval can then be done by two additions.\n\nThe second solution can handle queries online. For each pile, we calculate how big it would be if it was created on the first day: .\nWe maintain all existing piles in a multiset. When a day i starts, we add V'[i] into the multiset. Then we remove all piles with  \u0097 those are the piles that disappear on day i \u0097 and easily calculate the total volume of melted snow in them. All the piles left in the multiset contribute exactly .\n\nAs the multiset is sorted, and each pile is added and removed only once, the total complexity is ."
}