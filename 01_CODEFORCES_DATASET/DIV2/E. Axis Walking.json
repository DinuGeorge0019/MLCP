{
    "link": "https://codeforces.com//contest/327/problem/E",
    "problemId": "3287",
    "problem_idx": "E",
    "shortId": "327E",
    "contest_number": "327",
    "problem_submissions": {
        "E": [
            4017313,
            4017507,
            4018772,
            4017910,
            4019268,
            4023331,
            4015900,
            4017838,
            4016759,
            4027441,
            4022024,
            4019276
        ],
        "C": [
            4014970,
            4014797,
            4014725,
            4014945,
            4015808,
            4013334,
            4014670,
            4013527,
            4014594,
            4014368,
            4014192,
            4014033,
            4014334,
            4014505,
            4015890,
            4015156,
            4015704
        ],
        "D": [
            4014693,
            4016265,
            4015556,
            4017918,
            4018611,
            4017193,
            4015911,
            4016489,
            4016642,
            4016033,
            4016317,
            4016734,
            4016607,
            4017683,
            4017510
        ],
        "A": [
            4012718,
            4011428,
            4014213,
            4012212,
            4011845,
            4011264,
            4011546,
            4011299,
            4011577,
            4011527,
            4011323,
            4011508,
            4011858,
            4011904,
            4011582,
            4012111,
            4011772
        ],
        "B": [
            4011621,
            4012593,
            4012805,
            4012674,
            4012463,
            4011873,
            4012480,
            4011682,
            4012186,
            4012474,
            4011938,
            4011986,
            4012535,
            4012626,
            4012279,
            4012988,
            4012431
        ]
    },
    "name": "E. Axis Walking",
    "statement": "Iahub wants to meet his girlfriend Iahubina. They both live in axis (the\r\nhorizontal axis). Iahub lives at point 0 and Iahubina at point .Iahub\r\nhas positive integers , , ..., . The sum of those numbers is . Suppose ,\r\n, ..., is a permutation of . Then, let , and so on. The array b is\r\ncalled a \"route\". There are different routes, one for each permutation\r\n.Iahub’s travel schedule is: he walks steps on axis, then he makes a\r\nbreak in point . Then, he walks more steps on axis and makes a break in\r\npoint . Similarly, at -th time he walks more steps on axis and makes a\r\nbreak in point .Iahub is very superstitious and has integers which give\r\nhim bad luck. He calls a route \"good\" if he never makes a break in a\r\npoint corresponding to one of those numbers. For his own curiosity,\r\nanswer how many good routes he can make, modulo ().\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<time.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 24\n#define P 1000000007\nint a[N],b[N],n,k;\nlong long d[1<<N];int A[1<<N];\nlong long f[1<<N];\nint main()\n{\n\t//freopen(\"E.in\",\"r\",stdin);\n\t//freopen(\"E.out\",\"w\",stdout);\n\tint t1=clock();\n\tscanf(\"%d\",&n);for (int i=0;i<n;++i)scanf(\"%d\",&a[i]),A[1<<i]=a[i];\n\tscanf(\"%d\",&k);for (int i=0;i<k;++i)scanf(\"%d\",&b[i]);for (int i=k;i<=3;++i)b[i]=-1;\n\tfor (int i=1;i<(1<<n);++i)d[i]=d[i-(i&-i)]+A[i&-i];\n\tf[0]=1;\n\tfor (int i=0;i<(1<<n);++i)if (d[i]!=b[0]&&d[i]!=b[1]&&d[i]!=b[2]){\n\t\t//printf(\"%d %d %d\\n\",i,d[i],f[i]);\n\t\tf[i]%=P;\n\t\tfor (int jj=((1<<n)-1)^i;jj;jj-=jj&-jj)f[i+(jj&-jj)]+=f[i];\n\t}\n\tif (d[(1<<n)-1]==b[0]||d[(1<<n)-1]==b[1]||d[(1<<n)-1]==b[2])f[(1<<n)-1]=0;\n\tprintf(\"%d\\n\",int(f[(1<<n)-1]%P));\n\t//printf(\"time=%d\\n\",clock()-t1);\n\t//system(\"pause\");for (;;);\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "constructive algorithms",
        "dp",
        "meet-in-the-middle"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Axis Walking.json",
    "editorial_link": "https://codeforces.com//blog/entry/8274",
    "editorial": "Usually when dealing with complicated problems, a good idea is to solve\r\nthem for small cases. Let s try this here. First case: K = 0. The answer\r\nis obviously N! (each permutation of p1, p2, , pn would be good). Next\r\ncase: K = 1. The answer of this one is N! |L1|. By L1 I denote all\r\nroutes for which a prefix sum is equal to first lucky number. Obviously,\r\nif from all routes I exclude the wrong ones, I get my answer. If we can\r\nfind an algorithm to provide |L1| in good time, then problem is solved\r\nfor K = 1. We can just try all N! permutations. Despite this method is\r\nsimple, it has complexity O(N!), too much for the constraints. Suppose\r\nwe ve founded a set of positions p1, p2, .., pk such as a[p1] + a[p2] +\r\n..+ a[pk] = U1 (first unlucky number). How many permutations can we\r\nmake? The first k positions need to be p1, p2, .., pk, but in any order.\r\nHence we get k! . The not used positions can also appeared in any order,\r\nstarting from k + 1 position. As they are n k, we can permute them in (n\r\nk)! ways. Hence, the answer is k! * (n k)! Instead of permuting {1, 2,\r\n.., n}, now we need to find subsets of it. Hence, the running time\r\nbecomes O(2^n). This is still too much. Meet in the middle. We make all\r\nsubsets for first half of positions (from 1 to N / 2) and them for\r\nsecond half (from N / 2 + 1 to N). For each subset we keep 2\r\ninformation: (sum, cnt) representing that there is a subset of sum sum\r\ncontaining cnt elements. For each (X, Y) from left we iterate in the\r\nright. After choosing one element from the left and one from the right\r\nwe just split them. To split 2 states (A, B) and (C, D), the new state\r\nbecomes (A + C, B + D). But we know that A + C = U1. This comes us to\r\nthe idea: for each (X, Y) in the left, I check (U1 X, 1), (U1 X, 2), ,\r\n(U1 X, K) from the right. For each of them, the answer would be (Y +\r\nK)! * (N Y K)! . I can store (using any data structure that allows this\r\noperations, I suggest a hash) how(C, D) = how many times does state (C,\r\nD) appear in the right. So, for a state (A, B) the answer becomes a sum\r\nof how(U1 A, K) * (B + K)! * (N B K)!. Doing the sum for all states (A,\r\nB), we get our answer. The complexity of this method is O(2 ^ (N / 2) *\r\nN). Final Case: K = 2 The whole \"meet in the middle\" explanation\r\nworthed. We will do something very similar to solve this case. Suppose\r\nU1 and U2 are the unlucky numbers. Without loosing the generality, letâs\r\nassume U1 <= U2. Following \"Principle of inclusion and exclusion\"\r\nparadigm (google about it if you never heard before) we can write our\r\nsolution as N! |L1| |L2| + |intersection between L1 and L2|. Again, by\r\nL1,2 I denote the number of routes which have a prefix sum equal to\r\nnumber U1,2. The |X| is again the cardinal of this set. Basically we can\r\ncalculate |X| as for K = 1. The only problem remained is calculating\r\n|intersection between L1 and L2|. The |intersection between L1 and L2|\r\nis the number of permutations which have a prefix sum equal to U1 and a\r\nprefix sum equal to U2. Since U1 <= U2, we can split a permutation from\r\nthis set in 3 parts: 1/ p1, p2, ...pk such as a[p1] + a[p2] + ... +\r\na[pk] = U1. 2/ pk+1, pk+2, ..., pm such as a[pk+1], a[pk+2], ..., a[pm]\r\n= U2 U1. Note that a[p1] + a[p2] + ... + a[pm] = U2. 3/ The rest of\r\nelements until position n. By a perfectly identical logic from K = 1\r\ncase, the number of permutations given those p[] would be k! * (m k)! *\r\n(n m)!. So the problem reduces to: find all indices set p1, p2, ... and\r\nq1, q2, .. such as a[p1] + a[p2] + ... + a[pn1] = U1 and a[q1] + a[q2] +\r\n... + a[qn2] = U2 U1. Then, we can apply formula using n1 and n2\r\ndescribed above. The first idea would be O(3 ^ N) for each position from\r\n{1, 2, .., n} atribute all combinations of {0, 1, 2}. 0 means that\r\nposition i is 1/, 1 means that position i is in 2/ and 2 means that\r\nposition i is in 3/ . This would time out. Happily, we can improve it\r\nwith meet in the middle principle. The solution is very similar with K =\r\n1 case. I wonât fully explain it here, if you understood principle from\r\nK = 1 this shouldnât be a problem. The base idea is to keep (S1, S2,\r\ncnt1, cnt2) for both \"left\" and \"right\". (S1, S2, cnt1, cnt2) represents\r\na subset which has sum of elements from 1/ equal to S1, sum of elements\r\nfrom 2/ equal to S2, in 1/ we have cnt1 element and in 2/ we get cnt2\r\nelements. For a (S1, S2, cnt1, cnt2) state from \"left\" we are looking in\r\nthe right for something like (U1 S1, U2 U1 S2, i, j). We get O(3 ^ (N /\r\n2) * N ^ 2) complexity. Unexpected solution During the round, we saw a\r\nlot of O(2 ^ N * N) solutions passing. This was totally out of\r\nexpectations. I believe if would make tests stronger, this solution\r\nwonât pass and round would be more challenging. Thatâs it, nothing is\r\nperfect. As requested, Iâll explain that solution here. Before\r\nexplaining the solution, I assume you have some experience with \"bitmask\r\ndp\" technique. If you donât, please read before:\r\nhttp://community.topcoder.com/tc?module=Static&d1=tutorials&d2=bitManipulation\r\nhttp://codeforces.com/blog/entry/337 In this problem weâll assume that a\r\nis 0-based. For a mask, consider bits from right to left, noting them\r\nbit 0, bit 1 and so on. Bit i is 1 if and only if a[i] is in the subset\r\nwhich is in a bijective replation with the mask. For example, for mask\r\n100011101 the subset is {a0, a2, a3, a4, a8}. Iâll call from now on the\r\nsubset \"subset of mask\". Also, the sum of all elements in a subset will\r\nbe called \"sum of mask\" (i.e. a0 + a2 + a3 + a4 + a8). Weâll explain the\r\nsolution based by watashiâs submission. 4017915 First step of the\r\nalgorithm is to calculate sum of each mask. Let dp[i] the sum of mask i.\r\nRemove exactly one element from the subset of mask. Suppose the new mask\r\nobtained is k and removed element is j. Then, dp[i] = dp[k] + a[j].\r\ndp[k] is always calculated before dp[i] (to proof, write both k and i in\r\nbase 10. k is always smaller than i). Having j an element from subset of\r\nmask i, we can compute mask k by doing i ^ (1 << j). Bit j is 1, and by\r\nxor-ing it with another 1 bit, it becomes 0. Other bits are unchanged by\r\nbeing xor-ed by 0. This method works very fast to compute sum of each\r\nmask. From now on, letâs denote a new array dp2[i] = how many good\r\nroutes can I obtain with elements from subset of mask i. Watashi uses\r\nsame dp[] array, but for making it clear, in editorial Iâll use 2\r\nseparate arrays. Suppose that CNT(i) is number of elements from subset\r\nof mask i. We are interested in how many ways we can fill positions {1,\r\n2, ..., CNT(i)} with elements from subset of mask i such as each prefix\r\nsum is different by each unlucky number. Next step of the algorithm is\r\nto see which sum of masks are equal to one of unlucky numbers. We mark\r\nthem as \"-1\" in dp2[]. Suppose we founded a subset {a1, a2, ..., ax} for\r\nwhich a1 + a2 + ... + ax = one of unlucky numbers. Then, none\r\npermutation of {a1, a2, ..., ax} is allowed to appear on first x\r\npositions. When we arrive to a \"-1\" state, we know that the number of\r\ngood routes for its subset of mask is 0. Now, finally the main dp\r\nrecurrence. If for the current mask i, dp2[i] = -1, then dp2[i] = 0 and\r\ncontinue (we discard the state as explained above). Otherwise, we know\r\nthat there could exist at least one way to complete positions {1, 2, ...\r\nCNT(i)} with elements of subset of mask i. But how to calculate it? We\r\nfix the last element (the element from the position CNT(I)) with some j\r\nfrom subset of mask i. The problem reduces now with how many good routes\r\ncan I fill in positions {1, 2, ..., CNT(i) 1} with elements from subset\r\nof mask i, from which we erased element j. With same explanation of sum\r\nof mask calculations, this is already calculated in dp2[i ^ (1 << j)].\r\nThe result is dp2[(1 << N) 1] (number of good routes containing all\r\npositions). Editorial has been made by me and ll931110. The authors of\r\nthe problems: Div.2 A & Div.2 B me Div.2 C & Div.2 D & Div.2 E ll931110\r\n",
    "hint": []
}