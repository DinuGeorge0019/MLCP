{
    "link": "https://codeforces.com//contest/740/problem/D",
    "problemId": "81530",
    "problem_idx": "D",
    "shortId": "740D",
    "contest_number": "740",
    "problem_submissions": {
        "E": [
            22446990,
            22448474,
            22447966,
            22448057,
            22445073,
            22450140
        ],
        "D": [
            22439412,
            22439501,
            22441405,
            22442158,
            22441228,
            22442043,
            22444396,
            22443003,
            22443858,
            22440389,
            22438383,
            22443141,
            22440987,
            22434772,
            22440005,
            22441561,
            22440585,
            22443581,
            22437799,
            22440799
        ],
        "C": [
            22434901,
            22433582,
            22438379,
            22436692,
            22431072,
            22432796,
            22434051,
            22436772,
            22434191,
            22433939,
            22440329,
            22437240,
            22438204,
            22444420,
            22434561,
            22436539,
            22433220,
            22434158,
            22437987
        ],
        "B": [
            22430518,
            22430263,
            22434039,
            22433558,
            22429147,
            22430035,
            22430933,
            22430825,
            22428254,
            22429750,
            22432572,
            22434667,
            22438582,
            22431092,
            22433538,
            22429194,
            22431254,
            22430546,
            22430025
        ],
        "A": [
            22428386,
            22434382,
            22429601,
            22432121,
            22428085,
            22439358,
            22428434,
            22428332,
            22430743,
            22428904,
            22430234,
            22432401,
            22436992,
            22429501,
            22430090,
            22427921,
            22428402,
            22428280
        ]
    },
    "name": "D. Alyona and a tree",
    "statement": "Alyona has a tree with vertices. The root of the tree is the vertex . In\r\neach vertex Alyona wrote an positive integer, in the vertex she wrote .\r\nMoreover, the girl wrote a positive integer to every edge of the tree\r\n(possibly, different integers on different edges).Letâ€™s define as the\r\nsum of the integers written on the edges of the simple path from to .The\r\nvertex controls the vertex () if and only if is in the subtree of and\r\n.Alyona wants to settle in some vertex. In order to do this, she wants\r\nto know for each vertex what is the number of vertices such that\r\ncontrols .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std; \n\nconst int N=1e6;\nconst int Mod=1e9+7;\n\nlong long dis[N];\nint n,m,a[N],p[N],w[N],ans[N],in[N],out[N],ord;\nvector<int> E[N],W[N];\n\nvoid dfs(int x,long long y) {\n\tdis[x]=y;\n\tin[x]=++ord;\n\tfor(int i=0;i<E[x].size();i++) {\n\t\tdfs(E[x][i],y+W[x][i]);\n\t}\t\n\tout[x]=ord;\n}\n\nstruct Node {\n\tint t,id;\n\tlong long v;\n\tNode(){}\n\tNode(int t1,int id1,long long v1) {\n\t\tt=t1; id=id1; v=v1;\n\t} \n\tbool operator < (const Node &a) const {\n\t\tif(v==a.v) return t<a.t;\n\t\treturn v<a.v; \n\t}\n}Q[N];\n\nint cnt,B[N];\n\ninline void Ins(int x) {\n\twhile(x<=n) {\n\t\tB[x]++;\n\t\tx+=x&-x;\n\t}\n}\n\ninline int ask(int x) {\n\tint res=0;\n\twhile(x) {\n\t\tres+=B[x];\n\t\tx-=x&-x;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tfor(int i=2;i<=n;i++) {\n\t\tscanf(\"%d%d\",p+i,w+i);\n\t\tE[p[i]].push_back(i);\n\t\tW[p[i]].push_back(w[i]);\n\t} //cout<<\"/\";\n\tdfs(1,0); //cout<<\"/\";\n\tfor(int i=1;i<=n;i++) {\n\t\tQ[++cnt]=Node(1,i,dis[i]-a[i]);\n\t\tQ[++cnt]=Node(2,i,dis[i]);\n\t}\n\tsort(Q+1,Q+1+cnt);\n\tfor(int i=1;i<=cnt;i++) {\n\t\tif(Q[i].t==1) {\n\t\t\tIns(in[Q[i].id]);\n\t\t} else {\n\t\t\tans[Q[i].id]=ask(out[Q[i].id])-ask(in[Q[i].id]-1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]-1);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "graph matchings",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Alyona and a tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/48582",
    "editorial": "Let's fix a vertex v. This node adds +1 to all the ancestors whose depth depth[v]?-?a[v]???depth[p] (depth[v] = the sum of the weights of edges on the path from the root to the vertex v). It's a segment of the ancestors, ending in v, as the depth increases when moving to the leaves. It remains to find the first ancestor on the way up, it does not hold for him - so you can make a binary lifting or binary search, if you will be storing the path to the root in dfs. With the partial sums you can calculate the answer for each vertices.\n",
    "hint": []
}