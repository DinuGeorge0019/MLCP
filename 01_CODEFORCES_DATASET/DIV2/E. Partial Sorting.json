{"link": "https://codeforces.com//contest/1768/problem/E", "problemId": "1720622", "problem_idx": "E", "shortId": "1768E", "contest_number": "1768", "problem_submissions": {"D": [204982953, 188071247, 188067925, 188068130, 188070945, 188072940, 188074516, 188075810, 188085152, 188074579, 188073456, 188074101, 188082385, 188164225, 188089006, 188069736, 188081987, 188082522, 188078305, 188078232, 188080797], "F": [188116348, 188135822, 188160798, 188176131, 188168385], "E": [188083790, 188076616, 188084542, 188083977, 188085068, 188090588, 188090979, 188080120, 188090253, 188095827, 188095081, 188082638, 188089969, 188164249, 188075544, 188101242, 188092147, 188102271, 188100942, 188097984], "C": [188076017, 188062341, 188060907, 188066248, 188067691, 188065722, 188067475, 188070114, 188066780, 188064718, 188068797, 188076939, 188164202, 188081893, 188163969, 188059068, 188075112, 188075686, 188069461, 188068577, 188075836], "B": [188057634, 188051968, 188049872, 188053488, 188055902, 188055318, 188053420, 188056521, 188052830, 188053386, 188052891, 188065110, 188164191, 188059182, 188051170, 188056859, 188053279, 188061154, 188058286], "A": [188047123, 188046830, 188047332, 188048108, 188047085, 188046543, 188047234, 188050361, 188047575, 188046807, 188046596, 188059906, 188164162, 188047560, 188046948, 188050516, 188048920, 188047550, 188060898, 188051639]}, "name": "E. Partial Sorting", "statement": "Consider a permutation^\r\ndagger p of length 3n. Each time you can do one of the following\r\noperations: Sort the first 2n elements in increasing order. Sort the\r\nlast 2n elements in increasing order. We can show that every permutation\r\ncan be made sorted in increasing order using only these operations.\r\nLet\u2019s call f(p) the minimum number of these operations needed to make\r\nthe permutation p sorted in increasing order.Given n, find the sum of\r\nf(p) over all (3n)! permutations p of size 3n.Since the answer could be\r\nvery large, output it modulo a prime M.^\r\ndagger A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=3e6+10;\nint mod,n,t_case;\nstruct modint{\n\tint val;\n\tinline modint(int val_=0):val(val_){}\n\tinline modint &operator=(int val_){return val=val_,*this;}\n\tinline modint &operator+=(const modint &k){return val=val+k.val>=mod?val+k.val-mod:val+k.val,*this;}\n\tinline modint &operator-=(const modint &k){return val=val-k.val<0?val-k.val+mod:val-k.val,*this;}\n\tinline modint &operator*=(const modint &k){return val=1ll*val*k.val%mod,*this;}\n\tinline modint &operator^=(int k){\n\t    modint ret=1,tmp=*this;\n\t    for(;k;k>>=1,tmp*=tmp)if(k&1)ret*=tmp;\n\t    return val=ret.val,*this;\n\t}\n\tinline modint &operator/=(modint k){return *this*=(k^=mod-2);}\n\tinline modint &operator+=(int k){return val=val+k>=mod?val+k-mod:val+k,*this;}\n\tinline modint &operator-=(int k){return val=val<k?val-k+mod:val-k,*this;}\n\tinline modint &operator*=(int k){return val=1ll*val*k%mod,*this;}\n\tinline modint &operator/=(int k){return *this*=((modint(k))^=mod-2);}\n\ttemplate<class T>friend modint operator+(modint a,T b){return a+=b;}\n\ttemplate<class T>friend modint operator-(modint a,T b){return a-=b;}\n\ttemplate<class T>friend modint operator*(modint a,T b){return a*=b;}\n\ttemplate<class T>friend modint operator^(modint a,T b){return a/=b;}\n\ttemplate<class T>friend modint operator/(modint a,T b){return a/=b;}\n\tfriend modint operator^(modint a,int b){return a^=b;}\n\tfriend bool operator==(modint a,int b){return a.val==b;}\n\tfriend bool operator!=(modint a,int b){return a.val!=b;}\n\tinline bool operator!(){return !val;}\n\tinline modint operator-(){return val?mod-val:0;}\n\tinline modint &operator++(){return *this+=1;}\n};\nusing mi=modint;\nmi fac[maxn],ifac[maxn];\ninline void init(int sz){\n\tfac[0]=1;\n\tfor(ri i=1;i<=sz;++i)fac[i]=fac[i-1]*i;\n\tifac[sz]=1/fac[sz];\n\tfor(ri i=sz;i;--i)ifac[i-1]=ifac[i]*i;\n}\ninline mi A(int x,int y){\n\tif(x<y||y<0)return 0;\n\treturn fac[x]*ifac[x-y];\n}\ninline mi C(int x,int y){\n\tif(x<y||y<0)return 0;\n\treturn A(x,y)*ifac[y];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&mod);\n\tinit(n*3);\n\tmi w=1,x=2*fac[n*2]-fac[n],y=2*A(n*2,n)*fac[n*2],z=fac[n*3];\n\tfor(ri i=0;i<=n;++i)y-=C(n,i)*A(n,i)*A(n,n-i)*A(n*2-i,n)*fac[n];\n\tz-=y,y-=x,x-=w;\n\tprintf(\"%d\",0*w+1*x+2*y+3*z);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "math", "number theory"], "dificulty": "2300", "interactive": false}