{"link": "https://codeforces.com//contest/1230/problem/C", "problemId": "419097", "problem_idx": "C", "shortId": "1230C", "contest_number": "1230", "problem_submissions": {"F": [61160420, 61168761, 61169473, 61163448, 61168484, 61211410, 61166190, 61161224], "E": [61148718, 61161040, 61146705, 61151905, 61156612, 61143760, 61134387, 61160007, 61147362, 61152540, 61143988, 61157501, 61156272, 61146445, 61139279, 61157405, 61162378], "D": [61141780, 61141760, 61139292, 61144818, 61153245, 61138124, 61148103, 61186591, 61153749, 61148878, 61139116, 61159398, 61147761, 61146515, 61163213, 61156688, 61153790, 61144523], "C": [61128802, 61146533, 61172060, 61167384, 61149264, 61133355, 61139896, 61137699, 61129905, 61146775, 61146749, 61137639, 61130666, 61128891, 61133021, 61163475, 61147427, 61133523], "B": [61122260, 61138928, 61125100, 61135886, 61136151, 61126292, 61136826, 61131007, 61122773, 61127439, 61129919, 61122576, 61124319, 61122348, 62114936, 61124404, 61125885, 61125887, 61124264], "A": [61120076, 61128524, 61121738, 61130255, 61122144, 61123763, 61140465, 61128200, 61120371, 61124618, 61133127, 61121262, 61120693, 61119937, 62114885, 61126319, 61122327, 61122607, 61120311]}, "name": "C. Anadi and Domino", "statement": "Anadi has a set of dominoes. Every domino has two parts, and each part\r\ncontains some dots. For every a and b such that 1\r\nleq a\r\nleq b\r\nleq 6, there is exactly one domino with a dots on one half and b dots on\r\nthe other half. The set contains exactly 21 dominoes. Here is an exact\r\nillustration of his set: Also, Anadi has an undirected graph without\r\nself-loops and multiple edges. He wants to choose some dominoes and\r\nplace them on the edges of this graph. He can use at most one domino of\r\neach type. Each edge can fit at most one domino. It\u2019s not necessary to\r\nplace a domino on each edge of the graph.When placing a domino on an\r\nedge, he also chooses its direction. In other words, one half of any\r\nplaced domino must be directed toward one of the endpoints of the edge\r\nand the other half must be directed toward the other endpoint. There\u2019s a\r\ncatch: if there are multiple halves of dominoes directed toward the same\r\nvertex, each of these halves must contain the same number of dots.How\r\nmany dominoes at most can Anadi place on the edges of his graph?\r\n", "solutions": ["// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 7;\n\nint n, col[N], ans;\nbool edge[N][N], vis[6][6];\n\nvoid solve() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (edge[i][j]) {\n                vis[col[i]][col[j]] = true;\n            }\n        }\n    }\n    int cur = 0;\n    for (int i = 0; i < 6; ++i) {\n        for (int j = i; j < 6; ++j) {\n            cur += vis[i][j];\n            vis[i][j] = false;\n        }\n    }\n    ans = max(ans, cur);\n}\n\nvoid dfs(int i) {\n    if (i == n) {\n        return solve();\n    }\n    for (int &j = col[i] = 0; j < 6; ++j) {\n        dfs(i + 1);\n    }\n}\n\nint main() {\n    n = read();\n    int m = read();\n    while (m--) {\n        int x = read() - 1, y = read() - 1;\n        edge[x][y] = edge[y][x] = true;\n    }\n    dfs(0);\n    cout << ans << '\\n';\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "graphs"], "dificulty": "1700", "interactive": false}