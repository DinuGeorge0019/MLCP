{
    "link": "https://codeforces.com//contest/1561/problem/D1",
    "problemId": "1088959",
    "problem_idx": "D1",
    "shortId": "1561D1",
    "contest_number": "1561",
    "problem_submissions": {
        "F": [
            126904536,
            126901655,
            126903407,
            126897889,
            126905462,
            126895857,
            126909746,
            126868411
        ],
        "E": [
            126872829,
            126873450,
            126873472,
            126876837,
            126887119,
            126925237,
            126873365,
            126880329,
            126880730,
            126881569,
            126878334,
            126883106,
            126884943,
            126885452,
            126887344,
            126884906,
            126885650,
            126888199,
            126863450
        ],
        "C": [
            126869012,
            126865542,
            126864086,
            126863127,
            126863122,
            126861060,
            126868974,
            126853568,
            126857674,
            126857569,
            126854957,
            126857844,
            126858666,
            126860889,
            126860513,
            126857734,
            126864125,
            126867660,
            126866693
        ],
        "D1": [
            126861759,
            126863688,
            126864717,
            126869692,
            126872900,
            126868199,
            126862491,
            126866683,
            126868762,
            126864055,
            126863339,
            126863270,
            126867571,
            126865653,
            126863522,
            126870959,
            126872615,
            126860538,
            126862556
        ],
        "D2": [
            126861568,
            126863750,
            126868373,
            126869562,
            126876457,
            126868351,
            126862413,
            126873746,
            126868674,
            126867473,
            126864201,
            126863508,
            126868989,
            126866379,
            126880112,
            126871782,
            126872752,
            126861102,
            126877754
        ],
        "B": [
            126856962,
            126852931,
            126853927,
            126857335,
            126862047,
            126855473,
            126854073,
            126848963,
            126854204,
            126852816,
            126866896,
            126854673,
            126855023,
            126857298,
            126855876,
            126863677,
            126859086,
            126871391,
            126876744
        ],
        "A": [
            126847903,
            126848403,
            126847412,
            126849843,
            126849112,
            126848036,
            126848332,
            126847281,
            126847584,
            126847566,
            126847516,
            126847717,
            126847410,
            126847430,
            126850448,
            126848322,
            126849200,
            126856163,
            126853136
        ]
    },
    "name": "D1. Up the Strip  simplified version ",
    "statement": "You have a vertical strip with n cells, numbered consecutively from 1 to\r\nn from top to bottom.You also have a token that is initially placed in\r\ncell n. You will move the token up until it arrives at cell 1.Let the\r\ntoken be in cell x > 1 at some moment. One shift of the token can have\r\neither of the following kinds: Subtraction: you choose an integer y\r\nbetween 1 and x-1, inclusive, and move the token from cell x to cell x -\r\ny. Floored division: you choose an integer z between 2 and x, inclusive,\r\nand move the token from cell x to cell\r\nlfloor\r\nfrac{x}{z}\r\nrfloor (x divided by z rounded down). Find the number of ways to move\r\nthe token from cell n to cell 1 using one or more shifts, and print it\r\nmodulo m. Note that if there are several ways to move the token from one\r\ncell to another in one shift, all these ways are considered (check\r\nexample explanation for a better understanding).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL n,mod,dp1[4000005],dp2[4000005],sum[4000005];\n#define MOD mod\nint main(){\n\tscanf(\"%lld %lld\",&n,&mod);\n\tdp1[1]=dp2[1]=1;\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\t(dp1[i]+=(sum[i]+dp2[i-1]))%=mod;\n\t\tdp2[i]=(dp2[i-1]+dp1[i])%mod;\n\t\t(sum[i+1]+=sum[i])%=mod;\n\t\tfor(LL j=2;j*i<=n;++j)\t(sum[j*i]+=dp1[i])%=mod,(sum[min(j*i+j,n+1)]+=mod-dp1[i])%=mod;\n\t}\n\tprintf(\"%lld\",dp1[n]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Up the Strip  simplified version .json",
    "editorial_link": "https://codeforces.com//blog/entry/94216",
    "editorial": "Pretty clearly, we are facing a dynamic programming problem. Let f(x)\n be the number of ways to move from cell x\n to cell 1\n. Then, f(1)=1\n, f(x)=?y=1x?1f(x?y)+?z=2xf(?xz?)\n, and f(n)\n is the answer to the problem. However, a straightforward implementation has O(n2)\n time complexity and is too slow.\n\nLet's look at the main formula for f(x)\n again: f(x)=?y=1x?1f(x?y)+?z=2xf(?xz?)\n.\n\nThe first sum, ?y=1x?1f(x?y)\n, is easy to optimize: just maintain the sum of f1fx?1\n and recalculate it by adding f(x)\n. This takes just O(1)\n time per cell.\n\nFor the second sum, ?z=2xf(?xz?)\n, note that ?xz?\n can take at most O(x???)\n different values over z?[2;x]\n. We can handle this sum as follows:\n\nFind the sum over all z<x???\n directly.\nWe only need to consider z?x???\n now. For any such value, ?xz??x???\n. Let's loop over a cell c?x???\n, for how many different values of z\n it's true that c=?xz?\n? By definition of the floor function, c?xz<c+1\n. Solving this inequality, we get z?[?xc+1?+1;?xc?]\n. The length of this segment gives us the coefficient of f(c)\n in the sum.\nThis gives us an O(nn???)\n solution which is enough for the subtask in Division 2.\n\nTo get a faster solution, let S(x)\n denote the multiset of cells where we can go to from cell x\n (this multiset contains 2x?2\n values). How is S(x+1)\n different from S(x)\n?\n\nS(x+1)\n contains an extra occurrence of x\n because we can subtract 1\n from x+1\n.\nS(x+1)\n contains an extra occurrence of 1\n because we can divide x+1\n by x+1\n.\nFor each i>1\n that is a divisor of x+1\n, S(x+1)\n contains an occurrence of i\n that replaces an occurrence of i?1\n.\nWe don't need to maintain S(x)\n itself, but we can maintain the sum of f(i)\n over all i?S(x)\n and recalculate this sum as we go from x\n to x+1\n. The total number of changes to S\n is limited by the total number of divisors of all numbers from 1\n to n\n, that is, n1+n2++nn=O(nlogn)\n.\n\nHowever, if implemented directly, we need to quickly find the divisors of each x\n, and we can only afford O(n)\n memory due to the memory limit. We can achieve that by preparing a sieve of Eratosthenes, factorizing x\n and generating all its divisors.\n\nA better way is do it the reverse way: once we find f(c)\n for some c\n, let's traverse x=2c,3c,\n and add f(c)?f(c?1)\n to f(x)\n. This way the time complexity stays O(nlogn)\n and the memory complexity is O(n)\n.",
    "hint": []
}