{
    "link": "https://codeforces.com//contest/864/problem/E",
    "problemId": "124137",
    "problem_idx": "E",
    "shortId": "864E",
    "contest_number": "864",
    "problem_submissions": {
        "F": [
            30716015,
            30722402,
            30723225,
            30725964,
            30739740
        ],
        "E": [
            30710484,
            30714856,
            30715154,
            30723143,
            30713586,
            30730131,
            30715426,
            30713107,
            30711368,
            30718758,
            30718806,
            30718477,
            30714033,
            30714286,
            30715582,
            30713724,
            30713502,
            30738356,
            30717401,
            30713777,
            30716171,
            30715998
        ],
        "D": [
            30707520,
            30709478,
            30708092,
            30709303,
            30709255,
            30703697,
            30709397,
            30707026,
            30712505,
            30709061,
            30711433,
            30710302,
            30710827,
            30707816,
            30706829,
            30708611,
            30705451,
            30707869,
            30706715,
            30708055
        ],
        "C": [
            30705528,
            30707197,
            30704462,
            30712744,
            30706231,
            30710658,
            30706244,
            30713235,
            30708256,
            30705517,
            30708760,
            30706819,
            30708546,
            30705215,
            30711574,
            30711162,
            30709362,
            30710824,
            30709705,
            30706376
        ],
        "B": [
            30703070,
            30703231,
            30706404,
            30704293,
            30702498,
            30701721,
            30702746,
            30704552,
            30702131,
            30702339,
            30704226,
            30703770,
            30702687,
            30701947,
            30704004,
            30702177,
            30703567,
            30708307,
            30703521,
            30704217
        ],
        "A": [
            30701411,
            30701464,
            30701236,
            30703640,
            30701582,
            30701091,
            30701629,
            30704524,
            30701158,
            30701293,
            30701284,
            30701912,
            30701498,
            30701066,
            30701818,
            30701174,
            30701687,
            30701585,
            30701750,
            30701329
        ]
    },
    "name": "E. Fire",
    "statement": "Polycarp is in really serious trouble his house is on fire! Itâ€™s time to\r\nsave the most valuable items. Polycarp estimated that it would take\r\nseconds to save -th item. In addition, for each item, he estimated the\r\nvalue of the moment after which the item will be completely burned and\r\nwill no longer be valuable for him at all. In particular, if , then -th\r\nitem cannot be saved.Given the values for each of the items, find a set\r\nof items that Polycarp can save such that the total value of this items\r\nis maximum possible. Polycarp saves the items one after another. For\r\nexample, if he takes item first, and then item , then the item will be\r\nsaved in seconds, and the item in seconds after fire started.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint f[110][2010];\nint g[110][2010];\nstruct p\n{\n\tint t,d,p,id;\n};\np a[110];\nint cmp(p a,p b)\n{\n\treturn a.d<b.d;\n}\nvoid solve(int x,int y,int s)\n{\n\tif(x<0)\n\t\tprintf(\"%d\\n\",s);\n\telse\n\t{\n\t\tif(!g[x][y])\n\t\t\tsolve(x-1,y,s);\n\t\telse\n\t\t{\n\t\t\tsolve(x-1,y-a[x].t,s+1);\n\t\t\tprintf(\"%d \",a[x].id);\n\t\t}\n\t}\n}\nint main()\n{\n\tmemset(f,0x80,sizeof f);\n\tf[0][0]=0;\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a[i].t,&a[i].d,&a[i].p);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=2000;j++)\n\t\t{\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tg[i][j]=0;\n\t\t\tif(j>=a[i].t&&j<a[i].d)\n\t\t\t\tif(f[i-1][j-a[i].t]+a[i].p>f[i][j])\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=f[i-1][j-a[i].t]+a[i].p;\n\t\t\t\t\tg[i][j]=1;\n\t\t\t\t}\n\t\t}\n\tint ans1=-1,ans2=-1;\n\tfor(i=0;i<=2000;i++)\n\t\tif(f[n][i]>ans1)\n\t\t{\n\t\t\tans1=f[n][i];\n\t\t\tans2=i;\n\t\t}\n\tprintf(\"%d\\n\",ans1);\n\tsolve(n,ans2,0);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Fire.json",
    "editorial_link": "https://codeforces.com//blog/entry/54765",
    "editorial": "If Polycarp will save two items, it is more profitable to first save the\r\none whose parameter is less. So, you can sort items by the parameter\r\n.Let be the maximum total value of items Polycarp can save by checking\r\nfirst items in seconds. Here are two types of transitions. Polycarp can\r\neither save current item or skip it: , if To restore the sequence of\r\nitems Polycarp can save you can remember for each pair () whether you\r\ntook a thing with the number when updating the value .Overall\r\ncomplexity: .\r\n",
    "hint": []
}