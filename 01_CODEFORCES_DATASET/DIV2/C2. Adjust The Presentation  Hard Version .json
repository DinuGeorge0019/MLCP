{
    "link": "https://codeforces.com//contest/2021/problem/C2",
    "problemId": "2929694",
    "problem_idx": "C2",
    "shortId": "2021C2",
    "contest_number": "2021",
    "problem_submissions": {
        "D": [
            284590256,
            284590001,
            284586301,
            284623851,
            284569171,
            284578878,
            284712748,
            284578625,
            284581515,
            284581353,
            284637993
        ],
        "E3": [
            284578176,
            284565599,
            284600842,
            284850992,
            284584216,
            284618196,
            284597636,
            284599022,
            284585148,
            286020331,
            284745105
        ],
        "E1": [
            284577293,
            284599054,
            284566976,
            284599574,
            284568532,
            284584477,
            284579805,
            284586608,
            284600476,
            284585423,
            284594051,
            284576473,
            284592731,
            284581221,
            284582830,
            284576965,
            286020463,
            284573682,
            284745154,
            284585073
        ],
        "E2": [
            284576481,
            284599368,
            284566551,
            284571784,
            284584447,
            284580377,
            284586193,
            284585357,
            284576258,
            284585492,
            284583546,
            284582548,
            286020438,
            284593395,
            284766277,
            284587863
        ],
        "C2": [
            284552959,
            284550125,
            284578847,
            284570668,
            284557743,
            284572571,
            284559765,
            284559531,
            284592443,
            284564745,
            284553608,
            284551809,
            284555032,
            284564040,
            284565535,
            284591262,
            284564727,
            284560092
        ],
        "C1": [
            284543395,
            284545189,
            284579118,
            284555011,
            284551439,
            284544381,
            284549845,
            284558858,
            284582609,
            284556392,
            284545368,
            284554154,
            284545358,
            284546156,
            284555833,
            284553560,
            284550666,
            284546712,
            284545533,
            284552561
        ],
        "B": [
            284537997,
            284541648,
            284545572,
            284550280,
            284536827,
            284538339,
            284543136,
            284541306,
            284577835,
            284541582,
            284538597,
            284539525,
            284540971,
            284538476,
            284541915,
            284545007,
            284543924,
            284540121,
            284540098,
            284544260
        ],
        "A": [
            284536034,
            284541336,
            284535964,
            284545882,
            284543072,
            284535980,
            284537720,
            284537149,
            284572305,
            284541440,
            284535781,
            284536205,
            284539247,
            284535865,
            284537520,
            284541705,
            284541775,
            284537231,
            284537773,
            284536991
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134873",
    "editorial": "Firstly, letâs relabel the members such that member number is the -th\r\nmember in the initial line configuration in array . We also adjust the\r\nvalues in (and the future updates) accordingly.For now, letâs solve the\r\nproblem if there are no updates to the array . Consider the first member\r\nwho presents. Notice that member must be the first one presenting since\r\nhe/she is at the very front of the line, which means must hold. After\r\nthis, we insert him/her into any position in the line. However, instead\r\nof determining the target position immediately, we make member a\r\n\"pending member\" and we will only determine his/her position later on\r\nwhen we need him/her again.To generalize, we can form an algorithm to\r\ncheck whether achieving is possible or not. We iterate each element for\r\neach from to . While iterating, we maintain a set of pending members\r\nwhich is initially empty, and we maintain who is the next member in the\r\nline. When iterating a value of , there are three cases: If is equal to\r\nthe next member in the line, then we can make that member present. And\r\nthen he/she will become a pending member for the next iterations. Else,\r\nif is one of the pending members, then we can always set a precise\r\ntarget position when moving that member in the past such that he/she\r\nwill be at the very front of the line at this very moment. And then,\r\nthat member will be a pending member again. Else, then itâs impossible\r\nto make member present at this time. To solve the problem with updates,\r\nletâs observe some special properties of if is valid. Notice that once a\r\nmember becomes a pending member, he/she will be a pending member\r\nforever. And a member becomes a pending member during the first\r\noccurence of value . Since the order of members becoming pending must\r\nfollow the order of the members in the line, that means the first\r\noccurence for each value in must be in chronological order from to .\r\nMore formally, letâs define as follows: If the value appears at least\r\nonce in , then is the smallest index such that . If the value doesnât\r\nappear in , then . Then, for to be valid, it must hold that .To handle\r\nthe updates, we must maintain the array . In order to do that, for each\r\nvalue from to , we maintain a set of indices for every occurence of in .\r\nThe value of is just the minimum value in the set, or if the set is\r\nempty. An update to an element in corresponds to two updates among the\r\nsets, which corresponds to two updates in array .To maintain the status\r\non whether array is non-decreasing or not, we maintain a value which\r\nrepresents the number of pairs of adjacent indices (for all ) such that\r\n. The array is non-decreasing if and only if . For an update to an index\r\nin , we only need to check how pairs and affect the value of .Time\r\ncomplexity for each test case:\r\n",
    "name": "C2. Adjust The Presentation  Hard Version ",
    "statement": "A team consisting of n members, numbered from 1 to n, is set to present\r\na slide show at a large meeting. The slide show contains m slides.There\r\nis an array a of length n. Initially, the members are standing in a line\r\nin the order of a_1, a_2,\r\nldots, a_n from front to back. The slide show will be presented in order\r\nfrom slide 1 to slide m. Each section will be presented by the member at\r\nthe front of the line. After each slide is presented, you can move the\r\nmember at the front of the line to any position in the lineup (without\r\nchanging the order of the rest of the members). For example, suppose the\r\nline of members is [\r\ncolor{red}{3},1,2,4]. After member 3 presents the current slide, you can\r\nchange the line of members into either [\r\ncolor{red}{3},1,2,4], [1,\r\ncolor{red}{3},2,4], [1,2,\r\ncolor{red}{3},4] or [1,2,4,\r\ncolor{red}{3}].There is also an array b of length m. The slide show is\r\nconsidered if it is possible to make member b_i present slide i for all\r\ni from 1 to m under these constraints.However, your annoying boss wants\r\nto make q updates to the array b. In the i-th update, he will choose a\r\nslide s_i and a member t_i and set b_{s_i} := t_i. Note that these\r\nupdates are , that is changes made to the array b will apply when\r\nprocessing future updates.For each of the q+1 states of array b, the\r\ninitial state and after each of the q updates, determine if the\r\nslideshow is good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}mt19937 zsh(20070610);int p[200010];int pw1[200010],pw2[200010];#define Mod1 998244353#define Mod2 1004535809#define B1 19491001#define B2 19260817struct HASH{\tint num1,num2,len;};HASH operator+(HASH A,HASH B){\tHASH ret;\tret.len=A.len+B.len;\tret.num1=(1ll*A.num1*pw1[B.len]+B.num1)%Mod1;\tret.num2=(1ll*A.num2*pw2[B.len]+B.num2)%Mod2;\treturn ret;}  #define ls (pos<<1)#define rs (pos<<1|1)#define mid (l+r>>1)HASH s[800010];void reset(int pos,int l,int r){\ts[pos].num1=s[pos].num2=s[pos].len=0;\tif(l<r) reset(ls,l,mid),reset(rs,mid+1,r);}void change_num(int x,int k,int pos,int l,int r){\tif(l==r)\t{\t\tif(k) s[pos]=HASH{p[k],p[k],1};\t\telse s[pos]=HASH{0,0,0};\t}\telse if(x<=mid) change_num(x,k,ls,l,mid),s[pos]=s[ls]+s[rs];\telse change_num(x,k,rs,mid+1,r),s[pos]=s[ls]+s[rs];}void show(int pos,int l,int r){\tif(l==r) printf(\"%d \",s[pos].num1);\telse show(ls,l,mid),show(rs,mid+1,r);}#undef ls#undef rs#undef midHASH h[200010]; int n,m,q;int a[200010],b[200010],fl;set<int> S[200010];bool vis[200010];void chk(){\tint tk=s[1].len;\tif(s[1].num1==h[tk].num1&&s[1].num2==h[tk].num2) printf(\"YA\\n\");\telse printf(\"TIDAK\\n\");}int x,y;void solve(){\tfor(int i=1;i<=n;i++) set<int>().swap(S[i]);\tmemset(vis,0,(n+1)); \tn=Qread(),m=Qread(),q=Qread();\tfor(int i=1;i<=n;i++) a[i]=Qread();\tfor(int i=1;i<=m;i++) b[i]=Qread(); \tfor(int i=1;i<=n;i++)\t\th[i].num1=(1ll*h[i-1].num1*B1+p[a[i]])%Mod1,\t\th[i].num2=(1ll*h[i-1].num2*B2+p[a[i]])%Mod2; \treset(1,1,m);\tfor(int i=1;i<=m;i++) S[b[i]].insert(i);\tfor(int i=1;i<=n;i++) if(!S[i].empty())\t\tchange_num(*S[i].begin(),i,1,1,m);\t\tchk();\tfor(int i=1;i<=q;i++)\t{\t\tx=Qread(),y=Qread();\t\tif(*S[b[x]].begin()==x)\t\t{\t\t\tchange_num(x,0,1,1,m);\t\t\tS[b[x]].erase(x);\t\t\tif(!S[b[x]].empty()) change_num(*S[b[x]].begin(),b[x],1,1,m);\t\t}else S[b[x]].erase(x);\t\tif(S[y].empty()||*S[y].begin()>x)\t\t{\t\t\tif(!S[y].empty()) change_num(*S[y].begin(),0,1,1,m);\t\t\tchange_num(x,y,1,1,m);\t\t}S[y].insert(x);\t\tb[x]=y;\t\tchk();\t}}int main(){\tfor(int i=1;i<=200000;i++) p[i]=i;\tshuffle(p+1,p+200000+1,zsh); \tpw1[0]=pw2[0]=1;\tfor(int i=1;i<=200000;i++) pw1[i]=1ll*pw1[i-1]*B1%Mod1;\tfor(int i=1;i<=200000;i++) pw2[i]=1ll*pw2[i-1]*B2%Mod2; \tint T=Qread();\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C2. Adjust The Presentation  Hard Version .json",
    "hint": []
}