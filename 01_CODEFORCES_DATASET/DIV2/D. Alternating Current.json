{
    "link": "https://codeforces.com//contest/344/problem/D",
    "problemId": "3465",
    "problem_idx": "D",
    "shortId": "344D",
    "contest_number": "344",
    "problem_submissions": {
        "E": [
            4466832,
            4466881,
            4466839,
            4467938,
            4467852,
            4467906,
            4467882,
            4468520,
            4468666,
            4468956,
            4470309,
            4470343,
            4470890,
            4470646,
            4467178
        ],
        "D": [
            4462598,
            4463520,
            4463970,
            4465391,
            4463898,
            4463951,
            4464720,
            4464711,
            4464808,
            4465291,
            4466089,
            4465147,
            4464978,
            4462443,
            4462461,
            4461439,
            4462978,
            4463724
        ],
        "C": [
            4462080,
            4460954,
            4462735,
            4464740,
            4461891,
            4463048,
            4463380,
            4462836,
            4462940,
            4463239,
            4462139,
            4463864,
            4466720,
            4465356,
            4460855,
            4461389,
            4462577,
            4462304
        ],
        "B": [
            4460105,
            4460097,
            4460219,
            4462525,
            4460360,
            4459970,
            4461098,
            4461404,
            4460184,
            4461242,
            4460727,
            4461556,
            4462077,
            4459824,
            4459969,
            4460167,
            4460213,
            4459935
        ],
        "A": [
            4458731,
            4458719,
            4458834,
            4459218,
            4458679,
            4458789,
            4458804,
            4460231,
            4458819,
            4459697,
            4459355,
            4459770,
            4458622,
            4459629,
            4458794,
            4458666,
            4458710,
            4458866,
            4458867
        ]
    },
    "name": "D. Alternating Current",
    "statement": "Mad scientist Mike has just finished constructing a new device to search\r\nfor extraterrestrial intelligence! He was in such a hurry to launch it\r\nfor the first time that he plugged in the power wires without giving it\r\na proper glance and started experimenting right away. After a while Mike\r\nobserved that the wires ended up entangled and now have to be untangled\r\nagain.The device is powered by two wires \"plus\" and \"minus\". The wires\r\nrun along the floor from the wall (on the left) to the device (on the\r\nright). Both the wall and the device have two contacts in them on the\r\nsame level, into which the wires are plugged in some order. The wires\r\nare considered entangled if there are one or more places where one wire\r\nruns above the other one. For example, the picture below has four such\r\nplaces (top view): Mike knows the sequence in which the wires run above\r\neach other. Mike also noticed that on the left side, the \"plus\" wire is\r\nalways plugged into the top contact (as seen on the picture). He would\r\nlike to untangle the wires without unplugging them and the device.\r\nDetermine if it is possible to do that. A wire can be freely moved and\r\nstretched on the floor, but cannot be cut.To understand the problem\r\nbetter please read the notes to the test samples.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#pragma comment(linker, \"/STACK:167772160\")\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\n\nchar buff[100500];\nchar st[100500];\nint pos;\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"testD.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%s\", buff);\n    pos = 0;\n    int N = strlen(buff);\n    for (int i = 0; i < N; ++i)\n    {\n        if (pos > 0 && st[pos - 1] == buff[i])\n        {\n            --pos;\n        }\n        else\n        {\n            st[pos] = buff[i];\n            ++pos;\n        }\n    }\n\n    if (pos == 0)\n        puts(\"Yes\");\n    else\n        puts(\"No\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Alternating Current.json",
    "editorial_link": "https://codeforces.com//blog/entry/8860",
    "editorial": "Let us solve the following problem first: we are given a string of symbols A and B. If the i-th symbol is A, then at the i-th step the upper wire (see figure) is being put over the lower wire. If the i-th symbol is B, the lower wire is being put over the upper wire at i-th step. Observe that if some two symbols A and B are adjacent, we can untangle this place, throw the symbols out and obtain the string of length two symbols less. So the wires can be untangled iff the number of A's and B's in the string is the same. The given problem can be reduced to the described in a following fashion: in each odd position we change \u0096 to B and + to A. In each even position we change \u0097 to A and + to B. The reduction is correct, since on each even position the order of \u0097 and + are always swapped, and in each odd position their order is the same as in the beginning."
}