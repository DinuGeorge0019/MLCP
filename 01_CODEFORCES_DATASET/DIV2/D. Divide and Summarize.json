{
    "link": "https://codeforces.com//contest/1461/problem/D",
    "problemId": "829209",
    "problem_idx": "D",
    "shortId": "1461D",
    "contest_number": "1461",
    "problem_submissions": {
        "E": [
            100932966,
            100936269,
            100990346,
            100969491,
            100936672,
            100935997,
            100939174,
            100940524,
            100941594,
            101253968,
            100980986,
            100938127,
            100939775,
            100939746,
            100939282,
            100946150,
            100942054,
            100947167,
            100942687,
            100943260,
            100946250,
            100984712,
            100939780
        ],
        "D": [
            100927713,
            100927975,
            100930388,
            100930108,
            100929403,
            100928752,
            100927167,
            101253940,
            100929699,
            100925599,
            100929844,
            100930435,
            100928868,
            100927280,
            100929168,
            100927059,
            100928373,
            100929241,
            100929027,
            100931581
        ],
        "C": [
            100924332,
            100922434,
            100924379,
            100925587,
            100923163,
            100923132,
            100922302,
            101253910,
            100924116,
            100920852,
            100924402,
            100925009,
            100923233,
            100921503,
            100923858,
            100922215,
            100922547,
            100922569,
            100922801,
            100924266
        ],
        "B": [
            100920627,
            100919068,
            100920131,
            100923667,
            100919688,
            100918122,
            100916912,
            101253882,
            100919837,
            100916872,
            100919874,
            100921340,
            100919650,
            100918083,
            100918896,
            100918448,
            100932425,
            100918174,
            100919207,
            100918935
        ],
        "A": [
            100911403,
            100911220,
            100912022,
            100911829,
            100911757,
            100911131,
            100911094,
            101253862,
            100911574,
            100910965,
            100911506,
            100912093,
            100912000,
            100911450,
            100911077,
            100911732,
            100912598,
            100910886,
            100911279,
            100911559
        ],
        "F": [
            101254013,
            101253423,
            100951392,
            101467849,
            126697052
        ]
    },
    "name": "D. Divide and Summarize",
    "statement": "Mike received an array a of length n as a birthday present and decided\r\nto test how pretty it is.An array would pass the i-th prettiness test if\r\nthere is a way to get an array with a sum of elements totaling s_i,\r\nusing some number (possibly zero) of slicing operations. An array\r\nslicing operation is conducted in the following way: assume mid =\r\nlfloor\r\nfrac{max(array) + min(array)}{2}\r\nrfloor, where max and min are functions that find the maximum and the\r\nminimum array elements. In other words, mid is the sum of the maximum\r\nand the minimum element of array divided by 2 rounded down. Then the\r\narray is split into two parts\r\nmathit{left} and right. The\r\nmathit{left} array contains all elements which are less than or equal\r\nmid, and the right array contains all elements which are greater than\r\nmid. Elements in\r\nmathit{left} and right keep their relative order from array. During the\r\nthird step we choose which of the\r\nmathit{left} and right arrays we want to keep. The chosen array replaces\r\nthe current one and the other is permanently discarded. You need to help\r\nMike find out the results of q prettiness tests.Note that you test the\r\nprettiness of the array a, so you start each prettiness test with the\r\nprimordial (initial) array a. Thus, the first slice (if required) is\r\nalways performed on the array a.\r\n",
    "solutions": [
        "//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<\" \";cout<<\"\\n\";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\nset <int> s;\nvoid solve(vector <int> &v)\n{\n    int mx=-1, mi=1e7, s0=0;\n    for(auto num:v)\n    {\n        s0+=num;\n        mx=max(mx, num);\n        mi=min(mi, num);\n    }\n    s.insert(s0);\n    int p=(mi+mx)/2, s1=0, s2=0;\n    vector <int> v1, v2;\n    for(auto num:v)\n    {\n        if(num<=p)\n        {\n            v1.pb(num);\n            s1+=num;\n        }\n        else\n        {\n            v2.pb(num);\n            s2+=num;\n        }\n    }\n    s.insert(s1);\n    s.insert(s2);\n    if(v1.size()>0 && v2.size()>0)\n    {\n        solve(v1);\n        solve(v2);\n    }\n}\nint32_t main()\n{\n    IOS;\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        s.clear();\n       int n, q;\n       cin>>n>>q;\n       vector <int> v(n);\n       for(int i=0;i<n;i++)\n       cin>>v[i];\n       solve(v);\n       while(q--)\n       {\n           int x;\n           cin>>x;\n           if(s.find(x)!=s.end())\n           cout<<\"Yes\\n\";\n           else\n           cout<<\"No\\n\";\n       }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "implementation",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Divide and Summarize.json",
    "editorial_link": "https://codeforces.com//blog/entry/85491",
    "editorial": "To begin with, you can notice that the cut operation does not depend on\r\nthe order of the array. So we can sort it.Now let\u00e2\u0080\u0099s build a tree of\r\ntransitions from the original array to all its possible states. You can\r\nsimply prove that the height of this tree does not exceed . Since after\r\neach operation of the section is reduced at least twice.Having\r\nunderstood this, we can write a simple recursive search over the states\r\n. The state will describe a sub-segment of the array that is the current\r\narray. For each state, we can calculate the current amount (on the\r\nsegment from left to right) and add it to any convenient collection\r\n(set/HashSet).Next, to respond to requests, we can simply look at our\r\ncollected collection.\r\n"
}