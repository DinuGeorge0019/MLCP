{
    "link": "https://codeforces.com//contest/1417/problem/A",
    "problemId": "740371",
    "problem_idx": "A",
    "shortId": "1417A",
    "contest_number": "1417",
    "problem_submissions": {
        "D": [
            94021013,
            93997987,
            93994414,
            94008928,
            93994813,
            93993974,
            93997393,
            93994886,
            93995533,
            94000707,
            94022056,
            93991179,
            93997856,
            94000293,
            94004446,
            94003381,
            93990919,
            93999146,
            94004809,
            93994289,
            93993273
        ],
        "C": [
            94008586,
            93979621,
            93985626,
            93982539,
            93981622,
            93998363,
            93982359,
            93986555,
            93983202,
            93992239,
            93983337,
            93991411,
            93986598,
            93990140,
            93991651,
            94001522,
            93986870,
            93985359,
            93998445,
            93985761
        ],
        "B": [
            94003048,
            93973490,
            93978330,
            93975968,
            93973585,
            93982217,
            93975658,
            93979313,
            93975689,
            93981775,
            93977350,
            93981714,
            93975469,
            93979278,
            93978354,
            96285430,
            93978356,
            93980291,
            93977440,
            94041345,
            93979236,
            93977870
        ],
        "A": [
            94001724,
            93970294,
            93970800,
            93971885,
            93969936,
            93980954,
            93971325,
            93970349,
            93971917,
            93971289,
            93969984,
            93970972,
            93971064,
            93971068,
            93971066,
            96285403,
            93971270,
            93973889,
            93971400,
            94041333,
            93974793,
            93971921
        ],
        "E": [
            94000180,
            93995718,
            94008025,
            93998585,
            94011058,
            94003165,
            94008902,
            94012205,
            94012202,
            94009571,
            94022535,
            94014181,
            94009089,
            94015399,
            94011955,
            94009323,
            94016150,
            94015958,
            94013413,
            94011012,
            94019762
        ],
        "F": [
            93992993,
            94142204,
            94142122
        ]
    },
    "name": "A. Copy-paste",
    "statement": "is a powerful magician. He has got n piles of candies, the i-th pile\r\ninitially contains a_i candies. can cast a spell as follows: He chooses\r\ntwo piles (i, j) such that 1\r\nle i, j\r\nle n and i\r\nne j. All candies from pile i are copied into pile j. Formally, the\r\noperation a_j := a_j + a_i is performed. can cast this spell any number\r\nof times he wants to but unfortunately, if some pile contains strictly\r\nmore than k candies, he loses his magic power. What is the maximum\r\nnumber of times can cast the spell without losing his power?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nvoid solve(){\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor(auto &x : a){\n\t\tcin >> x;\n\t}\n\tsort(a.begin(), a.end());\n\tint ans = 0;\n\tfor(int i = 1; i < n; i++){\n\t\tans += (k - a[i])/a[0];\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout<<setprecision(32);\n\n\tint t; cin >> t;\n\twhile(t--)solve();\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Copy-paste.json",
    "editorial_link": "https://codeforces.com//blog/entry/83036",
    "editorial": "If we do our operation on two arbitrary integers , it is always better\r\nto copy into rather than to copy into (since a resulting pair is better\r\nthan ). Now, let\u00e2\u0080\u0099s assume that we do our operation on two integers such\r\nthat is not the minimum element of our array. If we replace with\r\nminimum, we can always achieve at least the same answer. Thus, we can\r\ntake any index such that is the array minimum and use it to increase all\r\nother values.Time complexity: or per testcase.Space complexity:\r\n"
}