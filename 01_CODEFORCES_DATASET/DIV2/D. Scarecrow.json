{
    "link": "https://codeforces.com//contest/2055/problem/D",
    "problemId": "3141117",
    "problem_idx": "D",
    "shortId": "2055D",
    "contest_number": "2055",
    "problem_submissions": {
        "E": [
            300746486,
            300849536,
            300761124
        ],
        "D": [
            300696033,
            300705238,
            300701008,
            300702007,
            300702452,
            300703784,
            300699187,
            300704114,
            300709175,
            300707029,
            300707549,
            300710969,
            300708967,
            300711888,
            300708148,
            300708052,
            300708173,
            300705738
        ],
        "C": [
            300672652,
            300668358,
            300677522,
            300677196,
            300683675,
            300681011,
            300678376,
            300681393,
            300678777,
            300680600,
            300678839,
            300677980,
            300671004,
            300679220,
            300687159,
            300684321,
            300687531,
            300683543
        ],
        "B": [
            300657881,
            300656820,
            300666935,
            300663382,
            300655553,
            300662689,
            300671074,
            300665092,
            300657486,
            300665581,
            300668563,
            300655341,
            300661161,
            300658795,
            300659826,
            300665475,
            300658513,
            300662771
        ],
        "A": [
            300651053,
            300651601,
            300652364,
            300654430,
            300651022,
            300652195,
            300652888,
            300655299,
            300650941,
            300654319,
            300652932,
            300651006,
            300651149,
            300651992,
            300652147,
            300652006,
            300652172,
            300650990
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/138343",
    "editorial": "SolutionWe make a few preliminary observations: (1) The order of\r\nscarecrows should never change, i.e no two scarecrows should cross each\r\nother while moving along the interval. (2) Scarecrow should spend the\r\nfirst seconds moving to position zero, as this move is required for the\r\ncrow to make any progress and there is no point in delaying it. (3)\r\nLet’s say that a scarecrow at position ‘has’ the crow if the crow is at\r\nposition , and there are no other scarecrows in the interval . A\r\nscarecrow that has the crow should always move to the right; in other\r\nwords, all scarecrows that find themselves located to the left of the\r\ncrow should spend all their remaining time moving to the right, as it is\r\nthe only way they will be useful. (4) Let there be a scenario where at\r\ntime , scarecrow has the crow and is at position , and another scenario\r\nat time where scarecrow also has the crow, but is at position . Then,\r\nthe latter scenario is at least as good as the former scenario, assuming\r\nscarecrows numbered higher than are not fixed. (5) The only way to save\r\ntime is to maximize the distance teleported by the crow. The second and\r\nfifth observations imply that the time spent to move the crow across the\r\ninterval is .Now, for each scarecrow , define to be the position along\r\nthe interval at which it begins to have the crow, i.e. the crow is\r\ntransferred from scarecrow to . For instance, in the second sample case\r\nthe values of are The second observation above implies that , and the\r\nfirst observation implies that . Notice that we may express the distance\r\nteleported as with the extra definition that . For instance, in the\r\nsecond sample case the distance teleported is and the total time is\r\n.Now, suppose that have been selected for some , and that time has\r\nelapsed upon scarecrow receiving the crow. We will argue the optimal\r\nchoice of . At time when scarecrow first receives the crow, scarecrow\r\nmay be at any position in the interval . Now, we have three\r\ncases.Case 1. In this case, scarecrow will need to move some nonnegative\r\namount to the left in order to meet with scarecrow . They will meet at\r\nthe midpoint of the crow position and the leftmost possible position of\r\nscarecrow at time . This gives Case 2. Notice that if our choice of has\r\n, it benefits us to increase our choice of (if possible) as a\r\nconsequence of our fourth observation, since all such will cause an\r\nimmediate transfer of the crow to scarecrow at time . However, if we\r\nchoose , lowering our choice of is now better as it loses less potential\r\nteleported distance , while leaving more space for teleported distance\r\nafter position . Therefore, we will choose in this case.Case 3. In this\r\ncase, regardless of how we choose , the crow will immediately transfer\r\nto scarecrow from scarecrow at time . We might as well pick .Therefore,\r\nthe optimal selection of may be calculated iteratively as It is now easy\r\nto implement the above approach to yield an solution. Note that the\r\nconstraints for were deliberately set to instead of to make two times\r\nthe maximum answer fit within -bit integer types. It is not difficult to\r\nshow that the values of as well as the answer are always integers or\r\nhalf-integers.\r\n",
    "name": "D. Scarecrow",
    "statement": "A crow is sitting at position 0 of the number line. There are n\r\nscarecrows positioned at integer coordinates a_1, a_2,\r\nldots, a_n along the number line. These scarecrows have been enchanted,\r\nallowing them to move left and right at a speed of 1 unit per second.The\r\ncrow is afraid of scarecrows and wants to stay at least a distance of k\r\nahead of the nearest scarecrow positioned it. To do so, the crow uses\r\nits teleportation ability as follows: Let x be the current position of\r\nthe crow, and let y be the largest position of a scarecrow such that y\r\nle x. If x - y < k, meaning the scarecrow is too close, the crow will\r\ninstantly teleport to position y + k. This teleportation happens\r\ninstantly and continuously. The crow will keep checking for scarecrows\r\npositioned at or to the left of him and teleport whenever one gets too\r\nclose (which could happen at non-integral times). Note that besides this\r\nteleportation ability, the crow will not move on its own.Your task is to\r\ndetermine the minimum time required to make the crow teleport to a\r\nposition greater than or equal to\r\nell, assuming the scarecrows move optimally to allow the crow to reach\r\nits goal. For convenience, you are asked to output needed for the crow\r\nto reach the target position\r\nell. It can be proven that this value will always be an integer.Note\r\nthat the scarecrows can start, stop, or change direction at any time\r\n(possibly at non-integral times).\r\n",
    "solutions": [
        "#include <algorithm>#include <array>#include <bitset>#include <cassert>#include <chrono>#include <cmath>#include <complex>#include <cstring>#include <functional>#include <iomanip>#include <iostream>#include <map>#include <numeric>#include <queue>#include <random>#include <set>#include <vector>#include <climits>using namespace std;using ll=long long;using db=long double;using pi=pair<int,int>;using pl=pair<ll,ll>;using vi=vector<int>;using vl=vector<ll>;using vpi=vector<pi>;using vpl=vector<pl>;#define mp make_pair#define eb emplace_back#define pb push_back#define x first#define y second#define sz(x)int((x).size())#define bg(x) begin(x)#define all(x)(x).begin(),(x).end()#define rall(x) x.rbegin(), x.rend() #define rep(i,a,b)for(int i=(a);i<(b);i++)#define per(i,a,b)for(int i=(b)-1;i>=(a);i--)#define ft front()#define bk back()#define rsz resize#define ins insert#define each(a,x)for(auto&a:x)bool ckmin(auto&a,auto b){return b<a?a=b,1:0;}bool ckmax(auto&a,auto b){return b>a?a=b,1:0;}#ifdef LOCALtemplate<class A, class B>ostream&operator<<(ostream&o,pair<A,B>p){return o<<\"(\"<<p.x<<\", \"<<p.y<<\")\";}template<class A, class B, class C>ostream&operator<<(ostream&o,tuple<A,B,C>t){    return o<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\", \"<<\")\";}auto operator<<(auto&o,auto x)->decltype(x.end(),o){    o<<\"{\";int i=0;for(auto&e:x)o<<\",\"+!i++<<e;return o<<\"}\";}#define debug(X...)cerr<<\"[\"#X\"]: \",[](auto...$){((cerr<<$<<\"; \"),...)<<endl;}(X);#else#define debug(...){}#endif const pi MOVES[] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}; // #include <ext/pb_ds/assoc_container.hpp>// #include <ext/pb_ds/tree_policy.hpp>// using namespace __gnu_pbds;// template<class T>// using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; template<int MOD, int RT> struct mint {    static const int mod = MOD;    static constexpr mint rt() { return RT; }    int v; explicit operator int() const { return v; }    mint() : v(0) {}    mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);        if (v < 0) v += MOD; }    bool operator==(const mint& o) const {        return v == o.v; }    friend bool operator!=(const mint& a, const mint& b) {         return !(a == b); }    friend bool operator<(const mint& a, const mint& b) {         return a.v < b.v; }     mint& operator+=(const mint& o) {         if ((v += o.v) >= MOD) v -= MOD;         return *this; }    mint& operator-=(const mint& o) {         if ((v -= o.v) < 0) v += MOD;         return *this; }    mint& operator*=(const mint& o) {         v = int((ll)v*o.v%MOD); return *this; }    mint& operator/=(const mint& o) { return (*this) *= inv(o); }    friend mint pow(mint a, ll p) {        mint ans = 1; assert(p >= 0);        for (; p; p /= 2, a *= a) if (p&1) ans *= a;        return ans; }    friend mint inv(const mint& a) { assert(a.v != 0);         return pow(a,MOD-2); }            mint operator-() const { return mint(-v); }    mint& operator++() { return *this += 1; }    mint& operator--() { return *this -= 1; }    friend mint operator+(mint a, const mint& b) { return a += b; }    friend mint operator-(mint a, const mint& b) { return a -= b; }    friend mint operator*(mint a, const mint& b) { return a *= b; }    friend mint operator/(mint a, const mint& b) { return a /= b; }    friend ostream& operator<<(ostream& o, const mint& a) { return o << a.v; }    friend istream& operator>>(istream& i, mint& a) {        ll x; i >> x; a = x;        return i;    }}; const int MOD = 998244353;using mi = mint<MOD,5>;using vmi = vector<mi>;using pmi = pair<mi,mi>;using vpmi = vector<pmi>; const int INF = 1e9+2137; void solve() {    int n, k, l;    cin >> n >> k >> l;    vi a(n);    rep(i,0,n) cin >> a[i];    k *= 2;    l *= 2;    rep(i,0,n) a[i] *= 2;    int pos = 0;    int tim = a[0];    rep(i,1,n) {        if (pos + k >= a[i] - tim) { // zdazymy na granice            pos = min(pos + k, a[i] + tim);        }        else {            int target_pos = (pos + a[i] - tim); // /2            assert(target_pos % 2 == 0);            target_pos /= 2;            target_pos += k/2;            int delta_tim = a[i] - tim - target_pos;            assert(delta_tim > 0);            pos = target_pos;            tim += delta_tim;        }    }    tim += max(0, l - k - pos);    cout << tim << '\\n';} signed main() {    cin.tie(0)->sync_with_stdio(0);     int t;    cin >> t;    while (t--) solve();     return 0;} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Scarecrow.json"
}