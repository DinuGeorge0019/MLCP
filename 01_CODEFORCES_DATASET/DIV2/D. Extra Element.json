{
    "link": "https://codeforces.com//contest/1185/problem/D",
    "problemId": "360324",
    "problem_idx": "D",
    "shortId": "1185D",
    "contest_number": "1185",
    "problem_submissions": {
        "G2": [
            55788875,
            55790981,
            55805220,
            55805211,
            55805181,
            55805110,
            55805072,
            55792804,
            55790893,
            55798346,
            55839723
        ],
        "F": [
            55780405,
            55784226,
            55779797,
            55790435,
            55783948,
            55774453,
            55775306,
            55787301,
            55787239,
            55780510,
            55776902,
            55778347,
            55775969,
            55787695,
            55787943,
            55780581,
            55779230,
            55782760,
            55786882,
            55789076
        ],
        "G1": [
            55775590,
            55777444,
            55773026,
            55772290,
            55770464,
            55777149,
            55766017,
            55779783,
            55780697,
            55775163,
            55781086,
            55781273,
            55783475,
            55770087,
            55781658,
            55783057,
            55787570,
            55776249,
            55782788,
            55780634
        ],
        "E": [
            55773709,
            55771675,
            55770836,
            55777430,
            55780309,
            55781282,
            55788835,
            55774037,
            55773565,
            55789637,
            55786175,
            55787728,
            55781452,
            55776381,
            55777447,
            55775569,
            55774578,
            55788543,
            55772414,
            55777859
        ],
        "D": [
            55764805,
            55765160,
            55763333,
            55764561,
            55767970,
            55767077,
            55763517,
            55765643,
            55766955,
            55766963,
            55766612,
            55765495,
            55757519,
            55767392,
            55769540,
            55767234,
            55769033,
            55770802,
            55765015,
            55772029
        ],
        "C1": [
            55760617,
            55761184,
            55760176,
            55760890,
            55765300,
            55759868,
            55766915,
            55759835,
            55763415,
            55762227,
            55760086,
            55765957,
            55763972,
            55762753,
            55765982,
            55761920,
            55763575,
            55762040,
            55779786,
            55761686
        ],
        "C2": [
            55760448,
            55761127,
            55759974,
            55760758,
            55765213,
            55759811,
            55767080,
            55761513,
            55763197,
            55762148,
            55760260,
            55762050,
            55763657,
            55765005,
            55765960,
            55761757,
            55779613,
            55763567,
            55779964,
            55761855
        ],
        "B": [
            55757432,
            55757400,
            55757118,
            55756714,
            55760856,
            55756979,
            55757746,
            55757494,
            55758775,
            55757209,
            55756807,
            55758385,
            55768633,
            55758969,
            55760948,
            55757700,
            55756899,
            55760037,
            55759228,
            55756676
        ],
        "A": [
            55755278,
            55754991,
            55754916,
            55754981,
            55758172,
            55754952,
            55755176,
            55754923,
            55755064,
            55755117,
            55755166,
            55754951,
            55770975,
            55755955,
            55755304,
            55755094,
            55755216,
            55755238,
            55756678,
            55754929
        ]
    },
    "name": "D. Extra Element",
    "statement": "A sequence a_1, a_2,\r\ndots, a_k is called an arithmetic progression if for each i from 1 to k\r\nelements satisfy the condition a_i = a_1 + c\r\ncdot (i - 1) for some fixed c.For example, these five sequences are\r\narithmetic progressions: [5, 7, 9, 11], [101], [101, 100, 99], [13, 97]\r\nand [5, 5, 5, 5, 5]. And these four sequences aren\u2019t arithmetic\r\nprogressions: [3, 1, 2], [1, 2, 4, 8], [1, -1, 1, -1] and [1, 2, 3, 3,\r\n3].You are given a sequence of integers b_1, b_2,\r\ndots, b_n. Find any index j (1\r\nle j\r\nle n), such that if you delete b_j from the sequence, you can reorder\r\nthe remaining n-1 elements, so that you will get an arithmetic\r\nprogression. If there is no such index, output the number .\r\n",
    "solutions": [
        "///Mn kotr el labawy mb2t4 nawy\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nint n;\npair<int,int> b[2 * 1000 * 105];\nmap<int, int> mp;\nvoid rem(int i){\n  if(i){\n    mp[b[i].first-b[i-1].first]--;\n    if(mp[b[i].first-b[i-1].first]==0)mp.erase(b[i].first-b[i-1].first);\n  }\n  if(i!=n-1){\n    mp[b[i+1].first-b[i].first]--;\n    if(mp[b[i+1].first-b[i].first]==0)mp.erase(b[i+1].first-b[i].first);\n  }\n  if(i&&i!=n-1)\n    mp[b[i+1].first-b[i-1].first]++;\n}\nvoid add(int i){\n  if(i&&i!=n-1){\n    mp[b[i+1].first-b[i-1].first]--;\n    if(mp[b[i+1].first-b[i-1].first]==0)mp.erase(b[i+1].first-b[i-1].first);\n  }\n  if(i){\n    mp[b[i].first-b[i-1].first]++;\n  }\n  if(i!=n-1){\n    mp[b[i+1].first-b[i].first]++;\n  }\n}\nint main(){\n  ios_base::sync_with_stdio(0);cin.tie(0);\n\n  cin >> n;\n  for(int i = 0; i < n; i++)\n    cin >> b[i].first,b[i].second = i;\n\n  sort(b,b+n);\n\n  for(int i = 1; i < n; i++){\n      mp[b[i].first-b[i-1].first]++;\n  }\n  for(int i = 0; i < n; i++){\n    rem(i);\n    if(mp.size()==0||mp.size()==1){\n      cout << b[i].second+ 1 << '\\n';\n      return 0;\n    }\n    add(i);\n  }\n\n  cout << -1<<'\\n';\n\n\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Extra Element.json",
    "editorial_link": "https://codeforces.com//blog/entry/67829",
    "editorial": "First of all, we should sort all elements (from smaller to larger, for\r\nexample, or vice versa). But in the answer is index of element in\r\noriginal sequence, so let\u00e2\u0080\u0099s keep the array of pairs , sorted by .Now we\r\nneed to check some simple cases, for example, let\u00e2\u0080\u0099s check the -st and\r\nthe -nd elements whether they are the answers. We\u00e2\u0080\u0099ll create the copy of\r\noriginal sequence, but without -st element. Then we will check that all\r\nneighboring elements and have the same difference. If it is so, is the\r\nanswer. For the -nd element similarly.Okay, now we have the sequence,\r\nwhere -st and -nd elements aren\u00e2\u0080\u0099t the answers. Let\u00e2\u0080\u0099s fix difference\r\nbetween them and check that all neighboring elements and have the same\r\ndifference. If we meet the pair, where the difference doesn\u00e2\u0080\u0099t equal , we\r\nwill check the difference between and . If it equals , so may be the\r\nanswer, otherwise there is no answer (output ). If we will find one else\r\npair, where the difference doesn\u00e2\u0080\u0099t equals , there is no answer too.If\r\nall pairs have the difference that equals , it means that it\u00e2\u0080\u0099s initially\r\narithmetic progression. So we can remove first or last element and get\r\narithmetic progression again. In this case let\u00e2\u0080\u0099s output .\r\n"
}