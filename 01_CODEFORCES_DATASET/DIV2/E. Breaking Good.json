{
    "link": "https://codeforces.com//contest/507/problem/E",
    "problemId": "21018",
    "problem_idx": "E",
    "shortId": "507E",
    "contest_number": "507",
    "problem_submissions": {
        "E": [
            9526622,
            9522874,
            9528248,
            9522738,
            9519732,
            9522241,
            9524358,
            9526324,
            9526094,
            9526850,
            9526275,
            9527839,
            9524894,
            9533260,
            9526956,
            9526355,
            9527254,
            9534539,
            9527572,
            9528068,
            9528656
        ],
        "D": [
            9524452,
            9527107,
            9526768,
            9524593,
            10558273,
            10558123,
            10558122,
            9525066
        ],
        "C": [
            9521275,
            9525428,
            9521898,
            9519042,
            9523598,
            9520087,
            9521484,
            9522923,
            9523120,
            9521243,
            9521401,
            9526151,
            9520501,
            9521807,
            9523054,
            9522069,
            9522518,
            9521325,
            9520982
        ],
        "B": [
            9517387,
            9516026,
            9517698,
            9515711,
            9521710,
            9519733,
            9518855,
            9517565,
            9516742,
            9518683,
            9519009,
            9516196,
            9517854,
            9518052,
            9516626,
            9518923,
            9517641,
            9516929,
            9517425
        ],
        "A": [
            9515320,
            9514942,
            9515025,
            9514972,
            9520386,
            9520232,
            9514912,
            9515204,
            9515151,
            9515163,
            9515214,
            9515096,
            9514948,
            9515853,
            9515067,
            9517288,
            9515310,
            9515279,
            9516279
        ]
    },
    "name": "E. Breaking Good",
    "statement": "Breaking Good is a new video game which a lot of gamers want to have.\r\nThere is a certain level in the game that is really difficult even for\r\nexperienced gamers.Walter William, the main character of the game, wants\r\nto join a gang called Los Hermanos (The Brothers). The gang controls the\r\nwhole country which consists of cities with bidirectional roads\r\nconnecting them. There is no road is connecting a city to itself and for\r\nany two cities there is at most one road between them. The country is\r\nconnected, in the other words, it is possible to reach any city from any\r\nother city using the given roads. The roads aren\u2019t all working. There\r\nare some roads which need some more work to be performed to be\r\ncompletely functioning.The gang is going to rob a bank! The bank is\r\nlocated in city . As usual, the hardest part is to escape to their\r\nheadquarters where the police can\u2019t get them. The gang\u2019s headquarters is\r\nin city . To gain the gang\u2019s trust, Walter is in charge of this\r\noperation, so he came up with a smart plan.First of all the path which\r\nthey are going to use on their way back from city to their headquarters\r\nmust be , since it is important to finish operation as fast as\r\npossible.Then, gang has to blow up all other roads in country that don\u2019t\r\nlay on this path, in order to prevent any police reinforcements. In case\r\nof non-working road, they don\u2019t have to blow up it as it is already\r\nmalfunctional. If the chosen path has some roads that doesn\u2019t work\r\nthey\u2019ll have to repair those roads before the operation.Walter\r\ndiscovered that there was a lot of paths that satisfied the condition of\r\nbeing shortest possible so he decided to choose among them a path that\r\nminimizes the total number of affected roads (both roads that have to be\r\nblown up and roads to be repaired).Can you help Walter complete his task\r\nand gain the gang\u2019s trust?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Node {\n    int u;\n    pair<int, int> dis;\n    bool operator < (const Node &b) const {\n        return dis > b.dis;\n    }\n};\n\npriority_queue<Node> q;\npair<int, int> dis[100010];\nint use[100010];\n\nint uu[100010], vv[100010], ww[100010], pre[100010], preId[100010];\n\nvector<pair<int, int> > g[100010];\n\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < m; i ++) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        uu[i] = u;\n        vv[i] = v;\n        ww[i] = w;\n        g[u].push_back(make_pair(v, i));\n        g[v].push_back(make_pair(u, i));\n    }\n    memset(use, 0, sizeof(use));\n    Node st;\n    st.u = 1;\n    st.dis = make_pair(0, 0);\n    q.push(st);\n    dis[1] = st.dis;\n    use[1] = 1;\n    while (!q.empty()) {\n        Node s = q.top();\n        q.pop();\n        int u = s.u;\n        if (dis[u] != s.dis) {\n            continue;\n        }\n        for (auto x : g[u]) {\n            int v = x.first, id = x.second;\n            pair<int, int> ne = make_pair(dis[u].first + 1, dis[u].second + 1 - ww[id]);\n            if (!use[v] || dis[v] > ne) {\n                use[v] = 1;\n                dis[v] = ne;\n                pre[v] = u;\n                preId[v] = id;\n                Node now;\n                now.u = v;\n                now.dis = ne;\n                q.push(now);\n            }\n        }\n    }\n    memset(use, 0, sizeof(use));\n    int now = n;\n    while (now != 1) {\n        use[preId[now]] = 1;\n        now = pre[now];\n    }\n    int tot = 0;\n    for (int i = 0; i < m; i ++) {\n        if (!use[i] && ww[i] == 1) {\n            tot ++;\n        }\n        if (use[i] && ww[i] == 0) {\n            tot ++;\n        }\n    }\n    printf(\"%d\\n\", tot);\n    for (int i = 0; i < m; i ++) {\n        if (!use[i] && ww[i] == 1) {\n            printf(\"%d %d %d\\n\", uu[i], vv[i], 0);\n        }\n        if (use[i] && ww[i] == 0) {\n            printf(\"%d %d %d\\n\", uu[i], vv[i], 1);\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Breaking Good.json",
    "editorial_link": "https://codeforces.com/blog/entry/15975",
    "editorial": "Hint: Consider we\u00e2\u0080\u0099ve chosen a certain path with length where is the\r\nlength of the shortest path from to and it has edges that are working.\r\nAssume that is the total number of edges that are working in the whole\r\ncountry. So we need to make changes (to make the malfunctioning edges on\r\nthe path work) and changes (to blow up all other edges that don\u00e2\u0080\u0099t lie on\r\nthe path). So we will totally make changes where and are constants. So\r\nthe optimal solution will depend only on number of working edges along\r\nthe path. So we\u00e2\u0080\u0099ll have to maximize this number! Solution: We will use\r\ndynamic programming on all nodes that lies on some shortest path. In\r\nother words, every node that satisfies that the shortest path from to +\r\nthe shortest path from to equals where is the length of the shortest\r\npath from to . Let\u00e2\u0080\u0099s define is the maximum number of working edges along\r\nsome shortest path from to . We can calculate the value for all nodes by\r\ndynamic programming by traversing the nodes in order of increasing\r\nshortest path from node . So at the end we\u00e2\u0080\u0099ll make changes. We can get\r\nthem easily by retrieving the chosen optimal path. Time complexity:\r\nImplementation: 9529272\r\n"
}