{
    "link": "https://codeforces.com//contest/1966/problem/A",
    "problemId": "2615001",
    "problem_idx": "A",
    "shortId": "1966A",
    "contest_number": "1966",
    "problem_submissions": {
        "E": [
            258440120,
            258447865,
            258441495,
            258448292,
            258453329,
            258455007,
            258455562,
            258463703,
            258454902,
            258457920,
            258464021,
            258461311,
            258462638,
            258462895,
            258465595,
            258463312,
            258462674,
            258458699
        ],
        "B": [
            258438529,
            258422443,
            258424110,
            258425316,
            258424919,
            258422815,
            258422044,
            258421183,
            258426420,
            258424238,
            258425787,
            258424328,
            258425355,
            258428106,
            258426188,
            258424457,
            258424995,
            258442623
        ],
        "D": [
            258429599,
            258433739,
            258439478,
            258442551,
            258438117,
            258440328,
            258436731,
            258432022,
            258450610,
            258450325,
            258442193,
            258450098,
            258450833,
            258450813,
            258448974,
            258453024,
            258454359,
            258451828
        ],
        "C": [
            258425131,
            258429293,
            258430381,
            258430477,
            258430820,
            258432851,
            258429869,
            258440236,
            258434780,
            258430009,
            258432109,
            258435350,
            258435642,
            258434757,
            258435098,
            258436413,
            258434457,
            258433325
        ],
        "A": [
            258421447,
            258418791,
            258419370,
            258420086,
            258417776,
            258418880,
            258418284,
            258421321,
            258417852,
            258418112,
            258418571,
            258418222,
            258418421,
            258419544,
            258419765,
            258417953,
            258420988,
            258424462
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "If you don\u00e2\u0080\u0099t initially have at least copies of any number, you can\u00e2\u0080\u0099t\r\nperform any operations, so the answer is .Otherwise, we can show that we\r\ncan always get down to cards, with the following algorithm: Choose any\r\ncard that you have copies of, and remove those copies If you have no\r\nmore cards, take any cards and end the process. Otherwise, let be the\r\nnumber on any card you have. Take copies of . Now, you have at least\r\ncopies of , so return to step . Since the total number of cards\r\ndecreases at each step, this process will always terminate, so you will\r\nalways end up with cards. Also, since the total number of cards\r\ndecreases by exactly at each step, and you can\u00e2\u0080\u0099t do any operations if\r\nyou have less than cards, it is impossible to do better than , so our\r\nsolution of is optimal.Complexity: or depending on implementation.\r\n",
    "name": "A. Card Exchange",
    "statement": "You have a hand of n cards, where each card has a number written on it,\r\nand a fixed integer k. You can perform the following operation any\r\nnumber of times: Choose any k cards from your hand that all have the\r\nsame number. Exchange these cards for k-1 cards, each of which can have\r\nnumber you choose (including the number written on the cards you just\r\nexchanged). Here is one possible sequence of operations for the first\r\nexample case, which has k=3: What is the minimum number of cards you can\r\nhave in your hand at the end of this process?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair<int,int> pii;const int N=505,Inf=1e9;int n,k,a[N],Cnt[N];signed main(){\tstd::ios::sync_with_stdio(false);\tcin.tie(0),cout.tie(0);\tint t;\tcin>>t;\twhile(t--){\t\tcin>>n>>k;\t\tmemset(Cnt,0,sizeof(Cnt));\t\tfor(int i=1,x;i<=n;++i)cin>>x,++Cnt[x];\t\twhile(1){\t\t\tint Mx=-1,i1=0,Mn=Inf,i2=0;\t\t\tfor(int i=1;i<=100;++i){\t\t\t\tif(Cnt[i]<k)continue;\t\t\t\tif(Mn>Cnt[i])Mn=Cnt[i],i2=i;\t\t\t}//\t\t\tcout<<i2<<\" \";\t\t\tif(!i2)break;\t\t\tCnt[i2]-=k;\t\t\tfor(int i=1;i<=100;++i){\t\t\t\tif(Mx<Cnt[i])Mx=Cnt[i],i1=i;\t\t\t}//\t\t\tcout<<i1<<\"  \";\t\t\tCnt[i1]+=k-1;\t\t}\t\tint Res=0;\t\tfor(int i=1;i<=100;++i)Res+=Cnt[i];\t\tcout<<Res<<\"\\n\";\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Card Exchange.json"
}