{
    "link": "https://codeforces.com//contest/1747/problem/D",
    "problemId": "1620661",
    "problem_idx": "D",
    "shortId": "1747D",
    "contest_number": "1747",
    "problem_submissions": {
        "E": [
            179486870,
            179253920,
            179273440,
            179260537,
            179225386,
            179271971,
            179283076,
            179281826,
            179282297,
            186348217,
            179284673,
            179245931
        ],
        "D": [
            179486860,
            179233757,
            179222054,
            179228487,
            179238738,
            179241063,
            179241183,
            179224057,
            179264449,
            179259728,
            179260831,
            179237890,
            179236308,
            180743238,
            179237732,
            179232676,
            179243502,
            179244572,
            179246464,
            179243020,
            179246798,
            179249877
        ],
        "C": [
            179486839,
            179213479,
            179208855,
            179232874,
            179261125,
            179235210,
            179222140,
            179238001,
            179214781,
            179211570,
            179268241,
            179214460,
            179214791,
            179205118,
            179213034,
            179214071,
            179222975,
            179219181,
            179217125,
            179223792,
            179216359
        ],
        "B": [
            179486831,
            179205385,
            179204232,
            179234016,
            179257195,
            179206841,
            179210631,
            179225692,
            179213313,
            179206192,
            179275964,
            179205986,
            179209442,
            179215191,
            179207056,
            179208301,
            179209222,
            179210943,
            179209630,
            179208432,
            179211946
        ],
        "A": [
            179486823,
            179200411,
            179199751,
            179235050,
            179240090,
            179202014,
            179204980,
            179199923,
            179202535,
            179200360,
            179277442,
            179199925,
            179203286,
            179208363,
            179199780,
            179200477,
            179203571,
            179204793,
            179201814,
            179200654,
            179202827
        ]
    },
    "name": "D. Yet Another Problem",
    "statement": "You are given an array a of n integers a_1, a_2, a_3,\r\nldots, a_n.You have to answer q independent queries, each consisting of\r\ntwo integers l and r. Consider the subarray a[l:r] = [a_l, a_{l+1},\r\nldots, a_r]. You can apply the following operation to the subarray any\r\nnumber of times (possibly zero)- Choose two integers L, R such that l\r\nle L\r\nle R\r\nle r and R - L + 1 is . Replace each element in the subarray from L to R\r\nwith the of the elements in the subarray [L, R]. The answer to the query\r\nis the minimum number of operations required to make all elements of the\r\nsubarray a[l:r] equal to 0 or -1 if it is impossible to make all of them\r\nequal to 0. You can find more details about operation here.\r\n",
    "solutions": [
        "// LUOGU_RID: 93003089\n/*\n\u308f\u3093\u308f\u3093\u2026\u2026\u308f\u3093\u3060\u307b\u30fc\u3044\u3063\u2606\nWonderhoy!\n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nchar buf[1<<21],*p1=buf,*p2=buf;\n#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)\nLL read()\n{\n\tLL x=0;\n\tchar c=getchar();\n\twhile(c<'0' || c>'9')\tc=getchar();\n\twhile(c>='0' && c<='9')\tx=(x<<1)+(x<<3)+(c^'0'),c=getchar();\n\treturn x;\n}\nvoid write(LL x)\n{\n\tif(x>9)\twrite(x/10);\n\tputchar(x%10+'0');\n}\nLL n,q;\nLL a[200005];\nLL pre[200005];\nLL sum[200005];\nmap<LL,LL> M;\nLL cnt;\nset<LL> S[200005][2];\nint main(){\n\tn=read(),q=read();\n\tfor(LL i=1;i<=n;++i)\ta[i]=read(),pre[i]=pre[i-1]^a[i],sum[i]=sum[i-1]+a[i];\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tif(!M[pre[i]])\tM[pre[i]]=++cnt;\n\t\tS[M[pre[i]]][i&1].insert(i);\n\t}\n\twhile(q-->0)\n\t{\n\t\tLL l=read(),r=read();\n\t\tif(pre[r]^pre[l-1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(sum[r]==sum[l-1])\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tif((r-l+1)&1)\n\t\t{\n\t\t\tputs(\"1\");\n\t\t\tcontinue;\n\t\t}\n\t\tLL d=M[pre[l-1]],p=l&1;\n\t\tauto it=S[d][p].lower_bound(l);\n\t\tif(it==S[d][p].end() || *it>r)\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tif(a[l]==0 || a[r]==0)\tputs(\"1\");\n\t\t\telse\tputs(\"2\");\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "constructive algorithms",
        "data structures"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Yet Another Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/108782",
    "editorial": "First forget queries, solve for single array a\n.\n\nLet's make some observations.\n\nXor of array does not change after each operation\n\nLook at the set of prefix XORs while doing operations. Its size always decreases or remains same after each operation. Infact we can further reduce it to parities. Let S0\n, S1\n be sets of prefix XOR's of parities 0\n and 1\n respectively. After each operation new sets S?0\n, S?1\n will be subsets of S0\n and S1\n respectively.\n\nSo necessary conditions for answer to exist is that xor of array should be 0\n and S1\n should contains 0\n.\n\nNow comes to minimum operations.\n\nClaim: If above conditions are satisfied, its always possible to make all elements 0\n in less than or equal to 2\n operations\n\nProof: Let length of array be n\n.\n\nCase 1: n\n is odd\n\nJust apply the operation on whole array.\n\nCase 2: n\n is even\n\nThere will exists some odd size prefix j\n such that xor of its elements is 0\n. Apply operation on [1,j]\n and [j+1,n]\n. It can happen that j=1\n or j=n?1\n, in that case we only need one operation, because other remaining element would already be equal to 0\n."
}