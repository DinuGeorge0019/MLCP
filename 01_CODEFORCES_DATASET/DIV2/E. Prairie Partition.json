{
    "link": "https://codeforces.com//contest/807/problem/E",
    "problemId": "105605",
    "problem_idx": "E",
    "shortId": "807E",
    "contest_number": "807",
    "problem_submissions": {
        "C": [
            26937367,
            26932679,
            26931824,
            26933954,
            26935002,
            26945243,
            26934673,
            26931916,
            26932051,
            26931857,
            26932221,
            26934137,
            26931106,
            26934955,
            26948034,
            26933750,
            26931179,
            26933734
        ],
        "E": [
            26937218,
            26941715,
            26942118,
            26943819,
            26944219,
            26940388,
            26942912,
            26974189,
            26945366,
            26938570,
            26939988,
            26940095
        ],
        "D": [
            26933616,
            26938470,
            26937308,
            26935937,
            26940795,
            26937188,
            26938367,
            26934356,
            26935620,
            26933949,
            26944682,
            26939881,
            26963824,
            26941895,
            26936251,
            26938625,
            26938681
        ],
        "B": [
            26929187,
            26930221,
            26930051,
            26930975,
            26931611,
            26930997,
            26945828,
            26929713,
            26931410,
            26929634,
            26929851,
            26931739,
            26929439,
            26931155,
            26930623,
            26932660,
            26928773,
            26928963
        ],
        "A": [
            26926738,
            26928269,
            26927513,
            26927911,
            81453119,
            81452755,
            26927099,
            26927720,
            26926862,
            26927495,
            26936234,
            26928013,
            26926637,
            26926993,
            26927122,
            26929273,
            26927007,
            26927862,
            26926641,
            26926659
        ],
        "F": [
            27349164
        ]
    },
    "name": "E. Prairie Partition",
    "statement": "It can be shown that any positive integer can be uniquely represented as\r\n, where and are integers, , . Let\u2019s call that representation of .For\r\nexample, the prairie partitions of , , and are: ,,,. Alice took a\r\nsequence of positive integers (possibly with repeating elements),\r\nreplaced every element with the sequence of summands in its prairie\r\npartition, arranged the resulting numbers in non-decreasing order and\r\ngave them to Borys. Now Borys wonders how many elements Alice\u2019s original\r\nsequence could contain. Find all possible options!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<long long> vec;\nint n;\nvector<int> a,b,res;\n\nbool possible(int t) {\n    int tinit = t;\n    vector<int> aux = a, bux = b;\n    if(aux[0] < t) {\n        return false;\n    }\n    bux[1] += aux[0]-t;\n    for(int i=1;i<41;i++) {\n        if(bux[i] > t) {\n            return false;\n        }\n        if(aux[i] > t) {\n            bux[i+1] += aux[i]-t;\n        } else if(aux[i] < t) {\n            bux[i] -= t-aux[i];\n            bux[i] = max(bux[i],0);\n            t = aux[i];\n        }\n        bux[i+1] += bux[i];\n    }\n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    vec.resize(n);\n    for(int i=0;i<n;i++) {\n        cin >> vec[i];\n    }\n    a.resize(42);\n    b.resize(42);\n    for(int i=0;i<42;i++) {\n        a[i] = 0;\n        b[i] = 0;\n    }\n    int pot = 0;\n    for(int i=0;i<vec.size();i++) {\n        while(vec[i] > (1LL<<pot)) {\n            pot++;\n        }\n        if(vec[i] == (1LL<<pot)) {\n            a[pot]++;\n        } else {\n            b[pot]++;\n        }\n    }\n    res.clear();\n    for(int i=1;i<=n;i++) {\n        if(possible(i)) {\n            res.push_back(i);\n        }\n    }\n    if(res.empty()) {\n        cout << -1 << endl;\n    } else {\n        for(int i=0;i<res.size();i++) {\n            if(i == res.size()-1) {\n                cout << res[i] << endl;\n            } else {\n                cout << res[i] << \" \";\n            }\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Prairie Partition.json",
    "editorial_link": "https://codeforces.com/blog/entry/51883",
    "editorial": "This kind of partition sometimes shows up in solutions to knapsack problems with multiple items of the same type.\n\nLet's say we want to check if the answer can be m. That means we have to construct m chains of powers of 2 like 1,?2,?4,?...,?2k?-?1 (possibly with different values of k), and then assign at most one of the remaining elements to each chain so that the element doesn't exceed double the largest power of 2 in its assigned chain. If we can assign all the elements successfully, m is one possible answer.\n\nIt can be proved that the chains can be constructed greedily one by one, with each chain as long as possible. Let's denote the number of occurrences of integer x in the input by c(x). Then, the number of chains where integer 2k can be used is restricted by bound(2k)?=?min(c(20),?c(21),?...,?c(2k)). If we construct the chains greedily, then it's easy to see that the first bound(2k) chains will use 2k. And if we use as many occurrences of powers of 2 as possible, that's better both because we are left with less elements to be assigned to the chains and because the largest powers of 2 in the chains are higher, thus more elements can be assigned to the chains.\n\nHaving m chains constructed, how do we quickly check if we can assign the remaining elements to these chains? This can also be done greedily. If we can't assign the largest of the remaining elements to the longest chain, then we can't assign this element to any chain, so there's no possible assignment. Otherwise, remove the largest element and the longest chain from consideration, and repeat the process until we either assign all the elements or run into a failure situation described above. Why is greedy correct? Consider a valid assignment where the largest element E is assigned to some chain c, and some element e is assigned to the longest chain C. If E???e and C???c, it can be seen that we can as well reassign E to C and e to c to get another valid assignment. Thus, if there exists a valid assignment, there also exists one with E assigned to C.\n\nImplemented straightforwardly, this solution works in O(n2). In fact, both factors of n can be optimized.\n\nFirst, it can be seen that if m is one possible answer but there is at least element equal to 1 not yet involved in any chains, then m?+?1 is another possible answer, since when we construct the m?+?1-th chain we only make the situation better \u0097 we won't have to assigned the elements of this chain to other chains, and we'll have another chain which can be used for assignment too. Therefore, we can perform a binary search on the smallest possible value of m, thus having to do  assignments instead of O(n).\n\nSecond, let a be the largest of the input integers. All elements of the input sequence can be distributed into  groups: powers of 2, and integers between consecutive powers of 2. The integers in the groups are effectively indistinguishable from our point of view, which allows us to do the assignment part in .\n\nApplying any of these two optimizations was enough to solve the problem."
}