{"link": "https://codeforces.com//contest/807/problem/E", "problemId": "105605", "problem_idx": "E", "shortId": "807E", "contest_number": "807", "problem_submissions": {"C": [26937367, 26932679, 26931824, 26933954, 26935002, 26945243, 26934673, 26931916, 26932051, 26931857, 26932221, 26934137, 26931106, 26934955, 26948034, 26933750, 26931179, 26933734], "E": [26937218, 26941715, 26942118, 26943819, 26944219, 26940388, 26942912, 26974189, 26945366, 26938570, 26939988, 26940095], "D": [26933616, 26938470, 26937308, 26935937, 26940795, 26937188, 26938367, 26934356, 26935620, 26933949, 26944682, 26939881, 26963824, 26941895, 26936251, 26938625, 26938681], "B": [26929187, 26930221, 26930051, 26930975, 26931611, 26930997, 26945828, 26929713, 26931410, 26929634, 26929851, 26931739, 26929439, 26931155, 26930623, 26932660, 26928773, 26928963], "A": [26926738, 26928269, 26927513, 26927911, 81453119, 81452755, 26927099, 26927720, 26926862, 26927495, 26936234, 26928013, 26926637, 26926993, 26927122, 26929273, 26927007, 26927862, 26926641, 26926659], "F": [27349164]}, "name": "E. Prairie Partition", "statement": "It can be shown that any positive integer can be uniquely represented as\r\n, where and are integers, , . Let\u2019s call that representation of .For\r\nexample, the prairie partitions of , , and are: ,,,. Alice took a\r\nsequence of positive integers (possibly with repeating elements),\r\nreplaced every element with the sequence of summands in its prairie\r\npartition, arranged the resulting numbers in non-decreasing order and\r\ngave them to Borys. Now Borys wonders how many elements Alice\u2019s original\r\nsequence could contain. Find all possible options!\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<long long> vec;\nint n;\nvector<int> a,b,res;\n\nbool possible(int t) {\n    int tinit = t;\n    vector<int> aux = a, bux = b;\n    if(aux[0] < t) {\n        return false;\n    }\n    bux[1] += aux[0]-t;\n    for(int i=1;i<41;i++) {\n        if(bux[i] > t) {\n            return false;\n        }\n        if(aux[i] > t) {\n            bux[i+1] += aux[i]-t;\n        } else if(aux[i] < t) {\n            bux[i] -= t-aux[i];\n            bux[i] = max(bux[i],0);\n            t = aux[i];\n        }\n        bux[i+1] += bux[i];\n    }\n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    vec.resize(n);\n    for(int i=0;i<n;i++) {\n        cin >> vec[i];\n    }\n    a.resize(42);\n    b.resize(42);\n    for(int i=0;i<42;i++) {\n        a[i] = 0;\n        b[i] = 0;\n    }\n    int pot = 0;\n    for(int i=0;i<vec.size();i++) {\n        while(vec[i] > (1LL<<pot)) {\n            pot++;\n        }\n        if(vec[i] == (1LL<<pot)) {\n            a[pot]++;\n        } else {\n            b[pot]++;\n        }\n    }\n    res.clear();\n    for(int i=1;i<=n;i++) {\n        if(possible(i)) {\n            res.push_back(i);\n        }\n    }\n    if(res.empty()) {\n        cout << -1 << endl;\n    } else {\n        for(int i=0;i<res.size();i++) {\n            if(i == res.size()-1) {\n                cout << res[i] << endl;\n            } else {\n                cout << res[i] << \" \";\n            }\n        }\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "greedy"], "dificulty": "2200", "interactive": false}