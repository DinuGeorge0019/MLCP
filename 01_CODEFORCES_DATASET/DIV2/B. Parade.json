{
    "link": "https://codeforces.com//contest/733/problem/B",
    "problemId": "78298",
    "problem_idx": "B",
    "shortId": "733B",
    "contest_number": "733",
    "problem_submissions": {
        "F": [
            21944181,
            21943396,
            21967823,
            21944382,
            21944760,
            21938912,
            21991227,
            22059840,
            21937562,
            21938035,
            21985645,
            21991821,
            21953425,
            22015051,
            21990688
        ],
        "E": [
            21937191,
            21938008,
            21943531,
            21943185,
            21953321,
            21943118,
            21945071,
            21961545
        ],
        "D": [
            21929126,
            21923181,
            21934246,
            21934699,
            21930359,
            21930083,
            21921931,
            21937281,
            21933013,
            21933051,
            21930915,
            21933717,
            21930137,
            21931610,
            21929842,
            21935332,
            21929335,
            21936423,
            21930780,
            21933993
        ],
        "C": [
            21927957,
            21950571,
            21931020,
            21929401,
            21936037,
            21935885,
            21953665,
            21934528,
            21938848,
            21929683,
            21937215,
            21940711,
            21934393,
            21928582,
            21934351,
            21931346,
            21936860,
            21931930
        ],
        "B": [
            21922288,
            21927937,
            21923164,
            21922462,
            21923910,
            21924025,
            21925504,
            21933294,
            21928279,
            21922570,
            21924161,
            21922272,
            21921961,
            21923577,
            21924912,
            21921350,
            21922700,
            21923311,
            21923198,
            21925029
        ],
        "A": [
            21919764,
            21920167,
            21920208,
            21919696,
            21920676,
            21920418,
            21919388,
            21932202,
            21929074,
            21920399,
            21925006,
            21920161,
            21919497,
            21919471,
            21922256,
            21919494,
            21926774,
            21920063,
            21919707,
            21927283
        ]
    },
    "name": "B. Parade",
    "statement": "Very soon there will be a parade of victory over alien invaders in\r\nBerland. Unfortunately, all soldiers died in the war and now the army\r\nconsists of entirely new recruits, many of whom do not even know from\r\nwhich leg they should begin to march. The civilian population also\r\npoorly understands from which leg recruits begin to march, so it is only\r\nimportant how many soldiers march in step.There will be columns\r\nparticipating in the parade, the -th column consists of soldiers, who\r\nstart to march from left leg, and soldiers, who start to march from\r\nright leg.The beauty of the parade is calculated by the following\r\nformula: if is the total number of soldiers on the parade who start to\r\nmarch from the left leg, and is the total number of soldiers on the\r\nparade who start to march from the right leg, so the beauty will equal .\r\nyou can choose one column and tell in this column to switch starting\r\nleg, i.e. everyone in this columns who starts the march from left leg\r\nwill now start it from right leg, and vice versa. Formally, you can pick\r\nno more than one index and swap values and . Find the index of the\r\ncolumn, such that switching the starting leg for soldiers in it will\r\nmaximize the the beauty of the parade, or determine, that no such\r\noperation can increase the current beauty.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint l[100005], r[100005];\n\nint main()\n{\n  int n;\n  cin >> n;\n  int s1 = 0, s2 = 0;\n  int ans = 0, ch = 0;\n  for(int i=0;i<n;i++)\n  {\n    scanf(\"%d %d\", &l[i], &r[i]);\n    s1 += l[i];\n    s2 += r[i];\n  }\n  ans = abs(s1 - s2);\n  for(int i=0;i<n;i++)\n  {\n    s1 += r[i] - l[i];\n    s2 += l[i] - r[i];\n    if(abs(s1 - s2) > ans)\n    {\n      ans = abs(s1 - s2);\n      ch = i + 1;\n    }\n    s2 += r[i] - l[i];\n    s1 += l[i] - r[i];\n  }\n  cout << ch;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Parade.json",
    "editorial_link": "https://codeforces.com//blog/entry/48133",
    "editorial": "Let\u00e2\u0080\u0099s calculate and values before update moves. Result will be stored in\r\nmaximum beauty that can be achieved. So initially . Now for every columm\r\nlet\u00e2\u0080\u0099s calculate - beauty of the parade after switching starting leg of\r\n-th column. . If then update value and store index for answer.If there\r\nwere no such that then answer is 0.Time complexity .\r\n"
}