{
    "link": "https://codeforces.com//contest/1200/problem/D",
    "problemId": "387084",
    "problem_idx": "D",
    "shortId": "1200D",
    "contest_number": "1200",
    "problem_submissions": {
        "F": [
            58597034,
            58604274,
            58603801,
            58604261,
            58606296,
            58609347,
            58606628,
            58603882,
            58611421,
            58614224,
            58612143,
            58659085,
            58617947,
            58615235,
            58614922,
            58618563,
            58618410,
            58819839,
            58819733,
            58614658,
            58617967,
            58616220,
            58617480
        ],
        "E": [
            58590453,
            58591974,
            58589669,
            58582754,
            58593262,
            58593765,
            58594950,
            58609042,
            58590807,
            58600501,
            58598133,
            58655621,
            58603439,
            58602117,
            58595933,
            58604924,
            58702004,
            58608728,
            58607700,
            58606886,
            58608547,
            58595823
        ],
        "D": [
            58585183,
            58587196,
            58595741,
            58592331,
            58597422,
            58600351,
            58598831,
            58588698,
            58604146,
            58596632,
            58604059,
            58594391,
            58596161,
            58605981,
            58592911,
            58594958,
            58601895,
            58602011,
            58595454,
            58607933
        ],
        "C": [
            58581348,
            58578761,
            58581508,
            58598446,
            58584753,
            58585227,
            58584309,
            58590893,
            58582665,
            58580776,
            58585592,
            58580638,
            58583883,
            58586342,
            58585762,
            58586591,
            58578435,
            58584027,
            58584223,
            58583648
        ],
        "B": [
            58580222,
            58581800,
            58579349,
            58596443,
            58582220,
            58582093,
            58584008,
            58593306,
            58580382,
            58578318,
            58581197,
            58578343,
            58580875,
            58583711,
            58582188,
            58581441,
            58581810,
            58580259,
            58599702,
            58580893
        ],
        "A": [
            58576391,
            58576584,
            58577266,
            58594056,
            58576879,
            58576717,
            58577509,
            58578116,
            58576412,
            58576423,
            58577739,
            58576429,
            58576681,
            58580309,
            58578442,
            58576553,
            58583309,
            58576504,
            58576736,
            58576406
        ]
    },
    "name": "D. White Lines",
    "statement": "Gildong has bought a famous painting software . The working screen of\r\ncfpaint is square-shaped consisting of n rows and n columns of square\r\ncells. The rows are numbered from 1 to n, from top to bottom, and the\r\ncolumns are numbered from 1 to n, from left to right. The position of a\r\ncell at row r and column c is represented as (r, c). There are only two\r\ncolors for the cells in cfpaint black and white.There is a tool named in\r\ncfpaint. The eraser has an integer size k (1\r\nle k\r\nle n). To use the eraser, Gildong needs to click on a cell (i, j) where\r\n1\r\nle i, j\r\nle n - k + 1. When a cell (i, j) is clicked, all of the cells (i\u2019, j\u2019)\r\nwhere i\r\nle i\u2019\r\nle i + k - 1 and j\r\nle j\u2019\r\nle j + k - 1 become white. In other words, a square with side equal to k\r\ncells and top left corner at (i, j) is colored white.A is a row or a\r\ncolumn without any black cells.Gildong has worked with cfpaint for some\r\ntime, so some of the cells (possibly zero or all) are currently black.\r\nHe wants to know the maximum number of after using the eraser . Help\r\nGildong find the answer to his question.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mxN=2e3;\nint n, k, b[mxN+1][mxN+1];\nstring s[mxN];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> k;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> s[i];\n\tfor(int i=0; i<n; ++i) {\n\t\tint l=0;\n\t\twhile(l<n&&s[i][l]=='W')\n\t\t\t++l;\n\t\tif(l>=n) {\n\t\t\t++b[0][0];\n\t\t\tcontinue;\n\t\t}\n\t\tint r=n-1;\n\t\twhile(~r&&s[i][r]=='W')\n\t\t\t--r;\n\t\tif(r-l+1>k)\n\t\t\tcontinue;\n\t\t//i-k+1, i\n\t\t//r-k+1, l\n\t\tint l1=max(i-k+1, 0), r1=i+1;\n\t\tint l2=max(r-k+1, 0), r2=l+1;\n\t\t++b[l1][l2];\n\t\t--b[l1][r2];\n\t\t--b[r1][l2];\n\t\t++b[r1][r2];\n\t}\n\tfor(int j=0; j<n; ++j) {\n\t\tint l=0;\n\t\twhile(l<n&&s[l][j]=='W')\n\t\t\t++l;\n\t\tif(l>=n) {\n\t\t\t++b[0][0];\n\t\t\tcontinue;\n\t\t}\n\t\tint r=n-1;\n\t\twhile(~r&&s[r][j]=='W')\n\t\t\t--r;\n\t\tif(r-l+1>k)\n\t\t\tcontinue;\n\t\t//r-k+1, l\n\t\t//j-k+1, j\n\t\tint l1=max(r-k+1, 0), r1=l+1;\n\t\tint l2=max(j-k+1, 0), r2=j+1;\n\t\t++b[l1][l2];\n\t\t--b[l1][r2];\n\t\t--b[r1][l2];\n\t\t++b[r1][r2];\n\t}\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tb[i][j+1]+=b[i][j];\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tb[i+1][j]+=b[i][j];\n\tint ans=0;\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tans=max(b[i][j], ans);\n\tcout << ans;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. White Lines.json",
    "editorial_link": "https://codeforces.com/blog/entry/69035",
    "editorial": "Let\u00e2\u0080\u0099s consider a single row that contains at least one black cell. If\r\nthe first appearance of a black cell is at the -th column and the last\r\nappearance of a black cell is at the -th column, we can determine\r\nwhether it becomes a white line when a certain cell is clicked in ,\r\nafter some preprocessing. It becomes a white line if and only if a cell\r\nis clicked where the row is at and . We just need to compute and in\r\nadvance.Now let\u00e2\u0080\u0099s consider all rows (not columns). First, count all rows\r\nthat are already white lines before clicking. Then we count the number\r\nof white rows when the cell is clicked, by applying the above method to\r\nall rows from to . Ignore the already-white rows that we counted before.\r\nSo far we obtained the number of white rows when the cell is clicked.\r\nFrom now, we . Add the -st row and remove the -st row by applying the\r\nsame method to them, and we obtain the number of white rows when the\r\ncell is clicked. We can repeat this until we calculate all cases for\r\nclicking the cells at the -st column. Then we repeat the whole process\r\nfor all columns.The same process can be done for counting white columns,\r\ntoo. Now we know the number of white rows and white columns when each\r\ncell is clicked, so we can find the maximum value among their sums.Time\r\ncomplexity:\r\n"
}