{
    "link": "https://codeforces.com//contest/1957/problem/E",
    "problemId": "2603603",
    "problem_idx": "E",
    "shortId": "1957E",
    "contest_number": "1957",
    "problem_submissions": {
        "F2": [
            257624433,
            257624489,
            257628560,
            257621420,
            257758223,
            257757604,
            257757158,
            257717832,
            257717730,
            257717258,
            257717094,
            257702987,
            257702893,
            257653582,
            257653503,
            257653382,
            257648260,
            257648200,
            257641190,
            257634868,
            258552083,
            257634246,
            257634091,
            257829923,
            257637903,
            257630367,
            257637563,
            257640902,
            257704441,
            257700658,
            257703241,
            257675512
        ],
        "F1": [
            257621694,
            257624482,
            257625658,
            257622086,
            257648013,
            257642139,
            257635215,
            257625683,
            257633642,
            258551844,
            257633990,
            257634721,
            257829841,
            257638057,
            257627166,
            257647697,
            257636396,
            257640746,
            257705007,
            257704891,
            257704777,
            257704536,
            257700768,
            257627958
        ],
        "E": [
            257613753,
            257614244,
            257616954,
            257640621,
            257621102,
            257640619,
            257640273,
            257640555,
            259401179,
            257624465,
            258075127,
            258075029,
            257758887,
            257629108,
            257623748,
            257629560,
            257710288,
            257703200,
            257629906
        ],
        "D": [
            257596630,
            257598457,
            257598487,
            257603992,
            257647200,
            257596253,
            257607704,
            257604728,
            257613557,
            257603006,
            257615450,
            257603399,
            257750188,
            257750155,
            257615591,
            257640469,
            257600270,
            257625077,
            257609428,
            257606452,
            257699780,
            257597686,
            257607920
        ],
        "C": [
            257588829,
            257601875,
            257591094,
            257606559,
            257647316,
            257588836,
            257594613,
            257599149,
            257595684,
            257596544,
            257603207,
            257596444,
            257750051,
            257601967,
            257593914,
            257592224,
            257605529,
            257595109,
            257707171,
            257596812,
            257597956
        ],
        "B": [
            257581790,
            257579250,
            257586196,
            257583617,
            257579912,
            257584731,
            257593706,
            257593301,
            257585131,
            257584270,
            257581125,
            257750016,
            257588415,
            257583409,
            257582823,
            257585712,
            257597823,
            257594421,
            257595763,
            257581837
        ],
        "A": [
            257576275,
            257575809,
            257577678,
            257575791,
            257575498,
            257575836,
            257579145,
            257575454,
            257576815,
            257575470,
            257575437,
            257749968,
            257582519,
            257575927,
            257575935,
            257576650,
            257596800,
            257590104,
            257582071,
            257575937
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128716",
    "editorial": "Let\u00e2\u0080\u0099s start by first solving the problem for , and extend the idea to\r\nlater. To solve for , we\u00e2\u0080\u0099ll find the smallest value that occurs with\r\ndifferent frequencies on the two paths.We\u00e2\u0080\u0099ll solve an easier version by\r\nsolving for two static arrays, instead of solving the problem of two\r\npaths. To find the smallest value that has a different frequency between\r\nthe two arrays, we can have a segment tree on the frequency array for\r\neach static array. Then, we can store the hash of each segment tree node\r\nand perform a descent to find the first point at which the hashes in the\r\ntwo segment trees differ. The hash of a node is the polynomial hash of\r\nthe subarray it corresponds to.Now, in order to use the same technique\r\non the path, we want the frequency array of the path . To achieve this,\r\nwe can use persistent segment trees. We define to be the segment tree\r\nthat corresponds to the frequency array of the values on the path . With\r\nthe idea of persistence, we can quickly compute for all , when we root\r\nat .To compute , we can use this: for every node in the segment tree\r\nthat we want.Hence, we are able to get the segment tree for the two\r\npaths we need to compare in a query. In our solution with the static\r\narrays, we used the polynomial hash to find the first point of\r\ndifference between the two frequency arrays. So, we need a way to\r\nquickly compute the hash of the pseudo node we computed for .If we have\r\ntwo frequency arrays , , , where the hash of a node is the polynomial\r\nhash of the subarray that corresponds to that node.Hence, we can\r\nsay:Hence, we can perform the same descent that we talked about earlier\r\non the derived segment tree.Now to solve this for , you can perform a\r\ndfs on , and keep entering nodes of the segment tree which have\r\ndiffering hashes, until we find values.The total time complexity comes\r\nout to\r\n",
    "name": "E. Carousel of Combinations",
    "statement": "You are given an integer n. The function C(i,k) represents the number of\r\ndistinct ways you can select k distinct numbers from the set {1, 2,\r\nldots, i} and arrange them in a circle^\r\ndagger.Find the value of\r\nsum\r\nlimits_{i=1}^n\r\nsum\r\nlimits_{j=1}^i\r\nleft( C(i,j)\r\nbmod j\r\nright). Here, the operation x\r\nbmod y denotes the remainder from dividing x by y.Since this value can\r\nbe very large, find it modulo 10^9+7.^\r\ndagger In a circular arrangement, sequences are considered identical if\r\none can be rotated to match the other. For instance, [1, 2, 3] and [2,\r\n3, 1] are equivalent in a circle.\r\n",
    "solutions": [
        "/*\u5728\u53d1\u89c9\u90a3\u4e00\u5929 \u5728\u90a3\u4e00\u5929\u6f6e\u6c5b\u6cdb\u4e0a\u9ad8\u7b51\u57ce\u5899\u65f6\u95f4\u8bf7\u5c06\u4e00\u5207\u8bc1\u660e*/#include<bits/stdc++.h>using namespace std;const int maxn=1000005,mod=1000000007;int n,m,T,flg,tot;int a[maxn],fac[maxn],nfac[maxn],inv[maxn],mul[maxn],pr[maxn],ans[maxn];inline int C(int a,int b){\treturn a<b? 0:1ll*fac[a]*nfac[b]%mod*nfac[a-b]%mod;}inline void inc(int &x,int y){\tx+=y;\tif(x>=mod)\t\tx-=mod;}int main(){\tfac[0]=fac[1]=inv[1]=nfac[0]=nfac[1]=1;\tfor(int i=2;i<maxn;i++)\t\tfac[i]=1ll*fac[i-1]*i%mod,inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod,nfac[i]=1ll*nfac[i-1]*inv[i]%mod;\tfor(int i=2;i<maxn;i++)\t\tfor(int j=i+i;j<maxn;j+=i)\t\t\tpr[j]=1;\tn=1e6;\tfor(int j=2;j<=n;j++)\t\tif(pr[j]==0||j==4)\t\t\tfor(int i=j;i<=n;i+=j){\t\t\t\tint val=1ll*(i/j)*(j-1)%j;\t\t\t\tif(j==4)\t\t\t\t\tval=1ll*(i/j)*2%j;\t\t\t\tinc(ans[i],val);\t\t\t\tif(i+j-1<=n)\t\t\t\t\tinc(ans[i+j],mod-val);//\t\t\t\t(ans+1ll*val*min(n-i+1,j))%mod;\t\t\t}\tfor(int i=1;i<maxn;i++)\t\tans[i]=(ans[i-1]+ans[i])%mod;\tfor(int i=1;i<maxn;i++)\t\tans[i]=(ans[i-1]+ans[i])%mod;\tscanf(\"%d\",&T);\twhile(T--){\t\tscanf(\"%d\",&n);\t\t/*for(int j=2;j<=n;j++)\t\t\tif(pr[j]==0||j==4)\t\t\t\tfor(int i=j;i<=n;i+=j){\t\t\t\t\tint val=1ll*(i/j)*(j-1)%j;\t\t\t\t\tif(j==4)\t\t\t\t\t\tval=1ll*(i/j)*2%j;\t\t\t\t\tans=(ans+1ll*val*min(n-i+1,j))%mod;\t\t\t\t}*/\t\tprintf(\"%d\\n\",ans[n]);\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Carousel of Combinations.json"
}