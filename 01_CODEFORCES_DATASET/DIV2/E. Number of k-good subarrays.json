{
    "link": "https://codeforces.com//contest/1982/problem/E",
    "problemId": "2717390",
    "problem_idx": "E",
    "shortId": "1982E",
    "contest_number": "1982",
    "problem_submissions": {
        "F": [
            267371295,
            267368983,
            267386192,
            267383481,
            267392812,
            267381747,
            267380349,
            267448537,
            267389268,
            267391412,
            267465375,
            267464196,
            267398754,
            267397907,
            267394247,
            267400370,
            267398779,
            267402058,
            267403186,
            267394811,
            267400611,
            267395899,
            267401217
        ],
        "E": [
            267356282,
            267356215,
            267370786,
            267372088,
            267363741,
            267371679,
            267383797,
            267376185,
            267367589,
            267367768,
            267377973,
            267379190,
            267379180,
            267375802,
            267376857,
            267377392,
            267370644,
            267387467,
            267382680,
            267383608
        ],
        "D": [
            267346551,
            267374785,
            267348133,
            267346019,
            267349259,
            267353213,
            267344889,
            267351505,
            267357173,
            267352582,
            267348135,
            267356257,
            267354124,
            267361818,
            267348920,
            267361280,
            267376940,
            267358334,
            267368263,
            267363956
        ],
        "C": [
            267340189,
            267360218,
            267340523,
            267338463,
            267344601,
            267345277,
            267337376,
            267446413,
            267343870,
            267348671,
            267345336,
            267334950,
            267349986,
            267345653,
            267351831,
            267339030,
            267352675,
            267359528,
            267350804,
            267359049,
            267348772
        ],
        "B": [
            267337179,
            267335525,
            267333706,
            267334809,
            267331361,
            267341628,
            267345760,
            267336279,
            267343504,
            267333937,
            267331022,
            267335181,
            267340882,
            267340337,
            267334531,
            267343773,
            267346672,
            267347539,
            267353296,
            267342437
        ],
        "A": [
            267328525,
            267326985,
            267328071,
            267327102,
            267327552,
            267328303,
            267347395,
            267326942,
            267331875,
            267328032,
            267327692,
            267327319,
            267328382,
            267327600,
            267327418,
            267330803,
            267331257,
            267327782,
            267348137,
            267328398
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130839",
    "editorial": "Let be a function to solve the problem, which will return three values\r\nsuch that: for the first numbers (i.e. from to ) holds, while or ; for\r\nthe last numbers (i.e. from to ) holds, while or ; the answer for the\r\npair . Let\u00e2\u0080\u0099s use the \"divide and conquer\" approach. Divide the segment\r\nfrom to into two segments: from to , where is the maximum such that ;\r\nfrom to . It can be noticed that instead of calculating the function on\r\nthe segment from to , it is possible to calculate it from to , but with\r\na smaller .More formally, can be recalculated through and .Based on the\r\npair of triples , which is obtained after calculating and , which is\r\nobtained after calculating , it is quite trivial to recalculate the\r\ntriple for using the formula in .However, the solution still works in\r\ntime, as we will have a complete binary tree of recursive calls.To fix\r\nthis, it is only necessary to precalculate all for each possible and .\r\nFor , it can be noticed that it is recalculated through and , so all\r\nvalues can be calculated using dynamic programming.After this, in the\r\nrecursive function, we always calculate in , and for the next call, the\r\nfirst argument is halved, so now everything works in for one test\r\ncase.In total, the solution is in for the test case.\r\n",
    "name": "E. Number of k-good subarrays",
    "statement": "Let bit(x) denote the number of ones in the binary representation of a\r\nnon-negative integer x.A subarray of an array is called if it consists\r\nonly of numbers with no more than k ones in their binary representation,\r\ni.e., a subarray (l, r) of array a is good if for any i such that l\r\nle i\r\nle r condition bit(a_{i})\r\nle k is satisfied.You are given an array a of length n, consisting of\r\nconsecutive non-negative integers starting from 0, i.e., a_{i} = i for 0\r\nle i\r\nle n - 1 (in 0-based indexing). You need to count the number of\r\nsubarrays in this array.As the answer can be very large, output it\r\nmodulo 10^{9} + 7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0#define ar array#define sz(v) int(v.size())typedef long long ll;\u00a0const int BIT=61, MOD=1e9+7;\u00a0struct info {    ll lef=0, rig=0, sz=0, num=0;};info operator+(const info &a, const info &b) {    info c;    c.lef=a.lef==a.sz?a.sz+b.lef:a.lef;    c.rig=b.rig==b.sz?b.sz+a.rig:b.rig;    c.sz=a.sz+b.sz;    c.num=(a.num+b.num+(a.rig%MOD)*(b.lef%MOD))%MOD;    return c;}info dp[BIT][BIT];\u00a0void init() {    for (int k=0; k<BIT; k++) dp[0][k]={1,1,1,1};    for (int b=1; b<BIT; b++) {        for (int k=0; k<BIT; k++) {            dp[b][k]=dp[b-1][k]+(k?dp[b-1][k-1]:info{0,0,1ll<<b,0});        }    }}\u00a0info get(ll n, int k) {    if (k<0) return info{0,0,n,0};    int msb=__lg(n);    ll p=1ll<<msb;    if (n==p) return dp[msb][k];    else return dp[msb][k]+get(n-p,k-1);}\u00a0void solve() {    ll n; int k;    cin>>n>>k;    cout<<get(n,k).num<<'\\n';}\u00a0int main() {    ios::sync_with_stdio(0); cin.tie(0);    init();    int T=1;    cin>>T;    while (T--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "divide and conquer",
        "dp",
        "math",
        "meet-in-the-middle"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Number of k-good subarrays.json"
}