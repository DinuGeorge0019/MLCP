{
    "link": "https://codeforces.com//contest/592/problem/D",
    "problemId": "39718",
    "problem_idx": "D",
    "shortId": "592D",
    "contest_number": "592",
    "problem_submissions": {
        "D": [
            13987439,
            13982159,
            13986627,
            13986544,
            13987382,
            13988819,
            13987375,
            13987118,
            13988148,
            13987147,
            13990565,
            13986857,
            13989994,
            13991007,
            13989203,
            13989734,
            13991375,
            13989244
        ],
        "C": [
            13982269,
            13981200,
            13983408,
            13982994,
            13981714,
            13982661,
            13983184,
            13983906,
            13982447,
            13984910,
            13983829
        ],
        "B": [
            13977841,
            13974476,
            13978321,
            13975713,
            13975313,
            13978246,
            13976302,
            13974264,
            13976441,
            13976404,
            13977709,
            13976428,
            13978061,
            13978476,
            13979510,
            13978971,
            13977780,
            13976576
        ],
        "A": [
            13975304,
            13993400,
            13979938,
            13974321,
            13974175,
            13975291,
            13978651,
            13978273,
            13974604,
            13988437,
            13975687,
            13974467,
            13976335,
            13976275,
            13975414,
            13976741,
            13976354,
            13981732
        ],
        "E": [
            14029966
        ]
    },
    "name": "D. Super M",
    "statement": "Ari the monster is not an ordinary monster. She is the hidden identity\r\nof Super M, the Byteforces superhero. Byteforces is a country that\r\nconsists of cities, connected by bidirectional roads. Every road\r\nconnects exactly two distinct cities, and the whole road system is\r\ndesigned in a way that one is able to go from any city to any other city\r\nusing only the given roads. There are cities being attacked by humans.\r\nSo Ari... we meant Super M have to immediately go to each of the cities\r\nbeing attacked to scare those bad humans. Super M can pass from one city\r\nto another only using the given roads. Moreover, passing through one\r\nroad takes her exactly one kron - the time unit used in Byteforces.\r\nHowever, Super M is not on Byteforces now - she is attending a training\r\ncamp located in a nearby country Codeforces. Fortunately, there is a\r\nspecial device in Codeforces that allows her to instantly teleport from\r\nCodeforces to any city of Byteforces. The way back is too long, so for\r\nthe purpose of this problem teleportation is used exactly once.You are\r\nto help Super M, by calculating the city in which she should teleport at\r\nthe beginning in order to end her job in the minimum time (measured in\r\nkrons). Also, provide her with this time so she can plan her way back to\r\nCodeforces.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define sz(x) ((int) (x).size())\n#define X first\n#define Y second\n#define TRACE(x) cerr << #x << \" : \" << x << endl\n#define _ << \" \" <<\n\n#define MAX (123456 + 100)\nvector <int> adj[MAX];\nint N, M;\nbool mark[MAX];\nvector <int> goals;\n\nint DFS(int u, int par) {\n\tint ret = -1;\n\tif (mark[u]) ret = 0;\n\tfor (int v : adj[u]) if (v != par) {\n\t\tint child = DFS(v, u);\n\t\tif (child != -1) {\n\t\t\tif (ret == -1) ret = child + 2;\n\t\t\telse ret += child + 2;\n\t\t}\n\t}\n\treturn ret;\n}\n\npii getFar(int u, int par, int level) {\n\tpii ret = {-1, 0};\n\tif (mark[u]) ret = {u, level};\n\tfor (int v : adj[u]) if (v != par) {\n\t\tpii child = getFar(v, u, level + 1);\n\t\tif ((ret.X == -1) || (ret.Y < child.Y) || (ret.Y == child.Y && ret.X > child.X)) ret = child;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef _LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tcin >> N >> M;\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u; cin >> u;\n\t\tu--;\n\t\tmark[u] = true;\n\t\tgoals.push_back(u);\n\t}\n\n\tif (M == 1) cout << goals[0] + 1 << endl << 0 << endl;\n\telse {\n\t\tint s = DFS(goals[0], -1);\n\t\t// TRACE(s);\n\t\tpii far_away = getFar(goals[0], -1, 0);\n\t\t// TRACE(far_away.X _ far_away.Y);\n\t\tpii far_far_away = getFar(far_away.X, -1, 0);\n\t\t// TRACE(far_far_away.X _ far_far_away.Y);\n\t\tcout << min(far_away.X, far_far_away.X) + 1 << endl;\n\t\tcout << s - far_far_away.Y << endl;\n\t}\n\n\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Super M.json",
    "editorial_link": "https://codeforces.com//blog/entry/21318",
    "editorial": "Observation 1: Ari should teleport to one of the attacked cities (it doesn't worth going to a city that is not attacked since then she should go to one of the attacked cities)\n\nObservation 2: The nodes visited by Ari will determine a sub-tree T of the original tree, this tree is unique and is determined by all the paths from two attacked cities.\n\n \n\nObservation 3: If Ari had to return to the city from where she started, then the total distance would be 2e, where e is the number of edges of T, that is because she goes through each edge forward and backward\n\nObservation 4: If Ari does not have to return to the starting city (the root of T), then the total distance is 2e?-?L, where L is the distance of the farthest node from the root\n\nObservation 5: In order to get a minimum total distance, Ari should chose one diameter of the tree, and teleport to one of its leaves.\n\nThe problem is now transformed in finding the diameter of a tree that contains the smallest index for one of its leaves. Note that all diameters pass through the center of the tree, so we can find all the farthest nodes from the center...and [details omitted]."
}