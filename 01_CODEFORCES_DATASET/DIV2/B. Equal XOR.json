{
    "link": "https://codeforces.com//contest/1944/problem/B",
    "problemId": "2535050",
    "problem_idx": "B",
    "shortId": "1944B",
    "contest_number": "1944",
    "problem_submissions": {
        "E": [
            251782515,
            251752198,
            251760134,
            251765767,
            251780123,
            251755818,
            251785307,
            251786773,
            251774041,
            251782215,
            251788365,
            251768261,
            251786805,
            251786877
        ],
        "D": [
            251774395,
            251745809,
            251734994,
            251735975,
            251741617,
            251753993,
            251816452,
            251754858,
            251782010,
            251751610,
            251760683,
            251760131,
            251771429,
            251757991,
            251756622,
            251757761,
            251764901,
            251792696,
            251771886,
            251771626
        ],
        "F2": [
            251750838,
            251716813,
            251789175,
            252177387
        ],
        "F1": [
            251747784,
            251709303,
            251789140,
            251765369,
            252064569,
            251778632,
            251783727,
            251776370,
            252190323,
            251778029,
            251787478
        ],
        "C": [
            251727192,
            251748340,
            251720353,
            251717607,
            251744834,
            251719448,
            251721344,
            251728728,
            251723190,
            251722648,
            251720271,
            251715992,
            251711499,
            251727997,
            251722342,
            251754221,
            251727857,
            251727380,
            251734830,
            251734204
        ],
        "B": [
            251714769,
            251743002,
            251717270,
            251713265,
            251751112,
            251715501,
            251712246,
            251715265,
            251717723,
            251714892,
            251714867,
            251712443,
            251720698,
            251717033,
            251737965,
            251714389,
            251717278,
            251719138,
            251727691,
            251724161
        ],
        "A": [
            251705704,
            251744128,
            251703581,
            251703048,
            251747005,
            251704719,
            251705040,
            251701932,
            251706171,
            251701886,
            251705757,
            251701530,
            251704051,
            251712020,
            251711838,
            251705512,
            251702145,
            251704041,
            251711450,
            251703284
        ]
    },
    "name": "B. Equal XOR",
    "statement": "You are given an array a of length 2n, consisting of each integer from 1\r\nto n exactly .You are also given an integer k (1\r\nleq k\r\nleq\r\nlfloor\r\nfrac{n}{2}\r\nrfloor ).You need to find two arrays l and r each of length\r\nmathbf{2k} such that: l is a subset^\r\ndagger of [a_1, a_2,\r\nldots a_n] r is a subset of [a_{n+1}, a_{n+2},\r\nldots a_{2n}] bitwise XOR of elements of l is equal to the bitwise XOR\r\nof elements of r; in other words, l_1\r\noplus l_2\r\noplus\r\nldots\r\noplus l_{2k} = r_1\r\noplus r_2\r\noplus\r\nldots\r\noplus r_{2k} It can be proved that at least one pair of l and r always\r\nexists. If there are multiple solutions, you may output any one of\r\nthem.^\r\ndagger A sequence x is a subset of a sequence y if x can be obtained by\r\ndeleting several (possibly none or all) elements of y and rearranging\r\nthe elements in any order. For example, [3,1,2,1], [1, 2, 3], [1, 1] and\r\n[3, 2] are subsets of [1, 1, 2, 3] but [4] and [2, 2] are not subsets of\r\n[1, 1, 2, 3].\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl '\\n'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nconst int N=1e5+10;\nint n,k,a[N];\nvector<int> p[N];\nvoid work() {\n\tcin>>n>>k; k<<=1;\n\tFor(i,1,n) p[i].clear();\n\tFor(i,1,n*2) cin>>a[i],p[a[i]].push_back(i);\n\tvector<int> f[2];\n\tFor(i,1,n) if((p[i][0]<=n)==(p[i][1]<=n)) {\n\t\tif(f[0].size()+(p[i][0]<=n)+(p[i][1]<=n)<=k)\n\t\t\tif(f[1].size()+(p[i][0]>n)+(p[i][1]>n)<=k) {\n\t\t\t\tf[p[i][0]>n].push_back(p[i][0]);\n\t\t\t\tf[p[i][1]>n].push_back(p[i][1]);\n\t\t\t}\n\t}\n\tFor(i,1,n) if((p[i][0]<=n)!=(p[i][1]<=n)) {\n\t\tif(f[0].size()+(p[i][0]<=n)+(p[i][1]<=n)<=k)\n\t\t\tif(f[1].size()+(p[i][0]>n)+(p[i][1]>n)<=k) {\n\t\t\t\tf[p[i][0]>n].push_back(p[i][0]);\n\t\t\t\tf[p[i][1]>n].push_back(p[i][1]);\n\t\t\t}\n\t}\n\tFor(i,0,1) {\n\t\tfor(auto x:f[i]) cout<<a[x]<<\" \"; cout<<endl;\n\t}\n}\nint main() {\n#ifdef LOCAL\n\tfreopen(\".in\",\"r\",stdin);\n\t// freopen(\".out\",\"w\",stdout);\n\t// freopen(\".debug\",\"w\",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Equal XOR.json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "We can append any 2\n occurrence numbers to our sequence l\n and any 0\n occurrence numbers to our sequence r\n without any issue because the xor value will cancel out. We do this while our sequence sizes are less than 2?k\n. At the end of this process, l\n and r\n will have the same size due to Hint 2\n.\n\nNow, we use as many 1\n occurrence numbers appending to both l\n and r\n as needed. Since we append to both sequences, the xor value of the 2\n sequences will be the same.\n\nIf we had to solve for odd sequence sizes, we could take a 1\n occurrence number at the very start to make it even, and then run the same process, but if there are no 1\n occurrence numbers at all, we fail with this method."
}