{"link": "https://codeforces.com//contest/1075/problem/F", "problemId": "249097", "problem_idx": "F", "shortId": "1075F", "contest_number": "1075", "problem_submissions": {"E": [45299888, 45297843, 45298056, 45296633, 45301081, 45300957, 45302422, 45302929, 45304409, 45302659, 45300790, 45303365, 45303877, 45302733], "F": [45298415, 45299656, 45299363, 45302076, 45302275, 45461749, 45308311], "D": [45294336, 45295894, 45295657, 45296846, 45300767, 45296827, 45297943, 45298533, 45298945, 45296351, 45298646, 45300089, 45299323, 45303594, 45300962, 45300486, 45300898], "C": [45292132, 45292865, 45293959, 45292758, 45292492, 45294033, 45294912, 45294846, 45293224, 45293567, 45294312, 45292544, 45295364, 45296384, 45295997, 45298611, 45297798], "B": [45290077, 45290576, 45289458, 45290287, 45290460, 106466381, 45291592, 45291593, 45291426, 45290169, 45291447, 45291908, 45290506, 45291957, 45290127, 45292064, 45294213, 45290472], "A": [45288469, 45288515, 45288420, 45288453, 45288440, 45288973, 45289044, 45288964, 45288524, 45289234, 45289586, 45288591, 45289499, 45288557, 45289581, 45288705, 45288541]}, "name": "F. Deduction Queries", "statement": "There is an array a of 2^{30} integers, indexed from 0 to 2^{30}-1.\r\nInitially, you know that 0\r\nleq a_i < 2^{30} (0\r\nleq i < 2^{30}), but you do not know any of the values. Your task is to\r\nprocess queries of two types: : You are informed that the of the\r\nsubarray [l, r] (ends inclusive) is equal to x. That is, a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_{r-1}\r\noplus a_r = x, where\r\noplus is the bitwise xor operator. In some cases, the received update\r\ncontradicts past updates. In this case, you should the contradicting\r\nupdate (the current update). : You are asked to output the bitwise xor\r\nof the subarray [l, r] (ends inclusive). If it is still impossible to\r\nknow this value, considering all past updates, then output .Note that\r\nthe queries are . That is, you need to write an solution.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define szv(V) ((int)(V).size())\n#define allv(V) (V).begin(), (V).end()\n#define sortv(V) sort(allv(V))\n#define uniquev(V) (V).erase(unique(allv(V)), (V).end())\n#define compv(V) sortv(V), uniquev(V)\n#define fs first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mod = 1e9 + 7;\nconst ll inf = 4e18 + 5;\n\nll gcd(ll x, ll y) { while (y) x %= y, swap(x, y); return x; }\npll operator+(pll a, pll b) { return pll(a.fs + b.fs, a.se + b.se); }\npll operator-(pll a, pll b) { return pll(a.fs - b.fs, a.se - b.se); }\nll operator*(pll a, pll b) { return a.fs * b.se - a.se * b.fs; }\ntemplate <class T> int sign(T x) { return x < 0 ? -1 : x > 0 ? 1 : 0; }\nint ccw(pll a, pll b, pll c) { return sign((b - a) * (c - b)); }\ntemplate <class T> void setmin(T &x, T y) { if (x > y) x = y; }\ntemplate <class T> void setmax(T &x, T y) { if (x < y) x = y; }\ntemplate <class T> void addval(T &x, T y) { x += y; x %= mod; }\n\nmap<ll, int> mp;\n\nint getIdx(ll x) {\n    auto it = mp.find(x);\n    if (it != mp.end()) return it->se;\n    return -1;\n}\n\nstruct unionfind {\n    vector<int> par;\n    int find(int x) {\n        if (par[x] != x) return par[x] = find(par[x]);\n        return x;\n    }\n    void merge(int x, int y) {\n        par[find(y)] = find(x);\n    }\n} U[31];\n\nint newP(ll x) {\n    int idx = szv(mp);\n    mp[x] = idx;\n    for (int i = 0; i <= 30; i++) U[i].par.push_back(idx);\n    return idx;\n}\n\nvoid query1(int l, int r, int x) {\n    int L1 = getIdx(l * 2ll);\n    int L2 = getIdx(l * 2ll + 1);\n    int R1 = getIdx(r * 2ll + 2);\n    int R2 = getIdx(r * 2ll + 3);\n    if (L1 == -1) L1 = newP(l * 2ll);\n    if (L2 == -1) L2 = newP(l * 2ll + 1);\n    if (R1 == -1) R1 = newP(r * 2ll + 2);\n    if (R2 == -1) R2 = newP(r * 2ll + 3);\n    for (int i = 0; i <= 30; i++) {\n        if ((x >> i) & 1) {\n            U[i].merge(L1, R2);\n            U[i].merge(L2, R1);\n            continue;\n        }\n        U[i].merge(L1, R1);\n        U[i].merge(L2, R2);\n    }\n}\n\nint query2(int l, int r) {\n    int ret = 0;\n    int L = getIdx(l * 2ll);\n    if (L == -1) return -1;\n    int R1 = getIdx(r * 2ll + 2);\n    int R2 = getIdx(r * 2ll + 3);\n    for (int i = 0; i <= 30; i++) {\n        int Lf = U[i].find(L);\n        if (R1 != -1 && U[i].find(R1) == Lf) continue;\n        if (R2 != -1 && U[i].find(R2) == Lf) {\n            ret |= 1 << i;\n            continue;\n        }\n        return -1;\n    }\n    return ret;\n}\n\nint q;\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> q;\n    int last = 0;\n    while (q--) {\n        int T;\n        cin >> T;\n        if (T == 1) {\n            int l, r, x;\n            cin >> l >> r >> x;\n            l ^= last;\n            r ^= last;\n            x ^= last;\n            if (l > r) swap(l, r);\n            int ret = query2(l, r);\n            if (ret != -1 && ret != x) continue;\n            query1(l, r, x);\n        }\n        else {\n            int l, r;\n            cin >> l >> r;\n            l ^= last;\n            r ^= last;\n            if (l > r) swap(l, r);\n            int ret = query2(l, r);\n            cout << ret << '\\n';\n            last = abs(ret);\n        }\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dsu"], "dificulty": "2400", "interactive": false}