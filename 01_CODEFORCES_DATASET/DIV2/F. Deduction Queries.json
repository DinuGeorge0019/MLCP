{
    "link": "https://codeforces.com//contest/1075/problem/F",
    "problemId": "249097",
    "problem_idx": "F",
    "shortId": "1075F",
    "contest_number": "1075",
    "problem_submissions": {
        "E": [
            45299888,
            45297843,
            45298056,
            45296633,
            45301081,
            45300957,
            45302422,
            45302929,
            45304409,
            45302659,
            45300790,
            45303365,
            45303877,
            45302733
        ],
        "F": [
            45298415,
            45299656,
            45299363,
            45302076,
            45302275,
            45461749,
            45308311
        ],
        "D": [
            45294336,
            45295894,
            45295657,
            45296846,
            45300767,
            45296827,
            45297943,
            45298533,
            45298945,
            45296351,
            45298646,
            45300089,
            45299323,
            45303594,
            45300962,
            45300486,
            45300898
        ],
        "C": [
            45292132,
            45292865,
            45293959,
            45292758,
            45292492,
            45294033,
            45294912,
            45294846,
            45293224,
            45293567,
            45294312,
            45292544,
            45295364,
            45296384,
            45295997,
            45298611,
            45297798
        ],
        "B": [
            45290077,
            45290576,
            45289458,
            45290287,
            45290460,
            106466381,
            45291592,
            45291593,
            45291426,
            45290169,
            45291447,
            45291908,
            45290506,
            45291957,
            45290127,
            45292064,
            45294213,
            45290472
        ],
        "A": [
            45288469,
            45288515,
            45288420,
            45288453,
            45288440,
            45288973,
            45289044,
            45288964,
            45288524,
            45289234,
            45289586,
            45288591,
            45289499,
            45288557,
            45289581,
            45288705,
            45288541
        ]
    },
    "name": "F. Deduction Queries",
    "statement": "There is an array a of 2^{30} integers, indexed from 0 to 2^{30}-1.\r\nInitially, you know that 0\r\nleq a_i < 2^{30} (0\r\nleq i < 2^{30}), but you do not know any of the values. Your task is to\r\nprocess queries of two types: : You are informed that the of the\r\nsubarray [l, r] (ends inclusive) is equal to x. That is, a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_{r-1}\r\noplus a_r = x, where\r\noplus is the bitwise xor operator. In some cases, the received update\r\ncontradicts past updates. In this case, you should the contradicting\r\nupdate (the current update). : You are asked to output the bitwise xor\r\nof the subarray [l, r] (ends inclusive). If it is still impossible to\r\nknow this value, considering all past updates, then output .Note that\r\nthe queries are . That is, you need to write an solution.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define szv(V) ((int)(V).size())\n#define allv(V) (V).begin(), (V).end()\n#define sortv(V) sort(allv(V))\n#define uniquev(V) (V).erase(unique(allv(V)), (V).end())\n#define compv(V) sortv(V), uniquev(V)\n#define fs first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mod = 1e9 + 7;\nconst ll inf = 4e18 + 5;\n\nll gcd(ll x, ll y) { while (y) x %= y, swap(x, y); return x; }\npll operator+(pll a, pll b) { return pll(a.fs + b.fs, a.se + b.se); }\npll operator-(pll a, pll b) { return pll(a.fs - b.fs, a.se - b.se); }\nll operator*(pll a, pll b) { return a.fs * b.se - a.se * b.fs; }\ntemplate <class T> int sign(T x) { return x < 0 ? -1 : x > 0 ? 1 : 0; }\nint ccw(pll a, pll b, pll c) { return sign((b - a) * (c - b)); }\ntemplate <class T> void setmin(T &x, T y) { if (x > y) x = y; }\ntemplate <class T> void setmax(T &x, T y) { if (x < y) x = y; }\ntemplate <class T> void addval(T &x, T y) { x += y; x %= mod; }\n\nmap<ll, int> mp;\n\nint getIdx(ll x) {\n    auto it = mp.find(x);\n    if (it != mp.end()) return it->se;\n    return -1;\n}\n\nstruct unionfind {\n    vector<int> par;\n    int find(int x) {\n        if (par[x] != x) return par[x] = find(par[x]);\n        return x;\n    }\n    void merge(int x, int y) {\n        par[find(y)] = find(x);\n    }\n} U[31];\n\nint newP(ll x) {\n    int idx = szv(mp);\n    mp[x] = idx;\n    for (int i = 0; i <= 30; i++) U[i].par.push_back(idx);\n    return idx;\n}\n\nvoid query1(int l, int r, int x) {\n    int L1 = getIdx(l * 2ll);\n    int L2 = getIdx(l * 2ll + 1);\n    int R1 = getIdx(r * 2ll + 2);\n    int R2 = getIdx(r * 2ll + 3);\n    if (L1 == -1) L1 = newP(l * 2ll);\n    if (L2 == -1) L2 = newP(l * 2ll + 1);\n    if (R1 == -1) R1 = newP(r * 2ll + 2);\n    if (R2 == -1) R2 = newP(r * 2ll + 3);\n    for (int i = 0; i <= 30; i++) {\n        if ((x >> i) & 1) {\n            U[i].merge(L1, R2);\n            U[i].merge(L2, R1);\n            continue;\n        }\n        U[i].merge(L1, R1);\n        U[i].merge(L2, R2);\n    }\n}\n\nint query2(int l, int r) {\n    int ret = 0;\n    int L = getIdx(l * 2ll);\n    if (L == -1) return -1;\n    int R1 = getIdx(r * 2ll + 2);\n    int R2 = getIdx(r * 2ll + 3);\n    for (int i = 0; i <= 30; i++) {\n        int Lf = U[i].find(L);\n        if (R1 != -1 && U[i].find(R1) == Lf) continue;\n        if (R2 != -1 && U[i].find(R2) == Lf) {\n            ret |= 1 << i;\n            continue;\n        }\n        return -1;\n    }\n    return ret;\n}\n\nint q;\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> q;\n    int last = 0;\n    while (q--) {\n        int T;\n        cin >> T;\n        if (T == 1) {\n            int l, r, x;\n            cin >> l >> r >> x;\n            l ^= last;\n            r ^= last;\n            x ^= last;\n            if (l > r) swap(l, r);\n            int ret = query2(l, r);\n            if (ret != -1 && ret != x) continue;\n            query1(l, r, x);\n        }\n        else {\n            int l, r;\n            cin >> l >> r;\n            l ^= last;\n            r ^= last;\n            if (l > r) swap(l, r);\n            int ret = query2(l, r);\n            cout << ret << '\\n';\n            last = abs(ret);\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Deduction Queries.json",
    "editorial_link": "https://codeforces.com/blog/entry/62985",
    "editorial": "First, let's learn how to handle information we have not recieved in updates. Let the function W(l,r)\n be equal to the xor of the subarray [l,r]\n. Also, we define W(l,r)=W(r,l)\n.\n\nAssume 3 indicies a?b?c\n. There are 2 rules:\n\nW(a,b)?W(b+1,c)=W(a,c)\n.\nW(a,c)?W(b,c)=W(a,b?1)\n (holds when a<b\n).\nThese rules require a lot of conditions (and also plenty of \u00b1\n 1). We can simplify them greatly: Let's index the borders between cells in our array (there are 230+1\n of them). Now, instead of defining a subarray [l,r]\n by its 2 endpoint cells, we will define a subarray by its 2 endpoint borders. Technically it just means, that we should increase r\n by 1, and then we get the 2 end borders.\n\nFrom now I will assume that our input is given in such a way, that subarrays are defined by their borders (So I will not mention the addition of 1 to r\n). Notice that the function W(l,r)\n is also affected by this.\n\nIf we take a look at our rules again, they boil down to just 1 rule:\n\nW(a,b)?W(b,c)=W(a,c)\n, for any 3 indicies a,b,c\n (a?b?c\n doesn't need to hold now, for instance W(3,5)?W(5,2)=W(3,2)\n).\nThis transformation also shows an observation; Assume every border is a vertex in a graph, and every update W(l,r)=x\n describes an undirected edge between the vertices l,r\n with weight x\n. We let the distance between 2 nodes a,b\n be the xor of edge weights on the path between them. Notice that this distance is equal to W(a,b)\n. In other words, an update adds an edge and a query asks for some distance.\n\nAnother observation is that, we do not care about all the 230+1\n nodes, but only about the ones we recieved in queries and updates. Moreover, their order is irrelevant, so we can do an online mapping of new nodes to the next free indicies. Thus, the number of nodes will be worstcase O(q)\n.\n\nClaim: We can know the answer to some query [l,r]\n, if and only if there exists a path between the nodes l,r\n (they are in the same connected component).\n\n//start spoiler of proof\n\nThere will be some subset of edges we take, to form the xor between nodes l\n and r\n. Assume every vertex has 2 states, on/off. Initially all vertices are off, and our current answer is 0\n. When we take an edge we flip the state of its 2 ends, and xor our answer by its weight. Suppose at some moment of time the nodes with \"on\" state are {x0,x1,x2,...,xk\n} (in sorted order). Observe that our current answer is equal to W(x0,x1)?W(x2,x3)?\u0085?W(xk?1,xk)\n. This implies we want our subset of edges to end up having only the nodes {l,r\n} activated. We look at the connected components. Observe that in each connected component, the number of nodes activated at any time is even. If the nodes l\n and r\n are in different component, then in our final result we would want to have only 1 activated node in the component of l\n, and same with r\n, but this is impossible.\n\n//end spoiler of proof\n\nFirst, we need to know whether a query gives us 2 nodes that are in different components (to know whether the answer is ?1\n or not). For this we need to use the Union-Find structure. Also notice, that our Union-Find structure will only need to handle a forest of trees (if an update gives us an edge that creates a cycle, it means there is no contribution, so we ignore it).\n\nProvided that an answer does exist, we need to also handle finding a xor path between 2 nodes in a tree, and to support merging of trees. Generally to find a property over some path in a tree, it is common to use LCA or binary lifting. This turns out very difficult when we also need to merge trees (unless you insist on implementing Link-Cut/ETT). Fortunately, we can still abuse the xor operator. In some tree, mark xv\n as the xor of edges on the path from v\n to some arbitrary root in the tree. The xor path between nodes (u,v\n) turns out to be xu?xv\n. So we would like to maintain for each tree some arbitrary root and all those values.\n\nNotice that we can augment our Union-Find structure to support this as well: For each node v\n in the structure, we maintain pv\n as its parent in the structure, and xv\n as the xor on the path from v\n to pv\n. Notice that xv\n can be easily updated together with pv\n during the find()\n operation in the structure.\n\nTo summarize, when we are given W(l,r)=x\n in some update, we transform it to W(pl,pr)=x?xl?xr\n, and then we add the edge between the parents.\n\nFinally, the complexity is O(qlogq)\n, but this is only due to the online mapping if we use a regular map; You can use a hash table and get a running time of O(q\u00d7?(q))\n, but I suggest being careful with a hash table (you may want to read this:"
}