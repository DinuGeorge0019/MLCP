{
    "link": "https://codeforces.com//contest/1248/problem/D1",
    "problemId": "445481",
    "problem_idx": "D1",
    "shortId": "1248D1",
    "contest_number": "1248",
    "problem_submissions": {
        "D1": [
            62994883,
            62993569,
            62992994,
            62997000,
            62994405,
            62997123,
            62999879,
            62995062,
            63003271,
            63000150,
            62999671,
            62994350,
            62998586,
            63000530,
            62992886,
            63075982,
            63072868,
            62991824,
            63006771
        ],
        "F": [
            62993845,
            62998618,
            63004376,
            63001516,
            63005145,
            63007254,
            63006725,
            63065814,
            63007421,
            63002656,
            63007898,
            63005627,
            63007696,
            63008967,
            63006462,
            63004460,
            63011504,
            63004125,
            63006964
        ],
        "E": [
            62985708,
            63073739,
            63003347,
            63018519,
            63004851
        ],
        "B": [
            62982231,
            62980110,
            62981055,
            62979292,
            62979961,
            62980992,
            62979799,
            62981220,
            62982692,
            62978096,
            62982064,
            62982362,
            62978497,
            62981072,
            62981976,
            62984594,
            63075956,
            62980955,
            62980611,
            62983563,
            62990769
        ],
        "A": [
            62979317,
            62977969,
            62978225,
            62977588,
            62977692,
            62977600,
            62977679,
            62978301,
            62980908,
            62977684,
            62981014,
            62982770,
            62977469,
            62977721,
            62977859,
            62979794,
            63075933,
            62977868,
            62980509,
            62980376,
            62988720
        ],
        "C": [
            62977501,
            62984679,
            62987113,
            62992373,
            62990888,
            62990326,
            62991798,
            62987434,
            62987346,
            62987305,
            62995225,
            62994509,
            63000614,
            62991483,
            62996125,
            63009114,
            62993964,
            62985766,
            62994340,
            62987126
        ],
        "D2": [
            63072452,
            63005552
        ]
    },
    "name": "D1. The World Is Just a Programming Task  Easy Version ",
    "statement": "This is an easier version of the problem. In this version, n\r\nle 500.Vasya is an experienced developer of programming competitions\u2019\r\nproblems. As all great minds at some time, Vasya faced a creative\r\ncrisis. To improve the situation, Petya gifted him a string consisting\r\nof opening and closing brackets only. Petya believes, that the beauty of\r\nthe bracket string is a number of its cyclical shifts, which form a\r\ncorrect bracket sequence.To digress from his problems, Vasya decided to\r\nselect two positions of the string () and swap characters located at\r\nthis positions with each other. Vasya will apply this operation exactly\r\nonce. He is curious what is the maximum possible beauty he can achieve\r\nthis way. Please help him.We remind that bracket sequence s is called\r\ncorrect if: s is empty; s is equal to \"t\", where t is correct bracket\r\nsequence; s is equal to t_1 t_2, i.e. concatenation of t_1 and t_2,\r\nwhere t_1 and t_2 are correct bracket sequences. For example, \"\", \"\" are\r\ncorrect, while \"\" and \"\" are not.The cyclical shift of the string s of\r\nlength n by k (0\r\nleq k < n) is a string formed by a concatenation of the last k symbols\r\nof the string s with the first n - k symbols of string s. For example,\r\nthe cyclical shift of string \"\" by 2 equals \"\".Cyclical shifts i and j\r\nare considered different, if i\r\nne j.\r\n",
    "solutions": [
        "// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,no-stack-protector\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n \n#include <bits/stdc++.h>\n \n#define debug(x) std::cerr << (#x) << \":\\t\" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n \ntypedef long long ll;\ntypedef long double ld;\n \nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n \nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 1 << 19;\n \nint n;\nchar str[N];\nint bal[N];\nint q[N];\n \nint getAns() {\n\tfor (int i = 0; i <= 3 * n; ++i) {\n\t\tbal[i] = 0;\n\t\tq[i] = 0;\n\t}\n \n\t// std::map<int, int> q;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tbal[i + 1] += bal[i];\n \n\t\tif (str[i] == '(') {\n\t\t\t++bal[i + 1];\n\t\t} else {\n\t\t\t--bal[i + 1];\n\t\t}\n\t}\n \n\tif (bal[0] != bal[n]) {\n\t\treturn 0;\n\t}\n \n\tfor (int i = 0; i < n; ++i) {\n\t\t++q[bal[i] + n];\n\t}\n \n \tfor (int i = 0; i < N; ++i) {\n \t\tif (q[i] != 0) {\n \t\t\treturn q[i];\n \t\t}\n \t}\n\n \tthrow 228;\n\t// return q.begin()->second;\n}\n \nint main(void) {\n\tscanf(\"%d\\n%s\", &n, str);\n \n\tint ans = getAns();\n\tint fi = 0;\n\tint se = 0;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (str[i] != str[j]) {\n\t\t\t\tstd::swap(str[i], str[j]);\n \n\t\t\t\tint curAns = getAns();\n\t\t\t\tif (curAns > ans) {\n\t\t\t\t\tans = curAns;\n\t\t\t\t\tfi = i;\n\t\t\t\t\tse = j;\n\t\t\t\t}\n \n\t\t\t\tstd::swap(str[i], str[j]);\n\t\t\t}\n\t\t}\n\t}\t\n \n\tprintf(\"%d\\n%d %d\\n\", ans, fi + 1, se + 1);\n \n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. The World Is Just a Programming Task  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/70720",
    "editorial": "Note first that the number of opening brackets must be equal to the\r\nnumber of closing brackets, otherwise the answer is always . Note that\r\nthe answer to the question about the number of cyclic shifts, which are\r\ncorrect bracket sequences, equals the number of minimal prefix balances.\r\nFor example, for string , the array of prefix balances is , and the\r\nnumber of cyclic shifts, the number of minimums in it (). Now we have a\r\nsolution of complexuty : let\u00e2\u0080\u0099s iterate over all pairs of symbols that\r\ncan be swapped. Let\u00e2\u0080\u0099s do this and find the number of cyclic shifts that\r\nare correct bracket sequences according to the algorithm described\r\nabove.\r\n"
}