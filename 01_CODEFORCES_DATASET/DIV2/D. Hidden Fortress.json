{"link": "https://codeforces.com//contest/1600/problem/D", "problemId": "1136952", "problem_idx": "D", "shortId": "1600D", "contest_number": "1600", "problem_submissions": {"D": [131326791, 131319774, 131349265, 131313616, 131318416, 131323729], "F": [131320345, 131329426, 131350388], "E": [131316574, 131313861, 131305576, 131310151, 131314773], "I": [131312786, 131309903, 131307758, 131305198, 131310781], "A": [131307398], "J": [131302886, 131305362, 131303377, 131303391, 131305512], "B": [], "C": []}, "name": "D. Hidden Fortress", "statement": "As part of your contribution in the Great Bubble War, you have been\r\ntasked with finding the newly built enemy fortress. The world you live\r\nin is a giant 10^9\r\ntimes 10^9 grid, with squares having both coordinates between 1 and\r\n10^9. You know that the enemy base has the shape of a rectangle, with\r\nthe sides parallel to the sides of the grid. The people of your world\r\nare extremely scared of being at the edge of the world, so you know that\r\nthe base doesn\u2019t contain any of the squares on the edges of the grid\r\n(the x or y coordinate being 1 or 10^9). To help you locate the base,\r\nyou have been given a device that you can place in any square of the\r\ngrid, and it will tell you the manhattan distance to the closest square\r\nof the base. The manhattan distance from square (a, b) to square (p, q)\r\nis calculated as |a p|+|b q|. If you try to place the device inside the\r\nenemy base, you will be captured by the enemy. Because of this, .\r\nUnfortunately, the device is powered by a battery and you can\u2019t recharge\r\nit. This means that you can use the device at most 40 times.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\nint sx1 = 999999999;\nint sy1 = 999999999;\nint sx2 = 999999999;\nint sy2 = 999999999;\n\nlong long ask(int u, int v) {\n  cout << \"? \" << u << \" \" << v << endl;\n  long long answer;\n  cin >> answer;\n  \n  // if (u < sx1) {\n  //   if (v < sy1) answer = abs(sx1 - u) + abs(sy1 - v);\n  //   else if (v > sy2) answer = abs(sx1 - u) + abs(sy2 - v);\n  //   else answer = abs(sx1 - u);\n  // } else if (u > sx2) {\n  //   if (v < sy1) answer = abs(sx2 - u) + abs(sy1 - v);\n  //   else if (v > sy2) answer = abs(sx2 - u) + abs(sy2 - v);\n  //   else answer = abs(sx2 - u);\n  // } else {\n  //   if (sx1 <= u && u <= sx2 && sy1 <= v && v <= sy2) exit(1);\n\n  //   if (sx1 <= u && u <= sx2) answer = min(abs(v - sy1), abs(v - sy2));\n  //   if (sy1 <= v && v <= sy2) answer = min(abs(u - sx1), abs(u - sx2));\n  // }\n  // cerr << answer << endl;\n  return answer;\n}\n\nvoid answer(int x1, int y1, int x2, int y2) {\n  cout << \"! \" << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n  exit(0);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int x1, y1, x2, y2;\n\n    long long n = (int)1e9;\n\n    long long dist11 = ask(1, 1);\n    long long dist1n = ask(1, n);\n\n    long long A = dist11 + 2 - 1;\n    long long B = 1 - ((1 - n) + dist1n);\n    long long C = (A+B)/2;\n    debug(A, B, C);\n\n    long long dist = ask(1, C);\n    x1 = 1 + dist;\n    dist = ask(n, C);\n    x2 = n - dist;\n\n    C = (x1 + x2) / 2;\n    y1 = ask(C, 1) + 1;\n    y2 = n - ask(C, n);\n    answer(x1, y1, x2, y2);\n   \n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "geometry", "interactive"], "dificulty": "2100", "interactive": false}