{
    "link": "https://codeforces.com//contest/490/problem/E",
    "problemId": "17899",
    "problem_idx": "E",
    "shortId": "490E",
    "contest_number": "490",
    "problem_submissions": {
        "F": [
            8817515,
            8819985,
            8842361,
            8817338,
            8817935,
            8817635,
            8855350,
            8819845,
            8823757,
            8823458,
            8821739,
            8820145
        ],
        "E": [
            8815308,
            8814782,
            8815162,
            8819489,
            8815467,
            8822097,
            8817785,
            8817507,
            8817956,
            8818730,
            8821845,
            8820184,
            8819671,
            8820855,
            8817217,
            8822605,
            8820689
        ],
        "D": [
            8813861,
            8818202,
            8817853,
            8814442,
            8820510,
            8816678,
            8814870,
            8815149,
            8814552,
            8815859,
            8816515,
            8814018,
            8816647,
            8817008,
            8816236,
            8820552,
            8814405,
            8814971,
            8817626,
            8817113
        ],
        "C": [
            8812444,
            8815662,
            8813217,
            8812979,
            8814331,
            8811719,
            8813130,
            8812621,
            8821924,
            8813827,
            8814389,
            8812560,
            8812032,
            8814787,
            8814945,
            8814699,
            8813034,
            8813032,
            8813495,
            8815850
        ],
        "B": [
            8811804,
            8812050,
            8811800,
            8811893,
            8812411,
            8813404,
            8812022,
            8811615,
            8813128,
            8812542,
            8812723,
            8811783,
            8814873,
            8813230,
            8813299,
            8812788,
            8811816,
            8811980,
            8812324,
            8813904
        ],
        "A": [
            8810238,
            8810285,
            8810322,
            8810378,
            8810319,
            8812020,
            8810257,
            8810233,
            8811808,
            8810284,
            8810467,
            8810179,
            8810618,
            8811059,
            8810734,
            8811110,
            8810293,
            8810358,
            8810190,
            8811062
        ]
    },
    "name": "E. Restoring Increasing Sequence",
    "statement": "Peter wrote on the board a strictly increasing sequence of positive\r\nintegers . Then Vasil replaced some digits in the numbers of this\r\nsequence by question marks. Thus, each question mark corresponds to\r\nexactly one lost digit.Restore the the original sequence knowing digits\r\nremaining on the board.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, f[100001][11], pos[100001], len[100001];\nchar str[100001][11], ans[100001][11];\nbool b[100001][11];\n\nint main(){\n     //freopen(\"e.in\", \"r\", stdin);\n     //freopen(\"e.out\", \"w\", stdout);\n     scanf(\"%d\", &n);\n     for (int i = 1; i <= n; i++) \n     {\n          scanf(\"%s\", str[i] + 1);\n          pos[i] = 0; len[i] = strlen(str[i] + 1);\n     }\n     for (int j = 1; j <= len[1]; j++)\n          if (str[1][j] == '?')\n               if (j == 1) ans[1][j] = '1';\n               else ans[1][j] = '0';\n          else ans[1][j] = str[1][j];\n     bool ok = true;\n     for (int i = 2; i <= n; i++)\n     {\n          if (len[i] < len[i - 1])\n          {\n               ok = false;\n               break;\n          }\n          else\n          if (len[i] > len[i - 1])\n          {\n               for (int j = 1; j <= len[i]; j++)\n                    if (str[i][j] == '?')\n                         if (j == 1) ans[i][j] = '1';\n                         else ans[i][j] = '0';\n                    else ans[i][j] = str[i][j];\n          }\n          else\n          {\n               bool status = true, big = false;\n               for (int j = 1; j <= len[i] && status; j++)\n                    if (str[i][j] != '?')\n                    {\n                         if (!big && str[i][j] < ans[i - 1][j])\n                              status = false;\n                         else \n                         {\n                              ans[i][j] = str[i][j];\n                              if (str[i][j] > ans[i - 1][j]) big = true;\n                         }\n                    }\n                    else\n                    {\n                         char now[11];\n                         for (int k = 1; k < j; k++) now[k] = ans[i][k];\n                         int up = 0; if (j == 1) up = 1;\n                         bool find = false;\n                         for (int k = up; k < 10 && !find; ++k)\n                         {\n                              now[j] = k + '0';\n                              for (int l = j + 1; l <= len[i]; l++)\n                                   if (str[i][l] == '?') now[l] = '9';\n                                   else now[l] = str[i][l];\n                              bool r = false;\n                              for (int e = 1; e <= len[i]; e++)\n                                   if (now[e] > ans[i - 1][e]) \n                                   {\n                                        r = true;\n                                        break;\n                                   }\n                                   else\n                                   if (now[e] < ans[i - 1][e]) \n                                   {\n                                        r = false;\n                                        break;\n                                   }\n                              if (r) \n                              {\n                                   find = true, ans[i][j] = now[j];\n                                   if (ans[i][j] > ans[i - 1][j]) big = true;\n                              }\n                         }\n                         if (!find) status = false;\n                    }\n               if (!status || !big) \n               {\n                    ok = false;\n                    break;\n               }\n          }\n     }\n     if (!ok) printf(\"NO\\n\");\n     else\n     {\n          printf(\"YES\\n\");\n          for (int i = 1; i <= n; i++)\n          {\n               for (int j = 1; j <= len[i]; j++) printf(\"%c\", ans[i][j]);\n               printf(\"\\n\");\n          }\n     }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Restoring Increasing Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/14849",
    "editorial": "Let s iterate on specified numbers and try to make from current number\r\nminimal possible, which value more than value of previous number. Let s\r\ncurrent number is , previous number is . If length of number less than\r\nlength of number let s print , this problem has not solution. If length\r\nof number more than length of number replace all signs in number to\r\ndigit , except case, when sign in first position replace him on digit ,\r\nbecause numbers in answer must be without leading zeroes. Another case\r\nwhen lengths of numbers and are equal. Let s iterate on positions , in\r\nwhich prefix number more than prefix of number . Now we need to try for\r\nthis position make minimal possible number, which more than . In all\r\npositions , which less than , replace all on . In all positions , which\r\nmore than , replace all on digit . If than make . If received number\r\nless or equal to this position is bad. From all good positions choose\r\nminimal number, received with operations above and assign him number and\r\nwill continue iteration. If count of such positions is we need to print\r\n.\r\n"
}