{
    "link": "https://codeforces.com//contest/812/problem/E",
    "problemId": "108006",
    "problem_idx": "E",
    "shortId": "812E",
    "contest_number": "812",
    "problem_submissions": {
        "E": [
            27494142,
            27491477,
            27493766,
            27515655,
            27496725,
            27495067,
            27497471,
            27496279,
            27497446,
            27497581,
            27499309,
            27499707,
            27489928,
            27498644,
            27502197,
            27500634,
            27499517,
            27499414,
            27502641,
            27500094,
            27500259
        ],
        "B": [
            27491993,
            27495156,
            27497709,
            27512953,
            27489354,
            27496857,
            27494139,
            27493311,
            27490608,
            27494150,
            27488730,
            27492610,
            27500920,
            27493253,
            27490411,
            27496233,
            27491317,
            27491574,
            27492471,
            27492075,
            27490349
        ],
        "C": [
            27490421,
            27492136,
            27488817,
            27489120,
            27487355,
            27489159,
            27489035,
            27492785,
            27488367,
            27489931,
            27490104,
            27498191,
            27489300,
            27492185,
            27489814,
            27490763,
            27493690,
            27489337,
            27493758,
            27491206
        ],
        "A": [
            27487305,
            27493249,
            27495525,
            27491891,
            27490175,
            27487261,
            27487056,
            27487516,
            27499547,
            27493817,
            27487154,
            27503033,
            27487455,
            27486987,
            27488643,
            27487109,
            27486628,
            27487274,
            27487808,
            27486790
        ],
        "D": [
            27503386,
            27512794,
            27534240,
            27564141,
            27521512
        ]
    },
    "name": "E. Sagheer and Apple Tree",
    "statement": "Sagheer is playing a game with his best friend Soliman. He brought a\r\ntree with nodes numbered from to and rooted at node . The -th node has\r\napples. This tree has a special property: the lengths of all paths from\r\nthe root to any leaf have the same parity (i.e. all paths have even\r\nlength or all paths have odd length).Sagheer and Soliman will take turns\r\nto play. Soliman will make the first move. The player who can\u2019t make a\r\nmove loses.In each move, the current player will pick a single node,\r\ntake a non-empty subset of apples from it and do one of the following\r\ntwo things: eat the apples, if the node is a leaf. move the apples to\r\none of the children, if the node is non-leaf. Before Soliman comes to\r\nstart playing, Sagheer will make to the tree. He will pick two different\r\nnodes and and swap the apples of with the apples of .Can you help\r\nSagheer count the number of ways to make the swap (i.e. to choose and )\r\nafter which he will win the game if both players play optimally? and are\r\nconsidered to be the same pair.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#if __cplusplus >= 201103L\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#include <vector>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define FOR(i,a,b) for(int i=a;i<(b);i++)\n#define FORN(i,b) for(int i=0;i<(b);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vii;\n\nint n,a[100005],t;\nvi g[100005];\nint d[100005];\nmap<int,int> c;\n\nvoid dfs(int x, int dd){\n\td[x]=dd;\n\tfor(int y:g[x])dfs(y,dd^1);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tFORN(i,n)scanf(\"%d\",a+i);\n\tFOR(i,1,n){\n\t\tint p;\n\t\tscanf(\"%d\",&p);p--;\n\t\tg[p].pb(i);\n\t}\n\tdfs(0,0);\n\tbool asd=false;\n\tFORN(i,n)if(!g[i].size()&&!d[i]){asd=true;break;}\n\tif(asd)FORN(i,n)d[i]^=1;\n\tFORN(i,n)if(d[i])t^=a[i];\n\tll r=0;\n\tif(t==0){\n\t\tint q[2];\n\t\tq[0]=q[1]=0;\n\t\tFORN(i,n)q[d[i]]++;\n\t\tr+=1LL*q[0]*(q[0]-1)/2;\n\t\tr+=1LL*q[1]*(q[1]-1)/2;\n\t}\n\tFORN(i,n)if(!d[i])c[a[i]]++;\n\tFORN(i,n)if(d[i])r+=c[t^a[i]];\n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sagheer and Apple Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/52318",
    "editorial": "In the standard nim game, we xor the values of all piles, and if the xor\r\nvalue is , then the first player loses. Otherwise, he has a winning\r\nstrategy. One variant of the nim game has an extra move that allows\r\nplayers to add positive number of stones to a single pile (given some\r\nconditions to make the game finite). The solution for this variant is\r\nsimilar to the standard nim game because this extra move will be used by\r\nthe winning player, and whenever the losing player does it, the winning\r\nplayer can cancel it by throwing away these added stones. This problem\r\ncan be modeled as the mentioned variant. Lets color leaf nodes with\r\nblue. The parent of a blue node is red and the parent of a red node is\r\nblue (that s why all paths from root to leaves must have the same\r\nparity). Blue nodes are our piles while red nodes allow discarding\r\napples or increasing piles. If the xor value of blue nodes , then\r\nSoliman loses on the initial tree. To keep this state after the swap,\r\nSagheer can: swap any two blue nodes or any two red nodes. swap a blue\r\nnode with a red node if they have the same number of apples. If the xor\r\nvalue of blue nodes , then Sagheer loses on the initial tree. To flip\r\nthis state after the swap, Sagheer must swap a blue node with a red node\r\nsuch that Complexity: where is the maximum value for apples in a single\r\nnode. Implementation You can read more about games from this link\r\n"
}