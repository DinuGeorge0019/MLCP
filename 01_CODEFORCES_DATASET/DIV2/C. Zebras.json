{
    "link": "https://codeforces.com//contest/950/problem/C",
    "problemId": "163624",
    "problem_idx": "C",
    "shortId": "950C",
    "contest_number": "950",
    "problem_submissions": {
        "F": [
            36110799,
            36106874,
            36110418,
            36111996,
            36110842,
            36112881,
            36112066,
            36111037,
            36115685,
            36107783,
            36111061,
            36110969
        ],
        "E": [
            36106600,
            36110576,
            36107020,
            36108185,
            36105421,
            36110602,
            36104100,
            36112036,
            36103180,
            36119591,
            36103520,
            36104391,
            36111839,
            36104803,
            36105285,
            36106153,
            36105692,
            36107917,
            36133513,
            36106022
        ],
        "D": [
            36099255,
            36103207,
            36103975,
            36101168,
            36099422,
            36104316,
            36100451,
            36105727,
            36100010,
            36100957,
            36098808,
            36101447,
            36108972,
            36101180,
            36100807,
            36101948,
            36101824,
            36102198,
            36099705,
            36115114,
            36103338
        ],
        "B": [
            36097037,
            36093570,
            36096763,
            36102283,
            36107341,
            36096070,
            36118539,
            36103628,
            36098191,
            36093324,
            36097654,
            36092909,
            36097186,
            36093092,
            36094178,
            36093761,
            36093826,
            36092324,
            36094422,
            36093177
        ],
        "C": [
            36095719,
            36096428,
            36100419,
            36099281,
            36103315,
            36101716,
            36094357,
            36100382,
            36094934,
            36098794,
            36096378,
            36098545,
            36106922,
            36096674,
            36097941,
            36096847,
            36097394,
            36095627,
            36097024,
            36097344
        ],
        "A": [
            36091256,
            36091581,
            36094574,
            36100244,
            36107668,
            36091536,
            36095298,
            36101664,
            36095785,
            36091314,
            36098215,
            36091291,
            36093398,
            36091393,
            36091803,
            36091568,
            36091610,
            36091266,
            36092123,
            36091364
        ]
    },
    "name": "C. Zebras",
    "statement": "Oleg writes down the history of the days he lived. For each day he\r\ndecides if it was good or bad. Oleg calls a non-empty sequence of days a\r\n, if it starts with a bad day, ends with a bad day, and good and bad\r\ndays are alternating in it. Let us denote bad days as and good days as .\r\nThen, for example, sequences of days , , are zebras, while sequences , ,\r\nare not.Oleg tells you the story of days he lived in chronological order\r\nin form of string consisting of and . Now you are interested if it is\r\npossible to divide Oleg\u2019s life history into several , each of which is a\r\nzebra, and the way it can be done. Each day must belong to exactly one\r\nof the subsequences. For each of the subsequences, days forming it must\r\nbe ordered chronologically. Note that subsequence does not have to be a\r\ngroup of consecutive days.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\nchar s[N];\nint le[N],ri[N],n,u,cnt;\nvector<int> vec[N],z0,z1;\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tif(!z0.size()){\n\t\t\t\tputs(\"-1\");return 0;\n\t\t\t}\n\t\t\tint t=z0.back();z0.pop_back();\n\t\t\tvec[t].push_back(i);z1.push_back(t);\n\t\t}else{\n\t\t\tif(!z1.size()){\n\t\t\t\tz0.push_back(i);vec[i].push_back(i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint t=z1.back();z1.pop_back();\n\t\t\t\tvec[t].push_back(i);z0.push_back(t);\n\t\t\t}\n\t\t}\n\t}\n\tif(z1.size()){\n\t\tputs(\"-1\");return 0;\n\t}\n\tprintf(\"%u\\n\",z0.size());\n\tfor(int i=0;i<z0.size();i++){\n\t\tprintf(\"%u\",vec[z0[i]].size());\n\t\tfor(int j=0;j<vec[z0[i]].size();j++){\n\t\t\tprintf(\" %d\",vec[z0[i]][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Zebras.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Simple greedy works here. Let's go from left to right and assign each element to some subsequence. At each moment we have two types of already built subsequences: zebras (\"0\", \"010\", \"01010\", ...) and \"almost zebras\" (\"01\", \"0101\", \"010101\"). If next element of the string is '1' we should add it to some zebra making it \"almost zebra\". If there are no zebras at this moment it's impossible to divide string into zebra subsequences. If next element of the string is '0' we should add it so some \"almost zebra\" making it simple zebra. If there are no \"almost zebra\"'s now just create new zebra consisting of this '0'.\n\nIf there are no \"almost zebra\"'s at the end answer exists and built zebras satisfy all requirements otherwise there is no answer."
}