{"link": "https://codeforces.com//contest/1855/problem/F", "problemId": "2119330", "problem_idx": "F", "shortId": "1855F", "contest_number": "1855", "problem_submissions": {"D": [216333466, 216282930, 216304321, 216288702, 216315573, 216283245, 216277730, 216313898, 216306202, 216314199, 216313213, 216292626, 216312027, 216805668, 216805337, 216315274, 216317158, 216319074, 216320064, 216332564, 216313414], "C1": [216327527, 216265798, 216278749, 216252157, 216263595, 216261550, 216296642, 216259910, 216265017, 216265900, 216266262, 216246799, 216254795, 216264575, 216271415, 216266184, 216256689, 216266334, 216273339, 216281116], "C2": [216327433, 216333169, 216278334, 216276389, 216290961, 216261266, 216308671, 216288782, 216279381, 216300131, 216292122, 216299685, 216284770, 216286877, 216294260, 216296589, 216302878, 216296848, 216273167, 216291700], "B": [216319187, 216239575, 216251320, 216239516, 216251539, 216242319, 216247221, 216244993, 216252246, 216251732, 216255891, 216249364, 216243332, 216244237, 216260716, 216245518, 216240380, 216281460, 216248098, 216245806], "A": [216318294, 216235675, 216247364, 216235951, 216238094, 216238019, 216237152, 216237362, 216248778, 216237335, 216241402, 216238578, 216237824, 216238112, 216254438, 216237599, 216236030, 216240134, 216239210, 216238506], "E": [216307488, 216320937, 216323420, 216339638, 216487251, 216321175, 216593212, 216352369], "F": [216295921, 216331597, 216627506]}, "name": "F. Michael and Hotel", "statement": "Michael and Brian are stuck in a hotel with n rooms, numbered from 1 to\r\nn, and need to find each other. But this hotel\u2019s doors are all locked\r\nand the only way of getting around is by using the teleporters in each\r\nroom. Room i has a teleporter that will take you to room a_i (it might\r\nbe that a_i = i). But they don\u2019t know the values of a_1,a_2,\r\ndots, a_n.Instead, they can call up the front desk to ask queries. In\r\none query, they give a room u, a positive integer k, and a set of rooms\r\nS. The hotel concierge answers whether a person starting in room u, and\r\nusing the teleporters k times, ends up in a room in S.Brian is in\r\nroom 1. Michael wants to know the set A of rooms so that if he starts in\r\none of those rooms they can use the teleporters to meet up. He can ask\r\nat most 2000 queries.The values a_1, a_2,\r\ndots, a_n are fixed before the start of the interaction and do not\r\ndepend on your queries. In other words, the interactor is not adaptive.\r\n", "solutions": ["#pragma GCC optimize(3)\n// #pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int N=1000007;\nconst int INF=1e9;\nconst int mod=998244353;\nconst double pi=acos(-1);\nmt19937_64 rng(time(NULL));\n \nint n;\nbool vis[N];\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int rem=2000;\n  cin>>n;\n  auto query=[&](int u,int k,vector<int>& lst){\n    rem--;\n    cout<<\"? \"<<u<<\" \"<<k<<\" \";\n    cout<<sz(lst)<<\" \";\n    for (auto c:lst) cout<<c<<\" \";\n    cout<<endl;\n    int ret;\n    cin>>ret;\n    return ret;\n  };\n  auto check_nxt=[&](int u,int k){\n    int L=1, R=n;\n    while (L<R){\n      int md=(L+R)>>1;\n      vector<int> lst;\n      for (int i=L;i<=md;++i) lst.push_back(i);\n      if (query(u,k,lst)) R=md;\n      else L=md+1; \n    }\n    return L;\n  };\n  int ed=check_nxt(1,INF);\n  vector<int> fuck;\n  fuck.push_back(ed);\n  vector<int> llst;\n  llst.push_back(ed);\n  int now=ed;\n  for (int i=1;i<=100;++i){\n    now=check_nxt(now,3);\n    if (now==ed) break;\n    llst.push_back(now);\n  }\n  for (auto c:llst) vis[c]=1;\n  for (int _=1;_<=1;++_){\n    for (int i=1;i<=n;++i){\n      if (vis[i]) continue;\n      if (rem<=n-sz(llst)) continue;\n      int rd=rng()%INF+1;\n      auto ret=query(i,1,llst);\n      if (ret) llst.push_back(i), vis[i]=1;\n    }\n  }\n  for (int _=1;_<=2000;++_){\n    for (int i=1;i<=n;++i){\n      if (vis[i]) continue;\n      if (rem<=n-sz(llst)) continue;\n      int rd=rng()%INF+1;\n      auto ret=query(i,rd,llst);\n      if (ret) llst.push_back(i), vis[i]=1;\n    }\n  }\n  for (int i=1;i<=n;++i){\n    if (vis[i]) continue;\n    if (query(i,INF,llst)) llst.push_back(i);\n  }\n  cout<<\"! \"<<sz(llst)<<\" \";\n  for (auto c:llst) cout<<c<<\" \";\n}  "], "input": "", "output": "", "tags": ["binary search", "interactive"], "dificulty": "3000", "interactive": false}