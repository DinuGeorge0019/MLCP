{
    "link": "https://codeforces.com//contest/861/problem/C",
    "problemId": "122871",
    "problem_idx": "C",
    "shortId": "861C",
    "contest_number": "861",
    "problem_submissions": {
        "B": [
            30441262,
            30424376,
            30427161,
            30427960,
            30424359,
            30424926,
            30425840,
            30430094,
            30424319,
            30428309,
            30428624,
            30440366,
            30437511,
            30435804,
            30427921,
            30432832,
            30423882
        ],
        "F": [
            30440095,
            30439628,
            30440266,
            30439498,
            30441670,
            30441500,
            30452319,
            30437084
        ],
        "E": [
            30436514,
            30436701,
            30441404,
            30443472,
            30442827,
            30445184,
            30445314,
            30443353,
            30443911
        ],
        "D": [
            30428168,
            30427382,
            30423887,
            30433533,
            30430871,
            30432293,
            30434646,
            30433520,
            30433941,
            30433630,
            30434459,
            30436865,
            30433644,
            30426019,
            30432738,
            30434925,
            30433542,
            30432317,
            30434703
        ],
        "A": [
            30424689,
            30422095,
            30427679,
            30422354,
            30422107,
            30422516,
            30422863,
            30426215,
            30422101,
            30424813,
            30422256,
            30425576,
            30489148,
            30430836,
            30422849,
            30423019,
            30422141,
            30422002
        ],
        "C": [
            30423987,
            30425801,
            30429852,
            30426800,
            30428131,
            30429744,
            30425472,
            30430400,
            30430892,
            30431289,
            30440032,
            30431284,
            30432065,
            30432412,
            30435482,
            30426919
        ]
    },
    "name": "C. Did you mean...",
    "statement": "Beroffice text editor has a wide range of features that help working\r\nwith text. One of the features is an automatic search for typos and\r\nsuggestions of how to fix them.Beroffice works only with small English\r\nletters (i.e. with 26 letters from to ). Beroffice thinks that a word is\r\ntyped with a typo if there are three or more consonants in a row in the\r\nword. The only exception is that if the block of consonants has all\r\nletters the same, then this block (even if its length is greater than\r\nthree) is not considered a typo. Formally, a word is typed with a typo\r\nif there is a block of not less that three consonants in a row, and\r\nthere are at least two different letters in this block.For example: the\r\nfollowing words have typos: \"\", \"\" and \"\"; the following words don\u2019t\r\nhave typos: \"\", \"\" and \"\". When Beroffice editor finds a word with a\r\ntypo, it inserts as little as possible number of spaces in this word\r\n(dividing it into several words) in such a way that each of the\r\nresulting words is typed without any typos.Implement this feature of\r\nBeroffice editor. Consider the following letters as the only vowels: \u201d,\r\n\u201d, \u201d, \u201d and \u201d. All the other letters are consonants in this problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n#define DEBUG(numx) cout << '>' << #numx << ':' << numx << endl;\n#define REP(idx1,num1) for(int idx1=0;idx1<(num1);idx1++)\n#define FOR(idx1,num1,bin) for(int idx1=(num1);idx1<=(bin);idx1++)\n#define FORD(idx1,num1,bin) for(int idx1=(num1);idx1>=(bin);idx1--)\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(\"%d\",&num1)\n#define sll(num1) scanf(\"%lld\",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define ll long long\n#define TRACE\n \n//FILE *fin = freopen(\"in\",\"r\",stdin);\n//FILE *fout = freopen(\"out\",\"s2numx\",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << \": \" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << \" | \" << #nn3 << \": \" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << endl;\n#define trace5(num1, bin, ch, d, e)    cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #e << \": \" << e << endl;\n#define trace6(num1, bin, ch, d, e, det) cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #e << \": \" << e << \" | \" << #det << \": \" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, e)\n#define trace6(num1, bin, ch, d, e, det)\n \n#endif\n \n#define pi(numx) printf(\"%d\\num1\",numx)\n#define F first\n#define pb push_back\n#define mp make_pair\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n\nusing namespace std;\n \nint main() {\n\tstring sst;\n\tcin >> sst;\n\tbool ttr = true;\n\t\tint ctt = 0;\n\t\tchar present = '-';\n\tfor(int i=0; i<sst.size(); i++){\n\t\tif(sst[i] == 'a' || sst[i] == 'e' || sst[i] == 'o' || sst[i] == 'i' || sst[i] == 'u'){\n\t\t\tcout << sst[i];\n\t\t\tttr = true;\n\t\t\tpresent = '-';\n\t\t\tctt = 0;\n\t\t}\n\t\telse{\n\t\t\tif(present == '-'){\n\t\t\t\tctt++;\n\t\t\t\tpresent = sst[i];\n\t\t\t\tcout << sst[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(present == sst[i] && ttr){\n\t\t\t\t\tctt++;\n\t\t\t\t\tpresent = sst[i];\n\t\t\t\t\tcout << sst[i];\n\t\t\t\t}else{\n\t\t\t\t\tttr = false;\n\t\t\t\t\tif(ctt < 2){\n\t\t\t\t\t\tcout << sst[i];\n\t\t\t\t\t\tctt++;\n \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout << \" \"<<sst[i];\n\t\t\t\t\t\tctt = 1;\n\t\t\t\t\t\tttr = true;\n\t\t\t\t\t\tpresent = sst[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Did you mean....json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si?-?1,?si and si?+?1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i?+?2, not i?+?1."
}