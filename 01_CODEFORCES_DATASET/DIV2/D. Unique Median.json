{
    "link": "https://codeforces.com//contest/2056/problem/D",
    "problemId": "3150795",
    "problem_idx": "D",
    "shortId": "2056D",
    "contest_number": "2056",
    "problem_submissions": {
        "F2": [
            301545587,
            301509040,
            301738450,
            302033567
        ],
        "F1": [
            301461815,
            301455964,
            301458356,
            301426872,
            301434246,
            302031432,
            302030623,
            301580078,
            301600084
        ],
        "E": [
            301439440,
            301447920,
            301443059,
            301433627,
            301428331,
            301444669,
            301439558,
            301439957,
            301443503,
            301447455,
            301451147,
            301446991,
            301456228,
            301452444,
            301427254,
            301456788,
            301448385
        ],
        "D": [
            301411463,
            301430952,
            301426584,
            301413553,
            301414046,
            301415062,
            301415941,
            301414692,
            301446695,
            301418999,
            301418932,
            301422889,
            301412134,
            301417642,
            301411530,
            301417000,
            301444048,
            301424366,
            301426240
        ],
        "C": [
            301399544,
            301411500,
            301416896,
            301418700,
            301401301,
            301404995,
            301400708,
            301399472,
            301417939,
            301403985,
            301402887,
            301398665,
            301399127,
            301403882,
            301404504,
            301408969,
            301407435,
            301401039,
            301402939
        ],
        "B": [
            301393848,
            301392518,
            301400501,
            301395217,
            301391544,
            301398396,
            301394970,
            301396057,
            301401319,
            301397018,
            301398125,
            301391015,
            301394435,
            301395913,
            301394898,
            301392345,
            301400120,
            301395871,
            301401973
        ],
        "A": [
            301388610,
            301388749,
            301390918,
            301392589,
            301387805,
            301391122,
            301388287,
            301390050,
            301390421,
            301388003,
            301389658,
            301387952,
            301388733,
            301389417,
            301387733,
            301388087,
            301390776,
            301389692,
            301388580
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138487",
    "editorial": "SolutionWhen is a subarray not good?If is odd, can’t be bad. Otherwise,\r\nsuppose the median of is . Then there need to be exactly elements in\r\nthat are and exactly that are .This gives us an idea to calculate the\r\nnumber of bad subarrays with a median of . Create another array of size\r\n, where if and otherwise., which has a median of , is bad if and only if\r\nand is even.Notice that the second condition is not needed, as the sum\r\nof an odd length subarray of is always odd, so it can’t be\r\nzero.Therefore, with a median of is bad iff .If there is no in , then\r\nthe median of trivially can’t be equal to .If there is an occurrence of\r\nin and , notice that the median of will always be exactly . This is true\r\nbecause smallest elements of are all , and there is an occurrence of ,\r\nso -th smallest element must be .This allows us to simply count the\r\nnumber of subarrays of with a sum of and with an occurrence of to count\r\nthe number of bad subarrays with median .We can subtract that value from\r\nfor all between and to solve the problem in .\r\n",
    "name": "D. Unique Median",
    "statement": "An array b of m integers is called if, , b_{\r\nleft\r\nlfloor\r\nfrac{m + 1}{2}\r\nright\r\nrfloor} = b_{\r\nleft\r\nlceil\r\nfrac{m + 1}{2}\r\nright\r\nrceil}. In other words, b is good if both of its medians are equal. In\r\nparticular,\r\nleft\r\nlfloor\r\nfrac{m + 1}{2}\r\nright\r\nrfloor =\r\nleft\r\nlceil\r\nfrac{m + 1}{2}\r\nright\r\nrceil when m is odd, so b is guaranteed to be good if it has an odd\r\nlength.You are given an array a of n integers. Calculate the number of\r\ngood subarrays^{\r\ntext{ }} in a.^{\r\ntext{ }}An array x is a subarray of an array y if x can be obtained from\r\ny by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define N 100005#define M 505#define LL long long#define inf 21474836477777777ll#define LD long double#define eps 1e-6using namespace std;int n,m,a[N],cnt[N][15],c[N];pair<int,int> p[N];// const int p=998244353;// inline void add(int x,int y){son[++tot]=y,nxt[tot]=fir[x],fir[x]=tot;} // inline int P(int x,int y){int z=1;while(y){if(y&1) z=1ll*z*x%p;y>>=1,x=1ll*x*x%p;} return z;}// inline void A(int &x,int y){x+=y,(x>=p)&&(x-=p,0),(x<0)&&(x+=p,0);}// inline void mul(int &x,int y){x=1ll*x*y%p;}inline void solve(int tc){    cin>>n;for(int i=1;i<=n;i++){cin>>a[i];for(int j=1;j<=10;j++) cnt[i][j]=cnt[i-1][j]+(a[i]<=j);}LL ans=0;    for(int i=1;i<=10;i++){        for(int j=0;j<=n;j++) c[j]=2*cnt[j][i]-j;sort(c,c+n+1);        for(int j=0;j<=n;j++){            int k=j;while(c[j]==c[k]&&k<=n) k++;k--;            ans+=1ll*(k-j+1)*(k-j)/2;j=k;        }    }    for(int i=1;i<=9;i++){        for(int j=0;j<=n;j++) p[j]=make_pair(2*cnt[j][i]-j,2*cnt[j][i+1]-j);sort(p,p+n+1);        for(int j=0;j<=n;j++){            int k=j;while(p[j]==p[k]&&k<=n) k++;k--;            ans-=1ll*(k-j+1)*(k-j)/2;j=k;        }    }    cout<<1ll*n*(n+1)/2-ans<<'\\n';}int main(){    // freopen(\"data.in\",\"r\",stdin);    ios::sync_with_stdio(false);    cin.tie(0); cout.tie(0);    int tc=1;    cin>>tc;    while(tc--) solve(tc);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "data structures",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Unique Median.json",
    "hint": [
        "Hint 1 Solve the problem when .",
        "Hint 2 Assign if and if and calculate the number of bad subarrays.",
        "Hint 3 Extend this solution for , however, you need to take overcounting into account."
    ]
}