{
    "link": "https://codeforces.com//contest/591/problem/E",
    "problemId": "39110",
    "problem_idx": "E",
    "shortId": "591E",
    "contest_number": "591",
    "problem_submissions": {
        "D": [
            13849030,
            13845483,
            13846625,
            13849366,
            13846742,
            13847541,
            13850733,
            13843952,
            14496309,
            13916744,
            13846148,
            13844076,
            13847951,
            13846518,
            13847210
        ],
        "E": [
            13844888,
            13848550,
            13850325,
            13847620,
            13850483,
            13852225,
            13849081,
            13855294,
            13847855,
            13849171,
            14085120,
            13848100,
            13847861,
            13864861,
            13855548,
            13848696,
            13873315
        ],
        "C": [
            13840817,
            13841693,
            13843123,
            13843996,
            13844252,
            13843977,
            13844258,
            13841623,
            13842033,
            13841419,
            13842844,
            13840871,
            13844001,
            13844419,
            13842123,
            13842913,
            13839987,
            13841515
        ],
        "B": [
            13836874,
            13837226,
            13837577,
            13839154,
            13840299,
            13839256,
            13840855,
            13838649,
            13838602,
            13839245,
            13839514,
            13845021,
            13838706,
            13837719,
            13838013,
            13840455,
            13841738,
            13843079
        ],
        "A": [
            13836028,
            13836035,
            13836124,
            13837057,
            13836904,
            13836780,
            13837115,
            13836694,
            13837210,
            13836891,
            13837220,
            13837863,
            13836419,
            13836389,
            13836528,
            13836982,
            13842350,
            13836315
        ]
    },
    "name": "E. Three States",
    "statement": "The famous global economic crisis is approaching rapidly, so the states\r\nof Berman, Berance and Bertaly formed an alliance and allowed the\r\nresidents of all member states to freely pass through the territory of\r\nany of them. In addition, it was decided that a road between the states\r\nshould be built to guarantee so that one could any point of any country\r\ncan be reached from any point of any other State.Since roads are always\r\nexpensive, the governments of the states of the newly formed alliance\r\nasked you to help them assess the costs. To do this, you have been\r\nissued a map that can be represented as a rectangle table consisting of\r\nrows and columns. Any cell of the map either belongs to one of three\r\nstates, or is an area where it is allowed to build a road, or is an area\r\nwhere the construction of the road is not allowed. A cell is called , if\r\nit belongs to one of the states, or the road was built in this cell.\r\nFrom any passable cells you can move up, down, right and left, if the\r\ncell that corresponds to the movement exists and is passable.Your task\r\nis to construct a road inside a minimum number of cells, so that it\r\nwould be possible to get from any cell of any state to any cell of any\r\nother state using only passable cells.It is guaranteed that initially it\r\nis possible to reach any cell of any state from any cell of this state,\r\nmoving only along its cells. It is also guaranteed that for any state\r\nthere is at least one cell that belongs to it.\r\n",
    "solutions": [
        "#include <string>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;                                   \n\n#define PATH \"C:\\\\Users\\\\ValenKof\\\\Desktop\\\\\"\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define forn(i, n) for(int i = 0; i < (n); ++i)\n#define debug(x) std::cerr << \"DEBUG: \" << #x << \" = \" << x << std::endl\n#define mp make_pair\n#define pb push_back\n\ntemplate<typename T> inline int sz(const T& x) { return x.size(); }\ntemplate<typename T> inline void mn(T& x, const T& y) { if (y < x) x = y; }\ntemplate<typename T> inline void mx(T& x, const T& y) { if (x < y) x = y; }\n\nconst int N = 1000;\n\nint n, m;\nchar a[N][N + 1];\n\nusing DistArray = array<array<int, N>, N>;\n\nDistArray d[3];\n\nconst int di[] = {-1, 0, +1, 0};\nconst int dj[] = {0, +1, 0, -1};\nconst int INF = 100000000;\n\nvoid solve(DistArray& dist, char c) {\n  deque<pair<int, int>> q;\n  forn (i, n) {\n    forn (j, m) {\n      dist[i][j] = INF;\n    }\n  }\n  forn (i, n) {\n    forn (j, m) {\n      if (a[i][j] == c) {\n        q.push_back({i, j});\n        dist[i][j] = 0;\n      }\n    }\n  }\n  while (!q.empty()) {\n    auto u = q.front();\n    q.pop_front();\n    forn (k, 4) {\n      int i = u.first + di[k];\n      int j = u.second + dj[k];\n      if (0 <= i && i < n && 0 <= j && j < m && a[i][j] != '#') {\n        int d = dist[u.first][u.second] + (a[i][j] == '.' ? 1 : 0);\n        if (d < dist[i][j]) {\n          if (a[i][j] == '.') {\n            q.push_back({i, j});\n          } else {\n            q.push_front({i, j});            \n          }\n          dist[i][j] = d;\n        }\n      }\n    }\n  }\n}\n\nint main() {\n  // freopen(\"input.txt\", \"r\", stdin);\n  // freopen(\"output.txt\", \"w\", stdout);\n  // freopen(PATH\"in.txt\", \"r\", stdin);\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  scanf(\"%d %d\\n\", &n, &m);\n  forn (i, n) {\n    gets(a[i]);\n  }\n  solve(d[0], '1');\n  solve(d[1], '2');\n  solve(d[2], '3');\n  \n  int ans = INF;\n  forn (i, n) {\n    forn (j, m) {\n      int cost = d[0][i][j] + d[1][i][j] + d[2][i][j];\n      if (cost < INF) {\n        if (a[i][j] == '.') {\n          cost -= 2;\n        }\n        mn(ans, cost);\n      }\n    }\n  }\n  vector<vector<int>> dist(3, vector<int>(3, INF));\n  forn (from, 3) {\n    forn (i, n) {\n      forn (j, m) {\n        if ('1' <= a[i][j] && a[i][j] <= '3') {\n          int to = a[i][j] - '1';\n          mn(dist[from][to], d[from][i][j]);\n        }\n      }\n    }\n  }\n  int sum = dist[0][1] + dist[0][2] + dist[1][2] -\n    max(max(dist[0][1], dist[0][2]), dist[1][2]);\n  mn(ans, sum);\n  if (ans == INF) {\n    ans = -1;\n  }\n  cout << ans << endl;\n  \n  \n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Three States.json",
    "editorial_link": "https://codeforces.com//blog/entry/21203",
    "editorial": "Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.\n\nProof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.\n\nThe solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V|?+?|E|).\n\nTo apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table ."
}