{
    "link": "https://codeforces.com//contest/1230/problem/E",
    "problemId": "419099",
    "problem_idx": "E",
    "shortId": "1230E",
    "contest_number": "1230",
    "problem_submissions": {
        "F": [
            61160420,
            61168761,
            61169473,
            61163448,
            61168484,
            61211410,
            61166190,
            61161224
        ],
        "E": [
            61148718,
            61161040,
            61146705,
            61151905,
            61156612,
            61143760,
            61134387,
            61160007,
            61147362,
            61152540,
            61143988,
            61157501,
            61156272,
            61146445,
            61139279,
            61157405,
            61162378
        ],
        "D": [
            61141780,
            61141760,
            61139292,
            61144818,
            61153245,
            61138124,
            61148103,
            61186591,
            61153749,
            61148878,
            61139116,
            61159398,
            61147761,
            61146515,
            61163213,
            61156688,
            61153790,
            61144523
        ],
        "C": [
            61128802,
            61146533,
            61172060,
            61167384,
            61149264,
            61133355,
            61139896,
            61137699,
            61129905,
            61146775,
            61146749,
            61137639,
            61130666,
            61128891,
            61133021,
            61163475,
            61147427,
            61133523
        ],
        "B": [
            61122260,
            61138928,
            61125100,
            61135886,
            61136151,
            61126292,
            61136826,
            61131007,
            61122773,
            61127439,
            61129919,
            61122576,
            61124319,
            61122348,
            62114936,
            61124404,
            61125885,
            61125887,
            61124264
        ],
        "A": [
            61120076,
            61128524,
            61121738,
            61130255,
            61122144,
            61123763,
            61140465,
            61128200,
            61120371,
            61124618,
            61133127,
            61121262,
            61120693,
            61119937,
            62114885,
            61126319,
            61122327,
            61122607,
            61120311
        ]
    },
    "name": "E. Kamil and Making a Stream",
    "statement": "Kamil likes streaming the competitive programming videos. His MeTube\r\nchannel has recently reached 100 million subscribers. In order to\r\ncelebrate this, he posted a video with an interesting problem he\r\ncouldn\u2019t solve yet. Can you help him?You\u2019re given a tree a connected\r\nundirected graph consisting of n vertices connected by n - 1 edges. The\r\ntree is rooted at vertex 1. A vertex u is called an of v if it lies on\r\nthe shortest path between the root and v. In particular, a vertex is an\r\nancestor of itself.Each vertex v is assigned its x_v a non-negative\r\ninteger not larger than 10^{12}. This allows us to define the beauty of\r\na path. Let u be an ancestor of v. Then we define the beauty f(u, v) as\r\nthe greatest common divisor of the beauties of all vertices on the\r\nshortest path between u and v. Formally, if u=t_1, t_2, t_3,\r\ndots, t_k=v are the vertices on the shortest path between u and v, then\r\nf(u, v) =\r\ngcd(x_{t_1}, x_{t_2},\r\ndots, x_{t_k}). Here,\r\ngcd denotes the greatest common divisor of a set of numbers. In\r\nparticular, f(u, u) =\r\ngcd(x_u) = x_u.Your task is to find the sum\r\nsum_{u\r\ntext{ is an ancestor of }v} f(u, v). As the result might be too large,\r\nplease output it modulo 10^9 + 7.Note that for each y,\r\ngcd(0, y) =\r\ngcd(y, 0) = y. In particular,\r\ngcd(0, 0) = 0.\r\n",
    "solutions": [
        "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nLL gcd(LL a, LL b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nconst size_t N = 1e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint n, ans;\nvector<int> g[N];\nLL x[N];\n\nvoid dfs(vector<pair<LL, int> > vc, int u, int p = 0) {\n    {\n        vector<pair<LL, int> > nvc;\n        nvc.emplace_back(x[u], 1);\n        ans = (ans + x[u]) % MOD;\n        for (auto [y, c] : vc) {\n            LL ny = gcd(y, x[u]);\n            ans = (ans + ny * c) % MOD;\n            if (ny == nvc.back().first) {\n                nvc.back().second += c;\n            } else {\n                nvc.emplace_back(ny, c);\n            }\n        }\n        nvc.swap(vc);\n    }\n    for (int v : g[u]) {\n        if (v != p) {\n            dfs(vc, v, u);\n        }\n    }\n}\n\nint main() {\n    n = read();\n    generate_n(x + 1, n, read);\n    for (int i = 1; i < n; ++i) {\n        int x = read(), y = read();\n        g[x].emplace_back(y);\n        g[y].emplace_back(x);\n    }\n    dfs({}, 1);\n    cout << ans;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Kamil and Making a Stream.json",
    "editorial_link": "https://codeforces.com//blog/entry/70008",
    "editorial": "Let's prove the following observation:\n\nFix a vertex v\n (the bottom end of the path), and consider all its ancestors u\n. The number of distinct values of f(u,v)\n is at most log2(1012)\n.\n\nTo prove this observation, consider the ancestors of v\n in the order from the bottom-most to top-most: v=u0,u1,u2,u3,\u0085,uk=1\n. Notice that f(ui,v)=gcd(xu0,xu1,xu2,\u0085,xui)\n. Therefore, each consecutive ui\n adds another value xu,i\n to the gcd of all numbers. If a gcd of all numbers changes, it must be a divisor of the previous gcd. Therefore, it's easy to see that it can change at most log2(1012)\n times.\n\nWe can now implement a depth-first search. If we invoke a recursive call in vertex v\n, we will receive the multiset of values {f(u,v)?u is an ancestor of v}\n. We add all these values to the result and run the recursive calls in the children.\n\nThis is currently O(n2)\n or O(n2logn)\n, but we can improve it by actually using a map from the distinct values in the multiset to the number of their occurrences. Then each map will have no more than Olog2(1012)\n elements. As we need to compute gcd\n's throughout the algorithm, this solution allows us to solve the problem in O(nlog2(1012))\n time and in O(nlog(1012))\n memory.\n\nIt's also possible to solve the problem using jump-pointers. Each jump-pointer will additionally hold the greatest common divisor of all the numbers we jump over when following the pointer."
}