{"link": "https://codeforces.com//contest/1151/problem/F", "problemId": "332197", "problem_idx": "F", "shortId": "1151F", "contest_number": "1151", "problem_submissions": {"F": [52969000, 52974140, 52969772, 52975022, 52980263, 52981542, 52980056, 52974325, 52978664, 52982169, 52980243, 52979375, 52980809, 52981384, 52980660, 52981146, 52979191, 52982382, 52981761], "A": [52964993, 52960645, 52960514, 52960890, 52960841, 52960632, 52960463, 52975864, 52961198, 52962194, 52961267, 52961719, 52960783, 52960868, 52960424, 52960539, 52961494, 52961722], "E": [52963816, 52970148, 52978614, 52970380, 52972910, 52970321, 52971212, 52978379, 52974086, 52973219, 52974283, 52974208, 52973176, 52975431, 52974891, 52976518, 52981339, 52975757, 52977016], "C": [52962801, 52967207, 52977404, 52967321, 52965669, 52965751, 52967555, 52965997, 52969606, 52970311, 52971192, 52970462, 52971754, 52968773, 52969400, 52967031, 52972316, 52975151], "D": [52961052, 52964041, 52961092, 52964482, 52967362, 52967568, 52969636, 52967779, 52971526, 52966600, 52966264, 52971704, 52969026, 52970628, 52970281, 52971940, 52968559, 52968478, 52966194], "B": [52960445, 52962771, 52963029, 52967763, 52962536, 52962803, 52962295, 52961661, 52965340, 52964038, 52963820, 52964825, 52967747, 52963985, 52966098, 52966081, 52962870, 52965786, 52964689]}, "name": "F. Sonya and Informatics", "statement": "A girl named Sonya is studying in the scientific lyceum of the Kingdom\r\nof Kremland. The teacher of computer science (Sonya\u2019s favorite subject!)\r\ninvented a task for her.Given an array a of length n, , and the number\r\nk. the following happens: Two numbers i and j are chosen equiprobable\r\nsuch that (1\r\nleq i < j\r\nleq n). The numbers in the i and j positions are swapped. Sonya\u2019s task\r\nis to find the probability that after all the operations are completed,\r\nthe a array will be . She turned to you for help. Help Sonya solve this\r\nproblem.It can be shown that the desired probability is either 0 or it\r\ncan be represented as\r\ndfrac{P}{Q}, where P and Q are coprime integers and Q\r\nnot\r\nequiv 0\u00a0\r\npmod {10^9+7}.\r\n", "solutions": ["#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nusing modulo = modint<mod>;\nint N, K, A[109]; modulo ans[55][55], mat[55][55], tmp[55][55];\nint main() {\n\tcin >> N >> K;\n\tint zeros = 0, ones = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t\tif (A[i] == 0) ++zeros;\n\t\telse ++ones;\n\t}\n\tint inidiff = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (A[i] == 0 && i >= zeros) ++inidiff;\n\t}\n\tmodulo allposs = modulo(N * (N - 1) / 2);\n\tint md = min(zeros, ones);\n\tfor (int i = 0; i <= md; ++i) {\n\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\tif (i - j == 1) {\n\t\t\t\tmat[i][j] = modulo(i * i) * allposs.inv();\n\t\t\t}\n\t\t\tif (i - j == 0) {\n\t\t\t\tmat[i][j] = modulo(allposs - i * i - (zeros - i) * (ones - i)) * allposs.inv();\n\t\t\t}\n\t\t\tif (i - j == -1) {\n\t\t\t\tmat[i][j] = modulo((zeros - i) * (ones - i)) * allposs.inv();\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= md; ++i) {\n\t\tans[i][i] = modulo(1);\n\t}\n\twhile (K > 0) {\n\t\tif (K & 1) {\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\ttmp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\tfor (int k = 0; k <= md; ++k) {\n\t\t\t\t\t\ttmp[i][j] += ans[i][k] * mat[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\t\tans[i][j] = tmp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\ttmp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\tfor (int k = 0; k <= md; ++k) {\n\t\t\t\t\ttmp[i][j] += mat[i][k] * mat[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= md; ++i) {\n\t\t\tfor (int j = 0; j <= md; ++j) {\n\t\t\t\tmat[i][j] = tmp[i][j];\n\t\t\t}\n\t\t}\n\t\tK >>= 1;\n\t}\n\tcout << ans[inidiff][0].get() << endl;\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "matrices", "probabilities"], "dificulty": "2300", "interactive": false}