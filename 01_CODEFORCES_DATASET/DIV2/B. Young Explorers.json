{
    "link": "https://codeforces.com//contest/1355/problem/B",
    "problemId": "621792",
    "problem_idx": "B",
    "shortId": "1355B",
    "contest_number": "1355",
    "problem_submissions": {
        "F": [
            80362643,
            80361142,
            80371199,
            80375388,
            80371644,
            80361246,
            80376315,
            80364923,
            80451552,
            80451301,
            82486662,
            80381916,
            80385112,
            80379306
        ],
        "E": [
            80342772,
            80347661,
            80342876,
            80352205,
            80343534,
            80366285,
            80351380,
            80344639,
            80337870,
            80337107,
            80341941,
            80338367,
            80340360,
            80336736,
            80314570,
            80337962,
            80336156,
            80334884,
            80344718
        ],
        "D": [
            80330173,
            80325918,
            80331675,
            80332445,
            80331125,
            80343460,
            80342008,
            80323259,
            80328043,
            80317161,
            80320497,
            80327650,
            80330129,
            80331474,
            80325643,
            80327968,
            80338287,
            80328760
        ],
        "C": [
            80320115,
            80322649,
            80326557,
            80321616,
            80325868,
            80336946,
            80347623,
            80329416,
            80318213,
            80323733,
            80324197,
            80332049,
            80321990,
            80325577,
            80334728,
            80333064,
            80322766,
            80319462,
            80324120
        ],
        "B": [
            80313084,
            80311263,
            80314204,
            80313526,
            80315674,
            80318605,
            80310517,
            80315225,
            80313004,
            80311116,
            80311816,
            80310369,
            80314982,
            80317625,
            80337817,
            80312634,
            80317719,
            80311591,
            80311875
        ],
        "A": [
            80310641,
            80315080,
            80310450,
            80310461,
            80311650,
            80314001,
            80355749,
            80319520,
            80310211,
            80310180,
            80310418,
            80311667,
            80311224,
            80310372,
            80321351,
            80310345,
            80316111,
            80324974,
            80310515
        ]
    },
    "name": "B. Young Explorers",
    "statement": "Young wilderness explorers set off to their first expedition led by\r\nsenior explorer Russell. Explorers went into a forest, set up a camp and\r\ndecided to split into groups to explore as much interesting locations as\r\npossible. Russell was trying to form groups, but ran into some\r\ndifficulties...Most of the young explorers are inexperienced, and\r\nsending them alone would be a mistake. Even Russell himself became\r\nsenior explorer not long ago. Each of young explorers has a positive\r\ninteger parameter e_i his inexperience. Russell decided that an explorer\r\nwith inexperience e can only join the group of e or more people.Now\r\nRussell needs to figure out how many groups he can organize. It’s not\r\nnecessary to include every explorer in one of the groups: some can stay\r\nin the camp. Russell is worried about this expedition, so he asked you\r\nto help him.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define endl \"\\n\"\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n//#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\n\n\nvoid solve(){\n  int n;\n  cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++){\n    cin>>v[i];\n  }\n  sort(v.begin(),v.end());\n  int tot=0;\n\n  for(int i=0;i<v.size();){\n    int inside = 1;\n    int mx = v[i];\n    i++;\n    while(i<n and inside < mx){\n      inside++;\n      mx = max(mx,v[i]);\n      i ++;\n    }\n    if(inside==mx){\n      tot++;\n    }\n\n  }\n  cout << tot << endl;\n}\n\nint32_t main(){\n  fastio;\n  int t=1;\n  cin>>t;\n  while(t--){\n    solve();\n  }\n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Young Explorers.json",
    "editorial_link": "https://codeforces.com//blog/entry/77491",
    "editorial": "Letâs sort all the explorers by non-decreasing inexperience. Suppose we\r\nhave formed some group, how can we check is this group is valid?\r\nInexperience of all the explorers in the group should be not greater\r\nthan the group size. But we have sorted all the explorers, so the last\r\nexplorer from the group has the largest inexperience. Therefore, to\r\ncheck the group for validity it is necessary and sufficient to check\r\nthat inexperience of the last explorer is not greater than the group\r\nsize.We can notice that we donât even look at all the explorers except\r\nthe last one, the only important thing is their number. In fact, we can\r\norganize the creation of groups in this way: first choose the explorers\r\nthat will be the last in their groups, then assign sufficient number of\r\nother explorers to corresponding groups. It is not profitable to assign\r\nmore explorers than needed for this particular last explorer, because we\r\ncan always leave them at the camp.So how should we choose the last\r\nexplorers? We want to make more groups, so the groups themselves should\r\nme smaller... It is tempting to use the following greedy algorithm:\r\nletâs greedily pick the leftmost (which means with the smallest\r\nnecessary group size) explorer such that they have enough explorers to\r\nthe left of them to create a valid group. The idea is that we spend the\r\nsmallest number of explorers and leave the most potential last explorers\r\nin the future. Letâs strictly prove this greedy:The solution is defined\r\nby positions of the last explorers in their corresponding groups 1\r\nle p_{1} < p_{2} <\r\nldots < p_{k}\r\nle n. Notice that the solution is valid if and only if e_{p_{1}} +\r\ne_{p_{2}} +\r\nldots + e_{p_{i}}\r\nle p_{i} for all 1\r\nle i\r\nle k (we always have enough explorers to form first i groups).Let 1\r\nle p_{1} < p_{2} <\r\nldots < p_{k}\r\nle n be the greedy solution and 1\r\nle q_{1} < q_{2} <\r\nldots < q_{m}\r\nle n be the optimal solution such that it has the largest common prefix\r\nwith greedy one among all optimal solutions. Let t be the position of\r\nfirst difference in these solutions. t\r\nle k since otherwise the greedy algorithm couldnât add one more group\r\nbut it was possible. p_{t} < q_{t} since otherwise the greedy algorithm\r\nwould take q_{t} instead of p_{t}. Since the explorers are sorted we\r\nhave e_{p_{t}}\r\nle e_{q_{t}}. But then 1\r\nle q_{1} < q_{2} <\r\nldots < q_{t - 1} < p_{t} < q_{t + 1} <\r\nldots < q_{m}\r\nle n is a valid optimal solution and it has strictly larger common\r\nprefix with the greedy one which contradicts the choosing of our optimal\r\nsolution.To implement this solution it is enough to sort the explorers\r\nby the non-decreasing inexperience, then go from left to right and\r\nmaintain the number of unused explorers. As soon as we encounter the\r\npossibility to create a new group, we do it.\r\n",
    "hint": []
}