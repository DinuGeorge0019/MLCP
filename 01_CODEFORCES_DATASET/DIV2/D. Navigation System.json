{
    "link": "https://codeforces.com//contest/1321/problem/D",
    "problemId": "551763",
    "problem_idx": "D",
    "shortId": "1321D",
    "contest_number": "1321",
    "problem_submissions": {
        "F": [
            72202118,
            72198416
        ],
        "C": [
            72190499,
            72170310,
            72171527,
            72174502,
            72175483,
            72175401,
            72175000,
            72176189,
            72171238,
            72175883,
            72177727,
            72183189,
            72179214,
            72177328,
            72279003,
            72174053,
            72178214,
            72178070,
            72179504,
            72179152,
            72178320
        ],
        "D": [
            72183268,
            72175184,
            72177797,
            72179168,
            72180779,
            72181426,
            72180644,
            72182068,
            72185885,
            72181701,
            72186041,
            72179938,
            72186063,
            72181326,
            72178168,
            72183258,
            72185462,
            72184740,
            72187220,
            72184221
        ],
        "E": [
            72180529,
            72186287,
            72184508,
            72188609,
            72188377,
            72190998,
            72191625,
            72192736,
            72180513,
            72191278,
            72214882,
            72192856,
            72193973,
            72192866,
            72196349,
            72194892,
            72194887,
            72194595,
            72195594,
            72195787
        ],
        "A": [
            72173172,
            72167016,
            72167934,
            72167935,
            72169001,
            72167363,
            72167505,
            72167646,
            72189321,
            72167844,
            72168400,
            72167413,
            72168727,
            72167365,
            72278985,
            72168080,
            72169683,
            72169011,
            72168321,
            72167972,
            72167569
        ],
        "B": [
            72168656,
            72168025,
            72169238,
            72170413,
            72171089,
            72169057,
            72169880,
            72170679,
            72187620,
            72171095,
            72171827,
            72169625,
            72172515,
            72169721,
            72170650,
            72172323,
            72173484,
            72170425,
            72174186,
            72171595
        ]
    },
    "name": "D. Navigation System",
    "statement": "The map of Bertown can be represented as a set of n intersections,\r\nnumbered from 1 to n and connected by m one-way roads. It is possible to\r\nmove along the roads from any intersection to any other intersection.\r\nThe length of some path from one intersection to another is the number\r\nof roads that one has to traverse along the path. The shortest path from\r\none intersection v to another intersection u is the path that starts in\r\nv, ends in u and has the minimum length among all such paths.Polycarp\r\nlives near the intersection s and works in a building near the\r\nintersection t. Every day he gets from s to t by car. Today he has\r\nchosen the following path to his workplace: p_1, p_2, ..., p_k, where\r\np_1 = s, p_k = t, and all other elements of this sequence are the\r\nintermediate intersections, listed in the order Polycarp arrived at\r\nthem. Polycarp never arrived at the same intersection twice, so all\r\nelements of this sequence are pairwise distinct. .Polycarp\u2019s car has a\r\ncomplex navigation system installed in it. Let\u2019s describe how it works.\r\nWhen Polycarp starts his journey at the intersection s, the system\r\nchooses some shortest path from s to t and shows it to Polycarp. Let\u2019s\r\ndenote the next intersection in the chosen path as v. If Polycarp\r\nchooses to drive along the road from s to v, then the navigator shows\r\nhim the same shortest path (obviously, starting from v as soon as he\r\narrives at this intersection). However, if Polycarp chooses to drive to\r\nanother intersection w instead, the navigator the path: as soon as\r\nPolycarp arrives at w, the navigation system chooses some shortest path\r\nfrom w to t and shows it to Polycarp. The same process continues until\r\nPolycarp arrives at t: if Polycarp moves along the road recommended by\r\nthe system, it maintains the shortest path it has already built; but if\r\nPolycarp chooses some other path, the system the path by the same\r\nrules.Here is an example. Suppose the map of Bertown looks as follows,\r\nand Polycarp drives along the path [1, 2, 3, 4] (s = 1, t = 4): Check\r\nthe picture by the link http://tk.codeforces.com/a.png When Polycarp\r\nstarts at 1, the system chooses some shortest path from 1 to 4. There is\r\nonly one such path, it is [1, 5, 4]; Polycarp chooses to drive to 2,\r\nwhich is not along the path chosen by the system. When Polycarp arrives\r\nat 2, the navigator the path by choosing some shortest path from 2 to 4,\r\nfor example, [2, 6, 4] (note that it could choose [2, 3, 4]); Polycarp\r\nchooses to drive to 3, which is not along the path chosen by the system.\r\nWhen Polycarp arrives at 3, the navigator the path by choosing the only\r\nshortest path from 3 to 4, which is [3, 4]; Polycarp arrives at 4 along\r\nthe road chosen by the navigator, so the system does not have to rebuild\r\nanything. Overall, we get 2 rebuilds in this scenario. Note that if the\r\nsystem chose [2, 3, 4] instead of [2, 6, 4] during the second step,\r\nthere would be only 1 rebuild (since Polycarp goes along the path, so\r\nthe system maintains the path [3, 4] during the third step).The example\r\nshows us that the number of rebuilds can differ even if the map of\r\nBertown and the path chosen by Polycarp stays the same. Given this\r\ninformation (the map and Polycarp\u2019s path), can you determine the minimum\r\nand the maximum number of rebuilds that could have happened during the\r\njourney?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r){return l+rng()%(r-l+1);}\n#define fasty ios_base::sync_with_stdio(0),cin.tie(0);\n#define forinc(a,b,c) for(int a=b,_c=c;a<=_c;++a)\n#define fordec(a,b,c) for(int a=b,_c=c;a>=_c;--a)\n#define forv(a,b) for(auto&a:b)\n#define fi first\n#define se second\n#define pb push_back\n#define ii pair<int,int>\n#define mt make_tuple\n#define all(a) a.begin(),a.end()\n#define reset(f, x) memset(f, x, sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define on(x,i) (x|(1ll<<(i-1)))\n#define off(x,i) (x&~(1<<(i-1)))\n#define gg exit(0);\n\nconst int N=200010;\n\nint n,m,k;\nint a[N],nxt[N];\nint f[N],cnt[N],ans[N];\nvector<int> ad[N];\n\nvoid sfa(int x){\n    reset(f,127);\n    priority_queue<ii,vector<ii>,greater<ii>> q;\n    q.push({0,x}); f[x]=0; cnt[x]=1; ans[x]=nxt[x]==x;\n    while(q.size()){\n        int c,u; tie(c,u)=q.top(); q.pop();\n        if(c==f[u]){\n            forv(v,ad[u]){\n                if(f[v]>c+1){\n                    f[v]=c+1;\n                    q.push({c+1,v});\n                    if(ans[v]) ans[v]=0;\n                }\n                if(f[v]==c+1){\n                    cnt[v]++;\n                    if(nxt[v]==u)\n                        ans[v]=1;\n                }\n            }\n        }\n    }\n}\n\nmain(){\n    #define task \"TASK\"\n    //freopen(task\".inp\",\"r\",stdin);\n    //freopen(task\".out\",\"w\",stdout);\n\n    n=in,m=in;\n    forinc(i,1,m){\n        int u=in,v=in;\n        ad[v].pb(u);\n    }\n    forinc(i,1,k=in) a[i]=in;\n    forinc(i,1,k-1) nxt[a[i]]=a[i+1];\n    sfa(a[k]);\n    int lf=0,rt=0;\n    forinc(i,1,k-1){\n        if(!ans[a[i]])\n            lf++, rt++;\n        else if(cnt[a[i]]>1)\n            rt++;\n    }\n    cout<<lf<<\" \"<<rt;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Navigation System.json",
    "editorial_link": "https://codeforces.com//blog/entry/74431",
    "editorial": "Let dv\n be the length of the shortest path from v\n to t\n. If we move from vertex v\n to vertex u\n on our path, then:\n\nthe rebuild will definitely occur if du>dv?1\n;\nthe rebuild may occur if there exists at least one vertex w?u\n such that dw=dv?1\n (the navigation system could have built a path through w\n).\nWe can calculate all values of dv\n using BFS from t\n on a transposed graph. Now for each vertex, we can easily determine whether it should be added to the set of vertices where the route definitely rebuilds and to the set of vertices where a rebuild is possible."
}