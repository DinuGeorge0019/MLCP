{
    "link": "https://codeforces.com//contest/1713/problem/B",
    "problemId": "1496885",
    "problem_idx": "B",
    "shortId": "1713B",
    "contest_number": "1713",
    "problem_submissions": {
        "E": [
            167272157,
            167275947,
            167255255,
            167280552,
            167277532,
            167281915,
            167286271,
            167295534,
            167291747,
            167285691,
            167290110,
            167289826,
            167289470,
            167288114,
            167295399,
            167293392,
            167292517,
            167288991,
            167292413,
            167295616
        ],
        "D": [
            167262934,
            167264444,
            167275938,
            167266127,
            167264903,
            167407463,
            167265717,
            167269013,
            167270800,
            167270098,
            167276487,
            167270258,
            167267741,
            167270166,
            167269509,
            167261936,
            167272225,
            167242557,
            167276667,
            167276744,
            167278772
        ],
        "C": [
            167243257,
            167245150,
            167266251,
            167242115,
            167251589,
            167255369,
            167252792,
            167244013,
            167251870,
            167263156,
            167253225,
            167255260,
            167254692,
            167249536,
            167241452,
            167251627,
            167255063,
            167259927,
            167257077,
            167247512
        ],
        "B": [
            167234078,
            167234734,
            167230438,
            167233192,
            167236986,
            167243546,
            167240561,
            167234594,
            167236064,
            167235869,
            167233392,
            167241862,
            167238018,
            167234909,
            167233503,
            167237613,
            167277571,
            167236123,
            167238131,
            167235652
        ],
        "A": [
            167230129,
            167230356,
            167231376,
            167230475,
            167230244,
            167239741,
            167232628,
            167231141,
            167231690,
            167230947,
            167230261,
            167230810,
            167230984,
            167230721,
            167230524,
            167233664,
            167273402,
            167231481,
            167232153,
            167230801
        ],
        "F": [
            167345887,
            167645094,
            167481610
        ]
    },
    "name": "B. Optimal Reduction",
    "statement": "Consider an array a of n positive integers.You may perform the following\r\noperation: select two indices l and r (1\r\nleq l\r\nleq r\r\nleq n), then decrease all elements a_l, a_{l + 1},\r\ndots, a_r by 1. Let’s call f(a) the minimum number of operations needed\r\nto change array a into an array of n zeros.Determine if for all\r\npermutations^\r\ndagger b of a, f(a)\r\nleq f(b) is true. ^\r\ndagger An array b is a permutation of an array a if b consists of the\r\nelements of a in arbitrary order. For example, [4,2,3,4] is a\r\npermutation of [3,2,4,4] while [1,2,2] is not a permutation of [1,2,3].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nbool solve() {\n    int n;\n    cin >> n;\n    vi arr(n);\n    cin >> arr;\n\n    bool flip = false;\n\n    for (int i = 0; i < n-1; i++) {\n        if (arr[i] < arr[i+1]) {\n            if (flip) {\n                cout << \"NO\\n\";\n                return false;\n            }\n        }\n        else if (arr[i] > arr[i+1]) {\n            flip = true;\n        }\n    }\n    cout << \"YES\\n\";\n\n    return false;\n}   \n\n\nint main() {\n\n    // freopen(\"input.in\", \"r\", stdin);\n    // freopen(\"input.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Optimal Reduction.json",
    "editorial_link": "https://codeforces.com//blog/entry/105419",
    "editorial": "Letâs call . The problem asks us to make all its elements become in some\r\noperations. And for each operation, we subtract each elements in an\r\nsubarray by . Thus, every largest elements of the array have to be\r\ndecreased in at least operations. And also because of that, over all\r\npermutations of is never less than . Every permutations of such that\r\nhave the same construction. That is, they can be divided into subarrays\r\nwhere the left subarray is sorted in non-decreasing order, and the right\r\nsubarray is sorted in non-increasing order. In other words, the elements\r\nof the array should form a mountain. Why?This is how to perform the\r\noperations: assign equal to the index of the leftmost element whose\r\nvalue is not , and assign equal to the index of the rightmost element\r\nwhose value is also not , then subtract each element by . Repeat the\r\noperation until all elements become . The thing is each element of the\r\narray is always greater or equal than every elements in the left side or\r\nthe right side of it so it can never become negative at some point of\r\nperforming the operations. Besides, all the largest elements are also\r\nincluded in each operation that we perform, which mean weâve achieved\r\nthe goal to make all elements of the array become in operations.\r\n",
    "hint": [
        "Hint 1 How to calculate ?",
        "Hint 2 What if is intially sorted?",
        "Hint 3 Consider has elements. What if and ?"
    ]
}