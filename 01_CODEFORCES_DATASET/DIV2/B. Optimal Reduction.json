{"link": "https://codeforces.com//contest/1713/problem/B", "problemId": "1496885", "problem_idx": "B", "shortId": "1713B", "contest_number": "1713", "problem_submissions": {"E": [167272157, 167275947, 167255255, 167280552, 167277532, 167281915, 167286271, 167295534, 167291747, 167285691, 167290110, 167289826, 167289470, 167288114, 167295399, 167293392, 167292517, 167288991, 167292413, 167295616], "D": [167262934, 167264444, 167275938, 167266127, 167264903, 167407463, 167265717, 167269013, 167270800, 167270098, 167276487, 167270258, 167267741, 167270166, 167269509, 167261936, 167272225, 167242557, 167276667, 167276744, 167278772], "C": [167243257, 167245150, 167266251, 167242115, 167251589, 167255369, 167252792, 167244013, 167251870, 167263156, 167253225, 167255260, 167254692, 167249536, 167241452, 167251627, 167255063, 167259927, 167257077, 167247512], "B": [167234078, 167234734, 167230438, 167233192, 167236986, 167243546, 167240561, 167234594, 167236064, 167235869, 167233392, 167241862, 167238018, 167234909, 167233503, 167237613, 167277571, 167236123, 167238131, 167235652], "A": [167230129, 167230356, 167231376, 167230475, 167230244, 167239741, 167232628, 167231141, 167231690, 167230947, 167230261, 167230810, 167230984, 167230721, 167230524, 167233664, 167273402, 167231481, 167232153, 167230801], "F": [167345887, 167645094, 167481610]}, "name": "B. Optimal Reduction", "statement": "Consider an array a of n positive integers.You may perform the following\r\noperation: select two indices l and r (1\r\nleq l\r\nleq r\r\nleq n), then decrease all elements a_l, a_{l + 1},\r\ndots, a_r by 1. Let\u2019s call f(a) the minimum number of operations needed\r\nto change array a into an array of n zeros.Determine if for all\r\npermutations^\r\ndagger b of a, f(a)\r\nleq f(b) is true. ^\r\ndagger An array b is a permutation of an array a if b consists of the\r\nelements of a in arbitrary order. For example, [4,2,3,4] is a\r\npermutation of [3,2,4,4] while [1,2,2] is not a permutation of [1,2,3].\r\n", "solutions": ["#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nbool solve() {\n    int n;\n    cin >> n;\n    vi arr(n);\n    cin >> arr;\n\n    bool flip = false;\n\n    for (int i = 0; i < n-1; i++) {\n        if (arr[i] < arr[i+1]) {\n            if (flip) {\n                cout << \"NO\\n\";\n                return false;\n            }\n        }\n        else if (arr[i] > arr[i+1]) {\n            flip = true;\n        }\n    }\n    cout << \"YES\\n\";\n\n    return false;\n}   \n\n\nint main() {\n\n    // freopen(\"input.in\", \"r\", stdin);\n    // freopen(\"input.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "sortings"], "dificulty": "1000", "interactive": false}