{"link": "https://codeforces.com//contest/1263/problem/E", "problemId": "483581", "problem_idx": "E", "shortId": "1263E", "contest_number": "1263", "problem_submissions": {"F": [65982966, 65978661, 65982743, 66004105, 65981403, 65982906, 65984527, 65967209, 65985700, 65987420, 65990597, 65985690, 65988080, 66082681, 66082661, 65991200, 65988308, 65990381, 65990481, 66004842, 66004759, 66004719, 66004190, 65989038, 65986432, 65987559], "A": [65969521, 65961098, 65960714, 65962476, 65960820, 65960894, 65980138, 65961073, 65960873, 65961438, 65963263, 65960772, 65978824, 65961157, 65962102, 65960839, 65961853, 65961109, 65961702], "E": [65968592, 65970858, 65970511, 66002882, 65966227, 65975131, 65974148, 65975198, 65975184, 65976510, 65977397, 65977245, 65977807, 65973180, 65969025, 65981150, 65979864, 65980298, 65982044, 65990889, 65982753], "D": [65964312, 65966149, 65963758, 65968928, 65967814, 65969772, 65976755, 65969893, 65967529, 65964864, 65971947, 65966055, 65962087, 65967297, 65966037, 65973690, 65970452, 65967218, 65972623], "C": [65962585, 65964625, 65962104, 65977080, 65966153, 65965608, 65964949, 65977661, 65966317, 65964823, 65965028, 65969369, 65963751, 65963273, 65964947, 65961279, 65968926, 65968185, 65964802, 65969882], "B": [65961580, 65962530, 65961425, 65964286, 65964464, 65963229, 65979595, 65963832, 65962737, 65962077, 65967269, 65974357, 65980348, 65962893, 65969125, 65965548, 65964171, 65963429, 65966476]}, "name": "E. Editor", "statement": "The development of a text editor is a hard problem. You need to\r\nimplement an extra module for brackets coloring in text.Your editor\r\nconsists of a line with infinite length and cursor, which points to the\r\ncurrent character. Please note that it points to only one of the\r\ncharacters (and not between a pair of characters). Thus, it points to an\r\nindex character. The user can move the cursor left or right one\r\nposition. If the cursor is already at the first (leftmost) position,\r\nthen it does not move left.Initially, the cursor is in the first\r\n(leftmost) character.Also, the user can write a letter or brackets\r\n(either , or ) to the position that the cursor is currently pointing at.\r\nA new character always overwrites the old value at that position.Your\r\neditor must check, whether the current line is the . Text is correct if\r\nthe brackets in them form the .Formally, correct text (CT) must satisfy\r\nthe following rules: any line without brackets is CT (the line can\r\ncontain whitespaces); If the first character of the string is , the last\r\nis , and all the rest form a CT, then the whole line is a CT; two\r\nconsecutively written CT is also CT. Examples of correct texts: , , , .\r\nExamples of incorrect texts: , , .The user uses special commands to work\r\nwith your editor. Each command has its symbol, which must be written to\r\nexecute this command.The correspondence of commands and characters is as\r\nfollows: move the cursor one character to the left (remains in place if\r\nit already points to the first character); move the cursor one character\r\nto the right; any lowercase Latin letter or bracket ( or ) write the\r\nentered character to the position where the cursor is now. For a\r\ncomplete understanding, take a look at the first example and its\r\nillustrations in the note below.You are given a string containing the\r\ncharacters that the user entered. For the brackets coloring module\u2019s\r\nwork, after each command you need to: check if the current text in the\r\neditor is a correct text; if it is, print the least number of colors\r\nthat required, to color all brackets. If two pairs of brackets are\r\nnested (the first in the second or vice versa), then these pairs of\r\nbrackets should be painted in colors. If two pairs of brackets are not\r\nnested, then they can be painted in different or the same colors. For\r\nexample, for the bracket sequence the least number of colors is 2, and\r\nfor the bracket sequence is 3.Write a program that prints the minimal\r\nnumber of colors after processing each command.\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n#include <iostream>\n\nusing namespace std;\n\n#define BT 1048576\n\nstruct node_t {\n  int minv, maxv;\n  int add;\n};\n\nnode_t tree[BT * 2];\n\nvoid refresh(int p) {\n  if (p >= BT) {\n    tree[p].minv = tree[p].maxv = tree[p].add;\n    return;\n  }\n  tree[p].minv = min(tree[p * 2].minv, tree[p * 2 + 1].minv) + tree[p].add;\n  tree[p].maxv = max(tree[p * 2].maxv, tree[p * 2 + 1].maxv) + tree[p].add;\n}\nvoid update(int l, int r, int add) {\n  l |= BT, r |= BT;\n  int oL = l, oR = r;\n  while (l <= r) {\n    if (l & 1){\n      tree[l].add += add;\n      tree[l].minv += add;\n      tree[l].maxv += add;\n    }\n    if (!(r & 1)) {\n      tree[r].add += add;\n      tree[r].minv += add;\n      tree[r].maxv += add;\n    }\n    l = (l + 1) >> 1;\n    r = (r - 1) >> 1;\n  }\n  tie(l, r) = tie(oL, oR);\n  while (l >= 1) {\n    refresh(l);\n    refresh(r);\n    l >>= 1;\n    r >>= 1;\n  }\n}\n\nint get_point(int p) {\n  p |= BT;\n  int ans = 0;\n  while (p >>= 1) {\n    ans += tree[p].add;\n  }\n  return ans;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  string command;\n  cin >> command;\n\n  string line(BT, ' ');\n  int pos = 0;\n  for (int i = 0; i < n; i++) {\n    if (command[i] == 'L') {\n      pos = max(0, pos - 1);\n    } else if (command[i] == 'R') {\n      pos++;\n    } else {\n      if (line[pos] == '(') {\n        update(pos, BT - 1, -1);\n      } else if (line[pos] == ')') {\n        update(pos, BT - 1, 1);\n      }\n      line[pos] = command[i];\n      if (line[pos] == '(') {\n        update(pos, BT - 1, 1);\n      } else if (line[pos] == ')') {\n        update(pos, BT - 1, -1);\n      }\n    }\n    int ans = -1;\n    if (get_point(BT - 1) == 0 && tree[1].minv >= 0) {\n      ans = tree[1].maxv;\n    }\n    cout << ans << (i + 1 == n ? \"\\n\" : \" \");\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "2100", "interactive": false}