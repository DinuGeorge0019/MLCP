{"link": "https://codeforces.com//contest/382/problem/E", "problemId": "5701", "problem_idx": "E", "shortId": "382E", "contest_number": "382", "problem_submissions": {"E": [5722079, 5724986, 5723752, 5718812, 5721924], "D": [5718725, 5717756, 5717851, 5717745, 5719690, 5714810, 5721932, 5720567, 5722151, 5717791, 5721410, 5720203, 5719876, 5721225], "C": [5716710, 5711942, 5714271, 5713299, 5715983, 5716064, 5717488, 5717351, 5717548, 5715922, 5713490, 5715750, 5723505, 5723844, 5715400, 5713682, 5713980], "B": [5715404, 5715550, 5712671, 5715816, 5713961, 5713314, 5719630, 5714660, 5714188, 5714767, 5717962, 5712988, 5721070, 5713270, 5717088, 5718416, 5713327, 5716113, 5717857], "A": [5711555, 5712570, 5718543, 5711489, 5711959, 5711620, 5711695, 5711887, 5718283, 5711414, 5711584, 5711421, 5717859, 5711558, 5711377, 5711567, 5711709, 5711919]}, "name": "E. Ksenia and Combinatorics", "statement": "Ksenia has her winter exams. Today she is learning combinatorics. Here\u2019s\r\none of the problems she needs to learn to solve.How many distinct trees\r\nare there consisting of vertices, each with the following properties:\r\nthe tree is marked, that is, the vertices of the tree are numbered from\r\n1 to ; each vertex of the tree is connected with at most three other\r\nvertices, and at the same moment the vertex with number 1 is connected\r\nwith at most two other vertices; the size of the tree\u2019s maximum matching\r\nequals . Two trees are considered distinct if there are such two\r\nvertices and , that in one tree they are connected by an edge and in the\r\nother tree they are not.Help Ksenia solve the problem for the given and\r\n. As the answer to the problem can be very huge you should output it\r\nmodulo .\r\n", "solutions": ["#include<stdio.h>\ntypedef long long LL;\nconst LL mod=1000000007;\nconst LL inv2=(mod+1)/2;\nLL inv[52];\nLL C[52][52];\nLL dp[52][52][2];// i nodes j matches k 0/1 root matched?\ninline void Add(LL &x,LL y){\n\tif(y>=mod) y%=mod;\n\ty*=inv2;\n\tif(y>=mod) y%=mod;\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint N,M;\nint main(){\n\tinv[1]=1;\n\tfor(int i=2;i<=50;++i) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tfor(int i=0;i<=50;++i){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t\tif(C[i][j]>=mod) C[i][j]-=mod;\n\t\t}\n\t}\n\tdp[0][0][1]=1;\n\tdp[1][0][0]=1;\n\tfor(int i=2;i<=50;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint k=i-1-j;\n\t\t\tfor(int l=0;l<=j/2;++l){\n\t\t\t\tfor(int m=0;m<=k/2;++m){\n\t\t\t\t\tfor(int ii=0;ii<2;++ii) for(int jj=0;jj<2;++jj){\n\t\t\t\t\t\tint cnt=!ii||!jj;\n\t\t\t\t\t\tAdd(dp[i][l+m+cnt][cnt],dp[j][l][ii]*dp[k][m][jj]%mod*i%mod*C[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d%d\",&N,&M);\n\tprintf(\"%d\\n\",int((dp[N][M][0]+dp[N][M][1])*inv[N]%mod));\n\tscanf(\"%d\",&N);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2600", "interactive": false}