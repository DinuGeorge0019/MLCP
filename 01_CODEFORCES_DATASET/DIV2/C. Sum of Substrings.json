{
    "link": "https://codeforces.com//contest/1691/problem/C",
    "problemId": "1416259",
    "problem_idx": "C",
    "shortId": "1691C",
    "contest_number": "1691",
    "problem_submissions": {
        "F": [
            159037796,
            159004862,
            159045351,
            159041486,
            159074626,
            159060003,
            159067904,
            159020729,
            159065774,
            159064237,
            159068264,
            159063969,
            159078050,
            159063182,
            159071648,
            159076943,
            159063472,
            159076016,
            159077857
        ],
        "B": [
            159027507,
            159038230,
            158993583,
            158988023,
            158992996,
            158994717,
            158998069,
            158998926,
            158995615,
            158994699,
            158990804,
            158993808,
            158998565,
            158999263,
            158993130,
            158999935,
            158995666,
            158999458,
            158995141
        ],
        "C": [
            159022549,
            159035573,
            159003255,
            159002225,
            159000529,
            159011268,
            159008002,
            159028212,
            159004618,
            159012184,
            158998251,
            159004574,
            159008883,
            159022667,
            159090832,
            159011554,
            159006572,
            159005346,
            159010957,
            159006486
        ],
        "D": [
            159013958,
            159031555,
            159015433,
            159028094,
            159016632,
            159019611,
            159021146,
            159042470,
            159021759,
            159030292,
            159022623,
            159025372,
            159146607,
            159023715,
            159047830,
            159026170,
            159023572,
            159028563,
            159187233,
            159031404,
            159022310
        ],
        "E": [
            159000396,
            159018557,
            159029594,
            159057177,
            159032015,
            159039937,
            159038189,
            159062074,
            159045617,
            159045245,
            159054013,
            159039162,
            209514948,
            209514832,
            209514807,
            159105644,
            159105615,
            159105572,
            159105377,
            159104884,
            159097312,
            159096514,
            159095571,
            159042066,
            159035791,
            159048242,
            159046117,
            159052677,
            159191233,
            159190974,
            159179554,
            159054650,
            159057264
        ],
        "A": [
            158985679,
            159039068,
            158986800,
            158984482,
            158984538,
            158986015,
            158985132,
            158992280,
            158986339,
            158985193,
            158984622,
            158989832,
            158990669,
            158984543,
            158985817,
            158988085,
            158998809,
            158987967
        ]
    },
    "name": "C. Sum of Substrings",
    "statement": "You are given a binary string s of length n.Let’s define d_i as the\r\nnumber whose decimal representation is s_i s_{i+1} (possibly, with a\r\nleading zero). We define f(s) to be the sum of all the valid d_i. In\r\nother words, f(s) =\r\nsum\r\nlimits_{i=1}^{n-1} d_i.For example, for the string s = 1011: d_1 = 10\r\n(ten); d_2 = 01 (one) d_3 = 11 (eleven); f(s) = 10 + 01 + 11 = 22. In\r\none operation you can swap any two adjacent elements of the string. Find\r\nthe minimum value of f(s) that can be achieved if at most k operations\r\nare allowed.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == '-', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, K, lpos[N], rpos[N];\nchar s[N];\nll tot = 0;\n\nvoid solve() {\n\tn = in, K = in; tot = 0; scanf(\"%s\", s + 1);\n\trep(i, 0, 9) lpos[i] = rpos[i] = 0;\n\trep(i, 1, n) {\n\t\tint x = s[i] - '0'; tot += x;\n\t\tlpos[x] = lpos[x] ? lpos[x] : i;\n\t\trpos[x] = i;\n\t}\n\ttot *= 11; ll ans = tot;\n\trep(x, 0, 9)\n\t\trep(y, 0, 9) if(lpos[x] && rpos[y]) {\n\t\tint a = lpos[x], b = rpos[y];\n\t\tif(a == b) continue;\n\t\tint oper = a - 1 + n - b - (a > b);\n\t\tif(oper <= K) chkmin(ans, tot - x - y * 10);\n\t} // two\n\trep(x, 0, 9) if(lpos[x]) {\n\t\tint oper = lpos[x] - 1;\n\t\tif(oper <= K) chkmin(ans, tot - x);\n\t}\n\trep(x, 0, 9) if(rpos[x]) {\n\t\tint oper = n - rpos[x];\n\t\tif(oper <= K) chkmin(ans, tot - x * 10);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "math",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Sum of Substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/103212",
    "editorial": "We can observe that for any string , can also be written as: In the\r\nabove equation, is the integral face value of the character of the\r\nstring . We came to this equation by observing what character is\r\ncontributing to the value of . If the character is a â1â, it will\r\ncontribute a value of 1 to and a value of 10 to .Now, in order to\r\nminimize the value of , we would want to put the 1s at position first,\r\nthen at position and then anywhere in the middle of the string. In order\r\nto achieve the best configuration in at max operations, we will try to\r\nmove the last â1â at position first, then with the remaining operations,\r\nwe will try to move the first â1â at position 1. The remaining 1s can\r\nstay where they are as they will anyways be contributing a value of no\r\nmatter which position they take.\r\n",
    "hint": [
        "Hint 1 What is the contribution of each 1 ?",
        "Hint 2 At what position would 1 contribute less?"
    ]
}