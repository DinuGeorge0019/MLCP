{
    "link": "https://codeforces.com//contest/1185/problem/E",
    "problemId": "360325",
    "problem_idx": "E",
    "shortId": "1185E",
    "contest_number": "1185",
    "problem_submissions": {
        "G2": [
            55788875,
            55790981,
            55805220,
            55805211,
            55805181,
            55805110,
            55805072,
            55792804,
            55790893,
            55798346,
            55839723
        ],
        "F": [
            55780405,
            55784226,
            55779797,
            55790435,
            55783948,
            55774453,
            55775306,
            55787301,
            55787239,
            55780510,
            55776902,
            55778347,
            55775969,
            55787695,
            55787943,
            55780581,
            55779230,
            55782760,
            55786882,
            55789076
        ],
        "G1": [
            55775590,
            55777444,
            55773026,
            55772290,
            55770464,
            55777149,
            55766017,
            55779783,
            55780697,
            55775163,
            55781086,
            55781273,
            55783475,
            55770087,
            55781658,
            55783057,
            55787570,
            55776249,
            55782788,
            55780634
        ],
        "E": [
            55773709,
            55771675,
            55770836,
            55777430,
            55780309,
            55781282,
            55788835,
            55774037,
            55773565,
            55789637,
            55786175,
            55787728,
            55781452,
            55776381,
            55777447,
            55775569,
            55774578,
            55788543,
            55772414,
            55777859
        ],
        "D": [
            55764805,
            55765160,
            55763333,
            55764561,
            55767970,
            55767077,
            55763517,
            55765643,
            55766955,
            55766963,
            55766612,
            55765495,
            55757519,
            55767392,
            55769540,
            55767234,
            55769033,
            55770802,
            55765015,
            55772029
        ],
        "C1": [
            55760617,
            55761184,
            55760176,
            55760890,
            55765300,
            55759868,
            55766915,
            55759835,
            55763415,
            55762227,
            55760086,
            55765957,
            55763972,
            55762753,
            55765982,
            55761920,
            55763575,
            55762040,
            55779786,
            55761686
        ],
        "C2": [
            55760448,
            55761127,
            55759974,
            55760758,
            55765213,
            55759811,
            55767080,
            55761513,
            55763197,
            55762148,
            55760260,
            55762050,
            55763657,
            55765005,
            55765960,
            55761757,
            55779613,
            55763567,
            55779964,
            55761855
        ],
        "B": [
            55757432,
            55757400,
            55757118,
            55756714,
            55760856,
            55756979,
            55757746,
            55757494,
            55758775,
            55757209,
            55756807,
            55758385,
            55768633,
            55758969,
            55760948,
            55757700,
            55756899,
            55760037,
            55759228,
            55756676
        ],
        "A": [
            55755278,
            55754991,
            55754916,
            55754981,
            55758172,
            55754952,
            55755176,
            55754923,
            55755064,
            55755117,
            55755166,
            55754951,
            55770975,
            55755955,
            55755304,
            55755094,
            55755216,
            55755238,
            55756678,
            55754929
        ]
    },
    "name": "E. Polycarp and Snakes",
    "statement": "After a hard-working week Polycarp prefers to have fun. Polycarp\u2019s\r\nfavorite entertainment is drawing snakes. He takes a rectangular\r\ncheckered sheet of paper of size n\r\ntimes m (where n is the number of rows, m is the number of columns) and\r\nstarts to draw snakes in cells.Polycarp draws snakes with lowercase\r\nLatin letters. He always draws the first snake with the symbol \u201d, the\r\nsecond snake with the symbol \u201d, the third snake with the symbol \u201d and so\r\non. All snakes have their own unique symbol. There are only 26 letters\r\nin the Latin alphabet, Polycarp is very tired and he doesn\u2019t want to\r\ninvent new symbols, so the total number of drawn snakes doesn\u2019t exceed\r\n26.Since by the end of the week Polycarp is very tired, he draws snakes\r\nas straight lines without bends. So each snake is positioned either\r\nvertically or horizontally. Width of any snake equals 1, i.e. each snake\r\nhas size either 1\r\ntimes l or l\r\ntimes 1, where l is snake\u2019s length. Note that snakes can\u2019t bend.When\r\nPolycarp draws a new snake, he can use already occupied cells for\r\ndrawing the snake. In this situation, he draws the snake \"over the top\"\r\nand overwrites the previous value in the cell.Recently when Polycarp was\r\nat work he found a checkered sheet of paper with Latin letters. He wants\r\nto know if it is possible to get this sheet of paper from an empty sheet\r\nby drawing some snakes according to the rules described above. If it is\r\npossible, he is interested in a way to draw snakes.\r\n",
    "solutions": [
        "///Mn kotr el labawy mb2t4 nawy\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<pair<int,int>> go[26];\nchar grid[2005][2005];\nint n, m;\nvector<int>snakes[26];\nint main(){\n  ios_base::sync_with_stdio(0);cin.tie(0);\n\n  int t;  cin >> t;\n\n  while(t--){\n\n    cin >> n >> m;\n    for(int k=0;k<26;k++)go[k].clear(),snakes[k].clear();\n    for(int i=0;i<n;i++){\n      for(int j = 0; j < m; j++){\n        cin >> grid[i][j];\n        if(isalpha(grid[i][j]))\n          go[grid[i][j]-'a'].push_back(make_pair(i,j));\n      }\n    }\n    int mx = -1;\n    bool ok = true;\n    for(int k = 0; k < 26 && ok; k++){\n      if(go[k].empty())continue;\n      set<int>r,c;\n      for(auto x:go[k])\n        r.insert(x.first),c.insert(x.second);\n      if(r.size()!=1&&c.size()!=1){\n        ok = false;\n        break;\n      }\n      mx = k;\n      if(r.size()==1&&c.size()==1){\n        snakes[k]={*r.begin(),*c.begin(),*r.begin(),*c.begin()};\n        continue;\n      }\n      if(r.size()==1){\n        int a = *c.begin();\n        int b = *c.rbegin();\n        snakes[k]={*r.begin(),a,*r.begin(),b};\n        for(int i = a; i <= b; i++){\n          if(grid[*r.begin()][i] =='.'){\n            ok=false;\n            break;\n          } else if(grid[*r.begin()][i] != char('a'+k)){\n            ///this is covered by that\n            ok &= (grid[*r.begin()][i] > char('a'+k));\n          }\n        }\n      } else {\n        int a = *r.begin();\n        int b = *r.rbegin();\n        snakes[k]={a,*c.begin(),b,*c.begin()};\n        for(int i = a; i <= b; i++){\n          if(grid[i][*c.begin()] =='.'){\n            ok=false;\n            break;\n          } else if(grid[i][*c.begin()] != char('a'+k)){\n            ///this is covered by that\n            ok &= (grid[i][*c.begin()] > char('a'+k));\n          }\n        }\n      }\n    }\n    if(!ok){\n      cout << \"NO\\n\";\n    } else {\n      cout << \"YES\\n\";\n      cout << mx + 1 << '\\n';\n      for(int i = 0; i <= mx; i++){\n        if(go[i].empty())\n        snakes[i] = {snakes[mx][0],snakes[mx][1],snakes[mx][0],snakes[mx][1]};\n        auto x = snakes[i];\n        cout << x[0]+1 << \" \" << x[1]+1 << \" \" << x[2]+1 << \" \" << x[3]+1 << \"\\n\";\n      }\n    }\n  }\n\n\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Polycarp and Snakes.json",
    "editorial_link": "https://codeforces.com//blog/entry/67829",
    "editorial": "Remember, that Polycarp draws snakes in alphabetic order.Firstly we\r\nshould find the most top left and the most bottom right occurrences of\r\neach letter.Secondly we should walk by these letters from \u00e2\u0080\u009d to \u00e2\u0080\u009d. We\r\nwill skip first not found letters. If for any letter both length and\r\nwidth are larger than , there is no way to draw snakes. Otherwise we\r\nshould check that all elements in the line equals current letter or \u00e2\u0080\u009d.\r\nIf it\u00e2\u0080\u0099s so, let\u00e2\u0080\u0099s overdraw this line with \u00e2\u0080\u009d and move on to the next\r\nletter. If it\u00e2\u0080\u0099s not so, there is no way to draw snakes.If there is the\r\nanswer, for each snake we can output coordinates of the most top left\r\nand the most bottom right occurrences of relevant letter. If there is no\r\noccurrences for some letter, we can suppose that the next letter fully\r\noverdrew the current letter. Totally we can solve the task, walking by\r\nfield no more than ones.\r\n"
}