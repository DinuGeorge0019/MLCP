{
    "link": "https://codeforces.com//contest/1888/problem/F",
    "problemId": "2278994",
    "problem_idx": "F",
    "shortId": "1888F",
    "contest_number": "1888",
    "problem_submissions": {
        "F": [
            229262682,
            229268295,
            229279653,
            229267586,
            229284334,
            229285219,
            229276083,
            229277377,
            229286489,
            229272406,
            229252945,
            229288627,
            229285987,
            229284770,
            229272187,
            229286826,
            229310887,
            229370513,
            229258123
        ],
        "E": [
            229238149,
            229253666,
            229242208,
            229240816,
            229251553,
            229257846,
            229263590,
            229246780,
            229256433,
            229260591,
            229262076,
            229254649,
            229262399,
            229264412,
            229251739,
            229252208,
            229245030,
            229246776,
            229279792,
            229232132
        ],
        "D1": [
            229222092,
            229223803,
            229219681,
            229242098,
            229224322,
            229226334,
            229230293,
            229225358,
            229225894,
            229221773,
            229390860,
            229390801,
            229280774,
            229219651,
            229226571,
            229247689,
            229239543,
            229239851,
            229221782,
            229224303,
            229234438,
            229241304
        ],
        "D2": [
            229221620,
            229240091,
            229246606,
            229255361,
            229242055,
            229240834,
            229234843,
            229232629,
            229235145,
            229252762,
            229279873,
            229223341,
            229239577,
            229247845,
            229239473,
            229239980,
            229230893,
            229230000,
            229249174
        ],
        "C": [
            229213092,
            229215650,
            229211600,
            229221568,
            229217105,
            229211091,
            229222386,
            229215704,
            229220556,
            229215982,
            229217769,
            229237908,
            229219310,
            229234524,
            229356337,
            229293687,
            229216398,
            229217719,
            229216289,
            229211094
        ],
        "B": [
            229206630,
            229208842,
            229207631,
            229222626,
            229213726,
            229207125,
            229214934,
            229208511,
            229211534,
            229208329,
            229211710,
            229231180,
            229214082,
            229214817,
            229207834,
            229209367,
            229209606,
            229206410,
            229208095,
            229206540
        ],
        "A": [
            229204153,
            229204837,
            229204508,
            229215610,
            229209518,
            229204005,
            229205998,
            229204440,
            229204217,
            229204234,
            229205240,
            229226330,
            229204261,
            229205698,
            229204405,
            229204097,
            229205791,
            229203960,
            229211403,
            229235978
        ]
    },
    "name": "F. Minimum Array",
    "statement": "Given an array a of length n consisting of integers. Then the following\r\noperation is sequentially applied to it q times: Choose indices l and r\r\n(1\r\nle l\r\nle r\r\nle n) and an integer x; Add x to all elements of the array a in the\r\nsegment [l, r]. More formally, assign a_i := a_i + x for all l\r\nle i\r\nle r.Let b_j be the array a obtained after applying the first j\r\noperations (0\r\nle j\r\nle q). Note that b_0 is the array a before applying any operations.You\r\nneed to find the lexicographically minimum^{\r\ndagger} array among all arrays b_j.^{\r\ndagger}An array x is lexicographically smaller than array y if there is\r\nan index i such that x_i < y_i, and x_j = y_j for all j < i. In other\r\nwords, for the first index i where the arrays differ, x_i < y_i.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<cstdio>\n#include<vector>\nint read(){\n\tint x=0,tp=1;\n\tchar ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-')tp=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();\n\treturn x*tp;\n}\ntypedef long long ll;\nvoid write(ll x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+48);\n\treturn;\n}\nconst int maxn=5e5+5;\nstruct node{\n\tint l,r;\n\tll mi,mx,tag;\n}tree[maxn*4];\nvoid build(int i,int l,int r){\n\ttree[i].l=l,tree[i].r=r,tree[i].mi=tree[i].mx=0,tree[i].tag=0;\n\tif(l==r)return;\n\tint mid=(l+r)>>1;\n\tbuild(i*2,l,mid),build(i*2+1,mid+1,r);\n\treturn;\n}\nvoid update(int i){\n\ttree[i].mi=std::min(tree[i*2].mi,tree[i*2+1].mi);\n\ttree[i].mx=std::max(tree[i*2].mx,tree[i*2+1].mx);\n\treturn;\n}\nvoid put(int x,ll v){\n\ttree[x].mi+=v,tree[x].mx+=v,tree[x].tag+=v;\n\treturn;\n}\nvoid pushdown(int x){\n\tif(tree[x].tag)put(x*2,tree[x].tag),put(x*2+1,tree[x].tag),tree[x].tag=0;\n\treturn;\n}\nvoid modify(int i,int l,int r,int v){\n//\tif(i==1)printf(\"modify:%d,%d,%d\\n\",l,r,v);\n\tif(tree[i].l>=l&&tree[i].r<=r){\n//\t\tprintf(\"put:%d,%d\\n\",i,v);\n\t\tput(i,v);\n\t\treturn;\n\t}\n\tpushdown(i);\n\tif(tree[i*2].r>=l)modify(i*2,l,r,v);\n\tif(tree[i*2+1].l<=r)modify(i*2+1,l,r,v);\n\tupdate(i);\n\treturn;\n}\nint go(int i){\n\tif(tree[i].l==tree[i].r)return tree[i].l;\n//\tprintf(\"{%d,%d,%lld,%lld}\\n\",tree[i].l,tree[i].r,tree[i].mi,tree[i].mx);\n\tpushdown(i);\n\tif(tree[i*2].mx==0&&tree[i*2].mi==0)return go(i*2+1);\n\telse return go(i*2);\n}\nll point(int i,int wz){\n\tif(tree[i].l==tree[i].r)return tree[i].mi;\n\tpushdown(i);\n\tif(tree[i*2].r>=wz)return point(i*2,wz);\n\telse return point(i*2+1,wz);\n}\nint t;\nint n,q;\nll a[maxn];\nint ml[maxn],mr[maxn],mv[maxn];\nll sum[maxn];\nsigned main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tt=read();\n\tfor(int wc=1;wc<=t;wc++){\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),sum[i]=0;\n\t\tbuild(1,1,n);\n\t\tq=read();\n\t\tint last=0;\n\t\tfor(int i=1;i<=q;i++){\n\t\t\tml[i]=read(),mr[i]=read(),mv[i]=read(),modify(1,ml[i],mr[i],mv[i]);\n\t\t\tif(tree[1].mx==0&&tree[1].mi==0)continue;\n\t\t\tint p=go(1);\n\t\t\tif(point(1,p)<0){\n\t\t\t\tfor(int j=last+1;j<=i;j++)modify(1,ml[j],mr[j],-mv[j]);\n\t\t\t\tlast=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=last;i++)sum[ml[i]]+=mv[i],sum[mr[i]+1]-=mv[i];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tsum[i]+=sum[i-1];\n\t\t\twrite(a[i]+sum[i]),putchar(' ');\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n/*\n1\n10\n0 0 0 0 0 0 0 0 0 0\n10\n1 4 -6\n4 9 3\n2 8 -5\n6 9 1\n1 3 -2\n4 5 -3\n6 9 3\n2 10 -7\n9 9 8\n1 9 9\n*/\n//namespace burningContract\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Minimum Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/121621",
    "editorial": "Let u\n be a difference array of an array v\n, i.e. u0=v0\n, ui=vi?vi?1\n for all i?1\n.\n\nNote that minimizing an array is equivalent to minimizing its difference array. Let's see how the difference array changes: when asked, adding the number add\n on the segment [l;r]\n only 2 elements are updated in it: add\n is added to the l\nth index, and add\n is subtracted from the r+1\nth index.\n\nLet's learn how to compare difference arrays after the j\nth and i\nth queries (j<i\n). Let's consider an auxiliary array, which is a union of changes in the difference array for all queries with numbers from j+1\n to i\n inclusive. Consider in this auxiliary array the minimum non-zero element by index. Note that if it is negative, then the difference array after the i\nth query will be smaller than after the j\nth one, and if it is positive, then it will be larger.\n\nLet's go through the queries and maintain the number of the minimum difference array. Let the current minimum difference array after request be number j\n. Since changes to the difference array occur only in two indexes, we can maintain them in a dictionary containing changes to the difference array by index. When we want to process the next request, we update the values in the dictionary using two keys. After the change, you need to check the sign of the minimum non-zero element by index:\n\nIf it is negative, then this means that the current request has updated the minimum, and we clear the dictionary so that we can now store changes relative to this request in it.\nIf it is positive, then we leave the dictionary the same and continue to change it in subsequent queries.\nAs a result, using the found index of the minimum difference array, we restore the array itself.",
    "hint": []
}