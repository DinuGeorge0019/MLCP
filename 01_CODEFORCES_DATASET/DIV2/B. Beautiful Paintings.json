{"link": "https://codeforces.com//contest/651/problem/B", "problemId": "50869", "problem_idx": "B", "shortId": "651B", "contest_number": "651", "problem_submissions": {"E": [16577901, 16576105, 16577885, 16579030, 16577600, 16579254, 16583684, 16612963, 16634108, 16579601, 16597899, 16582932, 16628107, 16578759], "D": [16573047, 16572719, 16574678, 16571901, 16569773, 16573081, 16571528, 16576891, 16571074, 16608055, 16590874, 16572871, 16572832, 16576303, 16574260, 16573986, 16574407, 16572633, 16573717, 16573769, 16572434], "C": [16565876, 16566691, 16563105, 16566656, 16570973, 16568950, 16566771, 16566951, 16566152, 16563979, 16567340, 16568555, 16569181, 16568020, 16565103, 16569049, 16566497, 16567339, 16568697, 16567246], "B": [16564324, 16569482, 16564950, 16565243, 16571584, 16566683, 16565016, 16565556, 16564840, 16565123, 16565306, 16566113, 16563647, 16564785, 16567065, 16568003, 16562805, 16566201, 16565282], "A": [16563044, 16565248, 16566177, 16563187, 16572713, 16564825, 16563775, 16564326, 16563005, 16562965, 16563558, 16563677, 16562755, 16562903, 16565600, 16564448, 16566878, 16565167, 16563473]}, "name": "B. Beautiful Paintings", "statement": "There are pictures delivered for the new exhibition. The -th painting\r\nhas beauty . We know that a visitor becomes happy every time he passes\r\nfrom a painting to a more beautiful one.We are allowed to arranged\r\npictures in any order. What is the maximum possible number of times the\r\nvisitor may become happy while passing all pictures from first to last?\r\nIn other words, we are allowed to rearrange elements of in any order.\r\nWhat is the maximum possible number of indices (), such that .\r\n", "solutions": ["# include <iostream>\n# include <algorithm>\n# include <cstdio>\n# include <cstdlib>\n# include <ctime>\n# include <cmath>\n# include <set>\n# include <vector>\n# include <map>\n# include <queue>\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\nmultiset<int> s;\n\nint main () {\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\ts.insert(x);\n\t}\n\tint last = 1e9;\n\tint ans = 0;\n\twhile(!s.empty()) {\n\t\tmultiset<int>::iterator ne = s.upper_bound(last);\n\t\tif(ne == s.end()) {\n\t\t\tlast = *s.begin();\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\telse {\n\t\t\tans++;\n\t\t\tlast = *ne;\n\t\t\ts.erase(s.find(last));\n\t\t}\n\t}\n\tcout << ans;\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["greedy", "sortings"], "dificulty": "1200", "interactive": false}