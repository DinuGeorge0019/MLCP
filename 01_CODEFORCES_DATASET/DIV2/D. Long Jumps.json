{
    "link": "https://codeforces.com//contest/479/problem/D",
    "problemId": "15736",
    "problem_idx": "D",
    "shortId": "479D",
    "contest_number": "479",
    "problem_submissions": {
        "A": [
            8309900,
            8302126,
            8303586,
            8301931,
            8301886,
            8303454,
            8302426,
            8303355,
            8302448,
            8301877,
            8303309,
            8302705,
            8301884,
            8303259,
            8303414,
            8319050,
            8314132,
            8301946,
            8520832
        ],
        "E": [
            8309056,
            8311803,
            8312909,
            8313438,
            8316084,
            8316020,
            8313424,
            8327786,
            8315963,
            8317334,
            8309253,
            8316559,
            8315476,
            8316804,
            8316031,
            8315095,
            8316251,
            8315450,
            8317290,
            8312971,
            8313774
        ],
        "D": [
            8307373,
            8309115,
            8309669,
            8309141,
            8311118,
            8310810,
            8314426,
            8309794,
            8310784,
            8315457,
            8313129,
            8315683,
            8314350,
            8316993,
            8315739,
            8312498,
            8311921,
            8333608,
            8316306
        ],
        "C": [
            8305195,
            8306485,
            8306619,
            8305446,
            8306856,
            8306836,
            8308389,
            8306838,
            8306950,
            8305838,
            8307233,
            8304436,
            8308183,
            8305296,
            8304427,
            8304574,
            8306220,
            8306521,
            8306064,
            8305718
        ],
        "B": [
            8304577,
            8305140,
            8304920,
            8353901,
            8304212,
            8303937,
            8306178,
            8306010,
            8306262,
            8305338,
            8304463,
            8306364,
            8309399,
            8307051,
            8303801,
            8309094,
            8310340,
            8304911,
            8313716,
            8303910,
            8520830
        ]
    },
    "name": "D. Long Jumps",
    "statement": "Valery is a PE teacher at a school in Berland. Soon the students are\r\ngoing to take a test in long jumps, and Valery has lost his favorite\r\nruler! However, there is no reason for disappointment, as Valery has\r\nfound another ruler, its length is centimeters. The ruler already has\r\nmarks, with which he can make measurements. We assume that the marks are\r\nnumbered from 1 to in the order they appear from the beginning of the\r\nruler to its end. The first point coincides with the beginning of the\r\nruler and represents the origin. The last mark coincides with the end of\r\nthe ruler, at distance from the origin. This ruler can be repesented by\r\nan increasing sequence , where denotes the distance of the -th mark from\r\nthe origin (, ).Valery believes that with a ruler he can measure the\r\ndistance of centimeters, if there is a pair of integers and (), such\r\nthat the distance between the -th and the -th mark is exactly equal to\r\n(in other words, ). Under the rules, the girls should be able to jump at\r\nleast centimeters, and the boys should be able to jump at least ()\r\ncentimeters. To test the children\u2019s abilities, Valery needs a ruler to\r\nmeasure each of the distances and . Your task is to determine what is\r\nthe minimum number of additional marks you need to add on the ruler so\r\nthat they can be used to measure the distances and . Valery can add the\r\nmarks at any integer non-negative distance from the origin not exceeding\r\nthe length of the ruler.\r\n",
    "solutions": [
        "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<cstring>\n#define rep(i,a,b) for (int i=a;i<=b;++i)\n#define dep(i,a,b) for (int i=a;i>=b;--i)\n#define For(i,u) for (int i=H[u];i;i=nxt[i])\n#define re(i,x) for (i=x.begin();i!=x.end();++i)\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 100005\n#define X first\n#define Y second\nusing namespace std;\ntemplate<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x=-x;};\ntemplate<class T> inline void read(T&x,T&y){read(x);read(y);}\ntemplate<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}\ntypedef long long ll;\ntypedef pair<int,int> pii;\n//head\nset<int> S;\nint n,a[N],x,y,L;\nbool check(int p){\n    rep(i,1,n)if(S.count(a[i]-p))return 1;\n    return 0;\n}\nint find(){\n    rep(i,1,n) {\n        if (a[i]+x<=L&&(S.count(a[i]+x+y)||S.count(a[i]+x-y))) return a[i]+x;\n        if (a[i]-x>=0&&(S.count(a[i]-x+y)||S.count(a[i]-x-y))) return a[i]-x;\n    }\n    return -1;\n}\nint main() {\n    read(n,L);read(x,y);rep(i,1,n)read(a[i]),S.insert(a[i]);\n    int t1=check(x),t2=check(y);\n    if(t1&&t2)puts(\"0\");\n    else if(t1&&!t2)printf(\"1\\n%d\\n\",y);\n    else if(!t1&&t2)printf(\"1\\n%d\\n\",x);\n    else{\n        int p=find();\n        if(p==-1)printf(\"2\\n%d %d\\n\",x,y);\n        else printf(\"1\\n%d\\n\",p);\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Long Jumps.json",
    "editorial_link": "https://codeforces.com//blog/entry/14351",
    "editorial": "It is easy to see that the answer is always 0, 1 or 2. If we can already\r\nmeasure both and , output 0. Then try to measure both and by adding one\r\nmore mark. If it was not successful, print two marks: one at , other at\r\n. So, how to check if the answer is 1? Consider all existing marks. Let\r\nsome mark be at . Try to add the new mark in each of the following\r\npositions: , , , . If it become possible to measure both and , you have\r\nfound the answer. It is easy to check this: if, for example, we are\r\ntrying to add the mark at , we just check if there is a mark at or (by a\r\nbinary search, since the marks are sorted). Make sure that the adde\r\nmarks are in .\r\n"
}