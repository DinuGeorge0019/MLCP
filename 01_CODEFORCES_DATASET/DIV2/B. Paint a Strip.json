{
    "link": "https://codeforces.com//contest/2040/problem/B",
    "problemId": "3075496",
    "problem_idx": "B",
    "shortId": "2040B",
    "contest_number": "2040",
    "problem_submissions": {
        "E": [
            295634858,
            295598220,
            295603659,
            295602852,
            295609062,
            295608956,
            295609438,
            295613265,
            295617536,
            295622256,
            295615426,
            295623087,
            295613034,
            295632243,
            295615757,
            295623729,
            295822197,
            295614576,
            295629623,
            295677087,
            295677053,
            295616459,
            295615739
        ],
        "F": [
            295625297,
            295602948,
            295765575,
            295764437,
            295628810,
            295613638,
            295772184
        ],
        "C": [
            295613817,
            295578002,
            295582361,
            295582510,
            295585319,
            295585121,
            295589541,
            295584238,
            295583765,
            295584198,
            295582424,
            295585127,
            295590138,
            295581996,
            295587456,
            295580712,
            295586116,
            295581622,
            295590178,
            295583863
        ],
        "D": [
            295602955,
            295588244,
            295593423,
            295591690,
            295596226,
            295661257,
            295596632,
            295595711,
            295594858,
            295602270,
            295597697,
            295602059,
            295598368,
            295600419,
            295605426,
            295590011,
            295601199,
            295607620
        ],
        "B": [
            295586789,
            295590381,
            295574073,
            295576257,
            295574329,
            295574189,
            295580781,
            295572257,
            295573109,
            295573299,
            295575453,
            295572099,
            295577165,
            295593436,
            295571846,
            295572279,
            295571755,
            295574449,
            295577717,
            295572094
        ],
        "A": [
            295581636,
            295569030,
            295573127,
            295568276,
            295571294,
            295574905,
            295568027,
            295568114,
            295567840,
            295567999,
            295568293,
            295568412,
            295569901,
            295568913,
            295567935,
            295568054,
            295568783,
            295570941,
            295568578
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137074",
    "editorial": "At each moment of time, the array contains a number of non-intersecting\r\nsegments consisting only of ones. Using an operation of the first type\r\ncan increase the number of these segments by . Using an operation of the\r\nsecond type decreases the number of these segments by , where is the\r\nnumber of segments that this operation covers. Therefore, the number of\r\noperations of the second type is no more than the number of operations\r\nof the first type minus .The optimal strategy is to perform one\r\noperation of the first type, and then alternate operations of the first\r\nand second types, increasing the number of ones from to on each such\r\npair of operations. There is no point in doing more operations of the\r\nfirst type on the prefix of operations, since we still must cover no\r\nmore than two segments of ones with operations of the second type;\r\notherwise, we will reduce the possible number of operations of the\r\nsecond type.\r\n",
    "name": "B. Paint a Strip",
    "statement": "You have an array of a_1, a_2,\r\nldots, a_n of length n.You can perform two types of operations on it:\r\nChoose an index i such that 1\r\nle i\r\nle n and a_i = 0, and assign 1 to a_i; Choose a pair of indices l and r\r\nsuch that 1\r\nle l\r\nle r\r\nle n, a_l = 1, a_r = 1, a_l +\r\nldots + a_r\r\nge\r\nlceil\r\nfrac{r - l + 1}{2}\r\nrceil, and assign 1 to a_i for all l\r\nle i\r\nle r. What is the minimum number of operations of the needed to make all\r\nelements of the array equal to one?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>; constexpr int MOD = 1e9 + 7;constexpr int INF = 1e9;constexpr ll LINF = 1e18;constexpr ld EPS = 1e-9; #define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define pb push_back#define eb emplace_back#define fi first#define se second#define sz(x) ((int)(x).size())#define dbg(x) cerr << #x << \" = \" << (x) << '\\n' void solve() {    ll n;    cin >> n;    if(n==1){        cout << 1 << \"\\n\";        return;    }    ll k = 1;    while(true){        ll res = 3LL*((ll)1 << (k-1)) - 2;        if(res>=n) {cout << k << \"\\n\"; break;}        k++;    } } int main() {    fast_io();    int t = 1;    cin >> t;    while (t--) solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Paint a Strip.json",
    "hint": []
}