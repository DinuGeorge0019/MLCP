{"link": "https://codeforces.com//contest/631/problem/D", "problemId": "50475", "problem_idx": "D", "shortId": "631D", "contest_number": "631", "problem_submissions": {"D": [16497522, 16499633, 16493773, 16494892, 16499612, 16496131, 16500541, 16496189, 16496051, 16496096, 16496795, 16496029, 16497137, 16492337, 16499122, 16499237, 16493359, 16497887], "B": [16495030, 16489061, 16486659, 16487643, 16488029, 16489630, 16489917, 16489099, 16489411, 16488403, 16487977, 16488126, 16487679, 16488914, 16488419, 16487198, 16487289, 16490683, 16488019, 16489321], "A": [16494676, 16486534, 16486041, 16486092, 16486307, 16490385, 16486724, 16487325, 16488701, 16486887, 16486812, 16486989, 16486391, 16488010, 16486032, 16486094, 16486005, 16486116, 16486446, 16486353], "E": [16494439, 16497634, 16498079, 16498605, 16510405, 16640523, 34966720], "C": [16487628, 16491468, 16495480, 16491148, 16494024, 16488408, 16494546, 16492668, 16492714, 16493264, 16490967, 16493139, 16492497, 16492510, 16493001, 16497861, 16491052, 16495036, 16496778, 16492352]}, "name": "D. Messenger", "statement": "Each employee of the \"Blake Techologies\" company uses a special\r\nmessaging app \"Blake Messenger\". All the stuff likes this app and uses\r\nit constantly. However, some important futures are missing. For example,\r\nmany users want to be able to search through the message history. It was\r\nalready announced that the new feature will appear in the nearest\r\nupdate, when developers faced some troubles that only you may help them\r\nto solve.All the messages are represented as a strings consisting of\r\nonly lowercase English letters. In order to reduce the network load\r\nstrings are represented in the special compressed form. Compression\r\nalgorithm works as follows: string is represented as a concatenation of\r\nblocks, each block containing only equal characters. One block may be\r\ndescribed as a pair , where is the length of the -th block and is the\r\ncorresponding letter. Thus, the string may be written as the sequence of\r\npairs .Your task is to write the program, that given two compressed\r\nstring and finds all occurrences of in . Developers know that there may\r\nbe many such occurrences, so they only ask you to find the of them. Note\r\nthat is the starting position of some occurrence of in if and only if ,\r\nwhere is the -th character of string .Note that the way to represent the\r\nstring in compressed form may not be unique. For example string \"\" may\r\nbe given as , , ...\r\n", "solutions": ["#include <iostream>\nusing namespace std;\n\nconst int N = 200011;\ntypedef long long intl;\n\nintl lt[N];\nchar ct[N];\n\nintl ls[N];\nchar cs[N];\n\nint p[N];\n\nint main()\n{\n\tios :: sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i ++)\n\t{\n\t\tchar c;\n\t\tcin >> lt[i] >> c >> ct[i];\n\t\tif(i > 0 && ct[i] == ct[i - 1])\n\t\t{\n\t\t\tlt[i - 1] += lt[i];\n\t\t\tn --;\n\t\t\ti --;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; i ++)\n\t{\n\t\tchar c;\n\t\tcin >> ls[i] >> c >> cs[i];\n\t\tif(i > 0 && cs[i] == cs[i - 1])\n\t\t{\n\t\t\tls[i - 1] += ls[i];\n\t\t\tm --;\n\t\t\ti --;\n\t\t}\n\t}\n\tif(n < m)\n\t{\n\t\tcout << 0 << '\\n';\n\t\treturn 0;\n\t}\n\tif(m > 2)\n\t{\n\t\t//cout << n << ' ' << m << '\\n';\n\t\tn -= 2;\n\t\tm -= 2;\n\t\tint last = 0;\n\t\tp[1] = 0;\n\t\tfor(int i = 2; i <= m; i ++)\n\t\t{\n\t\t\twhile(last > 0 && (cs[i] != cs[last + 1] || ls[i] != ls[last + 1]))\n\t\t\t\tlast = p[last];\n\t\t\tif(cs[i] == cs[last + 1] && ls[i] == ls[last + 1])\n\t\t\t\tlast ++;\n\t\t\tp[i] = last;\n\t\t}\n\n\t\tint ans = 0;\n\t\tlast = 0;\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tif(last == m)\n\t\t\t\tlast = p[last];\n\t\t\twhile(last > 0 && (ct[i] != cs[last + 1] || lt[i] != ls[last + 1]))\n\t\t\t\tlast = p[last];\n\t\t\tif(ct[i] == cs[last + 1] && lt[i] == ls[last + 1])\n\t\t\t\tlast ++;\n\t\t\t//cout << i << ' ' << last << '\\n';\n\t\t\tif(last == m)\n\t\t\t{\n\t\t\t\tif(cs[m + 1] == ct[i + 1] && ls[m + 1] <= lt[i + 1]\n\t\t\t\t\t&& cs[0] == ct[i - m] && ls[0] <= lt[i - m])\n\t\t\t\t\tans ++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\telse if(m == 2)\n\t{\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n - 1; i ++)\n\t\t\tif(cs[0] == ct[i] && ls[0] <= lt[i]\n\t\t\t\t&& cs[1] == ct[i + 1] && ls[1] <= lt[i + 1])\n\t\t\t\tans ++;\n\t\tcout << ans << '\\n';\n\t}\n\telse\n\t{\n\t\tintl ans = 0;\n\t\t//cout << cs[0] << ' ' << ls[0] << '\\n';\n\t\tfor(int i = 0; i < n; i ++)\n\t\t{\n\t\t\t//cout << ct[i] << ' ' << lt[i] << '\\n';\n\t\t\tif(cs[0] == ct[i] && ls[0] <= lt[i])\n\t\t\t\tans += lt[i] - ls[0] + 1;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "hashing", "implementation", "string suffix structures", "strings"], "dificulty": "2100", "interactive": false}