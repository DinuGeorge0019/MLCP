{"link": "https://codeforces.com//contest/828/problem/F", "problemId": "113856", "problem_idx": "F", "shortId": "828F", "contest_number": "828", "problem_submissions": {"A": [28460309, 28447412, 28433654, 28431619, 28432255, 28431175, 28432122, 28431834, 28432270, 28431560, 28438332, 28431659, 28431601, 28431041, 28431462, 28431315, 28448076, 28431218, 28431027], "F": [28448238, 28470827, 28472010, 30446292, 32054149], "E": [28442480, 28440989, 28445030, 28444433, 28441533, 28446059, 28447307, 28490530, 28447795, 28447314, 28449259, 28447763, 28449409, 28448527, 28448262], "D": [28439191, 28443487, 28440542, 28439312, 28444576, 28440699, 28440733, 28440504, 28444280, 28446082, 28441981, 28439597, 28441709, 28443017, 28442903, 28439094, 28443722, 28448787, 28443893], "C": [28435698, 28435500, 28439027, 28435829, 28437161, 28436717, 28438157, 28436695, 28443065, 28454126, 28453810, 28440499, 28438924, 28437102, 28438928, 28438895, 28436411, 28440043, 28437230, 28439797, 28439825, 28439032], "B": [28433895, 28433617, 28434962, 28433706, 28433707, 28434566, 28434207, 28434454, 28435513, 28435599, 28434805, 28433677, 28435479, 28434438, 28432799, 28434943, 28434343, 28435242, 28433224, 28433253]}, "name": "F. Best Edge Weight", "statement": "You are given a connected weighted graph with vertices and edges. The\r\ngraph doesn\u2019t contain loops nor multiple edges. Consider some edge with\r\nid . Let\u2019s determine for this edge the maximum integer weight we can\r\ngive to it so that it is contained in all minimum spanning trees of the\r\ngraph if we don\u2019t change the other weights.You are to determine this\r\nmaximum weight described above for each edge. You should calculate the\r\nanswer for each edge independently, it means there can\u2019t be two edges\r\nwith changed weights at the same time.\r\n", "solutions": ["#include<bits/stdc++.h>\nint as[500007];\nint n,m,f[500007],h[500007],fe[500007];\nint gf(int x){\n\twhile(x!=f[x])x=f[x];\n\treturn x;\n}\nstruct E{\n\tint to,id;\n\tE(int a,int b):to(a),id(b){}\n};\nstd::vector<E>es[500007];\nstruct edge{\n\tint a,b,c,id;\n\tbool operator<(const edge&w)const{return c<w.c;}\n\tvoid ae(){\n\t\tes[a].push_back(E(b,id));\n\t\tes[b].push_back(E(a,id));\n\t}\n}e[500007];\nvoid mins(int&a,int b){if(a>b)a=b;}\nstd::queue<int>q;\nint fas[20][200007],dep[200007];\nint fvs[20][200007];\nvoid init(){\n\tmemset(fvs,0x7f,sizeof(fvs));\n\tq.push(1);\n\tdep[1]=1;\n\twhile(q.size()){\n\t\tint w=q.front();q.pop();\n\t\tfor(int i=0;i<es[w].size();++i){\n\t\t\tint u=es[w][i].to;\n\t\t\tif(u==fas[0][w])continue;\n\t\t\tfas[0][u]=w;\n\t\t\tdep[u]=dep[w]+1;\n\t\t\tq.push(u);\n\t\t}\n\t}\n\tfor(int i=1;i<20;++i){\n\t\tfor(int w=1;w<=n;++w)fas[i][w]=fas[i-1][fas[i-1][w]];\n\t}\n//\tfor(int w=1;w<=n;++w)printf(\"%d:%d %d\\n\",w,fas[0][w],fas[1][w]);\n}\nvoid chk(int a,int b,int c){\n//\tprintf(\"(%d %d %d)\\n\",a,b,c);\n\tif(dep[a]<dep[b])std::swap(a,b);\n\tint d=dep[a]-dep[b];\n\tfor(int i=0;d;++i,d>>=1)if(d&1){\n\t\tmins(fvs[i][a],c);\n\t\ta=fas[i][a];\n\t}\n\tif(a==b)return;\n\tfor(int i=19;i>=0;--i)if(fas[i][a]!=fas[i][b]){\n\t\tmins(fvs[i][a],c);\n\t\tmins(fvs[i][b],c);\n\t\ta=fas[i][a];\n\t\tb=fas[i][b];\n//\tprintf(\"%d(%d %d)\\n\",i,a,b);\n\t}\n//\tprintf(\"(%d %d)\\n\",a,b);\n\tmins(fvs[0][a],c);\n\tmins(fvs[0][b],c);\n}\nvoid dns(){\n\tfor(int i=18;i>=0;--i){\n\t\tfor(int w=1;w<=n;++w){\n\t\t\tint f=fas[i][w];\n\t\t\tmins(fvs[i][w],fvs[i+1][w]);\n\t\t\tmins(fvs[i][f],fvs[i+1][w]);\n\t\t}\n\t}\n\tfor(int w=1;w<=n;++w){\n\t\tfor(int i=0;i<es[w].size();++i){\n\t\t\tint u=es[w][i].to;\n\t\t\tif(u==fas[0][w]&&fvs[0][w]<0x7f7f7f7f)as[es[w][i].id]=fvs[0][w]-1;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;++i){\n\t\tas[i]=-1;\n\t\tscanf(\"%d%d%d\",&e[i].a,&e[i].b,&e[i].c);\n\t\te[i].id=i;\n\t}\n\tstd::sort(e+1,e+m+1);\n\tfor(int i=1;i<=n;++i)f[i]=i;\n\tfor(int i=1;i<=m;++i){\n\t\tint x=gf(e[i].a),y=gf(e[i].b);\n\t\tif(x==y){\n\t\t\tx=e[i].a,y=e[i].b;\n\t\t\tint mn=0;\n\t\t\twhile(x!=y){\n\t\t\t\tif(h[x]>h[y])std::swap(x,y);\n\t\t\t\tif(fe[x]>mn)mn=fe[x];\n\t\t\t\tx=f[x];\n\t\t\t}\n\t\t\tas[e[i].id]=mn-1;\n\t\t}else{\n\t\t\te[i].ae();\n\t\t\tif(h[x]<h[y])std::swap(x,y);\n\t\t\tif(h[x]==h[y])++h[x];\n\t\t\tfe[y]=e[i].c;\n\t\t\tf[y]=x;\n\t\t}\n\t}\n\tinit();\n\tfor(int i=1;i<=m;++i)if(as[e[i].id]>-1){\n\t\tchk(e[i].a,e[i].b,e[i].c);\n\t}\n\tdns();\n\tfor(int i=1;i<=m;++i)printf(\"%d \",as[i]);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "graphs"], "dificulty": "2700", "interactive": false}