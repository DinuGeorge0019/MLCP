{
    "link": "https://codeforces.com//contest/828/problem/F",
    "problemId": "113856",
    "problem_idx": "F",
    "shortId": "828F",
    "contest_number": "828",
    "problem_submissions": {
        "A": [
            28460309,
            28447412,
            28433654,
            28431619,
            28432255,
            28431175,
            28432122,
            28431834,
            28432270,
            28431560,
            28438332,
            28431659,
            28431601,
            28431041,
            28431462,
            28431315,
            28448076,
            28431218,
            28431027
        ],
        "F": [
            28448238,
            28470827,
            28472010,
            30446292,
            32054149
        ],
        "E": [
            28442480,
            28440989,
            28445030,
            28444433,
            28441533,
            28446059,
            28447307,
            28490530,
            28447795,
            28447314,
            28449259,
            28447763,
            28449409,
            28448527,
            28448262
        ],
        "D": [
            28439191,
            28443487,
            28440542,
            28439312,
            28444576,
            28440699,
            28440733,
            28440504,
            28444280,
            28446082,
            28441981,
            28439597,
            28441709,
            28443017,
            28442903,
            28439094,
            28443722,
            28448787,
            28443893
        ],
        "C": [
            28435698,
            28435500,
            28439027,
            28435829,
            28437161,
            28436717,
            28438157,
            28436695,
            28443065,
            28454126,
            28453810,
            28440499,
            28438924,
            28437102,
            28438928,
            28438895,
            28436411,
            28440043,
            28437230,
            28439797,
            28439825,
            28439032
        ],
        "B": [
            28433895,
            28433617,
            28434962,
            28433706,
            28433707,
            28434566,
            28434207,
            28434454,
            28435513,
            28435599,
            28434805,
            28433677,
            28435479,
            28434438,
            28432799,
            28434943,
            28434343,
            28435242,
            28433224,
            28433253
        ]
    },
    "name": "F. Best Edge Weight",
    "statement": "You are given a connected weighted graph with vertices and edges. The\r\ngraph doesn\u2019t contain loops nor multiple edges. Consider some edge with\r\nid . Let\u2019s determine for this edge the maximum integer weight we can\r\ngive to it so that it is contained in all minimum spanning trees of the\r\ngraph if we don\u2019t change the other weights.You are to determine this\r\nmaximum weight described above for each edge. You should calculate the\r\nanswer for each edge independently, it means there can\u2019t be two edges\r\nwith changed weights at the same time.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nint as[500007];\nint n,m,f[500007],h[500007],fe[500007];\nint gf(int x){\n\twhile(x!=f[x])x=f[x];\n\treturn x;\n}\nstruct E{\n\tint to,id;\n\tE(int a,int b):to(a),id(b){}\n};\nstd::vector<E>es[500007];\nstruct edge{\n\tint a,b,c,id;\n\tbool operator<(const edge&w)const{return c<w.c;}\n\tvoid ae(){\n\t\tes[a].push_back(E(b,id));\n\t\tes[b].push_back(E(a,id));\n\t}\n}e[500007];\nvoid mins(int&a,int b){if(a>b)a=b;}\nstd::queue<int>q;\nint fas[20][200007],dep[200007];\nint fvs[20][200007];\nvoid init(){\n\tmemset(fvs,0x7f,sizeof(fvs));\n\tq.push(1);\n\tdep[1]=1;\n\twhile(q.size()){\n\t\tint w=q.front();q.pop();\n\t\tfor(int i=0;i<es[w].size();++i){\n\t\t\tint u=es[w][i].to;\n\t\t\tif(u==fas[0][w])continue;\n\t\t\tfas[0][u]=w;\n\t\t\tdep[u]=dep[w]+1;\n\t\t\tq.push(u);\n\t\t}\n\t}\n\tfor(int i=1;i<20;++i){\n\t\tfor(int w=1;w<=n;++w)fas[i][w]=fas[i-1][fas[i-1][w]];\n\t}\n//\tfor(int w=1;w<=n;++w)printf(\"%d:%d %d\\n\",w,fas[0][w],fas[1][w]);\n}\nvoid chk(int a,int b,int c){\n//\tprintf(\"(%d %d %d)\\n\",a,b,c);\n\tif(dep[a]<dep[b])std::swap(a,b);\n\tint d=dep[a]-dep[b];\n\tfor(int i=0;d;++i,d>>=1)if(d&1){\n\t\tmins(fvs[i][a],c);\n\t\ta=fas[i][a];\n\t}\n\tif(a==b)return;\n\tfor(int i=19;i>=0;--i)if(fas[i][a]!=fas[i][b]){\n\t\tmins(fvs[i][a],c);\n\t\tmins(fvs[i][b],c);\n\t\ta=fas[i][a];\n\t\tb=fas[i][b];\n//\tprintf(\"%d(%d %d)\\n\",i,a,b);\n\t}\n//\tprintf(\"(%d %d)\\n\",a,b);\n\tmins(fvs[0][a],c);\n\tmins(fvs[0][b],c);\n}\nvoid dns(){\n\tfor(int i=18;i>=0;--i){\n\t\tfor(int w=1;w<=n;++w){\n\t\t\tint f=fas[i][w];\n\t\t\tmins(fvs[i][w],fvs[i+1][w]);\n\t\t\tmins(fvs[i][f],fvs[i+1][w]);\n\t\t}\n\t}\n\tfor(int w=1;w<=n;++w){\n\t\tfor(int i=0;i<es[w].size();++i){\n\t\t\tint u=es[w][i].to;\n\t\t\tif(u==fas[0][w]&&fvs[0][w]<0x7f7f7f7f)as[es[w][i].id]=fvs[0][w]-1;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;++i){\n\t\tas[i]=-1;\n\t\tscanf(\"%d%d%d\",&e[i].a,&e[i].b,&e[i].c);\n\t\te[i].id=i;\n\t}\n\tstd::sort(e+1,e+m+1);\n\tfor(int i=1;i<=n;++i)f[i]=i;\n\tfor(int i=1;i<=m;++i){\n\t\tint x=gf(e[i].a),y=gf(e[i].b);\n\t\tif(x==y){\n\t\t\tx=e[i].a,y=e[i].b;\n\t\t\tint mn=0;\n\t\t\twhile(x!=y){\n\t\t\t\tif(h[x]>h[y])std::swap(x,y);\n\t\t\t\tif(fe[x]>mn)mn=fe[x];\n\t\t\t\tx=f[x];\n\t\t\t}\n\t\t\tas[e[i].id]=mn-1;\n\t\t}else{\n\t\t\te[i].ae();\n\t\t\tif(h[x]<h[y])std::swap(x,y);\n\t\t\tif(h[x]==h[y])++h[x];\n\t\t\tfe[y]=e[i].c;\n\t\t\tf[y]=x;\n\t\t}\n\t}\n\tinit();\n\tfor(int i=1;i<=m;++i)if(as[e[i].id]>-1){\n\t\tchk(e[i].a,e[i].b,e[i].c);\n\t}\n\tdns();\n\tfor(int i=1;i<=m;++i)printf(\"%d \",as[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Best Edge Weight.json",
    "editorial_link": "https://codeforces.com//blog/entry/53268",
    "editorial": "Hint 1: Find some MST in the initial graph and name it M. Now there are edges of two types: in the tree, and not in the tree. Process them in a different way.\n\nHint 2: For edges not in the MST, the answer is the maximum weight of MST edges on the path between the edge's ends, minus one.\n\nProof: Consider the edge E such that it doesn't appear in our MST and its weight is W and consider the maximum weight of MST edges on the path between the edge's ends is MX.\n\nIt's obvious that if W???MX there is an MST such that E will not appear in that (at least it will not appear in M).\n\nNow let's prove that if W?=?MX?-?1 it will appear in any MST. Consider an MST like OM that E does not appear in that, let's prove M was not an MST and it's a contradiction. Let ends of E be v,?u. Look, consider the path between v,?u in M, there is an edge with weight MX in this path but there isn't any edge in OM with weight greater than or equal to MX. So M is not an MST because when we build an MST we sort edges by their weight and add them greedily (Kruskal's algorithm).\n\nHint 3: For an edge E in the MST, let non-MST edges such that MST path between their ends go through E be bad edges, the answer is the minimum weight of bad edges, minus one.\n\nProof: Let the minimum weight of bad edges be CW and weight of E be W. It is obvious that if W???CW there is an MST such that E will not appear in that. Now if W?<?CW so we will check E before bad edges and we will add it.\n\nThe remaining part is easy: for non-MST edges, one can just query the maximum on a tree path with binary lifts or whatever other structure on a tree. For MST edges, we can do the same, but in the other direction, like range queries, or even easier with centroid decomposition, HLD or using sets and the smaller-to-larger optimization."
}