{
    "link": "https://codeforces.com//contest/1139/problem/F",
    "problemId": "317131",
    "problem_idx": "F",
    "shortId": "1139F",
    "contest_number": "1139",
    "problem_submissions": {
        "F": [
            51641186,
            51646762,
            109435140,
            51647787,
            51858420,
            51784923,
            51643584,
            51652352
        ],
        "E": [
            51636168,
            51644116,
            51640560,
            51642622,
            51644323,
            51644757,
            51643892,
            51845610,
            51647025,
            51647374,
            51647485,
            51647776,
            51635005,
            51638235,
            51639153,
            51639250,
            51638517,
            72001197,
            51662877
        ],
        "D": [
            51642032,
            51635420,
            51636603,
            51637368,
            51636440,
            51639381,
            51643782,
            51845601,
            51642527,
            51640197,
            51643918,
            51642858,
            51827413,
            51649480,
            51908875,
            51638589,
            51637429
        ],
        "C": [
            51630148,
            51629252,
            51628342,
            51628293,
            51633819,
            51633228,
            51629514,
            51845597,
            51631001,
            51631632,
            51635078,
            51636507,
            51631091,
            51631860,
            51631510,
            51630390,
            51632287,
            51636060,
            51629126,
            51630229
        ],
        "B": [
            51627583,
            51626711,
            51625352,
            51626461,
            51626658,
            51627929,
            51626015,
            51845593,
            51628451,
            51628233,
            51627332,
            51628138,
            51627935,
            51626813,
            51626814,
            51626137,
            51629187,
            51627498,
            51626295,
            51627320
        ],
        "A": [
            51623887,
            51624025,
            51623702,
            51623814,
            51624826,
            51624571,
            51623799,
            51845581,
            51625089,
            51624357,
            51625210,
            51626607,
            51624278,
            51623873,
            51625020,
            51624141,
            51624276,
            51623680,
            51624248,
            51623966
        ]
    },
    "name": "F. Dish Shopping",
    "statement": "There are m people living in a city. There are n dishes sold in the\r\ncity. Each dish i has a price p_i, a standard s_i and a beauty b_i. Each\r\nperson j has an income of inc_j and a preferred beauty pref_j. A person\r\nwould never buy a dish whose standard is less than the person\u2019s income.\r\nAlso, a person can\u2019t afford a dish with a price greater than the income\r\nof the person. In other words, a person j can buy a dish i only if p_i\r\nleq inc_j\r\nleq s_i.Also, a person j can buy a dish i, only if |b_i-pref_j|\r\nleq (inc_j-p_i). In other words, if the price of the dish is less than\r\nthe person\u2019s income by k, the person will only allow the absolute\r\ndifference of at most k between the beauty of the dish and his/her\r\npreferred beauty. Print the number of dishes that can be bought by each\r\nperson in the city.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 222222\n\nint n, m, acnt, bcnt, pa, pb, tot;\nstruct hp {\n\tint x, y, z, cnt, id;\n} f[N], a[N], b[N];\nint C[N], cnt[N], ch[N], p1[N], p2[N], p3[N];\n\nint p[N], s[N], d[N], inc[N], pref[N];\n\nint cmp1(hp a, hp b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y)\n\t       || (a.x == b.x && a.y == b.y && a.z < b.z)\n\t       || (a.x == b.x && a.y == b.y && a.z == b.z && a.cnt > b.cnt);\n}\nint cmp2(hp a, hp b)\n{\n\treturn a.y < b.y;\n}\nvoid add(int loc, int val)\n{\n\tif (!loc) return;\n\tfor (int i = loc; i <= n + m; i += i & (-i))\n\t\tC[i] += val;\n}\nint query(int loc)\n{\n\tint ans = 0;\n\tfor (int i = loc; i >= 1; i -= i & (-i))\n\t\tans += C[i];\n\treturn ans;\n}\nvoid cdq(int l, int r)\n{\n\tif (l >= r) return;\n\tint mid = (l + r) >> 1;\n\tcdq(l, mid);\n\n\tacnt = 0;\n\tfor (int i = l; i <= mid; ++i) a[++acnt] = f[i];\n\tsort(a + 1, a + acnt + 1, cmp2);\n\tbcnt = 0;\n\tfor (int i = mid + 1; i <= r; ++i) b[++bcnt] = f[i];\n\tsort(b + 1, b + bcnt + 1, cmp2);\n\tpa = pb = 1; tot = 0;\n\twhile (pb <= bcnt)\n\t{\n\t\twhile (pa <= acnt && a[pa].y <= b[pb].y)\n\t\t{\n\t\t\tif (a[pa].cnt)\n\t\t\t{\n\t\t\t\tadd(a[pa].z, a[pa].cnt);\n\t\t\t\tch[++tot] = a[pa].z;\n\t\t\t}\n\t\t\t++pa;\n\t\t}\n\t\tif (b[pb].cnt == 0)\n\t\t\tcnt[b[pb].id] += query(b[pb].z);\n\t\t++pb;\n\t}\n\tfor (int i = 1; i <= tot; ++i)\n\t\tadd(ch[i], -1);\n\n\tcdq(mid + 1, r);\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &s[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d\", &inc[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d\", &pref[i]);\n\tauto discretize = [&](int *p, int *q, int *x) {\n\t\tvector<int> number;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tnumber.push_back(p[i]);\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tnumber.push_back(q[i]);\n\t\tsort(number.begin(), number.end());\n\t\tnumber.erase(unique(number.begin(), number.end()), number.end());\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tx[i] = lower_bound(number.begin(), number.end(), p[i]) -\n\t\t\t       number.begin() + 1;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tx[i + n] = lower_bound(number.begin(), number.end(), q[i]) -\n\t\t\t           number.begin() + 1;\n\n\t};\n\tfor (int i = 1; i <= n; i++)\n\t\tp1[i] = p[i] + d[i];\n\tfor (int i = 1; i <= m; i++)\n\t\tp2[i] = inc[i] + pref[i];\n\tdiscretize(p1, p2, p3);\n\tfor (int i = 1; i <= n + m; i++)\n\t\tf[i].x = p3[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tp1[i] = p[i] - d[i];\n\tfor (int i = 1; i <= m; i++)\n\t\tp2[i] = inc[i] - pref[i];\n\tdiscretize(p1, p2, p3);\n\tfor (int i = 1; i <= n + m; i++)\n\t\tf[i].y = p3[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tp1[i] = -s[i];\n\tfor (int i = 1; i <= m; i++)\n\t\tp2[i] = -inc[i];\n\tdiscretize(p1, p2, p3);\n\tfor (int i = 1; i <= n + m; i++)\n\t\tf[i].z = p3[i];\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tf[i].id = i;\n\t\tf[i].cnt = 1;\n\t}\n\tfor (int i = 1; i <= m; ++i)\n\t\tf[i + n].id = i;\n\tsort(f + 1, f + n + m + 1, cmp1);\n\tcdq(1, n + m);\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", cnt[i]);\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Dish Shopping.json",
    "editorial_link": "https://codeforces.com//blog/entry/66101",
    "editorial": "Let\u00e2\u0080\u0099s consider a matrix where -th row represents price and -th column\r\nrepresents beauty , such that the value of represents the number of\r\ndishes that can be bought by a person having income and preferred beauty\r\n. Then, adding a dish with price , standard and beauty is similar to\r\nadding in each cell in the triangle formed by vertices , and . Now, we\r\nneed to update the given triangles with in a matrix efficiently. Let\u00e2\u0080\u0099s\r\ndo this offline.Note that for a triangle with vertices , and , the\r\ncolumn updated in -th row is . The columns updated in -th row are , and\r\n. So, if the columns updated in -th row are , then the columns updated\r\nin -th row will be . For updating a range in a row , we can update with\r\nand with . And then when we do prefix sum in that row we get actual\r\nvalues for each cell. We can use similar approach here. Note that\r\ninstead of updating with , we can update some array with , similarly\r\ninstead of updating with , we can update some array with . In this way,\r\nwe can provide updates for each row in triangle instead of just one row.\r\nThe value of a cell will be addition of prefix sum of in range and\r\nprefix sum of in range .Let\u00e2\u0080\u0099s create four events for each triangle. For,\r\na triangle with vertices , and , the events added will be at cell , at\r\ncell , at cell , at cell . Also, we add query events for each person at\r\ncell . Let\u00e2\u0080\u0099s sort this events on the basis of rows of the cell and then\r\nfor the same row we handle triangle events first and then handle query\r\nevents. For maintaining prefix sum in and , we can use compression and a\r\ndatastructure like fenwick tree.Overall Complexity:\r\n"
}