{
    "link": "https://codeforces.com//contest/218/problem/D",
    "problemId": "1605",
    "problem_idx": "D",
    "shortId": "218D",
    "contest_number": "218",
    "problem_submissions": {
        "A": [
            2028997,
            2030227,
            2025031,
            2023765,
            2025778,
            2023917,
            2029081,
            2023851,
            2023845,
            2024188,
            2023869,
            2024364,
            2024261,
            2023609,
            2024507,
            2024842,
            2024515,
            2024643,
            2025004,
            2024115
        ],
        "B": [
            2028813,
            2025859,
            2024728,
            2025181,
            2025174,
            2028767,
            2024807,
            2024938,
            2025059,
            2025512,
            2025303,
            2025424,
            2024591,
            2025144,
            2027115,
            2026214,
            2030523,
            2024374,
            2025288
        ],
        "D": [
            2028228,
            2028076,
            2028096,
            2028561,
            2028483,
            2028471,
            2029257,
            2029154,
            2029165,
            2029185,
            2029136,
            2029276,
            2029497,
            2029486,
            2028924,
            2029787,
            2028899
        ],
        "C": [
            2024163,
            2023867,
            2025504,
            2024348,
            2026143,
            2024315,
            2025600,
            2025742,
            2025843,
            2026651,
            2026604,
            2026297,
            2025597,
            2026207,
            2026007,
            2026046,
            2026139,
            2026389
        ],
        "E": [
            2032581,
            2031030
        ]
    },
    "name": "D. Blackboard Fibonacci",
    "statement": "Fibonacci numbers are the sequence of integers: , , , , , , , . So every\r\nnext number is the sum of the previous two.Bajtek has developed a nice\r\nway to compute Fibonacci numbers on a blackboard. First, he writes a 0.\r\nThen, below it, he writes a 1. Then he performs the following two\r\noperations: operation \"\": replace the top number with the sum of both\r\nnumbers; operation \"\": replace the bottom number with the sum of both\r\nnumbers. If he performs operations, starting with \"\" and then choosing\r\noperations alternately (so that the sequence of operations looks like\r\n\"\"), the last number written will be equal to .Unfortunately, Bajtek\r\nsometimes makes mistakes and repeats an operation two or more times in a\r\nrow. For example, if Bajtek wanted to compute , then he would want to do\r\noperations: \"\". If he instead performs the sequence of operations \"\",\r\nthen he will have made 3 mistakes, and he will incorrectly compute that\r\nthe seventh Fibonacci number is 10. The number of mistakes in the\r\nsequence of operations is the number of neighbouring equal operations (\r\nor ).You are given the number of operations that Bajtek has made in an\r\nattempt to compute and the number that is the result of his computations\r\n(that is last written number). Find the minimum possible number of\r\nmistakes that Bajtek must have made and any possible sequence of\r\noperations resulting in with that number of mistakes.Assume that Bajtek\r\nalways correctly starts with operation \"\".\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n//#include <stdbool.h>\n#include <math.h>\n#define LL long long\n#define CLR(x) memset(x,0,sizeof(x))\n#define typec double\n#define sqr(x) ((x)*(x))\n#define abs(x) ((x)<0?(-(x)):(x))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define PI acos(-1.0)\n#define lowbit(x) ((x)&(-(x)))\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\n#define inf 100000000\n//For C++\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <list>\n#include <iostream>\nusing namespace std;\nconst double eps=1e-10;\nint dblcmp(typec d) {\n    if (fabs(d)<eps)\n       return 0;\n    return (d>0)?1:-1;\n}\nint n,m,T,r;\nconst int N=1000100;\nstruct Me{\n    int s[N][2];\n    int cnt;\n    int errorr,all;\n    void clear(){\n        //memset(s,0,sizeof(s));\n        cnt=0;\n        errorr=0;\n        all=0;\n    }\n    void counterrorr(){\n        errorr=0;\n        for (int i=0;i<cnt;++i)\n            errorr+=s[i][1]-1;\n    }\n    bool operator < (const Me & A) const{\n        return errorr<A.errorr;\n    }\n    bool gao(int f,int g){\n        //memset(s,0,sizeof(s));\n        cnt=0;\n        errorr=0;\n        all=0;\n        while(f && g){\n            if (f>g){\n                s[cnt][0]=0;\n                s[cnt][1]=f/g;\n                if (f % g==0){\n                    s[cnt][1]--;\n                    f=g;\n                }\n                else f%=g;\n                all+=s[cnt++][1];\n                if (all>n) return false;\n            }\n            else if (f<g){\n                s[cnt][0]=1;\n                s[cnt][1]=g/f;\n                if (g % f ==0){\n                    s[cnt][1]--;\n                    g=f;\n                }\n                else  g%=f;\n                all+=s[cnt++][1];\n                if (all>n) return false;\n            }\n            else{\n                if (f * g !=1) return false;\n                   if (cnt==0 || s[cnt-1][0]==0){\n                        s[cnt][0]=1;\n                        s[cnt][1]=g/f;\n                        g%=f;\n                        all+=s[cnt++][1];\n                        if (all>n) return false;\n                   }\n                   else{\n                        s[cnt][0]=0;\n                        s[cnt][1]=f/g;\n                        f%=g;\n                        all+=s[cnt++][1];\n                        if (all>n) return false;\n                   }\n            }\n        }\n        return all==n;\n    }\n}ans[2];\nvoid solve(){\n    ans[0].errorr=99999999;\n    int dt=1;\n    for (int i=0;i<=r;++i){\n        //printf(\"%d\\n\",i);\n        if(!ans[dt].gao(i,r))continue;\n        //\n        ans[dt].counterrorr();\n        if (ans[dt]<ans[1-dt]) dt=1-dt;\n    }\n    dt=1-dt;\n    if (ans[dt].errorr==99999999) printf(\"IMPOSSIBLE\\n\");\n    else{\n        printf(\"%d\\n\",ans[dt].errorr);\n        int pre=ans[dt].s[0][0];\n        for (int i=0;i<ans[dt].cnt;++i)\n            for (int j=0;j<ans[dt].s[i][1];++j)\n                if (ans[dt].s[i][0]==pre) printf(\"T\");\n                else printf(\"B\");\n        printf(\"\\n\");\n    }\n}\nint main(){\n    while(cin>>n>>r) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Blackboard Fibonacci.json",
    "editorial_link": "https://codeforces.com//blog/entry/5285",
    "editorial": "If you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say\n\nUnable to parse markup [type=CF_TEX]\n\n) and replaces them by a?-?b,?b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a,?b by ) for all possibilities for a total runtime of . This was one of the expected solutions.\nHowever, with some insight, it can be seen that this optimization is in fact not neccessary Â— we can simply simulate the reverse process as described (replacing a,?b by a?-?b,?b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.",
    "hint": []
}