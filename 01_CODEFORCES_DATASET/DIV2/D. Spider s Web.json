{
    "link": "https://codeforces.com//contest/216/problem/D",
    "problemId": "1600",
    "problem_idx": "D",
    "shortId": "216D",
    "contest_number": "216",
    "problem_submissions": {
        "E": [
            2009676,
            2007456,
            2010925,
            2011846,
            2010767,
            2013186,
            2012062,
            2014949,
            2013666,
            2046735,
            2013517
        ],
        "D": [
            2008985,
            2008016,
            2009087,
            2009267,
            2009116,
            2010292,
            2010461,
            2009515,
            2010965,
            2010788,
            2008354,
            2011910,
            2011812,
            2010997,
            2011635,
            2010429,
            2010591
        ],
        "C": [
            2008196,
            2010650,
            2010398,
            2010245,
            2009928,
            2008042,
            2009220,
            2212789,
            2010921,
            2010250,
            2009530,
            2011922,
            2009776,
            2011084,
            2009565,
            2010436,
            2011686,
            2009858
        ],
        "B": [
            2007383,
            2008222,
            2006806,
            2008461,
            2008911,
            2011583,
            2007848,
            2008640,
            2008312,
            2007798,
            2007852,
            2009984,
            2009151,
            2011696,
            2009696,
            2009222,
            2012291
        ],
        "A": [
            2006576,
            2008320,
            2007244,
            2007015,
            2006474,
            2492889,
            2492882,
            2006494,
            2006484,
            2006601,
            2007349,
            2006728,
            2006555,
            2006564,
            2007269,
            2006768,
            2007828,
            2006557,
            2007513
        ]
    },
    "name": "D. Spider s Web",
    "statement": "Paw the Spider is making a web. Web-making is a real art, Paw has been\r\nlearning to do it his whole life. Let\u2019s consider the structure of the\r\nweb. There are threads going from the center of the web. All main\r\nthreads are located in one plane and divide it into equal infinite . The\r\nsectors are indexed from to in the clockwise direction. Sectors and are\r\nfor every , . In addition, sectors and are also adjacent.Some sectors\r\nhave . Each bridge connects the two main threads that make up this\r\nsector. The points at which the bridge is attached to the main threads\r\nwill be called . Both attachment points of a bridge are at the same\r\ndistance from the center of the web. At each attachment point exactly\r\none bridge is attached. The bridges are if they are in the same sector,\r\nand there are no other bridges between them.A of the web is a trapezoid,\r\nwhich is located in one of the sectors and is bounded by two main\r\nthreads and two adjacent bridges. You can see that the sides of the cell\r\nmay have the attachment points of bridges from adjacent sectors. If the\r\nnumber of attachment points on one side of the cell is not equal to the\r\nnumber of attachment points on the other side, it creates an imbalance\r\nof pulling forces on this cell and this may eventually destroy the\r\nentire web. We\u2019ll call such a cell . The perfect web does not contain\r\nunstable cells.Unstable cells are marked red in the figure. Stable cells\r\nare marked green.Paw the Spider isn\u2019t a skillful webmaker yet, he is\r\nonly learning to make perfect webs. Help Paw to determine the number of\r\nunstable cells in the web he has just spun.\r\n",
    "solutions": [
        "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nvector<int> a[1100];\n\nint main()\n{\n  _int64 ans;\n  int i,j,n,x,nn,i1,i2,i3,c1,c2;\n  scanf(\"%d\",&n);\n  for (i=0;i<n;i++)\n  {\n    scanf(\"%d\",&nn);\n    a[i].clear();\n    for (j=0;j<nn;j++)\n    {\n      scanf(\"%d\",&x);\n      a[i].push_back(x);\n    }\n    sort(a[i].begin(),a[i].end());\n  }\n  a[n]=a[0];\n  a[n+1]=a[1];\n  ans=0;\n  for (i=1;i<=n;i++)\n  {\n    i1=0;i3=0;\n    while ((i1<a[i-1].size())&&(a[i-1][i1]<a[i][0])) i1++;\n    while ((i3<a[i+1].size())&&(a[i+1][i3]<a[i][0])) i3++;\n    for (j=1;j<a[i].size();j++)\n    {\n      c1=0;c2=0;\n      while ((i1<a[i-1].size())&&(a[i-1][i1]<a[i][j]))\n      {\n        i1++;\n        c1++;\n      }\n      while ((i3<a[i+1].size())&&(a[i+1][i3]<a[i][j]))\n      {\n        i3++;\n        c2++;\n      }\n      if (c1!=c2)\n      {\n        ans++;\n        //printf(\"%d %d\\n\",i,j);\n      }\n    }\n  }\n  printf(\"%I64d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Spider s Web.json",
    "editorial_link": "https://codeforces.com//blog/entry/5066",
    "editorial": "For every sector you should sort bridges in order of increasing distance from the conter of the web. Now for every sector you should iterate over bridges of the current sector and two adjacent sectors using 3 pointers. During every pass you should carefully calculate number of bad cells. That is all solution."
}