{
    "link": "https://codeforces.com//contest/1838/problem/D",
    "problemId": "1951237",
    "problem_idx": "D",
    "shortId": "1838D",
    "contest_number": "1838",
    "problem_submissions": {
        "E": [
            208486336,
            208494772,
            208495329,
            208495228,
            208504838,
            208502550,
            208502081,
            208506624,
            208501784,
            208497568,
            208484754,
            208502274,
            208506982,
            208508861,
            208509587
        ],
        "D": [
            208474393,
            208472020,
            208475917,
            208474806,
            208470276,
            208484610,
            208476486,
            208481947,
            208484438,
            208492182,
            208509562,
            208485512,
            208497675,
            208502977,
            208488728,
            208469550,
            208477928,
            208461571
        ],
        "C": [
            208459822,
            208460902,
            208460156,
            208459254,
            208459677,
            208455873,
            208462517,
            208452784,
            208459736,
            208463220,
            208467092,
            208460581,
            208458526,
            208468810,
            208477568,
            208454310,
            208448256,
            208470265
        ],
        "B": [
            208453654,
            208447995,
            208452616,
            208450470,
            208449926,
            208446381,
            208454035,
            208446799,
            208444336,
            208450882,
            208456322,
            208448611,
            208449662,
            208456059,
            208462080,
            208447155,
            208442110,
            208452374
        ],
        "A": [
            208438767,
            208438058,
            208439478,
            208435532,
            208440850,
            208437783,
            208437196,
            208435664,
            208435519,
            208435964,
            208439335,
            208440976,
            208441596,
            208440802,
            208440409,
            208436085,
            208439210,
            208439722
        ],
        "F": [
            209584777,
            208548659
        ]
    },
    "name": "D. Bracket Walk",
    "statement": "There is a string s of length n consisting of the characters \u201d and \u201d.\r\nYou are walking on this string. You start by standing on top of the\r\nfirst character of s, and you want to make a sequence of moves such that\r\nyou end on the n-th character. In one step, you can move one space to\r\nthe left (if you are not standing on the first character), or one space\r\nto the right (if you are not standing on the last character). You may\r\nnot stay in the same place, however you may visit any character,\r\nincluding the first and last character, number of times.At each point in\r\ntime, you write down the character you are currently standing on. We say\r\nthe string is if there exists some sequence of moves that take you from\r\nthe first character to the last character, such that the string you\r\nwrite down is a regular bracket sequence.A regular bracket sequence is a\r\nbracket sequence that can be transformed into a correct arithmetic\r\nexpression by inserting characters \u201d and \u201d between the original\r\ncharacters of the sequence. For example, bracket sequences \"\", \"\" are\r\nregular (the resulting expressions are: \"\", \"\"), and \"\" and \"\" are\r\nnot.You are given q queries. Each query flips the value of a character\r\nfrom \u201d to \u201d or vice versa. After each query, determine whether the\r\nstring is walkable.Queries are , so the effects of each query carry on\r\nto future queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n,q; cin>>n>>q;\n    set<int> bl;\n    for (int i = 0; i < n; ++i) {\n        char c; cin>>c;\n        bool b = c == '(';\n        if (b ^ (i % 2 == 0)) {\n            bl.insert(i);\n        }\n    }\n    for (int qi = 0; qi < q; ++qi) {\n        int i; cin>>i; --i;\n        if (n % 2 == 1) {\n            cout << \"NO\\n\";\n            continue;\n        }\n        if (bl.count(i)) {\n            bl.erase(i);\n        } else {\n            bl.insert(i);\n        }\n        if (bl.empty() || (*bl.begin() % 2 == 1 && *bl.rbegin() % 2 == 0)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bracket Walk.json",
    "editorial_link": "https://codeforces.com//blog/entry/116995",
    "editorial": "For a string to be walkable, we need to be even, because the parity of\r\nthe balance factor changes on each move, and it has to be zero at the\r\nend of the process. So if is odd, the string is never walkable.Now,\r\nconsider the set that contains all indices (-indexed) satisfying one of\r\nthe below conditions: is even and \u00e2\u0080\u0099(\u00e2\u0080\u0099 is odd and \u00e2\u0080\u0099)\u00e2\u0080\u0099 Now, consider a few\r\ncases:If is empty, then is of the form ()()()(), and is therefore\r\ntrivially walkable by just moving to the right.If is odd, then is of the\r\nform ()()()).... We can show that it is never walkable, because for\r\nevery \u00e2\u0080\u0099)\u00e2\u0080\u0099 in the first section ()()(), when we land on this \u00e2\u0080\u0099)\u00e2\u0080\u0099 (before\r\nleaving this section of the string for the first time), the balance\r\nfactor must be . Therefore, when we try to move across the \"))\", the\r\nbalance factor will go to , and the walk will no longer be valid.If is\r\neven, then is of the form ....(()()(), and we can show that it is never\r\nwalkable using a somewhat symmetric argument to the previous case, but\r\nconsidering the ending of the walk instead of the beginning.Otherwise,\r\nis even and is odd. We will prove that it is walkable. In this case, s\r\nis of the form ()()()((....))()(). To form a valid walk, keep moving to\r\nthe right until you hit the \"((\", then alternate back and forth on the\r\n\"((\" times. After this, move to the right until you hit the \"))\". Note\r\nthat during this process, the balance factor can never go negative,\r\nbecause it will always be at least . Once you reach the \"))\", alternate\r\nback and forth on it until the balance factor hits . Because n is even,\r\nthis will happen on the rightmost character of the \"))\". At this point,\r\njust walk to the right until you hit the end, at which point the balance\r\nfactor will once again be .So we just need to maintain the set across\r\nall of the queries, and do these simple checks after each query to see\r\nif is walkable.Complexity:\r\n"
}