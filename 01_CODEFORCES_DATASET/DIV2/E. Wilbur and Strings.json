{"link": "https://codeforces.com//contest/596/problem/E", "problemId": "40909", "problem_idx": "E", "shortId": "596E", "contest_number": "596", "problem_submissions": {"E": [14284902, 14410276, 14285890, 14836358], "A": [14282529, 14272331, 14272408, 14272249, 14272247, 14272132, 14272036, 14272062, 14273974, 14272466, 14272094, 14272742, 14272840, 14272048, 14272087, 14272349, 14272225, 14272447, 14273354, 14273114], "D": [14280833, 14284455, 14282588, 14285386, 14285067, 14284298, 14286251, 14285939, 14284050, 14285941, 14286108, 14293470, 14284179], "C": [14276112, 14278736, 14278325, 14279291, 14278970, 14277576, 14282655, 14280088, 14281778, 14280140, 14281205, 14281281, 14279114, 14277665, 14278438, 14279354, 14285136, 14283954, 14281786], "B": [14272947, 14272778, 14273548, 14272930, 14272933, 14273058, 14272243, 14272568, 14274807, 14272965, 14272538, 14274186, 14273926, 14272409, 14272384, 14272994, 14273180, 14273634, 14274094, 14274290]}, "name": "E. Wilbur and Strings", "statement": "Wilbur the pig now wants to play with strings. He has found an by table\r\nconsisting only of the digits from to where the rows are numbered to and\r\nthe columns are numbered to . Wilbur starts at some square and makes\r\ncertain moves. If he is at square (, ) and the digit () is written at\r\nposition (, ), move to the square (, ), if that square lies within the\r\ntable, and he stays in the square (, ) otherwise. Before Wilbur makes a\r\nmove, he can choose whether or not to write the digit written in this\r\nsquare on the white board. All digits written on the whiteboard form\r\nsome string. Every time a new digit is written, it goes to the end of\r\nthe current string.Wilbur has strings that he is worried about. For each\r\nstring , Wilbur wants to know whether there exists a starting position\r\n(, ) so that by making finitely many moves, Wilbur can end up with the\r\nstring written on the white board.\r\n", "solutions": ["//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 249 * 249;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nstring mat[maxN], qs;\nint n, m, topo[maxN], h, t;\nvector<int> in[maxN], out[maxN];\nint ax[10], bx[10], deg[maxN], mark[maxN], dp[maxN], has[maxN], vis[maxN], dig[maxN], ms[(int) 1e6 + 9];\n\nint check (int i, int j) {\n\treturn (0 <= i) && (i < n) && (0 <= j) && (j < m);\t\n}\n\nint get (int i, int j) {\n\treturn i * m + j;\n}\n\nint f (int i, int j) {\n\tif (!check(i + ax[mat[i][j] - '0'], j + bx[mat[i][j] - '0']))\n\t\treturn get(i, j);\n\treturn get(i + ax[mat[i][j] - '0'], j + bx[mat[i][j] - '0']);\n}\n\nvoid dfs (int v) {\n\tif (vis[v]++) return;\n\tfor (int u : out[v]) {\n\t\tdfs(u);\n\t\thas[v] |= has[u];\t\n\t}\n\tif (!mark[v])\n\t\thas[v] |= 1 << dig[v];\n}\n\nvoid build () {\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint v = get(i, j), u = f(i, j);\n\t\t\tdig[v] = mat[i][j] - '0';\n\t\t\tout[v].push_back(u);\n\t\t\tin[u].push_back(v);\n\t\t\tdeg[u]++;\n\t\t}\n\tn = n * m;\n\tfor (int i = 0; i < n; i++)\n\t\tif (deg[i] == 0)\n\t\t\ttopo[t++] = i;\n\twhile (h != t) {\n\t\tint v = topo[h++];\n\t\tmark[v] = 1;\n\t\tfor (int u : out[v]) if ((--deg[u]) == 0) {\n\t\t\ttopo[t++] = u;\t\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (!vis[i])\n\t\tdfs(i);\n}\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tint q; cin >> q;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> mat[i];\n\tfor (int i = 0; i < 10; i++)\n\t\tcin >> ax[i] >> bx[i];\n\tbuild();\n\twhile (q--) {\n\t\tcin >> qs;\n\t\tm = (int) qs.size();\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tms[i] = 0;\n\t\tfor (int i = m - 1; i >= 0; i--)\n\t\t\tms[i] = ms[i + 1], ms[i] |= 1 << (qs[i] - '0');\n\t\tmemset(dp, 0, sizeof (dp));\n\t\tbool flag = 0;\n\t\tfor (int _ = 0; _ < t; _++) {\n\t\t\tint v = topo[_];\n\t\t\tfor (int u : in[v]) if (mark[u]) {\n\t\t\t\tsmax(dp[v], dp[u]);\n\t\t\t}\n\t\t\tif (dp[v] != m) {\n\t\t\t\tif (dig[v] == qs[dp[v]] - '0')\n\t\t\t\t\tdp[v]++;\n\t\t\t}\n\t\t\tif ((has[v] & ms[dp[v]]) == ms[dp[v]]) {\n\t\t\t\tcout << \"YES\\n\";\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!flag && (has[i] & ms[0]) == ms[0]) {\n\t\t\t\tflag = 1;\n\t\t\t\tcout << \"YES\\n\";\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\tif (!flag)\n\t\t\tcout << \"NO\\n\";\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "strings"], "dificulty": "2500", "interactive": false}