{
    "link": "https://codeforces.com//contest/596/problem/E",
    "problemId": "40909",
    "problem_idx": "E",
    "shortId": "596E",
    "contest_number": "596",
    "problem_submissions": {
        "E": [
            14284902,
            14410276,
            14285890,
            14836358
        ],
        "A": [
            14282529,
            14272331,
            14272408,
            14272249,
            14272247,
            14272132,
            14272036,
            14272062,
            14273974,
            14272466,
            14272094,
            14272742,
            14272840,
            14272048,
            14272087,
            14272349,
            14272225,
            14272447,
            14273354,
            14273114
        ],
        "D": [
            14280833,
            14284455,
            14282588,
            14285386,
            14285067,
            14284298,
            14286251,
            14285939,
            14284050,
            14285941,
            14286108,
            14293470,
            14284179
        ],
        "C": [
            14276112,
            14278736,
            14278325,
            14279291,
            14278970,
            14277576,
            14282655,
            14280088,
            14281778,
            14280140,
            14281205,
            14281281,
            14279114,
            14277665,
            14278438,
            14279354,
            14285136,
            14283954,
            14281786
        ],
        "B": [
            14272947,
            14272778,
            14273548,
            14272930,
            14272933,
            14273058,
            14272243,
            14272568,
            14274807,
            14272965,
            14272538,
            14274186,
            14273926,
            14272409,
            14272384,
            14272994,
            14273180,
            14273634,
            14274094,
            14274290
        ]
    },
    "name": "E. Wilbur and Strings",
    "statement": "Wilbur the pig now wants to play with strings. He has found an by table\r\nconsisting only of the digits from to where the rows are numbered to and\r\nthe columns are numbered to . Wilbur starts at some square and makes\r\ncertain moves. If he is at square (, ) and the digit () is written at\r\nposition (, ), move to the square (, ), if that square lies within the\r\ntable, and he stays in the square (, ) otherwise. Before Wilbur makes a\r\nmove, he can choose whether or not to write the digit written in this\r\nsquare on the white board. All digits written on the whiteboard form\r\nsome string. Every time a new digit is written, it goes to the end of\r\nthe current string.Wilbur has strings that he is worried about. For each\r\nstring , Wilbur wants to know whether there exists a starting position\r\n(, ) so that by making finitely many moves, Wilbur can end up with the\r\nstring written on the white board.\r\n",
    "solutions": [
        "//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 249 * 249;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nstring mat[maxN], qs;\nint n, m, topo[maxN], h, t;\nvector<int> in[maxN], out[maxN];\nint ax[10], bx[10], deg[maxN], mark[maxN], dp[maxN], has[maxN], vis[maxN], dig[maxN], ms[(int) 1e6 + 9];\n\nint check (int i, int j) {\n\treturn (0 <= i) && (i < n) && (0 <= j) && (j < m);\t\n}\n\nint get (int i, int j) {\n\treturn i * m + j;\n}\n\nint f (int i, int j) {\n\tif (!check(i + ax[mat[i][j] - '0'], j + bx[mat[i][j] - '0']))\n\t\treturn get(i, j);\n\treturn get(i + ax[mat[i][j] - '0'], j + bx[mat[i][j] - '0']);\n}\n\nvoid dfs (int v) {\n\tif (vis[v]++) return;\n\tfor (int u : out[v]) {\n\t\tdfs(u);\n\t\thas[v] |= has[u];\t\n\t}\n\tif (!mark[v])\n\t\thas[v] |= 1 << dig[v];\n}\n\nvoid build () {\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint v = get(i, j), u = f(i, j);\n\t\t\tdig[v] = mat[i][j] - '0';\n\t\t\tout[v].push_back(u);\n\t\t\tin[u].push_back(v);\n\t\t\tdeg[u]++;\n\t\t}\n\tn = n * m;\n\tfor (int i = 0; i < n; i++)\n\t\tif (deg[i] == 0)\n\t\t\ttopo[t++] = i;\n\twhile (h != t) {\n\t\tint v = topo[h++];\n\t\tmark[v] = 1;\n\t\tfor (int u : out[v]) if ((--deg[u]) == 0) {\n\t\t\ttopo[t++] = u;\t\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (!vis[i])\n\t\tdfs(i);\n}\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tint q; cin >> q;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> mat[i];\n\tfor (int i = 0; i < 10; i++)\n\t\tcin >> ax[i] >> bx[i];\n\tbuild();\n\twhile (q--) {\n\t\tcin >> qs;\n\t\tm = (int) qs.size();\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tms[i] = 0;\n\t\tfor (int i = m - 1; i >= 0; i--)\n\t\t\tms[i] = ms[i + 1], ms[i] |= 1 << (qs[i] - '0');\n\t\tmemset(dp, 0, sizeof (dp));\n\t\tbool flag = 0;\n\t\tfor (int _ = 0; _ < t; _++) {\n\t\t\tint v = topo[_];\n\t\t\tfor (int u : in[v]) if (mark[u]) {\n\t\t\t\tsmax(dp[v], dp[u]);\n\t\t\t}\n\t\t\tif (dp[v] != m) {\n\t\t\t\tif (dig[v] == qs[dp[v]] - '0')\n\t\t\t\t\tdp[v]++;\n\t\t\t}\n\t\t\tif ((has[v] & ms[dp[v]]) == ms[dp[v]]) {\n\t\t\t\tcout << \"YES\\n\";\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!flag && (has[i] & ms[0]) == ms[0]) {\n\t\t\t\tflag = 1;\n\t\t\t\tcout << \"YES\\n\";\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\tif (!flag)\n\t\t\tcout << \"NO\\n\";\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Wilbur and Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/21599",
    "editorial": "Solution 1: Suppose that is a string in the query. Reverse and the\r\ndirection of all the moves that can be made on the table. Note that\r\nstarting at any point that is part of a cycle, there is a loop and then\r\nedges that go out of the loop. So, for every point, it can be checked by\r\ndfs whether the can be made by starting at that point by storing what is\r\nin the cycle. Moreover, note that in the reversed graph, each point can\r\nonly be a part of one cycle. Therefore, the total time for the dfs in a\r\nquery is . This is good enough for queries to run in time. Complexity:\r\nwhere is the number of distinct characters in the table, and is the\r\nquery string for the th query. Code: Solution Solution 2 (Actually too\r\nslow, see comment by waterfalls below for more details): For each string\r\n, dfs from every node that has in degree equal to in the original graph.\r\nThere will be a path which leads into a cycle after which anything in\r\nthe cycle can be used any number of times in . Only every node with in\r\ndegree equal to has to be checked because every path which leads to a\r\ncycle is part of a larger path which starts with a vertex of in degree\r\nthat leads into a cycle. This solution is slower, but it works in\r\npractice since it is really hard for a string to match so many times in\r\nthe table. Each query will take time, but it is much faster in practice.\r\nComplexity: where is the number of distinct characters in the table, and\r\nis the query string of the th query.\r\n"
}