{
    "link": "https://codeforces.com//contest/2032/problem/D",
    "problemId": "2994607",
    "problem_idx": "D",
    "shortId": "2032D",
    "contest_number": "2032",
    "problem_submissions": {
        "F": [
            289267915,
            289277706,
            289232912,
            289267377,
            291314197,
            289416021
        ],
        "E": [
            289238022,
            289262776,
            289255223,
            289258448,
            289250787,
            289260574,
            289261929,
            289227660,
            289263018,
            289263597,
            289263187,
            289266715,
            289259935,
            289271752,
            289266962,
            289268830,
            289269008,
            289265714
        ],
        "D": [
            289731015,
            289233613,
            289264637,
            289214258,
            289228700,
            289223391,
            289226883,
            289280487,
            289241431,
            289231526,
            289229626,
            289234786,
            289242007,
            289228890,
            289240630,
            289239305,
            289231442,
            289232355
        ],
        "B": [
            289203679,
            289271925,
            289191670,
            289200056,
            289196726,
            289200003,
            289197742,
            289196982,
            289194362,
            289197275,
            289201147,
            289202156,
            289199141,
            289200655,
            289202275,
            289195764
        ],
        "C": [
            289193496,
            289267532,
            289198910,
            289207633,
            289201326,
            289203591,
            289285062,
            289204577,
            289220034,
            289205439,
            289204433,
            289208681,
            289194187,
            289211250,
            289206397,
            289208627,
            289215203
        ],
        "A": [
            289187421,
            289273450,
            289186675,
            289187594,
            289186664,
            289189130,
            289187996,
            289189265,
            289187088,
            289189596,
            289187843,
            289188574,
            289187095,
            289189623,
            289187877,
            289187863
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135622",
    "editorial": "For simplicity, weâll use the term \"tentacle\" to call each path tree in\r\nthe forest made by cutting off node . We also notice that in each\r\ntentacle, two nodes will never have the same distance from root node\r\n.The condition of iff leads to a crucial observation of the system: it\r\nis indexed in accordance to a BFS order of the tree. Hence, we now have\r\ntwo goals: Determine the number of tentacles. From node to , assign\r\nevery node to their respective tentacles. Due to the BFS order, at the\r\nmoment of assignment, the previous tip of the tentacle is the parent of\r\nthe current node, and the current node becomes the new tip of the\r\ntentacle. For the first objective, we see that node is guaranteed to be\r\nconnected with nodes and . Furthermore, is the first non-zero node where\r\nthe path between it and does not cross . Therefore, you can keep\r\nquerying for increasing until you find a to get .For the second\r\nobjective, we need to find the tentacle that each node () belongs to; in\r\nother words, find the node so that query yields a . Denote as the\r\ntentacle associated with node , then note that: If and share the same\r\ndistance from , then obviously , i.e., will be a tentacle at the forward\r\ndirection from in the tentacle list. If and donât share the same\r\ndistance from , then can be any tentacle in the list. So we can approach\r\nthis objective like this: denote as the next tentacle in the list after\r\n(or if was at the end of the list), starting from , weâll keep\r\nre-assigning until query yields a .From hindsight, it looks like weâll\r\nneed query count order to finish this part, but there is another crucial\r\nobservation: due to the nodes being indexed in BFS order, if any\r\ntentacle yields a during probing, that tentacle will never be extended\r\nagain proof for this is pretty intuitive but a bit lengthy to express in\r\nwords, so weâll leave it as an exercise for the reader thus if you reach\r\nan that has already been deactivated before, you ignore it and call\r\nagain, which wouldnât count towards the queries as it is your internal\r\nprocessing.Letâs count the number of queries we used. Let be the number\r\nof tentacles, then If , the second objective wouldnât be needed, so we\r\nend up with queries in total (as ). If , note that each time we process\r\na query, either a node is appended to a tentacle, or a tentacle is\r\nremoved. Since at most tentacles can be removed and there are nodes to\r\nbe processed, the second phase uses at most queries, so in total we use\r\nqueries. To process the list of tentacles, there are a few options:\r\nNaively mark the tentacles as active/inactive to know when to stop by\r\nfor queries and when to skip. Time complexity will be , and though it\r\ncan still pass (in fact one such solution from the author passed\r\nnicely), it is not recommended. Maintain the list of tentacles in a , if\r\na node is known to be inactive, remove it. Time complexity will be .\r\nMaintain the list of tentacles in a similar manner as above, but using a\r\ndoubly linked list this time. Time complexity will be .\r\n",
    "name": "D. Genokraken",
    "statement": "Upon clearing the Waterside Area, Gretel has found a monster named\r\nGenokraken, and she’s keeping it contained for her scientific\r\nstudies.The monster’s nerve system can be structured as a tree^{\r\ndagger} of n nodes , numbered from 0 to n-1, with node 0 as the\r\nroot.Gretel’s objective is to learn the exact structure of the monster’s\r\nnerve system more specifically, she wants to know the values p_1, p_2,\r\nldots, p_{n-1} of the tree, where p_i (0\r\nle p_i < i) is the direct parent node of node i (1\r\nle i\r\nle n - 1).She doesn’t know exactly how the nodes are placed, but she\r\nknows a few convenient facts: If we remove root node 0 and all adjacent\r\nedges, this tree will turn into a forest consisting of only paths^{\r\nddagger}. Each node that was initially adjacent to the node 0 . The\r\nnodes are indexed in a way that if 1\r\nle x\r\nle y\r\nle n - 1, then p_x\r\nle p_y. Node 1 has adjacent nodes (including the node 0). Gretel can\r\nmake queries to the containment cell: \"\" (1\r\nle a, b < n, a\r\nne b) the cell will check if the simple path between nodes a and b\r\ncontains the node 0. However, to avoid unexpected consequences by\r\noverstimulating the creature, Gretel wants to query at most 2n - 6\r\ntimes. Though Gretel is gifted, she can’t do everything all at once, so\r\ncan you give her a helping hand?^{\r\ndagger}A tree is a connected graph where every pair of distinct nodes\r\nhas exactly one simple path connecting them.^{\r\nddagger}A path is a tree whose vertices can be listed in the order v_1,\r\nv_2,\r\nldots, v_k such that the edges are (v_i, v_{i+1}) (1\r\nle i < k).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;// #define int long longtypedef pair<int,int> pii;#define all(x) (x).begin(),(x).end()#define fi first#define se second#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0) int ask(int x,int y){\tcout<<\"? \"<<x<<\" \"<<y<<endl;\tint res; cin>>res;\tassert(res!=-1);\treturn res;} void solve(){\tint n; cin>>n;\tvector<int> p(n+5,0);\tp[1]=0;\tint t=0;\tfor(int i=2;i<=n-1;i++)\t{\t\tint r=ask(1,i);\t\tif(r==0){t=i; break;}\t\telse p[i]=0;\t}\tp[t]=1;\tint now=2;\tfor(int i=t+1;i<=n-1;i++)\t{\t\twhile(ask(now,i)==1) now++;\t\tp[i]=now;\t\tnow++;\t}\tcout<<\"! \";\tfor(int i=1;i<=n-1;i++) cout<<p[i]<<\" \";\tcout<<endl;} signed main(){\tint T; cin>>T;\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "graphs",
        "greedy",
        "implementation",
        "interactive",
        "trees",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Genokraken.json",
    "hint": [
        "Hint #1 There are many specific constraints on the system tree. First, notice that if and only if . Draw a few trees with this constraint and start pointing your finger on the nodes from to . Notice the pattern your finger is making.",
        "Hint #2 Incorporate hint #1 with the fact that the \"tentacles\" of the Genokraken are just paths. Try to draw more detailed conclusion about that pattern.",
        "Hint #4 The query limit is very small. Is there a way to query that the information obtained in each query should (at least partially) determine a node?",
        "Hint #5 For each \"tentacle\", can we know when its path has ended? How many queries should it take?"
    ]
}