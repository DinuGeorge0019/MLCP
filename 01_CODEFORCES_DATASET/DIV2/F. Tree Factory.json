{"link": "https://codeforces.com//contest/1247/problem/F", "problemId": "451066", "problem_idx": "F", "shortId": "1247F", "contest_number": "1247", "problem_submissions": {"F": [63516585, 63498066, 63531653, 63484717], "E": [63466015, 63473982, 63472756, 63472587, 63477513, 63473125, 63474516, 63476526, 63478680, 63473858, 63480958, 63481550, 63481519, 63482376, 63483256, 63481801, 63480736, 63482911, 63484993], "D": [63458462, 63452186, 63464452, 63462467, 63461642, 63462284, 63469112, 63466038, 63465533, 63467098, 63466913, 63532659, 63458800, 63469138, 63466028, 63518059, 63471109, 63471871, 63471893, 63472863, 63468681], "C": [63451842, 63448915, 63446524, 63452894, 63453210, 63465192, 63456520, 63458388, 63455590, 63458932, 63454282, 63457733, 63453216, 63464210, 63454777, 63455424, 63462076, 63462168, 63461001], "B1": [63441028, 63445773, 63455031, 63446312, 63447577, 63448362, 63448931, 63448486, 63445824, 63453830, 63446861, 63447193, 63445847, 63460715, 63448295, 63449973, 63454578, 63450726, 63449807], "B2": [63440055, 63445491, 63454826, 63446019, 63446936, 63447440, 63449345, 63447899, 63445385, 63454155, 63447268, 63446929, 63448203, 63460143, 63447809, 63449173, 63454319, 63450374, 63450053], "A": [63437545, 63439551, 63452092, 63445337, 63447252, 63440937, 63439822, 63438397, 63438564, 63453424, 63437913, 63439495, 63438907, 63456486, 63442538, 63445415, 63444316, 63440390, 63439231]}, "name": "F. Tree Factory", "statement": "Bytelandian Tree Factory produces trees for all kinds of industrial\r\napplications. You have been tasked with optimizing the production of a\r\ncertain type of tree for an especially large and important order.The\r\ntree in question is a rooted tree with n vertices labelled with distinct\r\nintegers from 0 to n - 1. The vertex labelled 0 is the root of the tree,\r\nand for any non-root vertex v the label of its parent p(v) is less than\r\nthe label of v.All trees at the factory are made from bamboo blanks. A\r\nis a rooted tree such that each vertex has exactly one child, except for\r\na single leaf vertex with no children. The vertices of a bamboo blank\r\ncan be labelled arbitrarily before its processing is started.To process\r\na bamboo into another tree a single type of operation can be made:\r\nchoose an arbitrary non-root vertex v such that its parent p(v) is not a\r\nroot either. The operation consists of changing the parent of v to its\r\nparent\u2019s parent p(p(v)). Note that parents of all other vertices remain\r\nunchanged, in particular, the subtree of v does not change.Efficiency is\r\ncrucial, hence you have to minimize the number of operations to make the\r\ndesired tree from a bamboo blank. Construct any optimal sequence of\r\noperations to produce the desired tree.Note that the labelling of the\r\nresulting tree has to coincide with the labelling of the desired tree.\r\nFormally, the labels of the roots have to be equal, and for non-root\r\nvertices with the same label the labels of their parents should be the\r\nsame.It is guaranteed that for any test present in this problem an\r\nanswer exists, and further, an optimal sequence contains at most 10^6\r\noperations. Note that .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int maxn=(1e5)+10;\nint n,dep[maxn],t1,d[maxn];\nint t2,e[maxn*10];\nvector<int> g[maxn];\nvoid dfs(int u) {\n\tfor (int i=0;i<g[u].size();i++)\n\t\tdfs(g[u][i]),dep[u]=max(dep[u],dep[g[u][i]]+1);\n}\nvoid DFS(int u) {\n\td[++t1]=u;\n\tint mx=0;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (dep[v]>dep[mx]||!mx) mx=v;\n\t}\n\tint lst=mx;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (v==mx) continue;\n\t\te[++t2]=lst;\n\t\tg[v].push_back(lst);\n\t\tdep[v]=max(dep[v],dep[lst]+1);\n\t\tlst=v;\n\t}\n\tif (lst) DFS(lst);\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tread(n); int x,y;\n\t//printf(\"%d\\n\",n);\n\tfor (int i=2;i<=n;i++) {\n\t\tread(x); x++;\n\t\tg[x].push_back(i);\n\t\t//printf(\"%d\\n\",x-1);\n\t}\n\tdfs(1);\n\tDFS(1);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",d[i]-1);\n\tprintf(\"\\n\");\n\treverse(e+1,e+t2+1);\n\tprintf(\"%d\\n\",t2);\n\tfor (int i=1;i<=t2;i++) printf(\"%d \",e[i]-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "trees"], "dificulty": "2500", "interactive": false}