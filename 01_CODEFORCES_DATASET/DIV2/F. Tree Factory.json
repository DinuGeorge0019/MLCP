{
    "link": "https://codeforces.com//contest/1247/problem/F",
    "problemId": "451066",
    "problem_idx": "F",
    "shortId": "1247F",
    "contest_number": "1247",
    "problem_submissions": {
        "F": [
            63516585,
            63498066,
            63531653,
            63484717
        ],
        "E": [
            63466015,
            63473982,
            63472756,
            63472587,
            63477513,
            63473125,
            63474516,
            63476526,
            63478680,
            63473858,
            63480958,
            63481550,
            63481519,
            63482376,
            63483256,
            63481801,
            63480736,
            63482911,
            63484993
        ],
        "D": [
            63458462,
            63452186,
            63464452,
            63462467,
            63461642,
            63462284,
            63469112,
            63466038,
            63465533,
            63467098,
            63466913,
            63532659,
            63458800,
            63469138,
            63466028,
            63518059,
            63471109,
            63471871,
            63471893,
            63472863,
            63468681
        ],
        "C": [
            63451842,
            63448915,
            63446524,
            63452894,
            63453210,
            63465192,
            63456520,
            63458388,
            63455590,
            63458932,
            63454282,
            63457733,
            63453216,
            63464210,
            63454777,
            63455424,
            63462076,
            63462168,
            63461001
        ],
        "B1": [
            63441028,
            63445773,
            63455031,
            63446312,
            63447577,
            63448362,
            63448931,
            63448486,
            63445824,
            63453830,
            63446861,
            63447193,
            63445847,
            63460715,
            63448295,
            63449973,
            63454578,
            63450726,
            63449807
        ],
        "B2": [
            63440055,
            63445491,
            63454826,
            63446019,
            63446936,
            63447440,
            63449345,
            63447899,
            63445385,
            63454155,
            63447268,
            63446929,
            63448203,
            63460143,
            63447809,
            63449173,
            63454319,
            63450374,
            63450053
        ],
        "A": [
            63437545,
            63439551,
            63452092,
            63445337,
            63447252,
            63440937,
            63439822,
            63438397,
            63438564,
            63453424,
            63437913,
            63439495,
            63438907,
            63456486,
            63442538,
            63445415,
            63444316,
            63440390,
            63439231
        ]
    },
    "name": "F. Tree Factory",
    "statement": "Bytelandian Tree Factory produces trees for all kinds of industrial\r\napplications. You have been tasked with optimizing the production of a\r\ncertain type of tree for an especially large and important order.The\r\ntree in question is a rooted tree with n vertices labelled with distinct\r\nintegers from 0 to n - 1. The vertex labelled 0 is the root of the tree,\r\nand for any non-root vertex v the label of its parent p(v) is less than\r\nthe label of v.All trees at the factory are made from bamboo blanks. A\r\nis a rooted tree such that each vertex has exactly one child, except for\r\na single leaf vertex with no children. The vertices of a bamboo blank\r\ncan be labelled arbitrarily before its processing is started.To process\r\na bamboo into another tree a single type of operation can be made:\r\nchoose an arbitrary non-root vertex v such that its parent p(v) is not a\r\nroot either. The operation consists of changing the parent of v to its\r\nparent\u2019s parent p(p(v)). Note that parents of all other vertices remain\r\nunchanged, in particular, the subtree of v does not change.Efficiency is\r\ncrucial, hence you have to minimize the number of operations to make the\r\ndesired tree from a bamboo blank. Construct any optimal sequence of\r\noperations to produce the desired tree.Note that the labelling of the\r\nresulting tree has to coincide with the labelling of the desired tree.\r\nFormally, the labels of the roots have to be equal, and for non-root\r\nvertices with the same label the labels of their parents should be the\r\nsame.It is guaranteed that for any test present in this problem an\r\nanswer exists, and further, an optimal sequence contains at most 10^6\r\noperations. Note that .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int maxn=(1e5)+10;\nint n,dep[maxn],t1,d[maxn];\nint t2,e[maxn*10];\nvector<int> g[maxn];\nvoid dfs(int u) {\n\tfor (int i=0;i<g[u].size();i++)\n\t\tdfs(g[u][i]),dep[u]=max(dep[u],dep[g[u][i]]+1);\n}\nvoid DFS(int u) {\n\td[++t1]=u;\n\tint mx=0;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (dep[v]>dep[mx]||!mx) mx=v;\n\t}\n\tint lst=mx;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (v==mx) continue;\n\t\te[++t2]=lst;\n\t\tg[v].push_back(lst);\n\t\tdep[v]=max(dep[v],dep[lst]+1);\n\t\tlst=v;\n\t}\n\tif (lst) DFS(lst);\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tread(n); int x,y;\n\t//printf(\"%d\\n\",n);\n\tfor (int i=2;i<=n;i++) {\n\t\tread(x); x++;\n\t\tg[x].push_back(i);\n\t\t//printf(\"%d\\n\",x-1);\n\t}\n\tdfs(1);\n\tDFS(1);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",d[i]-1);\n\tprintf(\"\\n\");\n\treverse(e+1,e+t2+1);\n\tprintf(\"%d\\n\",t2);\n\tfor (int i=1;i<=t2;i++) printf(\"%d \",e[i]-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Tree Factory.json",
    "editorial_link": "https://codeforces.com//blog/entry/70898",
    "editorial": "Let's solve the problem backwards: given a tree, transform it into a bamboo with reverse operations. A reverse operation in this context looks like this: given a vertex v\n and its two distinct children u\n and w\n, make w\n the parent of u\n.\n\nWhat's the lower bound on the number of operations we need to make? We can see that the depth of the tree, i.e. the length of the longest vertical path starting from the root, can increase by at most one per operation. On the other hand, the depth of the bamboo is n?1\n. Therefore, we'll need to make at least n?1?(initial depth of the tree)\n operations.\n\nThis number would always be enough if for any non-bamboo tree we could find an operation that would increase its depth. And indeed we can: consider a longest path starting from the root. If all its vertices have at most one children, the tree is a bamboo and we are done. Otherwise, take any vertex v\n on the path with at least two children, its child u\n on the longest path, and any other child w\n, then make w\n the parent of u\n. One can see that there is a longer path now.\n\nOne efficient way to do these operations successively is to keep track of the lowest candidate for u\n. After applying an operation, the candidate is either u\n again, or one of its ancestors. With standard amortized analysis, we can now perform all these operations in O(n)\n time.\n\nTo output the answer, print the labelling of the final bamboo you obtain, followed by the reverse sequence of the operations you've made."
}