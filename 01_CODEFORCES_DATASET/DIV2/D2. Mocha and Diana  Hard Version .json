{"link": "https://codeforces.com//contest/1559/problem/D2", "problemId": "1078716", "problem_idx": "D2", "shortId": "1559D2", "contest_number": "1559", "problem_submissions": {"D2": [125995494, 126036275, 125997805, 126009493, 126011074, 126008472, 126038189, 126005034, 126002626, 125999937, 126005467, 126005672, 126010740, 126006398, 126010473, 126011364, 126008532, 126039421, 126011147, 126008772, 126009477, 126012187, 126015439], "E": [125974477, 125957083, 125970146, 125961617, 125979742, 125976394, 125982640, 125984935, 125974866, 125973356, 125969825, 125970524, 125976580, 125988330, 125973822, 126039403, 125988355, 125979721, 125979087, 125993147, 125980201], "D1": [125944192, 125969277, 125954678, 125967980, 125953790, 125959046, 125952547, 125954032, 125984889, 125979313, 125972340, 125951958, 125981117, 125956127, 125979601, 125965087, 125984172, 125984989, 125957742, 125959852], "C": [125940467, 125947734, 125943938, 125945955, 125945435, 125954449, 125957788, 125959041, 125956677, 125953215, 125950646, 125956630, 125949058, 125946362, 125956010, 125954414, 125947800, 125952498, 125949073, 125951269], "B": [125938532, 125941057, 125937911, 125940291, 125940964, 125944375, 125941668, 125940207, 125948124, 125946366, 125951888, 125939403, 125942974, 125940405, 125941485, 125941898, 125941189, 125945855, 125940756, 125941646], "A": [125934889, 125935929, 125934894, 125936023, 125936520, 125944189, 125936005, 125935279, 125938830, 125941957, 125944772, 125935138, 125938909, 125935398, 125941621, 125935239, 125935795, 125938400, 125934867, 125935241]}, "name": "D2. Mocha and Diana  Hard Version ", "statement": "A forest is an undirected graph without cycles (not necessarily\r\nconnected).Mocha and Diana are friends in Zhijiang, both of them have a\r\nforest with nodes numbered from 1 to n, and they would like to add edges\r\nto their forests such that: After adding edges, both of their graphs are\r\nstill forests. They add the same edges. That is, if an edge (u, v) is\r\nadded to Mocha\u2019s forest, then an edge (u, v) is added to Diana\u2019s forest,\r\nand vice versa. Mocha and Diana want to know the maximum number of edges\r\nthey can add, and which edges to add.\r\n", "solutions": ["#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,ssse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n//#define int long long\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nconst int INF = 0x3f3f3f3f;\nconst int NINF = -INF - 1;\nconst int N = 1e5 + 10;\nint n, m1, m2, cnt, fa[2][N], sav[N];\nstd::vector<std::pair<int, int> > ans;\nvoid init(int m) { rep(i, 1, m) fa[0][i] = fa[1][i] = i; }\nint get(int i, int x) { return fa[i][x] == x ? x : fa[i][x] = get(i, fa[i][x]); }\n\nstruct Node {\n    int w, p;\n    bool operator < (const Node &x) const { return x.w > w; }\n};\nstd::multiset<Node> s[N << 1], temp;\nint solve() {\n    rep(i, 1, 25) {\n        int x = rand() % n + 1;\n        rep(j, 1, n) {\n            if(get(0, x) != get(0, j) && get(1, x) != get(1, j)) {\n                fa[0][get(0, x)] = get(0, j);\n                fa[1][get(1, x)] = get(1, j);\n                ans.eb(x, j);\n            }\n        }\n    }\n    rep(i, 1, n) {\n        if(!sav[get(0, i)]) s[++cnt].insert({get(1, i), i}), sav[get(0, i)] = cnt;\n        else s[sav[get(0, i)]].insert({get(1, i), i});\n    }\n    rep(i, 1, cnt) {\n        temp.insert(*s[i].begin());\n        int tmp = (*s[i].begin()).w;\n        for(auto x : s[i])\n            if(tmp != x.w) temp.insert(x), tmp = x.w;\n        swap(temp, s[i]), temp.clear();\n    }\n    int tot = 0, sum = 0;\n    rep(i, 2, cnt) {\n        for(auto x : s[i]) temp.insert({get(1, x.p), x.p});\n        swap(temp, s[i]);\n        temp.clear(); temp.insert(*s[i].begin());\n        int tmp = (*s[i].begin()).w;\n        for(auto x : s[i])\n            if(tmp != x.w) temp.insert(x), tmp = x.w;\n        swap(temp, s[i]), temp.clear();\n        if(s[i].size() <= s[i - 1].size()) swap(s[i],s[i - 1]);\n        if(s[i - 1].size() == s[i].size() && s[i - 1].size() == 1 && (*s[i - 1].begin()).w == (*s[i].begin()).w) {\n            if(!tot) s[cnt+(++sum)].insert({get(1,(*s[i-1].begin()).p),(*s[i-1].begin()).p});\n        }\n        else {\n            if((*s[i - 1].begin()).w == (*s[i].begin()).w) s[i].erase(s[i].begin());\n            ans.eb((*s[i - 1].begin()).p, (*s[i].begin()).p);\n            fa[1][get(1, (*s[i - 1].begin()).p)] = get(1, (*s[i].begin()).p);\n            if(s[i].find((*s[i - 1].begin())) != s[i].end()) s[i].erase(s[i].find((*s[i - 1].begin())));\n            if(s[i].find((*s[i].begin())) != s[i].end()) s[i].erase(s[i].find((*s[i].begin())));\n            s[i].insert({get(1, (*s[i - 1].begin()).p), (*s[i - 1].begin()).p});\n            for(auto x:s[i-1]) {\n                if(x.w != (*s[i - 1].begin()).w && x.w != (*s[i].begin()).w)\n                    if(s[i].find(x) == s[i].end())\n                        s[i].insert(x);\n            }\n        }\n        if(cnt == i && !tot) cnt += sum, tot++;\n    }\n    std::cout << ans.size() << std::endl;\n    for(auto x : ans) std::cout <<x.fi << \" \" << x.se <<std::endl;\n    return 0;\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    srand(time(NULL));\n    std::cin >> n >> m1 >> m2;\n    init(n);\n    rep(i, 1, m1) {\n        int u, v; std::cin >> u >> v;\n        fa[0][get(0, u)] = get(0, v);\n    }\n    rep(i, 1, m2) {\n        int u, v; std::cin >> u >> v;\n        fa[1][get(1, u)] = get(1, v);\n    }\n    return solve();\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "dfs and similar", "dsu", "graphs", "greedy", "trees", "two pointers"], "dificulty": "2500", "interactive": false}