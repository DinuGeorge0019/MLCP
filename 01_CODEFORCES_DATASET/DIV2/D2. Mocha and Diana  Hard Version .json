{
    "link": "https://codeforces.com//contest/1559/problem/D2",
    "problemId": "1078716",
    "problem_idx": "D2",
    "shortId": "1559D2",
    "contest_number": "1559",
    "problem_submissions": {
        "D2": [
            125995494,
            126036275,
            125997805,
            126009493,
            126011074,
            126008472,
            126038189,
            126005034,
            126002626,
            125999937,
            126005467,
            126005672,
            126010740,
            126006398,
            126010473,
            126011364,
            126008532,
            126039421,
            126011147,
            126008772,
            126009477,
            126012187,
            126015439
        ],
        "E": [
            125974477,
            125957083,
            125970146,
            125961617,
            125979742,
            125976394,
            125982640,
            125984935,
            125974866,
            125973356,
            125969825,
            125970524,
            125976580,
            125988330,
            125973822,
            126039403,
            125988355,
            125979721,
            125979087,
            125993147,
            125980201
        ],
        "D1": [
            125944192,
            125969277,
            125954678,
            125967980,
            125953790,
            125959046,
            125952547,
            125954032,
            125984889,
            125979313,
            125972340,
            125951958,
            125981117,
            125956127,
            125979601,
            125965087,
            125984172,
            125984989,
            125957742,
            125959852
        ],
        "C": [
            125940467,
            125947734,
            125943938,
            125945955,
            125945435,
            125954449,
            125957788,
            125959041,
            125956677,
            125953215,
            125950646,
            125956630,
            125949058,
            125946362,
            125956010,
            125954414,
            125947800,
            125952498,
            125949073,
            125951269
        ],
        "B": [
            125938532,
            125941057,
            125937911,
            125940291,
            125940964,
            125944375,
            125941668,
            125940207,
            125948124,
            125946366,
            125951888,
            125939403,
            125942974,
            125940405,
            125941485,
            125941898,
            125941189,
            125945855,
            125940756,
            125941646
        ],
        "A": [
            125934889,
            125935929,
            125934894,
            125936023,
            125936520,
            125944189,
            125936005,
            125935279,
            125938830,
            125941957,
            125944772,
            125935138,
            125938909,
            125935398,
            125941621,
            125935239,
            125935795,
            125938400,
            125934867,
            125935241
        ]
    },
    "name": "D2. Mocha and Diana  Hard Version ",
    "statement": "A forest is an undirected graph without cycles (not necessarily\r\nconnected).Mocha and Diana are friends in Zhijiang, both of them have a\r\nforest with nodes numbered from 1 to n, and they would like to add edges\r\nto their forests such that: After adding edges, both of their graphs are\r\nstill forests. They add the same edges. That is, if an edge (u, v) is\r\nadded to Mocha\u2019s forest, then an edge (u, v) is added to Diana\u2019s forest,\r\nand vice versa. Mocha and Diana want to know the maximum number of edges\r\nthey can add, and which edges to add.\r\n",
    "solutions": [
        "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,ssse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n//#define int long long\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nconst int INF = 0x3f3f3f3f;\nconst int NINF = -INF - 1;\nconst int N = 1e5 + 10;\nint n, m1, m2, cnt, fa[2][N], sav[N];\nstd::vector<std::pair<int, int> > ans;\nvoid init(int m) { rep(i, 1, m) fa[0][i] = fa[1][i] = i; }\nint get(int i, int x) { return fa[i][x] == x ? x : fa[i][x] = get(i, fa[i][x]); }\n\nstruct Node {\n    int w, p;\n    bool operator < (const Node &x) const { return x.w > w; }\n};\nstd::multiset<Node> s[N << 1], temp;\nint solve() {\n    rep(i, 1, 25) {\n        int x = rand() % n + 1;\n        rep(j, 1, n) {\n            if(get(0, x) != get(0, j) && get(1, x) != get(1, j)) {\n                fa[0][get(0, x)] = get(0, j);\n                fa[1][get(1, x)] = get(1, j);\n                ans.eb(x, j);\n            }\n        }\n    }\n    rep(i, 1, n) {\n        if(!sav[get(0, i)]) s[++cnt].insert({get(1, i), i}), sav[get(0, i)] = cnt;\n        else s[sav[get(0, i)]].insert({get(1, i), i});\n    }\n    rep(i, 1, cnt) {\n        temp.insert(*s[i].begin());\n        int tmp = (*s[i].begin()).w;\n        for(auto x : s[i])\n            if(tmp != x.w) temp.insert(x), tmp = x.w;\n        swap(temp, s[i]), temp.clear();\n    }\n    int tot = 0, sum = 0;\n    rep(i, 2, cnt) {\n        for(auto x : s[i]) temp.insert({get(1, x.p), x.p});\n        swap(temp, s[i]);\n        temp.clear(); temp.insert(*s[i].begin());\n        int tmp = (*s[i].begin()).w;\n        for(auto x : s[i])\n            if(tmp != x.w) temp.insert(x), tmp = x.w;\n        swap(temp, s[i]), temp.clear();\n        if(s[i].size() <= s[i - 1].size()) swap(s[i],s[i - 1]);\n        if(s[i - 1].size() == s[i].size() && s[i - 1].size() == 1 && (*s[i - 1].begin()).w == (*s[i].begin()).w) {\n            if(!tot) s[cnt+(++sum)].insert({get(1,(*s[i-1].begin()).p),(*s[i-1].begin()).p});\n        }\n        else {\n            if((*s[i - 1].begin()).w == (*s[i].begin()).w) s[i].erase(s[i].begin());\n            ans.eb((*s[i - 1].begin()).p, (*s[i].begin()).p);\n            fa[1][get(1, (*s[i - 1].begin()).p)] = get(1, (*s[i].begin()).p);\n            if(s[i].find((*s[i - 1].begin())) != s[i].end()) s[i].erase(s[i].find((*s[i - 1].begin())));\n            if(s[i].find((*s[i].begin())) != s[i].end()) s[i].erase(s[i].find((*s[i].begin())));\n            s[i].insert({get(1, (*s[i - 1].begin()).p), (*s[i - 1].begin()).p});\n            for(auto x:s[i-1]) {\n                if(x.w != (*s[i - 1].begin()).w && x.w != (*s[i].begin()).w)\n                    if(s[i].find(x) == s[i].end())\n                        s[i].insert(x);\n            }\n        }\n        if(cnt == i && !tot) cnt += sum, tot++;\n    }\n    std::cout << ans.size() << std::endl;\n    for(auto x : ans) std::cout <<x.fi << \" \" << x.se <<std::endl;\n    return 0;\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    srand(time(NULL));\n    std::cin >> n >> m1 >> m2;\n    init(n);\n    rep(i, 1, m1) {\n        int u, v; std::cin >> u >> v;\n        fa[0][get(0, u)] = get(0, v);\n    }\n    rep(i, 1, m2) {\n        int u, v; std::cin >> u >> v;\n        fa[1][get(1, u)] = get(1, v);\n    }\n    return solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "trees",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Mocha and Diana  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/93898",
    "editorial": "To have a clearer understanding, let\u00e2\u0080\u0099s visualize the problem with a grid\r\nwhere each row is a component in the left forest and each column is a\r\ncomponent in the right forest. For example, the cell (i,j) contains\r\nvertexes which belongs to component in the left forest and component in\r\nthe right tree. (Some cells may be empty.) An operation corresponds to\r\nfinding two filled cells in different rows and different columns,\r\nmerging the two rows, and merging the two columns.Now we need to make\r\noperation rapidly. For each row, we maintain a set of the different\r\ncolumns with filled cells in this row. Symmetrically, for each column we\r\nmaintain a set of the different rows with filled cells in this column.To\r\nmerge two rows, we insert the elements of the smaller set into the\r\nlarger set. The smaller set is now useless, and we delete it from every\r\ncolumn in the set and insert the larger one. Since the data structure is\r\nsymmetric, merging two columns is similar.Without loss of generality,\r\nassume there are fewer rows than columns. If there is a row whose set\r\nhas more than 1 element, we can pick it and any other row, and find an\r\noperation we can make. Otherwise if all rows are singletons, then we\r\nknow the sets are all disjoint because there are more columns than rows.\r\nSo we can pick any two sets and make an operation, and then there\u00e2\u0080\u0099s a\r\nset with more than 1 element. Maintaining which rows have sets with size\r\nmore than 1 is not hard.For each operation, we need to output the\r\ncorresponding vertex in the original two forest. Firstly, choose a\r\nvertex as the representative of each cell, because all vertexes in a\r\ncell can be seen as equivalent. Then, when merging two rows or columns,\r\nwe just insert the representative vertexes at the same time.There can be\r\nat most merge operations and the total complexity of them will be . This\r\nis because an element moves to a new row/column times and each move is\r\ntime (using STL set in cpp).Overall, it\u00e2\u0080\u0099s time and space.\r\n"
}