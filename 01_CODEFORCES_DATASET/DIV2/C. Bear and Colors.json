{
    "link": "https://codeforces.com//contest/673/problem/C",
    "problemId": "59808",
    "problem_idx": "C",
    "shortId": "673C",
    "contest_number": "673",
    "problem_submissions": {
        "E": [
            17790544,
            17790298,
            17792643,
            17795142,
            17797198,
            17796072,
            17796678,
            17794290,
            17802948,
            18498821,
            18454059,
            18453934,
            18453804,
            27208468,
            17814502,
            17814492,
            17810486
        ],
        "A": [
            17785371,
            17780028,
            17783006,
            17781229,
            17780841,
            17781392,
            17781436,
            17783310,
            17780077,
            17780098,
            17783943,
            17780241,
            17780697,
            17780142,
            17780713,
            17780906,
            17780033,
            17782963,
            17780095,
            17780488
        ],
        "D": [
            17784968,
            17784163,
            17787638,
            17787311,
            17788261,
            17790516,
            17791783,
            17788147,
            17787202,
            17788591,
            17787856,
            17787228,
            17787665,
            17788331,
            17788505,
            17790808,
            17791801,
            17789992,
            17788978,
            17790173
        ],
        "B": [
            17783887,
            17780728,
            17785147,
            17782968,
            17783327,
            17784516,
            17785052,
            17786520,
            17783375,
            17784877,
            17782865,
            17784125,
            17784706,
            17782517,
            17784194,
            17786784,
            17781561,
            17784108,
            17784745,
            17783935
        ],
        "C": [
            17780670,
            17782033,
            17785575,
            17788307,
            17784829,
            17786955,
            17787316,
            17789788,
            17784945,
            17782021,
            17781157,
            17785332,
            17782835,
            17785106,
            17786557,
            17783986,
            17790134,
            17785539,
            17783083,
            17786914
        ],
        "F": [
            17799743
        ]
    },
    "name": "C. Bear and Colors",
    "statement": "Bear Limak has colored balls, arranged in one long row. Balls are\r\nnumbered through , from left to right. There are possible colors, also\r\nnumbered through . The -th ball has color .For a fixed interval (set of\r\nconsecutive elements) of balls we can define a color. It’s a color\r\noccurring the biggest number of times in the interval. In case of a tie\r\nbetween some colors, the one with the smallest number (index) is chosen\r\nas dominant.There are non-empty intervals in total. For each color, your\r\ntask is to count the number of intervals in which this color is\r\ndominant.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <limits.h>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N_ = 5050;\nint N, T[N_];\nint C[N_];\nint ans[N_];\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &T[i]);\n\t}\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tfill(C, C+N+1, 0);\n\t\tint best_c = 0, best_t = -1;\n\t\tfor(int j = i; j <= N; j++) {\n\t\t\tint c = ++C[T[j]];\n\t\t\tif(c > best_c || (c == best_c && T[j] < best_t))\n\t\t\t\tbest_c = c, best_t = T[j];\n\t\t\t++ans[best_t];\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; i++) printf(\"%d \", ans[i]);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bear and Colors.json",
    "editorial_link": "https://codeforces.com//blog/entry/44754",
    "editorial": "(invented by Errichto) We are going to iterate over all intervals. Let’s\r\nfirst fix the left end of the interval and denote it by . Now, we\r\niterate over the right end . When we go from to then we get one extra\r\nball with color . In one global array we can keep the number of\r\noccurrences of each color (we can clear the array for each new ). We\r\nshould increase by one and then check whether becomes a new dominant\r\ncolor. But how to do it? Additionally, let’s keep one variable with the\r\ncurrent dominant color. When we go to then we should whether or ( and ).\r\nThe second condition checks which color has smaller index (in case of a\r\ntie). And we must increase by one then because we know that is dominant\r\nfor the current interval. At the end, print values . 18286663 (invented\r\nby Errichto) There is no solution if or . But for and you can construct\r\nthe following graph: Here, cities denote other cities in any order you\r\nchoose (cities different than ). You should print in the first line, and\r\nin the second line. Two not very hard challenges for you. Are you able\r\nto prove that the answer doesn’t exist for ? Can you solve the problem\r\nif the four given cities don’t have to be distinct but it’s guaranteed\r\nthat and ? 18286683 (invented by Radewoosh) When we repeat something and\r\neach time we have probability to succeed then the expected number or\r\ntries is , till we succeed. How to calculate the expected time for one\r\nregion ? For each in some moment we will try to beat this level and then\r\nthere will be tokens in the bag, including tokens allowing us to beat\r\nthis new level. The probability to succeed is , so the expected time is\r\n. So, in total we should sum up values for . Ok, we managed to\r\nunderstand the actual problem. You can now stop and try to find a slow\r\nsolution in . Hint: use the dynamic programming. Now let’s write formula\r\nfor , as the minimum over denoting the end of the previous region: So we\r\ncan use convex hull trick to calculate it in . You should also get AC\r\nwith a bit slower divide&conquer trick, if it’s implemented carefully.\r\n18286696 (invented by Radewoosh) Let’s say that every company has one\r\nparent (a company it follows). Also, every copmany has some (maybe\r\nempty) set of children. It’s crucial that sets of children are disjoint.\r\nFor each company let’s keep (and always update) one value, equal to the\r\nsum of: It turns out that after each query only the above sum changes\r\nonly for a few values. If starts to follows then you should care about .\r\nAnd maybe and if you want to be sure. You can stop reading now for a\r\nmoment and analyze that indeed other companies will keep the same sum,\r\ndescribed above. Ok, but so far we don’t count the income coming from\r\nparent’s fanpage. But, for each company we can store all its children in\r\none set. All children have the same \"income from parent’s fanpage\"\r\nbecause they have the same parent. So, in set you can keep children\r\nsorted by the sum described above. Then, we should always puts the\r\nextreme elements from sets in one global set. In the global set you care\r\nabout the total income, equal to the sum described above and this new\r\n\"income from parent\". Check codes for details. The complexity should be\r\n, with big constant factor. 18286747 (invented by Errichto) Let denote\r\nthe probability that subtree (if attacked now) would have height at most\r\n. The first observation is that we don’t care about big because it’s\r\nvery unlikely that a path with e.g. 100 edges will survive. Let’s later\r\ntalk about choosing and now let’s say that it’s enough to consider up to\r\n. When we should answer a query for subtree then we should sum up to get\r\nthe answer. The other query is harder. Let’s say that a new vertex is\r\nattached to vertex . Then, among only changes (other values stay the\r\nsame). Also, one value changes, and so does and so on. You should\r\niterate over vertices (each time going to parent) and update the\r\ncorresponding value. TODO puts here come formula for updating value. The\r\ncomplexity is . You may think that is enough because is small enough.\r\nUnfortunately, there exist malicious tests. Consider a tree with paths\r\nfrom root, each with length . Now, we talk about the probability of\r\nmagnitude: which is more than for .\r\nhttp://www.wolframalpha.com/input/?i=1+-+(1-(1\r\n",
    "hint": []
}