{
    "link": "https://codeforces.com//contest/402/problem/D",
    "problemId": "7181",
    "problem_idx": "D",
    "shortId": "402D",
    "contest_number": "402",
    "problem_submissions": {
        "D": [
            6050292,
            6050270,
            6036208,
            6037449,
            6037811,
            6039018,
            6037509,
            6040120,
            6039818,
            6037103,
            6036738,
            6052225,
            6039860,
            6039785,
            6039774,
            6040232
        ],
        "E": [
            6038241,
            6039548,
            6034213,
            6036604,
            6037264,
            6040176,
            6052113,
            6052116,
            6052103,
            6052109,
            6058832,
            6040173
        ],
        "C": [
            6035300,
            6033009,
            6036584,
            6037830,
            6033803,
            6032415,
            6034126,
            6031244,
            6034759,
            6038445,
            6040085,
            6032494,
            6038144,
            6039496,
            6032240,
            6032451,
            6036956,
            6037470,
            6036329
        ],
        "B": [
            6031930,
            6031993,
            6031901,
            6040691,
            6032027,
            6037381,
            6032782,
            6035428,
            6032969,
            6032924,
            6042413,
            6034839,
            6033326,
            6031868,
            6052288,
            6052274,
            6052263,
            6035033,
            6034789,
            6032424,
            6034406,
            6032490
        ],
        "A": [
            6030878,
            6030962,
            6031937,
            6034701,
            6030965,
            6033265,
            6031812,
            6031632,
            6036793,
            6034363,
            6031101,
            6031359,
            6030877,
            6031259,
            6031075,
            6033654,
            6031474,
            6031051
        ]
    },
    "name": "D. Upgrading Array",
    "statement": "You have an array of positive integers and a set of prime numbers . The\r\nprime numbers that do not occur in the set are considered . The of array\r\nis the sum , where function is determined as follows: ; Let\u2019s assume\r\nthat is the minimum prime divisor of . If is a good prime, then ,\r\notherwise . You are allowed to perform an arbitrary (probably zero)\r\nnumber of operations to improve array . The is the following sequence of\r\nactions: Choose some number () and calculate the value = GCD(). Apply\r\nthe assignments: , , , . What is the maximum beauty of the array you can\r\nget?\r\n",
    "solutions": [
        "//Codeforces 236\n#include <cmath>\n\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int MAX_D = 40100;\nconst int MAX_N = 5005;\n\nint N, M, K;\nint a[MAX_N];\nint gcds[MAX_N];\nunordered_set<int> bad;\n\ninline int gcd(int a, int b);\ninline int f(int num);\n\nint main() {\n  ios_base::sync_with_stdio(0);\n\n  cin >> N >> M;\n  for (int i = 1; i <= N; i += 1) cin >> a[i];\n  for (int i = 1, bp; i <= M; i += 1) {\n    cin >> bp;\n    bad.insert(bp);\n  }\n\n  gcds[1] = a[1];\n  for (int i = 2; i <= N; i += 1)\n    gcds[i] = gcd(gcds[i - 1], a[i]);\n\n  for (int i = N; i > 0; i -= 1) {\n    int d = f(gcds[i]);\n    if (d < 0) {\n      for (int j = 1; j <= i; j += 1) {\n        a[j] /= gcds[i];\n        gcds[j] /= gcds[i];\n      }\n    }\n  }\n\n  int result = 0;\n  for (int i = 1; i <= N; i += 1)\n    result += f(a[i]);\n\n  cout << result;\n  return 0;\n}\n\ninline int f(int num) {\n  int r = 0;\n  for (int d = 2; d * d <= num; d += 1) {\n    while (num % d == 0) {\n      num /= d;\n      r += (bad.count(d) ? -1 : 1);\n    }\n  }\n  if (num > 1)\n    r += (bad.count(num) ? -1 : 1);\n  return r;\n}\n\ninline int gcd(int a, int b) {\n  return (b == 0 ? a : gcd(b, a % b));\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Upgrading Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/10972",
    "editorial": "I will describe two solutions. First. Dynamic programming approach.\r\nLet\u00e2\u0080\u0099s calculate an DP which is the best possible answer we can achieve,\r\nif current prefix has length and we used operation of Upgrading last\r\ntime in position . It is clear to understand, that we should iterate\r\nfrom to , and from to . There are only two transitions: Second. Greedy.\r\nLet\u00e2\u0080\u0099s find position , which can upgrade our answer. If there some values\r\nof we will take most right position. We will add this position to the\r\nanswer and upgrade our answer. Why it\u00e2\u0080\u0099s correct? Let\u00e2\u0080\u0099s fix an optimal\r\nsolution (sequence of position, where we used an upgrading operation) .\r\nAlso we have an solution which was built by using greedy . It\u00e2\u0080\u0099s clear,\r\nthat , because all position with cannot upgrade anything (otherwise\r\ngreedy will choose it as first position). In other hand, , because\r\notherwise we can upgrade in position and make answer better. So, , and\r\nafter that we can use our propositions for big indexes .\r\n"
}