{
    "link": "https://codeforces.com//contest/1467/problem/E",
    "problemId": "858756",
    "problem_idx": "E",
    "shortId": "1467E",
    "contest_number": "1467",
    "problem_submissions": {
        "A": [
            103781028,
            103732975,
            103789355,
            103727649,
            103776107,
            103728134,
            103733285,
            103731503,
            103734108,
            103745618,
            103776057,
            103728589,
            103737241,
            103730063,
            103728536,
            103782858,
            103740519,
            103780744,
            103730125,
            103733429
        ],
        "B": [
            103776223,
            103763378,
            103735716,
            103743111,
            103753392,
            103747731,
            103744698,
            103825399,
            103745451,
            103752738,
            103745778,
            103769242,
            103752112,
            103747036,
            103750474,
            103751826,
            103737251,
            103751660,
            103806893,
            103752900,
            103749089
        ],
        "C": [
            103771486,
            103780246,
            103746693,
            103766971,
            103761062,
            103800886,
            103767932,
            103776708,
            103770869,
            103762101,
            103786323,
            103768958,
            103786670,
            103776678,
            103772104,
            103785995,
            103773040,
            103799284,
            103805177,
            103785884
        ],
        "D": [
            103764796,
            103781468,
            103759529,
            103758056,
            103768367,
            103763856,
            103774343,
            103763817,
            103781960,
            103777881,
            103743423,
            103779264,
            103772933,
            103764332,
            103785499,
            103746072,
            103785798,
            103785854,
            103759639,
            103785071
        ],
        "E": [
            103749029,
            103758281,
            103840304,
            103785768,
            103786917,
            103785220,
            103779762,
            103798134,
            103802685,
            103796217,
            103804930,
            103797788,
            103804889,
            103803175,
            103801192,
            103810505,
            103804335,
            103855637,
            103803060,
            103803658,
            103762986,
            103795272,
            103809021
        ]
    },
    "name": "E. Distinctive Roots in a Tree",
    "statement": "You are given a tree with n vertices. Each vertex i has a value a_i\r\nassociated with it.Let us root the tree at some vertex v. The vertex v\r\nis called a if the following holds: in all paths that start at v and end\r\nat some other node, all the values encountered are distinct. Two\r\ndifferent paths may have values in common but a single path must have\r\nall distinct values.Find the number of in the tree.\r\n",
    "solutions": [
        "// author: xay5421\n// created: Fri Jan  8 22:33:36 2021\n#include<bits/stdc++.h>\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,K=20;\nint n,tt,a[N],id[N],ind,dep[N],tin[N],tou[N],cf[N],fa[N][K];\nint pp,lnk[N],nxt[N*2],to[N*2];\nvoid ae(int k1,int k2){to[++pp]=k2,nxt[pp]=lnk[k1],lnk[k1]=pp;}\nvoid dfs(int k1,int k2){\n\ttin[k1]=++ind,fa[k1][0]=k2,dep[k1]=dep[k2]+1;\n\trep(i,1,K-1)fa[k1][i]=fa[fa[k1][i-1]][i-1];\n\tfor(int i=lnk[k1];i;i=nxt[i])if(to[i]!=k2)dfs(to[i],k1);\n\ttou[k1]=ind;\n}\nint jump(int k1,int k2){\n\tfor(int i=K-1;i>=0;--i)if(k2>>i&1)k1=fa[k1][i];\n\treturn k1;\n}\nvoid sol(vector<int>v){\n\tif(SZ(v)==1)return;\n\tsort(v.begin(),v.end(),[&](int k1,int k2){return tin[k1]<tin[k2];});\n\t++tt;\n\tif(tin[v.back()]<=tou[v[0]]){\n\t\trep(i,1,SZ(v)-2){\n\t\t\tif(tin[v[i+1]]<=tou[v[i]]){\n\t\t\t\tputs(\"0\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tvector<int>son;\n\t\trep(i,1,SZ(v)-1){\n\t\t\tint k1=v[i];\n\t\t\tk1=jump(k1,dep[k1]-dep[v[0]]-1);\n\t\t\tson.push_back(k1);\n\t\t}\n\t\tsort(son.begin(),son.end());\n\t\tson.erase(unique(son.begin(),son.end()),son.end());\n\t\tif(SZ(son)>1){\n\t\t\tputs(\"0\");\n\t\t\texit(0);\n\t\t}\n\t\tfor(const auto&x:son){\n\t\t\t++cf[tin[x]],--cf[tou[x]+1];\n\t\t}\n\t\trep(i,1,SZ(v)-1)--cf[tin[v[i]]],++cf[tou[v[i]]+1];\n\t}else{\n\t\trep(i,0,SZ(v)-2){\n\t\t\tif(tin[v[i+1]]<=tou[v[i]]){\n\t\t\t\tputs(\"0\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\t++cf[1],--cf[n+1];\n\t\trep(i,0,SZ(v)-1)--cf[tin[v[i]]],++cf[tou[v[i]]+1];\n\t}\n}\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%d\",&a[i]),id[i]=i;\n\trep(i,1,n-1){\n\t\tint k1,k2;\n\t\tscanf(\"%d%d\",&k1,&k2);\n\t\tae(k1,k2),ae(k2,k1);\n\t}\n\tdfs(1,0);\n\tsort(id+1,id+1+n,[&](int k1,int k2){return a[k1]<a[k2];});\n\tfor(int i=1,j;i<=n;i=j){\n\t\tj=i+1;\n\t\twhile(j<=n&&a[id[i]]==a[id[j]])++j;\n\t\tvector<int>v;\n\t\trep(k,i,j-1)v.push_back(id[k]);\n\t\tsol(v);\n\t}\n\tint ans=0;\n\trep(i,1,n)cf[i]+=cf[i-1],ans+=cf[i]==tt;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Distinctive Roots in a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/86566",
    "editorial": "Root the tree arbitrarily. Consider any node . Let us remove from the\r\ntree and examine the trees that will be created in the resultant\r\nforest.Let\u00e2\u0080\u0099s say that a particular tree was attached to through node .\r\nFurther, let\u00e2\u0080\u0099s say that this tree has some node satisfying . Then\r\nclearly, if any distinctive root exists, it must be in this component,\r\nbecause if it were in any other component, then, when you root the tree\r\nat that node, you will get a path from the root containing both and .\r\nLet us add a directed edge from to , signifying that all distinctive\r\nroots must be in this particular component.Once we have repeated this\r\nfor all nodes, we now have a set of directed edges. All distinctive\r\nroots must have each of these edges pointing to it. We can check this\r\nfor all nodes using the rerooting technique. Link cut tree or difference\r\narray works as well.Note: In order to check the number of nodes which\r\noccur in a subtree, do a pre-order traversal of the tree. Create a map\r\nwhich maps a value to the dfs-in times of all nodes that satisfy . Now,\r\ntwo lower-bounds on this shall tell us the number of occurrences in the\r\nsubtree in logarithmic time. Also, with this information, you can also\r\ncalculate the number of times occurs in the tree attached to \u00e2\u0080\u0099s parent.\r\n"
}