{
    "link": "https://codeforces.com//contest/525/problem/C",
    "problemId": "25277",
    "problem_idx": "C",
    "shortId": "525C",
    "contest_number": "525",
    "problem_submissions": {
        "E": [
            10469529,
            10465773,
            10462320,
            10473852,
            10470314,
            10468913,
            10471407,
            10472352,
            10471463,
            10468119,
            10482016
        ],
        "A": [
            10466492,
            10459383,
            10459851,
            10468884,
            10459356,
            10464661,
            10460865,
            10459447,
            10463645,
            10460601,
            10459420,
            10459625,
            10468470,
            10464011,
            10460662,
            10460403,
            10460186,
            10460076,
            10465668,
            10459793
        ],
        "D": [
            10466031,
            10468890,
            10468989,
            10474860,
            10468593,
            10472101,
            10470926,
            10472770,
            10473464,
            10480430,
            10472569,
            10473468,
            10468745,
            10475146
        ],
        "C": [
            10463905,
            10462286,
            10467821,
            10468051,
            10468445,
            10463570,
            10464786,
            10471337,
            10464431,
            10462510,
            10465576,
            10466372,
            10462777,
            10467129,
            10480410,
            10469681,
            10469099,
            10467204
        ],
        "B": [
            10459849,
            10460170,
            10461961,
            10469584,
            10459611,
            10459522,
            10463289,
            10460886,
            10459674,
            10459690,
            10460416,
            10461920,
            10462421,
            10467148,
            10463544,
            10464761,
            10465220,
            10462234,
            10464721,
            10464494
        ]
    },
    "name": "C. Ilya and Sticks",
    "statement": "In the evening, after the contest Ilya was bored, and he really felt\r\nlike maximizing. He remembered that he had a set of sticks and an\r\ninstrument. Each stick is characterized by its length .Ilya decided to\r\nmake a rectangle from the sticks. And due to his whim, he decided to\r\nmake rectangles in such a way that maximizes their total area. Each\r\nstick is used in making at most one rectangle, it is possible that some\r\nof sticks remain unused. Bending sticks is not allowed.Sticks with\r\nlengths , , and can make a rectangle if the following properties are\r\nobserved: A rectangle can be made of sticks with lengths of, for\r\nexample, or . A rectangle cannot be made of, for example, sticks .Ilya\r\nalso has an instrument which can reduce the length of the sticks. The\r\nsticks are made of a special material, so the length of each stick can\r\nbe reduced by at most one. For example, a stick with length can either\r\nstay at this length or be transformed into a stick of length .You have\r\nto answer the question what maximum total area of the rectangles can\r\nIlya get with a file if makes rectangles from the available sticks?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << \" = \" << ccc << endl;\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tn;\nlli\tarr[200000];\nvector<lli>\tv;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tscanf(\"%d\",&n);\n\tFP( i,1,n )\n\t\tscanf(\"%lld\",arr+i);\n\tsort( arr+1,arr+n+1 );\n\treverse( arr+1,arr+n+1 );\n\tFP( i,1,n-1 ){\n\t\tif( arr[i]==arr[i+1] or arr[i]-1==arr[i+1] ){\n\t\t\tv.pb( min( arr[i],arr[i+1] ) );\n\t\t\ti++;\n\t\t}\n\t}\n\tsort( all(v) );\n\tlli\tres=0;\n\twhile( v.size()>=2 ){\n\t\tres += v.back()*v[v.size()-2];\n\t\tv.pop_back();\n\t\tv.pop_back();\n\t}\n\tcout << res << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Ilya and Sticks.json",
    "editorial_link": "https://codeforces.com//blog/entry/17119",
    "editorial": "This problem can be solved with help of greedy. At first count array cnt[]. In cnt[i] will store how many sticks with length i we have.\n\nNow iterate for len from maximal length of sticks to minimal. If cnt[len] is odd and we have sticks with length len?-?1 (that is cnt[len?-?1]?>?0), make cnt[len]-- and cnt[len?-?1]++. If cnt[len] is odd and we have no sticks with length len?-?1 (that is cnt[len?-?1]?=?0), make cnt[len]--.\n\nIn this way we properly done all sawing which we need and guaranteed that all cnt[len] is even. After that iterate similary on length of sticks and greedily merge pairs from 2 sticks with the same length in fours. It will be length of sides of sought-for rectangles, left only summarize their squares in answer. In the end can left 2 sticks without pair, we must not consider them in answer.\n\nFor example, if cnt[5]?=?6, cnt[4]?=?4, cnt[2]?=?4, we need to merge this sticks in following way \u0097 (5,?5,?5,?5), (5,?5,?4,?4), (4,?4,?2,?2). Two sticks with length 2 are left, we must not count them.\n\nAsymptotic behavior of this solution \u0097 O(n?+?maxlen?-?minlen), where n \u0097 count of sticks, maxlen \u0097 maximal length of stick, minlen \u0097 minimal length of stick."
}