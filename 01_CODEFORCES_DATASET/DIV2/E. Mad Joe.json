{
    "link": "https://codeforces.com//contest/250/problem/E",
    "problemId": "2295",
    "problem_idx": "E",
    "shortId": "250E",
    "contest_number": "250",
    "problem_submissions": {
        "D": [
            2661219,
            2661302,
            2661169,
            2662484,
            2661663,
            2661650,
            2663624,
            2661614,
            2662775,
            2662098,
            2661832,
            2662182,
            2662202,
            2662743,
            2662343,
            2662306
        ],
        "E": [
            2660453,
            2662495,
            2662431,
            2662896,
            2662159,
            2663414,
            2662356,
            2666687,
            2663326,
            3224559
        ],
        "C": [
            2659482,
            2660436,
            2660472,
            2658939,
            2660327,
            2660252,
            2659990,
            2660985,
            2659709,
            2660447,
            2660653,
            2678663,
            2660908,
            2661315,
            2660197,
            2661069,
            2661058
        ],
        "B": [
            2659124,
            2659956,
            2659963,
            2660324,
            2659809,
            2659468,
            2659350,
            2660518,
            2660539,
            2659612,
            2660025,
            2660108,
            2659586,
            2659566,
            2660019,
            2659920
        ],
        "A": [
            2658537,
            2658807,
            2658632,
            2658949,
            2658816,
            2658618,
            2658590,
            2658601,
            2658691,
            2658849,
            2658966,
            2659142,
            2658749,
            2658817,
            2659154,
            2658983
        ]
    },
    "name": "E. Mad Joe",
    "statement": "Joe has been hurt on the Internet. Now he is storming around the house,\r\ndestroying everything in his path.Joe’s house has floors, each floor is\r\na segment of cells. Each cell either contains nothing (it is an empty\r\ncell), or has a brick or a concrete wall (always something one of\r\nthree). It is believed that each floor is surrounded by a concrete wall\r\non the left and on the right.Now Joe is on the -th floor and in the\r\nfirst cell, counting from left to right. At each moment of time, Joe has\r\nthe direction of his gaze, to the right or to the left (always one\r\ndirection of the two). Initially, Joe looks to the right.Joe moves by a\r\nparticular algorithm. Every second he makes one of the following\r\nactions: If the cell directly under Joe is empty, then Joe falls down.\r\nThat is, he moves to this cell, the gaze direction is preserved.\r\nOtherwise consider the next cell in the current direction of the gaze.\r\nIf the cell is empty, then Joe moves into it, the gaze direction is\r\npreserved. If this cell has bricks, then Joe breaks them with his\r\nforehead (the cell becomes empty), and changes the direction of his gaze\r\nto the opposite. If this cell has a concrete wall, then Joe just changes\r\nthe direction of his gaze to the opposite (concrete can withstand any\r\nnumber of forehead hits). Joe calms down as soon as he reaches cell of\r\nthe first floor.The figure below shows an example Joe’s movements around\r\nthe house. Determine how many seconds Joe will need to calm down.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define FOR(it,a) for (__typeof((a).begin()) it=(a).begin();it!=(a).end();++it)\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\ninline int sign(double x)\n{\n    if (x<-eps) return -1;\n    return x>eps;\n}\n\nstruct Tpoint\n{\n    double x,y;\n    Tpoint(){}\n    Tpoint(double x,double y):x(x),y(y){}\n    inline double norm(){return sqrt(x*x+y*y);}\n    inline void rotate(double ang)\n    {\n        double co=cos(ang),si=sin(ang);\n        double tx=x,ty=y;\n        x=tx*co-ty*si;\n        y=tx*si+ty*co;\n    }\n};\n\ninline Tpoint operator +(const Tpoint &a,const Tpoint &b){return Tpoint(a.x+b.x,a.y+b.y);}\ninline Tpoint operator -(const Tpoint &a,const Tpoint &b){return Tpoint(a.x-b.x,a.y-b.y);}\ninline Tpoint operator *(const Tpoint &a,const double &b){return Tpoint(a.x*b,a.y*b);}\ninline Tpoint operator /(const Tpoint &a,const double &b){return Tpoint(a.x/b,a.y/b);}\ninline double det(const Tpoint &a,const Tpoint &b){return a.x*b.y-a.y*b.x;}\ninline double dot(const Tpoint &a,const Tpoint &b){return a.x*b.x+a.y*b.y;}\n//================================\n\nconst int maxn  =   105;\nconst int maxm  =   10005;\n\nchar s[maxn][maxm];\n\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for (int i=0;i<n;++i){\n        scanf(\"%s\",s[i]);\n    }\n    \n    int x=0,y=0,l=0,r=0,face=0;\n    LL ans=0;\n    bool change=true;\n    int cnt=0;\n    while (x<n-1 && cnt<3){\n        change=false;\n        if (s[x+1][y]=='.'){\n            ++ans;\n            ++x;\n            l=r=y;\n            change=true;\n            continue;\n        }\n        \n        if (face==0){\n            ans+=r-y;\n            y=r;\n            while (s[x+1][y]!='.'){\n                if (s[x][y+1]=='.'){\n                    ++y;\n                    ++ans;\n                    r=y;\n                    change=true;\n                }else if (s[x][y+1]=='+'){\n                    s[x][y+1]='.';\n                    ++ans;\n                    face=1;\n                    change=true;\n                    break;\n                }else{\n                    ++ans;\n                    face=1;\n                    break;\n                }\n            }\n        }else{\n            ans+=y-l;\n            y=l;\n            while (s[x+1][y]!='.'){\n                if (y && s[x][y-1]=='.'){\n                    --y;\n                    ++ans;\n                    l=y;\n                    change=true;\n                }else if (y && s[x][y-1]=='+'){\n                    s[x][y-1]='.';\n                    ++ans;\n                    face=0;\n                    change=true;\n                    break;\n                }else{\n                    ++ans;\n                    face=0;\n                    break;\n                }\n            }\n        }\n        if (!change){\n            ++cnt;\n        }else{\n            cnt=0;\n        }\n    }\n    if (x<n-1){\n        puts(\"Never\");\n    }else{\n        printf(\"%I64d\\n\",ans);\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Mad Joe.json",
    "editorial_link": "https://codeforces.com//blog/entry/5973",
    "editorial": "Stupid emulation is very slow. It has complexity and answer can be about\r\n. You should speed up stupid emulation using following way. For every\r\nfloor you should store segment of visited cells (two integers L and R\r\nbounds). We know that under every cell of this segment all cells are\r\nnon-empty. Therefore after every changing of move direction you can go\r\nthrough all the segment in . After every one or two \"teleportations\"\r\nthrough segment you either expand bounds of the segnent or change some\r\nbrick-cell into empty-cell or fall down. But actions of every type you\r\ncan do no more than times, so this optimization improves complexety to .\r\nAuthor is Ripatti.\r\n",
    "hint": []
}