{"link": "https://codeforces.com//contest/791/problem/E", "problemId": "98948", "problem_idx": "E", "shortId": "791E", "contest_number": "791", "problem_submissions": {"E": [25623822, 25707525, 25637756, 25686811], "D": [25619687, 25615888, 25616164, 25617170, 25877940, 25623254, 25619752, 25619476, 25621260, 25621091, 25621698, 25621432, 25634938, 25621485, 25620131, 25687920, 25622200, 25621928, 25620558, 25624599, 25620325, 25621555], "C": [25614829, 25610721, 25612354, 25611470, 25609920, 25609700, 25612129, 25612423, 25609930, 25611851, 25612109, 25634522, 25612617, 25613540, 25612121, 25613013, 25613533, 25611359, 25612919, 25614171], "B": [25607382, 25608951, 25608908, 25606986, 25611482, 25608509, 25609856, 25607620, 25608196, 25608851, 25634368, 25608159, 25610124, 25608652, 25608764, 25608051, 25608470, 25615071, 25609116], "A": [25604642, 25605072, 25605943, 25604441, 25605687, 25604865, 25604575, 25604516, 25605765, 25605230, 25634308, 25604731, 25605413, 25604932, 25605388, 25604873, 25604460, 25606109, 25605955]}, "name": "E. Bear and Company", "statement": "Bear Limak prepares problems for a programming competition. Of course,\r\nit would be unprofessional to mention the sponsor name in the statement.\r\nLimak takes it seriously and he is going to change some words. To make\r\nit still possible to read, he will try to modify each word as little as\r\npossible.Limak has a string that consists of uppercase English letters.\r\nIn one move he can swap two letters of the string. For example, he can\r\ntransform a string \"\" into \"\" or \"\" in one move.Limak wants to obtain a\r\nstring without a substring \"\" (i.e. there should be no letter \u201d\r\nimmediately followed by letter \u201d). It can be easily proved that it\u2019s\r\npossible for any initial string .What is the minimum possible number of\r\nmoves Limak can do?\r\n", "solutions": ["#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> V, K, O;\n\n\nint dp[76][76][76][3];\n\nint dfs(int v, int k, int o, int kind, vector<int>& p) {\n\tif (v==0 && k==0 && o==0 && kind==2) {\n\t\treturn 0;\n\t}\n\tif (dp[v][k][o][kind]) {\n\t\treturn dp[v][k][o][kind] - 1;\n\t}\n\tint pos;\n\tif (kind == 2) {\n\t\tif (o <= 0) {\n\t\t\treturn 10000;\n\t\t}\n\t\t--o;\n\t\tpos = O[o];\n\t\tp[pos] = 1;\n\t\tint ans = 10000;\n\t\tint extra = 1;\n\t\tfor (int i = 0; i < pos; ++i) {\n\t\t\textra += p[i];\n\t\t}\n\t\tans = min(ans, dfs(v, k, o, 0, p));\n\t\tans = min(ans, dfs(v, k, o, 1, p));\n\t\tans = min(ans, dfs(v, k, o, 2, p));\n\t\tp[pos] = 0;\n\t\tdp[v][k][o+1][kind] = ans + extra;\n\t\treturn dp[v][k][o+1][kind] - 1;\n\t}\n\tif (kind == 1) {\n\t\tif (k <= 0) {\n\t\t\treturn 10000;\n\t\t}\n\t\t--k;\n\t\tpos = K[k];\n\t\tp[pos] = 1;\n\t\tint ans = 10000;\n\t\tint extra = 1;\n\t\tfor (int i = 0; i < pos; ++i) {\n\t\t\textra += p[i];\n\t\t}\n\t\tans = min(ans, dfs(v, k, o, 1, p));\n\t\tans = min(ans, dfs(v, k, o, 2, p));\n\t\tp[pos] = 0;\n\t\tdp[v][k+1][o][kind] = ans + extra;\n\t\treturn dp[v][k+1][o][kind] - 1;\n\t}\n\tif (kind == 0) {\n\t\tif (v <= 0) {\n\t\t\treturn 10000;\n\t\t}\n\t\t--v;\n\t\tpos = V[v];\n\t\tp[pos] = 1;\n\t\tint ans = 10000;\n\t\tint extra = 1;\n\t\tfor (int i = 0; i < pos; ++i) {\n\t\t\textra += p[i];\n\t\t}\n\t\tans = min(ans, dfs(v, k, o, 0, p));\n\t\tans = min(ans, dfs(v, k, o, 1, p));\n\t\tans = min(ans, dfs(v, k, o, 2, p));\n\t\tp[pos] = 0;\n\t\tdp[v+1][k][o][kind] = ans + extra;\n\t\treturn dp[v+1][k][o][kind] - 1;\t\t\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == 'V') {\n\t\t\tV.push_back(i);\n\t\t} else if (s[i] == 'K') {\n\t\t\tK.push_back(i);\n\t\t} else {\n\t\t\tO.push_back(i);\n\t\t}\n\t}\n\tvector<int> p(n);\n\tint ans = dfs(V.size(), K.size(), O.size(), 0, p);\n\tans = min(ans, dfs(V.size(), K.size(), O.size(), 1, p));\n\tans = min(ans, dfs(V.size(), K.size(), O.size(), 2, p));\n    cout << ans << endl;\n}"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2500", "interactive": false}