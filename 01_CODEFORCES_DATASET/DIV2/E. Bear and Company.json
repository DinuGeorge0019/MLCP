{
    "link": "https://codeforces.com//contest/791/problem/E",
    "problemId": "98948",
    "problem_idx": "E",
    "shortId": "791E",
    "contest_number": "791",
    "problem_submissions": {
        "E": [
            25623822,
            25707525,
            25637756,
            25686811
        ],
        "D": [
            25619687,
            25615888,
            25616164,
            25617170,
            25877940,
            25623254,
            25619752,
            25619476,
            25621260,
            25621091,
            25621698,
            25621432,
            25634938,
            25621485,
            25620131,
            25687920,
            25622200,
            25621928,
            25620558,
            25624599,
            25620325,
            25621555
        ],
        "C": [
            25614829,
            25610721,
            25612354,
            25611470,
            25609920,
            25609700,
            25612129,
            25612423,
            25609930,
            25611851,
            25612109,
            25634522,
            25612617,
            25613540,
            25612121,
            25613013,
            25613533,
            25611359,
            25612919,
            25614171
        ],
        "B": [
            25607382,
            25608951,
            25608908,
            25606986,
            25611482,
            25608509,
            25609856,
            25607620,
            25608196,
            25608851,
            25634368,
            25608159,
            25610124,
            25608652,
            25608764,
            25608051,
            25608470,
            25615071,
            25609116
        ],
        "A": [
            25604642,
            25605072,
            25605943,
            25604441,
            25605687,
            25604865,
            25604575,
            25604516,
            25605765,
            25605230,
            25634308,
            25604731,
            25605413,
            25604932,
            25605388,
            25604873,
            25604460,
            25606109,
            25605955
        ]
    },
    "name": "E. Bear and Company",
    "statement": "Bear Limak prepares problems for a programming competition. Of course,\r\nit would be unprofessional to mention the sponsor name in the statement.\r\nLimak takes it seriously and he is going to change some words. To make\r\nit still possible to read, he will try to modify each word as little as\r\npossible.Limak has a string that consists of uppercase English letters.\r\nIn one move he can swap two letters of the string. For example, he can\r\ntransform a string \"\" into \"\" or \"\" in one move.Limak wants to obtain a\r\nstring without a substring \"\" (i.e. there should be no letter ”\r\nimmediately followed by letter ”). It can be easily proved that it’s\r\npossible for any initial string .What is the minimum possible number of\r\nmoves Limak can do?\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> V, K, O;\n\n\nint dp[76][76][76][3];\n\nint dfs(int v, int k, int o, int kind, vector<int>& p) {\n\tif (v==0 && k==0 && o==0 && kind==2) {\n\t\treturn 0;\n\t}\n\tif (dp[v][k][o][kind]) {\n\t\treturn dp[v][k][o][kind] - 1;\n\t}\n\tint pos;\n\tif (kind == 2) {\n\t\tif (o <= 0) {\n\t\t\treturn 10000;\n\t\t}\n\t\t--o;\n\t\tpos = O[o];\n\t\tp[pos] = 1;\n\t\tint ans = 10000;\n\t\tint extra = 1;\n\t\tfor (int i = 0; i < pos; ++i) {\n\t\t\textra += p[i];\n\t\t}\n\t\tans = min(ans, dfs(v, k, o, 0, p));\n\t\tans = min(ans, dfs(v, k, o, 1, p));\n\t\tans = min(ans, dfs(v, k, o, 2, p));\n\t\tp[pos] = 0;\n\t\tdp[v][k][o+1][kind] = ans + extra;\n\t\treturn dp[v][k][o+1][kind] - 1;\n\t}\n\tif (kind == 1) {\n\t\tif (k <= 0) {\n\t\t\treturn 10000;\n\t\t}\n\t\t--k;\n\t\tpos = K[k];\n\t\tp[pos] = 1;\n\t\tint ans = 10000;\n\t\tint extra = 1;\n\t\tfor (int i = 0; i < pos; ++i) {\n\t\t\textra += p[i];\n\t\t}\n\t\tans = min(ans, dfs(v, k, o, 1, p));\n\t\tans = min(ans, dfs(v, k, o, 2, p));\n\t\tp[pos] = 0;\n\t\tdp[v][k+1][o][kind] = ans + extra;\n\t\treturn dp[v][k+1][o][kind] - 1;\n\t}\n\tif (kind == 0) {\n\t\tif (v <= 0) {\n\t\t\treturn 10000;\n\t\t}\n\t\t--v;\n\t\tpos = V[v];\n\t\tp[pos] = 1;\n\t\tint ans = 10000;\n\t\tint extra = 1;\n\t\tfor (int i = 0; i < pos; ++i) {\n\t\t\textra += p[i];\n\t\t}\n\t\tans = min(ans, dfs(v, k, o, 0, p));\n\t\tans = min(ans, dfs(v, k, o, 1, p));\n\t\tans = min(ans, dfs(v, k, o, 2, p));\n\t\tp[pos] = 0;\n\t\tdp[v+1][k][o][kind] = ans + extra;\n\t\treturn dp[v+1][k][o][kind] - 1;\t\t\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == 'V') {\n\t\t\tV.push_back(i);\n\t\t} else if (s[i] == 'K') {\n\t\t\tK.push_back(i);\n\t\t} else {\n\t\t\tO.push_back(i);\n\t\t}\n\t}\n\tvector<int> p(n);\n\tint ans = dfs(V.size(), K.size(), O.size(), 0, p);\n\tans = min(ans, dfs(V.size(), K.size(), O.size(), 1, p));\n\tans = min(ans, dfs(V.size(), K.size(), O.size(), 2, p));\n    cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Bear and Company.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "Letters different than 'V' and 'K' are indistinguishable, so we can treat all of them as the same letter 'X'.\n\nWe will try to build the final string from left to right Let dp[v][k][x] denote the number of moves needed to move first v letters 'V', first k letters 'K' and first x letters 'X' to the beginning of the string (those letters should become first v?+?k?+?x letters of the string). We should also remember the last used letter (to ensure that there is no 'K' just after 'V') so let's extend the state to dp[v][k][x][lastLetter] (or it can be dp[v][k][x][is_the_last_letter_V]).\n\nTo move from a state, we should consider taking the next 'K' (i.e. the k?+?1-th letter 'K' in the initial string), the next 'V' or the next 'X'. Of course, we can't take 'K' if the last used letter was 'V'.\n\nThe last step is to see how we should add to the score when we add a new letter. It turns out that it isn't enough to just add the difference between indices (where the letter was and where it will be) and the third sample test (\"VVKEVKK\") showed that. Instead, we should notice that we know which letters are already moved to the beginning (first k letters 'K' and so on) so we know how exactly the string looks like currently.\n\nFor example, let's consider the string \"VVKXXVKVV\" and moving from the state v?=?4,?k?=?1,?x?=?1 by taking a new letter 'K'. We know that first 4 letters 'V', 1 letter 'K' and 1 letter 'X' are already moved to the beginning. To move the next letter 'K' (underlined in blue on the drawing below) to the left, we must swap it with all not-used letters that were initially on the left from this 'K'. Counting them in linear time gives the total complexity O(n4) but you can also think a bit and get O(n3) - it's quite easy but it wasn't required to get AC. On the drawing below, used letters are crossed out. There is only 1 not-crossed-out letter on the left from 'K' so we should increase the score by 1 (because we need 1 swap to move this 'K' to the x?+?k?+?v?+?1-th position).\n",
    "hint": []
}