{
    "link": "https://codeforces.com//contest/1786/problem/E",
    "problemId": "1767295",
    "problem_idx": "E",
    "shortId": "1786E",
    "contest_number": "1786",
    "problem_submissions": {
        "E": [
            192342570,
            192306394,
            192404273,
            192327524,
            192339032,
            192311189,
            192325805,
            192320065,
            192441626,
            192343977,
            192328171,
            192315469,
            192316636,
            192338226,
            192342670,
            192339784,
            192342778
        ],
        "D": [
            192320379,
            192313768,
            192307277,
            192318549,
            192309409,
            192292999,
            192316314,
            192320950,
            192332305,
            192309612,
            192327595,
            192325214,
            192325223,
            192311769,
            192310059,
            192313834,
            192316588,
            192327743
        ],
        "F": [
            192310858,
            192336618,
            192349130,
            192348404,
            192333052,
            192339600,
            192329659,
            192334176,
            192328243,
            192307751,
            192340487,
            192363526,
            192345318
        ],
        "C": [
            192293366,
            192290648,
            192294881,
            192293245,
            192293510,
            192290179,
            192292716,
            192294689,
            192305954,
            192310133,
            192289535,
            192298071,
            192296223,
            192302623,
            192296901,
            192292106,
            192294116,
            192300798,
            192295593,
            192301556
        ],
        "B": [
            192288687,
            192344141,
            192291360,
            192289646,
            192340206,
            192287135,
            192290672,
            192302280,
            192292700,
            192296847,
            192294213,
            192293367,
            192300808,
            192292539,
            192288767,
            192289750,
            192293496,
            192292722,
            192296815
        ],
        "A2": [
            192287082,
            192284625,
            192286145,
            192285724,
            192290142,
            192283788,
            192286284,
            192297549,
            192284597,
            192306985,
            192286345,
            192288530,
            192296607,
            192287030,
            192284519,
            192284365,
            192288011,
            192288312,
            192289376
        ],
        "A1": [
            192287049,
            192283178,
            192286410,
            192283361,
            192283338,
            192284177,
            192283764,
            192296237,
            192283279,
            192307201,
            192286846,
            192283729,
            192297100,
            192283762,
            192283137,
            192282950,
            192288217,
            192285269,
            192287405
        ]
    },
    "name": "E. Monsters  hard version ",
    "statement": "In a computer game, you are fighting against n monsters. Monster number\r\ni has a_i health points, all a_i are integers. A monster is alive while\r\nit has at least 1 health point.You can cast spells of two types: Deal 1\r\ndamage to any single alive monster of your choice. Deal 1 damage to all\r\nalive monsters. If at least one monster dies (ends up with 0 health\r\npoints) as a result of this action, then repeat it (and keep repeating\r\nwhile at least one monster dies every time). Dealing 1 damage to a\r\nmonster reduces its health by 1.Spells of type 1 can be cast any number\r\nof times, while a spell of type 2 can be cast at most once during the\r\ngame.For every k = 1, 2,\r\nldots, n, answer the following question. Suppose that only the first k\r\nmonsters, with numbers 1, 2,\r\nldots, k, are present in the game. What is the smallest number of times\r\nyou need to cast spells of type 1 to kill all k monsters?\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\n#define ls (id << 1)\n#define rs (id << 1 | 1)\n#define mid (l + r >> 1)\n\ndef(N, int, 2e5 + 5)\n\nint n, m;\nint a[N], b[N], to[N];\nint c[N << 2], mn[N << 2], lz[N << 2];\nll sum[N << 2];\n\nvoid pu(int id) {\n\tc[id] = c[ls] + c[rs];\n\tmn[id] = min(mn[ls], mn[rs]);\n\tsum[id] = sum[ls] + sum[rs];\n}\n\nvoid pd(int id) {\n\tif(lz[id]) {\n\t\tlz[ls] += lz[id], lz[rs] += lz[id];\n\t\t\n\t\tif(c[ls]) mn[ls] -= lz[id];\n\t\tif(c[rs]) mn[rs] -= lz[id];\n\t\t\n\t\tsum[ls] += 1ll * lz[id] * c[ls], sum[rs] += 1ll * lz[id] * c[rs];\n\t\t\n\t\tlz[id] = 0;\n\t}\n}\n\nvoid build(int id, int l, int r) {\n\tmn[id] = 0x3f3f3f3f;\n\tc[id] = sum[id] = lz[id] = 0;\n\tif(l == r) return ;\n\tbuild(ls, l, mid), build(rs, mid + 1, r);\n}\n\nvoid upd(int id, int l, int r, int x, int v) {\n\tif(l == r) {\n\t\tsum[id] = v;\n\t\tmn[id] = a[b[l]] - v;\n\t\tc[id] = 1;\n\t\treturn ;\n\t}\n\tpd(id);\n\tif(mid >= x) upd(ls, l, mid, x, v);\n\telse upd(rs, mid + 1, r, x, v);\n\tpu(id);\n}\n\nvoid mdf(int id, int l, int r, int x, int y) {\n\tif(x <= l && r <= y) {\n\t\tif(c[id]) {\n\t\t\tsum[id] += c[id];\n\t\t\t--mn[id], ++lz[id];\n\t\t}\n\t\treturn ;\n\t}\n\tpd(id);\n\tif(mid >= x) mdf(ls, l, mid, x, y);\n\tif(mid < y) mdf(rs, mid + 1, r, x, y);\n\tpu(id);\n}\n\nll qry(int id, int l, int r, int x) {\n\tif(l == r) return sum[id];\n\tpd(id);\n\tif(mid >= x) return qry(ls, l, mid, x);\n\telse return qry(rs, mid + 1, r, x); \n}\n\nint qmin(int id, int l, int r, int x, int y) {\n\tif(x <= l && r <= y) return mn[id];\n\tpd(id);\n\tint res = 0x3f3f3f3f;\n\tif(mid >= x) To_min(res, qmin(ls, l, mid, x, y));\n\tif(mid < y) To_min(res, qmin(rs, mid + 1, r, x, y));\n\treturn res;\n}\n\nint get(int l) {\n\tint nl = l;\n\tint r = n, res = l;\n\twhile(l <= r) {\n\t\tif(qmin(1, 1, n, nl, mid)) res = mid, l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tqread(n);\n\trep(i, 1, n) qread(a[i]), b[i] = i;\n\tsort(b + 1, b + n + 1, [&](int i, int j) { return a[i] < a[j]; });\n\trep(i, 1, n) to[b[i]] = i;\n\tbuild(1, 1, n); ll nw = a[1];\n\tset<int> s; s.emplace(-to[1]), s.emplace(0);\n\tcout << a[1] - 1 << ' ';\n\tupd(1, 1, n, to[1], 1);\n\trep(i, 2, n) {\n\t\tint t = *s.lower_bound(-to[i]), x, f = 0;\n\t\tif(!t) x = 1;\n\t\telse {\n\t\t\tint nn = qry(1, 1, n, -t);\n\t\t\tif(nn + 1 <= a[i]) x = nn + 1;\n\t\t\telse x = nn, f = 1;\n\t\t}\n\t\tupd(1, 1, n, to[i], x);\n\t\tif(to[i] != n && !f) {\n\t\t\tif(qmin(1, 1, n, to[i] + 1, n)) mdf(1, 1, n, to[i] + 1, n);\n\t\t\telse if(qmin(1, 1, n, to[i] + 1, to[i] + 1)) mdf(1, 1, n, to[i] + 1, get(to[i] + 1));\n\t\t}\n\t\ts.emplace(-to[i]);\n\t\tnw += a[i];\n\t\tcout << nw - sum[1] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Monsters  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "Continuing on the solution to the easy version: now we have a set of integers A\n, we need to add elements into A\n one by one and maintain the answer to the problem.\n\nRecall that for every i\n, either bi=bi?1\n or bi=bi?1+1\n. Note that bi=bi?1\n can only happen when bi=ai\n. Let's call such an element useless. If we remove a useless element, the answer does not change.\n\nIf there are no useless elements, we have b1=1\n and bi=bi?1+1\n for i>1\n: that is, bi=i\n. Thus, the answer to the problem can be easily calculated as ?i=1m(ai?bi)=?i=1mai?m(m+1)2\n, where m\n is the current size of the set.\n\nWe can formulate the condition \"there are no useless elements\" as follows. For any x\n, let kx\n be the number of elements in A\n not exceeding x\n. Then, kx?x\n.\n\nOn the other hand, suppose that for some x\n, we have kx>x\n. Let's find the smallest such x\n. Then, we can see that A\n contains a useless element equal to x\n, and we can safely remove it.\n\nWe can check this condition after adding each new element to A\n using a segment tree. In every cell x\n of the array maintained by the segment tree, we will store the difference x?kx\n. Initially, cell x\n contains value x\n. When a new element v\n appears, we should subtract 1\n from all cells in range [v;n]\n. Then, if a cell with a negative value appears (that is, x?kx<0\n, which is equivalent to kx>x\n), we should find the leftmost such cell x\n and remove an element equal to x\n. In particular, we should add 1\n to all cells in range [x;n]\n.\n\nThus, we can use a segment tree with \"range add\" and \"global min\". At most one useless element can appear every time we enlarge A\n, and if that happens, we can identify and remove it in O(logn)\n, resulting in an O(nlogn)\n time complexity.",
    "hint": []
}