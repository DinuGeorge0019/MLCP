{
    "link": "https://codeforces.com//contest/141/problem/D",
    "problemId": "748",
    "problem_idx": "D",
    "shortId": "141D",
    "contest_number": "141",
    "problem_submissions": {
        "D": [
            1025243,
            1022766,
            1022505,
            1022637,
            1022105,
            1022584,
            1047488,
            1023184,
            1044430
        ],
        "E": [
            1021955,
            1021949,
            1679914,
            1679889,
            1679868,
            1025484
        ],
        "C": [
            1020295,
            1020537,
            1020738,
            1019845,
            1021214,
            1023402,
            1019630,
            1020831,
            1019576,
            1019514,
            1020109,
            1019778,
            1019345,
            1020372,
            1020912,
            1020409,
            1020232,
            1020654,
            1020722
        ],
        "B": [
            1019192,
            1022517,
            1019188,
            1018654,
            1019147,
            1018859,
            1024115,
            1019030,
            1018785,
            1020350,
            1018726,
            1019903,
            1019068,
            1018867,
            1019239,
            1019023,
            1019215,
            1019103
        ],
        "A": [
            1018140,
            1022790,
            1017901,
            1019131,
            1018196,
            1017610,
            17012370,
            1017739,
            1018174,
            1017967,
            1018258,
            1017762,
            1017651,
            1018509,
            1018016,
            1017685,
            1018122,
            1017780,
            1017862,
            1018064
        ]
    },
    "name": "D. Take-off Ramps",
    "statement": "Vasya participates in a ski race along the axis. The start is at point ,\r\nand the finish is at , that is, at a distance meters from the start in\r\nthe positive direction of the axis. Vasya has been training so hard that\r\nhe can run one meter in exactly one second.Besides, there are take-off\r\nramps on the track, each ramp is characterized by four numbers:\r\nrepresents the rampâ€™s coordinate represents from how many meters Vasya\r\nwill land if he goes down this ramp represents the flight time in\r\nseconds is the number, indicating for how many meters Vasya should\r\ngather speed to get ready and fly off the ramp. As Vasya gathers speed,\r\nhe should ski on the snow (that is, he should not be flying), but his\r\nspeed still equals one meter per second. Vasya is allowed to move in on\r\nthe axis, but he is prohibited to cross the start line, that is go to\r\nthe negative semiaxis. Vasya himself chooses which take-off ramps he\r\nwill use and in what order, that is, he is not obliged to take off from\r\nall the ramps he encounters. Specifically, Vasya can skip the ramp. It\r\nis guaranteed that , that is, Vasya cannot cross the finish line in\r\nflight.Your task is to find the minimum time that Vasya will spend to\r\ncover the distance.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\ntypedef pair< int, int > PRII;\ntypedef pair< double, double > PRDD;\n\n#define p_b push_back\n#define m_p make_pair\n#define x first\n#define y second\n\n#define Size(a) ((int)a.size())\n#define sqr(x) ((x)*(x))\n\n#define oo 1000000001\n#define eps 1e-9\nconst double pi = acos(-1.0);\n\n#define maxn 200000 + 10\n#define maxm 500000 + 10\n\nint n,m = 0;\nmap< int, int > s;\nmap< int, int >::iterator itr1,itr2;\n\nint totm = 0,e[maxm],last[maxm],f[maxm],g[maxm],now[maxn];\nint dist[maxn],pre[maxn],ramp[maxn],ans[maxn];\npriority_queue< PRII > que;\n\ninline void build( int u, int v, int d, int k )\n{\n    ++totm;\n    e[totm] = v;\n    last[totm] = now[u];\n    f[totm] = d;\n    g[totm] = k;\n    now[u] = totm;\n}\n\nint main()\n{\n    int i,L,x,d,t,p;\n    \n    scanf(\"%d%d\",&n,&L);\n    s[0] = ++m;\n    s[L] = ++m;\n    for( i = 1 ; i <= n ; ++i )\n        {\n            scanf(\"%d%d%d%d\",&x,&d,&t,&p);\n            if( x-p < 0 )\n                continue;\n            if( s.find(x-p) == s.end() )\n                s[x-p] = ++m;\n            if( s.find(x+d) == s.end() )\n                s[x+d] = ++m;\n            build(s[x-p],s[x+d],p+t,i);\n        }\n    for( itr1 = s.begin() ; ; ++itr1 )\n        {\n            itr2 = itr1, ++itr2;\n            if( itr2 == s.end() )\n                break;\n            build(itr1->y,itr2->y,itr2->x-itr1->x,0);\n            build(itr2->y,itr1->y,itr2->x-itr1->x,0);\n        }\n    \n    for( i = 1 ; i <= m ; ++i )\n        dist[i] = oo;\n    dist[1] = 0;\n    que.push(m_p(0,1));\n    while( Size(que) )\n        {\n            PRII tmp = que.top();\n            que.pop();\n            for( i = now[tmp.y] ; i ; i = last[i] )\n                if( dist[e[i]] > -tmp.x+f[i] )\n                    {\n                        dist[e[i]] = -tmp.x+f[i];\n                        que.push(m_p(-dist[e[i]],e[i]));\n                        pre[e[i]] = tmp.y;\n                        ramp[e[i]] = g[i];\n                    }\n        }\n        \n    printf(\"%d\\n\",dist[2]);\n    for( i = 2 ; i != 1 ; i = pre[i] )\n        if( ramp[i] )\n            ans[++ans[0]] = ramp[i];\n    printf(\"%d\\n\",ans[0]);\n    for( i = ans[0] ; i >= 1 ; --i )\n        printf(\"%d%c\",ans[i],i>1?' ':'\\n');    \n        \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Take-off Ramps.json",
    "editorial_link": "https://codeforces.com//blog/entry/3571",
    "editorial": "Let's generate the weighted directed graph of all ramps. The graphs' vertexes are the important points on the line Ox, there are points: 0,?L,?xi?-?pi,?xi?+?di. The graphs' edges are the possible ramp jumps: transfer from point xi?-?pi to point xi?+?di or transfer from vertex in neighboring vertexes (neighboring means that we get the next and previous important points on the line). The weights of these edges are correspondingly pi?+?ti and xv?+?1?-?xv, xv?-?xv?-?1. We must note that in the transfers we can't get in the negative part of Ox, and we must delete this transfers.\n\nThen we must find and output the shortest path in this graph from vertex 0 to L. This can be done, for example, with Dijkstra's algorithm for the sparse graphs. ",
    "hint": []
}