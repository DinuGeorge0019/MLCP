{
    "link": "https://codeforces.com//contest/2021/problem/C1",
    "problemId": "2929693",
    "problem_idx": "C1",
    "shortId": "2021C1",
    "contest_number": "2021",
    "problem_submissions": {
        "D": [
            284590256,
            284590001,
            284586301,
            284623851,
            284569171,
            284578878,
            284712748,
            284578625,
            284581515,
            284581353,
            284637993
        ],
        "E3": [
            284578176,
            284565599,
            284600842,
            284850992,
            284584216,
            284618196,
            284597636,
            284599022,
            284585148,
            286020331,
            284745105
        ],
        "E1": [
            284577293,
            284599054,
            284566976,
            284599574,
            284568532,
            284584477,
            284579805,
            284586608,
            284600476,
            284585423,
            284594051,
            284576473,
            284592731,
            284581221,
            284582830,
            284576965,
            286020463,
            284573682,
            284745154,
            284585073
        ],
        "E2": [
            284576481,
            284599368,
            284566551,
            284571784,
            284584447,
            284580377,
            284586193,
            284585357,
            284576258,
            284585492,
            284583546,
            284582548,
            286020438,
            284593395,
            284766277,
            284587863
        ],
        "C2": [
            284552959,
            284550125,
            284578847,
            284570668,
            284557743,
            284572571,
            284559765,
            284559531,
            284592443,
            284564745,
            284553608,
            284551809,
            284555032,
            284564040,
            284565535,
            284591262,
            284564727,
            284560092
        ],
        "C1": [
            284543395,
            284545189,
            284579118,
            284555011,
            284551439,
            284544381,
            284549845,
            284558858,
            284582609,
            284556392,
            284545368,
            284554154,
            284545358,
            284546156,
            284555833,
            284553560,
            284550666,
            284546712,
            284545533,
            284552561
        ],
        "B": [
            284537997,
            284541648,
            284545572,
            284550280,
            284536827,
            284538339,
            284543136,
            284541306,
            284577835,
            284541582,
            284538597,
            284539525,
            284540971,
            284538476,
            284541915,
            284545007,
            284543924,
            284540121,
            284540098,
            284544260
        ],
        "A": [
            284536034,
            284541336,
            284535964,
            284545882,
            284543072,
            284535980,
            284537720,
            284537149,
            284572305,
            284541440,
            284535781,
            284536205,
            284539247,
            284535865,
            284537520,
            284541705,
            284541775,
            284537231,
            284537773,
            284536991
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134873",
    "editorial": "Firstly, let's relabel the n\n members such that member number i\n is the i\n-th member in the initial line configuration in array a\n. We also adjust the values in b\n (and the future updates) accordingly.\n\nFor now, let's solve the problem if there are no updates to the array b\n. Consider the first member who presents. Notice that member 1\n must be the first one presenting since he/she is at the very front of the line, which means b1=1\n must hold. After this, we insert him/her into any position in the line. However, instead of determining the target position immediately, we make member 1\n a \"pending member\" and we will only determine his/her position later on when we need him/her again.\n\nTo generalize, we can form an algorithm to check whether achieving b\n is possible or not. We iterate each element bi\n for each i\n from 1\n to m\n. While iterating, we maintain a set of pending members which is initially empty, and we maintain who is the next member in the line. When iterating a value of bi\n, there are three cases:\n\nIf bi\n is equal to the next member in the line, then we can make that member present. And then he/she will become a pending member for the next iterations.\nElse, if bi\n is one of the pending members, then we can always set a precise target position when moving that member in the past such that he/she will be at the very front of the line at this very moment. And then, that member will be a pending member again.\nElse, then it's impossible to make member bi\n present at this time.\nTo solve the problem with updates, let's observe some special properties of b\n if b\n is valid. Notice that once a member becomes a pending member, he/she will be a pending member forever. And a member x\n becomes a pending member during the first occurence of value x\n b\n. Since the order of members becoming pending must follow the order of the members in the line, that means the first occurence for each value x\n in b\n must be in chronological order from 1\n to n\n. More formally, let's define first[x]\n as follows:\n\nIf the value x\n appears at least once in b\n, then first[x]\n is the smallest index i\n such that bi=x\n.\nIf the value x\n doesn't appear in b\n, then first[x]=m+1\n.\nThen, for b\n to be valid, it must hold that first[1]?first[2]?\u0085?first[n]\n.\n\nTo handle the updates, we must maintain the array first\n. In order to do that, for each value x\n from 1\n to n\n, we maintain a set of indices for every occurence of x\n in b\n. The value of first\n is just the minimum value in the set, or m+1\n if the set is empty. An update to an element in b\n corresponds to two updates among the sets, which corresponds to two updates in array first\n.\n\nTo maintain the status on whether array first\n is non-decreasing or not, we maintain a value c\n which represents the number of pairs of adjacent indices (x,x+1)\n (for all 1?x?n?1\n) such that first[x]?first[x+1]\n. The array is non-decreasing if and only if c=n?1\n. For an update to an index x\n in first\n, we only need to check how pairs (x?1,x)\n and (x,x+1)\n affect the value of c\n.\n\nTime complexity for each test case: O((n+m+q)log(n+m))",
    "name": "C1. Adjust The Presentation  Easy Version ",
    "statement": "A team consisting of n members, numbered from 1 to n, is set to present\r\na slide show at a large meeting. The slide show contains m slides.There\r\nis an array a of length n. Initially, the members are standing in a line\r\nin the order of a_1, a_2,\r\nldots, a_n from front to back. The slide show will be presented in order\r\nfrom slide 1 to slide m. Each section will be presented by the member at\r\nthe front of the line. After each slide is presented, you can move the\r\nmember at the front of the line to any position in the lineup (without\r\nchanging the order of the rest of the members). For example, suppose the\r\nline of members is [\r\ncolor{red}{3},1,2,4]. After member 3 presents the current slide, you can\r\nchange the line of members into either [\r\ncolor{red}{3},1,2,4], [1,\r\ncolor{red}{3},2,4], [1,2,\r\ncolor{red}{3},4] or [1,2,4,\r\ncolor{red}{3}].There is also an array b of length m. The slide show is\r\nconsidered if it is possible to make member b_i present slide i for all\r\ni from 1 to m under these constraints.However, your annoying boss wants\r\nto make q updates to the array b. In the i-th update, he will choose a\r\nslide s_i and a member t_i and set b_{s_i} := t_i. Note that these\r\nupdates are , that is changes made to the array b will apply when\r\nprocessing future updates.For each of the q+1 states of array b, the\r\ninitial state and after each of the q updates, determine if the\r\nslideshow is good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}int n,m,q;int a[200010],b[200010],fl;bool vis[200010];void solve(){\tmemset(vis,0,(n+1));\u00a0\tn=Qread(),m=Qread(),q=Qread();\tfor(int i=1;i<=n;i++) a[i]=Qread();\tfor(int i=1;i<=m;i++) b[i]=Qread();\u00a0\tfl=1;\tfor(int i=1;i<=m;i++)\t{\t\tif(vis[b[i]]) continue;\t\tif(fl<=n&&a[fl]==b[i]){vis[a[fl++]]=true;continue;}\t\treturn printf(\"TIDAK\\n\"),void();\t}\tprintf(\"YA\\n\");}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C1. Adjust The Presentation  Easy Version .json"
}