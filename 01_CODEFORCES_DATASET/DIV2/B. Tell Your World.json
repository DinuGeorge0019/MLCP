{
    "link": "https://codeforces.com//contest/849/problem/B",
    "problemId": "120622",
    "problem_idx": "B",
    "shortId": "849B",
    "contest_number": "849",
    "problem_submissions": {
        "E": [
            29984627
        ],
        "D": [
            29980380,
            29984713,
            29987113,
            29987678,
            29986479,
            29988201,
            29987208,
            29988755,
            29987991,
            29987817,
            29987769,
            29988339,
            29988247,
            29989621,
            29986927,
            29988632,
            29990118,
            29990720,
            29989058,
            29990251
        ],
        "B": [
            29979684,
            29977657,
            29978977,
            29978484,
            29979095,
            29977894,
            29979276,
            29977973,
            29982859,
            29980015,
            29979892,
            29979449,
            29979975,
            29979216,
            29978971,
            29979346,
            29979237,
            29979525,
            29984295,
            29979922
        ],
        "C": [
            29976407,
            29980612,
            29981370,
            29975801,
            29981874,
            29980020,
            29981577,
            29978884,
            29980292,
            29982740,
            29981839,
            29981519,
            29982769,
            29982080,
            29982993,
            29981923,
            29980470,
            29981447,
            29979227,
            29982562
        ],
        "A": [
            29974883,
            29975173,
            29974854,
            29979296,
            29975395,
            29982064,
            29975326,
            29974873,
            29976333,
            29975161,
            29977076,
            29975568,
            29977504,
            29975431,
            29977059,
            29976536,
            29974950,
            29974966,
            29980055,
            29977173
        ]
    },
    "name": "B. Tell Your World",
    "statement": "There are points on a coordinate plane, the -th of which being\r\n.Determine whether itâ€™s possible to draw two parallel and\r\nnon-overlapping lines, such that every point in the set lies on of them,\r\nand each of them passes through point in the set.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define MN 1005\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,gs,pre;\nint a[MN];\nbool bj[MN],u[MN];\n\nint main()\n{\n\tregister int i,j;\n\tn=read();\n\tfor (i=1;i<=n;++i) a[i]=read();\n\tfor (i=1;i<n;++i) if (a[i+1]-a[i]!=a[2]-a[1]) break;\n\tif (i==n) return 0*printf(\"No\");\n\tfor (i=2;i<n;++i) if (a[i+1]-a[i]!=a[3]-a[2]) break;\n\tif (i==n) return 0*printf(\"Yes\");\n\tu[1]=true;\n\tfor (i=2;i<=n;++i)\n\t{\n\t\tif (u[i]) continue;\n\t\tmemset(bj,0,sizeof(bj));\n\t\tgs=1; bj[1]=true;\n\t\tfor (j=i;j<=n;++j) if (1LL*(a[j]-a[1])*(i-1)==1LL*(a[i]-a[1])*(j-1)) bj[j]=true,++gs;\n//\t\tfor (j=1;j<=n;++j) printf(\"%d \",bj[j]); puts(\"\");\n\t\tif (n-gs<2) return 0*printf(\"Yes\");\n\t\tpre=0;\n\t\tfor (j=1;j<=n;++j)\n\t\t{\n\t\t\tif (!bj[j]) {if (pre&&1LL*(a[j]-a[pre])*(i-1)!=1LL*(a[i]-a[1])*(j-pre)) break; pre=j;}\n\t\t\telse u[j]=true;\n\t\t}\n\t\tif (j>n) return 0*printf(\"Yes\");\n//\t\tfor (j=1;j<=n;++j) printf(\"%d \",u[j]); puts(\"\");\n\t}\n\tprintf(\"No\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "geometry"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Tell Your World.json",
    "editorial_link": "https://codeforces.com//blog/entry/54233",
    "editorial": "Denote them as , and .A possible Yes solution falls into one of these\r\nthree cases: one of the lines pass through and ; passes through and ; or\r\npasses through and . With each case, find out all the points that will\r\nbe covered if the line is extended infinitely, and if there are still\r\nremaining points and all of them are collinear, then the answer is Yes.\r\nTime complexity is .A possible Yes solution falls into one of these two\r\ncases: lies alone on a line; or some exists such that one of the lines\r\npasses through and . For the second case, iterate over this , and do it\r\nsimilarly as above to check whether a possible solution exists; for the\r\nfirst case, either check it specially, or reverse the array and apply\r\nthe check for second case again. Time complexity is .Note that in this\r\nproblem, there is no need to worry about floating point errors, since\r\nall possible slopes are either integers, or , which can be precisely\r\nstored with IEEE doubles.\r\n",
    "hint": [
        "Hint First way: consider the first three points. What cases are there? Second way: consider the first point. Either it's on a single line alone, or the line that passes through it passes through another point. Iterate over this point.",
        "Hint For a given string, how to calculate the cost? More For each letter, count how many times it appears in the original string.",
        "Hint When do dancers collide? What changes and what keeps the same? Next Group dancers by . What happens next?",
        "Hint Difference between last occurrence and first occurrence equals the sum of differences between pairs of adjacent occurrences. Handle this with some segment tree, or even non-standard size block decomposition, say sizes of .",
        "Hint Use DP. keeps the number of subgraphs with operations and a minimum cut of . The transition may be in a knapsack-like manner. Add more functions (say another ) if needed to make it faster. There are more than one way to do DP, you can also read about other nice solutions here and here .",
        "Hint Break the circle down into semicircles. Then there will be 1D/1D recurrences over several functions. Last insight Use FFT in a divide-and-conquer manner to optimize it."
    ]
}