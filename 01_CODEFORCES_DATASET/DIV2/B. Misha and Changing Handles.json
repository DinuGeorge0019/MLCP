{
    "link": "https://codeforces.com//contest/501/problem/B",
    "problemId": "20653",
    "problem_idx": "B",
    "shortId": "501B",
    "contest_number": "501",
    "problem_submissions": {
        "D": [
            9410957,
            9411339,
            9411793,
            9412714,
            9412830,
            9413378,
            9413495,
            9413859,
            9416597,
            9414226,
            9414777,
            9414880,
            9414082,
            9414871,
            9413282,
            9414476,
            9414234,
            9413065,
            9413605,
            9413446,
            9414020
        ],
        "C": [
            9409710,
            9412812,
            9409915,
            9410635,
            9411145,
            9410890,
            9410381,
            9411803,
            9411723,
            9411491,
            9410908,
            9413785,
            9412825,
            9408972,
            9410063,
            9413464,
            9416221,
            9416007
        ],
        "B": [
            9408651,
            9408711,
            9412680,
            9409222,
            9408915,
            9408969,
            9409184,
            9409368,
            9409570,
            9409614,
            9412592,
            9408622,
            9409821,
            9442325,
            9413740,
            9410394,
            9410355,
            9410485
        ],
        "A": [
            9407105,
            9407522,
            9412385,
            9407579,
            9407165,
            9407296,
            9407604,
            9407397,
            9407151,
            9407485,
            9407144,
            9407155,
            9408421,
            9441866,
            9414917,
            9414709,
            9407354,
            9407430,
            9407583,
            9409049
        ],
        "E": [
            9423665,
            9415217
        ]
    },
    "name": "B. Misha and Changing Handles",
    "statement": "Misha hacked the Codeforces site. Then he decided to let all the users\r\nchange their handles. A user can now change his handle any number of\r\ntimes. But each new handle must not be equal to any handle that is\r\nalready used or that was used at some point.Misha has a list of handle\r\nchange requests. After completing the requests he wants to understand\r\nthe relation between the original and the new handles of the users. Help\r\nhim to do that.\r\n",
    "solutions": [
        "/*\n    Look at me!\n    Look at me!\n    Look at how large the monster inside me has become!\n*/\n\n#include<fstream>\n#include<iostream>\n#include<cstdio>\n#include<map>\n#include<set>\n#define FIT(a,b) for(vector<int >::iterator a=b.begin();a!=b.end();a++)\n#define FITP(a,b) for(vector<pair<int,int> >::iterator a=b.begin();a!=b.end();a++)\n#define RIT(a,b) for(vector<int>::reverse_iterator a=b.end();a!=b.begin();++a)\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#define REP(a,b) for(register int a=0;a<b;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<ctime>\n#define f cin\n#define g cout\n#include<queue>\n#define debug cerr<<\"OK\";\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define ull unsigned long long\n#define mod 666013\n#define inf 1<<30\n#define N 200100\n#define DIM 10000000\nusing namespace std;\n/*int dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};*/\n\nint T[N],K,q,sol;\nstring a[N],b[N],nou[N];\n\nint main ()\n{\n\n    #ifndef ONLINE_JUDGE\n    freopen(\"a.in\",\"r\",stdin);\n    freopen(\"a.out\",\"w\",stdout);\n    #endif\n\n    f>>q;\n    FOR(i,1,q)\n    {\n        f>>a[i]>>b[i];\n        K=1;\n        ROF(j,i-1,1)\n        if(a[i].compare(nou[j])==0)\n        {\n            K=0;\n            nou[j]=b[i];\n            break;\n        }\n        if(K)\n        nou[i]=b[i];\n    }\n    FOR(i,1,q)\n    if(nou[i][0])\n    sol++;\n    g<<sol<<\"\\n\";\n    FOR(i,1,q)\n    if(nou[i][0])\n    {\n        g<<a[i]<<\" \"<<nou[i]<<\"\\n\";\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "strings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Misha and Changing Handles.json",
    "editorial_link": "https://codeforces.com//blog/entry/15743",
    "editorial": "The problem can be formulated as follows: The directed graph is given,\r\nits vertices correspond to users\u00e2\u0080\u0099 handles and edges to requests. It\r\nconsists of a number of chains, so every vertex ingoing and outgoing\r\ndegree doesn\u00e2\u0080\u0099t exceed one. One need to find number of chains and first\r\nand last vertices of every chain. The arcs of this graph can be stored\r\nin dictionary(one can use std::map\r\nunoredered_map in C++ and TreeMap\r\nHashMap in Java) with head of the arc as the key and the tail as the\r\nvalue. Each zero ingoing degree vertex corresponds to unique user as\r\nwell as first vertex of some chain. We should iterate from such vertices\r\nthrough the arcs while it\u00e2\u0080\u0099s possible. Thus we find relation between\r\nfirst and last vertices in the chain as well as relation between the\r\noriginal and the new handle of some user. You can see my solution for\r\ndetails. Time complexity: .\r\n"
}