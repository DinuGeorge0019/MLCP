{
    "link": "https://codeforces.com//contest/508/problem/E",
    "problemId": "21347",
    "problem_idx": "E",
    "shortId": "508E",
    "contest_number": "508",
    "problem_submissions": {
        "E": [
            9587610,
            9584813,
            9586421,
            9585135,
            9583814,
            9589053,
            9587449,
            9586484,
            9589963,
            9588638,
            9584850,
            9589523,
            9582441,
            9590322,
            9588666,
            9583017,
            9590629,
            9606435
        ],
        "D": [
            9585269,
            9592984,
            9592880,
            9606979,
            11955537,
            9597174,
            9607981,
            9591160
        ],
        "C": [
            9578155,
            9579052,
            9580254,
            9581709,
            9579236,
            9581849,
            9584375,
            9581929,
            9580398,
            9580036,
            9584567,
            9580689,
            9584970,
            9588863,
            9584808,
            9582586,
            9578299,
            9582444,
            9584975
        ],
        "B": [
            9575657,
            9576658,
            9575398,
            9576129,
            9576184,
            9577421,
            9578063,
            9577484,
            9575841,
            9575521,
            9580057,
            9577021,
            9576342,
            9586515,
            9578539,
            9578428,
            9577881,
            9580472
        ],
        "A": [
            9574439,
            9574503,
            9577415,
            9574774,
            9577057,
            9574902,
            9574502,
            9574812,
            9574701,
            9574474,
            9574846,
            9581748,
            9574597,
            9585159,
            9575359,
            9590306,
            9574725,
            9575399,
            9578528
        ]
    },
    "name": "E. Arthur and Brackets",
    "statement": "Recently Arthur and Sasha have studied correct bracket sequences. Arthur\r\nunderstood this topic perfectly and become so amazed about correct\r\nbracket sequences, so he even got himself a favorite correct bracket\r\nsequence of length . Unlike Arthur, Sasha understood the topic very\r\nbadly, and broke Arthur\u2019s favorite correct bracket sequence just to\r\nspite him.All Arthur remembers about his favorite sequence is for each\r\nopening parenthesis (\u201d) the approximate distance to the corresponding\r\nclosing one (\u201d). For the -th opening bracket he remembers the segment ,\r\ncontaining the distance to the corresponding closing bracket.Formally\r\nspeaking, for the -th opening bracket (in order from left to right) we\r\nknow that the difference of its position and the position of the\r\ncorresponding closing bracket belongs to the segment .Help Arthur\r\nrestore his favorite correct bracket sequence!\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvector <int> L;\nvector <int> R;\n\nvector <vector <int> > dp;\n\nint can(int l, int r) {\n    if (l > r) return true;\n\n    int & res = dp[l][r];\n    if (res != -1) {\n        return res;\n    }\n    res = 0;\n    for (int i = l; i <= r; ++i) {\n        int x = can(l + 1, i) && 2 * (i - l) >= L[l] - 1 && 2 * (i - l) <= R[l] - 1 && can(i + 1, r);\n        if (x) {\n            //cerr << l << \" \" << r << \" \" << i << endl;\n            res = 1;\n            return res;\n        }\n    }\n    return res;\n}\n\nvoid rec(int l, int r) {\n    if (l > r) return;\n    for (int i = l; i <= r; ++i) {\n        int x = can(l + 1, i) && 2 * (i - l) >= L[l] - 1 && 2 * (i - l) <= R[l] - 1 && can(i + 1, r);\n        if (x) {\n            cout << \"(\";\n            rec(l + 1, i);\n            cout << \")\";\n            rec(i + 1, r);\n            return;\n        }\n    }\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#else\n\n#endif\n\n    int n;\n\n    cin >> n;\n\n    L.resize(n);\n    R.resize(n);\n\n    dp.assign(n, vector <int>(n, -1));\n\n    for (int i = 0; i < n; ++i) {\n        cin >> L[i] >> R[i];\n    }\n\n    int ans = can(0, n - 1);\n    if (!ans) {\n        puts(\"IMPOSSIBLE\");\n        return 0;\n    }\n    rec(0, n - 1);\n    cout << \"\\n\";\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Arthur and Brackets.json",
    "editorial_link": "https://codeforces.com/blog/entry/16048?locale=en",
    "editorial": "This problem can be solved with help of dynamic dynamic programming. Let's create squre matrix Z with sizes n?\u00d7?n, where n \u0097 count of open brackets in sequence. Main hint \u0097 if open bracket is in position l, and corresponding for her close bracket \u0097 in position r, than from position l?+?1 to position r?-?1 must stay a regular bracket sequence.\n\nIn array Z first parametr lf \u0097 number of open bracket, second parametr rg \u0097 number of last open bracket, which can be in a regular bracket sequence, which will exists between open bracket with number lf and corresponding for it close bracket.\n\nZ[lf][rg]?=?true if it is possible to construct such sequence. Otherwise Z[lf][rg]?=?false.\n\nFor current lf and rg let's iterate on cnt \u0097 how many open brackets and corresponding them close brackets in a regular bracket sequence will stay between open bracket number lf and corresponding for it close bracket. If this count falls in the given interval for open bracket lf, recurcively run dynamic from two segments \u0097 (lf?+?1,?lf?+?cnt) and (lf?+?cnt?+?1,?rg).\n\nIf for both segments we can construct regular bracket sequences, appropriate to data-in from input, put in Z[lf][rg] value true. To restore answer, we must move from segment (lf,?rg) in segments (lf?+?1,?lf?+?cnt) and (lf?+?cnt?+?1,?rg), if for both this segments we can construct regular bracket sequences and recursively restore asnwer. If Z[0][n?-?1] equals to false, print IMPOSSIBLE. Asymptotic behavior of this solution \u0097 O(n3)."
}