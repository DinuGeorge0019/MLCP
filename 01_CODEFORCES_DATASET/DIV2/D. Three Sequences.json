{"link": "https://codeforces.com//contest/1406/problem/D", "problemId": "720774", "problem_idx": "D", "shortId": "1406D", "contest_number": "1406", "problem_submissions": {"E": [92629042, 92630500, 92628899, 92635228, 92634107, 92638626, 92619773, 97164376, 92640175, 92638803, 92636918, 92676046, 92671322, 92625530, 92637463, 92637483, 92614606, 92630766, 92631813, 92662786], "D": [92610024, 92609433, 92611409, 92609957, 92609251, 92609187, 92633310, 92613282, 92627048, 92606021, 92676006, 92636207, 92606425, 92616730, 92693126, 92691073, 92607353, 92606067, 92612958], "C": [92591912, 92593174, 92597136, 92597584, 92597579, 92602468, 92594387, 92596256, 92599703, 92594293, 92675991, 92618821, 92592065, 92605879, 92597551, 92594066, 92693156, 92691032, 92598806, 92594142, 92595349], "B": [92585402, 92587012, 92590282, 92585685, 92585843, 92593482, 92586267, 92588568, 92586097, 92589192, 92675966, 92591284, 92587210, 92582618, 92588033, 92585543, 92691012, 92591068, 92596476, 92585669], "A": [92582753, 92582816, 92583498, 92583384, 92582723, 92583951, 92583076, 92582946, 92583005, 92675955, 92583729, 92582667, 92591746, 92583143, 92583399, 92690980, 92584679, 92582643, 92583860]}, "name": "D. Three Sequences", "statement": "You are given a sequence of n integers a_1, a_2,\r\nldots, a_n.You have to construct two sequences of integers b and c with\r\nlength n that satisfy: for every i (1\r\nleq i\r\nleq n) b_i+c_i=a_i b is non-decreasing, which means that for every 1<i\r\nleq n, b_i\r\ngeq b_{i-1} must hold c is non-increasing, which means that for every\r\n1<i\r\nleq n, c_i\r\nleq c_{i-1} must hold You have to minimize\r\nmax(b_i,c_i). In other words, you have to minimize the maximum number in\r\nsequences b and c.Also there will be q changes, the i-th change is\r\ndescribed by three integers l,r,x. You should add x to a_l,a_{l+1},\r\nldots, a_r. You have to find the minimum possible value of\r\nmax(b_i,c_i) for the initial sequence and for sequence after each\r\nchange.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl '\\n'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\n\nstruct LAZY{\nvector<ll> tree,lazy;\nint n;\nLAZY(){}\nLAZY(int _n){ // pass a vector/array if needed\n  n = _n;\n  tree.resize(4*n + 100,0);\n  lazy.resize(4*n + 100,0);\n}\n\nll f(ll a,ll b){\n   return (a>b ? a : b); // max/min (a>b ? a : b)\n}\nvoid build(int no,int i,int j){\n  if(i==j){\n    tree[no] = 0;\n  }else{\n    int m = (i+j)/2;\n    int l = 2*no,r=2*no+1;\n    build(l,i,m);\n    build(r,m+1,j);\n    tree[no] = f(tree[l],tree[r]);\n  }\n}\n\nvoid propagate(int no,int i,int j){\n  if(lazy[no]==0)return;\n  tree[no]+=lazy[no];\n  if(i!=j){\n    lazy[2*no]+=lazy[no];\n    lazy[2*no+1]+=lazy[no];\n  }\n  lazy[no] = 0;\n}\n\nvoid update(int no,int i,int j,int a,int b,ll v){\n  propagate(no,i,j);\n  if(i>b || j<a || i>j)return;\n  if(a<=i && j<=b){\n    tree[no] += v;\n    if(i!=j){\n      lazy[2*no]+=v;\n      lazy[2*no+1]+=v;\n    }\n    return;\n  }\n  int m = (i+j)/2;\n  int l = 2*no,r=2*no+1;\n  update(l,i,m,a,b,v);\n  update(r,m+1,j,a,b,v);  \n  tree[no] = f(tree[l],tree[r]);\n}\n\nconst ll inf = 1e18;\nll query(int no,int i,int j,int a,int b){\n  if(i>b || j<a || i>j)return -inf;\n  \n  propagate(no,i,j);\n  \n  if(a<=i && j<=b)return tree[no];\n  \n  int m = (i+j)/2;\n  int l = 2*no,r=2*no+1;\n  \n  return f(query(l,i,m,a,b),query(r,m+1,j,a,b));\n}\n\n\n ll get(int x){\n  if(x == 1)return 0;\n  return max(0ll,query(1,1,n,x,x) - query(1,1,n,x-1,x-1));\n }\n\n};\n\n\nconst int N = 100100;\nll a[N];\n\nll get(ll X){\n  ll r = (X+1)/2 - 5;\n  while(r*2 < X)r++;\n  assert(2*r >= X);\n  return r;\n}\n\nint32_t main(){\n  FASTIO;\n  int n;\n  cin >> n;\n  LAZY L(n);\n  ll d=0;\n  for(int i=1;i<=n;i++){\n    cin >> a[i];\n    L.update(1,1,n,i,i,a[i]);\n    if(i!=1){\n      d+=max(0ll,a[i] - a[i-1]);\n    }\n  }\n  int q;\n  cin >> q;\n  cout << get(d + a[1]) << endl;\n  while(q--){\n    int l,r,x;\n    \n    cin >> l >> r >> x;\n    if(l==1)a[1]+=x;\n    pii c1 = pii(0,0),c2 = pii(0,0);\n    c1.ff = L.get(l);\n    c2.ff = L.get(r+1);\n    L.update(1,1,n,l,r,x);\n    c1.ss = L.get(l);\n    c2.ss = L.get(r+1);\n    //\n    d+=c1.ss - c1.ff;\n    d+=c2.ss - c2.ff;\n    //\n    ll res = get(d + a[1]);\n    cout << res << endl;\n  }\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "greedy", "math"], "dificulty": "2200", "interactive": false}