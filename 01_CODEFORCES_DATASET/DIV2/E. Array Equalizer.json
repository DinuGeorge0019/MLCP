{
    "link": "https://codeforces.com//contest/1605/problem/E",
    "problemId": "1182998",
    "problem_idx": "E",
    "shortId": "1605E",
    "contest_number": "1605",
    "problem_submissions": {
        "E": [
            135140556,
            135137170,
            135140149,
            135131162,
            135139425,
            135135884,
            135145750,
            135134170,
            135146319,
            135151738,
            135143897,
            135157772,
            135157112,
            135164572,
            135156916,
            135165811,
            135157373,
            135164912,
            135160322,
            135160455
        ],
        "D": [
            135123258,
            135121299,
            135126903,
            135118749,
            135131018,
            135121443,
            135128070,
            135130028,
            135134932,
            135133895,
            135133786,
            135133991,
            135133461,
            135131214,
            135138932,
            135135042,
            135138476,
            135132029,
            135132400,
            135148563
        ],
        "C": [
            135109471,
            135112911,
            135114732,
            135134429,
            135118955,
            135116544,
            135116248,
            135117340,
            135108363,
            135118939,
            135119487,
            135116822,
            135120064,
            135117077,
            135120474,
            135119518,
            135124633,
            135117200,
            135123222,
            135116741
        ],
        "B": [
            135104011,
            135105341,
            135106044,
            135104987,
            135108524,
            135104124,
            135112684,
            135116832,
            135113729,
            135109962,
            135123178,
            135110129,
            135109123,
            135109984,
            135111099,
            135109709,
            135119558,
            135106232,
            135120020,
            135107502
        ],
        "A": [
            135103035,
            135103047,
            135103241,
            135103076,
            135103421,
            135106303,
            135106513,
            135110580,
            135103745,
            135103393,
            135105600,
            135103522,
            135103862,
            135104535,
            135103487,
            135103484,
            135106186,
            135103066,
            135106006,
            135103429
        ]
    },
    "name": "E. Array Equalizer",
    "statement": "Jeevan has two arrays a and b of size n. He is fond of performing weird\r\noperations on arrays. This time, he comes up with two types of\r\noperations: Choose any i (1\r\nle i\r\nle n) and increment a_j by 1 for every j which is a multiple of i and 1\r\nle j\r\nle n. Choose any i (1\r\nle i\r\nle n) and decrement a_j by 1 for every j which is a multiple of i and 1\r\nle j\r\nle n. He wants to convert array a into an array b using the minimum\r\ntotal number of operations. However, Jeevan seems to have forgotten the\r\nvalue of b_1. So he makes some guesses. He will ask you q questions\r\ncorresponding to his q guesses, the i-th of which is of the form: If b_1\r\n= x_i, what is the minimum number of operations required to convert a to\r\nb? Help him by answering each question.\r\n",
    "solutions": [
        "// Problem: E. Array Equalizer\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nint a[1000003],b[1000003];\nint f[1000003];\nvector<int> d[200003];\nint prim[1000003];\nint mu[1000003],cnt=0;\nbool vis[1000003];\nvoid init()\n{\n    mu[1]=1;\n    for(int i=2;i<=200000;i++)\n    {\n        if(!vis[i]) prim[++cnt]=i,mu[i]=-1;\n        for(int j=1; j<=cnt&&prim[j]*i<=200000; j++)\n        {\n            vis[prim[j]*i]=1;\n            if(i%prim[j]==0) break; \n            else mu[i*prim[j]]=-mu[i];\n        }\n    }\n    for(int i=1; i<=200000; ++i)\n    \tfor(int j=1; i*j<=200000; ++j)\n    \t\td[i*j].push_back(i);\n}\nint A[1000003],sa;\nint pa[1000003];\nint B[1000003],sb;\nint pb[1000003];\nsigned main()\n{\n\tinit();\n\tint n=read();\n\tfor(int i=1; i<=n; ++i) a[i]=read();\n\tfor(int i=1; i<=n; ++i) b[i]=read();\n\tfor(int i=2; i<=n; ++i) f[i]=a[i]-b[i];\n\tint ans=0;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tint t=0;\n\t\tfor(int j:d[i]) t+=f[j]*mu[i/j];\n\t\tif(mu[i]==1) A[++sa]=t;\n\t\telse if(mu[i]==-1) B[++sb]=t;\n\t\telse ans+=abs(t);\n\t}\n\tsort(A+1,A+sa+1);sort(B+1,B+sb+1);\n\tfor(int i=1; i<=sa; ++i) pa[i]=pa[i-1]+A[i];\n\tfor(int i=1; i<=sb; ++i) pb[i]=pb[i-1]+B[i];\n\tfor(int T=read();T--;)\n\t{\n\t\tint x=a[1]-read();\n\t\tint posa=lower_bound(A+1,A+sa+1,-x)-A-1;\n\t\tint posb=lower_bound(B+1,B+sb+1,x)-B-1;\n\t\tint ans1=-posa*x-pa[posa];\n\t\tint ans2=(pa[sa]-pa[posa])+(sa-posa)*x;\n\t\tint ans3=-posb*(-x)-pb[posb];\n\t\tint ans4=(pb[sb]-pb[posb])+(sb-posb)*(-x);\n\t\tprintf(\"%lld\\n\",ans+ans1+ans2+ans3+ans4);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation",
        "math",
        "number theory",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Array Equalizer.json",
    "editorial_link": "https://codeforces.com//blog/entry/96866",
    "editorial": "Firstly letâs observe that only the differences matter, and not the\r\nindividual values of and . So let us create two more arrays and where\r\ninitially and for all . The problem reduces to making equal to .Letâs\r\nhave a few definitions for ease of explanation. We define operation\r\n\"add\" to as: perform the increment operation at (and multiples of ),\r\ntimes, if , otherwise perform the decrement operation at (and multiples\r\nof ), times. In both cases, the number of operations performed is .Letâs\r\nfirst solve the problem for only one value of . We notice that problem\r\ncan be solved using a simple greedy approach. We iterate over the\r\nelements from left to right. Let the index of the current element be .\r\nInitial arrays: -123456addââ At : Applying the operation at alone can\r\nchange the value of . Thereby we \"add\" at to make . The remaining array\r\nalso gets modified accordingly. Resulting arrays: -123456addââ At :\r\nApplying the operation at and only can change the value of . But since\r\nwe have already made , we will only apply operations at . We \"add\" at .\r\nResulting arrays: -123456addâ- At : Applying the operation at and only\r\ncan change the value of . But since we have already made , we will only\r\napply operations at . We \"add\" at . Resulting arrays: -123456addâ At :\r\nApplying the operation at , and only can change the value of . But since\r\nwe have already made and = B_2, we will only apply operations at . We\r\n\"add\" at . Resulting arrays: -123456addâ And so on...So we iterate from\r\nleft to right and at every index , we \"add\" current value of at . The\r\nfinal answer will be summation of absolute value of these values (i.e.\r\nthe values written in the \"add\" row).However, in the original problem,\r\nwe have to solve the problem for multiple values of . So let us assume\r\nthe value of to be equal to some variable, say . Let us try to use the\r\nsame approach with the variable . Initial arrays: -123456addââ At : We\r\n\"add\" at . Resulting arrays: -123456addââ At : We \"add\" at . Resulting\r\narrays: -123456addâ- At : We \"add\" at . Resulting arrays: -123456addâ At\r\n: We \"add\" at . Resulting arrays: -123456addâ And so on...Every cell in\r\nthe \"add\" row here will be of the form: . The final answer will be the\r\nsummation of absolute values of these values written in the \"add\"\r\nrow.Also we know,Note that the above equalities hold only when . So if\r\nis negative in any term, then we can multiply the entire term with to\r\nmake it positive since .Now, we can store the values of for each index\r\nin sorted order. And for each query, we can find out, using binary\r\nsearch, which of the absolute value terms will have a positive sign and\r\nwhich of those will have a negative sign. So we can finally calculate\r\nthe answer using prefix and suffix sums.Bonus: It turns out that the\r\nvalue of coefficient of in the \"add\" value for the -th index is where is\r\nthe mobious function. So .:\r\n",
    "hint": [
        "Hint 1 How would you solve the problem for one query?",
        "Hint 2 Assume the value of to be some variable, say .",
        "Hint 3 Try finding the number of operations applied at each index in terms of ."
    ]
}