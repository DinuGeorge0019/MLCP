{
    "link": "https://codeforces.com//contest/2001/problem/D",
    "problemId": "2825893",
    "problem_idx": "D",
    "shortId": "2001D",
    "contest_number": "2001",
    "problem_submissions": {
        "B": [
            277398710,
            277337688,
            277333922,
            277337722,
            277337555,
            277331647,
            277331395,
            277333468,
            277348528,
            277341588,
            277340363,
            277333951,
            277333359,
            277338651,
            277333253,
            277332470,
            277333025,
            277335874,
            277338084,
            277338047
        ],
        "A": [
            277396358,
            277332606,
            277324069,
            277328881,
            277324101,
            277323710,
            277325572,
            277324708,
            277342273,
            277324601,
            277327125,
            277324363,
            277324076,
            277325983,
            277324668,
            277323640,
            277324308,
            277324085,
            277329437,
            277324734
        ],
        "C": [
            277393929,
            277349647,
            277343837,
            277347819,
            277349047,
            277345424,
            277478575,
            277341657,
            277342745,
            277358874,
            277352973,
            277356317,
            277345054,
            277358657,
            277349482,
            277354577,
            277354478,
            277341600,
            277373032,
            277357702,
            277354144
        ],
        "D": [
            277386516,
            277362274,
            277363417,
            277423990,
            277364589,
            277362182,
            277363264,
            277481384,
            277378655,
            277372682,
            277373441,
            277372083,
            277373799,
            277371029,
            277376602,
            277374746,
            277374825,
            277383133,
            277374017,
            277362123,
            277383713,
            277376041
        ],
        "E2": [
            277373545,
            283086293,
            277423307,
            278251315,
            278253470
        ],
        "E1": [
            277335505,
            277376073,
            277395747,
            277388497,
            277391499,
            277398952,
            277393530,
            277401516,
            277389370,
            277393752,
            277394666,
            277405095,
            277396023,
            277402006,
            277399147,
            277397663,
            277407033,
            278257931,
            277717643,
            277717625,
            277717605,
            277717578,
            277403586,
            277396025,
            277402066
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132942",
    "editorial": "Consider\nsubtask:Letâs ignore the constraint where b should be lexicographically\nsmallest. How can we find the length of b?Apparently, it is the number\nof distinct elements in a. Letâs call it k.Construct b from left to\nright without worsening the answer:Now we know how to find the maximum\npossible length of b. Letâs try to construct b from left to right\nwithout worsening the answer, and greedily minimize its lexicographical\norder. Assume we pick a_i as the j-th element in b, then there should be\nk - j distinct elements in the subarray a[i + 1, n] after deleting all\nelements that appear in the subarray b[1, j].Assume we already construct\nb_1, b_2,\nldots, b_j where b_j = a_i and we want to find b_{j + 1}, and let l_x be\nthe last position where x occurs in the subarray a[i + 1, n] or\ninfty if it doesnât exist, then we can choose anything in a[i + 1,\nmin\nlimits_{1\nle x\nle n}(l_x)]. And to minimize lexicographical order, we need to choose\nthe maximum element in it if (j + 1) is odd, or the minimum element\notherwise. If there are multiple of them, choose the leftmost one of\nthem is optimal since we would have a longer suffix of a for future\nconstruction.Then observe for the candidate window (i.e. a[i + 1,\nmin\nlimits_{1\nle x\nle n}(l_x)]), its left bound and right bound are non-decreasing, so we\ncan use priority queues or set to maintain all possible candidates by\nstoring (a_{pos}, pos), and another priority queue or set to maintain\nall l_x > i. And the total time complexity is O(nlgn).\n",
    "name": "D. Longest Max Min Subsequence",
    "statement": "You are given an integer sequence a_1, a_2,\r\nldots, a_n. Let S be the set of all possible non-empty subsequences of a\r\nwithout duplicate elements. Your goal is to find the longest sequence in\r\nS. If there are multiple of them, find the one that minimizes\r\nlexicographical order after multiplying terms at odd positions by -1.For\r\nexample, given a = [3, 2, 3, 1], S =\r\n{[1], [2], [3], [2, 1], [2, 3], [3, 1], [3, 2], [2, 3, 1], [3, 2, 1]\r\n}. Then [2, 3, 1] and [3, 2, 1] would be the longest, and [3, 2, 1]\r\nwould be the answer since [-3, 2, -1] is lexicographically smaller than\r\n[-2, 3, -1].A sequence c is a subsequence of a sequence d if c can be\r\nobtained from d by the deletion of several (possibly, zero or all)\r\nelements.A sequence c is lexicographically smaller than a sequence d if\r\nand only if one of the following holds: c is a prefix of d, but c\r\nne d; in the first position where c and d differ, the sequence c has a\r\nsmaller element than the corresponding element in d.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}const int N=300005;int n;template<typename T,T (*merg)(T,T),T (*get)(T,T)>struct seg{\tT tr[N<<2],F[N];\tvoid Build(int id,int l,int r){\t\tif(l==r){tr[id]=F[l];re;}\t\tint mid=(l+r)>>1;\t\tBuild(id<<1,l,mid);Build(id<<1|1,mid+1,r);\t\ttr[id]=merg(tr[id<<1],tr[id<<1|1]);\t}\tvoid build(){Build(1,0,n-1);}\tvoid Upd(int id,int l,int r,int pos,T x){\t\tif(l==r){tr[id]=get(tr[id],x);re;}\t\tint mid=(l+r)>>1;\t\tif(pos<=mid)Upd(id<<1,l,mid,pos,x);\t\telse Upd(id<<1|1,mid+1,r,pos,x);\t\ttr[id]=merg(tr[id<<1],tr[id<<1|1]);\t}\tvoid upd(int pos,T x){Upd(1,0,n-1,pos,x);}\tT Qry(int id,int l,int r,int ql,int qr){\t\tif(ql<=l&&r<=qr)re tr[id];\t\tint mid=(l+r)>>1;\t\tif(ql<=mid&&qr>mid)re merg(Qry(id<<1,l,mid,ql,qr),Qry(id<<1|1,mid+1,r,ql,qr));\t\tif(ql<=mid)re Qry(id<<1,l,mid,ql,qr);\t\tre Qry(id<<1|1,mid+1,r,ql,qr);\t}\tT qry(int l,int r){re Qry(1,0,n-1,l,r);}};il int mg(int x,int y){re y;}il int mx(int x,int y){re max(x,y);}il int mi(int x,int y){re min(x,y);}seg<int,mx,mg>T1;seg<int,mi,mg>T2;vi vec[N];set<int>st;int a[N];void run(){\tcin>>n;\trep(i,n+1)vec[i].clear();\trep(i,n){\t\tcin>>a[i];\t\tT1.F[i]=a[i]*n+n-1-i;\t\tT2.F[i]=a[i]*n+i;\t\tvec[a[i]].pb(i);\t}//\trep(i,n)cout<<T1.F[i]<<\" \";cout<<\"\\n\";//\trep(i,n)cout<<T2.F[i]<<\" \";cout<<\"\\n\";\tT1.build();T2.build();\trep(i,n+1)if(sz(vec[i]))st.insert(vec[i].back());\tbool fl=0;\tint lp=0;\tvi ans;\twhile(sz(st)){\t\tint rp=*st.begin();\t\tint sp=-1,sv=-1;\t\tif(fl==0){\t\t\tint s=T1.qry(lp,rp);\t\t\tsv=s/n;sp=n-1-s%n;\t\t}\t\telse{\t\t\tint s=T2.qry(lp,rp);\t\t\tsv=s/n;sp=s%n;\t\t}\t\tst.erase(vec[sv].back());\t\tfor(int i:vec[sv])T1.upd(i,-INF);\t\tfor(int i:vec[sv])T2.upd(i,INF);\t\tans.pb(sv);\t\tlp=sp;\t\tfl^=1;\t}\tcout<<sz(ans)<<\"\\n\";\tfor(int i:ans)cout<<i<<\" \";cout<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Longest Max Min Subsequence.json",
    "hint": [
        "Hint 1 Forget about minimize lexicographical order. What's the size of longest we can get?",
        "Hint 2 It's the number of different elements. Try to minimize/maximize first element in without reducing the max size of we can get."
    ]
}