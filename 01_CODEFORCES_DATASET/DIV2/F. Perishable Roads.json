{
    "link": "https://codeforces.com//contest/807/problem/F",
    "problemId": "105606",
    "problem_idx": "F",
    "shortId": "807F",
    "contest_number": "807",
    "problem_submissions": {
        "C": [
            26937367,
            26932679,
            26931824,
            26933954,
            26935002,
            26945243,
            26934673,
            26931916,
            26932051,
            26931857,
            26932221,
            26934137,
            26931106,
            26934955,
            26948034,
            26933750,
            26931179,
            26933734
        ],
        "E": [
            26937218,
            26941715,
            26942118,
            26943819,
            26944219,
            26940388,
            26942912,
            26974189,
            26945366,
            26938570,
            26939988,
            26940095
        ],
        "D": [
            26933616,
            26938470,
            26937308,
            26935937,
            26940795,
            26937188,
            26938367,
            26934356,
            26935620,
            26933949,
            26944682,
            26939881,
            26963824,
            26941895,
            26936251,
            26938625,
            26938681
        ],
        "B": [
            26929187,
            26930221,
            26930051,
            26930975,
            26931611,
            26930997,
            26945828,
            26929713,
            26931410,
            26929634,
            26929851,
            26931739,
            26929439,
            26931155,
            26930623,
            26932660,
            26928773,
            26928963
        ],
        "A": [
            26926738,
            26928269,
            26927513,
            26927911,
            81453119,
            81452755,
            26927099,
            26927720,
            26926862,
            26927495,
            26936234,
            26928013,
            26926637,
            26926993,
            26927122,
            26929273,
            26927007,
            26927862,
            26926641,
            26926659
        ],
        "F": [
            27349164
        ]
    },
    "name": "F. Perishable Roads",
    "statement": "In the country of Never, there are cities and a well-developed road\r\nsystem. There is exactly one bidirectional road between every pair of\r\ncities, thus, there are as many as roads! No two roads intersect, and no\r\nroad passes through intermediate cities. The art of building tunnels and\r\nbridges has been mastered by Neverians.An independent committee has\r\nevaluated each road of Never with a positive integer called the of the\r\nroad. The lower the road\u2019s perishability is, the more pleasant it is to\r\ndrive through this road.It\u2019s the year of transport in Never. It has been\r\ndecided to build a museum of transport in one of the cities, and to set\r\na single signpost directing to some city (not necessarily the one with\r\nthe museum) in each of the other cities. The signposts must satisfy the\r\nfollowing important condition: if any Neverian living in a city without\r\nthe museum starts travelling from that city following the directions of\r\nthe signposts, then this person will eventually arrive in the city with\r\nthe museum.Neverians are incredibly positive-minded. If a Neverian\r\ntravels by a route consisting of several roads, he considers the to be\r\nequal to the smallest perishability of all the roads in this route.The\r\ngovernment of Never has not yet decided where to build the museum, so\r\nthey consider all possible options. The most important is the sum of\r\nperishabilities of the routes to the museum city from all the other\r\ncities of Never, if the travelers strictly follow the directions of the\r\nsignposts. The government of Never cares about their citizens, so they\r\nwant to set the signposts in a way which minimizes this sum. Help them\r\ndetermine the minimum possible sum for all possible options of the city\r\nwhere the museum can be built.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\n#define maxn 2010\n#define ll long long\nint a[maxn][maxn];\nll d[maxn];\nbool used[maxn];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;++i)\n    {\n        a[i][i]=0;\n        for(int j=i+1;j<n;++j)\n        {\n            scanf(\"%d\",&a[i][j]);\n            a[j][i]=a[i][j];\n        }\n    }\n    int mn=a[0][1];\n    for(int i=0;i<n;++i)\n        for(int j=i+1;j<n;++j)\n            mn=min(mn,a[i][j]);\n    for(int i=0;i<n;++i)\n        for(int j=0;j<n;++j)\n            if(i!=j) a[i][j]-=mn;\n    for(int i=0;i<n;++i)\n    {\n        d[i]=INF; used[i]=false;\n        for(int j=0;j<n;++j)\n            if(i!=j)\n                d[i]=min(d[i],2LL*a[i][j]);\n    }\n    for(int it=0;it<n;++it)\n    {\n        ll tmp=INF;\n        int v=-1;\n        for(int i=0;i<n;++i)\n            if(!used[i]&&d[i]<tmp)\n            {\n                tmp=d[i];\n                v=i;\n            }\n        used[v]=true;\n        for(int i=0;i<n;++i)\n            d[i]=min(d[i],d[v]+a[v][i]);\n    }\n    for(int i=0;i<n;++i)\n        printf(\"%I64d\\n\",d[i]+1LL*mn*(n-1));\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Perishable Roads.json",
    "editorial_link": "https://codeforces.com/blog/entry/51883",
    "editorial": "This is my favorite problem in this contest. Several clever observations make its solution really simple.\n\nFirst important observation helps understand the optimal structure of the signpost directions. Suppose there are two cities A and B with the signposts directed to the same city C. Without loss of generality, suppose that the road A-C has smaller or equal perishability than the road B-C. Then, if the signpost in city B is redirected to city A instead, perishability of the route from B (as well as from other cities with routes passing through B) to the museum city won't increase. It follows that there exists an optimal solution with at most one signpost directing to each city, so the directions of the signposts form a path ending in the museum city.\n\nSecond important observation is that there exists a road with the smallest perishability p. Let's subtract p from all road perishabilities, and increase the answer by p\u00b7(n?-?1) in the end. Now, all roads have non-negative perishabilities, and there exists a road with perishability 0. Once our path contains such a road, perishabilities of all routes from cities after this road up the path is equal to 0.\n\nMore formally, let's denote perishabilities of the roads in the path starting from the museum city as w1,?w2,?...,?wn?-?1. The sought sum is then equal to . It's easy to prove that there exists some k such that wk?=?0. Indeed, as we go up the path from the museum city, then once we visit an endpoint of any 0-perishability road it's good to follow this 0-perishability road so that route perishabilities of all the remaining cities become 0.\n\nConsider an optimal solution, and let k be the smallest index with wk?=?0. Let's prove that for all i???k?-?3 we have wi?>?wi?+?1. Indeed, assume that for some i???k?-?3 we have wi???wi?+?1. Then, since the graph is complete, we can replace the i?+?1-th edge with an edge directing to an endpoint of any 0-perishability road, and the i?+?2-th edge with this 0-perishability road. In this case, the minimized sum will become smaller, which is a contradiction to our solution being optimal.\n\nThen, we have two options: either wk?-?2?>?wk?-?1 or wk?-?2???wk?-?1. If some path of the first type is optimal, then it always coincides with the minimum weight path from the museum city to some city adjacent to a 0-perishability road, and the weight of this path will be the answer. If some path of the second type is optimal, then in this path we first move to some city X, and then use two roads to move to a city adjacent to a 0-perishability road, and we increase the answer by double the weight of the first of these roads as the result of this movement \u0097 therefore, first we find the minimum weight path from the museum city to each city X, increase the weight of this path by double the smallest perishability of the roads adjacent to X, and find the answer as the smallest of these values.\n\nThis gives us an O(n3) solution if we run Dijkstra's algorithm from every vertex of the graph to find the answer for it.\n\nIt can be optimized to O(n2) if instead of running Dijkstra's algorithm from every vertex, we run just one instance of Dijkstra's algorithm, initializing the answer for each vertex with double the smallest perishability of an adjacent edge."
}