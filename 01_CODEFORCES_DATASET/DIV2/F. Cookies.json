{"link": "https://codeforces.com//contest/1099/problem/F", "problemId": "278506", "problem_idx": "F", "shortId": "1099F", "contest_number": "1099", "problem_submissions": {"E": [48000148, 48008414, 48015162, 48015155, 47998674, 68679965, 48055305, 48002816, 48005156, 48004046], "F": [47993398, 48000668, 47998030, 47996940, 48003129, 48002459, 48000786, 48002880, 48003524, 48001521, 48002772, 48065469, 48065253, 48007017, 48004595, 48004955, 48023235, 48006181, 48008407], "D": [47985584, 47989615, 47984416, 47978723, 47985339, 47986984, 47992304, 47990729, 47990739, 47992156, 47990766, 47987456, 47986225, 47993500, 47991322, 47992653, 47992397, 47991707, 47988171, 47987589], "C": [47981176, 47983527, 47980104, 47987818, 47981157, 47982699, 47982090, 47982267, 47986173, 47985738, 47981653, 47982375, 47988366, 47985929, 47986209, 47986811, 47984704, 47981818, 47983683], "B": [47976890, 47977488, 47975669, 47984516, 47975576, 47975800, 47977583, 47977135, 47978430, 47982162, 47977417, 47977771, 47981576, 47979226, 47979187, 47980494, 47977529, 47975997, 47978338], "A": [47974401, 47973914, 47973933, 47982820, 47974013, 47974051, 47974701, 47974488, 47974881, 47974319, 47973925, 47973908, 47975086, 47976101, 47974397, 47974659, 47974316, 47973944, 47974200]}, "name": "F. Cookies", "statement": "Mitya and Vasya are playing an interesting game. They have a rooted tree\r\nwith n vertices, and the vertices are indexed from 1 to n. The root has\r\nindex 1. Every other vertex i\r\nge 2 has its p_i, and vertex i is called a of vertex p_i.There are some\r\ncookies in every vertex of the tree: there are x_i cookies in vertex i.\r\nIt takes exactly t_i time for Mitya to eat cookie in vertex i. There is\r\nalso a chip, which is initially located in the root of the tree, and it\r\ntakes l_i time to move the chip along the edge connecting vertex i with\r\nits parent.Mitya and Vasya take turns playing, Mitya goes first. Mitya\r\nmoves the chip from the vertex, where the chip is located, to one of its\r\nchildren. Vasya can remove an edge from the vertex, where the chip is\r\nlocated, to one of its children. Vasya can also decide to skip his turn.\r\nMitya can stop the game at any his turn. Once he stops the game, he\r\nmoves the chip up to the root, eating some cookies along his way. Mitya\r\ncan decide how many cookies he would like to eat in every vertex on his\r\nway. The total time spent on descend, ascend and eating cookies should\r\nnot exceed T. Please note that in the end of the game the chip is always\r\nlocated in the root of the tree: Mitya can not leave the chip in any\r\nother vertex, even if he has already eaten enough cookies he must move\r\nthe chip back to the root (and every move from vertex v to its parent\r\ntakes l_v time).Find out what is the maximum number of cookies Mitya can\r\neat, regardless of Vasya\u2019s actions.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\nconst int MAXV = (int)1e6 + 42;\n\nint64_t tr[4 * MAXN];\nint64_t cnt[4 * MAXN];\n\nvoid add(int pos, int64_t cnt, int64_t val, int l, int r, int idx)\n{\n\tif(pos < l || pos > r) return;\n\tif(l == r)\n\t{\n\t\ttr[idx] += val * cnt;\n\t\t::cnt[idx] += cnt;\n\t\treturn;\n\t}\n\n\tint mid = (l + r) >> 1;\n\tadd(pos, cnt, val, l, mid, 2 * idx + 1);\n\tadd(pos, cnt, val, mid + 1, r, 2 * idx + 2);\n\n\ttr[idx] = tr[2 * idx + 1] + tr[2 * idx + 2];\n\t::cnt[idx] = ::cnt[2 * idx + 1] + ::cnt[2 * idx + 2];\n}\n\nint64_t query(int64_t X, int l, int r, int idx)\n{\n\tif(l == r) \n\t{\n\t\tint64_t can = min(cnt[idx], X / l);\n\t\treturn can;\n\t}\n\n\tint mid = (l + r) >> 1;\n\tif(tr[2 * idx + 1] <= X) return cnt[2 * idx + 1] + query(X - tr[2 * idx + 1], mid + 1, r, 2 * idx + 2);\n\treturn query(X, l, mid, 2 * idx + 1);\n}\n\nint64_t T;\n\nvoid add(int64_t cnt, int64_t v) { add(v, cnt, v, 1, MAXV, 0); }\nvoid rem(int64_t cnt, int64_t v) { add(v, -cnt, v, 1, MAXV, 0); }\nint64_t query(int64_t I) { return query(I, 1, MAXV, 0); }\n\nint n;\nint x[MAXN], t[MAXN];\nvector<pair<int, int64_t> > adj[MAXN];\n\nvoid read()\n{\n\tcin >> n >> T;\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tfor(int i = 1; i <= n; i++) cin >> t[i];\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tint par;\n\t\tint64_t l;\n\t\tcin >> par >> l;\n\t\tadj[par].pb({i, l});\n\t}\n}\n\nint64_t value[MAXN];\n\nvoid dfs1(int u, int64_t Len = 0)\n{\n\tadd(x[u], t[u]);\n\tvalue[u] = query(T - 2ll * Len);\n\n\tfor(auto e: adj[u])\n\t\tdfs1(e.first, Len + e.second);\n\n\trem(x[u], t[u]);\n}\n\nint64_t dfs2(int u)\n{\n\tint64_t ret = value[u];\n\tvector<int64_t> lis;\n\tfor(auto e: adj[u])\n\t\tlis.pb(dfs2(e.first));\n\n\tif(!lis.empty())\n\t{\n\t\tsort(ALL(lis));\n\t\tlis.pop_back();\n\t\tif(!lis.empty())\n\t\t\tchkmax(ret, lis.back());\t\t\t\n\t}\n\n\treturn ret;\n}\n\nvoid solve()\n{\n\tdfs1(1);\n\t\n\tint64_t answer = value[1];\n\tfor(auto e: adj[1])\n\t\tchkmax(answer, dfs2(e.first));\n\t\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "dp", "games", "trees"], "dificulty": "2400", "interactive": false}