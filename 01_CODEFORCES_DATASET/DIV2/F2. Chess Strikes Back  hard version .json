{"link": "https://codeforces.com//contest/1379/problem/F2", "problemId": "676895", "problem_idx": "F2", "shortId": "1379F2", "contest_number": "1379", "problem_submissions": {"F2": [87337334], "F1": [87335742, 87339101, 87337260, 87346349, 87331786], "C": [87325904, 87311494, 87310672, 87300625, 87303708, 87304495, 87303918, 144460845, 87308563, 87299896, 87303811, 87316171, 87303179, 87308051, 87311612, 87310601, 87310579, 87310057, 87313129, 87307968, 87308536], "D": [87320979, 87326317, 87326054, 87310243, 87318999, 87323134, 87327442, 144461795, 87328150, 87328279, 87321031, 87333849, 87337374, 87336880, 87336733, 87324819, 87323673, 87326632, 87332039, 87324509], "B": [87292569, 87299875, 87297218, 87294683, 87294536, 87293871, 87299681, 144459626, 87295308, 87293115, 87290952, 87296663, 87291474, 87295427, 87292476, 87294398, 87295480, 87294133, 87302755, 87296827, 87299220], "A": [87289516, 87291821, 87290680, 87291117, 87290110, 87290710, 87290018, 144458741, 87289978, 87290066, 87289499, 87289644, 87295538, 87290013, 87289641, 87289754, 87291674, 87304051, 87290874, 87292316, 87291880], "E": []}, "name": "F2. Chess Strikes Back  hard version ", "statement": "Ildar and Ivan are tired of chess, but they really like the chessboard,\r\nso they invented a new game. The field is a chessboard 2n\r\ntimes 2m: it has 2n rows, 2m columns, and the cell in row i and column j\r\nis colored white if i+j is even, and is colored black otherwise.The game\r\nproceeds as follows: Ildar marks some of the cells of the chessboard as\r\n, and asks Ivan to place n\r\ntimes m kings on the remaining cells in such way, so that there are no\r\nkings attacking each other. A king can attack another king if they are\r\nlocated in the adjacent cells, sharing an edge or a corner.Ildar would\r\nlike to explore different combinations of cells. Initially all cells are\r\nmarked as available, and then he has q queries. In each query he either\r\nmarks a cell as unavailable, or marks the previously unavailable cell as\r\navailable. After each query he would like to know whether it is possible\r\nto place the kings on the available cells in a desired way. Please help\r\nhim!\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntuple<bool, int, int> domerge(tuple<bool, int, int> a, tuple<bool, int, int> b) {\n\treturn {\n\t\tget<0>(a) && get<0>(b) && get<2>(a) > get<1>(b),\n\t\tmax(get<1>(a), get<1>(b)),\n\t\tmin(get<2>(a), get<2>(b))\n\t};\n}\n\n\nclass SegmentTree {\npublic:\n\tvector< tuple<bool, int, int> > a;\n\tint n;\n\n\tSegmentTree(int sz) {\n\t\tn = sz;\n\t\ta.resize(4 * n, tuple<bool, int, int>(true, -1, 1000000000));\n\t}\n\n\tvoid set(int v, int vl, int vr, int i, tuple<bool, int, int> x) {\n\t\tif(vr - vl == 1) {\n\t\t\ta[v] = x;\n\t\t} else {\n\t\t\tint vm = (vl + vr) / 2;\n\t\t\tif(i < vm) {\n\t\t\t\tset(v * 2, vl, vm, i, x);\n\t\t\t} else {\n\t\t\t\tset(v * 2 + 1, vm, vr, i, x);\n\t\t\t}\n\t\t\ta[v] = domerge(a[v * 2], a[v * 2 + 1]);\n\t\t}\n\t}\n\n\tvoid set(int i, tuple<bool, int, int> x) {\n\t\tset(1, 0, n, i, x);\n\t}\n\n\ttuple<bool, int, int> get(int v, int vl, int vr, int l, int r) {\n\t\tif(vl == l && vr == r) {\n\t\t\treturn a[v];\n\t\t} else {\n\t\t\tint vm = (vl + vr) / 2;\n\t\t\tif(r <= vm) {\n\t\t\t\treturn get(v * 2, vl, vm, l, r);\n\t\t\t} else if(l >= vm) {\n\t\t\t\treturn get(v * 2 + 1, vm, vr, l, r);\n\t\t\t} else {\n\t\t\t\treturn domerge(get(v * 2, vl, vm, l, vm), get(v * 2 + 1, vm, vr, vm, r));\n\t\t\t}\n\t\t}\n\t}\n\n\ttuple<bool, int, int> get(int l, int r) {\n\t\treturn get(1, 0, n, l, r);\n\t}\n};\n\nsigned main() {\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\tvector< set<int> > zeroes_on_line(n);\n\tvector< set<int> > ones_on_line(n);\n\n\tSegmentTree st(n);\n\n\tfor(int cnt = 0; cnt < q; cnt++) {\n\t\tint i, j;\n\t\tcin >> i >> j;\n\t\ti--; j--;\n\t\tbool is_one = i % 2 == 0;\n\t\ti /= 2;\n\t\tj /= 2;\n\n\t\tif(is_one) {\n\t\t\tif(ones_on_line[i].count(j)) {\n\t\t\t\tones_on_line[i].erase(j);\n\t\t\t} else {\n\t\t\t\tones_on_line[i].insert(j);\n\t\t\t}\n\t\t} else {\n\t\t\tif(zeroes_on_line[i].count(j)) {\n\t\t\t\tzeroes_on_line[i].erase(j);\n\t\t\t} else {\n\t\t\t\tzeroes_on_line[i].insert(j);\n\t\t\t}\n\t\t}\n\n\t\tauto line = st.get(i, i + 1);\n\t\tget<1>(line) = zeroes_on_line[i].empty() ? -1 : *zeroes_on_line[i].rbegin();\n\t\tget<2>(line) = ones_on_line[i].empty() ? 1000000000 : *ones_on_line[i].begin();\n\t\tget<0>(line) = get<1>(line) < get<2>(line);\n\t\tst.set(i, line);\n\n\t\tif(get<0>(st.get(0, n))) {\n\t\t\tcout << \"YES\" << \"\\n\";\n\t\t} else {\n\t\t\tcout << \"NO\" << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer"], "dificulty": "2800", "interactive": false}