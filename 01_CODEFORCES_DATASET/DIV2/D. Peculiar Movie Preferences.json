{
    "link": "https://codeforces.com//contest/1629/problem/D",
    "problemId": "1270553",
    "problem_idx": "D",
    "shortId": "1629D",
    "contest_number": "1629",
    "problem_submissions": {
        "E": [
            143691687,
            143672752,
            143687137,
            143663655,
            143674506,
            143679445,
            143862635,
            143682492,
            143680665,
            143680424,
            143685684,
            143684891,
            143753002,
            143685619,
            143692185,
            143689230,
            143685863,
            143687115,
            143695099,
            143693974
        ],
        "F2": [
            143688718,
            143726329,
            143690987
        ],
        "F1": [
            143676123,
            143697164,
            143692998,
            143741879,
            143678223,
            143750588,
            143750365
        ],
        "D": [
            143667461,
            143661533,
            143674891,
            143656107,
            143648676,
            143665361,
            143663909,
            143668220,
            143661278,
            143662732,
            143656926,
            143668180,
            143668746,
            143665526,
            143669234,
            143667378,
            143676861,
            143663591,
            143664123
        ],
        "C": [
            143651046,
            143647499,
            143659885,
            143651714,
            143662268,
            143651456,
            143647120,
            143654421,
            143646086,
            143650221,
            143697555,
            143656282,
            143655178,
            143644392,
            143657665,
            143654804,
            143651022,
            143650097,
            143652583
        ],
        "B": [
            143642034,
            143637040,
            143638720,
            143651837,
            143664772,
            143638989,
            143637268,
            143641201,
            143638312,
            143634980,
            143632383,
            143644246,
            143635339,
            143635326,
            143637617,
            143639992,
            143639371,
            143640785,
            143642627
        ],
        "A": [
            143633916,
            143631168,
            143632391,
            143651906,
            143666062,
            143631304,
            143631044,
            143630886,
            143631218,
            143630607,
            143639841,
            143633922,
            143630487,
            143630572,
            143630653,
            143631188,
            143630505,
            143635250,
            143635282
        ]
    },
    "name": "D. Peculiar Movie Preferences",
    "statement": "You are given a list s of n non-empty strings of length , representing\r\nthe scenes of Mihai\u2019s movie.A subsequence of s is called if it is\r\nnon-empty and the concatenation of the strings in the subsequence, in\r\norder, is a palindrome.Can you help Mihai check if there is at least one\r\nawesome subsequence of s?A palindrome is a string that reads the same\r\nbackward as forward, for example strings \"\", \"\", \"\", \"\" are palindromes,\r\nbut strings \"\", \"\", \"\" are not.A sequence a is a non-empty subsequence\r\nof a non-empty sequence b if a can be obtained from b by deletion of\r\nseveral (possibly zero, but not all) elements.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 998244353\nll read() {\n\tll x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\nint T;\nint n;\nchar s[101010][5];\nint len[101010];\nint val[101010];\nint val2[101010];\nint val3[101010];\nint id(char s1,char s2) {\n\treturn (s1-'a')*30+s2-'a';\n}\nint id2(char s1,char s2,char s3){\n\treturn (s1-'a')*30*30+(s2-'a')*30+s3;\n}\nint main() {\n\tscanf(\"%d\",&T);\n\twhile(T--) {\n\t\tmemset(val,0,sizeof(val));\n\t\tmemset(val2,0,sizeof(val2));\n\t\tmemset(val3,0,sizeof(val3));\n\t\tint ans=0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tscanf(\"%s\",s[i]+1);\n\t\t\tlen[i]=strlen(s[i]+1);\n\t\t\tif(len[i]==1) {ans=1;}\n\t\t\telse if(len[i]==2) {\n\t\t\t\tif(s[i][1]==s[i][2]) {ans=1;}\n\t\t\t\tif(val[id(s[i][2],s[i][1])]||val3[id(s[i][2],s[i][1])]) {ans=1;}\n\t\t\t\tval[id(s[i][1],s[i][2])]=1;\n\t\t\t}\n\t\t\telse if(len[i]==3) {\n\t\t\t\tif(s[i][1]==s[i][3]) {ans=1;}\n\t\t\t\tif(val[id(s[i][3],s[i][2])]) {ans=1;}\n\t\t\t\tif(val2[id2(s[i][3],s[i][2],s[i][1])]) {ans=1;}\n\t\t\t\tval2[id2(s[i][1],s[i][2],s[i][3])]=1;val3[id(s[i][1],s[i][2])]=1;\n\t\t\t}\n\t\t}\n\t\tif(ans) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Peculiar Movie Preferences.json",
    "editorial_link": "https://codeforces.com//blog/entry/99276",
    "editorial": "Because of the low constraints on the lengths of the strings, we can prove that it's enough to pair at most 2\n strings to form a palindrome.\n\n<proof only checking pairs is enough>\n\nLet's assume there is a awesome subsequence of the form xyz where x and z are single strings from s, and y is anything. If x and z are the same length, they clearly have to be reverses of each other for xyz to be a palindrome, so y is not needed to make it a palindrome. If they are not the same length, one of them is of length 3 and the other is of length 2. Assume x is the string of length 3 and y is the string of length 2. The first two characters of x must be the reverse of z. If x and z are concatenated, the third character of x is in the middle, so it doesn't matter. So in this case too, y is not needed. This proves that if any awesome subsequence exists, there also exists an awesome subsequence of 1 or 2 strings.\n\n<proof ends>\n\nSo, we first check if there exists a palindrome already, if there is, we found a solution! If not, checking for each pair would take too long, but we can do it much more efficiently. We can assume that all strings are of length 2\n or 3\n since if there was a string of length 1\n it would be a palindrome and we would have found the solution earlier.\n\nFor each string of length 2\n it's enough to check if before it, we have seen a string of the following 2\n forms: its reverse or its reverse with a character appended to it (so a string of length 3\n), since the last character of a string of length 3\n would be the middle character of the palindrome obtained after concatenation.\n\nFor each string of length 3\n it's enough to check if before it, we have seen a string of the following 2\n forms: its reverse or the reverse of the string without considering the first character (so a string of length 2\n), since the first character of a string of length 3\n would be the middle character of the palindrome obtained after concatenation.\n\nAll this can be checked using a frequency matrix, map, set or other data structures."
}