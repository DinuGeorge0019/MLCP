{"link": "https://codeforces.com//contest/1287/problem/F", "problemId": "509652", "problem_idx": "F", "shortId": "1287F", "contest_number": "1287", "problem_submissions": {"E2": [68292966], "E1": [68275567, 69857829, 68268888, 68267730, 68276517, 68275345, 68277506], "D": [68254686, 69267989, 68263399, 68273154, 68268233, 68260202, 68261652, 68267427, 68261050, 68269506, 68253370, 68261828, 68262781, 68259993, 68263653, 68262032, 68264765, 68263857, 68263835, 68268683], "C": [68251057, 69267378, 68258032, 68258705, 68258307, 68255841, 68251184, 68254777, 68254064, 68259914, 68257391, 68256601, 68256839, 68253229, 68254316, 68258260, 68255773, 68259159, 68259073, 68255080], "B": [68248587, 69266960, 68254034, 68252413, 68256461, 68250437, 68247733, 68281202, 68281106, 68280696, 68280618, 68264095, 68250685, 68253499, 68259982, 68248645, 68435109, 68253464, 68263831, 68250832, 68248995, 68250500, 68255530, 68255702, 68249590], "A": [68244872, 69266641, 68245653, 68244897, 68247583, 68245583, 68244694, 68245113, 68244700, 68244809, 68261293, 68244924, 68435072, 68246461, 68245783, 68245033, 68244706, 68244729, 68245472, 68245512, 68245361], "F": [68641340]}, "name": "F. LCC", "statement": "An infinitely long Line Chillland Collider (LCC) was built in Chillland.\r\nThere are n pipes with coordinates x_i that are connected to LCC. When\r\nthe experiment starts at time 0, i-th proton flies from the i-th pipe\r\nwith speed v_i. It flies to the right with probability p_i and flies to\r\nthe left with probability (1 - p_i). The is determined as the time of\r\nthe first collision of any two protons. In case there is no collision,\r\nthe duration of the experiment is considered to be zero.Find the\r\nexpected value of the duration of the experiment.Illustration for the\r\nfirst example\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=110000;\nconst int P=998244353;\nconst int INV100=828542813;\nvoid exgcd(int a, int b, int& x, int& y)\n{\n\tif (b==0) x=1, y=0;\n\telse exgcd(b, a%b, y, x), y-=a/b*x;\n}\ninline int inv(int a)\n{\n\tint x, y;\n\texgcd(a, P, x, y);\n\treturn (x%P+P)%P;\n}\nstruct Matrix\n{\n\tint n, m, a[3][3];\n\tMatrix() {}\n\tMatrix(int r, int c): n(r), m(c)\n\t{\n\t\tmemset(a, 0, sizeof a);\n\t}\n\tMatrix operator * (const Matrix& b) const\n\t{\n\t\tMatrix c(n, b.m);\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (int k=0; k<m; k++)\n\t\t\t\tfor (int j=0; j<b.m; j++)\n\t\t\t\t\tc.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j])%P;\n\t\treturn c;\n\t}\n} w[MAXN];\nstruct SegmenTree\n{\n\tstruct Node\n\t{\n\t\tint l, r;\n\t\tMatrix val;\n\t} tr[4*MAXN];\n\t#define lc (o<<1)\n\t#define rc (o<<1|1)\n\tvoid pushup(int o)\n\t{\n\t\ttr[o].val=tr[lc].val*tr[rc].val;\n\t}\n\tvoid build(int o, int l, int r)\n\t{\n\t\ttr[o].l=l; tr[o].r=r;\n\t\tif (l==r) { tr[o].val=w[l]; return; }\n\t\tint mid=l+r>>1;\n\t\tbuild(lc, l, mid);\n\t\tbuild(rc, mid+1, r);\n\t\tpushup(o);\n\t}\n\tvoid update(int o, int p)\n\t{\n\t\tif (tr[o].l==tr[o].r)\n\t\t{\n\t\t\ttr[o].val=w[p];\n\t\t\treturn;\n\t\t}\n\t\tint mid=tr[o].l+tr[o].r>>1;\n\t\tif (p<=mid) update(lc, p);\n\t\telse update(rc, p);\n\t\tpushup(o);\n\t}\n\t#undef lc\n\t#undef rc\n} st;\nstruct Pipe\n{\n\tint x, v, p;\n\tPipe() {}\n\tPipe(int a, int b, int c): x(a), v(b), p(c) {}\n} a[MAXN];\nstruct Movement\n{\n\tint id, d0, d1;\n\tMovement() {}\n\tMovement(int a, int b, int c):\n\t\tid(a), d0(b), d1(c) {}\n\tbool operator < (const Movement& rhs) const\n\t{\n\t\treturn 1ll*(a[id].x-a[id-1].x)*(rhs.d0*a[rhs.id-1].v-rhs.d1*a[rhs.id].v)\n\t\t      <1ll*(a[rhs.id].x-a[rhs.id-1].x)*(d0*a[id-1].v-d1*a[id].v);\n\t}\n\tvoid set(bool k)\n\t{\n\t\tif (d0==1)\n\t\t\tif (d1==1) w[id].a[0][0]=k*a[id].p;\n\t\t\telse w[id].a[0][1]=k*(1-a[id].p+P)%P;\n\t\telse\n\t\t\tif (d1==1) w[id].a[1][0]=k*a[id].p;\n\t\t\telse w[id].a[1][1]=k*(1-a[id].p+P)%P;\n\t}\n\tint meettime()\n\t{\n\t\treturn 1ll*(a[id].x-a[id-1].x)*inv(d0*a[id-1].v-d1*a[id].v)%P;\n\t}\n} b[4*MAXN];\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\tint n, m=0;\n\tscanf(\"%d\", &n);\n\ta[0]=Pipe(-(1E9+233), 1E6+233, 0);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x, v, p;\n\t\tscanf(\"%d%d%d\", &x, &v, &p);\n\t\ta[i]=Pipe(x, v, 1ll*p*INV100%P);\n\t\tb[++m]=Movement(i, 1, -1);\n\t\tif (a[i].v<a[i-1].v) b[++m]=Movement(i, 1, 1);\n\t\telse if (a[i].v>a[i-1].v) b[++m]=Movement(i, -1, -1);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tw[i]=Matrix(2, 2);\n\t\tw[i].a[0][0]=w[i].a[1][0]=a[i].p;\n\t\tw[i].a[0][1]=w[i].a[1][1]=(1-a[i].p+P)%P;\n\t}\n\tst.build(1, 1, n);\n\tsort(b+1, b+m+1);\n\tint ans=0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tMatrix t=w[b[i].id];\n\t\tw[b[i].id]=Matrix(2, 2); b[i].set(1);\n\t\tst.update(1, b[i].id);\n\t\tans=(ans+1ll*b[i].meettime()*(st.tr[1].val.a[1][0]+st.tr[1].val.a[1][1]))%P;\n\t\tw[b[i].id]=t; b[i].set(0);\n\t\tst.update(1, b[i].id);\t\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "math", "probabilities"], "dificulty": "3100", "interactive": false}