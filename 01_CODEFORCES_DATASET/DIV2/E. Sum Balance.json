{"link": "https://codeforces.com//contest/1243/problem/E", "problemId": "461416", "problem_idx": "E", "shortId": "1243E", "contest_number": "1243", "problem_submissions": {"E": [64413060, 64469730, 64408846, 64417229, 64399200, 64470547, 64416699, 64442944], "D": [64391286, 64397713, 64431742, 64397869, 64387912, 64386733, 64389402, 64387675, 64408229, 64380388, 64396146, 64395794, 64394593, 64392997, 64394432, 64400786, 64397002, 64396496, 64397563, 64397111, 64393509], "C": [64384895, 64387481, 64390976, 64405340, 64382337, 64385693, 64385929, 64394275, 64434799, 64386198, 64382497, 64383809, 64377823, 64389605, 64376790, 64385883, 64378335, 64383814, 64387181, 64382731, 64387786], "B2": [64382237, 64381285, 64379711, 64392921, 64382257, 64380535, 64394999, 64387075, 64388632, 64389667, 64386828, 64401152, 64379896, 64404188, 64390999, 64383775, 64439469, 64397436, 64400046], "B1": [64376943, 64376875, 64382975, 64410900, 64376252, 64375532, 64376537, 64399066, 64383882, 64379534, 64379185, 64385521, 64377760, 64384722, 64375586, 64377602, 64378450, 64377183, 64379613, 64377830], "A": [64373589, 64373694, 64408041, 64373563, 64373607, 64373538, 64381662, 64378360, 64376936, 64374179, 64380404, 64373751, 64374463, 64373629, 64373483, 64374884, 64373477, 64375133, 64374905]}, "name": "E. Sum Balance", "statement": "Ujan has a lot of numbers in his boxes. He likes order and balance, so\r\nhe decided to reorder the numbers.There are k boxes numbered from 1 to\r\nk. The i-th box contains n_i integer numbers. The integers can be\r\nnegative. Ujan is lazy, so he will do the following reordering of the\r\nnumbers . He will pick a single integer from each of the boxes, k\r\nintegers in total. Then he will insert the chosen numbers one integer in\r\neach of the boxes, so that the number of integers in each box is the\r\nsame as in the beginning. Note that he may also insert an integer he\r\npicked from a box back into the same box.Ujan will be happy if the sum\r\nof the integers in each box is the same. Can he achieve this and make\r\nthe boxes perfectly balanced, like all things should be?\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long   ll;\ntypedef long double ld;\n\n#define all(x)  (x).begin(), (x).end()\n#define sz(x)   (x).size()\n#define pb      push_back\n#define mp      make_pair\n#define fr      first\n#define sc      second\n\nconst int N = 100 * 1000 + 5;\n\nint k, n[20];\nvector<vector<ll>> elems;\nll oversum = 0, colsum[20], each;\nunordered_map<ll, int> cols;\n\nvoid input() {\n    cin >> k;\n    elems.resize(k);\n    for(int i = 0; i < k; i++) {\n        cin >> n[i];\n        elems[i].resize(n[i]);\n        for(int j = 0; j < n[i]; j++) {\n            cin >> elems[i][j];\n            cols[elems[i][j]] = i;\n            colsum[i] += elems[i][j];\n            oversum += elems[i][j];\n        }\n    }\n}\n\nvector<vector<pair<int, ll>>> cycles;\n\nvoid simulate(int ni, ll elem) {\n    vector<ll> tmpsums(colsum, colsum + k);\n    vector<pair<int, ll>> res {};\n    res.emplace_back(ni, elem);\n    while(tmpsums[ni] != each) {\n        ll needed = each - (tmpsums[ni] - elem);\n        if (cols.find(needed) == cols.end()) return;\n        int newni = cols[needed];\n        if (tmpsums[newni] == each || newni == ni) return;\n        tmpsums[ni] = each;\n        tmpsums[newni] += elem - needed;\n        res.emplace_back(newni, needed);\n        ni = newni;\n    }\n    // cout << sz(res) << endl;\n    int mask = 0;\n    for(auto& elem : res) {\n        mask |= (1 << elem.first);\n    }\n    if (cycles[mask].empty()) {\n        cycles[mask] = res;\n    }\n}\n\nvector<int> all_masks;\nvector<bool> gen;\nvector<int> last_mask;\n\nvoid solve() {\n    if (abs(oversum) % k != 0) {\n        puts(\"No\");\n        return;\n    }\n    each = oversum / k;\n    cycles.resize((1 << k));\n    for(int i = 0; i < k; i++) {\n        for(int j = 0; j < n[i]; j++) {\n            simulate(i, elems[i][j]);\n        }\n    }\n    gen.resize((1 << k), false);\n    gen[0] = true;\n    last_mask.resize((1 << k));\n    for(int mask = 0; mask < (1 << k); mask++) {\n        if (!cycles[mask].empty()) {\n            all_masks.pb(mask);\n            // cout << \"For mask \" << mask << \"\\n\";\n            // for(auto& elem : cycles[mask]) { cout << elem.fr << \" \" << elem.sc << \"\\n\"; }\n        }\n    }\n    for(int i = 1; i < (1 << k); i++) {\n        for(int mask : all_masks) {\n            if ((i & mask) == mask && gen[i ^ mask]) {\n                gen[i] = true;\n                last_mask[i] = mask;\n                break;\n            }\n        }\n    }\n    if (gen[(1 << k) - 1]) {\n        puts(\"Yes\");\n        int msk = (1 << k) - 1;\n        vector<pair<ll, int>> moves(k);\n        while(msk != 0) {\n            // cout << last_mask[msk] << \" \";\n            int tmp_msk = last_mask[msk];\n            int ssz = sz(cycles[tmp_msk]);\n            for(int i = 0; i < ssz; i++) {\n                moves[cycles[tmp_msk][i].fr] = mp(cycles[tmp_msk][i].sc, cycles[tmp_msk][(i - 1 + ssz) % ssz].fr + 1);\n                // cout << cycles[tmp_msk][i].sc << \" \" << cycles[tmp_msk][(i - 1 + ssz) % ssz].fr + 1 << endl;\n            }\n            msk ^= last_mask[msk];\n        }\n        for(auto& elem : moves) {\n            cout << elem.fr << \" \" << elem.sc << endl;\n        }\n    }\n    else {\n        puts(\"No\");\n    }\n\n\n\n\n\n}\n\nint main() {\n    int testcases = 1;\n    // scanf(\"%d\", &testcases);\n    while(testcases--) {\n        input();\n        solve();\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar", "dp", "graphs", "implementation"], "dificulty": "2400", "interactive": false}