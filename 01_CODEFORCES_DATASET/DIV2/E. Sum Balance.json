{
    "link": "https://codeforces.com//contest/1243/problem/E",
    "problemId": "461416",
    "problem_idx": "E",
    "shortId": "1243E",
    "contest_number": "1243",
    "problem_submissions": {
        "E": [
            64413060,
            64469730,
            64408846,
            64417229,
            64399200,
            64470547,
            64416699,
            64442944
        ],
        "D": [
            64391286,
            64397713,
            64431742,
            64397869,
            64387912,
            64386733,
            64389402,
            64387675,
            64408229,
            64380388,
            64396146,
            64395794,
            64394593,
            64392997,
            64394432,
            64400786,
            64397002,
            64396496,
            64397563,
            64397111,
            64393509
        ],
        "C": [
            64384895,
            64387481,
            64390976,
            64405340,
            64382337,
            64385693,
            64385929,
            64394275,
            64434799,
            64386198,
            64382497,
            64383809,
            64377823,
            64389605,
            64376790,
            64385883,
            64378335,
            64383814,
            64387181,
            64382731,
            64387786
        ],
        "B2": [
            64382237,
            64381285,
            64379711,
            64392921,
            64382257,
            64380535,
            64394999,
            64387075,
            64388632,
            64389667,
            64386828,
            64401152,
            64379896,
            64404188,
            64390999,
            64383775,
            64439469,
            64397436,
            64400046
        ],
        "B1": [
            64376943,
            64376875,
            64382975,
            64410900,
            64376252,
            64375532,
            64376537,
            64399066,
            64383882,
            64379534,
            64379185,
            64385521,
            64377760,
            64384722,
            64375586,
            64377602,
            64378450,
            64377183,
            64379613,
            64377830
        ],
        "A": [
            64373589,
            64373694,
            64408041,
            64373563,
            64373607,
            64373538,
            64381662,
            64378360,
            64376936,
            64374179,
            64380404,
            64373751,
            64374463,
            64373629,
            64373483,
            64374884,
            64373477,
            64375133,
            64374905
        ]
    },
    "name": "E. Sum Balance",
    "statement": "Ujan has a lot of numbers in his boxes. He likes order and balance, so\r\nhe decided to reorder the numbers.There are k boxes numbered from 1 to\r\nk. The i-th box contains n_i integer numbers. The integers can be\r\nnegative. Ujan is lazy, so he will do the following reordering of the\r\nnumbers . He will pick a single integer from each of the boxes, k\r\nintegers in total. Then he will insert the chosen numbers one integer in\r\neach of the boxes, so that the number of integers in each box is the\r\nsame as in the beginning. Note that he may also insert an integer he\r\npicked from a box back into the same box.Ujan will be happy if the sum\r\nof the integers in each box is the same. Can he achieve this and make\r\nthe boxes perfectly balanced, like all things should be?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long   ll;\ntypedef long double ld;\n\n#define all(x)  (x).begin(), (x).end()\n#define sz(x)   (x).size()\n#define pb      push_back\n#define mp      make_pair\n#define fr      first\n#define sc      second\n\nconst int N = 100 * 1000 + 5;\n\nint k, n[20];\nvector<vector<ll>> elems;\nll oversum = 0, colsum[20], each;\nunordered_map<ll, int> cols;\n\nvoid input() {\n    cin >> k;\n    elems.resize(k);\n    for(int i = 0; i < k; i++) {\n        cin >> n[i];\n        elems[i].resize(n[i]);\n        for(int j = 0; j < n[i]; j++) {\n            cin >> elems[i][j];\n            cols[elems[i][j]] = i;\n            colsum[i] += elems[i][j];\n            oversum += elems[i][j];\n        }\n    }\n}\n\nvector<vector<pair<int, ll>>> cycles;\n\nvoid simulate(int ni, ll elem) {\n    vector<ll> tmpsums(colsum, colsum + k);\n    vector<pair<int, ll>> res {};\n    res.emplace_back(ni, elem);\n    while(tmpsums[ni] != each) {\n        ll needed = each - (tmpsums[ni] - elem);\n        if (cols.find(needed) == cols.end()) return;\n        int newni = cols[needed];\n        if (tmpsums[newni] == each || newni == ni) return;\n        tmpsums[ni] = each;\n        tmpsums[newni] += elem - needed;\n        res.emplace_back(newni, needed);\n        ni = newni;\n    }\n    // cout << sz(res) << endl;\n    int mask = 0;\n    for(auto& elem : res) {\n        mask |= (1 << elem.first);\n    }\n    if (cycles[mask].empty()) {\n        cycles[mask] = res;\n    }\n}\n\nvector<int> all_masks;\nvector<bool> gen;\nvector<int> last_mask;\n\nvoid solve() {\n    if (abs(oversum) % k != 0) {\n        puts(\"No\");\n        return;\n    }\n    each = oversum / k;\n    cycles.resize((1 << k));\n    for(int i = 0; i < k; i++) {\n        for(int j = 0; j < n[i]; j++) {\n            simulate(i, elems[i][j]);\n        }\n    }\n    gen.resize((1 << k), false);\n    gen[0] = true;\n    last_mask.resize((1 << k));\n    for(int mask = 0; mask < (1 << k); mask++) {\n        if (!cycles[mask].empty()) {\n            all_masks.pb(mask);\n            // cout << \"For mask \" << mask << \"\\n\";\n            // for(auto& elem : cycles[mask]) { cout << elem.fr << \" \" << elem.sc << \"\\n\"; }\n        }\n    }\n    for(int i = 1; i < (1 << k); i++) {\n        for(int mask : all_masks) {\n            if ((i & mask) == mask && gen[i ^ mask]) {\n                gen[i] = true;\n                last_mask[i] = mask;\n                break;\n            }\n        }\n    }\n    if (gen[(1 << k) - 1]) {\n        puts(\"Yes\");\n        int msk = (1 << k) - 1;\n        vector<pair<ll, int>> moves(k);\n        while(msk != 0) {\n            // cout << last_mask[msk] << \" \";\n            int tmp_msk = last_mask[msk];\n            int ssz = sz(cycles[tmp_msk]);\n            for(int i = 0; i < ssz; i++) {\n                moves[cycles[tmp_msk][i].fr] = mp(cycles[tmp_msk][i].sc, cycles[tmp_msk][(i - 1 + ssz) % ssz].fr + 1);\n                // cout << cycles[tmp_msk][i].sc << \" \" << cycles[tmp_msk][(i - 1 + ssz) % ssz].fr + 1 << endl;\n            }\n            msk ^= last_mask[msk];\n        }\n        for(auto& elem : moves) {\n            cout << elem.fr << \" \" << elem.sc << endl;\n        }\n    }\n    else {\n        puts(\"No\");\n    }\n\n\n\n\n\n}\n\nint main() {\n    int testcases = 1;\n    // scanf(\"%d\", &testcases);\n    while(testcases--) {\n        input();\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dp",
        "graphs",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sum Balance.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "First, calculate the total average sum s:=(?ni=1ai)/k\n. If the answer is positive, the sum of integers in each box must be equal to s\n after reordering. If s\n is not integer, then the answer is immediately negative.\n\nNow, suppose that an integer x:=ai,p\n is taken out of some box i\n. Then we know that it should be replaced by y:=s??nij=1ai,j+ai,p\n. We then construct a graph where all of the given integers are vertices, and we draw a directed edge from x\n to y\n.\n\nNote that we obtain a functional graph. Examine all of the cycles of this graph; since this a functional graph, no two cycles share the same vertex. Let n:=?ki=1ni\n, then the total number of cycles is at most n?15?5000=75000\n.\n\nExamine any valid reordering. It is easy to see that it is a collection of cycles from the obtained graph such that each box is visited by some cycle exactly once. Therefore, lets extract all of the cycles from our graph such that do not pass through the same box twice. A valid reordering then is some subset of these cycles that visit all of the k\n boxes exactly once.\n\nWe can also reformulate this problem in the following way: each of the extracted cycles C\n visits some set of boxes S\n. Find all of such subsets S\n; the number of such subsets is at most 2k\n. Now, the problem is reduced to exactly covering the set {1,\u0085,k}\n with some subset of such sets.\n\nThis is a classical problem that can be solved in O(3n)\n using dynamic programming. For a subset X\n of {1,\u0085,k}\n, define dp[X]\n to be true if X\n can be exactly covered, and false otherwise. Firstly, dp[?]=true\n. To find dp[X]\n for X??\n, iterate over all subsets S\n of X\n, and check whether S\n is visited by some cycle and X?S\n can be covered (e.g., dp[X?S]\n is true). Then the answer is dp[{1,\u0085,k}]\n. "
}