{
    "link": "https://codeforces.com//contest/785/problem/E",
    "problemId": "98357",
    "problem_idx": "E",
    "shortId": "785E",
    "contest_number": "785",
    "problem_submissions": {
        "E": [
            25535913,
            25520701,
            25521367,
            25524258,
            25516770,
            25518668,
            25525495,
            25517389,
            25526683,
            25519510,
            25510315,
            25516733,
            25699539,
            25521276,
            25540389,
            25540369,
            25522122,
            25560171,
            25522262
        ],
        "D": [
            25514969,
            25516920,
            25517547,
            25523665,
            25527515,
            25519834,
            25527742,
            25518744,
            25524873,
            25653943,
            25515800,
            25517945,
            25515992,
            25518919,
            25517044,
            25522041
        ],
        "C": [
            25509527,
            25508471,
            25509773,
            25536741,
            25508063,
            25509604,
            25510288,
            25520657,
            25513296,
            25522523,
            25517091,
            25519490,
            25510828,
            25511108,
            25511948,
            25512218,
            25511493,
            25510575,
            25511287,
            25511649,
            25508687
        ],
        "B": [
            25505453,
            25505566,
            25506791,
            25505538,
            25504971,
            25506495,
            25505802,
            25505209,
            25507435,
            25512598,
            25507000,
            25506314,
            25505276,
            25506234,
            25507471,
            25504662,
            25505140,
            25505996,
            25505311,
            25505921
        ],
        "A": [
            25502237,
            25502308,
            25504008,
            25502246,
            25501830,
            25501715,
            25502679,
            25501866,
            25503109,
            25511198,
            25501880,
            25502005,
            25502194,
            25502627,
            25503151,
            25502062,
            25501702,
            25506739,
            25501679,
            25502337
        ]
    },
    "name": "E. Anton and Permutation",
    "statement": "Anton likes permutations, especially he likes to permute their elements.\r\nNote that a permutation of elements is a sequence of numbers , in which\r\nevery number from to appears exactly once.One day Anton got a new\r\npermutation and started to play with it. He does the following operation\r\ntimes: he takes two elements of the permutation and swaps these\r\nelements. After each operation he asks his friend Vanya, how many\r\ninversions there are in the new permutation. The number of inversions in\r\na permutation is the number of distinct pairs such that and .Vanya is\r\ntired of answering Anton\u2019s silly questions. So he asked you to write a\r\nprogram that would answer these questions instead of him.Initially\r\nAnton\u2019s permutation was , that is for all such that .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#define bel(i) ((i)>>10)\n#define lbt(i) ((i)&-(i))\nusing namespace std;\ntypedef long long LL;\nint n,q;\nconst int MX=200011,B=1024;\nint cnt[MX/B+2][MX],cntblk[MX/B+2][MX],a[MX];\ninline void add(int *c,int *s,int x,int d){\n\tfor(int i=x;bel(i)==bel(x)&&i<=n;i++)c[i]+=d;\n\tfor(int i=bel(x);i<=bel(n);i++)s[i]+=d;\n}\ninline int que(int *c,int *s,int x){\n\treturn bel(x)?s[bel(x)-1]+c[x]:c[x];\n}\nLL ans=0LL;\ninline int rd(){\n\tint x=0;char ch=getchar();\n\twhile(ch>'9'||ch<'0')ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint main(){\n\tn=rd(),q=rd();\n\tfor(int i=1;i<=n;i++)a[i]=i;\n\tfor(int i=1;i<=n;i++)add(cnt[bel(i)],cntblk[bel(i)],a[i],1);\n\tfor(int i=1;i<=q;i++){\n\t\tint l=rd(),r=rd();\n\t\tif(l==r)goto E;\n\t\tif(l>r)swap(l,r);\n\t\tif(a[l]<a[r]){\n\t\t\tans++;\n\t\t\tif(bel(l+1)==bel(r-1))for(int j=l+1;j<r;j++)ans+=2*(a[j]>a[l]&&a[j]<a[r]);\n\t\t\telse {\n\t\t\t\tfor(int j=l+1;bel(j)==bel(l+1);j++)ans+=2*(a[j]>a[l]&&a[j]<a[r]);\n\t\t\t\tfor(int j=r-1;bel(j)==bel(r-1);j--)ans+=2*(a[j]>a[l]&&a[j]<a[r]);\n\t\t\t\tfor(int j=bel(l+1)+1;j<bel(r-1);j++)ans+=2*(que(cnt[j],cntblk[j],a[r])-que(cnt[j],cntblk[j],a[l]));\n\t\t\t}\n\t\t}else{\n\t\t\tans--;\n\t\t\tif(bel(l+1)==bel(r-1))for(int j=l+1;j<r;j++)ans-=2*(a[j]>a[r]&&a[j]<a[l]);\n\t\t\telse {\n\t\t\t\tfor(int j=l+1;bel(j)==bel(l+1);j++)ans-=2*(a[j]>a[r]&&a[j]<a[l]);\n\t\t\t\tfor(int j=r-1;bel(j)==bel(r-1);j--)ans-=2*(a[j]>a[r]&&a[j]<a[l]);\n\t\t\t\tfor(int j=bel(l+1)+1;j<bel(r-1);j++)ans-=2*(que(cnt[j],cntblk[j],a[l])-que(cnt[j],cntblk[j],a[r]));\n\t\t\t}\n\t\t}\n\t\tadd(cnt[bel(l)],cntblk[bel(l)],a[l],-1);\n\t\tadd(cnt[bel(r)],cntblk[bel(r)],a[r],-1);\n\t\tswap(a[l],a[r]);\n\t\tadd(cnt[bel(l)],cntblk[bel(l)],a[l],1);\n\t\tadd(cnt[bel(r)],cntblk[bel(r)],a[r],1);\nE:\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Anton and Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/50996",
    "editorial": "At first observe that there is inversions in the initial\r\npermutation.Let\u00e2\u0080\u0099s divide our queries in blocks. Now learn how to answer\r\nall the queries in one block in .At first, let\u00e2\u0080\u0099s divide our positions in\r\nthe permutation in fixed and mobile positions. Mobile positions are all\r\nthe positions that are changed in the current block. Fixed positions are\r\nthe rest of the positions. Observe that the number of mobile positions\r\nis not more than . Now all the inversions are divided into three types:\r\nInversions only between fixed positions; Inversions only between mobile\r\npositions; Inversions between fixed and mobile positions. To keep\r\ninversions of the first type is the easiest of all: their number doesn\u00e2\u0080\u0099t\r\nchange. So we can precalcualte them in the beginning of the block. How\r\ncan we do it? Let\u00e2\u0080\u0099s remember the answer for the query that was directly\r\nbefore the beginning of the block (if the block starts with the first\r\nquery, this number is equal to ). This number is equal to the total\r\nnumber of inversions in the beginning of the block. To get the number of\r\nfixed inversions, we can just subtract from this number the number of\r\ninversions of the second and the third types.It\u00e2\u0080\u0099s also easy to calculate\r\nthe number of inversions of the second type. In the beginning their\r\nnumber can be counted even using a naive algorithm in . How to keep this\r\nnumber? We can recalculate each time not all the inversions but only\r\nthese ones that contain changed elements. Totally we can count them in\r\nfor a block.It\u00e2\u0080\u0099s a little bit harder to keep inversions of the third\r\ntype. To count them we\u00e2\u0080\u0099ll use the similar approach as with inversions of\r\nthe second type. We\u00e2\u0080\u0099ll also recount the number of inversions only for\r\nchanged elements. So, we must learn how to count the number of\r\ninversions between fixed elements and some mobile element on the\r\nposition . What fixed elements make an inversion with it? It\u00e2\u0080\u0099s obvious\r\nthat these are the elements which are earlier than the -th and wherein\r\nbigger than it (denote this query ) or elements which are later than the\r\n-th and wherein smaller than it (denote this query ). Here denotes the\r\n-th element of permutation. Observe that there are such queries.How can\r\nwe calculate the answers for these queries quickly? At first note that\r\nwe can count them offline, because fixed elements doesn\u00e2\u0080\u0099t change and\r\nmobile elements are not counted in these queries. Consider how we can\r\ncount answers for (for we can use the same approach). Let\u00e2\u0080\u0099s sort all the\r\nqueries by non-decreasing . Now if we have some structure that can add a\r\nvalue to an element and count a sum on a segment, we can easily do it.\r\nLet we added the fixed elements that stay earlier than (it can be easily\r\ndone because all the queries are sorted by non-decreasing ). So the\r\nanswer is the sum on the segment .What data structure can we use? We can\r\nuse sqrt-decomposition, because it takes for adding and for sum query.\r\nTotally all the and queries in a block are processed in .Time complexity\r\nis .There also exists an solution. You can find it by yourself as an\r\nexercise. Such solution should be written carefully, otherwise it\r\ndoesn\u00e2\u0080\u0099t fit to the time limit or memory limit.\r\n"
}