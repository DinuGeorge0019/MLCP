{
    "link": "https://codeforces.com//contest/1253/problem/D",
    "problemId": "472861",
    "problem_idx": "D",
    "shortId": "1253D",
    "contest_number": "1253",
    "problem_submissions": {
        "F": [
            65199103,
            65190951,
            65202217,
            65200176,
            65205791,
            65198288,
            65206369,
            65202224,
            65204185,
            65198880,
            71343526,
            65209779,
            69242445
        ],
        "E": [
            65190374,
            65200198,
            65189404,
            65179572,
            65189474,
            65203687,
            65210511,
            65176917,
            65203722,
            65186844,
            65188534,
            65195069,
            65199233,
            65190702,
            65194167,
            65189184,
            65189079,
            65566785,
            65194999,
            65197237
        ],
        "D": [
            65185415,
            65178485,
            65180601,
            65183049,
            65178022,
            65187686,
            65195445,
            65178632,
            65179619,
            65180170,
            65183967,
            65181658,
            65188561,
            65181701,
            65182069,
            65187758,
            65183529,
            65182372,
            65181324
        ],
        "C": [
            65180957,
            65172664,
            65176866,
            65185425,
            65173509,
            65180180,
            65194567,
            65173458,
            65200178,
            65176131,
            65179441,
            65175878,
            65184305,
            65178007,
            65179468,
            65178975,
            65179727,
            65177898,
            65176250
        ],
        "B": [
            65175476,
            65202574,
            65174599,
            65188764,
            65185456,
            65176094,
            65186553,
            65183630,
            65196117,
            65172495,
            65173857,
            65173178,
            65174792,
            65174898,
            65174679,
            65176409,
            65176161,
            65176165,
            65172853
        ],
        "A": [
            65171088,
            65170116,
            65170656,
            65190482,
            65180567,
            65170231,
            65180099,
            65170284,
            65170843,
            65169770,
            65169894,
            65169914,
            65170943,
            65169881,
            65172675,
            65172008,
            65171211,
            65169945,
            65169720
        ]
    },
    "name": "D. Harmonious Graph",
    "statement": "You\u2019re given an undirected graph with n nodes and m edges. Nodes are\r\nnumbered from 1 to n.The graph is considered if and only if the\r\nfollowing property holds: For every triple of integers (l, m, r) such\r\nthat 1\r\nle l < m < r\r\nle n, if there exists a going from node l to node r, then there exists a\r\ngoing from node l to node m. In other words, in a harmonious graph, if\r\nfrom a node l we can reach a node r through edges (l < r), then we\r\nshould able to reach nodes (l+1), (l+2),\r\nldots, (r-1) too.What is the minimum number of edges we need to add to\r\nmake the graph harmonious?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n\nint n,m;\nvector < int > E[200005];\nint P[200005];\n\nint f( int x ){\n\tif ( P[x] != x ) return P[x] = f(P[x]);\n\treturn x;\n}\n\nint main(){\n\n\n\tscanf(\"%d%d\",&n,&m);\n\tfor ( int i = 1; i <= n; i++ ) P[i] = i;\n\tfor ( int i = 0; i < m; i++ ){\n\t\tint u, v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tE[u].pb(v);\n\t\tE[v].pb(u);\n\t\tif ( f(u) != f(v) ){\n\t\t\tint pu = f(u), pv = f(v);\n\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\tP[pv] = pu;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tint Max = -1;\n\tfor ( int i = 1; i <= n; i++ ){\n\t\tfor ( int v : E[i] ){\n\t\t\tMax = max( Max, v );\n\t\t\tif ( v > i ){\n\t\t\t\tif ( f(v) != f(i) ){\n\t\t\t\t\tans++;\n\t\t\t\t\tint pu = f(v), pv = f(i);\n\t\t\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\t\t\tP[pv] = pu;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( Max <= i ) {\n\t\t\tMax = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif ( f(Max) != f(i) ){\n\t\t\tans++;\n\t\t\tint pu = f(Max), pv = f(i);\n\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\tP[pv]= pu;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Harmonious Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/71489?locale=en",
    "editorial": "For each connected component, let\u00e2\u0080\u0099s find the weakest node and the\r\nbiggest node in it (with one DFS per connected component).If we look for\r\nall components at their intervals , we can see that two components\r\nshould be connected in the resulting graph if and only if their\r\nintervals intersect. This leads to a naive solution : create a second\r\ngraph where nodes represent components, add an edge between all pairs of\r\ncomponents with intersecting intervals, and choose any spanning\r\nforest.To optimize it, generate intervals in increasing order of\r\n(starting DFS in increasing order of nodes numbers). Look at them in\r\nthis order, maintaining the biggest end seen. If , it is necessary to\r\nconnect current interval to the interval ending at (hence increment\r\nanswer).It is quite easy to prove that doing only these connections is\r\nalso sufficient (i.e. resulting graph will be harmonious).Final\r\ncomplexity is .Implementation\r\n"
}