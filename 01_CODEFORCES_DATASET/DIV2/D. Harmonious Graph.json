{"link": "https://codeforces.com//contest/1253/problem/D", "problemId": "472861", "problem_idx": "D", "shortId": "1253D", "contest_number": "1253", "problem_submissions": {"F": [65199103, 65190951, 65202217, 65200176, 65205791, 65198288, 65206369, 65202224, 65204185, 65198880, 71343526, 65209779, 69242445], "E": [65190374, 65200198, 65189404, 65179572, 65189474, 65203687, 65210511, 65176917, 65203722, 65186844, 65188534, 65195069, 65199233, 65190702, 65194167, 65189184, 65189079, 65566785, 65194999, 65197237], "D": [65185415, 65178485, 65180601, 65183049, 65178022, 65187686, 65195445, 65178632, 65179619, 65180170, 65183967, 65181658, 65188561, 65181701, 65182069, 65187758, 65183529, 65182372, 65181324], "C": [65180957, 65172664, 65176866, 65185425, 65173509, 65180180, 65194567, 65173458, 65200178, 65176131, 65179441, 65175878, 65184305, 65178007, 65179468, 65178975, 65179727, 65177898, 65176250], "B": [65175476, 65202574, 65174599, 65188764, 65185456, 65176094, 65186553, 65183630, 65196117, 65172495, 65173857, 65173178, 65174792, 65174898, 65174679, 65176409, 65176161, 65176165, 65172853], "A": [65171088, 65170116, 65170656, 65190482, 65180567, 65170231, 65180099, 65170284, 65170843, 65169770, 65169894, 65169914, 65170943, 65169881, 65172675, 65172008, 65171211, 65169945, 65169720]}, "name": "D. Harmonious Graph", "statement": "You\u2019re given an undirected graph with n nodes and m edges. Nodes are\r\nnumbered from 1 to n.The graph is considered if and only if the\r\nfollowing property holds: For every triple of integers (l, m, r) such\r\nthat 1\r\nle l < m < r\r\nle n, if there exists a going from node l to node r, then there exists a\r\ngoing from node l to node m. In other words, in a harmonious graph, if\r\nfrom a node l we can reach a node r through edges (l < r), then we\r\nshould able to reach nodes (l+1), (l+2),\r\nldots, (r-1) too.What is the minimum number of edges we need to add to\r\nmake the graph harmonious?\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n\nint n,m;\nvector < int > E[200005];\nint P[200005];\n\nint f( int x ){\n\tif ( P[x] != x ) return P[x] = f(P[x]);\n\treturn x;\n}\n\nint main(){\n\n\n\tscanf(\"%d%d\",&n,&m);\n\tfor ( int i = 1; i <= n; i++ ) P[i] = i;\n\tfor ( int i = 0; i < m; i++ ){\n\t\tint u, v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tE[u].pb(v);\n\t\tE[v].pb(u);\n\t\tif ( f(u) != f(v) ){\n\t\t\tint pu = f(u), pv = f(v);\n\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\tP[pv] = pu;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tint Max = -1;\n\tfor ( int i = 1; i <= n; i++ ){\n\t\tfor ( int v : E[i] ){\n\t\t\tMax = max( Max, v );\n\t\t\tif ( v > i ){\n\t\t\t\tif ( f(v) != f(i) ){\n\t\t\t\t\tans++;\n\t\t\t\t\tint pu = f(v), pv = f(i);\n\t\t\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\t\t\tP[pv] = pu;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( Max <= i ) {\n\t\t\tMax = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif ( f(Max) != f(i) ){\n\t\t\tans++;\n\t\t\tint pu = f(Max), pv = f(i);\n\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\tP[pv]= pu;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "dsu", "graphs", "greedy", "sortings"], "dificulty": "1700", "interactive": false}