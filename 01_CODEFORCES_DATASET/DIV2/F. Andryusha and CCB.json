{
    "link": "https://codeforces.com//contest/2092/problem/F",
    "problemId": "3297798",
    "problem_idx": "F",
    "shortId": "2092F",
    "contest_number": "2092",
    "problem_submissions": {
        "F": [
            313024072
        ],
        "E": [
            313000271,
            312969707,
            312983960,
            312981996,
            312968778,
            312981677,
            312983137,
            312976146,
            312967918,
            312987199,
            312966853,
            312978935,
            312982784,
            312983310,
            312990508
        ],
        "D": [
            312985746,
            312980683,
            312966151,
            312963806,
            312979770,
            312972092,
            312973588,
            312972934,
            312975411,
            312970630,
            312984829,
            312974754,
            312973591,
            312974219,
            312974125
        ],
        "C": [
            312968332,
            312958283,
            312951558,
            312951101,
            312956688,
            312962577,
            312960872,
            312961466,
            312959434,
            312964501,
            312963490,
            312968676,
            312965224,
            312966318,
            312958909
        ],
        "B": [
            312954182,
            312954965,
            312956218,
            312968439,
            312955440,
            312953626,
            312955662,
            312953860,
            312954705,
            312962665,
            312965211,
            312957241,
            312955219,
            312953537
        ],
        "A": [
            312949653,
            312950184,
            312949676,
            312949416,
            312951072,
            312954840,
            312949917,
            312948936,
            312949574,
            312962028,
            315023921,
            312963336,
            312950648,
            312950994,
            312951265
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141023",
    "editorial": "SolutionFirst, note that it is sufficient to consider only two types of\r\nblocks of consecutive 0s and 1s: those of size and those of size greater\r\nthan . Based on this, we construct a new string of length , consisting\r\nof characters 1 and 2, representing the types of blocks. For example,\r\nfor the original string 00101110, the new string is 21121.Let s fix a\r\nvalue of the desired beauty of the substrings we are dividing the string\r\ninto. It is easy to see that there are possible values of (the number of\r\nsubstrings).Now, for a fixed pair , let be the set of indices such that\r\nit is possible to divide the prefix of the new string (representing\r\nblock types) into substrings of beauty . It is claimed that forms a\r\ncontinuous segment for some . Let s prove this by induction.Base case\r\n(). We set , (0-based indexing).Inductive step (). Suppose that for\r\nevery index , the first blocks can be divided into substrings of beauty\r\n. Then we can construct a valid division into substrings by: Simply\r\nappending a new substring of length starting at block , giving us a new\r\nupper bound at . Additionally, if block is of type , we can split it\r\nbetween the -th and -th substrings, allowing us to finish the -th\r\nsubstring earlier and start the -th within the same block. This enables\r\nus to reach as well. Thus, we conclude: if the -th block is of type 2.\r\nOtherwise, . To compute the full solution, we iterate over all values of\r\nfrom to . For each , we iterate over until the left bound of the\r\ncorresponding segment exceeds . The special case should be handled\r\nseparately.For each , we need to increment the answer for all positions\r\nfrom to by one. This can be efficiently done by recording the operations\r\nand and then applying a scanline technique to process the accumulated\r\nchanges.Since there are possible values of for each , the total\r\ncomplexity of this solution is .\r\n",
    "name": "F. Andryusha and CCB",
    "statement": "Let us define the of a binary string z as the number of indices i such\r\nthat 1\r\nle i < |z| and z_i\r\nneq z_{i+1}.While waiting for his friends from the CCB, Andryusha baked\r\na pie, represented by a binary string s of length n. To avoid offending\r\nanyone, he wants to divide this string into k substrings such that each\r\ndigit belongs to exactly one substring, and the beauties of all\r\nsubstrings are the same.Andryusha does not know the exact number of\r\nfriends from the CCB who will come to his house, so he wants to find the\r\nnumber of values of k for which it is possible to split the pie into\r\nexactly k parts with equal beauties.However, Andryushaâ€™s brother,\r\nTristan, decided that this formulation of the problem is too simple.\r\nTherefore, he wants you to find the number of such values of k . In\r\nother words, for each i from 1 to n, you need to find the number of\r\nvalues of k for which it is possible to split the prefix s_1 s_2\r\nldots s_i into exactly k parts with equal beauties.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "math",
        "number theory",
        "strings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Andryusha and CCB.json",
    "hint": [
        "Hint 1 It is sufficient to consider only two types of blocks of consecutive 0 s and 1 s: those of size and those of size greater than .",
        "Hint 2 For a fixed beauty value of a substring, there are possible values of , where is the number of blocks of consecutive 0 s and 1 s.",
        "Hint 3 For a fixed pair , let be the set of indices such that it is possible to divide the prefix of the string into substrings of beauty . It is claimed that forms a continuous segment for some ."
    ]
}