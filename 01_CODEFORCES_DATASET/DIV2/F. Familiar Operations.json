{
    "link": "https://codeforces.com//contest/1072/problem/F",
    "problemId": "240874",
    "problem_idx": "F",
    "shortId": "1072F",
    "contest_number": "1072",
    "problem_submissions": {
        "E": [
            44644399,
            44650543,
            44734034
        ],
        "D": [
            44632605,
            44632447,
            44632175,
            44637652,
            44635628,
            44637006,
            44633885,
            151267020,
            44638964,
            44635045,
            44638115,
            44637529,
            44637972,
            44638624,
            44636915,
            44640412,
            44642212,
            44637605,
            44638663,
            44639668,
            44680075,
            44642131
        ],
        "C": [
            44629439,
            44628133,
            44629672,
            44628147,
            44630750,
            44631571,
            44630332,
            44631317,
            44630520,
            44628174,
            44630246,
            44632020,
            44630576,
            44632772,
            44630621,
            44630463,
            44631591,
            44634217,
            44633521,
            44631795
        ],
        "B": [
            44628286,
            44626280,
            44627642,
            44625837,
            44627706,
            44628961,
            44626684,
            44627105,
            44628089,
            44633570,
            44627458,
            44628288,
            44627756,
            44630738,
            44627790,
            44627828,
            44631462,
            44628114,
            44627946,
            44628620
        ],
        "A": [
            44624145,
            44624123,
            44661469,
            44624742,
            44624134,
            44625024,
            44624914,
            44624126,
            44624358,
            44624143,
            44630174,
            44624249,
            44625453,
            44624220,
            44625169,
            44624173,
            44624200,
            44631557,
            44625268,
            44624520,
            44624259
        ],
        "F": [
            44725275
        ]
    },
    "name": "F. Familiar Operations",
    "statement": "You are given two positive integers a and b. There are two possible\r\noperations: multiply one of the numbers by some prime p; divide one of\r\nthe numbers on its prime factor p. What is the minimum number of\r\noperations required to obtain two integers having the same number of\r\ndivisors? You are given several such pairs, you need to find the answer\r\nfor each of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <unordered_map>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long unll;\ninline int read() {\n\tint f=1,sum=0;\n\tchar x=getchar();\n\tfor(;(x<'0'||x>'9');x=getchar()) if(x=='-') f=-1;\n\tfor(;x>='0'&&x<='9';x=getchar()) sum=sum*10+x-'0';\n\treturn f*sum;\n}\n\n#define M 3005\n#define mod 76543\n#define N 1000005\nbool vis[N];\nint sta[M],zt[N];\nint A[M],dis[M][M];\nint cnt,a[M][10],f[M],s[N],g[N][10];\nint x_[10]={0,2,3,5,7,11,13,17,19};\n\nunordered_map <unll,int> st;\n\ninline void max(int &x,int y) {if(x<y) x=y;}\ninline void min(int &x,int y) {if(x>y) x=y;}\n\ninline void dfs(int x,int d,ll sum) {\n\tif(x==9) {\n\t\tf[++cnt]=d;\n\t\tfor1(0,8,i) a[cnt][i]=sta[i];\n\t\tunll t=0;\n\t\tfor1(1,8,i) if(sta[i]) t=t*mod+sta[i];\n\t\tst[t]=cnt;\n\t\treturn;\n\t}\n\t\n\tfor1(0,sta[x-1],i) {\n\t\tsta[x]=i;\n\t\tdfs(x+1,d*(i+1),sum);\n\t\tsum*=x_[x];\n\t\tif(sum>200000000) break;\n\t}\n}\n\ninline int get_(int x) {\n\tint now=x;\n\tint b[10]={0};\n\tfor1(1,s[x],i) {\n\t\tint y=g[x][i];\n\t\twhile (!(now%y)) now/=y,++b[i];\n\t}\n\tsort(b+1,b+s[x]+1);\n\t\n\tunll t=0;\n\tFOR2(s[x],1,i) t=t*mod+b[i];\n\treturn st[t];\n}\n\nint main () {\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tsta[0]=30;\n\tdfs(1,1,1);\n\t\n\tmemset(dis,0x3f,sizeof(dis));\n\tfor1(1,cnt,i) dis[i][i]=0;\n\tfor1(1,cnt,i) {\n\t\tfor1(1,8,j) {\n\t\t\tif(a[i][j]+1>a[i][j-1]) continue;\n\t\t\tunll x=0;\n\t\t\t++a[i][j];\n\t\t\tfor1(1,8,k) if(a[i][k]) x=x*mod+a[i][k];\n\t\t\t--a[i][j];\n\t\t\tif(st.count(x)) {\n\t\t\t\tint t=st[x];\n\t\t\t\tdis[i][t]=dis[t][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor1(1,cnt,i) \n\t\tfor1(1,cnt,j) if(dis[j][i]<100) \n\t\t\tfor1(1,cnt,k) if(dis[i][k]<100) \n\t\t\t\tmin(dis[j][k],dis[j][i]+dis[i][k]);\n\t\n\tfor1(1,cnt,i) {\n\t\tfor1(1,cnt,j) A[j]=dis[i][j],dis[i][j]=1e9;\n\t\tfor1(1,cnt,j) min(dis[i][f[j]],A[j]);\n\t}\n\t\n\tfor1(2,N-5,i) {\n\t\tif(s[i]) continue;\n\t\tint x=i;\n\t\twhile (x+4<N) g[x][++s[x]]=i,x+=i;\n\t}\n\t\n\t\n\tint size=0;\n\tfor1(1,cnt,i) if(!vis[f[i]]) vis[f[i]]=1,zt[++size]=f[i];\n\t\n\tint Test_=read();\n\twhile (Test_--) {\n\t\tint x=read(),y=read();\n\t\tx=get_(x),y=get_(y);\n\t\tint ans=1e9;\n\t\tfor1(1,size,i) min(ans,dis[x][zt[i]]+dis[y][zt[i]]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Familiar Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/62612",
    "editorial": "Note that if a=?i=1kpxii\n then d(a)=?i=1k(xi+1)\n. This implies that we can map a\n to vector (x1,x2,,xk)\n, where x1?x2??xk\n, because the order of the powers doesn't matter. The operations correspond to adding 1 to some item or appending 1 to the end of the vector or decreasing 1 from some item and sorting the vector after that, erasing zeros. There are only 289 different such vectors for numbers up to 106\n, so we need to calculate only 41616 distances.\n\nThe first thought could be to just run Floyd-Warshall algorithm on these 289 vertices, which would fit in time. After that for each pair (x,d)\n we can find the minimum number of operations needed to make with vector x\n so that the generated number has d\n divisors. To find the answer for (x,y)\n, we could simply iterate over all possible values of d\n. But there are some tricky cases. For example, for numbers 219\n and 2236\n the answer is 1, because after multiplying the first number by 2 both numbers have 21 divisors. But the number 220>106\n, and the vector (20)\n is not among these 289 vertices. So, we need to consider some other vectors too.\n\nAnyway, let's run this algorithm to see what could be the maximal distance between the two numbers up to 106\n. It turns out that in 10 operations any two numbers can be led to have the same number of divisors when all numbers in the path don't exceed 106\n too.\n\nThis means that each possible number in the optimal path satisfies ?i=1kxi<30\n, because for the numbers in the input this sum doesn't exceed 19, and there can be no more than 10 operations with each number. This condition gives us all vectors of powers necessary to consider as middle points for the pairs which can be in the input. There are 28629 such vectors. Now we run 289 bfs instances on the generated graph with the start in each possible vector from the input and build the same data structure for pairs (x,d)\n as explained before, which allows us to find the answers for all vectors of numbers up to 106\n.\n\nThis solution works in 2.5s on cf servers, which is still too slow. But the thing is that we found answers for all pairs of the vectors from the input. So we can try to get rid of some unnecessary vertices and simply check if the sum of answers is unchanged. One of the possible speedups is to consider only vectors generating the number of divisors not more than some reasonable number. The maximum number of divisors of some necessary vector is 288, so magic constants like 300 or more will work. Another possible speedup is to decrease the border on the sum of powers from 30 to 22, which is precise.",
    "hint": []
}