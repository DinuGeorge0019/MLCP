{"link": "https://codeforces.com//contest/281/problem/D", "problemId": "2723", "problem_idx": "D", "shortId": "281D", "contest_number": "281", "problem_submissions": {"E": [3283483, 3280513, 83186797, 3282100, 3282867], "D": [3280737, 3280273, 3278003, 3278968, 3282200, 3280660, 3279694, 3281443, 3282246, 3283008, 3283922, 3282844, 3283697], "C": [3278293, 3277396, 3284012, 3281377, 3283186], "B": [3276309, 3278090, 3276072, 3277223, 3286976, 3276173, 3276703, 3277506, 3276168, 3280432, 3280316, 3277025, 3276467, 3417552, 3277388, 3276638, 3287354], "A": [3274463, 3274325, 3274769, 3275162, 3274438, 3274688, 3274803, 3274521, 3274569, 3274437, 3279688, 3274972, 3274371, 3275776, 3274400, 3276374]}, "name": "D. Maximum Xor Secondary", "statement": "Bike loves looking for the second maximum element in the sequence. The\r\nsecond maximum element in the sequence of distinct numbers is such\r\nmaximum element , that the following inequality holds: .The lucky number\r\nof the sequence of distinct positive integers is the number that is\r\nequal to the bitwise excluding OR of the maximum element of the sequence\r\nand the second maximum element of the sequence.You\u2019ve got a sequence of\r\ndistinct positive integers . Let\u2019s denote sequence as . Your task is to\r\nfind the maximum number among all lucky numbers of sequences .Note that\r\nas all numbers in sequence are distinct, all the given definitions make\r\nsence.\r\n", "solutions": ["#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nint n, v[100100], maior[100100];\npair <int, int> pilha[100100];\nint topo;\n\nint calcula() {\n\tint resp = 0;\n\n\tint aux = v[0], id = 0;\n\tmaior[0] = -1;\n\ttopo = 0;\n\tpilha[topo++] = mp(v[0], 0);\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (topo > 0 && v[i] > pilha[topo-1].first) topo--;\n\t\n\t\tif (topo == 0) maior[i] = -1;\n\t\telse maior[i] = pilha[topo-1].second;\n\t\tpilha[topo++] = mp(v[i], i);\n\t}\n\t//for (int i = 0; i < n; i++) printf(\"%d \", maior[i]); printf(\"\\n\");\n\tfor (int i = 1; i < n; i++) if (maior[i] != -1) resp = max(resp, v[i]^v[maior[i]]);\n\t\n\treturn resp;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &v[i]);\n\tint resp = calcula();\n\treverse(v, v+n);\n\tresp = max(resp, calcula());\n\t\n\t\n\t/*int ans = 0;\n\tfor (int i = 0; i < n-1; i++) for (int j = i+1; j < n; j++) {\n\t\tint f = 0, id, s = 0;\t\n\t\tfor (int k = i; k <= j; k++)\n\t\t\tif (v[k] > f) {\t\tf = v[k]; id = k; } \n\t\n\t\tfor (int k = i; k <= j; k++)\n\t\t\tif (v[k] > s && (v[k] != f || k != id)) s = v[k];\n\t\t\t\n\t\tans = max(ans, f^s);\n\t}\n\tcout << ans << ' ' ;*/\n\tcout << resp << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["two pointers"], "dificulty": "1800", "interactive": false}