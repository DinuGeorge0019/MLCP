{"link": "https://codeforces.com//contest/707/problem/D", "problemId": "68578", "problem_idx": "D", "shortId": "707D", "contest_number": "707", "problem_submissions": {"E": [19999638, 20000220, 19999902, 20004459, 20001527, 20000267, 20003187, 19998436, 19997562, 20002961, 20002001], "D": [19992217, 19995484, 19994755, 19992826, 19997136, 19993596, 20006942, 19997119, 20013037, 19993142, 19995313, 19999894, 19997617, 19996425, 19998702, 19999735, 21372182, 21371999, 19995598], "C": [19989680, 19991341, 19989052, 19995374, 20002471, 19987427, 19991851, 19986782, 19987642, 20012707, 19989756, 19990354, 19991429, 19991374, 19994085, 19991752, 19991441], "B": [19985922, 19986558, 19987945, 19996933, 19986674, 19984891, 20010196, 19984984, 19989212, 19987604, 19990363, 19989764, 19987808, 19989404, 19988496, 19990285, 19987180, 19991247], "A": [19982567, 19982966, 19983593, 19982522, 19982389, 19984792, 19998325, 19995326, 19993243, 19983627, 19985898, 19982933, 19984161, 19983215, 19983795]}, "name": "D. Persistent Bookcase ", "statement": "Recently in school Alina has learned what are the : they are data\r\nstructures that always preserves the previous version of itself and\r\naccess to it when it is modified.After reaching home Alina decided to\r\ninvent her own persistent data structure. Inventing didn\u2019t take long:\r\nthere is a bookcase right behind her bed. Alina thinks that the bookcase\r\nis a good choice for a persistent data structure. Initially the bookcase\r\nis empty, thus there is no book at any position at any shelf.The\r\nbookcase consists of shelves, and each shelf has exactly positions for\r\nbooks at it. Alina enumerates shelves by integers from to and positions\r\nat shelves from to . Initially the bookcase is empty, thus there is no\r\nbook at any position at any shelf in it.Alina wrote down operations,\r\nwhich will be consecutively applied to the bookcase. Each of the\r\noperations has one of four types: Place a book at position at shelf if\r\nthere is no book at it. Remove the book from position at shelf if there\r\nis a book at it. Invert book placing at shelf . This means that from\r\nevery position at shelf which has a book at it, the book should be\r\nremoved, and at every position at shelf which has not book at it, a book\r\nshould be placed. Return the books in the bookcase in a state they were\r\nafter applying -th operation. In particular, means that the bookcase\r\nshould be in initial state, thus every book in the bookcase should be\r\nremoved from its position.After applying each of operation Alina is\r\ninterested in the number of books in the bookcase. Alina got \u2019A\u2019 in the\r\nschool and had no problem finding this values. Will you do so?\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\nconst int maxn = 1005,maxm = 100005;\n\nstruct Quer\n{\n\tint type,i,j,ans,ok;\n}Q[100005];\n\nvector<int> lk[100005];\nbitset<maxn> f[maxn],all;\nint n,m,q,final[maxm],next[maxm],co[maxn],total;\n\nvoid link(int u,int v)\n{\n\tnext[v] = final[u],final[u] = v;\n}\n\nvoid Apply(int now)\n{\n\tint ty = Q[now].type,i = Q[now].i,j = Q[now].j;\n\tif (!ty || ty == 4) return;\n\tif (ty == 1)\n\t{\n\t\ttotal -= f[i].count();\n\t\tif (!f[i][j]) f[i][j] = 1,Q[now].ok = 1;\n\t\ttotal += f[i].count();\n\t} else\n\tif (ty == 2)\n\t{\n\t\ttotal -= f[i].count();\n\t\tif (f[i][j]) f[i][j] = 0,Q[now].ok = 1;\n\t\ttotal += f[i].count();\n\t} else\n\t{\n\t\ttotal -= f[i].count();\n\t\tf[i] ^= all;\n\t\ttotal += f[i].count();\n\t}\n}\n\nvoid Roll(int now)\n{\n\tint ty = Q[now].type,i = Q[now].i,j = Q[now].j;\n\tif (!ty || ty == 4) return;\n\tif (ty == 1)\n\t{\n\t\ttotal -= f[i].count();\n\t\tif (Q[now].ok) f[i][j] = 0,Q[now].ok = 1;\n\t\ttotal += f[i].count();\n\t} else\n\tif (ty == 2)\n\t{\n\t\ttotal -= f[i].count();\n\t\tif (Q[now].ok) f[i][j] = 1,Q[now].ok = 1;\n\t\ttotal += f[i].count();\n\t} else\n\t{\n\t\ttotal -= f[i].count();\n\t\tf[i] ^= all;\n\t\ttotal += f[i].count();\n\t}\n}\n\nvoid dfs(int now)\n{\n\tApply(now);\n\tQ[now].ans = total;\n\tfor(int i = final[now];i;i = next[i]) dfs(i);\n\tRoll(now);\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\tfor(int i = 1;i <= m;i ++) all[i] = 1;\n\tfor(int i = 1;i <= q;i ++)\n\t{\n\t\tscanf(\"%d%d\", &Q[i].type, &Q[i].i);\n\t\tif (Q[i].type < 3) scanf(\"%d\", &Q[i].j);\n\t\tif (Q[i].type == 4) link(Q[i].i,i); else\n\t\t\tlink(i - 1,i);\t\t\n\t}\n\tdfs(0);\n\tfor(int i = 1;i <= q;i ++)\n\t\tprintf(\"%d\\n\", Q[i].ans);\n}\t\n"], "input": "", "output": "", "tags": ["bitmasks", "data structures", "dfs and similar", "implementation"], "dificulty": "2200", "interactive": false}