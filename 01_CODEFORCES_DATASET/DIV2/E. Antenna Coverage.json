{
    "link": "https://codeforces.com//contest/1253/problem/E",
    "problemId": "472862",
    "problem_idx": "E",
    "shortId": "1253E",
    "contest_number": "1253",
    "problem_submissions": {
        "F": [
            65199103,
            65190951,
            65202217,
            65200176,
            65205791,
            65198288,
            65206369,
            65202224,
            65204185,
            65198880,
            71343526,
            65209779,
            69242445
        ],
        "E": [
            65190374,
            65200198,
            65189404,
            65179572,
            65189474,
            65203687,
            65210511,
            65176917,
            65203722,
            65186844,
            65188534,
            65195069,
            65199233,
            65190702,
            65194167,
            65189184,
            65189079,
            65566785,
            65194999,
            65197237
        ],
        "D": [
            65185415,
            65178485,
            65180601,
            65183049,
            65178022,
            65187686,
            65195445,
            65178632,
            65179619,
            65180170,
            65183967,
            65181658,
            65188561,
            65181701,
            65182069,
            65187758,
            65183529,
            65182372,
            65181324
        ],
        "C": [
            65180957,
            65172664,
            65176866,
            65185425,
            65173509,
            65180180,
            65194567,
            65173458,
            65200178,
            65176131,
            65179441,
            65175878,
            65184305,
            65178007,
            65179468,
            65178975,
            65179727,
            65177898,
            65176250
        ],
        "B": [
            65175476,
            65202574,
            65174599,
            65188764,
            65185456,
            65176094,
            65186553,
            65183630,
            65196117,
            65172495,
            65173857,
            65173178,
            65174792,
            65174898,
            65174679,
            65176409,
            65176161,
            65176165,
            65172853
        ],
        "A": [
            65171088,
            65170116,
            65170656,
            65190482,
            65180567,
            65170231,
            65180099,
            65170284,
            65170843,
            65169770,
            65169894,
            65169914,
            65170943,
            65169881,
            65172675,
            65172008,
            65171211,
            65169945,
            65169720
        ]
    },
    "name": "E. Antenna Coverage",
    "statement": "The mayor of the Central Town wants to modernize Central Street,\r\nrepresented in this problem by the (Ox) axis.On this street, there are n\r\nantennas, numbered from 1 to n. The i-th antenna lies on the position\r\nx_i and has an initial scope of s_i: it covers all integer positions\r\ninside the interval [x_i - s_i; x_i + s_i].It is possible to increment\r\nthe scope of any antenna by 1, this operation costs 1 coin. We can do\r\nthis operation as much as we want (multiple times on the same antenna if\r\nwe want).To modernize the street, we need to make all positions from 1\r\nto m inclusive covered by one antenna. Note that it is authorized to\r\ncover positions outside [1; m], even if it\u2019s not required.What is the\r\nminimum amount of coins needed to achieve this modernization?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n\nint n,m;\nint X[105], S[105];\nint dp[100005][85];\nvector < int > id;\n\nbool cmp( int a, int b ){\n\tif ( X[a] - S[a] == X[b] - S[b] ){\n\t\treturn X[a] + S[a] < X[b] + S[b];\n\t}\n\treturn X[a] - S[a] < X[b] - S[b];\n}\n\nint f( int pos, int i ){\n\t// printf(\"%d %d\\n\", pos, i);\n\tif ( pos > m ){\n\t\treturn 0;\n\t}\n\tif ( i == n ){\n\t\treturn m - pos + 1;\n\t}\n\tint &ans = dp[pos][i];\n\tif ( ans != -1 ) return ans;\n\tans = 1e9;\n\tans = min( ans, f(pos,i+1) );\n\tint x = X[id[i]], s = S[id[i]];\n\tif ( x - s <= pos ){\n\t\tans = min( ans, f(x+s+1,i+1));\n\t} else {\n\t\tint s2 = x - s - pos;\n\t\tans = min( ans, f(x + s2 + s+1, i + 1) + s2);\n\t}\n\treturn ans;\n}\n\nint main(){\n\n\n\tscanf(\"%d%d\",&n,&m);\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tscanf(\"%d%d\",&X[i],&S[i]);\n\t\tid.push_back(i);\n\t}\n\tsort(id.begin(),id.end(),cmp);\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\",f(1,0));\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Antenna Coverage.json",
    "editorial_link": "https://codeforces.com//blog/entry/71489?locale=en",
    "editorial": "We can add an antenna . It will not modifiy the answer, because it would\r\nbe non-optimal to increase the scope of this antenna.Let be the minimum\r\ncost to cover all positions from to inclusive, knowing that position is\r\ncovered. We compute in decreasing order of .Base case is .The default\r\ntransition is .If position is initially covered, Otherwise, let\u00e2\u0080\u0099s\r\nconsider all antennas and their initial intervals . If , let , then a\r\npossible transition is .We take the minimum of all these transitions.\r\nNote that we always extend intervals as less as possible, but it\u00e2\u0080\u0099s\r\noptimal because : If after using this interval , we use another interval\r\n(at the right of ), the time spent to extend could have been used to\r\nextend instead, which will be more optimal. If was the last interval\r\nused, we don\u00e2\u0080\u0099t care because the default transition will take care of\r\nthis case. The final answer will be .There are states and transitions,\r\nhence final complexity is with very low constant. can also get AC\r\nbecause of very low constant.Implementation\r\n"
}