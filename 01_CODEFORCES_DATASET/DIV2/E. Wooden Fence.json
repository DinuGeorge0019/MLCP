{"link": "https://codeforces.com//contest/182/problem/E", "problemId": "1270", "problem_idx": "E", "shortId": "182E", "contest_number": "182", "problem_submissions": {"C": [1663733, 1663728, 1623940, 1623119, 1624114, 1624504, 1624399, 1622980, 1643406, 10562948], "E": [1624193, 1623067, 1622067, 1624242, 1623079, 1622816, 1625915, 1622385, 1624996, 1622444, 1622634], "D": [1623370, 1620768, 1625829, 1625101, 1620935, 1627627, 1625879, 1620500, 1624702, 1623228, 1623926, 1620648, 1625035, 1621025, 1621358], "B": [1622937, 1621227, 1620887, 1620496, 1621242, 1620438, 1620699, 1620796, 1623576, 1623718, 1620257, 1623264, 1620331, 1620463], "A": [1622661, 1624396, 1623052, 1628460, 1622766, 1623550, 1622930]}, "name": "E. Wooden Fence", "statement": "Vasya has recently bought some land and decided to surround it with a\r\nwooden fence.He went to a company called \"Wooden board\" that produces\r\nwooden boards for fences. Vasya read in the catalog of products that the\r\ncompany has at its disposal different types of wood. The company uses\r\nthe -th type of wood to produce a board of this type that is a\r\nrectangular by block.Vasya decided to order boards in this company and\r\nbuild a fence from them. It turned out that the storehouse of the\r\ncompany is so large that Vasya can order arbitrary number of boards of\r\nevery type. Note that Vasya is allowed to the boards as he builds the\r\nfence. Vasya is required to construct a fence of length , however, an\r\narbitrary fence won\u2019t do. Vasya wants his fence to look beautiful. We\u2019ll\r\nsay that a fence is if and only if the following two conditions are\r\nfulfilled: two successive boards of the same type the first board of the\r\nfence has an arbitrary length, and the of each subsequent board equals\r\nthe of the previous one In other words, the fence is considered\r\nbeautiful, if the type of the -th board in the fence is different from\r\nthe -th board\u2019s type; besides, the -th board\u2019s length is equal to the\r\n-th board\u2019s width (for all , starting from 2).Now Vasya wonders, how\r\nmany variants of arranging a fence for his land exist. Your task is to\r\ncount the number of different beautiful fences of length . Since the\r\nsought number can be large enough, you need to calculate the answer\r\nmodulo .\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\nint main(void)\n{\n    int md = 1000000007, n, l, len, i, j, a[200], b[200];\n    cin >> n >> len;\n    fo(i,n)\n        {\n            cin >> a[i] >> b[i];\n        }\n    \n    ll d[3010][110][2];\n    memset(d, 0, sizeof(d));\n    \n    for(l=1;l<=len;l++)\n        {\n            fo(i, n)\n                {\n                    //cout << l << \" \" << a[i] << \" \" << b[i] << endl;\n                    if (l == a[i])\n                        {\n                            d[l][i][0] = 1;\n                        }\n                    if (l == b[i] && a[i] != b[i])\n                        {\n                            d[l][i][1] = 1;\n                        }\n                    if (l - a[i] > 0)\n                        {\n                            fo(j,n) if (j != i)                        \n                                {\n                                    if (a[j] == a[i])\n                                        d[l][i][0] += d[l - a[i]][j][1];\n                                    if (b[j] == a[i])\n                                        d[l][i][0] += d[l - a[i]][j][0];                                    \n                                }\n                        }\n                    if (l - b[i] > 0 && a[i] != b[i])\n                        {\n                            fo(j,n) if (j != i)                        \n                                {\n                                    if (a[j] == b[i])\n                                        d[l][i][1] += d[l - b[i]][j][1];\n                                    if (b[j] == b[i])\n                                        d[l][i][1] += d[l - b[i]][j][0];\n                                }\n                        }\n                    d[l][i][0] %= md;\n                    d[l][i][1] %= md;\n                }\n        }\n\n    ll ans = 0;\n    fo(i,n)\n        {\n            ans += d[len][i][0];\n            ans += d[len][i][1];\n            ans %= md;\n        }\n    cout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "1800", "interactive": false}