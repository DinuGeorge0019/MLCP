{"link": "https://codeforces.com//contest/721/problem/C", "problemId": "73869", "problem_idx": "C", "shortId": "721C", "contest_number": "721", "problem_submissions": {"E": [21042234, 21104290, 21041800, 21039130, 21182080], "D": [21029644, 21033019, 21030262, 21053351, 21030654, 21028935, 21032532, 21032446, 21031468, 21029821, 21033557, 21036571, 21034746, 21031908, 21028774, 21033067, 21034309, 21035655, 21033370, 21035759], "C": [21024340, 21029695, 21023653, 21025311, 21023065, 21023920, 21023708, 21027694, 21026337, 21025612, 21024290, 21025832, 21026823, 21026753, 21033393, 21026369, 21027659, 21024234, 21028054, 21028402], "B": [21020547, 21023831, 21019117, 21020848, 21020236, 21018793, 21019630, 21018806, 21021097, 21020368, 21019611, 21018664, 21023267, 21021687, 21020531, 21019677, 21021078, 21019653, 21021642, 21022060], "A": [21016747, 21016854, 21016383, 21017669, 21020192, 21016357, 21016892, 21016594, 21016893, 21016724, 21016524, 21016663, 21017641, 21017121, 21017001, 21016623, 21017723, 21016907, 21017349, 21018497]}, "name": "C. Journey", "statement": "Recently Irina arrived to one of the most famous cities of Berland the\r\nBerlatov city. There are showplaces in the city, numbered from to , and\r\nsome of them are connected by one-directional roads. The roads in\r\nBerlatov are designed in a way such that there cyclic routes between\r\nshowplaces.Initially Irina stands at the showplace , and the endpoint of\r\nher journey is the showplace . Naturally, Irina wants to visit as much\r\nshowplaces as she can during her journey. However, Irina\u2019s stay in\r\nBerlatov is limited and she can\u2019t be there for more than time units.Help\r\nIrina determine how many showplaces she may visit during her journey\r\nfrom showplace to showplace within a time not exceeding . It is\r\nguaranteed that there is at least one route from showplace to showplace\r\nsuch that Irina will spend no more than time units passing it.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define N 5005\nusing namespace std;\n\nint d[N][N],pre[N][N],tot,fst[N],nxt[N],pnt[N],len[N],n,m,t; bool vis[N];\nvoid add(int x,int y,int z){pnt[++tot]=y;len[tot]=z;nxt[tot]=fst[x];fst[x]=tot;}\nvoid dp(int x){\n\tint i,j,y;\n\tif (vis[x]) return; vis[x]=1;\n\t\tif (x==1) d[x][1]=0;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];dp(y);\n\t\tfor (j=1; j<=n; j++)\n\t\t\tif (d[y][j-1]+len[i]<d[x][j]){\n\t\t\t\td[x][j]=d[y][j-1]+len[i]; pre[x][j]=y;\n\t\t\t}\n\t}\n}\nvoid solve(int x,int y){\n\tif (y>1) solve(pre[x][y],y-1);printf(\"%d \",x);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tint i,x,y,z;\n\tfor (i=1; i<=m; i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadd(y,x,z);\n\t}\n\tmemset(d,0x3f,sizeof(d));\n\t//cout<<d[0][0]<<endl;\n\tdp(n);\n\tfor (i=n; i; i--) if (d[n][i]<=t) break;\n\t//\tcout<<d[n][i]<<endl;\n\tprintf(\"%d\\n\",i);\n\tsolve(n,i);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "graphs"], "dificulty": "1800", "interactive": false}