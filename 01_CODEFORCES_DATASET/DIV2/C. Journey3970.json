{
    "link": "https://codeforces.com//contest/721/problem/C",
    "problemId": "73869",
    "problem_idx": "C",
    "shortId": "721C",
    "contest_number": "721",
    "problem_submissions": {
        "E": [
            21042234,
            21104290,
            21041800,
            21039130,
            21182080
        ],
        "D": [
            21029644,
            21033019,
            21030262,
            21053351,
            21030654,
            21028935,
            21032532,
            21032446,
            21031468,
            21029821,
            21033557,
            21036571,
            21034746,
            21031908,
            21028774,
            21033067,
            21034309,
            21035655,
            21033370,
            21035759
        ],
        "C": [
            21024340,
            21029695,
            21023653,
            21025311,
            21023065,
            21023920,
            21023708,
            21027694,
            21026337,
            21025612,
            21024290,
            21025832,
            21026823,
            21026753,
            21033393,
            21026369,
            21027659,
            21024234,
            21028054,
            21028402
        ],
        "B": [
            21020547,
            21023831,
            21019117,
            21020848,
            21020236,
            21018793,
            21019630,
            21018806,
            21021097,
            21020368,
            21019611,
            21018664,
            21023267,
            21021687,
            21020531,
            21019677,
            21021078,
            21019653,
            21021642,
            21022060
        ],
        "A": [
            21016747,
            21016854,
            21016383,
            21017669,
            21020192,
            21016357,
            21016892,
            21016594,
            21016893,
            21016724,
            21016524,
            21016663,
            21017641,
            21017121,
            21017001,
            21016623,
            21017723,
            21016907,
            21017349,
            21018497
        ]
    },
    "name": "C. Journey",
    "statement": "Recently Irina arrived to one of the most famous cities of Berland the\r\nBerlatov city. There are showplaces in the city, numbered from to , and\r\nsome of them are connected by one-directional roads. The roads in\r\nBerlatov are designed in a way such that there cyclic routes between\r\nshowplaces.Initially Irina stands at the showplace , and the endpoint of\r\nher journey is the showplace . Naturally, Irina wants to visit as much\r\nshowplaces as she can during her journey. However, Irina’s stay in\r\nBerlatov is limited and she can’t be there for more than time units.Help\r\nIrina determine how many showplaces she may visit during her journey\r\nfrom showplace to showplace within a time not exceeding . It is\r\nguaranteed that there is at least one route from showplace to showplace\r\nsuch that Irina will spend no more than time units passing it.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 5005\nusing namespace std;\n\nint d[N][N],pre[N][N],tot,fst[N],nxt[N],pnt[N],len[N],n,m,t; bool vis[N];\nvoid add(int x,int y,int z){pnt[++tot]=y;len[tot]=z;nxt[tot]=fst[x];fst[x]=tot;}\nvoid dp(int x){\n\tint i,j,y;\n\tif (vis[x]) return; vis[x]=1;\n\t\tif (x==1) d[x][1]=0;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];dp(y);\n\t\tfor (j=1; j<=n; j++)\n\t\t\tif (d[y][j-1]+len[i]<d[x][j]){\n\t\t\t\td[x][j]=d[y][j-1]+len[i]; pre[x][j]=y;\n\t\t\t}\n\t}\n}\nvoid solve(int x,int y){\n\tif (y>1) solve(pre[x][y],y-1);printf(\"%d \",x);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tint i,x,y,z;\n\tfor (i=1; i<=m; i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadd(y,x,z);\n\t}\n\tmemset(d,0x3f,sizeof(d));\n\t//cout<<d[0][0]<<endl;\n\tdp(n);\n\tfor (i=n; i; i--) if (d[n][i]<=t) break;\n\t//\tcout<<d[n][i]<<endl;\n\tprintf(\"%d\\n\",i);\n\tsolve(n,i);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Journey3970.json",
    "editorial_link": "https://codeforces.com//blog/entry/47457",
    "editorial": "Authorâs solution uses dynamic programming. Let be the minimum time\r\nrequired to arrive at the vertex , if we visit vertices (including\r\nvertices and ). We have a DAG (directed acyclic graph), so we can\r\ncompute it recursively (and memory constraints were a bit strict in this\r\nproblem, so itâs better to use recursion to compute it). Letâs store the\r\ntransposed version of the graph: if we had an edge () in the input, we\r\nwill store (). Then our function , which will compute the answer for ,\r\nwill be like that: the base of dynamic programming is , all other states\r\nare equal to -1 . If we call , then it will work like that: if the state\r\nwe want to compute is incorrect (), we return a very large integer\r\nnumber (any number that is greater than , because ). If the answer for\r\nthis state has already been calculated, then we return (it is easy do\r\ndetermine: if , then it has already been calculated). Else we begin to\r\ncalculate the state. Firstly, letâs put (a number greater than ) into .\r\nThen look at all the edges beginning in and try to update with the value\r\nof ( is the vertex at the endpoint of current edge, is the weight of\r\nthis edge). If this value is less than , then we update and store the\r\ninformation that our last update in was from the vertex . If we try to\r\ngo by path which doesnât end in the vertex , then we get a value which\r\nis greater than , thatâs because that the only value we didnât denote as\r\nis . So, now we have our function, letâs compute the answer. We will\r\niterate on the number of vertices in the path from to in descending\r\norder, and if , then we have found the answer, now we iterate on the\r\nparent vertices we stored while calculating our , until we come to\r\nvertex (itâs important because some participants sent solutions that\r\ncontinued even past vertex !) and print the answer.Time complexity of\r\nthis solution , and mempry complexity .\r\n",
    "hint": []
}