{
    "link": "https://codeforces.com//contest/228/problem/E",
    "problemId": "1859",
    "problem_idx": "E",
    "shortId": "228E",
    "contest_number": "228",
    "problem_submissions": {
        "D": [
            2261902,
            2260756,
            2262084,
            2263037,
            2262295,
            2262513,
            2267122
        ],
        "E": [
            2260963,
            2258057,
            2257897,
            2258974,
            2259887,
            2261215,
            2260752,
            2260117,
            2260870,
            2262062,
            2262069,
            2259543,
            2261908,
            2259655,
            2259999,
            2259991,
            2260321,
            2260196,
            2260295
        ],
        "C": [
            2260163,
            2263333,
            2260878,
            2261707,
            2259668,
            2261949,
            2262461,
            2260423,
            2262627,
            2261069,
            2261515,
            2272185
        ],
        "B": [
            2257986,
            2258545,
            2258475,
            2257641,
            2258627,
            2257501,
            2258104,
            2259075,
            2257831,
            2258346,
            2258655,
            2258262,
            2258816,
            2257667,
            2258656,
            2258407,
            2259171,
            2258869
        ],
        "A": [
            2256975,
            2258646,
            2256552,
            2256842,
            2256376,
            2256560,
            2257820,
            2256816,
            2256677,
            2257146,
            2256648,
            2257004,
            2256374,
            2256749,
            2256802,
            2257128,
            2257247,
            2257318
        ]
    },
    "name": "E. The Road to Berland is Paved With Good Intentions",
    "statement": "Berland has cities, some of them are connected by bidirectional roads.\r\nFor each road we know whether it is asphalted or not.The King of Berland\r\nValera II wants to asphalt all roads of Berland, for that he gathered a\r\ngroup of workers. Every day Valera chooses exactly one city and orders\r\nthe crew to asphalt all roads that come from the city. The valiant crew\r\nfulfilled the King\u2019s order in a day, then workers went\r\nhome.Unfortunately, not everything is as great as Valera II would like.\r\nThe main part of the group were gastarbeiters illegal immigrants who are\r\nenthusiastic but not exactly good at understanding orders in Berlandian.\r\nTherefore, having received orders to asphalt the roads coming from some\r\nof the city, the group asphalted all non-asphalted roads coming from the\r\ncity, and vice versa, took the asphalt from the roads that had it.Upon\r\nlearning of this progress, Valera II was very upset, but since it was\r\ntoo late to change anything, he asked you to make a program that\r\ndetermines whether you can in some way asphalt Berlandian roads in at\r\nmost days. Help the king.\r\n",
    "solutions": [
        "// AntiFate\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define fab(i,a,b) for(int i=(a);i<=(b);++i)\n#define fba(i,b,a) for(int i=(b);i>=(a);--i)\n#define clr(a) memset(a,0,sizeof(a))\n#define fec(i,a) for(__typeof((a).end())i=(a).begin();i!=(a).end();++i)\n#define fpc(i,j,v) for(int i=a[v],j;j=to[i],i;i=nx[i])\n\n#define N 111\n\nint f[N], g[N];\n\nint fd(int x)\n{\n    int y = x, z = 0;\n    while (f[x])\n    {\n        z ^= g[x];\n        x = f[x];\n    }\n    while (f[y])\n    {\n        int t = g[y];\n        g[y] = z;\n        z ^= t;\n        t = y;\n        y = f[y];\n        f[t] = x;\n    }\n    return x;\n}\n\nint n, m;\nint main()\n{\n    scanf(\"%d%d\\n\", &n, &m);\n\n    rep(i,m)\n    {\n        int x,y,z, xx, yy;\n        scanf(\"%d%d%d\", &x, &y, &z);\n        z = !z;\n\n        xx = fd(x);\n        yy = fd(y);\n\n        z ^= g[x];\n        z ^= g[y];\n        \n//cerr<<xx<<\" \"<<yy<<endl;\n\n        if (xx==yy && z)\n        {\n            puts(\"Impossible\");\n            return 0;\n        }\n        if (xx != yy)\n        {\n            f[xx] = yy;\n            g[xx] = z;\n        }\n/*\n        fab(i,1,n)\n        cerr<<i<<\":\"<<f[i]<<\",\"<<g[i]<<endl;*/\n\n    }\n    \n    vector<int> s;\n    fab(i,1,n)\n    {\n        fd(i);\n        if (g[i]) s.push_back(i);\n    }\n\n    printf(\"%d\\n\", s.size());\n    fec(i,s)\n        printf(\"%d%s\", *i, i+1==s.end()?\"\\n\":\" \");\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Road to Berland is Paved With Good Intentions.json",
    "editorial_link": "https://codeforces.com//blog/entry/5404",
    "editorial": "This problem can be solved in different ways. It was expected the\r\nsolution that solved the system of modular equations using Gauss\r\nalgorithm. Here is another simple solution. The vertices from the result\r\ncall switched-on. Firstly, note that every vertex should be switched-on\r\nno more than once. Then, consider every edge of color . We want to make\r\nits color . So, if we should switch on vertices and or don t switch them\r\non simultaneously. If we should switch on or . So, consider some vertex\r\nand try to switch it on or not. Thus, we can uniquely determine the\r\nstate of every vertex of the same connected component as . If we face\r\nsome collision, we can t get the solution, you should print Impossible.\r\nThe solution can be realized using bfs with complexity .\r\n"
}