{
    "link": "https://codeforces.com//contest/1243/problem/A",
    "problemId": "461411",
    "problem_idx": "A",
    "shortId": "1243A",
    "contest_number": "1243",
    "problem_submissions": {
        "E": [
            64413060,
            64469730,
            64408846,
            64417229,
            64399200,
            64470547,
            64416699,
            64442944
        ],
        "D": [
            64391286,
            64397713,
            64431742,
            64397869,
            64387912,
            64386733,
            64389402,
            64387675,
            64408229,
            64380388,
            64396146,
            64395794,
            64394593,
            64392997,
            64394432,
            64400786,
            64397002,
            64396496,
            64397563,
            64397111,
            64393509
        ],
        "C": [
            64384895,
            64387481,
            64390976,
            64405340,
            64382337,
            64385693,
            64385929,
            64394275,
            64434799,
            64386198,
            64382497,
            64383809,
            64377823,
            64389605,
            64376790,
            64385883,
            64378335,
            64383814,
            64387181,
            64382731,
            64387786
        ],
        "B2": [
            64382237,
            64381285,
            64379711,
            64392921,
            64382257,
            64380535,
            64394999,
            64387075,
            64388632,
            64389667,
            64386828,
            64401152,
            64379896,
            64404188,
            64390999,
            64383775,
            64439469,
            64397436,
            64400046
        ],
        "B1": [
            64376943,
            64376875,
            64382975,
            64410900,
            64376252,
            64375532,
            64376537,
            64399066,
            64383882,
            64379534,
            64379185,
            64385521,
            64377760,
            64384722,
            64375586,
            64377602,
            64378450,
            64377183,
            64379613,
            64377830
        ],
        "A": [
            64373589,
            64373694,
            64408041,
            64373563,
            64373607,
            64373538,
            64381662,
            64378360,
            64376936,
            64374179,
            64380404,
            64373751,
            64374463,
            64373629,
            64373483,
            64374884,
            64373477,
            64375133,
            64374905
        ]
    },
    "name": "A. Maximum Square",
    "statement": "Ujan decided to make a new wooden roof for the house. He has n\r\nrectangular planks numbered from 1 to n. The i-th plank has size a_i\r\ntimes 1 (that is, the width is 1 and the height is a_i).Now, Ujan wants\r\nto make a square roof. He will first choose some of the planks and place\r\nthem side by side in some order. Then he will glue together all of these\r\nplanks by their vertical sides. Finally, he will cut out a square from\r\nthe resulting shape in such a way that the sides of the square are\r\nhorizontal and vertical.For example, if Ujan had planks with lengths 4,\r\n3, 1, 4 and 5, he could choose planks with lengths 4, 3 and 5. Then he\r\ncan cut out a 3\r\ntimes 3 square, which is the maximum possible. Note that this is not the\r\nonly way he can obtain a 3\r\ntimes 3 square. What is the maximum side length of the square Ujan can\r\nget?\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\ntypedef pair < db, db > pdd;\ntypedef pair < db, ld > pdl;\ntypedef pair < ld, db > pld;\ntypedef pair < ld, ld > ldp;\n\ntypedef pair < ll, ll > pll;\ntypedef pair < int, ll > pil;\ntypedef pair < ll, int > pli;\ntypedef pair < int, int > pii;\n\n#define F first\n#define S second\n\n#define en end()\n#define bg begin()\n\n#define rev reverse\n#define mp make_pair\n#define pb push_back\n\n#define y1 y1234567890\n#define um unordered_map\n\n#define all(x) x.bg, x.en\n#define sz(x) (int)x.size()\n#define len(x) (int)strlen(x)\n\n#define sqr(x) ((x + 0ll) * (x))\n#define sqrd(x) ((x + 0.0) * (x))\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\n\nconst db eps = (db)1e-9;\nconst db pi = acos(-1.0);\n\nconst int dx[] = {0, 0, 1, 0, -1};\nconst int dy[] = {0, 1, 0, -1, 0};\n\nconst int N = 100500;\n\nint n, a[N];\n\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\t//freopen(\".err\", \"w\", stderr);\n\n\t//srand(time(NULL));\n\n\t//cin.tie(NULL);\n\t//cout.tie(NULL);\n\t//ios_base::sync_with_stdio(false);\n\n\t//cout << setprecision(10) << fixed;\n\t\n\tint t;\n\tcin >> t;\n\n\twhile (t--) {\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tsort(a + 1, a + 1 + n);\n\t\trev(a + 1, a + 1 + n);\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (a[i] >= i)\n\t\t\t\tans = i;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\t//cerr << (clock() + 0.0) / CLOCKS_PER_SEC;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Maximum Square.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "There are different solutions: Bruteforce the length of the square from\r\nto . If you can make a square of side length , then there should be at\r\nleast planks of length at least . The complexity of such solution: . The\r\nparameter can be also checked using binary search: then the complexity\r\nbecomes . Suppose you want to take planks and cut the largest square\r\nfrom them. Of course, it is always better to take the longest planks.\r\nThe side of the largest square that can be cut from them is bounded by\r\nthe length of the smallest of these planks and the number of the planks,\r\n. Therefore, the solution is: sort the numbers in descending order; then\r\nthe solution is . The complexity: . Since the numbers are at most , we\r\ncan use counting sort and the complexity becomes .\r\n",
    "hint": []
}