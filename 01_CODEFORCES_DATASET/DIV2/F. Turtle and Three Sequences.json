{
    "link": "https://codeforces.com//contest/2003/problem/F",
    "problemId": "2836632",
    "problem_idx": "F",
    "shortId": "2003F",
    "contest_number": "2003",
    "problem_submissions": {
        "E2": [
            278341707,
            278455104,
            278330622,
            278179988,
            278257072,
            278360261,
            278589270
        ],
        "E1": [
            278142159,
            278142843,
            278147621,
            278145820,
            278139445,
            278118163,
            278284773,
            278152908,
            278522597
        ],
        "D2": [
            278115632,
            278124223,
            278116119,
            278123063,
            278131280,
            278090274,
            278184104,
            278101954,
            278115622,
            278113440,
            278105822,
            278109507,
            278111408,
            278106372,
            278109910,
            278114958,
            278113518,
            278109092
        ],
        "D1": [
            278092613,
            278095057,
            278099358,
            278106267,
            278123018,
            278076086,
            278136646,
            278080662,
            278086676,
            278089029,
            278091347,
            278090118,
            278085289,
            278096196,
            278091226,
            278088309,
            278092415,
            278094460
        ],
        "C": [
            278073298,
            278084142,
            278084204,
            278091216,
            278102032,
            278059873,
            278062388,
            278064696,
            278066407,
            278065300,
            278076163,
            278064469,
            278071045,
            278077312,
            278070267,
            278068388,
            278071776,
            278071322
        ],
        "B": [
            278057061,
            278062158,
            278060356,
            278059818,
            278072173,
            278051522,
            278051239,
            278054673,
            278056246,
            278057857,
            278063310,
            278056133,
            278051957,
            278062245,
            278058767,
            278054937,
            278067356,
            278063368
        ],
        "A": [
            278051014,
            278054951,
            278054980,
            278049465,
            278052299,
            278047930,
            278047962,
            278049334,
            278049908,
            278052979,
            278052705,
            278049194,
            278048004,
            278057248,
            278049244,
            278048425,
            278067001,
            278049077
        ],
        "F": [
            283415067,
            278185607,
            278644931
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/132953",
    "editorial": "If the number of possible values for is small, you can use bitmask DP.\r\nDefine as the maximum result considering all numbers up to , where is\r\nthe current set of distinct values in the subsequence, and is the value\r\nof for the last element of the subsequence. The transitions can be\r\noptimized using a Fenwick tree (Binary Indexed Tree).When has many\r\npossible values, consider using color-coding, where each is randomly\r\nmapped to a number in , and then apply bitmask DP. The probability of\r\nobtaining the optimal solution in one attempt is , and the probability\r\nof not obtaining the optimal solution after attempts is . When , the\r\nprobability of not obtaining the optimal solution is approximately ,\r\nwhich is acceptable.Time complexity: .\r\n",
    "name": "F. Turtle and Three Sequences",
    "statement": "Piggy gives Turtle three sequences a_1, a_2,\r\nldots, a_n, b_1, b_2,\r\nldots, b_n, and c_1, c_2,\r\nldots, c_n.Turtle will choose a subsequence of 1, 2,\r\nldots, n of length m, let it be p_1, p_2,\r\nldots, p_m. The subsequence should satisfy the following conditions:\r\na_{p_1}\r\nle a_{p_2}\r\nle\r\ncdots\r\nle a_{p_m}; All b_{p_i} for all indices i are , i.e., there don’t exist\r\ntwo different indices i, j such that b_{p_i} = b_{p_j}. Help him find\r\nthe maximum value of\r\nsum\r\nlimits_{i = 1}^m c_{p_i}, or tell him that it is impossible to choose a\r\nsubsequence of length m that satisfies the conditions above.Recall that\r\na sequence a is a subsequence of a sequence b if a can be obtained from\r\nb by the deletion of several (possibly, zero or all) elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define GO cin.tie(0);cout.tie(0);ios::sync_with_stdio(0);typedef long long ll;using namespace std;template<typename type>struct Fenwick {   vector<type> fen;  int n;   Fenwick() {}   Fenwick(int n) {    init(n);  }   void init(int n) {    this->n = n;    fen.assign(n + 5, 0);  }   void upd(int pos, type inc) {    for(; pos <= n ; pos = (pos | (pos + 1))) {      //fen[pos] += inc;      fen[pos] = max(fen[pos],inc);    }  }   // prefix query  type query(int r) {    type sum = 0;    for(; r >= 0 ; r = (r & (r + 1)) - 1) {      sum = max(sum,fen[r]);    }    return sum;  }   // range query  type query(int l, int r) {    return query(r) - query(l - 1);  }   // the array should be ones and zeroes only to find the kth one  int find_kth(type k) {    k--;    int x = 0;    for(int i = 1 << std::__lg(n) ; i > 0 ; i >>= 1){      if(x + i <= n && fen[x + i - 1] <= k) {        x += i;        k -= fen[x - 1];      }    }    return x;  } }; int main(){    GO    srand(time(0));    int n,m;    cin>>n>>m;    int a[n],b[n],c[n];    for(int i=0;i<n;i++){        cin>>a[i];    }    for(int i=0;i<n;i++){        cin>>b[i];    }    for(int i=0;i<n;i++){        cin>>c[i];    }    int ans = 0;    for(int t=0;t<300;t++){        int d[n],g[n + 1];        for(int i=1;i<=n;i++){            g[i] = rand()%m;        }        for(int i=0;i<n;i++){            d[i] = g[b[i]];        }        Fenwick<int>f[(1<<m)];        for(int i=0;i<(1<<m);i++){            f[i].init(n + 1);        }        for(int i=0;i<n;i++){            for(int j=0;j<(1<<m);j++){                if(!(j&(1<<d[i])))                    continue;                int x = f[(j^(1<<d[i]))].query(a[i]);                if(x || (j^(1<<d[i])) == 0)                    f[j].upd(a[i],x + c[i]);            }        }        ans = max(ans,f[(1<<m) - 1].query(n));    }    if(ans == 0){        cout<<\"-1\\n\";    }else{        cout<<ans<<'\\n';    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "math",
        "probabilities",
        "two pointers"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Turtle and Three Sequences.json",
    "hint": [
        "Hint 1 What will you do if the number of possible values for is small?",
        "Hint 2 Try some randomized algorithms, like color-coding."
    ]
}