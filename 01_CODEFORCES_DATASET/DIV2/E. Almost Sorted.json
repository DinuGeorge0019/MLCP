{
    "link": "https://codeforces.com//contest/1509/problem/E",
    "problemId": "958791",
    "problem_idx": "E",
    "shortId": "1509E",
    "contest_number": "1509",
    "problem_submissions": {
        "F": [
            113256937,
            113452435,
            113285395
        ],
        "E": [
            113232874,
            113219267,
            113224061,
            113223560,
            113233730,
            113226238,
            113242617,
            113234728,
            113229028,
            113234613,
            113236691,
            113233309,
            113237999,
            113236924,
            113234998,
            113244661,
            113248199,
            113294044,
            113242554,
            113241170,
            113238407
        ],
        "D": [
            113221122,
            113205083,
            113211524,
            113212503,
            113218682,
            113218702,
            113210079,
            113222981,
            113224859,
            113213502,
            113222656,
            113222165,
            113224508,
            113227361,
            113205851,
            113214932,
            113213501,
            113214642,
            113227110,
            113229498
        ],
        "C": [
            113210555,
            113197246,
            113200376,
            113200962,
            113204903,
            113197040,
            113198240,
            113210183,
            113210598,
            113200328,
            113196898,
            113203900,
            113204261,
            113210665,
            113209464,
            113204447,
            113203994,
            113206401,
            113202494,
            113202048
        ],
        "B": [
            113194717,
            113193937,
            113192191,
            113190108,
            113198761,
            113232450,
            113190578,
            113195766,
            113197868,
            113220965,
            113207035,
            113194479,
            113196536,
            113224188,
            113200860,
            113198840,
            113198891,
            113192926,
            113195317
        ],
        "A": [
            113186426,
            113184937,
            113185796,
            113185053,
            113185023,
            113184968,
            113185012,
            113185414,
            113185256,
            113188852,
            113200720,
            113185467,
            113185688,
            113212116,
            113186288,
            113188479,
            113188850,
            113184903,
            113188945
        ]
    },
    "name": "E. Almost Sorted",
    "statement": "Seiji Maki doesn\u2019t only like to observe relationships being unfolded, he\r\nalso likes to observe sequences of numbers, especially permutations.\r\nToday, he has his eyes on permutations.A permutation a_1, a_2,\r\ndots, a_n of 1, 2,\r\ndots, n is said to be if the condition a_{i + 1}\r\nge a_i - 1 holds for all i between 1 and n - 1 inclusive.Maki is\r\nconsidering the list of all almost sorted permutations of 1, 2,\r\ndots, n, given in lexicographical order, and he wants to find the k-th\r\npermutation in this list. Can you help him to find such\r\npermutation?Permutation p is lexicographically smaller than a\r\npermutation q if and only if the following holds: in the first position\r\nwhere p and q differ, the permutation p has a smaller element than the\r\ncorresponding element in q.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\n#define int long long\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define F first\n#define S second\n\n\nvoid accell() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n}\n\n\nsigned main() {\n    accell();\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        if (n <= 60 && (1LL << (n - 1)) < k) {\n            cout << -1 << '\\n';\n            continue;\n        }\n        --k;\n        vector<int> ans;\n        for (int j = 0; j < n; ++j) {\n            int fir = j + 1;\n            for (int i = min(n - j - 2, 60LL); i >= 0; --i) {\n                if (k >= (1LL << i)) {\n                    ++fir;\n                    k -= (1LL << i);\n                } else {\n                    break;\n                }\n            }\n            for (int cur = fir; cur >= j + 1; --cur) {\n                ans.push_back(cur);\n            }\n            j = fir - 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            cout << ans[i] << ' ';\n        }\n        cout << '\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Almost Sorted.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "First solution.\n\nLet's first analyze the general structure of an almost sorted permutation. We know that when the sequence decreases, it must decrease by exactly 1\n. Thus, every decreasing subarray covers some consecutive range of values. Let's split the permutation into decreasing subarrays, each of them as large as possible. For example, we can split the almost sorted permutation [3,2,1,4,6,5,7]\n as [3,2,1],[4],[6,5],[7]\n. The main claim goes as follows.\n\nClaim. Each almost sorted permutation is determined uniquely by the sequence of sizes of its maximal decreasing subarrays.\n\nSo for instance, in the previous example, the sequence of sizes 3,1,2,1\n uniquely determines the permutation as [3,2,1,4,6,5,7]\n. This is because the last element ai\n of a decreasing block must be smaller than the first element ai+1\n in the next block. Otherwise we either have ai+1=ai?1\n, in which case we should expand the previous block, or ai+1<ai?1\n, which is contradictory.\n\nNow, this is basically enough to get a complete solution. Through some careful counting (which we will go into detail about later) we can show that there are 2n?1\n almost sorted permutations of size n\n. Now notice that smaller sizes for the first block produce lexicographically smaller permutations (since a permutation whose first block has size m\n starts with m\n). Moreover, the remaining sequence after deleting the first block is almost sorted. This enables to do a recursive argument to find the permutation, by first choosing the correct size for the first block and then solving recursively for the remaining sequence. This works in O(nlogk)\n.\n\nSecond solution.\n\nBut we can do better. Let's mark the positions in the array where a decreasing block ends with 0\n, and the other positions as 1\n. Notice that the last character is always 0\n, so we will ignore it and assign only the other n?1\n characters. Thus our example permutation [3,2,1,4,6,5,7]\n becomes 110010\n since the first, second, and third blocks end at positions 3\n, 4\n, and 6\n. By the first claim, we can recover the permutation from this sequence (which is also the proof of there being 2n?1\n permutations of size n\n that we promised earlier!).\n\nNow, we can read the assigned sequence as a binary number, for instance, the corresponding number is 1100102=25+24+21=50\n for our trusty example. The point of doing this is the following:\n\nClaim 2. The k\n-th almost sorted permutation in lexicographical order is assigned the number k?1\n.\n\nTo prove this it's actually enough to check that the number m+1\n is assigned to a greater permutation than the number m\n. This can be done by looking at how the permutation changes when we add 1\n to m\n, looking at the binary representation of m\n from right to left. We leave it to the reader to fill in the details of the proof, but here's a diagram showing the situation graphically (with height representing the values of the permutation)."
}