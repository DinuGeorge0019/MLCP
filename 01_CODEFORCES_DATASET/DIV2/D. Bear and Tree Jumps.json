{
    "link": "https://codeforces.com//contest/791/problem/D",
    "problemId": "98947",
    "problem_idx": "D",
    "shortId": "791D",
    "contest_number": "791",
    "problem_submissions": {
        "E": [
            25623822,
            25707525,
            25637756,
            25686811
        ],
        "D": [
            25619687,
            25615888,
            25616164,
            25617170,
            25877940,
            25623254,
            25619752,
            25619476,
            25621260,
            25621091,
            25621698,
            25621432,
            25634938,
            25621485,
            25620131,
            25687920,
            25622200,
            25621928,
            25620558,
            25624599,
            25620325,
            25621555
        ],
        "C": [
            25614829,
            25610721,
            25612354,
            25611470,
            25609920,
            25609700,
            25612129,
            25612423,
            25609930,
            25611851,
            25612109,
            25634522,
            25612617,
            25613540,
            25612121,
            25613013,
            25613533,
            25611359,
            25612919,
            25614171
        ],
        "B": [
            25607382,
            25608951,
            25608908,
            25606986,
            25611482,
            25608509,
            25609856,
            25607620,
            25608196,
            25608851,
            25634368,
            25608159,
            25610124,
            25608652,
            25608764,
            25608051,
            25608470,
            25615071,
            25609116
        ],
        "A": [
            25604642,
            25605072,
            25605943,
            25604441,
            25605687,
            25604865,
            25604575,
            25604516,
            25605765,
            25605230,
            25634308,
            25604731,
            25605413,
            25604932,
            25605388,
            25604873,
            25604460,
            25606109,
            25605955
        ]
    },
    "name": "D. Bear and Tree Jumps",
    "statement": "A tree is an undirected connected graph without cycles. The distance\r\nbetween two vertices is the number of edges in a simple path between\r\nthem.Limak is a little polar bear. He lives in a tree that consists of\r\nvertices, numbered through .Limak recently learned how to jump. He can\r\njump from a vertex to any vertex within distance at most .For a pair of\r\nvertices we define as the minimum number of jumps Limak needs to get\r\nfrom to . Your task is to find the sum of over all pairs of vertices\r\nsuch that .\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long ans = 0;\n\nvector<long long> dfs(int v, int f, int k, vector<vector<int> >& e) {\n\tvector<long long> res(k+1);\n\tres[0] = 1;\n\tlong long sum = 1;\n\tfor (int i = 0; i < e[v].size(); ++i) {\n\t\tint vv = e[v][i];\n\t\tif (vv == f) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto tmp = dfs(vv, v, k, e);\n\t\t\n\t\tlong long tmpsum = 0;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\ttmpsum += tmp[j];\n\t\t}\n\t\t\n\t\ttmp[k] += tmp[0];\n\t\tlong long c = tmp[k-1];\n\t\tfor (int j = k-2; j >= 0; --j) {\n\t\t\ttmp[j+1] = tmp[j];\n\t\t}\n\t\ttmp[0] = c;\n\t\t\n\t\tans += sum * tmp[k] + tmpsum * res[k];\n\t\tsum += tmpsum;\n\t\t\n\t\tfor (int j = 1; j < k; ++j) {\n\t\t\tfor (int tmpj = 1; tmpj < k; ++tmpj) {\n\t\t\t\tif (j + tmpj <= k) {\n\t\t\t\t\tans -= res[j] * tmp[tmpj];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= k; ++j) {\n\t\t\tres[j] += tmp[j];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tvector<vector<int> > e(n+1);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tdfs(1, 0, k, e);\n    cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bear and Tree Jumps.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "It's a known problem to count the sum of distances for all pairs of vertices. For each edge, we should add to the answer the number of times this edge appears in a path between some two vertices. If sv denotes the size of the subtree of the vertex v (we can first root the tree in 1), we should add sv\u00b7(n?-?sv) to the sum.\n\nIn this problem, the answer is around , where S is the answer for the known problem described above. But for each path with length L, we should add  to the answer, where f(L,?k) says how much we must add to L to get a number divisible by k (f(10,?3)?=?2,?f(11,?3)?=?1,?f(12,?3)?=?0). We know the sum of  because it's  in total. What remains is to compute the sum of f(L,?k). To achieve that, for each remainder modulo k, we want to know the number of paths with length that has this remainder. For example, if k?=?3 and there are 200 paths with remainder 1, they all have f(L,?k)?=?2, so we should add 200\u00b72 to the answer.\n\nLet's root the tree in any vertex and do bottom-up dp. For each subtree we compute the k values: for each remainder modulo k how many paths (starting from the root of this subtree) have this remainder. We can merge two subtrees in O(k2), so the total complexity is O(n\u00b7k2). See my code for details."
}