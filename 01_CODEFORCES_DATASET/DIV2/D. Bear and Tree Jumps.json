{"link": "https://codeforces.com//contest/791/problem/D", "problemId": "98947", "problem_idx": "D", "shortId": "791D", "contest_number": "791", "problem_submissions": {"E": [25623822, 25707525, 25637756, 25686811], "D": [25619687, 25615888, 25616164, 25617170, 25877940, 25623254, 25619752, 25619476, 25621260, 25621091, 25621698, 25621432, 25634938, 25621485, 25620131, 25687920, 25622200, 25621928, 25620558, 25624599, 25620325, 25621555], "C": [25614829, 25610721, 25612354, 25611470, 25609920, 25609700, 25612129, 25612423, 25609930, 25611851, 25612109, 25634522, 25612617, 25613540, 25612121, 25613013, 25613533, 25611359, 25612919, 25614171], "B": [25607382, 25608951, 25608908, 25606986, 25611482, 25608509, 25609856, 25607620, 25608196, 25608851, 25634368, 25608159, 25610124, 25608652, 25608764, 25608051, 25608470, 25615071, 25609116], "A": [25604642, 25605072, 25605943, 25604441, 25605687, 25604865, 25604575, 25604516, 25605765, 25605230, 25634308, 25604731, 25605413, 25604932, 25605388, 25604873, 25604460, 25606109, 25605955]}, "name": "D. Bear and Tree Jumps", "statement": "A tree is an undirected connected graph without cycles. The distance\r\nbetween two vertices is the number of edges in a simple path between\r\nthem.Limak is a little polar bear. He lives in a tree that consists of\r\nvertices, numbered through .Limak recently learned how to jump. He can\r\njump from a vertex to any vertex within distance at most .For a pair of\r\nvertices we define as the minimum number of jumps Limak needs to get\r\nfrom to . Your task is to find the sum of over all pairs of vertices\r\nsuch that .\r\n", "solutions": ["#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nlong long ans = 0;\n\nvector<long long> dfs(int v, int f, int k, vector<vector<int> >& e) {\n\tvector<long long> res(k+1);\n\tres[0] = 1;\n\tlong long sum = 1;\n\tfor (int i = 0; i < e[v].size(); ++i) {\n\t\tint vv = e[v][i];\n\t\tif (vv == f) {\n\t\t\tcontinue;\n\t\t}\n\t\tauto tmp = dfs(vv, v, k, e);\n\t\t\n\t\tlong long tmpsum = 0;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\ttmpsum += tmp[j];\n\t\t}\n\t\t\n\t\ttmp[k] += tmp[0];\n\t\tlong long c = tmp[k-1];\n\t\tfor (int j = k-2; j >= 0; --j) {\n\t\t\ttmp[j+1] = tmp[j];\n\t\t}\n\t\ttmp[0] = c;\n\t\t\n\t\tans += sum * tmp[k] + tmpsum * res[k];\n\t\tsum += tmpsum;\n\t\t\n\t\tfor (int j = 1; j < k; ++j) {\n\t\t\tfor (int tmpj = 1; tmpj < k; ++tmpj) {\n\t\t\t\tif (j + tmpj <= k) {\n\t\t\t\t\tans -= res[j] * tmp[tmpj];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= k; ++j) {\n\t\t\tres[j] += tmp[j];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tvector<vector<int> > e(n+1);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tdfs(1, 0, k, e);\n    cout << ans << endl;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "trees"], "dificulty": "2100", "interactive": false}