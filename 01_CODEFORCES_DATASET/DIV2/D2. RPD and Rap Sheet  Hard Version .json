{
    "link": "https://codeforces.com//contest/1543/problem/D2",
    "problemId": "1038889",
    "problem_idx": "D2",
    "shortId": "1543D2",
    "contest_number": "1543",
    "problem_submissions": {
        "E": [
            121638293,
            121640122,
            121646039,
            121646816,
            121811012,
            121760431,
            121760422,
            121760385,
            121760374,
            121760355,
            121760336,
            121760282,
            121760064,
            121760038,
            121759905,
            121653632,
            121644982,
            121669265,
            121699461,
            121677102,
            121676768,
            121663043,
            121682193,
            121682008,
            121681968,
            121681825
        ],
        "C": [
            121607103,
            121580363,
            121606682,
            121627500,
            121653560,
            121590146,
            121589009,
            121582693,
            121614005,
            121615009,
            121616095,
            121613756,
            121596961,
            121599154,
            121597926,
            121608185,
            121597933,
            121606103,
            121606203
        ],
        "D2": [
            121596158,
            121601464,
            121617704,
            121620392,
            121626490,
            121619638,
            121618444,
            121618704,
            121605621,
            121605043,
            121602716,
            121616842,
            121615764,
            121615962,
            121615812,
            121620480,
            121619304,
            121615169,
            121624602
        ],
        "D1": [
            121576532,
            121593477,
            121613266,
            121597889,
            121614339,
            121601755,
            121604364,
            121608739,
            121598195,
            121595487,
            121589696,
            121586209,
            121618059,
            121609771,
            121609361,
            121593980,
            121614987,
            121614945,
            121599352
        ],
        "B": [
            121572816,
            121573125,
            121599866,
            121581407,
            121575511,
            121573418,
            121573029,
            121584593,
            121575414,
            121574254,
            121573423,
            121577407,
            121575483,
            121573867,
            121576997,
            121576837,
            121577599,
            121574767,
            121583481
        ],
        "A": [
            121572516,
            121572434,
            121598213,
            121578311,
            121573469,
            121572491,
            121577467,
            121587968,
            121572718,
            121572541,
            121572464,
            121574176,
            121573349,
            121572610,
            121574728,
            121572920,
            121574400,
            121572846,
            121578119
        ]
    },
    "name": "D2. RPD and Rap Sheet  Hard Version ",
    "statement": "Every decimal number has a base k equivalent. The individual digits of a\r\nbase k number are called k-its. Let’s define the k-itwise XOR of two\r\nk-its a and b as (a + b)\r\nbmod k.The k-itwise XOR of two base k numbers is equal to the new number\r\nformed by taking the k-itwise XOR of their corresponding k-its. The\r\nk-itwise XOR of two decimal numbers a and b is denoted by a\r\noplus_{k} b and is equal to the decimal representation of the k-itwise\r\nXOR of the base k representations of a and b. All further numbers used\r\nin the statement below are in decimal unless specified.You have hacked\r\nthe criminal database of Rockport Police Department (RPD), also known as\r\nthe Rap Sheet. But in order to access it, you require a password. You\r\ndon’t know it, but you are quite sure that it lies between 0 and n-1\r\ninclusive. So, you have decided to guess it. Luckily, you can try at\r\nmost n times without being blocked by the system. But the system is\r\nadaptive. Each time you make an incorrect guess, it changes the\r\npassword. Specifically, if the password before the guess was x, and you\r\nguess a different number y, then the system changes the password to a\r\nnumber z such that x\r\noplus_{k} z=y. Guess the password and break into the system.\r\n",
    "solutions": [
        "// Problem: D1. RPD and Rap Sheet (Easy Version)\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/D1\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nint n,k;\nint f(int x,int y)//减\n{\n\tint res=0,base=1;\n\twhile(x||y)\n\t{\n\t\tres+=(x%k+k-y%k)%k*base;\n\t\tbase*=k;\n\t\tx/=k,y/=k;\n\t}\n\treturn res;\n}\nint g(int x,int y)//加\n{\n\tint res=0,base=1;\n\twhile(x||y)\n\t{\n\t\tres+=(x%k+y%k)%k*base;\n\t\tbase*=k;\n\t\tx/=k,y/=k;\n\t}\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tn=read(),k=read();\n\t\tint s=0;\n        bool t=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t{\n\t\t\tint cur;\n            if(t) cur=g(f(0,i),s);\n            else cur=g(i,s);\n\t\t\tprintf(\"%lld\\n\",cur);\n\t\t\tfflush(stdout);\n\t\t\ts=f(cur,s),t^=1;//s-cur\n\t\t\tif(read()==1) break;\n\t\t\t//如果i是0，会变成ixor s\n            //printf(\"*%lld\\n\",s);\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "interactive",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. RPD and Rap Sheet  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/92582",
    "editorial": "Note It is strongly recommended to read the proofs also to\ncompletely understand why the solutions work.The solutions described for\nthe easy version wonât work here because the general -itwise operation\ndoes not satisfy self-inverse property, i.e., .In this whole solution,\nwe will work in base only and we will convert the numbers to decimal\nonly for I/O purpose. Notice that any property which is satisfied by\n-its will also be satisfied by base numbers since a base number is\nnothing but a concatenation of -its.When we make an incorrect guess, the\nsystem changes the password to such that . Letâs denote the -th -it of\nby . Expanding this according to the definition of -itwise XOR, for all\nindividual -its . So, letâs define another -itwise operation . Then, .\nNow, letâs extend the solutions of the Easy Version for this version.\nMethod 1Before moving to the solution, letâs see some properties of the\noperation over -its.Property 1 Proof Property 2 Proof Solution -Let\ndenote the -th query. Then, , if is even and if is odd. Letâs see why\nthis works.Claim If the original password was , after queries, the\npassword becomes if is even and if is odd. ProofLetâs prove this by\ninduction.Base Case . So, after -st query, the password becomes .Case 1\nis evenInduction hypothesis Let the current password after queries be\n.Inductive step is odd. So, the -th query is . The new password will be\nby Property 2.Case 2 is oddInduction hypothesis Let the current password\nafter queries be .Inductive step is even. So, the -th query is . The new\npassword will be by Property 1.Hence, proved by induction.Now notice\nthat after queries, the password will become if is even or if is odd\nwhich will be equal to the -th query. Hence, the problem will be solved\nafter exactly queries. Since , the problem will be solved after at most\nqueries. Method 2Again, letâs denote the -th query by .Then, Letâs see\nwhy this works.Claim If the original password was , after queries, the\npassword will be ProofLetâs prove this by induction.Base Case After the\n-st query which is , the password will be .Induction hypothesis Let the\npassword after queries be Inductive Step The -th query is . After\nqueries, the password will becomes Hence, proved by induction.Now notice\nthat after queries, the password will become which will be equal to the\n-th query. Hence, the problem will be solved after exactly queries.\nSince , the problem will be solved after at most queries.But we are not\ndone yet. This solution is which will time out. The solution for this\nisnât as simple as what we did for the Easy version because the\noperation is neither associative nor commutative. So, itâs time to\nexplore some more properties of these operations.Property 3 Proof\nProperty 4 Proof Now, letâs try to simplify our queries. (by Property 3)\n(by Property 4) See the pattern?You can generalize the -th query as - if\nis odd if is even So, we will maintain a prefix Negative XOR whose value\nafter queries will be Then, if is odd if is even Then update Notes Both\nthe operations and can be implemented naively by converting the decimal\nnumbers to base , finding the -itwise XOR of the base numbers and\nfinally converting it back to decimal. The time complexity for each of\nthese operations will be . At any stage, the maximum number that we\ncould be dealing with will be non-negative and will not exceed as the\n-itwise operations do not add extra -its. This fits well within the\nlimits of which is . The total time complexity of the solution will be .\n",
    "hint": []
}