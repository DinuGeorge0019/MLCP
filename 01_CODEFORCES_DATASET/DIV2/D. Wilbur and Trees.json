{"link": "https://codeforces.com//contest/596/problem/D", "problemId": "40908", "problem_idx": "D", "shortId": "596D", "contest_number": "596", "problem_submissions": {"E": [14284902, 14410276, 14285890, 14836358], "A": [14282529, 14272331, 14272408, 14272249, 14272247, 14272132, 14272036, 14272062, 14273974, 14272466, 14272094, 14272742, 14272840, 14272048, 14272087, 14272349, 14272225, 14272447, 14273354, 14273114], "D": [14280833, 14284455, 14282588, 14285386, 14285067, 14284298, 14286251, 14285939, 14284050, 14285941, 14286108, 14293470, 14284179], "C": [14276112, 14278736, 14278325, 14279291, 14278970, 14277576, 14282655, 14280088, 14281778, 14280140, 14281205, 14281281, 14279114, 14277665, 14278438, 14279354, 14285136, 14283954, 14281786], "B": [14272947, 14272778, 14273548, 14272930, 14272933, 14273058, 14272243, 14272568, 14274807, 14272965, 14272538, 14274186, 14273926, 14272409, 14272384, 14272994, 14273180, 14273634, 14274094, 14274290]}, "name": "D. Wilbur and Trees", "statement": "Wilbur the pig really wants to be a beaver, so he decided today to\r\npretend he is a beaver and bite at trees to cut them down.There are\r\ntrees located at various positions on a line. Tree is located at\r\nposition . All the given positions of the trees are distinct.The trees\r\nare equal, i.e. each tree has height . Due to the wind, when a tree is\r\ncut down, it either falls left with probability , or falls right with\r\nprobability . If a tree hits another tree while falling, that tree will\r\nfall in the same direction as the tree that hit it. A tree can hit\r\nanother tree only if the distance between them is strictly less than .\r\nFor example, imagine there are trees located at positions , , and ,\r\nwhile and the tree at position falls right. It hits the tree at position\r\nand it starts to fall too. In it\u2019s turn it hits the tree at position and\r\nit also starts to fall. The distance between and is exactly , so the\r\ntree at position will not fall.As long as there are still trees\r\nstanding, Wilbur will select either the leftmost standing tree with\r\nprobability or the rightmost standing tree with probability . Selected\r\ntree is then cut down. If there is only one tree remaining, Wilbur\r\nalways selects it. As the ground is covered with grass, Wilbur wants to\r\nknow the expected total length of the ground covered with fallen trees\r\nafter he cuts them all down because he is concerned about his\r\ngrass-eating cow friends. Please help Wilbur.\r\n", "solutions": ["//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define int long long\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2049;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nld dp[maxN][maxN][2][2];\n\nll x[maxN], nx[maxN][2], val[maxN][2];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tld p;\n\tint n, h; cin >> n >> h >> p;\n\tx[0] = -1e9;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tx[n + 1] = 1e9; \n\tsort(x, x + n + 2);\n\tn += 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos = i;\n\t\twhile (pos < n - 1 && x[pos + 1] - x[pos] < h)\n\t\t\tpos++;\n\t\tnx[i][1] = pos;\n\t\tval[i][1] = x[pos] - x[i] + h;\n\t\tpos = i;\n\t\twhile (pos && x[pos] - x[pos - 1] < h)\n\t\t\tpos--;\n\t\tnx[i][0] = pos;\n\t\tval[i][0] = x[i] - x[pos] + h;\n\t}\n\tfor (int l = n - 2; l; --l) {\n\t\tfor (int r = l; r < n - 1; r++) {\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tint prv = a? x[l - 1] + h: x[l - 1];\n\t\t\t\t\tint nxt = b? x[r + 1]: x[r + 1] - h;\n\t\t\t\t\tif (r == l) {\n\t\t\t\t\t\tdp[l][r][a][b] += p * min(x[l] - prv, h) + (1 - p) * min(nxt - x[r], h); \n\t\t\t\t\t} else {\n\t\t\t\t\t\t//l falls left\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + dp[l + 1][r][0][b]));\n\t\t\t\t\t\t//r falls right\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + dp[l][r - 1][a][1]));\n\t\t\t\t\t\t//l falls right\n\t\t\t\t\t\tint pos = nx[l][1];\n\t\t\t\t\t\tif (pos >= r)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * ((val[l][1]) + dp[pos + 1][r][1][b]));\n\t\t\t\t\t\t//r falls left\n\t\t\t\t\t\tpos = nx[r][0];\n\t\t\t\t\t\tif (pos <= l)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * ((val[r][0]) + dp[l][pos - 1][a][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(7) << fixed << dp[1][n - 2][0][1] << '\\n';\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "input": "", "output": "", "tags": ["dp", "math", "probabilities", "sortings"], "dificulty": "2300", "interactive": false}