{
    "link": "https://codeforces.com//contest/596/problem/D",
    "problemId": "40908",
    "problem_idx": "D",
    "shortId": "596D",
    "contest_number": "596",
    "problem_submissions": {
        "E": [
            14284902,
            14410276,
            14285890,
            14836358
        ],
        "A": [
            14282529,
            14272331,
            14272408,
            14272249,
            14272247,
            14272132,
            14272036,
            14272062,
            14273974,
            14272466,
            14272094,
            14272742,
            14272840,
            14272048,
            14272087,
            14272349,
            14272225,
            14272447,
            14273354,
            14273114
        ],
        "D": [
            14280833,
            14284455,
            14282588,
            14285386,
            14285067,
            14284298,
            14286251,
            14285939,
            14284050,
            14285941,
            14286108,
            14293470,
            14284179
        ],
        "C": [
            14276112,
            14278736,
            14278325,
            14279291,
            14278970,
            14277576,
            14282655,
            14280088,
            14281778,
            14280140,
            14281205,
            14281281,
            14279114,
            14277665,
            14278438,
            14279354,
            14285136,
            14283954,
            14281786
        ],
        "B": [
            14272947,
            14272778,
            14273548,
            14272930,
            14272933,
            14273058,
            14272243,
            14272568,
            14274807,
            14272965,
            14272538,
            14274186,
            14273926,
            14272409,
            14272384,
            14272994,
            14273180,
            14273634,
            14274094,
            14274290
        ]
    },
    "name": "D. Wilbur and Trees",
    "statement": "Wilbur the pig really wants to be a beaver, so he decided today to\r\npretend he is a beaver and bite at trees to cut them down.There are\r\ntrees located at various positions on a line. Tree is located at\r\nposition . All the given positions of the trees are distinct.The trees\r\nare equal, i.e. each tree has height . Due to the wind, when a tree is\r\ncut down, it either falls left with probability , or falls right with\r\nprobability . If a tree hits another tree while falling, that tree will\r\nfall in the same direction as the tree that hit it. A tree can hit\r\nanother tree only if the distance between them is strictly less than .\r\nFor example, imagine there are trees located at positions , , and ,\r\nwhile and the tree at position falls right. It hits the tree at position\r\nand it starts to fall too. In it\u2019s turn it hits the tree at position and\r\nit also starts to fall. The distance between and is exactly , so the\r\ntree at position will not fall.As long as there are still trees\r\nstanding, Wilbur will select either the leftmost standing tree with\r\nprobability or the rightmost standing tree with probability . Selected\r\ntree is then cut down. If there is only one tree remaining, Wilbur\r\nalways selects it. As the ground is covered with grass, Wilbur wants to\r\nknow the expected total length of the ground covered with fallen trees\r\nafter he cuts them all down because he is concerned about his\r\ngrass-eating cow friends. Please help Wilbur.\r\n",
    "solutions": [
        "//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define int long long\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2049;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nld dp[maxN][maxN][2][2];\n\nll x[maxN], nx[maxN][2], val[maxN][2];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tld p;\n\tint n, h; cin >> n >> h >> p;\n\tx[0] = -1e9;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tx[n + 1] = 1e9; \n\tsort(x, x + n + 2);\n\tn += 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos = i;\n\t\twhile (pos < n - 1 && x[pos + 1] - x[pos] < h)\n\t\t\tpos++;\n\t\tnx[i][1] = pos;\n\t\tval[i][1] = x[pos] - x[i] + h;\n\t\tpos = i;\n\t\twhile (pos && x[pos] - x[pos - 1] < h)\n\t\t\tpos--;\n\t\tnx[i][0] = pos;\n\t\tval[i][0] = x[i] - x[pos] + h;\n\t}\n\tfor (int l = n - 2; l; --l) {\n\t\tfor (int r = l; r < n - 1; r++) {\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tint prv = a? x[l - 1] + h: x[l - 1];\n\t\t\t\t\tint nxt = b? x[r + 1]: x[r + 1] - h;\n\t\t\t\t\tif (r == l) {\n\t\t\t\t\t\tdp[l][r][a][b] += p * min(x[l] - prv, h) + (1 - p) * min(nxt - x[r], h); \n\t\t\t\t\t} else {\n\t\t\t\t\t\t//l falls left\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + dp[l + 1][r][0][b]));\n\t\t\t\t\t\t//r falls right\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + dp[l][r - 1][a][1]));\n\t\t\t\t\t\t//l falls right\n\t\t\t\t\t\tint pos = nx[l][1];\n\t\t\t\t\t\tif (pos >= r)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * ((val[l][1]) + dp[pos + 1][r][1][b]));\n\t\t\t\t\t\t//r falls left\n\t\t\t\t\t\tpos = nx[r][0];\n\t\t\t\t\t\tif (pos <= l)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * ((val[r][0]) + dp[l][pos - 1][a][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(7) << fixed << dp[1][n - 2][0][1] << '\\n';\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Wilbur and Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/21599",
    "editorial": "Let us solve this problem using dynamic programming. First let us\r\nreindex the trees by sorting them by -coordinate. Let where we would\r\nlike to consider the problem of if we only have trees standing where\r\nindicates that tree falls right and if it falls left and indicates that\r\ntree falls right and if it falls left. We start with the case that\r\nWilbur chooses the left tree and it falls right. The plan is to\r\ncalculate the expected length in this scenario and multiply by the\r\nchance of this case occurring, which is . We can easily calculate what\r\nis the farthest right tree that falls as a result of this and call it .\r\nThen if this means the entire segment falls, from which the length of\r\nthe ground covered by trees in can be calculated. However, be careful\r\nwhen , as there may be overlapping covered regions when the tree falls\r\nright but the tree falls left. If only , then we just consider adding\r\nthe length of ground covered by trees falling right and add to the value\r\nof the subproblem . There is another interesting case where Wilbur\r\nchooses the left tree and it falls left. In this case we calculate the\r\nexpected length and multiply by the chance of this occurring, which is .\r\nThe expected length of ground covered by the trees here is just the\r\nlength contributed by tree falling left, which we must be careful\r\ncalculating as there might be overlapping covered regions with the th\r\ntree falling left and the th tree falling right. Then we also add the\r\nvalue of subproblem . Doing this naively would take time, but this can\r\nbe lowered to by precalculating what happens when tree falls left or\r\nright. We should also consider the cases that Wilbur chooses the right\r\ntree, but these cases are analogous by symmetry. Complexity: Code:\r\nSolution Solution 1: Suppose that is a string in the query. Reverse and\r\nthe direction of all the moves that can be made on the table. Note that\r\nstarting at any point that is part of a cycle, there is a loop and then\r\nedges that go out of the loop. So, for every point, it can be checked by\r\ndfs whether the can be made by starting at that point by storing what is\r\nin the cycle. Moreover, note that in the reversed graph, each point can\r\nonly be a part of one cycle. Therefore, the total time for the dfs in a\r\nquery is . This is good enough for queries to run in time. Complexity:\r\nwhere is the number of distinct characters in the table, and is the\r\nquery string for the th query. Code: Solution Solution 2 (Actually too\r\nslow, see comment by waterfalls below for more details): For each string\r\n, dfs from every node that has in degree equal to in the original graph.\r\nThere will be a path which leads into a cycle after which anything in\r\nthe cycle can be used any number of times in . Only every node with in\r\ndegree equal to has to be checked because every path which leads to a\r\ncycle is part of a larger path which starts with a vertex of in degree\r\nthat leads into a cycle. This solution is slower, but it works in\r\npractice since it is really hard for a string to match so many times in\r\nthe table. Each query will take time, but it is much faster in practice.\r\nComplexity: where is the number of distinct characters in the table, and\r\nis the query string of the th query.\r\n"
}