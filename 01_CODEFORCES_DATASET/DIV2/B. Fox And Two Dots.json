{
    "link": "https://codeforces.com//contest/510/problem/B",
    "problemId": "21648",
    "problem_idx": "B",
    "shortId": "510B",
    "contest_number": "510",
    "problem_submissions": {
        "D": [
            9684147,
            9684396,
            9684806,
            9688259,
            9688872,
            9688202,
            9688369,
            9688723,
            9687291,
            9689191,
            9687900,
            9689279,
            9689405,
            9687159,
            9684719,
            9685186,
            9686736
        ],
        "C": [
            9682253,
            9688210,
            9686978,
            9685682,
            9685139,
            9685614,
            10161234,
            9700673,
            9685738,
            66447569,
            66445904,
            9686328,
            9689041,
            9687111,
            9690400,
            9689647,
            9688140,
            9688179,
            9685456,
            16269182,
            9682965,
            9696689,
            9680263
        ],
        "B": [
            9680110,
            9680943,
            9682904,
            9681822,
            9681781,
            9681477,
            9683346,
            9682052,
            9683360,
            9681047,
            9680759,
            9682507,
            9684457,
            9685737,
            9682120,
            9681028,
            9680313,
            9681991,
            9684236
        ],
        "A": [
            9678764,
            9678175,
            9681007,
            9678673,
            9678650,
            9678967,
            9679803,
            9682761,
            9680657,
            9678328,
            9678305,
            9680461,
            9680750,
            9679631,
            9678188,
            9678264,
            20834368,
            9678330,
            9678840
        ]
    },
    "name": "B. Fox And Two Dots",
    "statement": "Fox Ciel is playing a mobile puzzle game called \"Two Dots\". The basic\r\nlevels are played on a board of size cells, like this:Each cell contains\r\na dot that has some color. We will use different uppercase Latin\r\ncharacters to express different colors.The key of this game is to find a\r\ncycle that contain dots of same color. Consider 4 blue dots on the\r\npicture forming a circle as an example. Formally, we call a sequence of\r\ndots a if and only if it meets the following condition: These dots are\r\ndifferent: if then is different from . is at least 4. All dots belong to\r\nthe same color. For all : and are adjacent. Also, and should also be\r\nadjacent. Cells and are called adjacent if they share an edge. Determine\r\nif there exists a on the field.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nchar mp[51][51];\nbool vis[51][51];\nint dx[4] = {\n\t0, 0, 1, -1\n};\nint dy[4] = {\n  1, -1, 0, 0\n};\nint n, m;\nbool dfs(int x, int y, int px, int py, char c) {\n\tvis[x][y] = 1;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif (tx == px && ty == py) continue;\n\t\tif (tx >= 0 && tx < n && ty >= 0 && ty < m && mp[tx][ty] == c) {\n\t\t\tif (vis[tx][ty]) return 1;\n\t\t\tif (dfs(tx, ty, x, y, c)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\" %s\", mp[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (!vis[i][j]) {\n\t\t\t\tif (dfs(i, j, -1, -1, mp[i][j])) {\n\t\t\t\t\tputs(\"Yes\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"No\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Fox And Two Dots.json",
    "editorial_link": "https://codeforces.com//blog/entry/16173",
    "editorial": "This task is essentially ask if there is a cycle in an undirected graph:\r\ntreat each cell as a node, and add an edge if two cells are neighborhood\r\nand have some color. There are lots of ways to do this, for example: Run\r\ndfs / bfs, if an edge lead you to a visited node, then there must be a\r\ncycle. For each connected component, test if , if not then there must be\r\na cycle.\r\n",
    "hint": []
}