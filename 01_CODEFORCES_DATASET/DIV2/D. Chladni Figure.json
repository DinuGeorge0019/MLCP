{
    "link": "https://codeforces.com//contest/1162/problem/D",
    "problemId": "339907",
    "problem_idx": "D",
    "shortId": "1162D",
    "contest_number": "1162",
    "problem_submissions": {
        "F": [
            53760255
        ],
        "E": [
            53755729,
            53755411,
            53755882,
            53754129,
            53757378,
            53756764,
            53757700,
            53758454,
            53758416,
            53754833,
            53757407,
            53756313,
            53758588,
            53756165,
            53758997,
            53756619,
            53758311,
            53759677
        ],
        "D": [
            53752747,
            53753462,
            53754325,
            53757481,
            53752843,
            53755399,
            53755520,
            53755668,
            53754940,
            53755489,
            53758915,
            53755731,
            53754946,
            53755618,
            53759491,
            53755508,
            53758786,
            53755777,
            53756167
        ],
        "C": [
            53749836,
            53750600,
            53751425,
            53750020,
            53750391,
            53752273,
            53751033,
            53751621,
            53752004,
            53752815,
            53754220,
            53751629,
            53753641,
            53751893,
            53752886,
            53751070,
            53756767,
            53753219
        ],
        "B": [
            53748291,
            53748052,
            53748376,
            53747817,
            53748626,
            53748146,
            53748574,
            53749401,
            53805701,
            53749421,
            53749906,
            53748692,
            53758550,
            53750610,
            53749077,
            53749412,
            53749393,
            53748736,
            53751212
        ],
        "A": [
            53746666,
            53746560,
            53746976,
            53746641,
            53746514,
            53746879,
            53746868,
            53747863,
            53805694,
            53747143,
            53747013,
            53746924,
            53746595,
            53746573,
            53747849,
            53746548,
            53747762,
            53747182,
            53748613
        ]
    },
    "name": "D. Chladni Figure",
    "statement": "Inaka has a disc, the circumference of which is n units. The\r\ncircumference is equally divided by n points numbered clockwise from 1\r\nto n, such that points i and i + 1 (1\r\nleq i < n) are adjacent, and so are points n and 1.There are m straight\r\nsegments on the disc, the endpoints of which are all among the\r\naforementioned n points.Inaka wants to know if her image is , i.e. if\r\nthere is an integer k (1\r\nleq k < n), such that if all segments are rotated clockwise around the\r\ncenter of the circle by k units, the new image will be the same as the\r\noriginal one.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N, M;\n\nll chord(ll x, ll y)\n{\n    x %= N;\n    y %= N;\n    if (x > y) swap(x, y);\n    return (x << 32) | y;\n}\n\nll rotate(ll c, int a)\n{\n    ll y = c & ((1LL << 32) - 1);\n    ll x = (c >> 32);\n    return chord(x + a, y + a);\n}\n\nint main()\n{\n    unordered_set<ll> us;\n    vector<ll> cs;\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 0; i < M; ++i) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        ll c = chord(x, y);\n        cs.push_back(c);\n        us.insert(c);\n    }\n\n    for (int i = 1; i < N; ++i) {\n        if (N % i) continue;\n        int ok = true;\n        for (auto& x : cs) {\n            if (!us.count(rotate(x, i))) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n    printf(\"No\\n\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "number theory",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Chladni Figure.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "Let's brute force the value of k\n and check if it's possible to rotate the image by k\n to get the same image. We can do this by iterating through all segments (a,b)\n, and checking that (a+k,b+k)\n is a segment (the endpoints taken modulo n\n if needed).\n\nThis gives an O(nm)\n solution, however, you can notice that we only need to check divisors of n\n rather than all values from 1\n to n\n. This is because the set of segments (a,b),(a+k,b+k),(a+2k,b+2k),\n is exactly equal to (a,b),(a+gcd(n,k),b+gcd(n,k)),(a+2gcd(n,k),b+2gcd(n,k)),\n. Thus, this take O(m?d(n))\n, where d(n)\n denotes the number of divisors of n\n, which is fast enough to pass this problem.\n\nThere is also a faster linear time solution. We can reduce this to a problem of finding the largest period of a string. For every point, we can sort the length of the segments starting from that point (length in this case refers to clockwise distance). We also add some null character to denote a point. For instance, the first sample case's string might start like 2,?1,?1,4,8,10,?1,\n that represent the points from 1\n to 3\n. Such a string can be computed in O(mlogm)\n time. Then, after finding this string, we just want to check the period is bigger than 1\n. Let w\n be the length of the string. We can find this by concatenating the string to itself, then use z-algorithm to check if there is any is any index i\n from 1\n to w?1\n that is at least w\n.",
    "hint": []
}