{
    "link": "https://codeforces.com//contest/518/problem/F",
    "problemId": "22991",
    "problem_idx": "F",
    "shortId": "518F",
    "contest_number": "518",
    "problem_submissions": {
        "C": [
            9988883,
            9986333,
            9990862,
            9987399,
            9998129,
            9989956,
            9985416,
            9991301,
            9988773,
            9987777,
            9986792,
            9990874,
            9996855,
            9993083,
            9991646,
            9993492,
            9989796
        ],
        "B": [
            9986603,
            9991969,
            9985412,
            9984010,
            9991935,
            9983836,
            9985675,
            9984464,
            9984814,
            9987730,
            9987512,
            9987182,
            9990867,
            9988157,
            9985156,
            9986048
        ],
        "D": [
            9984146,
            9987656,
            9983589,
            9996581,
            9988389,
            9983991,
            10019512,
            9994388,
            9990798,
            9998733,
            9989910,
            9992602,
            9994055,
            9988668,
            9997395,
            9994329,
            10003029
        ],
        "A": [
            9982691,
            9984919,
            9983532,
            9982857,
            9984890,
            9982599,
            9983377,
            9983139,
            9982876,
            10006211,
            9984273,
            10016035,
            9996459,
            9986695,
            9983905
        ],
        "F": [
            9995207,
            10007934
        ],
        "E": [
            10000287,
            10002761,
            10005947,
            10001378,
            9999399,
            10002023,
            10011774
        ]
    },
    "name": "F. Pasha and Pipe",
    "statement": "On a certain meeting of a ruling party \"\" minister Pavel suggested to\r\nimprove the sewer system and to create a new pipe in the city.The city\r\nis an rectangular squared field. Each square of the field is either\r\nempty (then the pipe can go in it), or occupied (the pipe cannot go in\r\nsuch square). Empty squares are denoted by character ”, occupied squares\r\nare denoted by character ”.The pipe must meet the following criteria:\r\nthe pipe is a polyline of width , the pipe goes in empty squares, the\r\npipe starts from the edge of the field, but not from a corner square,\r\nthe pipe ends at the edge of the field but not in a corner square, the\r\npipe has at most turns ( degrees), the border squares of the field must\r\nshare squares with the pipe, if the pipe looks like a single segment,\r\nthen the end points of the pipe must lie on distinct edges of the field,\r\nfor each non-border square of the pipe there are side-adjacent squares\r\nthat also belong to the pipe, for each border square of the pipe there\r\nis side-adjacent cell that also belongs to the pipe. Here are some\r\nsamples of piping routes: .... .... .*.. ***** ****. .***. .... ..*.\r\n..*. ... ..* ..* ..... ...*. ...*.Here are some samples of piping\r\nroutes: .**. *... .*.* ..... ****. .*.*. .... ..*. .**. ... ..* *.*\r\n..... ...*. .***.In these samples the pipes are represented by\r\ncharacters ”.You were asked to write a program that calculates the\r\nnumber of distinct ways to make exactly one pipe in the city. The two\r\nways to make a pipe are considered distinct if they are distinct in at\r\nleast one square.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <memory.h>                     \n#include <fstream>\n#include <queue>\n#include <vector>\n\nusing namespace std;  \n\nint a[2222][2222], n, m, b[2222], c[2222], d[2222];\nint sum[2222][2222];\nlong long answer; \n\nint getsum(int x1, int y1, int x2, int y2) {\n\treturn sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];\n}          \n\nvoid addRow(int l, int r) {\n\tlong long k = d[r] - d[l - 1] + c[r] - c[l - 1];\n\tlong long h = 0;\n\tfor (int i = l; i <= r; ++i) {\n\t\tint k1 = k - (d[i] - d[i - 1]) - (c[i] - c[i - 1]);\n\t\tint k2 = k - k1;\n\t\th += (long long)k1 * (long long)k2;\n\t}\t\n\tanswer += (h / 2);\t\n}\n\nvoid addColumn(int l, int r) {\n\taddRow(l, r);  \n}\n                             \nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout); \n\tscanf(\"%d %d\\n\", &n, &m);  \t\n\tstring s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tgetline(cin, s);\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\t//a[i][j] = 0;\n\t\t\tif (s[j - 1] == '.') a[i][j] = 0; else a[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tsum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];\n\t\t}\n\t}\n\tfor (int i = 2; i + 1 <= n; ++i) {\n\t\tif (getsum(i, 1, i, m) == 0) ++answer;\t\t\t\t\n\t}\n\tfor (int i = 2; i + 1 <= m; ++i) {\n\t\tif (getsum(1, i, n, i) == 0) ++answer;\n\t}\n\n\tfor (int i = 2; i + 1<= n; ++i) {\n\t\tfor (int j = 2; j + 1 <= m; ++j) {\n\t\t\tint q1 = getsum(i, 1, i, j);\n\t\t\tint q2 = getsum(i, j, i, m);\n\t\t\tint q3 = getsum(1, j, i, j);\n\t\t\tint q4 = getsum(i, j, n, j);\n\t\t\tint cnt1 = 0, cnt2 = 0;\n\t\t\tif (q1 == 0) ++cnt1;\n\t\t\tif (q2 == 0) ++cnt1;\n\t\t\tif (q3 == 0) ++cnt2;\n\t\t\tif (q4 == 0) ++cnt2;\n\t\t\tanswer += (long long)(cnt1 * cnt2);\n\t\t}\n\t}\n\t\n\tfor (int j = 2; j + 1 <= m; ++j) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tb[i] = a[i][j];\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tc[i] = 0; \n\t\t\td[i] = 0;   \t\n\t\t\tif (getsum(i, 1, i, j) == 0) ++c[i];\n\t\t\tif (getsum(i, j, i, m) == 0) ++d[i];\n\t\t}   \n\t\n\t\tc[0] = 0, d[0] = 0;\n\t\tfor (int i = 1; i <= n; ++i) c[i] = c[i - 1] + c[i], d[i] = d[i - 1] + d[i];    \n\n\n\t\tint l = 2;\n\t\twhile (l < n) {\n\t\t\tif (b[l] == 1) ++l; else {\n\t\t\t\tint r = l;\n\t\t\t\twhile (r < n && b[r] == 0) ++r; --r;\n\t\t\t\taddRow(l, r);\n\t\t\t\tl = r + 1;\n\t\t\t}\n\t\t}   \n\t}\n\n\n\tfor (int i = 2; i + 1 <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tb[j] = a[i][j];\n\t\t}\n\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tc[j] = 0;\n\t\t\td[j] = 0;\n\t\t\tif (getsum(1, j, i, j) == 0) ++c[j];\n\t\t\tif (getsum(i, j, n, j) == 0) ++d[j];\n\t\t}\n\t\t\n\t\tc[0] = 0, d[0] = 0;\n\t\tfor (int j = 1; j <= m; ++j) c[j] = c[j - 1] + c[j], d[j] = d[j - 1] + d[j];\n\n\t\tint l = 2;\n\t\twhile (l < m) {\n\t\t\tif (b[l] == 1) ++l; else {\n\t\t\t\tint r = l;\n\t\t\t\twhile (r < m && b[r] == 0) ++r; --r;\n\t\t\t\taddColumn(l, r);\n\t\t\t\tl = r + 1;\n\t\t\t}\n\t\t} \n\t}    \n\n\tfor (int i = 2; i + 1 <= n; ++i) {     \n\t\tfor (int j = 2; j + 1 <= m; ++j) {\n\t\t\tif (a[i][j] == 0 && a[i + 1][j] == 0 && i + 1 < n) {\n\t\t\t\tint h1 = getsum(i, 1, i, j), h2 = getsum(i, j, i, m);\n\t\t\t\tint h3 = getsum(i + 1, 1, i + 1, j), h4 = getsum(i + 1, j, i + 1, m);\n\t\t\t\tif (h1 == 0 && h3 == 0) --answer;\n\t\t\t\tif (h2 == 0 && h4 == 0) --answer;\n\t\t\t}\n\t\t\tif (a[i][j] == 0 && a[i][j + 1] == 0 && j + 1 < m) {\n\t\t\t\tint h1 = getsum(1, j, i, j), h2 = getsum(i, j, n, j);\n\t\t\t\tint h3 = getsum(1, j + 1, i, j + 1), h4 = getsum(i, j + 1, n, j + 1);\t\n\t\t\t\tif (h1 == 0 && h3 == 0) --answer;\n\t\t\t\tif (h2 == 0 && h4 == 0) --answer;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << answer << endl;\n\n\treturn 0;\n}                           "
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "dp",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Pasha and Pipe.json",
    "editorial_link": "https://codeforces.com//blog/entry/16598",
    "editorial": "At first let's count two two-dimensional arrays of prefix sums sumv[][] and sumg[][]. In sumv[i][j] store how many grids are in column j beginning from row 1 to row i. In sumg[i][j] store how many grid are in row i beginning from column 1 to column j.\n\nLet's count ans0  how many pipes without bending we can pave. Count how many vertical pipes  we can pave. Iterate on j from 2 to m??1 and, if sumg[n][j]??sumg[n][0]?=?0 (i. e. in this column zero grids), increase ans0 on one. Similary count number of horizontal pipes.\n\nLet's count ans1  how many pipes with 1 bending we can pave. We need to brute cell, in which will bending. There are four cases. Let's consider first case, others we can count similary. This case  pipe begin in left column, go to current cell in brute and then go to top row. If brute cell in row i and column j then to ans1 we need to add one, if (sumg[i][j]??sumg[i][0])?+?(sumv[i][j]??sumv[0][j])?=?0.\n\nLet's count ans2  how many pipes with 2 bendings we can pave. Let's count how many tunes begin from top row and end in top or bottom row and add this number to ans2. Then rotate our matrix three times on 90 degrees and after every rotate add to ans2 count of pipes, which begin from top row and end in top or bottom row. Then we need divide ans2 to 2, because every pipe will count twice.\n\nHow we can count to current matrix how many pipes begin from top row and end in top or bottom row? Let's count four two-dimension arrays lf[][], rg[][], sumUp[][], sumDown[][]. If i  number of row, j  number of column of current cell, then in position (i,?lf[i][j]) in matrix are nearest from left grid for cell (i,?j), and in position (i,?rg[i][j]) in matrix are nearest from right grid for cell (i,?j). sumUp[i][j]  how many columns without grids are in submatrix from (1,?1) to (i,?j) of given matrix. sumDown[i][j]  how many columns without grids are in submatrix from (i,?1) to (n,?j) of given matrix. Then let's brute cell in which will be the first bending of pipe (pipe goes from top row and in this cell turned to left or to right), check, that in column j above this cell 0 grids, with help of arrays lf and rg find out as far as pipe can go to left or to right and with help of arrays sumUp and sumDown carefully update answer.\n\nNow print number ans1?+?ans2?+?ans3.\n\nAsymptotic behavior of this solution  O(n?*?m?*?const), where n  hoew many rows in given matrix, m  how many columns in given matrix, const takes different values depending on the implementation, in solution from editorial const?=?10.",
    "hint": []
}