{"link": "https://codeforces.com//contest/935/problem/E", "problemId": "158425", "problem_idx": "E", "shortId": "935E", "contest_number": "935", "problem_submissions": {"E": [35490294, 35492393, 35493358, 35495709, 35495541, 35493647, 35499422, 35499276, 35500262, 35500719, 35500162, 35500658, 35500728, 35499258, 35501222, 35495668, 35497342, 35498886], "D": [35486074, 35488065, 35489775, 35490762, 35489358, 35485225, 35484887, 35488795, 35492000, 35489470, 35491505, 35486948, 35491669, 35491916, 35491520, 35489051, 35488153, 35487210], "C": [35484257, 35486190, 35486639, 35485548, 35486272, 35495170, 35490125, 35484897, 35485714, 35486561, 35487356, 35493330, 35488504, 35487181, 35485279, 35490239], "B": [35480395, 35480198, 35480227, 35479698, 35479918, 35483145, 35479197, 35480428, 35479972, 35480181, 35482318, 35482750, 35481424, 35486459, 35478821, 35479749, 35480541, 35480932], "A": [35478116, 35476883, 35477273, 35476648, 35476835, 35476757, 35476798, 35478023, 35477705, 35477042, 35477472, 35478918, 35478074, 35478028, 35476637, 35476753, 35478890, 35477831], "F": [42089787, 35507058]}, "name": "E. Fafa and Ancient Mathematics", "statement": "Ancient Egyptians are known to have understood difficult concepts in\r\nmathematics. The ancient Egyptian mathematician Ahmes liked to write a\r\nkind of arithmetic expressions on papyrus paper which he called as .An\r\ncan be defined as: \"\" is an Ahmes arithmetic expression, where is a\r\none-digit positive integer; \"\" is an Ahmes arithmetic expression, where\r\nand are valid Ahmes arithmetic expressions (without spaces) and is\r\neither plus or minus . For example , and are valid Ahmes arithmetic\r\nexpressions.On his trip to Egypt, Fafa found a piece of papyrus paper\r\nhaving one of these Ahmes arithmetic expressions written on it. Being\r\nvery ancient, the papyrus piece was very worn out. As a result, all the\r\noperators were erased, keeping only the numbers and the brackets. Since\r\nFafa loves mathematics, he decided to challenge himself with the\r\nfollowing task:Given the number of plus and minus operators in the\r\noriginal expression, find out the maximum possible value for the\r\nexpression on the papyrus paper after putting the plus and minus\r\noperators in the place of the original erased operators.\r\n", "solutions": ["#pragma GCC optimize(\"inline\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int maxn = 1e4, maxk = 100;\nconst int inf = 1e9;\n\ninline void Min(int &a, int b) {\n  if (b < a) a = b;\n}\n\ninline void Max(int &a, int b) {\n  if (b > a) a = b;\n}\n\nstruct Node {\n  int lc, rc;\n} node[maxn];\n\nint cnt_node, n;\nchar s[maxn + 1];\n\nint size[maxn];\nint dpmax[maxn][maxk + 2];\nint dpmin[maxn][maxk + 2];\n\nint cntplus, cntminus;\nchar special;\n\nint cur;\n\nint Build(void) {\n  if (isdigit(s[cur])) {\n    node[cnt_node] = {-1, s[cur++] - '0'};\n    return cnt_node++;\n  }\n  int u = cnt_node++;\n  ++cur;\n  node[u].lc = Build();\n  ++cur;\n  node[u].rc = Build();\n  ++cur;\n  return u;\n}\n\nvoid Calc(int u) {\n  if (node[u].lc == -1) {\n    size[u] = 0;\n    dpmax[u][0] = dpmin[u][0] = node[u].rc;\n  } else {\n    int a = node[u].lc, b = node[u].rc;\n    size[u] = min(size[a] + size[b] + 1, maxk);\n    for (int i = 0; i <= size[u]; ++i) {\n      dpmax[u][i] = -inf;\n      dpmin[u][i] = inf;\n    }\n    for (int i = 0; i <= size[a]; ++i) {\n      for (int j = 0; j <= size[b]; ++j) {\n        if (i + j > size[u]) continue;\n        // take min\n        Min(dpmin[u][i + j + (special == '+')],\n            dpmin[a][i] + dpmin[b][j]);\n        Min(dpmin[u][i + j + (special == '-')],\n            dpmin[a][i] - dpmax[b][j]);\n        // take max\n        Max(dpmax[u][i + j + (special == '+')],\n            dpmax[a][i] + dpmax[b][j]);\n        Max(dpmax[u][i + j + (special == '-')],\n            dpmax[a][i] - dpmin[b][j]);\n      }\n    }\n  }\n}\n\nint main(void) {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  Build();\n  scanf(\"%d%d\", &cntplus, &cntminus);\n  if (cntplus < cntminus) {\n    special = '+';\n  } else {\n    special = '-';\n  }\n  for (int i = cnt_node - 1; i >= 0; --i) {\n    Calc(i);\n  }\n  printf(\"%d\\n\", dpmax[0][min(cntplus, cntminus)]);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "trees"], "dificulty": "2300", "interactive": false}