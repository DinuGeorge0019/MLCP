{"link": "https://codeforces.com//contest/69/problem/E", "problemId": "374", "problem_idx": "E", "shortId": "69E", "contest_number": "69", "problem_submissions": {"C": [349894, 349614, 350523, 349560, 350776, 350549, 351000, 349942, 666908, 350133, 349952, 349426, 350282, 349696, 349722, 349869, 350920, 349777], "B": [349465, 348708, 348893, 348837, 348839, 349036, 348717, 349280, 348895, 349174, 349021, 348740, 348850, 349870, 349250, 348865, 349111, 348964, 348915], "D": [349262, 349874, 349968, 350206, 350117, 351057, 350472, 350799, 615053, 350148, 350408, 351180, 351030, 352036, 351421, 350961], "E": [349012, 349182, 349347, 349788, 349489, 349727, 349844, 350290, 615043, 349763, 350933, 350789, 349750, 350850, 349215, 348791, 349522, 349971, 350071, 349597, 349978], "A": [348235, 348170, 348402, 348178, 348224, 348337, 348855, 348930, 445218, 348306, 348777, 348388, 348282, 348181, 348122, 348360, 348165, 348416, 348199, 348278]}, "name": "E. Subsegments", "statement": "Programmer Sasha has recently begun to study data structures. His coach\r\nStas told him to solve the problem of finding a minimum on the segment\r\nof the array in , which Sasha coped with. For Sasha not to think that he\r\nhad learned all, Stas gave him a new task. For each segment of the fixed\r\nlength Sasha must find the maximum element of those that occur on the\r\ngiven segment exactly once. Help Sasha solve this problem.\r\n", "solutions": ["#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N , K , A[111111] ;\nmap < int , int > Count ;\nset < int > Myset ;\n\nint main()\n{\n\tscanf( \"%d%d\" , &N , &K ) ;\n\tfor ( int i = 1 ; i <= N ; i ++ ) {\n\t\tscanf( \"%d\" , &A[i] ) ;\n\t\tCount[A[i]] = 0 ;\n\t}\n\tfor ( int i = 1 ; i < K ; i ++ ) {\n\t\tCount[A[i]] ++ ;\n\t\tif ( Count[A[i]] == 1 ) Myset.insert( A[i] ) ;\n\t\tif ( Count[A[i]] == 2 ) Myset.erase( A[i] ) ;\n\t}\n\tfor ( int i = K ; i <= N ; i ++ ) {\n\t\tCount[A[i]] ++ ;\n\t\tif ( Count[A[i]] == 1 ) Myset.insert( A[i] ) ;\n\t\tif ( Count[A[i]] == 2 ) Myset.erase( A[i] ) ;\n\t\tif ( Myset.size() == 0 ) {\n\t\t\tprintf( \"Nothing\\n\" ) ;\n\t\t} else {\n\t\t\tprintf( \"%d\\n\" , *Myset.rbegin() ) ;\n\t\t}\n\t\tCount[A[i-K+1]] -- ;\n\t\tif ( Count[A[i-K+1]] == 1 ) Myset.insert( A[i-K+1] ) ;\n\t\tif ( Count[A[i-K+1]] == 0 ) Myset.erase( A[i-K+1] ) ;\n\t}\n\treturn 0 ;\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "1800", "interactive": false}