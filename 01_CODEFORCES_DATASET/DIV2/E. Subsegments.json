{
    "link": "https://codeforces.com//contest/69/problem/E",
    "problemId": "374",
    "problem_idx": "E",
    "shortId": "69E",
    "contest_number": "69",
    "problem_submissions": {
        "C": [
            349894,
            349614,
            350523,
            349560,
            350776,
            350549,
            351000,
            349942,
            666908,
            350133,
            349952,
            349426,
            350282,
            349696,
            349722,
            349869,
            350920,
            349777
        ],
        "B": [
            349465,
            348708,
            348893,
            348837,
            348839,
            349036,
            348717,
            349280,
            348895,
            349174,
            349021,
            348740,
            348850,
            349870,
            349250,
            348865,
            349111,
            348964,
            348915
        ],
        "D": [
            349262,
            349874,
            349968,
            350206,
            350117,
            351057,
            350472,
            350799,
            615053,
            350148,
            350408,
            351180,
            351030,
            352036,
            351421,
            350961
        ],
        "E": [
            349012,
            349182,
            349347,
            349788,
            349489,
            349727,
            349844,
            350290,
            615043,
            349763,
            350933,
            350789,
            349750,
            350850,
            349215,
            348791,
            349522,
            349971,
            350071,
            349597,
            349978
        ],
        "A": [
            348235,
            348170,
            348402,
            348178,
            348224,
            348337,
            348855,
            348930,
            445218,
            348306,
            348777,
            348388,
            348282,
            348181,
            348122,
            348360,
            348165,
            348416,
            348199,
            348278
        ]
    },
    "name": "E. Subsegments",
    "statement": "Programmer Sasha has recently begun to study data structures. His coach\r\nStas told him to solve the problem of finding a minimum on the segment\r\nof the array in , which Sasha coped with. For Sasha not to think that he\r\nhad learned all, Stas gave him a new task. For each segment of the fixed\r\nlength Sasha must find the maximum element of those that occur on the\r\ngiven segment exactly once. Help Sasha solve this problem.\r\n",
    "solutions": [
        "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N , K , A[111111] ;\nmap < int , int > Count ;\nset < int > Myset ;\n\nint main()\n{\n\tscanf( \"%d%d\" , &N , &K ) ;\n\tfor ( int i = 1 ; i <= N ; i ++ ) {\n\t\tscanf( \"%d\" , &A[i] ) ;\n\t\tCount[A[i]] = 0 ;\n\t}\n\tfor ( int i = 1 ; i < K ; i ++ ) {\n\t\tCount[A[i]] ++ ;\n\t\tif ( Count[A[i]] == 1 ) Myset.insert( A[i] ) ;\n\t\tif ( Count[A[i]] == 2 ) Myset.erase( A[i] ) ;\n\t}\n\tfor ( int i = K ; i <= N ; i ++ ) {\n\t\tCount[A[i]] ++ ;\n\t\tif ( Count[A[i]] == 1 ) Myset.insert( A[i] ) ;\n\t\tif ( Count[A[i]] == 2 ) Myset.erase( A[i] ) ;\n\t\tif ( Myset.size() == 0 ) {\n\t\t\tprintf( \"Nothing\\n\" ) ;\n\t\t} else {\n\t\t\tprintf( \"%d\\n\" , *Myset.rbegin() ) ;\n\t\t}\n\t\tCount[A[i-K+1]] -- ;\n\t\tif ( Count[A[i-K+1]] == 1 ) Myset.insert( A[i-K+1] ) ;\n\t\tif ( Count[A[i-K+1]] == 0 ) Myset.erase( A[i-K+1] ) ;\n\t}\n\treturn 0 ;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Subsegments.json",
    "editorial_link": "https://codeforces.com//blog/entry/1571",
    "editorial": "To solve this problem you have to do a \"move\" subsegment and know :\n\n 1. The set B of numbers, meeting once, with the function of extracting the maximum for O (logN)\n\n2.The set of numbers appearing on this subsegments with keeping the number of times,that this number is found on this subsegments, with function of verifying how many times the number in this subsegments for O (logN).\n\n \n\nWhile moving a segment from (a[i] .. a[i + k - 1]) for 1 item left (a[I + 1] .. a[I + k]) you have to:\n\n1) Check whether a[i] with a[I + k]. If yes, then there is no need to modify the set, otherwise proceed to item 2 and 3.\n\n2) Check how many times we have a[i] in the set A: if 2, then add a[i] to B, if 1, then remove it from  A and B. Do not forget to reduce the corresponding number of occurrences of a[i] in the current segment 1.\n\n3) Check, how many times we have a[I + k] in the set A: if 0, then add a[i] in the B and A, if 1, then remove it from B. Do not forget to increase the corresponding number of occurrences of a[i] the current interval to 1.\n\n \n\nAfter that, if the set is not empty, we should take peak from it.\n\n \n\nSo the asymptotics of this process will be O(NlogN).",
    "hint": []
}