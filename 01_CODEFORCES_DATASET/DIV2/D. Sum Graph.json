{"link": "https://codeforces.com//contest/1816/problem/D", "problemId": "1871640", "problem_idx": "D", "shortId": "1816D", "contest_number": "1816", "problem_submissions": {"F": [201571165, 201575603], "E": [201540535, 201521580, 201552172, 201540274, 201551497, 201560232, 201559664, 201557564, 201560804, 201563162, 201561880, 201537774, 201526707, 201515322, 201535371, 201540257, 201545215], "D": [201526272, 201555297, 201531457, 201549839, 201530007, 201538289, 201538409, 201545276, 201541091, 201540016, 201546751, 201561431], "C": [201502393, 201505622, 201493541, 201488761, 201501981, 201485106, 201492364, 201508062, 201504590, 201507370, 201512800, 201550313, 201501935, 201545685, 201512228, 201507426, 201505339], "B": [201495797, 201498113, 201488843, 201489011, 201486184, 201503986, 201518658, 201489822, 201495126, 201490303, 201498690, 201494781, 201494291, 201504455, 201496973, 201494497, 201495296], "A": [201482599, 201481556, 201482965, 201480957, 201481143, 201486345, 201502905, 201481407, 201481488, 201481674, 201480959, 201483748, 201481910, 201493735, 201483634, 201482175, 201488121]}, "name": "D. Sum Graph", "statement": "There is a hidden permutation p_1, p_2,\r\ndots, p_n. Consider an undirected graph with n nodes only with no edges.\r\nYou can make two types of queries: Specify an integer x satisfying 2\r\nle x\r\nle 2n. For all integers i (1\r\nle i\r\nle n) such that 1\r\nle x-i\r\nle n, an edge between node i and node x-i will be added. Query the\r\nnumber of in the shortest path between node p_i and node p_j. As the\r\nanswer to this question you will get the number of edges in the shortest\r\npath if such a path exists, or -1 if there is no such path. Note that\r\nyou can make both types of queries in order.Within 2n queries (including\r\ntype 1 and type 2), guess two possible permutations, at least one of\r\nwhich is p_1, p_2,\r\ndots, p_n. You get accepted if at least one of the permutations is\r\ncorrect. You are allowed to guess the same permutation twice.A\r\npermutation of length n is an array consisting of n distinct integers\r\nfrom 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n", "solutions": ["//\n//  main.cpp\n//  D\n//\n//  Created by Thomas Guo on 2023-04-09.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define maxn 1002\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\nusing namespace std;\nint dis[maxn], fp[maxn], rp[maxn];\nint main(){\n    int t;cin>>t;\n    while(t--){\n        int n;cin>>n;\n        cout<<\"+ \"<<n+1<<endl;\n        int result;cin>>result;\n        if(result == -2){\n            return 0;\n        }\n        cout<<\"+ \"<<n+2<<endl;\n        cin>>result;\n        if(result == -2){\n            return 0;\n        }\n        int maxdis = 0, farthest = 1;\n        dis[1] = 0;\n        for(int i = 2; i <= n; i++){\n            cout<<\"? 1 \"<<i<<endl;\n            cin>>result;\n            if(result == -2){\n                return 0;\n            }\n            else{\n                dis[i] = result;\n                if(dis[i] > maxdis){\n                    maxdis = dis[i];\n                    farthest = i;\n                }\n            }\n        }\n        dis[farthest] = 0;\n        for(int i = 1; i <= n; i++){\n            if(i == farthest){\n                continue;\n            }\n            cout<<\"? \"<<farthest<<\" \"<<i<<endl;\n            cin>>result;\n            if(result == -2){\n                return 0;\n            }\n            else{\n                dis[i] = result;\n            }\n        }\n        vector<pii> points;\n        vector<int> forward, reverse;\n        for(int i = 1; i <= n; i++){\n            points.pb(mp(dis[i], i));\n        }\n        sort(points.begin(), points.end());\n        int lo = 1, hi = n;\n        for(int i = 1; i <= n; i++){\n            if(i % 2 == 1){\n                forward.pb(lo);\n                lo++;\n            }\n            else{\n                forward.pb(hi);\n                hi--;\n            }\n        }\n        for(int i = n-1; i >= 0; i--){\n            reverse.pb(forward[i]);\n        }\n        for(int i = 0; i < n; i++){\n            fp[points[i].second] = forward[i];\n            rp[points[i].second] = reverse[i];\n        }\n        cout<<\"! \";\n        for(int i = 1; i <= n; i++){\n            cout<<fp[i]<<\" \";\n        }\n        for(int i = 1; i <= n; i++){\n            cout<<rp[i]<<\" \";\n        }\n        cout<<endl;\n        cin>>result;\n        if(result == -2){\n            return 0;\n        }\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "implementation", "interactive", "shortest paths", "trees"], "dificulty": "2000", "interactive": false}