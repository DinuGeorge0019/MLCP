{
    "link": "https://codeforces.com//contest/1816/problem/D",
    "problemId": "1871640",
    "problem_idx": "D",
    "shortId": "1816D",
    "contest_number": "1816",
    "problem_submissions": {
        "F": [
            201571165,
            201575603
        ],
        "E": [
            201540535,
            201521580,
            201552172,
            201540274,
            201551497,
            201560232,
            201559664,
            201557564,
            201560804,
            201563162,
            201561880,
            201537774,
            201526707,
            201515322,
            201535371,
            201540257,
            201545215
        ],
        "D": [
            201526272,
            201555297,
            201531457,
            201549839,
            201530007,
            201538289,
            201538409,
            201545276,
            201541091,
            201540016,
            201546751,
            201561431
        ],
        "C": [
            201502393,
            201505622,
            201493541,
            201488761,
            201501981,
            201485106,
            201492364,
            201508062,
            201504590,
            201507370,
            201512800,
            201550313,
            201501935,
            201545685,
            201512228,
            201507426,
            201505339
        ],
        "B": [
            201495797,
            201498113,
            201488843,
            201489011,
            201486184,
            201503986,
            201518658,
            201489822,
            201495126,
            201490303,
            201498690,
            201494781,
            201494291,
            201504455,
            201496973,
            201494497,
            201495296
        ],
        "A": [
            201482599,
            201481556,
            201482965,
            201480957,
            201481143,
            201486345,
            201502905,
            201481407,
            201481488,
            201481674,
            201480959,
            201483748,
            201481910,
            201493735,
            201483634,
            201482175,
            201488121
        ]
    },
    "name": "D. Sum Graph",
    "statement": "There is a hidden permutation p_1, p_2,\r\ndots, p_n. Consider an undirected graph with n nodes only with no edges.\r\nYou can make two types of queries: Specify an integer x satisfying 2\r\nle x\r\nle 2n. For all integers i (1\r\nle i\r\nle n) such that 1\r\nle x-i\r\nle n, an edge between node i and node x-i will be added. Query the\r\nnumber of in the shortest path between node p_i and node p_j. As the\r\nanswer to this question you will get the number of edges in the shortest\r\npath if such a path exists, or -1 if there is no such path. Note that\r\nyou can make both types of queries in order.Within 2n queries (including\r\ntype 1 and type 2), guess two possible permutations, at least one of\r\nwhich is p_1, p_2,\r\ndots, p_n. You get accepted if at least one of the permutations is\r\ncorrect. You are allowed to guess the same permutation twice.A\r\npermutation of length n is an array consisting of n distinct integers\r\nfrom 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "//\n//  main.cpp\n//  D\n//\n//  Created by Thomas Guo on 2023-04-09.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define maxn 1002\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\nusing namespace std;\nint dis[maxn], fp[maxn], rp[maxn];\nint main(){\n    int t;cin>>t;\n    while(t--){\n        int n;cin>>n;\n        cout<<\"+ \"<<n+1<<endl;\n        int result;cin>>result;\n        if(result == -2){\n            return 0;\n        }\n        cout<<\"+ \"<<n+2<<endl;\n        cin>>result;\n        if(result == -2){\n            return 0;\n        }\n        int maxdis = 0, farthest = 1;\n        dis[1] = 0;\n        for(int i = 2; i <= n; i++){\n            cout<<\"? 1 \"<<i<<endl;\n            cin>>result;\n            if(result == -2){\n                return 0;\n            }\n            else{\n                dis[i] = result;\n                if(dis[i] > maxdis){\n                    maxdis = dis[i];\n                    farthest = i;\n                }\n            }\n        }\n        dis[farthest] = 0;\n        for(int i = 1; i <= n; i++){\n            if(i == farthest){\n                continue;\n            }\n            cout<<\"? \"<<farthest<<\" \"<<i<<endl;\n            cin>>result;\n            if(result == -2){\n                return 0;\n            }\n            else{\n                dis[i] = result;\n            }\n        }\n        vector<pii> points;\n        vector<int> forward, reverse;\n        for(int i = 1; i <= n; i++){\n            points.pb(mp(dis[i], i));\n        }\n        sort(points.begin(), points.end());\n        int lo = 1, hi = n;\n        for(int i = 1; i <= n; i++){\n            if(i % 2 == 1){\n                forward.pb(lo);\n                lo++;\n            }\n            else{\n                forward.pb(hi);\n                hi--;\n            }\n        }\n        for(int i = n-1; i >= 0; i--){\n            reverse.pb(forward[i]);\n        }\n        for(int i = 0; i < n; i++){\n            fp[points[i].second] = forward[i];\n            rp[points[i].second] = reverse[i];\n        }\n        cout<<\"! \";\n        for(int i = 1; i <= n; i++){\n            cout<<fp[i]<<\" \";\n        }\n        for(int i = 1; i <= n; i++){\n            cout<<rp[i]<<\" \";\n        }\n        cout<<endl;\n        cin>>result;\n        if(result == -2){\n            return 0;\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "implementation",
        "interactive",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Sum Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/114899",
    "editorial": "There are many ways to solve this problem. My original solution is rather difficult to implement correctly, and a bit complicated. During round testing, tester rsj found an alternative solution, which is, in my opinion, one that's a lot easier to understand and implement.\n\nFirstly, use a type 1 operation on x=n+1\n and x=n+2\n (or you can do x=n\n and x=n+1\n). Then, the graph should look like a chain (e.g. when n=6\n, it should look like 1?6?2?5?3?4\n). Note that there are actually two edges between each pair of directly connected nodes, but it is irrelevant to the task.\n\nNext, use a type 2 query on all pairs of (1,i)\n where 2?i?n\n. Take the maximum of the query results. Let k\n be one of the values such that the query result of (1,k)\n is maximum among all (1,i)\n. It is easy to see that, node pk\n is one of the endpoints of the chain.\n\nAfterwards, use a type 2 query on all pairs of (k,i)\n where 1?i?n\n and i?k\n. Since node pk\n is an endpoint of the chain, all the query results are distinct and you can recover the exact node that each query result corresponds to.\n\nA problem arises that it is unclear about which endpoint node pk\n actually is. But this issue can be solved easily: since the problem allows outputting two permutations that can be p\n, just try both endpoints and output the corresponding permutations.\n\nIn total, 2\n type 1 operations and 2n?2\n type 2 operations are used, which sums up to 2n\n operations. As stated in the sample description, you don't even need any operations when n=2\n. It is also easy to see that the actual number of operations required is 2n?1\n since there is a pair of duplicate type 2 operations, but we allow duplicating the operation anyway."
}