{
    "link": "https://codeforces.com//contest/342/problem/E",
    "problemId": "3442",
    "problem_idx": "E",
    "shortId": "342E",
    "contest_number": "342",
    "problem_submissions": {
        "E": [
            4424475,
            4422829,
            4430368,
            4421720,
            4425588,
            4424864,
            7980137,
            4422643,
            4422969,
            33894142,
            33894120,
            12335279
        ],
        "D": [
            4422563,
            4424584,
            4422881,
            4425178,
            4424327
        ],
        "B": [
            4417892,
            4425509,
            4417934,
            4418698,
            4420332,
            4419060,
            4418029,
            4418641,
            4419108,
            4418926,
            4419003,
            4423078,
            4421488,
            4420712,
            4420147,
            4428238,
            4428202,
            4420216,
            4418853,
            4419150,
            4419856
        ],
        "A": [
            4417092,
            4417221,
            4417057,
            4417245,
            4417383,
            4417575,
            4417020,
            4417100,
            4417102,
            4419265,
            4417254,
            4417136,
            4419082,
            4418070,
            4418662,
            4418542,
            4417680,
            4417389,
            4417298
        ],
        "C": [
            4419537,
            4420363,
            4425253,
            4423789,
            4425489,
            4420140,
            4422038,
            4419838,
            4423331,
            4424488,
            4420343,
            4420820,
            4423363
        ]
    },
    "name": "E. Xenia and Tree",
    "statement": "Xenia the programmer has a tree consisting of nodes. We will consider\r\nthe tree nodes indexed from 1 to . We will also consider the first node\r\nto be initially painted red, and the other nodes to be painted blue.The\r\nbetween two tree nodes and is the number of edges in the shortest path\r\nbetween and .Xenia needs to learn how to quickly execute queries of two\r\ntypes: paint a specified blue node in red; calculate which red node is\r\nthe closest to the given one and print the shortest distance to the\r\nclosest red node. Your task is to write a program which will execute the\r\ndescribed queries.\r\n",
    "solutions": [
        "#define LOCAL\n\n/** ` Micro Mezzo Macro Flation -- Overheated Economy ., **/\n\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (n____=int(n),i=0;i<n____;++i)\n#define FOR_C_N(i, a, b) for (b____=int(b),i=a;i<b____;++i)\n#define DWN_C_N(i, b, a) for (a____=int(a),i=b-1;i>=a____;--i)\n#define REP_1_C_N(i, n) for (n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (a____=int(a),i=b;i>=a____;--i)\n\n#define ECH(it, A) for (typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define DO(n) while(n--)\n#define DO_C(n) int n____ = n; while(n____--)\n#define TO(i, a, b) int s_=a<b?1:-1,b_=b+s_;for(int i=a;i!=b_;i+=s_)\n#define TO_1(i, a, b) int s_=a<b?1:-1,b_=b;for(int i=a;i!=b_;i+=s_)\n#define SQZ(i, j, a, b) for (int i=int(a),j=int(b)-1;i<j;++i,--j)\n#define SQZ_1(i, j, a, b) for (int i=int(a),j=int(b);i<=j;++i,--j)\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, X) fP(ALL(A), X) // != A.end()\n#define CTN(T, x) (T.fP(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n\n#define Rush int T____; RD(T____); DO(T____)\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define Ruby system(\"ruby main.rb\")\n#define Haskell system(\"runghc main.hs\")\n#define Pascal system(\"fpc main.pas\")\n\ntypedef long long LL;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VD;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef set<LL> SL;\ntypedef set<DB> SD;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef map<LL, int> MLI;\ntypedef map<DB, int> MDI;\ntypedef map<int, bool> MIB;\ntypedef map<string, bool> MSB;\ntypedef map<LL, bool> MLB;\ntypedef map<DB, bool> MDB;\ntypedef pair<int, int> PII;\ntypedef pair<int, bool> PIB;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\ntypedef set<PII> SII;\ntypedef map<PII, int> MPIII;\ntypedef map<PII, bool> MPIIB;\n\n/** I/O Accelerator **/\n\n/* ... :\" We are I/O Accelerator ... Use us at your own risk ;) ... \" .. */\n\ntemplate<class T> inline void RD(T &);\ntemplate<class T> inline void OT(const T &);\n\ninline int RD(){ int x; RD(x); return x;}\ntemplate<class T> inline T& _RD(T &x){ RD(x); return x;}\ninline void RC(char &c){scanf(\" %c\", &c);}\ninline char RC(){ char x; RC(x); return x;}\ninline void RS(char *s){scanf(\"%s\", s);}\n\ntemplate<class T0, class T1> inline void RD(T0 &x0, T1 &x1){RD(x0), RD(x1);}\ntemplate<class T0, class T1, class T2> inline void RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6);}\ntemplate<class T0, class T1> inline void OT(T0 &x0, T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(T0 &x0, T1 &x1, T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\n\n\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){\n    while (!Q.empty()) Q.pop();\n}\n\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){\n    while (!Q.empty()) Q.pop();\n}\n\ntemplate<class T> inline void CLR(T &A){A.clear();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2){FLC(A0), FLC(A1), FLC(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3){FLC(A0), FLC(A1), FLC(A2), FLC(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4), FLC(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){FLC(A0), FLC(A1), FLC(A2), FLC(A3), FLC(A4), FLC(A5), FLC(A6);}\n\ntemplate<class T> inline void SRT(T &A){sort(ALL(A));}\ntemplate<class T, class C> inline void SRT(T &A, C B){sort(ALL(A), B);}\n\n/** Add - On **/\n\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = 3.14159265358979323846264; //M_PI;\n\n// <<= ` 0. Daily Use .,\n\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (b>a) a=b;}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(min(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\nint Ceil(int x, int y){return (x - 1) / y + 1;}\n\n// <<= ` 1. Bitwise Operation .,\ninline bool _1(int x, int i){return x & 1<<i;}\ninline bool _1(LL x, int i){return x & 1LL<<i;}\ninline LL _1(int i){return 1LL<<i;}\n//inline int _1(int i){return 1<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n//inline int _U(int i){return _1(i) - 1;};\n\n\ntemplate<class T> inline T low_bit(T x) {\n    return x & -x;\n}\n\ntemplate<class T> inline T high_bit(T x) {\n    T p = low_bit(x);\n    while (p != x) x -= p, p = low_bit(x);\n    return p;\n}\n\ninline int count_bits(int x){\n    x = (x & 0x55555555) + ((x & 0xaaaaaaaa) >> 1);\n    x = (x & 0x33333333) + ((x & 0xcccccccc) >> 2);\n    x = (x & 0x0f0f0f0f) + ((x & 0xf0f0f0f0) >> 4);\n    x = (x & 0x00ff00ff) + ((x & 0xff00ff00) >> 8);\n    x = (x & 0x0000ffff) + ((x & 0xffff0000) >> 16);\n    return x;\n}\n\ninline int count_bits(LL x){\n    x = (x & 0x5555555555555555LL) + ((x & 0xaaaaaaaaaaaaaaaaLL) >> 1);\n    x = (x & 0x3333333333333333LL) + ((x & 0xccccccccccccccccLL) >> 2);\n    x = (x & 0x0f0f0f0f0f0f0f0fLL) + ((x & 0xf0f0f0f0f0f0f0f0LL) >> 4);\n    x = (x & 0x00ff00ff00ff00ffLL) + ((x & 0xff00ff00ff00ff00LL) >> 8);\n    x = (x & 0x0000ffff0000ffffLL) + ((x & 0xffff0000ffff0000LL) >> 16);\n    x = (x & 0x00000000ffffffffLL) + ((x & 0xffffffff00000000LL) >> 32);\n    return x;\n}\n\nint reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\nLL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\n// <<= ` 2. Modular Arithmetic Basic .,\n\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int pow(int a, int b){\n    int c = 1;\n    while (b) {\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T>\ninline int pow(T a, int b){\n    T c(1);\n    while (b) {\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIA(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int sum(int a, int b, int MOD){\n    a += b; if (a >= MOD) a -= MOD;\n    return a;\n}\n\ninline int phi(int n){\n    int res = n;\n    for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n// <<= '9. Comutational Geometry .,\n\nstruct Po; struct Line; struct Seg;\n\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\nstruct Po{\n    DB x, y;\n    Po(DB _x = 0, DB _y = 0):x(_x), y(_y){}\n\n    friend istream& operator >>(istream& in, Po &p){return in >> p.x >> p.y;}\n    friend ostream& operator <<(ostream& out, Po p){return out << \"(\" << p.x << \", \" << p.y << \")\";}\n\n    friend bool operator ==(Po, Po);\n    friend bool operator !=(Po, Po);\n    friend Po operator +(Po, Po);\n    friend Po operator -(Po, Po);\n    friend Po operator *(Po, DB);\n    friend Po operator /(Po, DB);\n\n    bool operator < (const Po &rhs) const{return sgn(x, rhs.x) < 0 || sgn(x, rhs.x) == 0 && sgn(y, rhs.y) < 0;}\n    Po operator-() const{return Po(-x, -y);}\n    Po& operator +=(Po rhs){x += rhs.x, y += rhs.y; return *this;}\n    Po& operator -=(Po rhs){x -= rhs.x, y -= rhs.y; return *this;}\n    Po& operator *=(DB k){x *= k, y *= k; return *this;}\n    Po& operator /=(DB k){x /= k, y /= k; return *this;}\n\n    DB length_sqr(){return sqr(x) + sqr(y);}\n    DB length(){return sqrt(length_sqr());}\n\n    DB atan(){\n        return atan2(y, x);\n    }\n\n    void input(){\n        scanf(\"%lf %lf\", &x, &y);\n    }\n};\n\nbool operator ==(Po a, Po b){return sgn(a.x - b.x) == 0 && sgn(a.y - b.y) == 0;}\nbool operator !=(Po a, Po b){return sgn(a.x - b.x) != 0 || sgn(a.y - b.y) != 0;}\nPo operator +(Po a, Po b){return Po(a.x + b.x, a.y + b.y);}\nPo operator -(Po a, Po b){return Po(a.x - b.x, a.y - b.y);}\nPo operator *(Po a, DB k){return Po(a.x * k, a.y * k);}\nPo operator *(DB k, Po a){return a * k;}\nPo operator /(Po a, DB k){return Po(a.x / k, a.y / k);}\n\nstruct Line{\n    Po a, b;\n    Line(Po _a = Po(), Po _b = Po()):a(_a), b(_b){}\n    Line(DB x0, DB y0, DB x1, DB y1):a(Po(x0, y0)), b(Po(x1, y1)){}\n    Line(Seg);\n\n    friend ostream& operator <<(ostream& out, Line p){return out << p.a << \"-\" << p.b;}\n};\n\nstruct Seg{\n    Po a, b;\n    Seg(Po _a = Po(), Po _b = Po()):a(_a), b(_b){}\n    Seg(DB x0, DB y0, DB x1, DB y1):a(Po(x0, y0)), b(Po(x1, y1)){}\n    Seg(Line l);\n\n    friend ostream& operator <<(ostream& out, Seg p){return out << p.a << \"-\" << p.b;}\n    DB length(){return (b - a).length();}\n};\n\nLine::Line(Seg l):a(l.a), b(l.b){}\nSeg::Seg(Line l):a(l.a), b(l.b){}\n\n#define innerProduct dot\n#define scalarProduct dot\n#define dotProduct dot\n#define outerProduct det\n#define crossProduct det\n\ninline DB dot(DB x1, DB y1, DB x2, DB y2){return x1 * x2 + y1 * y2;}\ninline DB dot(Po a, Po b){return dot(a.x, a.y, b.x, b.y);}\ninline DB dot(Po p0, Po p1, Po p2){return dot(p1 - p0, p2 - p0);}\ninline DB dot(Line l1, Line l2){return dot(l1.b - l1.a, l2.b - l2.a);}\ninline DB det(DB x1, DB y1, DB x2, DB y2){return x1 * y2 - x2 * y1;}\ninline DB det(Po a, Po b){return det(a.x, a.y, b.x, b.y);}\ninline DB det(Po p0, Po p1, Po p2){return det(p1 - p0, p2 - p0);}\ninline DB det(Line l1, Line l2){return det(l1.b - l1.a, l2.b - l2.a);}\n\ntemplate<class T1, class T2> inline DB dist(T1 x, T2 y){return sqrt(dist_sqr(x, y));}\n\ninline DB dist_sqr(Po a, Po b){return sqr(a.x - b.x) + sqr(a.y - b.y);}\ninline DB dist_sqr(Po p, Line l){Po v0 = l.b - l.a, v1 = p - l.a; return sqr(fabs(det(v0, v1))) / v0.length_sqr();}\ninline DB dist_sqr(Po p, Seg l){\n    Po v0 = l.b - l.a, v1 = p - l.a, v2 = p - l.b;\n    if (sgn(dot(v0, v1)) * sgn(dot(v0, v2)) <= 0) return dist_sqr(p, Line(l));\n    else return min(v1.length_sqr(), v2.length_sqr());\n}\n\ninline DB dist_sqr(Line l, Po p){return dist_sqr(p, l);}\ninline DB dist_sqr(Seg l, Po p){return dist_sqr(p, l);}\n\ninline DB dist_sqr(Line l1, Line l2){\n    if (sgn(det(l1, l2)) != 0) return 0;\n    return dist_sqr(l1.a, l2);\n}\ninline DB dist_sqr(Line l1, Seg l2){\n    Po v0 = l1.b - l1.a, v1 = l2.a - l1.a, v2 = l2.b - l1.a; DB c1 = det(v0, v1), c2 = det(v0, v2);\n    return sgn(c1) != sgn(c2) ? 0 : sqr(min(fabs(c1), fabs(c2))) / v0.length_sqr();\n}\n\nbool isIntersect(Seg l1, Seg l2){\n\n    //if (l1.a == l2.a || l1.a == l2.b || l1.b == l2.a || l1.b == l2.b) return true;\n\n    return\n        min(l1.a.x, l1.b.x) <= max(l2.a.x, l2.b.x) &&\n        min(l2.a.x, l2.b.x) <= max(l1.a.x, l1.b.x) &&\n        min(l1.a.y, l1.b.y) <= max(l2.a.y, l2.b.y) &&\n        min(l2.a.y, l2.b.y) <= max(l1.a.y, l1.b.y) &&\n    sgn( det(l1.a, l2.a, l2.b) ) * sgn( det(l1.b, l2.a, l2.b) ) <= 0 &&\n    sgn( det(l2.a, l1.a, l1.b) ) * sgn( det(l2.b, l1.a, l1.b) ) <= 0;\n\n}\n\ninline DB dist_sqr(Seg l1, Seg l2){\n    if (isIntersect(l1, l2)) return 0;\n    else return min(dist_sqr(l1.a, l2), dist_sqr(l1.b, l2), dist_sqr(l2.a, l1), dist_sqr(l2.b, l1));\n}\n\ninline bool isOnExtremePoint(const Po &p, const Seg &l){\n    return p == l.a || p == l.b;\n}\n\ninline bool isOnseg(const Po &p, const Seg &l){\n\n    //if (p == l.a || p == l.b) return false;\n\n    return sgn(det(p, l.a, l.b)) == 0 &&\n        sgn(l.a.x, p.x) * sgn(l.b.x, p.x) <= 0 && sgn(l.a.y, p.y) * sgn(l.b.y, p.y) <= 0;\n}\n\ninline Po intersect(const Line &l1, const Line &l2){\n    return l1.a + (l1.b - l1.a) * (det(l2.a, l1.a, l2.b) / det(l2, l1));\n}\n\n// perpendicular foot\ninline Po intersect(const Po & p, const Line &l){\n    return intersect(Line(p, p + Po(l.a.y - l.b.y, l.b.x - l.a.x)), l);\n}\n\ninline Po rotate(Po p, DB alpha, Po o = Po()){\n    p.x -= o.x, p.y -= o .y;\n    return Po(p.x * cos(alpha) - p.y * sin(alpha), p.y * cos(alpha) + p.x * sin(alpha)) + o;\n}\n\n// <<= ' A. Random Event ..\n\ninline int rand32(){return (bool(rand() & 1) << 30) | (rand() << 15) + rand();}\ninline int random32(int l, int r){return rand32() % (r - l + 1) + l;}\ninline int random(int l, int r){return rand() % (r - l + 1) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return rand() % 2;}\n\n// <<= ' 0. I/O Accelerator interface .,\n\ntemplate<class T> inline void RD(T &x){\n    //cin >> x;\n    //scanf(\"%d\", &x);\n    char c; for (c = getchar(); c < '0'; c = getchar()); x = c - '0'; for (c = getchar(); c >= '0'; c = getchar()) x = x * 10 + c - '0';\n    //char c; c = getchar(); x = c - '0'; for (c = getchar(); c >= '0'; c = getchar()) x = x * 10 + c - '0';\n}\n\ntemplate<class T> inline void OT(const T &x){\n    printf(\"%d\\n\", x);\n}\n\n/* .................................................................................................................................. */\n\nconst int N = 100009, M = N * 2;\n\nint hd[N], prd[M], suc[M], to[M];\n// Adjcent List .. .\nint size[N], head[N], F[N], D[N], Hid[N];\n// Vertex .. .\nint n, nn;\n\n#define black(x) H[x].B[1]\n\n#define lx (x<<1)\n#define rx (lx|1)\n#define y (x>>1)\n\nstruct Heap{\n\n    VI B; int *H, *P;\n    int n;\n\nprivate:\n\n    inline int A(int x){return B[H[x]];}\n\n    void Swap(int a, int b){\n        swap(H[a], H[b]);\n        P[H[a]] = a, P[H[b]] = b;\n    }\n\n    inline void Up(int x){\n        while (A(y) > A(x)){\n            Swap(x, y), x = y;\n        }\n    }\n\n    inline void Down(int x){\n        int h = x; while (true){\n            if (lx <= n && A(lx) < A(h)) h = lx;\n            if (rx <= n && A(rx) < A(h)) h = rx;\n            if (h == x) break;\n            Swap(h, x), x = h;\n        }\n    }\n\npublic:\n\n    void Build(){\n        n = SZ(B); H = new int[n], P = new int[n]; --n;\n        FOR_1(i, 0, n) H[i] = P[i] = i; DWN_1(i, n>>1, 1) Down(i);\n    }\n\n    void Update(int x, int v){\n        if (B[x] > v) B[x] = v, Up(P[x]);\n        else B[x] = v, Down(P[x]);\n    }\n\n    int top(){\n        return A(1);\n    }\n\n} H[N];\n\n#undef y\n\n#define root 1, 0, n-1\n#define m ((l+r)>>1)\n#define lc lx, l, m\n#define rc rx, m+1, r\n\n#define Update(x) ml[x] = min(ml[lx], d(l, m+1) + ml[rx]), mr[x] = min(mr[rx], d(m, r) + mr[lx])\n#define Upleaf(x) ml[x] = mr[x] = h.top()\n\nstruct Interval_Tree{\n\n    VI id; int *ml, *mr;\n    int n, _x, offset;\n\nprivate:\n\n    int d(int l, int r){\n        return r - l;\n    }\n\n#define h H[id[l]]\n    void _B(int x, int l, int r){\n        if (l == r) ml[x] = mr[x] = INF;\n        else _B(lc), _B(rc), ml[x] = mr[x] = INF;\n    }\n\n    void _M(int x, int l, int r){\n        if (l == r) Upleaf(x);\n        else {if (_x <= m) _M(lc); if (m < _x) _M(rc); Update(x);}\n    }\n\n    int _MinL(int x, int l, int r){\n        if (l == r) return ml[x];\n        else return _x <= m ? _MinL(lc) : min(_MinL(rc), mr[lx] + d(m, _x));\n    }\n\n    int _MinR(int x, int l, int r){\n        if (l == r) return mr[x];\n        else return _x <= m ? min(_MinR(lc), d(_x, m+1) + ml[rx]) : _MinR(rc);\n    }\n\n#undef h\n\npublic:\n\n    int d(int x){\n        return d(0, D[x] - offset);\n    }\n\n    void Build(){\n        n = SZ(id); offset = D[id[0]]; int t=1; while(t<n) t<<=1; t<<=1;\n        ml = new int[t], mr = new int[t],  _B(root);\n    }\n\n    void Modify(int x){\n        _x = D[x] - offset, _M(root);\n    }\n\n    int MinR(int x){\n        _x = D[x] - offset; return _MinR(root);\n    }\n\n    int MinL(int x){\n        _x = D[x] - offset; return _MinL(root);\n    }\n\n    int MinL(){return ml[1];}\n\n} T[N];\n\n#undef Update\n\ninline void del(int x){\n    if (x == hd[to[x^1]]) prd[hd[to[x^1]] = suc[x]] = 0;\n    else suc[prd[suc[x]] = prd[x]] = suc[x];\n}\n\n#define TRA(i, x) for(int i=hd[x];i;i=suc[i])\n#define u q[i]\n#define v to[ii]\n\nint q[N]; void bfs(){\n    n = 0, q[n++] = 1; REP(i, n) TRA(ii, u) if(!F[v])\n        q[n++] = v, F[v] = u, D[v] = D[u] + 1, del(ii^1);\n\n    DWN(i, n, 0){\n        size[u] = 1; TRA(ii, u)\n            size[u] += size[v];\n    }\n}\n\nvoid hld(){\n    REP(i, n) if (!head[u]){\n        int x = u, y; while (true){\n            T[u].id.PB(x); y = 0; head[x] = u; TRA(ii, x){\n                if(!y || size[v] > size[y]) y = v;\n            }\n            if (!y) break;\n            x = y;\n        }\n    }\n}\n\nvoid init(){\n\n    DWN(i, n, 0){\n\n        int cnt = 1; H[u].B.PB(INF);\n\n        TRA(ii, u) if(head[v] != head[u])\n            Hid[v]=++cnt, H[u].B.PB(INF);\n\n        H[u].Build(); if (head[u] == u)  // is path head ? ..\n            T[u].Build();\n    }\n}\n\n#undef u\n#undef v\n\nvoid Up(int& x){\n    T[head[x]].Modify(x), x = head[x];\n}\n\nvoid Modify(int u){\n\n    if (black(u)) H[u].Update(1, 0);\n    else H[u].Update(1, INF);\n\n    Up(u); int v = F[u]; while (v){\n        H[v].Update(Hid[u], T[u].MinL() + 1);\n        Up(v), v = F[u = v];\n    }\n}\n\nint Query(int u){\n\n    if (!black(u)) return 0;\n\n    int res = INF, path = 0, t; while (u){\n        t = min(T[head[u]].MinL(u), T[head[u]].MinR(u));\n        checkMin(res, t + path); if (!t) break; // Cut .. -2s..\n        path += T[head[u]].d(u) + 1;\n        u = F[head[u]];\n    }\n    return res == INF ? -1 : res;\n}\n\nint vvv[N];\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    int Q; RD(n, Q);\n    FOR_C(i, 2, n << 1){\n        RD(to[i], to[i|1]);\n        prd[hd[to[i^1]]] = i, suc[i] = hd[to[i^1]], hd[to[i^1]] = i, ++i;\n        prd[hd[to[i^1]]] = i, suc[i] = hd[to[i^1]], hd[to[i^1]] = i;\n    }\n\n\n\n    REP_1(i, n) H[i].B.PB(-INF); // offset .. .\n\n\n\n    bfs(); hld(); init(); // heavy light decomposition .. .\n\n\n        Modify(1);\nvvv[1] = 1;\n    DO(Q){\n        if (RD()==2) {\n                OT(Query(RD()));\n        }\n        else {\n            int ttt  = RD ();\n            if (vvv[ttt] == 0)\n                Modify(ttt);\n            vvv[ttt] = 1;\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Xenia and Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/8800",
    "editorial": "The problem can be solved in different ways. The most easy idea is\r\nsqrt-optimization. Split all queries into blocks. Each block we will\r\nprocess separately. Before processing each block, we should calculate\r\nminimum distances from every node to the closest red node using bfs. To\r\nanswer the query we should update this value by shortest distances to\r\nred nodes in current block. The solution becomes simple. Every queries\r\nwe make simple bfs and for every node WE calculate value the shortest\r\ndistance to some red node from node . Then to answer the query of type 2\r\nyou should calculate , where every red node, which becomes red in\r\ncurrent block of length . Distance between two nodes can be got using\r\npreprocessing for lca.\r\n",
    "hint": []
}