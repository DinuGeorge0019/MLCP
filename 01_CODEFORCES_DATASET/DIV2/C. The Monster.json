{
    "link": "https://codeforces.com//contest/918/problem/C",
    "problemId": "151494",
    "problem_idx": "C",
    "shortId": "918C",
    "contest_number": "918",
    "problem_submissions": {
        "D": [
            34674216,
            34676112,
            34673508,
            34668068,
            34677841,
            34677199,
            34677332,
            34677732,
            34674284,
            34676764,
            34679239,
            34678391,
            34678589,
            34677462,
            34676960,
            34679127,
            34678913,
            34675354,
            34679183
        ],
        "B": [
            34670440,
            34667518,
            34666861,
            34670421,
            34670264,
            34667471,
            34666401,
            34668510,
            34667116,
            34668380,
            34668100,
            34668007,
            34668333,
            34667912,
            34667438,
            34673764,
            34668108,
            34668574,
            34670180
        ],
        "C": [
            34669065,
            34673271,
            34676492,
            34678621,
            34673223,
            34674841,
            34674142,
            34672405,
            34678982,
            34671931,
            34673671,
            34675775,
            34673964,
            34675892,
            34678000,
            34670923,
            34676125,
            34680026,
            34675452
        ],
        "A": [
            34664697,
            34665015,
            34664848,
            34664663,
            34664707,
            34665222,
            34664674,
            34665219,
            34664947,
            34672513,
            34664938,
            34664735,
            34665446,
            34664882,
            34665035,
            34672321,
            34665406,
            34664826,
            34666801
        ],
        "E": [
            34687078,
            34688168,
            34687900,
            34687853
        ]
    },
    "name": "C. The Monster",
    "statement": "As Will is stuck in the Upside Down, he can still communicate with his\r\nmom, Joyce, through the Christmas lights (he can turn them on and off\r\nwith his mind). He can\u2019t directly tell his mom where he is, because the\r\nmonster that took him to the Upside Down will know and relocate him.\r\nThus, he came up with a puzzle to tell his mom his coordinates. His\r\ncoordinates are the answer to the following problem.A string consisting\r\nonly of parentheses (\u201d and \u201d) is called a bracket sequence. Some bracket\r\nsequence are called correct bracket sequences. More formally: Empty\r\nstring is a correct bracket sequence. if is a correct bracket sequence,\r\nthen is also a correct bracket sequence. if and are correct bracket\r\nsequences, then (concatenation of and ) is also a correct bracket\r\nsequence. A string consisting of parentheses and question marks (\u201d) is\r\ncalled pretty if and only if there\u2019s a way to replace each question mark\r\nwith either \u201d or \u201d such that the resulting string is a correct bracket\r\nsequence.Will gave his mom a string consisting of parentheses and\r\nquestion marks (using Morse code through the lights) and his coordinates\r\nare the number of pairs of integers such that and the string is pretty,\r\nwhere is -th character of .Joyce doesn\u2019t know anything about bracket\r\nsequences, so she asked for your help.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 5e3 + 10;\n\nint n;\nstring s;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> s;\n\tn = s.size();\n\tint ans = 0;\n\tfor (int l = 0; l < n; l++){ \n\t\tint tl = 0, tr = 1;\n\t\tfor (int r = l; r < n; r++) {\n\t\t\tif (s[r] == '('){\n\t\t\t\ttl++, tr++;\n\t\t\t}\n\t\t\telse if (s[r] == ')'){\n\t\t\t\ttl--, tr--;\n\t\t\t\ttl = max(0, tl);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttr++;\n\t\t\t\ttl--;\n\t\t\t\ttl = max(0, tl);\n\t\t\t}\n\t\t\tif (tl == tr) break;\n\t\t\tif ((r-l+1) % 2 == 0 && tl == 0)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. The Monster.json",
    "editorial_link": "https://codeforces.com/blog/entry/57420",
    "editorial": "First, let's denote s[l..r] as the substring slsl?+?1... sr of string s. Also s.count(t) is the number of occurrences of t in s.\n\nA string consisting of parentheses and question marks is pretty if and only if:\n\n|s| is even.\n0???s[1..i].count('(')?+?s[1..i].count('?')?-?s[1..i].count(')') for each 1???i???|s|.\n0???s[i..|s|].count(')')?+?s[i..|s|].count('?')?-?s[i..|s|].count('(') for each 1???i???|s|.\nProof: If s.count('?')?=?0 then s is a correct bracket sequence. Otherwise, let q be an integer between 1 to |s| such that sq?=?'?'.\n\nLemma: We can replace sq by either '(' or ')' such that the three conditions above remain satisfied.\n\nProof: We'll use proof by contradiction. If we can replace sq by either '(' or ')' such that the conditions remain satisfied, the lemma is proven. Otherwise, the conditions will be violated if we replace sq by '(' or ')'.\n\nLet's denote f(s) as s.count('(')?+?s.count('?')?-?s.count(')') and g(s) as s.count(')')?+?s.count('?')?-?s.count('('). Please note that f(s)?=??-?g(s)?+?2?\u00d7?s.count('?') and g(s)?=??-?f(s)?+?2?\u00d7?s.count('?').\n\nBy assumption, if we replace sq by '(' the conditions will be violated. By replacing sq the second condition can't be violated, thus the third condition will be violated. So, there's an integer i such that 1???i???q and g(t[i..|t|])?<?0 (t is s after replacing sq by '('). Thus, g(s[i..|s|])?<?2. Similarly, there's an integer j such that q???j???|s| and f(s[1..j])?<?2.\n\nSince all three conditions are satisfied for s (by assumption), then 0???g(s[i..|s|]),?f(s[1..j])???1.\n\nLet's break s into three parts (they could be empty): a?=?s[1..(i?-?1)], b?=?s[i..j] and c?=?s[(j?+?1)..|s|].\n\ng(s[i..|s|])?=?g(b)?+?g(c) and f(s[1..j])?=?f(a)?+?f(b). Since the three conditions are satisfied for s, then 0???g(c),?f(a).\n\nf(a)?+?f(b)???1 so f(a)?-?1????-?f(b). Thus f(a)?-?1???g(b)?-?2?\u00d7?b.count('?'), so f(a)?-?1?+?2?\u00d7?b.count('?')???g(b).\n\nSo f(a)?-?1?+?2?\u00d7?b.count('?')?+?g(c)???g(b)?+?g(c)???1. So f(a)?-?1?+?2?\u00d7?b.count('?')?+?g(c)???1. Since i???q???j, then 2???2?\u00d7?b.count('?').\n\nAlso, 0???g(c),?f(a). So, 1???f(a)?-?1?+?2?\u00d7?b.count('?')?+?g(c)???1. So f(a)?-?1?+?2?\u00d7?b.count('?')?+?g(c)?=?1. This requires that f(a)?=?g(c)?=?0 and b.count('?')?=?1.\n\nSince f(a) and g(c) are even, then |a| and |c| are even, and since |s| is even (first condition), then |b| is also even (because |s|?=?|a|?+?|b|?+?|c|).\n\nf(a)?=?g(c)?=?0 and 0???f(a)?+?f(b) and 0???g(b)?+?g(c), thus 0???f(b),?g(b). Also, f(a)?+?f(b),?g(b)?+?g(c)???1, thus 0???f(b),?g(b)???1, since |b| is even, f(b) and g(b) are also even, thus, f(b)?=?g(b)?=?0. g(b)?=??-?f(b)?+?2?\u00d7?b.count('?') and since 1???b.count('?') then g(b)???0.\n\nThus, we have 0???0, which is false. So the lemma is true.\n\nUsing the lemma above, each time we can replace a question mark by parentheses and at the end we get a correct bracket sequence."
}