{
    "link": "https://codeforces.com//contest/1758/problem/E",
    "problemId": "1661252",
    "problem_idx": "E",
    "shortId": "1758E",
    "contest_number": "1758",
    "problem_submissions": {
        "F": [
            182540191,
            182568321
        ],
        "E": [
            182511822,
            182586636,
            182586387,
            182515621,
            182519585,
            182518611,
            182521484,
            182522469,
            182521201,
            182526835,
            182524445,
            182531747,
            182527370,
            182535662,
            182516659,
            182531389,
            182540195,
            182534906,
            182535704,
            182534874,
            182530934
        ],
        "D": [
            182500138,
            182501532,
            182504442,
            182507521,
            182511731,
            182494704,
            182508383,
            182512302,
            182512544,
            182503927,
            182510854,
            182528079,
            182501802,
            182493856,
            182514498,
            182506950,
            182513404,
            182511217,
            182525174,
            182492321
        ],
        "C": [
            182492468,
            182496509,
            182492305,
            182495507,
            182494119,
            182500722,
            182502459,
            182500806,
            182500441,
            182492103,
            182505245,
            182496553,
            182526899,
            182500230,
            182495864,
            182508565,
            182493170,
            182498448,
            182538442
        ],
        "B": [
            182487714,
            182492898,
            182486562,
            182485510,
            182487169,
            182486096,
            182487229,
            182491179,
            182486630,
            182482943,
            182485521,
            182488443,
            182519764,
            182489830,
            182487145,
            182487987,
            182502412,
            182487085,
            182484646
        ],
        "A": [
            182480951,
            182480859,
            182482976,
            182480629,
            182480620,
            182481772,
            182483562,
            182480441,
            182483772,
            182479955,
            182480275,
            182480273,
            182517991,
            182490014,
            182483571,
            182480580,
            182480710,
            182480601,
            182480454
        ]
    },
    "name": "E. Tick, Tock",
    "statement": "Tannhaus, the clockmaker in the town of Winden, makes mysterious clocks\r\nthat measure time in h hours numbered from 0 to h-1. One day, he decided\r\nto make a puzzle with these clocks. The puzzle consists of an n\r\ntimes m grid of clocks, and each clock always displays some hour exactly\r\n(that is, it doesn\u2019t lie between two hours). In one move, he can choose\r\nany row or column and shift all clocks in that row or column one hour\r\nforward^\r\ndagger.The grid of clocks is called if it is possible to make all the\r\nclocks display the same time.While building his puzzle, Tannhaus\r\nsuddenly got worried that it might not be possible to make the grid\r\nsolvable. Some cells of the grid have clocks already displaying a\r\ncertain initial time, while the rest of the cells are empty.Given the\r\npartially completed grid of clocks, find the number of ways^\r\nddagger to assign clocks in the empty cells so that the grid is\r\nsolvable. The answer can be enormous, so compute it modulo 10^9 + 7.^\r\ndagger If a clock currently displays hour t and is shifted one hour\r\nforward, then the clock will instead display hour (t+1)\r\nbmod h.^\r\nddagger Two assignments are different if there exists some cell with a\r\nclock that displays a different time in both arrangements.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch=='-')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=4e5+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n,m,k,flag = 1,cnt;\nint r[N],c[N],vc[N],vr[N];\nvector<int>a[N];\nI Pow(ll t,int x,ll s=1){\n\tfor(;x;x>>=1,t=t*t%mod)if(x&1)\n\t\ts= s*t%mod;\n\treturn s;\n}\nvoid dfsc(int j);\nvoid dfsr(int i){\n\t// if(tag[i])return;\n\tFOR(j,1,m)if(~a[i][j]){\n\t\tif(c[j]){\n\t\t\tif((vr[i]+vc[j])%k!=a[i][j])\n\t\t\t\tflag = 0;\n\t\t}\n\t\telse{\n\t\t\tc[j] = 1;\n\t\t\tvc[j] = (a[i][j]-vr[i]+k)%k;\n\t\t\tdfsc(j);\n\t\t}\n\t}\n}\nvoid dfsc(int j){\n\tFOR(i,1,n)if(~a[i][j]){\n\t\tif(r[i]){\n\t\t\tif((vr[i]+vc[j])%k!=a[i][j])\n\t\t\t\tflag = 0;\n\t\t}\n\t\telse{\n\t\t\tr[i] = 1;\n\t\t\tvr[i] = (a[i][j]-vc[j]+k)%k;\n\t\t\tdfsr(i);\n\t\t}\n\t}\n}\nV input(){\n\tn = getint(), m = getint(),k =getint();\n\tcnt = 0,flag = 1;\n\tFOR(i,1,n)a[i].resize(m+1);\n\tFOR(i,1,n)FOR(j,1,m)a[i][j]=getint();\n\tFOR(i,1,n)r[i]=vr[i]=0;\n\tFOR(i,1,m)c[i]=vc[i]=0;\n\tcnt = 0;\n\tFOR(i,1,n)if(!r[i])dfsr(i),cnt++;\n\tFOR(i,1,m)if(!c[i])cnt++;\n\t// if(flag)\n\t// cerr<<\"cnt=\"<<cnt<<'\\n';\n\tcout<<Pow(k,cnt-1,flag)<<'\\n';\n\n\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n\t// freopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tfor(scanf(\"%d\",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tick, Tock.json",
    "editorial_link": "https://codeforces.com//blog/entry/109438",
    "editorial": "Notice that a relationship between two clocks with assigned values on\r\nthe grid on different rows but the same column, that is, and , can be\r\nrepresented as , where . Now, for every , . Using these relationships,\r\nwe can create a weighted directed graph using our rows as\r\nnodes.Obviously, no solutions exist if there are discrepancies in the\r\ngraph , no solution exists. Now, for each connected component, if there\r\nis an assigned value in one of the rows it contains, we can determine\r\nall of the other values for that column in the connected component. We\r\ncan merge different connected components by choosing a common difference\r\nfor these components. This needs to be done (connected components - 1)\r\ntimes, and there are different ways to choose a common difference when\r\ncombining different components, resulting in different ways to combine\r\nall components into one connected component.This leaves us with columns\r\nthat are fully empty, i.e., they consist of unassigned clocks. As all\r\nrows are in one connected component at this point, assigning a clock in\r\none empty column results in all other clocks in that column becoming\r\nassigned values too. There are different ways to assign clocks to these\r\nempty columns.Thus, overall, our solution is .\r\n"
}