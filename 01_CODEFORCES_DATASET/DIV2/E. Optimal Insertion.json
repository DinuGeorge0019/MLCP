{
    "link": "https://codeforces.com//contest/1602/problem/E",
    "problemId": "1157774",
    "problem_idx": "E",
    "shortId": "1602E",
    "contest_number": "1602",
    "problem_submissions": {
        "E": [
            133032006,
            133003754,
            133004259,
            133007498,
            133009354,
            133008986,
            133015586,
            133014296,
            133019189,
            133016251,
            133023043,
            133017173,
            133017654,
            133031118,
            133031771,
            133023126,
            133023444,
            133026607,
            133071046,
            133071006,
            133023246,
            133026124
        ],
        "F": [
            133014631,
            133053467,
            133059590,
            133053314,
            133051962,
            133051828,
            133051273,
            133051246,
            133050986,
            133051444,
            133058927,
            154906935,
            133202717
        ],
        "D": [
            133005341,
            132997744,
            132998965,
            133002435,
            132995700,
            132999302,
            133001008,
            133003621,
            133003659,
            132999008,
            132999274,
            133007130,
            133055379,
            133006665,
            133001448,
            133002893,
            133007904,
            133005768,
            133005590,
            133006243,
            133009816
        ],
        "C": [
            132998504,
            132991987,
            132994038,
            132995401,
            132990761,
            132993753,
            132991630,
            132994468,
            132994573,
            133000658,
            132992001,
            132996442,
            132999119,
            132991525,
            132995757,
            132998190,
            132996165,
            132996191,
            132994329,
            132993830
        ],
        "B": [
            132991874,
            132990242,
            132989322,
            132992468,
            132988801,
            132988045,
            132989355,
            132992898,
            148604097,
            132990867,
            133003212,
            132988289,
            133227165,
            132993306,
            133064818,
            132995361,
            132995328,
            132993153,
            132995379,
            132997555,
            132991609,
            132992280,
            132992140
        ],
        "A": [
            132986686,
            132984939,
            132985573,
            132990670,
            132984472,
            132986995,
            132984659,
            132987933,
            148604079,
            132986349,
            132985981,
            132984656,
            133227226,
            132987663,
            132991514,
            132988125,
            132988425,
            132989208,
            132984538,
            132986551,
            132985450,
            132984595
        ]
    },
    "name": "E. Optimal Insertion",
    "statement": "You are given two arrays of integers a_1, a_2,\r\nldots, a_n and b_1, b_2,\r\nldots, b_m.You need to insert all elements of b into a in an arbitrary\r\nway. As a result you will get an array c_1, c_2,\r\nldots, c_{n+m} of size n + m.Note that you are not allowed to change the\r\norder of elements in a, while you can insert elements of b at arbitrary\r\npositions. They can be inserted at the beginning, between any elements\r\nof a, or at the end. Moreover, elements of b can appear in the resulting\r\narray in any order.What is the minimum possible number of inversions in\r\nthe resulting array c? Recall that an inversion is a pair of indices (i,\r\nj) such that i < j and c_i > c_j.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nint read()\n{\n\tint ret=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0')f|=(c=='-'),c=getchar();\n\twhile(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\treturn f?-ret:ret;\n}\nint T;\nconst int maxn=2e6+5;\nint n,m,a[maxn],b[maxn],id[maxn];\nll ans;\nstruct segment\n{\n\tstruct node{int mi,tag;}t[maxn<<2];\n\tvoid pushdown(int u){if(t[u].tag)put(u*2,t[u].tag),put(u*2+1,t[u].tag),t[u].tag=0;}\n\tvoid update(int u){t[u].mi=min(t[u*2].mi,t[u*2+1].mi);}\n\tvoid put(int u,int v){t[u].tag+=v,t[u].mi+=v;}\n\tvoid build(int u=1,int l=0,int r=n)\n\t{\n\t\tt[u].tag=0;t[u].mi=l;\n\t\tint mid=(l+r)>>1;\n\t\tif(l==r)return;\n\t\tbuild(u*2,l,mid),build(u*2+1,mid+1,r);\n\t}\n\tvoid change(int lc,int u=1,int l=0,int r=n)\n\t{\n\t\tif(lc<=l)return put(u,-1);pushdown(u);int mid=(l+r)>>1;\n\t\tif(lc<=mid)change(lc,u*2,l,mid);change(lc,u*2+1,mid+1,r);update(u);\n\t}\n}tr1;\nstruct fenwick\n{\n\tint a[maxn];\n\tvoid change(int x){for(;x<=n;x+=x&-x)++a[x];}\n\tint query(int x){int ret=0;for(;x;x&=x-1)ret+=a[x];return ret;}\n\tvoid clr(){for(int i=1;i<=n;++i)a[i]=0;}\n}tr2;\nint main(){\n\tT=read();\n\twhile(T--)\n\t{\n\t\tn=read();m=read();\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),id[i]=i;\n\t\tsort(id+1,id+n+1,[&](int x,int y){return a[x]!=a[y]?a[x]<a[y]:x<y;});for(int i=1;i<=m;++i)b[i]=read();\n\t\tid[n+1]=0,a[0]=2e9;\n\t\tsort(b+1,b+m+1);\n\t\ttr1.build(1,0,n);\n\t\tll ans=0;\n\t\ttr2.clr();\n\t\tfor(int i=n;i>=1;i--)ans+=tr2.query(id[i]),tr2.change(id[i]);\n\t\tfor(int i=1,p=1,h=0;i<=m;i++)\n\t\t{\n\t\t\tif(b[i]!=b[i-1])\n\t\t\t{\n\t\t\t\twhile(a[id[p]]==b[i-1])tr1.change(id[p++]),++h;\n\t\t\t\twhile(a[id[p]]<b[i])tr1.change(id[p]),tr1.change(id[p++]),++h;\n\t\t\t\tfor(int j=p;a[id[j]]==b[i];++j)tr1.change(id[j]);\n\t\t\t}\n\t\t\tans+=h+tr1.t[1].mi;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Optimal Insertion.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "For some reason Iâve decided to not use the Fenwick trees like I did\r\nbefore and switched to Order Statistics Tree from GNU C++ PBDs. The\r\nsolution should be O((n + m) (log(n) + log(m))) Can someone help me\r\nunderstand why I have TLE? The idea is as follows: The asymptotic seems\r\nright: there are n + m steps, at each of them there are at most log(n) +\r\nlog(m) operations, so this should really fit the limitations. I canât\r\nfigure out why I get TLE :( Hereâs the code: 133029362\r\n",
    "hint": []
}