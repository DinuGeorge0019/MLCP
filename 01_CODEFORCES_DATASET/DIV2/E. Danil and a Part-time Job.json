{
    "link": "https://codeforces.com//contest/877/problem/E",
    "problemId": "130132",
    "problem_idx": "E",
    "shortId": "877E",
    "contest_number": "877",
    "problem_submissions": {
        "F": [
            31654167,
            31653139,
            31655134,
            31656955,
            31639931,
            31650204,
            31648622,
            31651887,
            33479364,
            31655646,
            31694169,
            31893110
        ],
        "E": [
            31643937,
            31646320,
            31646382,
            31649500,
            31641532,
            31645322,
            31640350,
            31645337,
            31641515,
            31644016,
            31652300,
            31648164,
            31648540,
            31649482,
            31644271,
            31648366,
            31646891,
            31648638,
            31653283,
            31654866
        ],
        "D": [
            31641155,
            31644336,
            31643884,
            31647657,
            31665021,
            31739883,
            31649498,
            31650176,
            31649638,
            31639062,
            31644913,
            31645497,
            31649880,
            31645363,
            31666561,
            31654457,
            31648925,
            31649435
        ],
        "C": [
            31638971,
            31647846,
            31638928,
            31641413,
            31644732,
            31639320,
            31637367,
            31649045,
            31644989,
            31640032,
            31639911,
            31643252,
            31638722,
            31638437,
            31636874,
            31639305,
            31642602,
            31642153,
            31643991,
            31641659
        ],
        "B": [
            31638394,
            31636212,
            31636559,
            31636226,
            31644604,
            31636106,
            31634815,
            31636547,
            31636242,
            31637676,
            31679870,
            31636958,
            31645807,
            31636913,
            31635284,
            31638201,
            31637074,
            31636966,
            31638021,
            31639655,
            31639274
        ],
        "A": [
            31635408,
            31634914,
            31634587,
            31634665,
            31664979,
            31634608,
            31634317,
            31634960,
            31650654,
            31634394,
            31634371,
            31644024,
            31634639,
            31634521,
            31634889,
            31634575,
            31635175,
            31640619,
            31635186,
            31635511
        ]
    },
    "name": "E. Danil and a Part-time Job",
    "statement": "Danil decided to earn some money, so he had found a part-time job. The\r\ninterview have went well, so now he is a light switcher.Danil works in a\r\nrooted tree (undirected connected acyclic graph) with vertices, vertex\r\nis the root of the tree. There is a room in each vertex, light can be\r\nswitched on or off in each room. Danil\u2019s duties include switching light\r\nin all rooms of the subtree of the vertex. It means that if light is\r\nswitched on in some room of the subtree, he should switch it off.\r\nOtherwise, he should switch it on.Unfortunately (or fortunately), Danil\r\nis very lazy. He knows that his boss is not going to personally check\r\nthe work. Instead, he will send Danil tasks using personal\r\nmessages.There are two types of tasks: describes a task to switch lights\r\nin the subtree of vertex . describes a task to count the number of rooms\r\nin the subtree of , in which the light is turned on. Danil should send\r\nthe answer to his boss using messages.A subtree of vertex is a set of\r\nvertices for which the shortest path from them to the root passes\r\nthrough . In particular, the vertex is in the subtree of .Danil is not\r\ngoing to perform his duties. He asks you to write a program, which\r\nanswers the boss instead of him.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=200005;\nint ti,n,q,a[N],nextt[N],ed[N],son[N];\nint nedge,tree[N<<2],in[N],out[N],lazy[N<<2];\ninline int p(int a,int b){\n\treturn a+b;\n}\ninline void cao(int p,int l,int r){\n\ttree[p]=r-l+1-tree[p];\n}\ninline void pushdown(int p,int l,int r){\n\tif(!lazy[p])return; int mid=(l+r)>>1;\n\tlazy[p<<1]^=lazy[p]; lazy[(p<<1)+1]^=lazy[p]; cao(p<<1,l,mid); cao((p<<1)^1,mid+1,r); lazy[p]=0;\n}\ninline int ask(int l,int r,int i,int j,int nod){int mid=(l+r)>>1;\n\tif (l==i&&j==r) return tree[nod]; pushdown(nod,l,r);\n\tif (j<=mid) return ask(l,mid,i,j,nod<<1);\n\telse if(i>mid) return ask(mid+1,r,i,j,(nod<<1)+1);\n\tint left=ask(l,mid,i,mid,nod<<1);\n\tint right=ask(mid+1,r,mid+1,j,(nod<<1)+1);\n\treturn p(left,right);\n}\ninline void insert(int l,int r,int i,int j,int nod){int mid=(l+r)>>1;\n\tif(l==i&&r==j){\n\t\tlazy[nod]^=1; cao(nod,l,r); return;\n\t}\n    pushdown(nod,l,r);\n    if(j<=mid)insert(l,mid,i,j,nod<<1); else\n    if(i>mid)insert(mid+1,r,i,j,(nod<<1)+1); else{\n    \tinsert(l,mid,i,mid,nod<<1); insert(mid+1,r,mid+1,j,(nod<<1)+1);\n\t}\n\ttree[nod]=p(tree[nod<<1],tree[(nod<<1)^1]);\n}\ninline void build(int l,int r,int nod){int mid=(l+r)>>1;\n\tif (l==r) {tree[nod]=a[l]; return;}\n\tbuild(l,mid,nod<<1); build(mid+1,r,(nod<<1)+1);\n\ttree[nod]=p(tree[nod<<1],tree[(nod<<1)+1]);\n}\ninline void write(int a){\n\tif(a>=10)write(a/10);\n\tputchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\ninline int\tread(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void aedge(int a,int b){\n\tnextt[++nedge]=son[a]; son[a]=nedge; ed[nedge]=b;\n}\ninline void dfs(int p){\n\tin[p]=++ti;\n\tfor(int i=son[p];i;i=nextt[i]){\n\t\tdfs(ed[i]);\n\t}\n\tout[p]=ti;\n}\nchar ch[10];\nint main(){\n\tn=read();\n\tfor(int i=2;i<=n;i++){\n\t\tint t1=read();\n\t\taedge(t1,i);\n\t}\n\tdfs(1);\n\tfor(int i=1;i<=n;i++)a[in[i]]=read();\n\tbuild(1,n,1);\n\tq=read();\n\twhile(q--){\n\t\tscanf(\"%s\",&ch); int s1=read();\n\t\tif(ch[0]=='g'){\n\t\t\twriteln(ask(1,n,in[s1],out[s1],1));\n\t\t}else{\n\t\t\tinsert(1,n,in[s1],out[s1],1);\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Danil and a Part-time Job.json",
    "editorial_link": "https://codeforces.com//blog/entry/55362",
    "editorial": "Let\u00e2\u0080\u0099s construct Euler tour tree. We\u00e2\u0080\u0099ll put vertex in vector when first\r\ntime visit it. For each vertext subtree is segment in this vector,\r\nborders of which we can calculate while constructing.Now we need to make\r\ninversion on segment and get sum of segment. Segment tree is good for\r\nit.\r\n"
}