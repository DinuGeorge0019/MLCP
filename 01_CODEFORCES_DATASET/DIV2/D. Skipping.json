{
    "link": "https://codeforces.com//contest/2024/problem/D",
    "problemId": "2964359",
    "problem_idx": "D",
    "shortId": "2024D",
    "contest_number": "2024",
    "problem_submissions": {
        "F": [
            287015023,
            287169223,
            287373673,
            287215917,
            287215736,
            287211292,
            287210539
        ],
        "D": [
            286987175,
            286931903,
            286960958,
            286961825,
            286971656,
            286929566,
            286931351,
            286932695,
            286932954,
            286934298,
            286931628,
            286927969,
            286932481,
            286936758,
            286930518,
            286960977,
            286959072,
            286943034,
            286936933
        ],
        "B": [
            286981623,
            286914966,
            286919282,
            286915114,
            286921371,
            286905134,
            286915552,
            286914323,
            286916482,
            286915957,
            286912577,
            286914600,
            286917409,
            286917069,
            286960523,
            286915841,
            286912540,
            286913505,
            286928405,
            286917057
        ],
        "E": [
            286971252,
            287005601,
            287014904,
            287015860,
            287015861,
            287172897,
            287179171,
            286984012
        ],
        "A": [
            286921784,
            286907603,
            286905627,
            286906243,
            286909098,
            286912198,
            286906985,
            286905683,
            286907292,
            286909521,
            286906250,
            286906979,
            286905397,
            286905452,
            286905213,
            286906731,
            286905626,
            286906240,
            286907336,
            286905986
        ],
        "C": [
            286916369,
            286924618,
            286933885,
            286931704,
            286933058,
            286906288,
            286921833,
            286923843,
            286925202,
            286923774,
            286923641,
            286921029,
            286922676,
            286924091,
            286919391,
            286920408,
            286922209,
            286923637,
            286916167,
            286927200
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Notice that it makes no sense for us to skip problems for which bi?i\n, since we can solve the problem, earn points for it, and the next problem will be chosen from the numbers j<i\n. If we skip it, we do not earn points, and the next problem will be chosen from the same set of problems or even a smaller one.\n\nWe also note that if we are at problem i\n and the maximum problem number that has been assigned to us earlier in the competition is j?bi\n, then it makes no sense to skip this problem, because after skipping, we could have reached the next problem from problem j\n simply by solving problems.\n\nUnder these conditions, it turns out that all the problems assigned to us, after the competition ends, are on some prefix of the set of problems (i.e., there exists some number i\n from 1\n to n\n such that all problems with numbers j?i\n were received by us, and problems with numbers j>i\n were not received). This is indeed the case; let i\n be the maximum problem number that has been assigned to us. After this problem is assigned, we will not skip any more problems, as we have already proven that it is not beneficial, which means we will only solve problems and will solve all problems with numbers j<i\n that have not been visited before.\n\nInstead of trying to maximize the total score for the solved problems, we will aim to minimize the total score for the skipped problems. We will incur a penalty equal to ai\n for a skipped problem and 0\n if we solve it. We know that the answer lies on some prefix, so now we want to determine the minimum penalty required to reach each problem.\n\nLet's solve the following subproblem. We are given the same problems, and the following two options if we are at problem i\n:\n\nPay a penalty of 0\n and move to problem i?1\n, if such a problem exists;\nPay a penalty of ai\n and move to problem bi\n.\nNow we are allowed to visit each problem as many times as we want. In this case, we can construct a weighted directed graph of the following form:\n\nThe graph has n\n vertices, each vertex i\n corresponds to problem i\n;\nFor each i>1\n, there is an edge of weight 0\n from vertex i\n to vertex i?1\n;\nFor each i\n, there is an edge of weight ai\n from vertex i\n to vertex bi\n.\nThus, our task reduces to finding the shortest distance from vertex 1\n to each vertex. Recall that the shortest distance guarantees that on the way to vertex i\n, we visited each vertex at most once, which means that if we reached problem i\n with some penalty, we can solve all problems on the prefix up to i\n (inclusive), since the points for all skipped problems will be compensated by the penalty. Since we already know that the optimal answer lies on one of the prefixes, we need to know the total points for the problems for each prefix, which can be easily done using prefix sums. After that, from all the values of the difference between the prefix sum and the minimum penalty needed to reach vertex i\n, we will choose the maximum across all prefixes i\n, and this will be the answer.",
    "name": "D. Skipping",
    "statement": "It is already the year 3024, ideas for problems have long run out, and\r\nthe olympiad now takes place in a modified individual format. The\r\nolympiad consists of n problems, numbered from 1 to n. The i-th problem\r\nhas its own score a_i and a certain parameter b_i (1\r\nle b_i\r\nle n).Initially, the testing system gives the participant the problem.\r\nWhen the participant is given the i-th problem, they have two options:\r\nThey can submit the problem and receive a_i points; They can skip the\r\nproblem, in which case they will never be able to submit it. Then, the\r\ntesting system selects the next problem for the participant from\r\nproblems with indices j, such that: If he submitted the i-th problem, it\r\nlooks at problems with indices j < i; If he skipped the i-th problem, it\r\nlooks at problems with indices j\r\nleq b_i. Among these problems, it selects the problem with the index\r\nthat it has to the participant (he has neither submitted nor skipped it\r\nbefore). If there is no such problem, then the competition for the\r\nparticipant , and their result is equal to the sum of points for all\r\nsubmitted problems. In particular, if the participant submits the first\r\nproblem, then the competition for them ends. Note that the participant\r\nreceives each problem .Prokhor has prepared thoroughly for the olympiad,\r\nand now he can submit any problem. Help him determine the maximum number\r\nof points he can achieve.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; typedef long long int ll;const ll FOD = 998244353;typedef pair<ll, ll> P;using ull = unsigned long long;template <class T> using V = vector<T>;template <class T> using VV = V<V<T>>;  template <ll MD> struct ModInt {    using M = ModInt;    const static M G;    ll v;    ModInt(ll _v = 0) { set_v(_v % MD + MD); }    M& set_v(ll _v) {        v = (_v < MD) ? _v : _v - MD;        return *this;    }    explicit operator bool() const { return v != 0; }    M operator-() const { return M() - *this; }    M operator+(const M& r) const { return M().set_v(v + r.v); }    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }    M operator*(const M& r) const { return M().set_v(ll(v) * r.v % MD); }    M operator/(const M& r) const { return *this * r.inv(); }    M& operator+=(const M& r) { return *this = *this + r; }    M& operator-=(const M& r) { return *this = *this - r; }    M& operator*=(const M& r) { return *this = *this * r; }    M& operator/=(const M& r) { return *this = *this / r; }    bool operator==(const M& r) const { return v == r.v; }    M pow(ll n) const {        M x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    M inv() const { return pow(MD - 2); }    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }};using Mint = ModInt<998244353>;template<> const Mint Mint::G = Mint(3); template <class Mint> void nft(bool type, V<Mint>& a) {    int n = int(a.size()), s = 0;    while ((1 << s) < n) s++;    assert(1 << s == n);     static V<Mint> ep, iep;    while (int(ep.size()) <= s) {        ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));        iep.push_back(ep.back().inv());    }    V<Mint> b(n);    for (int i = 1; i <= s; i++) {        int w = 1 << (s - i);        Mint base = type ? iep[i] : ep[i], now = 1;        for (int y = 0; y < n / 2; y += w) {            for (int x = 0; x < w; x++) {                auto l = a[y << 1 | x];                auto r = now * a[y << 1 | x | w];                b[y | x] = l + r;                b[y | x | n >> 1] = l - r;            }            now *= base;        }        swap(a, b);    }} template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {    int n = int(a.size()), m = int(b.size());    if (!n || !m) return {};    int lg = 0;    while ((1 << lg) < n + m - 1) lg++;    int z = 1 << lg;    auto a2 = a, b2 = b;    a2.resize(z);    b2.resize(z);    nft(false, a2);    nft(false, b2);    for (int i = 0; i < z; i++) a2[i] *= b2[i];    nft(true, a2);    a2.resize(n + m - 1);    Mint iz = Mint(z).inv();    for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;    return a2;} ll n, k, q, h, w; ll m1, m2;vector<P> g[400'009 * 2]; vector<ll> a, b; Mint mod_pow (Mint l, ll r) {\tif (r == 0) return 1; \treturn mod_pow((l * l), r/2) * ((r%2) ? l : 1);}Mint mod_inv (Mint x) {\treturn mod_pow(x, FOD-2);} template<class T>vector<ll> mp (const vector<T> &s) {\tvector<ll> ans(s.size() + 1);\tans[0] = -1;\tll j = -1;\tfor (ll i = 0; i < s.size(); i++) {\t\twhile (j >= 0 && s[i] != s[j]) j = ans[j];\t\tj++;\t\tans[i+1] = j;\t}\treturn ans;} void solve () {\tfor (ll i = 0; i < n; i++) {\t\tg[i].clear();\t} \tfor (ll i = 0; i < n; i++) {\t\tif (i) {\t\t\tg[i].push_back({0, i-1});\t\t} \t\tg[i].push_back({a[i], b[i]});\t} \tll allsum = 0;\tfor (ll i = 0; i < n; i++) allsum += a[i]; \tvector<ll> d(n, allsum + 1);\tpriority_queue<P, vector<P>, greater<P> > que;\td[0] = 0;\tque.push({0, 0});\twhile (!que.empty()) {\t\tP p = que.top(); que.pop();\t\tll c = p.first, v = p.second;\t\tif (d[v] < c) continue; \t\tfor (P q : g[v]) {\t\t\tll c2 = q.first, u = q.second;\t\t\tif (d[u] > c + c2) {\t\t\t\td[u] = c + c2;\t\t\t\tque.push({d[u], u});\t\t\t}\t\t}\t} \tll ans = 0;\tll sum = 0;\tfor (ll i = 0; i < n; i++) {\t\tsum += a[i];\t\tans = max(ans, sum - d[i]);\t} \tcout << ans << \"\\n\";} int main (void) {\tcin >> q;\twhile (q--) {\t\tcin >> n;\t\ta.resize(n);\t\tfor (ll i = 0; i < n; i++) {\t\t\tcin >> a[i];\t\t}\t\tb.resize(n);\t\tfor (ll i = 0; i < n; i++) {\t\t\tcin >> b[i];\t\t\tb[i]--;\t\t}\t\t\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "divide and conquer",
        "dp",
        "flows",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Skipping.json",
    "hint": []
}