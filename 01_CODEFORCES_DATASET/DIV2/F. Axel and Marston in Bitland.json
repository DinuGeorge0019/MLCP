{
    "link": "https://codeforces.com//contest/782/problem/F",
    "problemId": "96960",
    "problem_idx": "F",
    "shortId": "782F",
    "contest_number": "782",
    "problem_submissions": {
        "B": [
            25267905,
            25250113,
            25247221,
            25250057,
            25249960,
            25260592,
            25250810,
            25250250,
            25247987,
            25248996,
            25252120,
            25252630,
            25250336,
            25258914,
            25255792,
            25254407,
            25252511,
            25252408,
            25251554,
            25264621,
            25253624
        ],
        "E": [
            25257921,
            25262484,
            25258744,
            25260005,
            25259671,
            25259859,
            25263675,
            25263558,
            25261219,
            25263312,
            25264852,
            25262648,
            25263111,
            25263112,
            25265502,
            25264818,
            25264138,
            25263813,
            25263236,
            25499887,
            25266724,
            25260260,
            25256767
        ],
        "D": [
            25255317,
            25254040,
            25254587,
            25256934,
            25261275,
            25263628,
            25259016,
            25257085,
            25258676,
            25258895,
            25257929,
            25259738,
            25253164,
            25260236,
            25257532,
            25259424,
            25260675,
            25259499,
            25261948,
            25267588
        ],
        "C": [
            25252879,
            25249891,
            25251779,
            25251734,
            25260562,
            25253017,
            25252465,
            25250777,
            25252022,
            25254042,
            25255189,
            25253477,
            25255602,
            25254511,
            25256655,
            25255363,
            25254268,
            25254004,
            25250050,
            25250430
        ],
        "A": [
            25247630,
            25246175,
            25246521,
            25247338,
            25259975,
            25247530,
            25246345,
            25246130,
            25246627,
            25246669,
            25247634,
            25246833,
            25257300,
            25246231,
            25249989,
            25247211,
            25250337,
            25247505,
            25500110,
            25251276,
            25246111
        ],
        "F": [
            25264803,
            25787036,
            25277978
        ]
    },
    "name": "F. Axel and Marston in Bitland",
    "statement": "A couple of friends, Axel and Marston are travelling across the country\r\nof Bitland. There are towns in Bitland, with some pairs of towns\r\nconnected by one-directional roads. Each road in Bitland is either a\r\npedestrian road or a bike road. There can be multiple roads between any\r\npair of towns, and may even be a road from a town to itself. However, no\r\npair of roads shares the starting and the destination towns along with\r\ntheir types simultaneously.The friends are now located in the town 1 and\r\nare planning the travel route. Axel enjoys walking, while Marston\r\nprefers biking. In order to choose a route diverse and equally\r\ninteresting for both friends, they have agreed upon the following\r\nprocedure for choosing the road types during the travel: The route\r\nstarts with a pedestrian route. Suppose that a beginning of the route is\r\nwritten in a string of letters P (pedestrain road) and B (biking road).\r\nThen, the string is appended to , where stands for the string with each\r\ncharacter changed to opposite (that is, all pedestrian roads changed to\r\nbike roads, and vice versa).In the first few steps the route will look\r\nas follows: P, PB, PBBP, PBBPBPPB, PBBPBPPBBPPBPBBP, and so on.After\r\nthat the friends start travelling from the town 1 via Bitlandian roads,\r\nchoosing the next road according to the next character of their route\r\ntype each time. If it is impossible to choose the next road, the friends\r\nterminate their travel and fly home instead.Help the friends to find the\r\nlongest possible route that can be travelled along roads of Bitland\r\naccording to the road types choosing procedure described above. If there\r\nis such a route with more than roads in it, print -1 instead.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define size(x) int(x.size())\n#define pb push_back\n#define ex exit(0)\n#define mp make_pair\n#define F first\n#define S second\nconst int MAXN = 501;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbitset <MAXN> dp[61][2][MAXN];\n\nint main() {\n    srand(time(NULL));\n    #ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n    #endif\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        dp[0][z][x][y] = 1;\n    }\n    for (int k = 1; k <= 60; k++) {\n        for (int z = 0; z <= 1; z++) {\n            for (int t = 1; t <= n; t++)\n            for (int i = 1; i <= n; i++) {\n                if (dp[k - 1][z][i][t])\n                dp[k][z][i] |= (dp[k - 1][(z ^ 1)][t]);\n            }\n        }\n    }\n    ll res = 0;\n    set <int> st;\n    st.insert(1);\n    int q = 0;\n    for (int k = 60; k >= 0; k--) {\n        set<int> nw;\n        for (auto i : st) {\n            for (int j = 1; j <= n; j++) {\n                if (dp[k][q][i][j]) {\n                   nw.insert(j);\n                }            \n            }\n        }\n        if (size(nw) == 0) continue;\n        q ^= 1;\n        res += (1LL << (k * 1LL));\n        if (res < 0) cout << -1, ex;\n        st = nw;\n    }\n    if (res > ll(1e18)) cout << -1, ex;\n    cout << res;\n    #ifndef ONLINE_JUDGE\n       cerr << clock() << \" ms\";\n    #endif\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Axel and Marston in Bitland.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "Let us write Ai for the binary string obtained after i inverse-append steps, for example, A0?=?0, A1?=?01, and so on. Let us also write . By definition we must have , and .\n\nLet us store matrices Pk and Qk, with entries Pk?/?Qk(v,?u) equal to 1 for pairs of vertices v,?u such that there is a Ak/Bk-path from v to u. Note that P0 and Q0 are exactly the adjacency matrices with 0- and 1-arcs respectively.\n\nNext, note that Pk?+?1(v,?u)?=?1 if and only if there is a vertex w such that Pk(v,?w)?=?Qk(w,?u)?=?1, and a similar condition can be written for Qk?+?1(v,?u). It follows that Pk?+?1 and Qk?+?1 can be computed using Pk and Qk in O(n3) time (the method is basically boolean matrix multiplication: , ).\n\nTo use the matrices Pk and Qk to find the answer, let us store L \u0097 the largest answer found, and S \u0097 the set of vertices reachable from the vertex 1 in exactly L steps. Let's process k by decreasing from a certain value k0, and see if L can be increased by 2k. The next 2k characters after L-th position will form the string Ak or Bk depending on the popcount parity of L. Let's denote S' the set of vertices reachable from S following Ak?/?Bk. If S' is non-empty, we can increase L by 2k, and assign S?=?S', otherwise, we don't change anything. In the end, L will be the maximal path length as long as it at less than 2k0.\n\nNote that we can take k0?=?60 since we don't care about exact value of answer if it is greater than 260. This results in an O(k0n3) solution, which is too slow. However, optimizing boolean multiplication with bitsets cuts the working time  times, and the solution is now fast enough.\n\nComplexity:  time, and  memory. Here , and w?=?64 is the word length in bits."
}