{"link": "https://codeforces.com//contest/378/problem/C", "problemId": "4958", "problem_idx": "C", "shortId": "378C", "contest_number": "378", "problem_submissions": {"E": [5563219, 5595791, 8179323, 5559860, 20070615, 5562227], "D": [5556813, 5557228, 5557861, 5557995, 5559128, 5559510, 5560131, 5559854, 5564039, 5558835, 5562214, 5559720, 5555845, 5561731, 5562171, 5561606, 5562261, 5561403, 8216379], "C": [5554238, 5554337, 5554949, 5554592, 5554549, 5556387, 5557557, 5554236, 5556931, 5559205, 5555878, 5557269, 5561573, 5555439, 5557184, 5557477, 5558631, 5558088, 5558866], "B": [5553450, 5553574, 5553632, 5553677, 5555408, 5554569, 5553596, 5556019, 5554338, 5553306, 5553948, 5560235, 5560773, 5557562, 5554753, 5556550, 5557175, 5558723, 5557766], "A": [5551839, 5552020, 5551945, 5551789, 5552122, 5552095, 5551986, 5551831, 5552492, 5551800, 5551769, 5551863, 5552473, 5552326, 5555120, 5553391, 5552249, 5552366]}, "name": "C. Maze", "statement": "Pavel loves grid mazes. A grid maze is an rectangle maze where each cell\r\nis either empty, or is a wall. You can go from one cell to another only\r\nif both cells are empty and have a common side.Pavel drew a grid maze\r\nwith all empty cells forming a connected area. That is, you can go from\r\nany empty cell to any other one. Pavel doesn\u2019t like it when his maze has\r\ntoo little walls. He wants to turn exactly empty cells into walls so\r\nthat all the remaining cells still formed a connected area. Help him.\r\n", "solutions": ["#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint n, m, k;\nchar board[600][600];\nint d[600][600];\n\nvoid dfs(int a, int b, int& left) {\n  d[a][b] = 1;\n\n  if (a - 1 >= 0 && board[a - 1][b] == '.' && d[a - 1][b] == 0) dfs(a - 1, b, left);\n  if (a + 1 < n && board[a + 1][b] == '.' && d[a + 1][b] == 0) dfs(a + 1, b, left);\n  if (b - 1 >= 0 && board[a][b - 1] == '.' && d[a][b - 1] == 0) dfs(a, b - 1, left);\n  if (b + 1 < m && board[a][b + 1] == '.' && d[a][b + 1] == 0) dfs(a, b + 1, left);\n  if (left > 0) {\n    --left;\n    board[a][b] = 'X';\n  }\n}\n\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 0; i < n; ++i) scanf(\"%s\", board[i]);\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      d[i][j] = 0;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (board[i][j] == '.') {\n        dfs(i, j, k);\n        goto end;\n      }\n    }\n  }\nend:;\n  for (int i = 0; i < n; ++i) {\n    printf(\"%s\\n\", board[i]);\n  }\n  return 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar"], "dificulty": "1600", "interactive": false}