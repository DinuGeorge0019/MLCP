{
    "link": "https://codeforces.com//contest/378/problem/C",
    "problemId": "4958",
    "problem_idx": "C",
    "shortId": "378C",
    "contest_number": "378",
    "problem_submissions": {
        "E": [
            5563219,
            5595791,
            8179323,
            5559860,
            20070615,
            5562227
        ],
        "D": [
            5556813,
            5557228,
            5557861,
            5557995,
            5559128,
            5559510,
            5560131,
            5559854,
            5564039,
            5558835,
            5562214,
            5559720,
            5555845,
            5561731,
            5562171,
            5561606,
            5562261,
            5561403,
            8216379
        ],
        "C": [
            5554238,
            5554337,
            5554949,
            5554592,
            5554549,
            5556387,
            5557557,
            5554236,
            5556931,
            5559205,
            5555878,
            5557269,
            5561573,
            5555439,
            5557184,
            5557477,
            5558631,
            5558088,
            5558866
        ],
        "B": [
            5553450,
            5553574,
            5553632,
            5553677,
            5555408,
            5554569,
            5553596,
            5556019,
            5554338,
            5553306,
            5553948,
            5560235,
            5560773,
            5557562,
            5554753,
            5556550,
            5557175,
            5558723,
            5557766
        ],
        "A": [
            5551839,
            5552020,
            5551945,
            5551789,
            5552122,
            5552095,
            5551986,
            5551831,
            5552492,
            5551800,
            5551769,
            5551863,
            5552473,
            5552326,
            5555120,
            5553391,
            5552249,
            5552366
        ]
    },
    "name": "C. Maze",
    "statement": "Pavel loves grid mazes. A grid maze is an rectangle maze where each cell\r\nis either empty, or is a wall. You can go from one cell to another only\r\nif both cells are empty and have a common side.Pavel drew a grid maze\r\nwith all empty cells forming a connected area. That is, you can go from\r\nany empty cell to any other one. Pavel doesnâ€™t like it when his maze has\r\ntoo little walls. He wants to turn exactly empty cells into walls so\r\nthat all the remaining cells still formed a connected area. Help him.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint n, m, k;\nchar board[600][600];\nint d[600][600];\n\nvoid dfs(int a, int b, int& left) {\n  d[a][b] = 1;\n\n  if (a - 1 >= 0 && board[a - 1][b] == '.' && d[a - 1][b] == 0) dfs(a - 1, b, left);\n  if (a + 1 < n && board[a + 1][b] == '.' && d[a + 1][b] == 0) dfs(a + 1, b, left);\n  if (b - 1 >= 0 && board[a][b - 1] == '.' && d[a][b - 1] == 0) dfs(a, b - 1, left);\n  if (b + 1 < m && board[a][b + 1] == '.' && d[a][b + 1] == 0) dfs(a, b + 1, left);\n  if (left > 0) {\n    --left;\n    board[a][b] = 'X';\n  }\n}\n\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &k);\n  for (int i = 0; i < n; ++i) scanf(\"%s\", board[i]);\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      d[i][j] = 0;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (board[i][j] == '.') {\n        dfs(i, j, k);\n        goto end;\n      }\n    }\n  }\nend:;\n  for (int i = 0; i < n; ++i) {\n    printf(\"%s\\n\", board[i]);\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Maze.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "Start BFS or DFS from any free cell. As the maze is connected, this search will visit all s free cells. But we can stop the search when it visits s?-?k free cells. It's obvious that these s?-?k cells are connected to each other. Remaining k cells can be transformed into the walls.\n\nSolutions which every move transform the cell which has the minimal number of neighbours passed pretests. However, it's wrong. Here is the counter-test:\n\n....\n.#..\n..##\n..##\nTop-left cell has no more neighbours than any other cell but we cannot transform it into the wall.",
    "hint": []
}