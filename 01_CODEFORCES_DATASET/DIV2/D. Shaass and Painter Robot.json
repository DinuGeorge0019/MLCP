{"link": "https://codeforces.com//contest/294/problem/D", "problemId": "2809", "problem_idx": "D", "shortId": "294D", "contest_number": "294", "problem_submissions": {"D": [3489455, 3490392], "E": [3487299, 3487883, 3488957, 3485802, 3487525, 3494240, 3497332, 3493600, 3489972], "C": [3486147, 3485304, 3486088, 3488625, 3489289, 3484703, 3483687, 3487009, 3485239, 3485635, 3486050, 3485757, 3485793, 3486458, 3486345, 3485667, 3486505, 3486019], "A": [3482812, 3482475, 3482613, 3488228, 3482534, 3482882, 3482485, 3482654, 3482539, 3482697, 3482561, 3482633, 3483083, 3483097, 3483409, 3482585, 3483087, 3482816], "B": [3483440, 3483787, 3487702, 3490250, 3483629, 3484145, 3483917, 3483569, 3484549, 3484018, 3484016, 3483940, 3484588, 3484893, 3483567, 3484832, 3485008]}, "name": "D. Shaass and Painter Robot", "statement": "Shaass thinks a kitchen with all white floor tiles is so boring. His\r\nkitchen floor is made of square tiles forming a rectangle. Therefore\r\nhe\u2019s decided to color some of the tiles in black so that the floor looks\r\nlike a checkerboard, which is no two side-adjacent tiles should have the\r\nsame color.Shaass wants to use a painter robot to color the tiles. In\r\nthe beginning the robot is standing in a border tile facing a diagonal\r\ndirection (i.e. upper-left, upper-right, down-left or down-right). As\r\nthe robot walks in the kitchen he paints every tile he passes even if\r\nit\u2019s painted before. Painting each tile consumes one unit of black\r\npaint. If at any moment the robot hits a wall of the kitchen he changes\r\nhis direction according the reflection rules. Note that a tile gets\r\npainted when the robot enters the tile from another tile, in other words\r\nchanging direction in the same tile doesn\u2019t lead to any painting. The\r\nfirst tile the robot is standing on, is also painted.The robot stops\r\npainting the first moment the floor is checkered. Given the dimensions\r\nof the kitchen and the position of the robot, find out the amount of\r\npaint the robot consumes before it stops painting the floor.Let\u2019s\r\nconsider an examples depicted below. If the robot starts at tile number\r\n1 (the tile ) of the left grid heading to down-right it\u2019ll pass tiles\r\n1354236 and consumes 7 units of black paint on his way until he stops at\r\ntile number 6. But if it starts at tile number 1 in the right grid\r\nheading to down-right it will get stuck in a loop painting tiles 1, 2,\r\nand 3.\r\n", "solutions": ["#include <cstdio>\n#include <set>\n#include <string>\n#include <iostream>\nusing namespace std;\nstruct State\n{\n    int x, y, vec;\n    bool operator< (const State &a) const\n    {\n        if (x != a.x)\n            return x < a.x;\n        else if (y != a.y)\n            return y < a.y;\n        else\n            return vec < a.vec;\n    }\n};\nint main()\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    string s;\n    cin >> s;\n    int vec;\n    if (s == \"UL\")\n        vec = 0;\n    else if (s == \"UR\")\n        vec = 1;\n    else if (s == \"DL\")\n        vec = 2;\n    else\n        vec = 3;\n    set <State> st, udst;\n    State now, udnow;   \n    now.x = x;\n    now.y = y;\n    now.vec = vec;\n    udnow.x = x;\n    udnow.y = y;\n    udnow.vec = 0;  \n    long long ans = 0;\n    while (1)\n    {\n        //printf(\"%d %d %d\\n\", now.x, now.y, now.vec);\n        int &vec = now.vec;\n        if (st.find(now) != st.end())\n            break;\n        st.insert(now);\n        udst.insert(udnow);\n        if (udst.size() == n + m - 2)\n            break;\n        int step = 0;\n        if (now.vec == 0)\n        {\n            step = min(now.x - 1, now.y - 1);\n            now.x -= step;\n            now.y -= step;\n            if (now.x == now.y)\n                vec = 3;\n            else if (now.x < now.y)\n                vec = 2;\n            else\n                vec = 1;\n        }\n        else if (now.vec == 1)\n        {\n            step = min(now.x - 1, m - now.y);\n            now.x -= step;\n            now.y += step;\n            if (now.x == m - now.y + 1)\n                vec = 2;\n            else if (now.x < m - now.y + 1)\n                vec = 3;\n            else \n                vec = 0;\n        }\n        else if (now.vec == 2)\n        {\n            step = min(n - now.x, now.y - 1);\n            now.x += step;\n            now.y -= step;\n            if (n - now.x + 1 == now.y)\n                vec = 1;\n            else if (n - now.x + 1 < now.y)\n                vec = 0;\n            else\n                vec = 3;\n        }\n        else \n        {\n            step = min(n - now.x, m - now.y);\n            now.x += step;\n            now.y += step;\n            if (n - now.x == m - now.y)\n                vec = 0;\n            else if (n - now.x < m - now.y)\n                vec = 1;\n            else\n                vec = 2;\n        }\n        ans += step;\n        udnow = now;\n        udnow.vec = 0;\n    }\n    //printf(\"%d\\n\", udst.size());\n    if (udst.size() != n + m - 2)\n        ans = -1;\n    else\n        ++ans;\n    printf(\"%I64d\\n\", ans);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "implementation", "number theory"], "dificulty": "2500", "interactive": false}