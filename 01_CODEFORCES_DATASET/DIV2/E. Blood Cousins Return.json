{
    "link": "https://codeforces.com//contest/246/problem/E",
    "problemId": "2239",
    "problem_idx": "E",
    "shortId": "246E",
    "contest_number": "246",
    "problem_submissions": {
        "E": [
            2618309,
            2625699,
            2625672,
            2625616
        ],
        "D": [
            2614880,
            2615580,
            2616212,
            2614968,
            2614320,
            2614660,
            2616653,
            2616273,
            2613212,
            2614960,
            2617901,
            2614696,
            2616035,
            2614578,
            2615857,
            2616416,
            2616305,
            2614469,
            2615989,
            2614634
        ],
        "C": [
            2614006,
            2613802,
            2615098,
            2617187,
            2615874,
            2612559,
            2614266,
            2614575,
            2614275,
            2616756,
            2615418,
            2616320,
            2614220,
            2615862,
            2614590,
            2615086,
            2614032,
            2615573,
            2614720,
            2616902
        ],
        "B": [
            2612557,
            2612051,
            2612469,
            2612350,
            2611530,
            2613518,
            2611821,
            2612876,
            2615385,
            2612183,
            2613369,
            2612732,
            2612231,
            2612645,
            2611735,
            2612717,
            2612424,
            2613466,
            2613427,
            2613236
        ],
        "A": [
            2611340,
            2611588,
            2611575,
            2611688,
            2611152,
            2611180,
            2612517,
            2612042,
            2615112,
            2611515,
            2611961,
            2611233,
            2611703,
            2611227,
            2611218,
            2611222,
            2611497,
            2611116,
            2612114,
            2612186
        ]
    },
    "name": "E. Blood Cousins Return",
    "statement": "Polycarpus got hold of a family tree. The found tree describes the\r\nfamily relations of people, numbered from 1 to . Every person in this\r\ntree has at most one direct ancestor. Also, each person in the tree has\r\na name, the names are not necessarily unique.We call the man with a\r\nnumber a 1-ancestor of the man with a number , if the man with a number\r\nis a direct ancestor of the man with a number .We call the man with a\r\nnumber a -ancestor of the man with a number , if the man with a number\r\nhas a 1-ancestor, and the man with a number is a -ancestor of the\r\n1-ancestor of the man with a number .In the tree the family ties do not\r\nform cycles. In other words there isn’t a person who is his own direct\r\nor indirect ancestor (that is, who is an -ancestor of himself, for some\r\n, ).We call a man with a number the -son of the man with a number , if\r\nthe man with a number is a -ancestor of the man with a number\r\n.Polycarpus is very much interested in how many sons and which sons each\r\nperson has. He took a piece of paper and wrote pairs of numbers , . Help\r\nhim to learn for each pair , the number of distinct names among all\r\nnames of the -sons of the man with number .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\nconst int maxn=1000*100*2;\nvi g[maxn], q[maxn], qi[maxn], rt;\nchar S[100000];\nstring s[maxn], ts[maxn];\nint n, m, nm[maxn], ans[maxn], l[maxn], zz;\nvector<set<int> > T[maxn];\nvoid mer(set<int> &l, set<int> &r)\n{\n    if (l.size()<r.size()) l.swap(r);\n    for (set<int>::iterator it=r.begin(); it!=r.end(); it++)\n        l.insert(*it);\n}\nint nh;\nvoid dfs(int v, int h=0)\n{\n    nh++;\n    for (int i=0;i<q[v].size();i++)\n    {\n        int th=h+q[v][i];\n        l[qi[v][i]]=T[th].size();\n    }\n    set<int> tst;\n    tst.insert(lower_bound(ts, ts+zz, s[v])-ts);\n    T[h].push_back(tst);\n    for (int i=0; i<g[v].size(); i++)\n        dfs(g[v][i], h+1);\n    for (int i=0;i<q[v].size();i++)\n    {\n        int th=h+q[v][i], tl=l[qi[v][i]], tr=T[th].size();\n        if (tl==tr) continue;\n        for (int j=tr-1; j-1>=tl; j--)\n        {\n            mer(T[th][j-1], T[th][j]);\n            T[th].pop_back();\n        }\n        ans[qi[v][i]]=T[th][tl].size();\n    }\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i=0; i<n;i++)\n    {\n        int p; scanf(\"%s %d\", S, &p);\n        s[i]=ts[i]=string(S, S+strlen(S));\n        p--;\n        if (p!=-1) g[p].push_back(i); else rt.push_back(i);\n    }\n    scanf(\"%d\", &m);\n    for (int i=0; i<m; i++)\n    {\n        int v, k;\n        scanf(\"%d %d\", &v, &k);\n        v--;\n        q[v].push_back(k);\n        qi[v].push_back(i);\n    }\n    sort(ts, ts+n); zz=unique(ts, ts+n)-ts;\n    for (int i=0; i<rt.size(); i++) dfs(rt[i], nh);\n    for (int i=0; i<m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "dp",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Blood Cousins Return.json",
    "editorial_link": "https://codeforces.com//blog/entry/5934",
    "editorial": "This problem had little in common with problem 208E - Blood Cousins. In comments to this problem there was given a solution using structure deque (array in which you can add or delete elements from both endings). Lets describe solution using this structure.\n\nFirstly all different names change with different integers and for every vertex v save all queries with this vertex. Then for every vertex, which is root of some tree make dfs, the parameters of dfs are vertex v and deque <set > z. This deque for every depth i of the subtree of v save set  all different names (integers) on depth i.\n\nThis deque could be calculated simply. Consider all sons of v and calculate such deque for them. Obviously, the size of our deque z will be maximum of sizes of descendants deques. Then consider every descendants deques and merge appropriate sets of integers. Of course, we will merge smaller set to a larger set. After that you should insert to the beginning of deque z the set of size 1  color of vertex v.\n\nAfter this, you can at once answer all queries of vertex v. Answer is 0 if v has no descendants on the depth k or the size of z[k]. It is known that such method has good asymptotic, the authors solution works about one second. The asymptotic is O(N·log2(N)).\n\nThe solution should be realized carefully. You must not copy every element of your set or deque. You should do swap of smaller and greater set or deque without copying elements ant than merge smaller to greater.",
    "hint": []
}