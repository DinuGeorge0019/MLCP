{"link": "https://codeforces.com//contest/337/problem/E", "problemId": "3395", "problem_idx": "E", "shortId": "337E", "contest_number": "337", "problem_submissions": {"A": [12299505, 4287779, 4294787, 4288908, 4287593, 4287655, 4288715, 4287767, 4287597, 4289361, 4292228, 4297873, 4287659, 4288000, 4287546, 4288581, 4287692, 4288502], "E": [4297308, 4294426, 4299642, 7151846, 4296911, 4298400], "D": [4293164, 4295622, 4296185, 4297268, 4295484, 4297391, 4293932, 4295013, 4295647, 4297089, 4306458, 4315672, 4296531], "C": [4291413, 4292827, 4290434, 4291634, 4291820, 4293004, 4295602, 4293040, 4292436, 4290283, 4292545, 4293113, 4292103, 4291206, 4293573, 4292596], "B": [4289325, 4294106, 4292267, 4289473, 4288898, 4289573, 4288545, 4289624, 4292085, 4290934, 4289760, 4289731, 4290149, 4289634, 4289994, 4289149, 4302088]}, "name": "E. Divisor Tree", "statement": "A is a rooted tree that meets the following conditions: Each vertex of\r\nthe tree contains a positive integer number. The numbers written in the\r\nleaves of the tree are prime numbers. For any inner vertex, the number\r\nwithin it is equal to the product of the numbers written in its\r\nchildren. Manao has distinct integers . He tries to build a divisor tree\r\nwhich contains each of these numbers. That is, for each , there should\r\nbe at least one vertex in the tree which contains . Manao loves compact\r\nstyle, but his trees are too large. Help Manao determine the minimum\r\npossible number of vertices in the divisor tree sought.\r\n", "solutions": ["#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define N 1000010\n#define int64 long long\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nstruct ww {\n    int64 a;\n    int sum;\n} a[10];\nint i,j,k,n,m,an;\nint f[N],p[N],sum[N],s[100],ff[10],f1[10];\nint64 x,g[N];\n/*inline int work(int x) {\n    if (x==1) return 1;\n    return work(x/2+x%2)+x/2*2;\n}\ninline int work1(int x,int y) {\n    int A=x/2;\n    if (A<y) return s[y]+s[x-y]+1;\n    return min(f1[A][y]+s[x-A],f1[x-A][y]+s[A]);\n}*/\ninline void prepare() {\n    int i,j,k,u;\n    For(i,2,N-1) {\n        if (!f[i]) f[i]=p[++*p]=i;\n        for (j=1;j<=*p&&p[j]<=f[i]&&p[j]*i<N;j++) f[p[j]*i]=p[j];\n    }\n    /*For(i,1,50) s[i]=work(i),f1[i][i]=1;\n    For(i,2,50)For(j,1,i-1) f1[i][j]=work1(i,j);\n    For(i,3,50)For(j,1,i-1)For(k,1,i-j) {\n        int A=N;\n        For(u,j,i-k) A=min(A,f1[u][j]+f1[i-u][k]+1);\n        For(u,j+k,i-1) A=min(A,f2[u][j][k]+s[i-u]+1);\n        f2[i][j][k]=A;\n    }*/\n}\ninline bool cc1(const ww &a,const ww &b) {\n    return a.sum<b.sum;\n}\n/*inline void calc(int x,int &y) {\n    if (!ff[x]) {\n        y+=s[a[x].sum]; return;\n    }\n    if (ff[x]==1) {\n        y+=f1[a[x].sum][a[g[x]].sum]; return;\n    }\n    if (ff[x]==2) {\n        y+=f2[a[x].sum][a[g[x]].sum][a[h[x]].sum]; return;\n    }\n}*/\nvoid dfs(int x,int y,int sum) {\n    if (x>n) {\n        an=min(an,y+(sum>1)); return;\n    }\n    y+=(a[x].sum>1)+a[x].sum-f1[x];\n    dfs(x+1,y,sum+1);\n    int i;\n    For(i,x+1,n) {\n        if (a[i].a/g[i]%a[x].a==0) {\n            f1[i]+=a[x].sum; g[i]*=a[x].a; dfs(x+1,y,sum); g[i]/=a[x].a;\n            f1[i]-=a[x].sum;\n        }\n    }\n}\nint main() {\n    scanf(\"%d\",&n);\n    For(i,1,n) scanf(\"%I64d\",&a[i].a);\n    prepare();\n    For(i,1,n) {\n        for (j=1,x=a[i].a;j<=*p&&x>1;j++)\n        for (;x%p[j]==0;x/=p[j],a[i].sum++);\n        if (x>1) a[i].sum++; g[i]=1;\n    }\n    sort(a+1,a+n+1,cc1);\n    an=N; dfs(1,0,0);\n    printf(\"%d\\n\",an);\n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "number theory", "trees"], "dificulty": "2200", "interactive": false}