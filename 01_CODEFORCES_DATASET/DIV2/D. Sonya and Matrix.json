{
    "link": "https://codeforces.com//contest/1004/problem/D",
    "problemId": "195380",
    "problem_idx": "D",
    "shortId": "1004D",
    "contest_number": "1004",
    "problem_submissions": {
        "D": [
            40003970,
            40002114,
            40006190,
            40065552,
            40018246,
            40318920,
            39996575,
            39998916,
            39999974,
            40000249,
            40000299
        ],
        "E": [
            40002484,
            40005119,
            40002116,
            39999883,
            39999448,
            40001703,
            40001918,
            40001172,
            40000650,
            40002637,
            40008283,
            40003263,
            40002856,
            40003509,
            40018331,
            40018260,
            40018197,
            40017976,
            40019825
        ],
        "F": [
            40001175,
            40176983,
            40353564,
            40007502,
            40003848
        ],
        "C": [
            39997306,
            39993584,
            39996423,
            39991994,
            39992348,
            39992627,
            39992610,
            39994247,
            39996536,
            39995648,
            39993270,
            39993344,
            39994504,
            39995916,
            39993496,
            39993165,
            39993772,
            39993747,
            39997604
        ],
        "B": [
            39994165,
            39991785,
            39998844,
            39994058,
            39994368,
            39991334,
            39991006,
            39993012,
            39992174,
            39992714,
            39991428,
            39991267,
            39992520,
            39993434,
            39991814,
            39991327,
            39991886,
            39991449,
            39996736
        ],
        "A": [
            39992007,
            39990327,
            39997320,
            39990328,
            39990314,
            39990627,
            39990358,
            39990498,
            39990516,
            39991224,
            39990460,
            39990569,
            39990938,
            39991677,
            39990538,
            39990378,
            39990592,
            39990535,
            39995891
        ]
    },
    "name": "D. Sonya and Matrix",
    "statement": "Since Sonya has just learned the basics of matrices, she decided to play\r\nwith them a little bit.Sonya imagined a new type of matrices that she\r\ncalled . These matrices have exactly one zero, while all other cells\r\nhave the Manhattan distance to the cell containing the zero. The cells\r\nwith equal numbers have the form of a rhombus, that is why Sonya called\r\nthis type so.The Manhattan distance between two cells (x_1, y_1) and\r\n(x_2, y_2) is defined as |x_1 - x_2| + |y_1 - y_2|. For example, the\r\nManhattan distance between the cells (5, 2) and (7, 1) equals to\r\n|5-7|+|2-1|=3. Note that are uniquely defined by n, m, and the\r\ncoordinates of the cell containing the zero.She drew a n\r\ntimes m . She believes that you can not recreate the matrix if she gives\r\nyou only the elements of this matrix in some arbitrary order (i.e., the\r\nsequence of n\r\ncdot m numbers). Note that Sonya will not give you n and m, so only the\r\nsequence of numbers in this matrix will be at your disposal.Write a\r\nprogram that finds such an n\r\ntimes m whose elements are the same as the elements in the sequence in\r\nsome order.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PA;\ntypedef long long LL;\n\n#define MAXN 2000003\n#define MODP 1000000007\n#define FST first\n#define SCD second\n\n\nLL qpow(LL x, int y) {\n\tLL res = 1;\n\tfor (;y>0;y>>=1, x = x*x%MODP) {\n\t\tif (y&1) res = (res*x)%MODP;\n\t}\n\treturn res;\n}\n\nint q[MAXN];\nint c[MAXN];\nint v[MAXN];\n\ninline int chk(int n, int m, int x, int y) {\n\t// cout << n << m << x << y << endl;\n\tmemset(v,0,sizeof(v));\n\tfor (int i=0;i<n;++i) {\n\t\tfor (int j=0;j<m;++j) {\n\t\t\tint d = abs(x-i) + abs(y-j);\n\t\t\t++v[d];\n\t\t}\n\t}\n\tfor (int i=0;i<n*m;i++) if (c[i]!=v[i]) return 0;\n\treturn 1;\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t#endif\n\tint Tn = 1;\n\t// scanf(\"%d\", &Tn);\n\tfor (int ci=1;ci<=Tn;++ci) {\n\t\tint n;\n\t\tcin>>n;\n\t\tint mx = 0;\n\t\tmemset(c,0,sizeof(c));\n\t\tfor (int i=0;i<n;++i) {\n\t\t\tscanf(\"%d\", q+i);\n\t\t\t++c[q[i]];\n\t\t\tif (mx<q[i]) mx=q[i];\n\t\t}\n\t\tint flag = 1;\n\t\tint X=-1, Y=-1;\n\t\tint N=-1, M=-1;\n\t\tfor (int i=1;i<=n&&flag;++i) {\n\t\t\tint k = i*4;\n\t\t\tif (c[i]>k) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c[i]<k) {\n\t\t\t\tX = i-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\tfor (Y=0;Y<n;++Y) {\n\t\t\tif ((Y+1)*(X+1)>n) break;\n\t\t\tint S = mx + 2 + (X+Y);\n\t\t\tLL z = (LL)S*S-4*n;\n\t\t\tif ((LL)sqrt(z)*sqrt(z)==z)  {\n\t\t\t\tint B = sqrt(z);\n\t\t\t\tif ((S-B)%2==0) {\n\t\t\t\t\tN = S-B>>1;\n\t\t\t\t\tM = S-N;\n\t\t\t\t\t// cout << N << \" ! \" << M << \" \" << X << \" \" << Y << endl;\n\t\t\t\t\tif (Y+M-1-X<=mx&&chk(M, N, X, Y)) {\n\t\t\t\t\t\tcout << M << \" \" << N << endl;\n\t\t\t\t\t\tcout << X+1 << \" \" << Y+1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (Y+N-1-X<=mx&&chk(N, M, X, Y)) {\n\t\t\t\t\t\tcout << N << \" \" << M << endl;\n\t\t\t\t\t\tcout << X+1 << \" \" << Y+1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tN = mx+X+1-Y;\n\t\t\tif (N>X && n%N==0) {\n\t\t\t\tM = n%N;\n\t\t\t\tif (M>Y&&N-1-X+M-1-Y<=mx) {\n\t\t\t\t\t// cout << N << \" : \" << M << \" \" << X << \" \" << Y << endl;\n\t\t\t\t\tif (chk(N,M,X,Y)) {\n\t\t\t\t\t\tcout << M << \" \" << N << endl;\n\t\t\t\t\t\tcout << X+1 << \" \" << Y+1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Sonya and Matrix.json",
    "editorial_link": "https://codeforces.com/blog/entry/60443",
    "editorial": "Suppose that a matrix has sizes , zero is located at . Let be the\r\ndistance to the cell , and let the distance to the cell . Obvious that\r\nthe farthest distance from the zero cell will be to a corner cell. The\r\nmaximum number in the list is equal to the maximum distance to a corner\r\ncell (let\u00e2\u0080\u0099s assume that it is ).We know that ; ; ; . And ; ; . Let\u00e2\u0080\u0099s\r\nfind the minimum ) such that the number of occurrences of in the list is\r\nnot equal to . We can notice that . Let\u00e2\u0080\u0099s look at each pair (). If we\r\nknow , and , we can find and restore the matrix. If it could be done, we\r\nalready found the answer.\r\n"
}