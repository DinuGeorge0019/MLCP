{
    "link": "https://codeforces.com//contest/1978/problem/F",
    "problemId": "2700160",
    "problem_idx": "F",
    "shortId": "1978F",
    "contest_number": "1978",
    "problem_submissions": {
        "F": [
            266015924,
            266018575,
            266024125,
            266033740,
            266028083,
            266027710,
            266028585,
            266024095,
            266036440,
            266033576,
            266029665,
            266036412,
            266041436,
            266041844,
            266041967,
            266882750,
            266351108,
            266110975,
            266088026,
            266087920,
            266023524,
            266033401,
            266035217,
            266036624
        ],
        "E": [
            266000524,
            266001801,
            266009793,
            266004105,
            266012414,
            266016063,
            266008012,
            266015249,
            266006615,
            266014173,
            266017400,
            266020084,
            266012817,
            266011255,
            266015571,
            266032339,
            266012543,
            266023085,
            266019516
        ],
        "D": [
            265990967,
            265994660,
            265992821,
            265990827,
            266000702,
            266003653,
            265990714,
            266008157,
            265992101,
            265998993,
            266001887,
            266000172,
            266003373,
            265994305,
            266006281,
            266003246,
            266004799,
            266008989
        ],
        "C": [
            265985379,
            265985354,
            265985444,
            265986444,
            265986598,
            265993956,
            265998241,
            265999992,
            265986085,
            265988153,
            265994441,
            265990408,
            265984296,
            265987378,
            265999490,
            265992981,
            265996795,
            266000530
        ],
        "B": [
            265978142,
            265979065,
            265980009,
            265978941,
            265978322,
            265980965,
            265981356,
            265979492,
            265980232,
            265978357,
            265984882,
            265979643,
            265979302,
            265980231,
            265980858,
            265979553,
            265982486,
            265984445
        ],
        "A": [
            265974530,
            265975393,
            265974727,
            265975783,
            265974454,
            265975693,
            265975843,
            265974877,
            265974450,
            265974422,
            265984603,
            265974317,
            265974305,
            265975484,
            265974419,
            265975133,
            265977387,
            265984150
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130527",
    "editorial": "Notice that since we have cyclic shifts to the right and , the diagonals\r\nparallel to the main one will be in the same connected component, except\r\nfor the case with ones. Diagonals consisting of ones will be counted\r\nseparately and forgotten.After that, we can solve the problem for the\r\none-dimensional case, where each element is a representative of its\r\ndiagonal. By definition, if the GCD of some pair of elements is greater\r\nthan , then this means that they are both divisible by some prime\r\nnumber. Let\u00e2\u0080\u0099s find all the elements of the array-diagonals that are\r\ndivisible by each prime number. Let the indices of the current prime\r\nnumber be . We will draw edges between and if . It is claimed that the\r\nconnected components in such a graph will coincide with the connected\r\ncomponents if we draw edges between all valid pairs. Indeed, if there is\r\nan edge between two elements in the complete graph, this means that the\r\ndistance between them is not greater than , and we can reach them in the\r\nnew graph either by one edge or through elements that are divisible by\r\nthe same prime number.Using the sieve of Eratosthenes, we can quickly\r\nfactorize all numbers into prime divisors, after which the number of\r\nconnected components in the graph can be calculated using DSU or DFS.\r\nThe time complexity of this solution is .\r\n",
    "name": "F. Large Graph",
    "statement": "Given an array a of length n. Let\u2019s construct a square matrix b of size\r\nn\r\ntimes n, in which the i-th row contains the array a cyclically shifted\r\nto the right by (i - 1). For example, for the array a = [3, 4, 5], the\r\nobtained matrix isb =\r\nbegin{bmatrix} 3 & 4 & 5\r\n5 & 3 & 4\r\n4 & 5 & 3\r\nend{bmatrix}Let\u2019s construct the following graph: The graph contains n^2\r\nvertices, each of which corresponds to one of the elements of the\r\nmatrix. Let\u2019s denote the vertex corresponding to the element b_{i, j} as\r\n(i, j). We will draw an edge between vertices (i_1, j_1) and (i_2, j_2)\r\nif |i_1 - i_2| + |j_1 - j_2|\r\nle k and\r\ngcd(b_{i_1, j_1}, b_{i_2, j_2}) > 1, where\r\ngcd(x, y) denotes the greatest common divisor of integers x and y. Your\r\ntask is to calculate the number of connected components^{\r\ndagger} in the obtained graph.^{\r\ndagger}A connected component of a graph is a set of vertices in which\r\nany vertex is reachable from any other via edges, and adding any other\r\nvertex to the set violates this rule.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));const int MAXN=2e6+5;int n,k,m,a[MAXN],fa[MAXN];int p[MAXN],pr[MAXN],lst[MAXN];bool vis[MAXN];inline int find(int x){\twhile(x^fa[x]) x=fa[x]=fa[fa[x]];\treturn x;}void init(){\tfor(int i=2;i<MAXN;i++){\t\tif(!vis[i]) p[i]=i,pr[++m]=i;\t\tfor(int j=1;j<=m&&pr[j]*i<MAXN;j++){\t\t\tp[pr[j]*i]=pr[j];\t\t\tvis[pr[j]*i]=true;\t\t\tif(i%pr[j]==0) break;\t\t}\t}}void solve(){\tcin>>n>>k;\tll ans=0;\tfor(int i=1;i<=n;i++){\t\tcin>>a[i];\t\tif(a[i]==1) ans+=n-2+(i==1);\t}\treverse(a+1,a+n+1);\tfor(int i=1;i<n;i++) a[n+i]=a[i];\tn=2*n-1;\tfor(int i=1;i<=n;i++) fa[i]=i;\tvector<int> ini;\tfor(int i=1;i<=n;i++){\t\twhile(a[i]>1){\t\t\tint x=p[a[i]];a[i]/=x;ini.push_back(x);\t\t\tif(lst[x]&&i-lst[x]<=k) fa[find(i)]=find(lst[x]);\t\t\tlst[x]=i;\t\t}\t}\tfor(int i=1;i<=n;i++) if(find(i)==i) ans++;\tcout<<ans<<'\\n';\tfor(int i:ini) lst[i]=0;}int main(){\tios::sync_with_stdio(false);\t// freopen(\"Otomachi_Una.in\",\"r\",stdin);\t// freopen(\"Otomachi_Una.out\",\"w\",stdout);\tinit();\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Large Graph.json"
}