{
    "link": "https://codeforces.com//contest/1659/problem/E",
    "problemId": "1371415",
    "problem_idx": "E",
    "shortId": "1659E",
    "contest_number": "1659",
    "problem_submissions": {
        "E": [
            153913573,
            153929614,
            153928927,
            153922832,
            153919141,
            153972138,
            153926923,
            153927092,
            153929319,
            153932903,
            153930192,
            153930364,
            153930632,
            153931626,
            153929090,
            153932497,
            153927674,
            153932539,
            153931108,
            153930225
        ],
        "D": [
            153912412,
            153905719,
            153910339,
            153913081,
            153925687,
            153914747,
            153914843,
            153917030,
            153914214,
            153914225,
            153916202,
            153914923,
            153911260,
            153911942,
            153919382,
            153913809,
            153916530,
            153910597,
            153914778,
            153923066
        ],
        "B": [
            153899189,
            153895163,
            153894044,
            153901045,
            153896660,
            153905534,
            153895509,
            153894100,
            153894393,
            153894053,
            153896780,
            153900091,
            153895296,
            153893292,
            153896323,
            153897272,
            153895755,
            153896012,
            153922971,
            153892638
        ],
        "C": [
            153893804,
            153899081,
            153898923,
            153904670,
            153899860,
            153895491,
            153906966,
            153902317,
            153904388,
            153898598,
            153905688,
            153905657,
            153901854,
            153898683,
            153904460,
            153903103,
            153900333,
            153901824,
            153895900,
            153899518
        ],
        "A": [
            153892134,
            153890875,
            153890881,
            153898852,
            153891639,
            153899777,
            153891702,
            153891302,
            153890852,
            153890890,
            153891590,
            153893681,
            153891282,
            153890712,
            153890944,
            153892901,
            153890725,
            153890838,
            153891604,
            153890839
        ],
        "F": [
            153937865
        ]
    },
    "name": "E. AND-MEX Walk",
    "statement": "There is an undirected, connected graph with n vertices and m weighted\r\nedges. A from vertex u to vertex v is defined as a sequence of vertices\r\np_1,p_2,\r\nldots,p_k (which are not necessarily distinct) starting with u and\r\nending with v, such that p_i and p_{i+1} are connected by an edge for 1\r\nleq i < k.We define the of a walk as follows: take the ordered sequence\r\nof edges and write down the weights on each of them in an array. Now,\r\nwrite down the bitwise AND of every nonempty prefix of this array. The\r\nof the walk is the MEX of all these values.More formally, let us have\r\n[w_1,w_2,\r\nldots,w_{k-1}] where w_i is the weight of the edge between p_i and\r\np_{i+1}. Then the of the walk is given by\r\nmathrm{MEX}(\r\n{w_1,\r\n,w_1\r\n& w_2,\r\n,\r\nldots,\r\n,w_1\r\n& w_2\r\n&\r\nldots\r\n& w_{k-1}\r\n}), where\r\n& denotes the bitwise AND operation.Now you must process q queries of\r\nthe form . For each query, find the possible length of a walk from u to\r\nv.The MEX (minimum excluded) of a set is the smallest non-negative\r\ninteger that does not belong to the set. For instance: The MEX of\r\n{2,1\r\n} is 0, because 0 does not belong to the set. The MEX of\r\n{3,1,0\r\n} is 2, because 0 and 1 belong to the set, but 2 does not. The MEX of\r\n{0,3,1,2\r\n} is 4 because 0, 1, 2 and 3 belong to the set, but 4 does not.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconst int NR = 1e5 + 10;\n\nint n, m;\nint Q;\nbool vis[NR];\n\nstruct Dsu {\n\tint fa[NR];\n\tbool mark[NR];\n\tvoid init() {\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x) {\n\t\tif (fa[x] == x) return x;\n\t\treturn fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x != y) fa[x] = y;\n\t}\n} a[30], b[30];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n >> m;\n\tfor (int i = 0; i < 30; i++) a[i].init(), b[i].init();\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tfor (int j = 0; j < 30; j++)\n\t\t\tif (w & (1 << j)) a[j].merge(u, v);\n\t\tif (w & 1) {\n\t\t\tw >>= 1;\n\t\t\tfor (int j = 0; j < 30; j++)\n\t\t\t\tif (w & (1 << j)) b[j].merge(u, v);\n\t\t} else vis[u] = vis[v] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t\tif (vis[i])\n\t\t\tfor (int j = 0; j < 30; j++)\n\t\t\t\tb[j].mark[b[j].find(i)] = 1;\n\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tbool flag = 0;\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tif (a[i].find(u) == a[i].find(v)) { flag = 1; break; }\n\t\tif (flag) {\n\t\t\tcout << 0 << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tif (b[i].mark[b[i].find(u)]) { flag = 1; break; }\n\t\tif (flag) cout << 1 << '\\n';\n\t\telse cout << 2 << '\\n';\n\t}\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. AND-MEX Walk.json",
    "editorial_link": "https://codeforces.com//blog/entry/100938",
    "editorial": "The MEX can only be , , or .Proof: Suppose the MEX is greater than . We\r\nknow that on using the bitwise AND function, some on bits will turn off\r\nand the sequence will be non-increasing.This would imply that we have ,\r\nand in our sequence. However, going from () to () is not possible as an\r\noff bit gets turned on. Hence, and canât both be in our sequence. MEX is\r\n.For MEX to be , there must be a walk from to such that the bitwise AND\r\nof the weights of all the edges in that walk is non-zero. This implies\r\nthat there exists some bit which is on in all the edges of that walk.To\r\ncheck this, we can loop over all possible bits, i.e. goes from to , and\r\nconstruct a new graph for each bit while only adding the edges which\r\nhave the -th bit on. We can use DSU on this new graph and form connected\r\ncomponents. This can be processed before taking the queries.In a query,\r\nwe can go through all bits from to and if we get and in the same\r\ncomponent for some bit, then weâre done and our answer is . MEX is .If\r\nwe didnât get the MEX to be , then we know that is in our sequence.Now,\r\nin our walk, if we ever get a node which has an even edge (letâs say\r\nthis is the first even edge so far) and our bitwise AND so far is\r\ngreater than (it would also be an odd number since thereâs no even\r\nedges), then including this edge in our walk would guarantee a MEX of\r\nsince the even edge has the -th bit off. Taking the bitwise AND with\r\nthis edge guarantees that the last bit stays off until the end of our\r\nwalk and we never get in the sequence. Let us call this node . For a\r\ngiven , if an exists, then an answer of is possible.This also shows us\r\nthat the value of is not relevant, since after we get the even edge, our\r\nMEX is guaranteed to be and the subsequent weights do not matter.For the\r\nbitwise AND of the walk to be an odd number greater than , all edges on\r\nthe walk from to must have the -th bit on and the -th bit on for some in\r\n.Similar to the previous case, we now loop from to and make a new graph\r\nfor each bit while only adding edges which have the -th and the -th bits\r\non, and use DSU to form connected components. Within a component, if any\r\nnode has an even edge, then every node in that component can be the\r\nstarting point of a walk to get the answer as . Then, we go through all\r\nthe nodes. If the current node, say, has an even edge, then we can mark\r\nthe parent node of âs component indicating that this component has an\r\neven edge. In the queries, we can go through all the graphs and if the\r\nparent of in a graph has been marked, then we know that itâs possible to\r\nhave the MEX as .If not, the answer must be since MEX cannot exceed\r\n.Time complexity:\r\n",
    "hint": [
        "Hint 1 Can the MEX ever be ?",
        "Hint 2 For the MEX to be , the AND of the walk should be . This implies that some bit is on for all the edges of the walk. How can you check this efficiently?",
        "Hint 3 Make graphs, with each graph only containing edges where the -th bit is on. You can use disjoint sets on these graphs to solve the above problem.",
        "Hint 4 When MEX is , we know exists in the sequence. We need to avoid and jump from some other number to . We need to get rid of the -th bit while some other bit stays on to ensure we don't get in our sequence. This basically means that we need to walk to a node which has an even edge and ensure our AND so far is . Travelling through the even edge would guarantee that our answer is .",
        "Hint 5 Again, make graphs, with each graph only containing edges where the -th and -th ( ) bits are on. Use disjoint sets on these graphs. For each vertex you can note if it is adjacent to an even edge and then store this information in the disjoint set data structure."
    ]
}