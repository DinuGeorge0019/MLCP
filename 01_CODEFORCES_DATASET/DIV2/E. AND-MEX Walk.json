{"link": "https://codeforces.com//contest/1659/problem/E", "problemId": "1371415", "problem_idx": "E", "shortId": "1659E", "contest_number": "1659", "problem_submissions": {"E": [153913573, 153929614, 153928927, 153922832, 153919141, 153972138, 153926923, 153927092, 153929319, 153932903, 153930192, 153930364, 153930632, 153931626, 153929090, 153932497, 153927674, 153932539, 153931108, 153930225], "D": [153912412, 153905719, 153910339, 153913081, 153925687, 153914747, 153914843, 153917030, 153914214, 153914225, 153916202, 153914923, 153911260, 153911942, 153919382, 153913809, 153916530, 153910597, 153914778, 153923066], "B": [153899189, 153895163, 153894044, 153901045, 153896660, 153905534, 153895509, 153894100, 153894393, 153894053, 153896780, 153900091, 153895296, 153893292, 153896323, 153897272, 153895755, 153896012, 153922971, 153892638], "C": [153893804, 153899081, 153898923, 153904670, 153899860, 153895491, 153906966, 153902317, 153904388, 153898598, 153905688, 153905657, 153901854, 153898683, 153904460, 153903103, 153900333, 153901824, 153895900, 153899518], "A": [153892134, 153890875, 153890881, 153898852, 153891639, 153899777, 153891702, 153891302, 153890852, 153890890, 153891590, 153893681, 153891282, 153890712, 153890944, 153892901, 153890725, 153890838, 153891604, 153890839], "F": [153937865]}, "name": "E. AND-MEX Walk", "statement": "There is an undirected, connected graph with n vertices and m weighted\r\nedges. A from vertex u to vertex v is defined as a sequence of vertices\r\np_1,p_2,\r\nldots,p_k (which are not necessarily distinct) starting with u and\r\nending with v, such that p_i and p_{i+1} are connected by an edge for 1\r\nleq i < k.We define the of a walk as follows: take the ordered sequence\r\nof edges and write down the weights on each of them in an array. Now,\r\nwrite down the bitwise AND of every nonempty prefix of this array. The\r\nof the walk is the MEX of all these values.More formally, let us have\r\n[w_1,w_2,\r\nldots,w_{k-1}] where w_i is the weight of the edge between p_i and\r\np_{i+1}. Then the of the walk is given by\r\nmathrm{MEX}(\r\n{w_1,\r\n,w_1\r\n& w_2,\r\n,\r\nldots,\r\n,w_1\r\n& w_2\r\n&\r\nldots\r\n& w_{k-1}\r\n}), where\r\n& denotes the bitwise AND operation.Now you must process q queries of\r\nthe form . For each query, find the possible length of a walk from u to\r\nv.The MEX (minimum excluded) of a set is the smallest non-negative\r\ninteger that does not belong to the set. For instance: The MEX of\r\n{2,1\r\n} is 0, because 0 does not belong to the set. The MEX of\r\n{3,1,0\r\n} is 2, because 0 and 1 belong to the set, but 2 does not. The MEX of\r\n{0,3,1,2\r\n} is 4 because 0, 1, 2 and 3 belong to the set, but 4 does not.\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconst int NR = 1e5 + 10;\n\nint n, m;\nint Q;\nbool vis[NR];\n\nstruct Dsu {\n\tint fa[NR];\n\tbool mark[NR];\n\tvoid init() {\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x) {\n\t\tif (fa[x] == x) return x;\n\t\treturn fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x != y) fa[x] = y;\n\t}\n} a[30], b[30];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\t\n\tcin >> n >> m;\n\tfor (int i = 0; i < 30; i++) a[i].init(), b[i].init();\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tfor (int j = 0; j < 30; j++)\n\t\t\tif (w & (1 << j)) a[j].merge(u, v);\n\t\tif (w & 1) {\n\t\t\tw >>= 1;\n\t\t\tfor (int j = 0; j < 30; j++)\n\t\t\t\tif (w & (1 << j)) b[j].merge(u, v);\n\t\t} else vis[u] = vis[v] = 1;\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t\tif (vis[i])\n\t\t\tfor (int j = 0; j < 30; j++)\n\t\t\t\tb[j].mark[b[j].find(i)] = 1;\n\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tbool flag = 0;\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tif (a[i].find(u) == a[i].find(v)) { flag = 1; break; }\n\t\tif (flag) {\n\t\t\tcout << 0 << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tif (b[i].mark[b[i].find(u)]) { flag = 1; break; }\n\t\tif (flag) cout << 1 << '\\n';\n\t\telse cout << 2 << '\\n';\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "constructive algorithms", "dfs and similar", "dsu", "graphs"], "dificulty": "2200", "interactive": false}