{
    "link": "https://codeforces.com//contest/242/problem/E",
    "problemId": "2151",
    "problem_idx": "E",
    "shortId": "242E",
    "contest_number": "242",
    "problem_submissions": {
        "D": [
            2537952,
            2537942,
            2539339,
            2539698,
            2539156,
            2539580,
            2537494,
            2542278,
            2538787,
            2539905,
            2536184,
            2537759,
            2542044,
            2538066,
            2564424
        ],
        "C": [
            2537373,
            2537268,
            2536519,
            2536785,
            2537810,
            2537116,
            2537792,
            2536568,
            2536898,
            2537580,
            2536958,
            2536262,
            2537263,
            2538218,
            2536235,
            2542015,
            2536779,
            2536389,
            2538664,
            2537599
        ],
        "B": [
            2536607,
            2534065,
            2534724,
            2534650,
            2534927,
            2535116,
            2534461,
            2535027,
            2534468,
            2533804,
            2535897,
            2534112,
            2534107,
            2535117,
            2534450,
            2534923,
            2542000,
            2534963,
            2534474,
            2534940,
            2535281
        ],
        "A": [
            2536206,
            2533805,
            2533960,
            2533930,
            2534212,
            2534073,
            2533868,
            2533943,
            2533896,
            2534746,
            2535180,
            2533808,
            2533814,
            2534432,
            2533857,
            2533887,
            2541991,
            2534152,
            2533996,
            2533848,
            2534557
        ],
        "E": [
            2535640,
            2536427,
            2538447,
            2538483,
            2538649,
            2538639,
            2537907,
            2539042,
            2537371,
            2537776,
            2539203,
            2536140,
            2538840,
            2538202,
            2564479,
            2541961,
            2541948,
            2542249,
            2542247,
            2542240,
            2539344,
            9226579,
            2538102,
            2538950
        ]
    },
    "name": "E. XOR on Segment",
    "statement": "You’ve got an array , consisting of integers . You are allowed to\r\nperform two operations on this array: Calculate the sum of current array\r\nelements on the segment , that is, count value . Apply the xor operation\r\nwith a given number to each array element on the segment , that is,\r\nexecute . This operation changes exactly array elements. Expression\r\nmeans applying bitwise xor operation to numbers and . The given\r\noperation exists in all modern programming languages, for example in\r\nlanguage and it is marked as \"\", in as \"\".You’ve got a list of\r\noperations of the indicated type. Your task is to perform all given\r\noperations, for each sum query you should print the result you get.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nconst int maxn = 811111;\n\nstruct tree {\n\tint rev[maxn]; int cnt[maxn];\n\n\tinline void reverse(int x, int st, int ed) {\n\t\trev[x] ^= 1;\n\t\tcnt[x] = ed - st + 1 - cnt[x];\n\t}\n\n\tvoid change(int x, int st, int ed, int p, int q) {\n\t\tif (st == p && ed == q) {\n\t\t\treverse(x, st, ed); return ;\n\t\t}\n\n\t\tint mid = (st + ed) / 2;\n\t\tif (rev[x]) {\n\t\t\treverse(x + x, st, mid);\n\t\t\treverse(x + x + 1, mid + 1, ed);\n\t\t\trev[x] = 0;\n\t\t}\n\n\t\tif (q <= mid) {\n\t\t\tchange(x + x, st, mid, p, q);\n\t\t}\n\t\telse {\n\t\t\tif (p > mid) change(x + x + 1, mid + 1, ed, p, q);\n\t\t\telse {\n\t\t\t\tchange(x + x, st, mid, p, mid);\n\t\t\t\tchange(x + x + 1, mid + 1, ed, mid + 1, q);\n\t\t\t}\n\t\t}\n\n\t\tcnt[x] = cnt[x + x] + cnt[x + x + 1];\n\t}\n\n\tint calc(int x, int st, int ed, int p, int q) {\n\t\tif (st == p && ed == q) {\n\t\t\treturn cnt[x];\n\t\t}\n\n\t\tint mid = (st + ed) / 2;\n\t\tif (rev[x]) {\n\t\t\treverse(x + x, st, mid);\n\t\t\treverse(x + x + 1, mid + 1, ed);\n\t\t\trev[x] = 0;\n\t\t}\n\n\t\tint ret;\n\t\tif (q <= mid) ret = calc(x + x, st, mid, p, q);\n\t\telse {\n\t\t\tif (p > mid) ret =  calc(x + x + 1, mid + 1, ed, p, q);\n\t\t\telse ret = calc(x + x, st, mid, p, mid) + calc(x + x + 1, mid + 1, ed, mid + 1, q);\n\t\t}\n\n\t\tcnt[x] = cnt[x + x] + cnt[x + x + 1];\n\t\treturn ret;\n \t}\n\n} F[20];\n\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x; scanf(\"%d\", &x);\n\t\tfor (int j = 0; j < 20; ++j)\n\t\t\tif (x & (1 << j)) F[j].change(1, 1, n, i, i);\n\t}\n\tint m; scanf(\"%d\", &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint t, p, q; scanf(\"%d%d%d\", &t, &p, &q);\n\n\t\tif (t == 1) {\n\t\t\tlong long ans = 0ll;\n\t\t\tfor (int j = 0; j < 20; ++j) ans += (long long) (1 << j) * F[j].calc(1, 1, n, p, q);\n\t\t\tprintf(\"%I64d\\n\", ans);\n\t\t}\n\t\telse {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tfor (int j = 0; j < 20 ;++j) if (x & (1 << j)) F[j].change(1, 1, n, p, q);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. XOR on Segment.json",
    "editorial_link": "https://codeforces.com//blog/entry/5837",
    "editorial": "Letâs write numbers as a table which has size , and is th bit in . Then\r\nsum of numbers on segment equals . The last notation helps us to process\r\nqueries. For fast implementation we should use 20 binary trees like\r\ncartesian trees or range trees. Every tree matchs one of bits (and\r\nmatchs one of the columns of the table ). calculation of sum is equal to\r\ncounting -s from -th to -th. operation \"xor\" equals reversing all bits\r\nfrom -th to -th (i.e. changes to , changes to ). The first operation\r\nexecutes for all bit numbers, the second executes only for bits in which\r\ninput number has ones. These operations may be easy implemented with\r\nbinary trees. The time is .\r\n",
    "hint": []
}