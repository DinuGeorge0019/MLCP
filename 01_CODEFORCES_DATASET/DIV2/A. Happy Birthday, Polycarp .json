{
    "link": "https://codeforces.com//contest/1277/problem/A",
    "problemId": "495581",
    "problem_idx": "A",
    "shortId": "1277A",
    "contest_number": "1277",
    "problem_submissions": {
        "F": [
            66866628,
            66860664,
            66862829,
            66860439,
            66977841,
            66899469,
            66863808,
            92979782,
            92978994,
            92978960,
            92978865,
            66891528,
            66889235,
            66866269,
            67019482
        ],
        "D": [
            66856749,
            66864218,
            66854207,
            66847715,
            66844420,
            66847306,
            66854098,
            66848610,
            66848065,
            66848280,
            66844474,
            66849217,
            66848886,
            66864076,
            66847735
        ],
        "E": [
            66850123,
            66849554,
            66847076,
            66854313,
            66848191,
            66853241,
            66855295,
            66853466,
            66848425,
            66855580,
            66855848,
            66853292,
            66856132,
            92977693,
            66856983,
            66854785,
            125051093,
            66850783,
            66861075
        ],
        "C": [
            66841382,
            66842457,
            66841119,
            66845741,
            66837706,
            66839907,
            66838468,
            66840457,
            66839782,
            66840815,
            66841610,
            66843424,
            66846378,
            66837428,
            66844848,
            66841436,
            66840246,
            66839763
        ],
        "B": [
            66837718,
            66838330,
            66834438,
            66842100,
            66834455,
            66836147,
            66833752,
            66836537,
            66835874,
            66836673,
            66837137,
            66837196,
            66974853,
            66841617,
            66834535,
            66838161,
            66835795,
            66834507,
            66836405
        ],
        "A": [
            66834598,
            66836237,
            66833655,
            66838372,
            66833757,
            66834211,
            66833507,
            66833800,
            66834296,
            66834715,
            66834270,
            66834723,
            66974834,
            66839401,
            66833706,
            66836909,
            66833653,
            66833594,
            66833715
        ]
    },
    "name": "A. Happy Birthday, Polycarp ",
    "statement": "Hooray! Polycarp turned n years old! The Technocup Team sincerely\r\ncongratulates Polycarp!Polycarp celebrated all of his n birthdays: from\r\nthe 1-th to the n-th. At the moment, he is wondering: how many times he\r\nturned number of years?According to Polycarp, a positive integer is if\r\nit consists of only one digit repeated one or more times. For example,\r\nthe following numbers are beautiful: 1, 77, 777, 44 and 999999. The\r\nfollowing numbers are not beautiful: 12, 11110, 6969 and 987654321.Of\r\ncourse, Polycarpus uses the decimal numeral system (i.e. radix is\r\n10).Help Polycarpus to find the number of numbers from 1 to n\r\n(inclusive) that are beautiful.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int t;cin>>t;\n  rep(i,t){\n    ll n;cin>>n;\n    ll m = n;\n    ll ans = 0;\n    ll count = 0;\n    while(m >= 10){\n      ans += 9;\n      m /= 10;\n      count++;\n    }\n    ll p = m;\n    rep(i,count){\n      m *= 10;\n      m += p;\n    }\n    if(m <= n){\n      ans += p;\n    }else{\n      ans += (p-1);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Happy Birthday, Polycarp .json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "It seems that one of the easiest ways to solve this problem is to iterate over all beautiful numbers up to 109\n and check each of the numbers to ensure that it does not exceed n\n. First of all, you can iterate over a length from 1\n to 8\n, supporting a number of the form 11...1 of this length, and inside iterate over a factor for this number from 1\n to 9\n. The main part of a solution might look like this:",
    "hint": []
}