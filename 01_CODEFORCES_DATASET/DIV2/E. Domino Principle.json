{"link": "https://codeforces.com//contest/56/problem/E", "problemId": "296", "problem_idx": "E", "shortId": "56E", "contest_number": "56", "problem_submissions": {"E": [258649, 275636, 258438, 257981, 258601, 259067, 259739], "D": [258330, 258098, 257671, 258532, 258585, 258647, 258137, 259765, 259114, 259097, 259090, 259087, 258433, 258859, 258531, 258403], "C": [257968, 257135, 257281, 257886, 258037, 257842, 257990, 257633, 257657, 257674, 257434, 257851, 257922, 257982], "B": [257322, 275541, 256897, 257039, 257245, 257159, 256958, 257543, 256938, 257029, 256950, 257096, 256939, 257185, 257167, 257332, 257174, 257484], "A": [256682, 258521, 256494, 256668, 256712, 256667, 256559, 256742, 256436, 256563, 256540, 256671, 258296, 256737, 256662, 256687, 256601, 256658]}, "name": "E. Domino Principle", "statement": "Vasya is interested in arranging dominoes. He is fed up with common\r\ndominoes and he uses the dominoes of different heights. He put dominoes\r\non the table along one axis, going from left to right. Every domino\r\nstands perpendicular to that axis so that the axis passes through the\r\ncenter of its base. The -th domino has the coordinate and the height .\r\nNow Vasya wants to learn for every domino, how many dominoes will fall\r\nif he pushes it to the right. Help him do that. Consider that a domino\r\nfalls if it is touched strictly above the base. In other words, the fall\r\nof the domino with the initial coordinate and height leads to the fall\r\nof all dominoes on the segment .\r\n", "solutions": ["//#pragma comment(linker,\"/STACK:256000000\")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\n\n#define ldb long double\n#define LL long long\n#define nextline() {int c; while ((c = getchar()) != 10 && c != EOF);}\n\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n\n#define sqr(x) ((x) * (x))\n#define ABS(a) ((a)<0?-(a):(a))\n#define EQ(a,b) (ABS((a)-(b))<EPS)\n\n#define all(a) a.begin(), a.end()\n#define two(i) (1 << (i))\n#define has(mask, i) ((((mask) & two(i)) == 0) ? false : true)\n\nconst int inf = 1000 * 1000 * 1000;\nconst LL inf64 = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;\n\nvector <int> t;\nint a[200000];\nvector <pair <pair<int, int>, int> > d;\nint ans[200000];\nint n;\n\nvoid build (int i = 1, int l = 0, int r = n-1) \n{\n\tif (i == 1)\n\t\tt.resize (n*4 + 1);\n\tif (l == r)\n\t\tt[i] = a[l];\n\telse \n\t{\n\t\tint m = (l + r) / 2;\n\t\tbuild (i*2, l, m);\n\t\tbuild (i*2+1, m+1, r);\n\t\tt[i] = max(t[i*2], t[i*2+1]);\n\t}\n}\n\nint mx (int l, int r, int i = 1, int tl = 0, int tr = n-1) \n{\n\tif (l == tl && r == tr)\n\t\treturn t[i];\n\tint m = (tl + tr) / 2;\n\tif (r <= m)\n\t\treturn mx (l, r, i*2, tl, m);\n\tif (l > m)\n\t\treturn mx (l, r, i*2+1, m+1, tr);\n\treturn max (mx(l, m, i*2, tl, m), mx (m+1, r, i*2+1, m+1, tr));\n}\n\nvoid update (int pos, int newval, int i = 1, int l = 0, int r = n-1) \n{\n\tif (l == r)\n\t\tt[i] = newval;\n\telse \n\t{\n\t\tint m = (l + r) / 2;\n\t\tif (pos <= m)\n\t\t\tupdate (pos, newval, i*2, l, m);\n\t\telse\n\t\t\tupdate (pos, newval, i*2+1, m+1, r);\n\t\tt[i] = max(t[i*2], t[i*2+1]);\n\t}\n}\n\nvoid Load()\n{\n\tpair <int, int> p;\n\tscanf (\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf (\"%d%d\", &p.first, &p.second);\n\t\td.push_back(make_pair(p, i));\n\t\ta[i] = i;\n\t}\n\tsort (d.begin(), d.end());\n\t\n\t\n\tbuild();\n}\n\nset <pair <int, int> > st;\nset <pair <int, int> > :: iterator it;\n\n\nvoid Solve()\n{\n\tint end;\n\tfor (int i = 0; i < n; i++)\n\t\tst.insert(make_pair(d[i].first.first, i));\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\t\tit = st.lower_bound(make_pair(d[i].first.first + d[i].first.second, -1));\n\t\tif (it == st.end())\n\t\t\tend = n;\n\t\telse\n\t\t\tend = (*it).second;\n\t\t//cerr << i << \" \" << end << \"\\n\";\n\t\tif (i + 1 <= end - 1)\n\t\t\tupdate (i, mx(i + 1, end - 1));\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tans[d[i].second] = 1 + mx(i, i) - i;\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf (\"%d \", ans[i]);\n}\n                \nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\", \"rt\", stdin);\n\tfreopen(\"out\", \"wt\", stdout);\n#endif\n\tLoad();\n\tSolve();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "sortings"], "dificulty": "2200", "interactive": false}