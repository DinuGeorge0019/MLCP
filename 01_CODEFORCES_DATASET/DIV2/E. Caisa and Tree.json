{"link": "https://codeforces.com//contest/463/problem/E", "problemId": "13413", "problem_idx": "E", "shortId": "463E", "contest_number": "463", "problem_submissions": {"E": [7638960, 7637193, 7682816, 7638248, 7639853, 7638211, 7637973, 7639823, 7643707, 7637460, 7639583, 7639708, 7646111, 7680392], "D": [7633516, 7634297, 7633801, 7632252, 7635569, 7633746, 7635006, 7633676, 7631296, 7637376, 7629043, 7638633, 7636946, 7634549, 7632611, 7631941, 7635806, 7635047, 7633827], "A": [7632250, 7626691, 7626688, 7627018, 7627107, 7626706, 7644040, 7631576, 7626744, 7634237, 7634275, 7626965, 7627191, 7627423, 7627095, 7627639, 7628035, 7635333], "B": [7630537, 7627110, 7627719, 7627619, 7629633, 7628175, 7631202, 7629983, 7627256, 7633605, 7632837, 7629106, 7628563, 7629250, 7629192, 7628955, 7630266, 7636050], "C": [7628696, 7632900, 7632098, 7629603, 7634187, 7640208, 7633142, 7628662, 7678669, 7631060, 7637636, 7632929, 7631029, 7638701, 7635241, 7632886, 7633425, 7630271]}, "name": "E. Caisa and Tree", "statement": "Caisa is now at home and his son has a simple task for him.Given a\r\nrooted tree with vertices, numbered from to (vertex is the root). Each\r\nvertex of the tree has a value. You should answer queries. Each query is\r\none of the following: Format of the query is \"1 \". Let\u2019s write out the\r\nsequence of vertices along the path from the root to vertex : . You need\r\nto output such a vertex that and . If there are several possible\r\nvertices pick the one with maximum value of . If there is no such vertex\r\noutput . Format of the query is \"2 \". You must change the value of\r\nvertex to . You are given all the queries, help Caisa to solve the\r\nproblem.\r\n", "solutions": ["#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <stack>\n#include <functional>\n\n#define snuke(it,x) for (__typeof((x).begin()) it = (x).begin(); it != (x).end(); ++ it)\n\ntypedef long long lld;\nconst int INF = 0X3F3F3F3F;\nconst int M = 2000000 + 5;\nconst int N = 100000 + 5;\nstd::stack<int> stack[200000 + 5];\nint prime[M],ptot,min_div[M],Index[M];\nbool doge[M];\nint A[N],answer[N],depth[N];\nstd::stack<int> queries[N];\nstd::vector<int> edges[N];\n\nvoid getPrime(int n) {\n    for (int i = 2; i <= n; ++ i) {\n        if (!doge[i]) {\n            Index[i] = ptot;\n            prime[ptot++] = i;\n            min_div[i] = i;\n        }\n        for (int j = 0; j < ptot; ++ j) {\n            if (i*prime[j]>n) break;\n            doge[i*prime[j]] = true;\n            min_div[i*prime[j]] = prime[j];\n            if (i%prime[j]==0) break;\n        }\n    }\n}\n\nvoid dfs(int u,int fa) {\n    if (fa!=-1) depth[u] = depth[fa] + 1;\n    int value = A[u];\n    int max_depth = -1,p = -2;\n    while (value>1) {\n        int d = min_div[value];\n        while (value%d==0) value /= d;\n        if (!stack[Index[d]].empty()) {\n            int id = stack[Index[d]].top();\n            if (max_depth < depth[id]) {\n                max_depth = depth[id];\n                p = id;\n            }\n        }\n        stack[Index[d]].push(u);\n    }\n    while (!queries[u].empty()) {\n        int id = queries[u].top(); queries[u].pop();\n        answer[id] = p + 1;\n    }\n    snuke(it,edges[u]) {\n        int v = *it;\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n    value = A[u];\n    while (value>1) {\n        int d = min_div[value];\n        while (value%d==0) value /= d;\n        stack[Index[d]].pop();\n    }\n}\n\nvoid solve() {\n    dfs(0,-1);\n}\n\nint main() {\n    getPrime(2000000);\n    int n,nq;\n    scanf(\"%d%d\",&n,&nq);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d\",A+i);\n    }\n    for (int i = 0; i < n-1; ++ i) {\n        int a,b;\n        scanf(\"%d%d\",&a,&b); a --; b --;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    for (int i = 0; i < nq; ++ i) {\n        int op,a,b;\n        scanf(\"%d\",&op);\n        if (op==1) {\n            scanf(\"%d\",&a); a --;\n            queries[a].push(i);\n        } else {\n            scanf(\"%d%d\",&a,&b); a --;\n            solve();\n            A[a] = b;\n            answer[i] = INF;\n        }\n    }\n    solve();\n    for (int i = 0; i < nq; ++ i) {\n        if (answer[i] != INF) {\n            printf(\"%d\\n\",answer[i]);\n        }\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "math", "number theory", "trees"], "dificulty": "2100", "interactive": false}