{
    "link": "https://codeforces.com//contest/1370/problem/E",
    "problemId": "652387",
    "problem_idx": "E",
    "shortId": "1370E",
    "contest_number": "1370",
    "problem_submissions": {
        "F2": [
            84487930,
            84501037,
            84507034,
            84502122,
            84505842,
            84494417,
            84504172,
            84566845,
            84578526,
            84673821,
            84511966,
            84521155,
            84516268,
            84510958,
            84637167,
            84542732
        ],
        "F1": [
            84486378,
            84486419,
            84492617,
            84502436,
            84505676,
            84494227,
            84501907,
            84505799,
            84499630,
            84498065,
            84511746,
            84521030,
            84480006,
            84503644,
            84491858,
            84509184,
            84485122,
            84503318,
            84509115,
            84506881
        ],
        "E": [
            84464817,
            84468991,
            84473151,
            84479507,
            84475443,
            84500759,
            84489817,
            84460631,
            84470842,
            84474055,
            84482485,
            84496561,
            84465043,
            84479036,
            84484283,
            84492032,
            84480292,
            84478287,
            84477997
        ],
        "D": [
            84455500,
            84452319,
            84463814,
            84469488,
            84464677,
            84451453,
            84463855,
            84448741,
            84456676,
            84455689,
            84468315,
            84454815,
            84457156,
            84464597,
            84470092,
            84462687,
            84463427,
            84468065,
            84460953
        ],
        "C": [
            84440472,
            84440716,
            84454929,
            84448947,
            84446464,
            84442992,
            84450392,
            84441491,
            84448508,
            84447398,
            84459387,
            84446704,
            84452028,
            84452970,
            84461892,
            84451604,
            84450230,
            84447402,
            84456732
        ],
        "B": [
            84435577,
            84430992,
            84438860,
            84436667,
            84431532,
            84431988,
            84433331,
            84431260,
            84434049,
            84434058,
            84441995,
            84433852,
            84624590,
            84440409,
            84443832,
            84438516,
            84432500,
            84433721,
            84440325,
            84431147
        ],
        "A": [
            84423084,
            84423206,
            84424226,
            84425612,
            84423582,
            84423261,
            84424093,
            84424056,
            84423388,
            84425755,
            84429438,
            84426743,
            84423750,
            84423134,
            84428806,
            84425122,
            84423069,
            84423389,
            84423328
        ]
    },
    "name": "E. Binary Subsequence Rotation",
    "statement": "Naman has two binary strings s and t of length n (a binary string is a\r\nstring which only consists of the characters \"\" and \"\"). He wants to\r\nconvert s into t using the following operation as few times as\r\npossible.In one operation, he can choose any subsequence of s and rotate\r\nit clockwise once.For example, if s = 1\r\ntextbf{1}101\r\ntextbf{00}, he can choose a subsequence corresponding to indices\r\n(1-based)\r\n{2, 6, 7\r\n} and rotate them clockwise. The resulting string would then be s = 1\r\ntextbf{0}101\r\ntextbf{10}.A string a is said to be a subsequence of string b if a can\r\nbe obtained from b by deleting some characters without changing the\r\nordering of the remaining characters.To perform a clockwise rotation on\r\na sequence c of size k is to perform an operation which sets c_1:=c_k,\r\nc_2:=c_1, c_3:=c_2,\r\nldots, c_k:=c_{k-1} simultaneously.Determine the minimum number of\r\noperations Naman has to perform to convert s into t or say that it is\r\nimpossible.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nset < int > go[2];\n\nmain() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, cnt0 = 0, cnt1 = 0, ans = 0;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    string S = s, T = t;\n    sort(S.begin(), S.end());\n    sort(T.begin(), T.end());\n    if (S != T) {\n        cout << -1;\n        exit(0);\n    }\n    for (int i = 0; i < n; ++i) {\n        if (s[i] != t[i]) {\n            go[s[i] - '0'].insert(i);\n        }\n    }\n    while ((int)go[0].size() > 0 || (int)go[1].size() > 0) {\n        int start = n + 1, f;\n        if ((int)go[0].size() > 0) {\n            int d = (*go[0].begin());\n            if (d < start) start = d, f = 0;\n        }\n        if ((int)go[1].size() > 0) {\n            int d = (*go[1].begin());\n            if (d < start) start = d, f = 1;\n        }\n        ans++;\n        while (1) {\n            go[f].erase(start);\n            f = (f^1);\n            auto p = go[f].lower_bound(start);\n            if (p == go[f].end()) break;\n            start = (*p);\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Binary Subsequence Rotation.json",
    "editorial_link": "https://codeforces.com//blog/entry/79107",
    "editorial": "Firstly, if is not an anagram of , it is impossible to convert to -\r\nsince total number of s and s are conserved. However, if they are\r\nanagrams, we can always convert to .We can ignore all the indices where\r\nas it is never optimal to include those indices in a rotation. The\r\nremaining indices must be satisfy or . In the optimal answer, the chosen\r\nsubsequences should be of the form or .There are many approaches to\r\nsolving the problem, all revolving around the key idea. We can greedily\r\nfind the minimum number of chains of alternating and that the string can\r\nbe broken down into using faster ways of simulation, such as a\r\ncounter-based for loop or using sets and deleting successive indices,\r\netc.However, we will discuss an elegant approach which allows us to\r\nsolve the problem and also prove its optimality. Moreover, it allows us\r\nto solve the problem for queries of the form - which denotes the answer\r\nfor the strings and respectively.Logic: Let\u00e2\u0080\u0099s create an array with\r\nvalues from as follows: If , Else if , Else Then the answer is equal to\r\nthe maximum absolute value of the sum of any subarray in , that is,\r\n).Proof: The chosen subsequences must be of the form or (alternating s\r\nand s). If there are two consecutive s or s we can remove any one of\r\nthem as applying the rotation operation could only affect one of them.\r\nThe maximum absolute value of subarray sum in is a lower bound on the\r\nanswer. Let the sum of any subarray in be . We can assume that\r\n(otherwise we can interchange and ). In any move, cannot be reduced by\r\nmore than , since we must choose subsequences of the form or . We can\r\nachieve the above lower bound, and hence it is the answer. To prove the\r\nclaim, we just need to show that in every operation, we can reduce the\r\nvalue of maximum absolute subarray sum by (if there are multiple such\r\nsubarrays, then we must reduce all of them by ). For the above, a key\r\nrealization is: suppose the maximum comes from a subarray with a\r\npositive sum. Then it is necessary that on both sides of its endpoints\r\nif there is an element, it must be (we can ignore the s), since if\r\neither side had a , we would have a higher valued subarray. Now we can\r\npick any from this subarray and a either from its left or right to\r\nreduce its sum by , thus completing the proof. (Note that any subarray\r\nwith maximum absolute sum must have at least one element with sign\r\nopposite to its sum either to its left or right.) Time complexity:\r\n"
}