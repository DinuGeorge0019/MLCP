{
    "link": "https://codeforces.com//contest/1820/problem/E",
    "problemId": "1880613",
    "problem_idx": "E",
    "shortId": "1820E",
    "contest_number": "1820",
    "problem_submissions": {
        "E": [
            202221495,
            202224197,
            202223650,
            202221055,
            202211278,
            202210773,
            202210525,
            202392193,
            202234544,
            202241741
        ],
        "D": [
            202204493,
            202203834,
            202204941,
            202200357,
            202224521,
            202196714,
            202201649,
            202201288,
            202205548,
            202208808,
            202207552,
            202206152,
            202208768,
            202210206,
            202204088,
            202209173,
            202204193,
            202208143
        ],
        "C": [
            202188210,
            202190438,
            202191871,
            202204067,
            202186370,
            202194680,
            202193928,
            202184998,
            202190422,
            202190852,
            202188780,
            202191686,
            202189589,
            202189497,
            202191313,
            202189933,
            202193203,
            202191781,
            202192559,
            202193037
        ],
        "B": [
            202184059,
            202186314,
            202188694,
            202185290,
            202181971,
            202185877,
            202195824,
            202184988,
            202186184,
            202184424,
            202184282,
            202185384,
            202184368,
            202185406,
            202183611,
            202187273,
            202187259,
            202188101,
            202186319
        ],
        "A": [
            202181070,
            202181088,
            202184573,
            202180673,
            202180868,
            202181103,
            202180754,
            202181157,
            202181299,
            202180503,
            202180966,
            202180804,
            202180777,
            202180572,
            202180527,
            202180589,
            202182901,
            202184035,
            202181508
        ],
        "F": [
            202489739,
            202420015
        ]
    },
    "name": "E. The Fox and the Complete Tree Traversal",
    "statement": "The fox Yae climbed the of the Sacred Sakura. A tree is a connected\r\nundirected graph that does not contain cycles.The fox uses her magical\r\npowers to move around the tree. Yae can jump from vertex v to another\r\nvertex u if and only if the distance between these vertices does not\r\nexceed 2. In other words, in one jump Yae can jump from vertex v to\r\nvertex u if vertices v and u are connected by an edge, or if there\r\nexists such vertex w that vertices v and w are connected by an edge, and\r\nalso vertices u and w are connected by an edge.After Yae was able to get\r\nthe sakura petal, she wondered if there was a route in the tree v_1,\r\nv_2,\r\nldots, v_n such that: the fox can jump from vertex v_i to vertex v_{i +\r\n1}, the fox can jump from vertex v_n to vertex v_1, all v_i are pairwise\r\ndistinct. Help the fox determine if the required traversal exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FORI(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n \nmt19937 rnd(time(0));\n\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define endl '\\n'\n\n#define mp(m, n) make_pair((m), (n))\n \ntemplate<typename T>\nvoid read(vector<T> &t) {FOR(i, t.size()) {cin >> t[i];}}\ntemplate<typename T> string tostring(T a) { istringstream sin; sin >> a; return sin.str(); }\n \n// #define DEBUG\n \n#ifdef DEBUG\ntemplate<typename T>\nvoid _debug(string s, T x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, unordered_map<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \":\" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, map<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \":\" << it->second;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, set<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, vector<pair<T, K> > x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \",\" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, pair<T, K> x) {\n    cerr << s << \": \" << x.first << \",\" << x.second << endl;\n}\n \nvoid _debug(string s, int x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, long long x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, double x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, string x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, char x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, size_t x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, bool x) {\n    cerr << s << \": \" << x << endl;\n}\n \n#define debug(x) _debug(#x, (x))\n#else\n#define debug(x)\n#endif\n \n#define db debug\n\ntemplate <class T>\nvoid print(vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        cout << v[i];\n        if (i == v.size() - 1) {\n            cout << endl;\n        } else {\n            cout << \" \";\n        }\n    }\n}\n\nvoid solve();\n \nvoid pre_init();\n\nint main() {\n    ios_base::sync_with_stdio(false); std::cin.tie(0);\n    pre_init();\n    int t = 1;\n    // cin >> t;\n    while (t--) {\n        solve();\n    }\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}\n \nvoid pre_init() {}\n\nvoid dfs(vector<vector<int> > &vp, vector<int> &depth, vector<int> &fnode, int x, int f) {\n    for (int i = 0; i < vp[x].size(); i++) {\n        int v = vp[x][i];\n        if (v == f) continue;\n        fnode[v] = x;\n        depth[v] = depth[x] + 1;\n        dfs(vp, depth, fnode, v, x);\n    }\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<vector<int> > vp(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        vp[a].push_back(b);\n        vp[b].push_back(a);\n    }\n    vector<int> depth(n), fnode(n);\n    dfs(vp, depth, fnode, 0, -1);\n    int t = std::max_element(depth.begin(), depth.end()) - depth.begin();\n    depth[t] = 0; fnode[t] = -1;\n    dfs(vp, depth, fnode, t, -1);\n    int tt = std::max_element(depth.begin(), depth.end()) - depth.begin();\n    vector<int> v;\n    v.push_back(tt);\n    while (tt != t) {\n        tt = fnode[tt];\n        v.push_back(tt);\n    }\n    vector<int> used(n);\n    for (int i = 0; i < v.size(); i++) used[v[i]] = 1;\n    vector<int> qx;\n    if (v.size() == 2) {\n        cout << \"Yes\" << endl;\n        cout << \"1 2\" << endl;\n        return;\n    }\n    if (v.size() % 2 == 1) {\n        for (int i = 0; i < v.size(); i++) {\n            qx.push_back(i % 2 == 0 ? i : - i);\n        }\n        for (int i = v.size() - 2; i >= 1; i--) {\n            qx.push_back(i % 2 == 1 ? i : - i);\n        }\n    } else {\n        for (int i = 0; i < v.size() - 1; i++) {\n            qx.push_back(i % 2 == 0 ? i : - i);\n        }\n        for (int i = v.size() - 1; i >= 1; i--) {\n            qx.push_back(i % 2 == 1 ? i : - i);\n        }\n    }\n    debug(v);\n    debug(qx);\n    vector<int> final_ans;\n    for (int i = 0; i < qx.size(); i++) {\n        int x = qx[i];\n        if (x >= 0) {\n            final_ans.push_back(v[x] + 1);\n        } else {\n            x = -x;\n            for (int j = 0; j < vp[v[x]].size(); j++) {\n                if (!used[vp[v[x]][j]]) {\n                    final_ans.push_back(vp[v[x]][j] + 1);\n                }\n            }\n        }\n    }\n    if (final_ans.size() == n) {\n        cout << \"Yes\" << endl;\n        print (final_ans);\n    } else {\n        cout << \"No\" << endl;\n    }\n    // debug(final_ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Fox and the Complete Tree Traversal.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "Note that if the tree contains the subgraph shown below, then there is no answer. To prove this it is enough to consider all possible cases for how a cyclic route can pass through the upper vertex and understand that it is impossible to construct such route.\n\n\nLet's assume that the tree does not contain the subgraph shown. It is easy to see that in this case, the tree can be represented as a path and vertices directly attached to it. To check that the tree can be represented in this way, we will find the diameter of the tree and check that all other vertices are directly connected to it. Now we need to learn how to build a cyclic route.\n\nNumber the vertices of the diameter from 1\n to k\n in the order of traversal of the diameter from one end to the other. Now let's build the route as follows. Firstly, visit vertex 1\n, then visit all vertices not on the diameter attached to vertex 2\n, then move to vertex 3\n, then to all vertices not on the diameter attached to vertex 4\n, and so on. When we reach the end of the diameter, we will visit all vertices of the diameter with even numbers, as well as all vertices of the tree not on the diameter attached to the vertices of the diameter with odd numbers. Now let's make the same route in the opposite direction along the diameter, but through vertices of a different parity, which reaches vertex 2\n.\n\nTime complexity: O(n)\n."
}