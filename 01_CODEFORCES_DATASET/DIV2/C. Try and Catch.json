{
    "link": "https://codeforces.com//contest/195/problem/C",
    "problemId": "1421",
    "problem_idx": "C",
    "shortId": "195C",
    "contest_number": "195",
    "problem_submissions": {
        "E": [
            1777341,
            1777807,
            1780602,
            1778882,
            1779695,
            1778939,
            1778079,
            1779584,
            1779643,
            1780676,
            1779994,
            1779882,
            1781688
        ],
        "D": [
            1776612,
            1777077,
            1778398,
            1777210,
            1777366,
            1777818,
            1778286,
            1778743,
            1779250,
            1776789,
            1779690,
            1779525,
            1779340,
            1779758
        ],
        "C": [
            1776366,
            1778703,
            1777228,
            1786363,
            1778918,
            1777720,
            1778071,
            1778134,
            1779053,
            1780725,
            1777787,
            1778730,
            1778503,
            1778557
        ],
        "B": [
            1775818,
            1776287,
            1776244,
            1776178,
            1776166,
            1776316,
            1776212,
            1776715,
            1776133,
            1776660,
            1776543,
            1776189,
            1776717,
            1777992,
            1776246,
            1777021,
            1776348,
            1776593
        ],
        "A": [
            1775640,
            1775659,
            1775647,
            1775756,
            1775776,
            1775645,
            1775901,
            1776042,
            1775714,
            1776301,
            1775707,
            1775754,
            1776172,
            1777471,
            1775841,
            1775942,
            1776937,
            1775764
        ]
    },
    "name": "C. Try and Catch",
    "statement": "Vasya is developing his own programming language VPL (Vasya Programming\r\nLanguage). Right now he is busy making the system of exceptions. He\r\nthinks that the system of exceptions must function like that.The\r\nexceptions are processed by try-catch-blocks. There are two operators\r\nthat work with the blocks: The operator. It opens a new try-catch-block.\r\nThe operator. It closes the try-catch-block that was started last and\r\nhaven’t yet been closed. This block can be activated only via exception\r\nof type <exception_type>. When we activate this block, the screen\r\ndisplays the <message>. If at the given moment there is no open\r\ntry-catch-block, then we can’t use the operator.The exceptions can occur\r\nin the program in only one case: when we use the operator. The operator\r\ncreates the exception of the given type.Let’s suggest that as a result\r\nof using some operator the program created an exception of type . In\r\nthis case a try-catch-block is activated, such that this block’s\r\noperator was described in the program earlier than the used operator.\r\nAlso, this block’s operator was given an exception type as a parameter\r\nand this block’s operator is described later that the used operator. If\r\nthere are several such try-catch-blocks, then the system activates the\r\nblock whose operator occurs earlier than others. If no try-catch-block\r\nwas activated, then the screen displays message \"\".To test the system,\r\nVasya wrote a program that contains only , and operators, one line\r\ncontains no more than one operator, the whole program contains exactly\r\none operator.Your task is: given a program in VPL, determine, what\r\nmessage will be displayed on the screen.\r\n",
    "solutions": [
        "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N >> ws;\n\n    stack<int> es;\n    int th = -1;\n    string tp;\n    for (int i = 0; i < N; i++)\n    {\n        string line;\n        getline(cin, line);\n        replace(RA(line), '(', ' ');\n        replace(RA(line), ')', ' ');\n        replace(RA(line), ',', ' ');\n        istringstream toks(line);\n\n        string cmd;\n        toks >> cmd;\n        if (cmd == \"try\")\n        {\n            es.push(i);\n        }\n        else if (cmd == \"throw\")\n        {\n            toks >> tp;\n            th = i;\n        }\n        else if (cmd == \"catch\")\n        {\n            string t;\n            toks >> t;\n            if (t == tp && es.top() < th)\n            {\n                string msg;\n                getline(toks, msg);\n                msg.erase(0, msg.find('\"') + 1);\n                msg.erase(msg.find('\"'), msg.size());\n                cout << msg << '\\n';\n                return 0;\n            }\n            es.pop();\n        }\n    }\n    cout << \"Unhandled Exception\\n\";\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "expression parsing",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Try and Catch.json",
    "editorial_link": "https://codeforces.com//blog/entry/4699",
    "editorial": "In this problem you was to implement what was writen in the statement.\r\nIn my solution I did the following. Erase all spaces from the text\r\nexcept spaces in messages in try-catch blocks. Then when we get word\r\n\"try\" we put number of the new try-catch block in stack. When we get\r\nword \"throw\" we remember itâs type and current state of stack (that is\r\nwhat try-catch blocks are opened). For example, put these number in set.\r\nWhen we get word \"catch\" if itâs type equals to type of operator \"throw\"\r\nand the number of current try-catch block is in your set then write the\r\nanswer now else erase this try-catch block from stack. If there was no\r\nsuitable try-catch block write \"Unhandled Exception\".\r\n",
    "hint": []
}