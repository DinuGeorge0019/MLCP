{"link": "https://codeforces.com//contest/937/problem/E", "problemId": "159985", "problem_idx": "E", "shortId": "937E", "contest_number": "937", "problem_submissions": {"B": [35696794, 35702864, 35692823, 35690729, 35694513, 35690544, 35690257, 35698410, 35691221, 35690892, 35691375, 35702558, 35696021, 35691603, 35692248, 35693511, 35689627, 35691074], "D": [35692697, 35713147, 35697020, 35698388, 35700044, 35703123, 35701138, 35701740, 35699988, 35703153, 35699440, 35715758, 35702654, 35703145, 35702583, 35705096, 35704134, 35704747], "C": [35687317, 35691596, 35689373, 35694359, 35690896, 35693744, 35693408, 35694406, 35694106, 35697537, 35696111, 35691520, 35694573, 35696303, 35696728, 35696658, 35694289, 35696468, 35696813], "A": [35686618, 35687353, 35687073, 35686895, 35689698, 35687175, 35687230, 35687897, 35688429, 35688503, 35687868, 35688027, 35686930, 35689664, 35687167, 35686480, 35686539], "E": [35699925, 35705854, 35766833, 35707300, 35705001, 35707037, 35726109, 35750977, 35707021]}, "name": "E. Lock Puzzle", "statement": "Welcome to another task about breaking the code lock! Explorers\r\nWhitfield and Martin came across an unusual safe, inside of which,\r\naccording to rumors, there are untold riches, among which one can find\r\nthe solution of the problem of discrete logarithm!Of course, there is a\r\ncode lock is installed on the safe. The lock has a screen that displays\r\na string of lowercase Latin letters. Initially, the screen displays\r\nstring . Whitfield and Martin found out that the safe will open when\r\nstring will be displayed on the screen.The string on the screen can be\r\nchanged using the operation . In order to apply this operation,\r\nexplorers choose an integer from 0 to inclusive. After that, the current\r\nstring changes to , where the length of is , and the length of is . In\r\nother words, the suffix of the length of string is reversed and moved to\r\nthe beginning of the string. For example, after the operation the string\r\nwill be changed with string , since , , .Explorers are afraid that if\r\nthey apply too many operations , the lock will be locked forever. They\r\nask you to find a way to get the string on the screen, using no more\r\nthan operations.\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid err() {\n    puts(\"-1\");\n    exit(0);\n}\n\nconst int maxN = 2048;\n\nvector<int> pos[maxN];\nvector<int> ans;\n\nchar s[maxN];\nchar t[maxN];\n\nvector<int> _p;\nvector<int> p;\n\nint n;\n\nvoid do_perm() {\n    p.resize(n);\n    _p.resize(n);\n\n    for(int i = 0; i < n; ++i)\n        pos[t[i]].push_back(i);\n    for(int i = 0; i < n; ++i) {\n        if(pos[s[i]].empty())\n            err();\n        p[i] = pos[s[i]].back();\n        pos[s[i]].pop_back();\n//         printf(\"%d \", p[i]);\n    }\n//     puts(\"\");\n}\n\nvoid print() {\n    for(int a: p) printf(\"%d \", a);\n    puts(\"\");\n}\n\nvoid do_move(int x) {\n    if(x == 0) return;\n    ans.push_back(x);\n    for(int i = 0; i < n - x; ++i)\n        _p[i + x] = p[i];\n    for(int i = 0; i < x; ++i)\n        _p[i] = p[n - i - 1];\n    _p.swap(p);\n//     print();\n}\n\nvoid init() {\n    for(int i = 0; i < n; ++i)\n        if(p[i] == 0) {\n            do_move(n - i - 1);\n            return;\n        }\n}\n\nvoid foo(int x) {\n    for(int i = 0; i < n; ++i) {\n        if(p[i] == x) {\n            do_move(n - i - 1);\n            do_move(1);\n            do_move(n);\n            return;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d%s%s\", &n, s, t);\n    do_perm();\n//     print();\n    init();\n//     print();\n    \n    for(int i = 1; i <= n - 1; ++i) {\n        foo(i);\n//         print();\n    }\n    printf(\"%d\\n\", (int) ans.size());\n    for(int a: ans) printf(\"%d \", a);\n    puts(\"\");\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "strings"], "dificulty": "2300", "interactive": false}