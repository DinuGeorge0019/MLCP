{
    "link": "https://codeforces.com//contest/1521/problem/C",
    "problemId": "977645",
    "problem_idx": "C",
    "shortId": "1521C",
    "contest_number": "1521",
    "problem_submissions": {
        "D": [
            115581818,
            115594850,
            115598612,
            115603691,
            115599448,
            115601993,
            115608478,
            115569159,
            115612872,
            115604589,
            115610795,
            115602271,
            115608146,
            115607408,
            115599985
        ],
        "C": [
            115571933,
            115576814,
            115571686,
            115575287,
            115554792,
            115578008,
            115583346,
            115581715,
            115563254,
            115563941,
            115569253,
            115571673,
            115577961,
            115579502,
            115578223,
            115583699
        ],
        "B": [
            115555782,
            115541222,
            115542122,
            115539078,
            115535984,
            115537884,
            115535617,
            115535973,
            115540952,
            115589944,
            115543027,
            115535929,
            115532822,
            115550853,
            115551249,
            115536556,
            115547431,
            115535420
        ],
        "A": [
            115533383,
            115523492,
            115530232,
            115525696,
            115523586,
            115527609,
            115525343,
            115525115,
            115586248,
            115523901,
            115524582,
            115523559,
            115530582,
            115527602,
            115524514,
            115526011,
            115524612
        ],
        "E": [
            115603853,
            115608158,
            115614666,
            116024421,
            115649428,
            115659057,
            115613282,
            115649743,
            115610712
        ]
    },
    "name": "C. Nastia and a Hidden Permutation",
    "statement": "Nastia has a hidden permutation p of length n consisting of integers\r\nfrom 1 to n. You, for some reason, want to figure out the permutation.\r\nTo do that, you can give her an integer t (1\r\nle t\r\nle 2), two indices i and j (1\r\nle i, j\r\nle n, i\r\nneq j), and an integer x (1\r\nle x\r\nle n - 1). Depending on t, she will answer: t = 1:\r\nmax{(\r\nmin{(x, p_i)},\r\nmin{(x + 1, p_j)})}; t = 2:\r\nmin{(\r\nmax{(x, p_i)},\r\nmax{(x + 1, p_j)})}. You can ask Nastia\r\nlfloor\r\nfrac {3\r\ncdot n} { 2}\r\nrfloor + 30 times. It is guaranteed that she will change her permutation\r\ndepending on your queries. Can you guess the permutation?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define _FORTIFY_SOURCE 0\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\n#pragma GCC optimize(\"fast-math\")\n#define int long long\n\nusing namespace std;\n\nmt19937 rnd(time(nullptr));\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int pos = -1;\n    for (int i = 0; i < n - 1; i += 2) {\n        cout << \"? 2 \" << i + 1 << \" \" << i + 2 << \" \" << 1 << endl;\n        int res;\n        cin >> res;\n        if (res == 1) {\n            pos = i;\n            break;\n        }\n        if (res == 2) {\n            cout << \"? 2 \" << i + 2 << \" \" << i + 1 << \" \" << 1 << endl;\n            int kek;\n            cin >> kek;\n            if (kek == 1) {\n                pos = i + 1;\n                break;\n            }\n        }\n    }\n    if (pos == -1)\n        pos = n - 1;\n    vector <int> ans(n);\n    ans[pos] = 1;\n    for (int i = 0; i < n; i++) {\n        if (i == pos)\n            continue;\n        cout << \"? 1 \" << pos + 1 << \" \" << i + 1 << \" \" << n - 1 << endl;\n        int res;\n        cin >> res;\n        ans[i] = res;\n    }\n    cout << \"! \";\n    for (int x : ans)\n        cout << x << \" \";\n    cout << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Nastia and a Hidden Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/90477",
    "editorial": "Let\u00e2\u0080\u0099s fix indices and . Then restore and .Let\u00e2\u0080\u0099s assume we know the\r\nmaximum element among and : .Now we can figure out where exactly the\r\nmaximum is by asking the following query: .There are cases: : it means ,\r\notherwise . : it means , because . If we know where the maximum is\r\nlocated we easily can find the remaining element: if , then . if , then\r\n. We can solve the problem if we know the . Let\u00e2\u0080\u0099s find it:Take a look on\r\nthe case when . Here we cannot be sure that . It\u00e2\u0080\u0099s possible only if .\r\nThus if we spend an extra query to be sure that . We will ask:So, if ,\r\nthen the value equlas to , otherwise the value equals to the real\r\nmaximum among and .As a result, we can restore any elements of the\r\npermutation. Let\u00e2\u0080\u0099s split our permutation into pairs and restore them\r\nindependently of each other.The total queries we perform is . We spend\r\noperations to restore each of the pair of elements. And than extra\r\nqueries to be sure that is correct. Let\u00e2\u0080\u0099s find the maximum of the\r\npermutation and then restore the element of the permutation by query:\r\n.To find the maximum element let\u00e2\u0080\u0099s split the permutation into pairs and\r\nperform the following operation to each of them: . if , then is the\r\nposition with a maximum element. if , then need to make sure that .\r\nLet\u00e2\u0080\u0099s make the same extra query as we do in the . Note that if you don\u00e2\u0080\u0099t\r\nfind the maximum element among the , then it\u00e2\u0080\u0099s in the remaining element\r\nwhen is odd.The total queries we perform is n + . We ask queries to find\r\nthe maximum of the permutation and quiries to restore the remaining\r\nelements.\r\n"
}