{
    "link": "https://codeforces.com//contest/350/problem/B",
    "problemId": "3563",
    "problem_idx": "B",
    "shortId": "350B",
    "contest_number": "350",
    "problem_submissions": {
        "E": [
            4631521,
            4627481,
            4627736,
            4628109,
            4628919,
            4627306,
            4629552,
            4630396,
            4630738,
            4630557,
            4631036,
            4630307,
            4628626,
            4630765,
            4631090,
            4631222,
            4631307
        ],
        "D": [
            4631384,
            4632639,
            4630471
        ],
        "C": [
            4623828,
            4624599,
            4624536,
            4622933,
            4624699,
            4624176,
            4626336,
            4621951,
            4625656,
            4625740,
            4626157,
            4624456,
            4625990,
            4625202,
            4624685,
            4626744,
            4623856,
            4627186
        ],
        "B": [
            4622942,
            4623430,
            4623053,
            4625927,
            4623752,
            4628716,
            4624114,
            4623578,
            4624072,
            4624239,
            4624594,
            4626727,
            4624251,
            4624259,
            4627379,
            4623391,
            4627529,
            4625315
        ],
        "A": [
            4621532,
            4621502,
            4623629,
            4621549,
            4621709,
            4622086,
            4622630,
            4621567,
            4621446,
            4621939,
            4622148,
            4623843,
            4622109,
            4621409,
            4622118,
            4621840
        ]
    },
    "name": "B. Resort",
    "statement": "Valera\u2019s finally decided to go on holiday! He packed up and headed for a\r\nski resort.Valera\u2019s fancied a ski trip but he soon realized that he\r\ncould get lost in this new place. Somebody gave him a useful hint: the\r\nresort has objects (we will consider the objects indexed in some way by\r\nintegers from to ), each object is either a hotel or a mountain.Valera\r\nhas also found out that the ski resort had multiple ski tracks.\r\nSpecifically, for each object , the resort has at most one object , such\r\nthat there is a ski track built from object to object . We also know\r\nthat no hotel has got a ski track leading from the hotel to some\r\nobject.Valera is afraid of getting lost on the resort. So he wants you\r\nto come up with a path he would walk along. The path must consist of\r\nobjects () and meet the following conditions: Objects with numbers are\r\nmountains and the object with number is the hotel. For any integer ,\r\nthere is ski track leading from object . This track goes to object . The\r\npath contains as many objects as possible ( is maximal). Help Valera.\r\nFind such path that meets all the criteria of our hero!\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int NMax=100000;\nint N,A[NMax],T[NMax],C[NMax];\nint main()\n{\n    scanf(\"%d\",&N);\n    for (int i=0;i<N;i++)\n        scanf(\"%d\",T+i);\n    for (int i=0;i<N;i++){\n        scanf(\"%d\",A+i);\n        A[i]--;\n    }\n    for (int i=0;i<N;i++)\n        C[i]=0;\n    for (int i=0;i<N;i++)\n        if (A[i]!=-1)\n            C[A[i]]++;\n    int ret=0,reti=-1;\n    for (int i=0;i<N;i++)\n        if (T[i]==1){\n            int c=1;\n            int j=i;\n            while (A[j]!=-1 && C[A[j]]==1){\n                j=A[j];\n                c++;\n            }\n            if (c>ret){\n                ret=c;\n                reti=i;\n            }\n        }\n    printf(\"%d\\n\",ret);\n    vector<int> output;\n    for (int i=0;i<ret;i++){\n        output.push_back(reti);\n        reti=A[reti];\n    }\n    for (int i=0;i<ret;i++){\n        if (i)\n            printf(\" \");\n        printf(\"%d\",output[ret-1-i]+1);\n    }\n    puts(\"\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Resort.json",
    "editorial_link": "https://codeforces.com//blog/entry/9042",
    "editorial": "Input data represents a graph, by using a array of parents of every\r\nvertex. Because every vertex has at most one parent, we can use\r\nfollowing solution: we will go up to parent of vertex () until not found\r\nvertex with the outcome degree . It is better to calculate outcome\r\ndegrees in advance. After all, we will update the answer. This algorithm\r\nworks in . Author solution: 4632399\r\n"
}