{
    "link": "https://codeforces.com//contest/1130/problem/B",
    "problemId": "303007",
    "problem_idx": "B",
    "shortId": "1130B",
    "contest_number": "1130",
    "problem_submissions": {
        "E": [
            50451743,
            50450700,
            50452094,
            50453474,
            50446313,
            50455916,
            50454920,
            50454012,
            50454008,
            50454839,
            50457467,
            50456727,
            50456260,
            50455672,
            50455605,
            50457927,
            50458312,
            50458126,
            50457415,
            50456722
        ],
        "D1": [
            50446455,
            50445965,
            50445582,
            50447980,
            50455630,
            50447204,
            50446775,
            50447785,
            50448347,
            50449449,
            50449217,
            50450469,
            50443264,
            50449132,
            50450976,
            50449020,
            50447745,
            50451064,
            50451498,
            50451552
        ],
        "D2": [
            50446421,
            50445878,
            50447104,
            50447912,
            50455476,
            50447640,
            50449363,
            50448330,
            50449131,
            50450168,
            50449067,
            50450309,
            50443073,
            50449382,
            50450922,
            50449226,
            50450982,
            50451004,
            50451840,
            50451473
        ],
        "C": [
            50442552,
            50443206,
            50442662,
            50441379,
            50437688,
            50442381,
            50441711,
            50439129,
            50445792,
            50444106,
            50444264,
            50443989,
            50450118,
            50445704,
            50445333,
            50444492,
            50440739,
            50444078,
            50446518,
            50445495
        ],
        "B": [
            50438439,
            50440829,
            50438694,
            50437732,
            50440500,
            50437727,
            50437348,
            50443831,
            50442386,
            50441239,
            50438973,
            50438854,
            50445257,
            50439931,
            50440493,
            50439101,
            50443847,
            50438507,
            50438623,
            50441001
        ],
        "A": [
            50434167,
            50434903,
            50434750,
            50433920,
            50434056,
            50434451,
            50434231,
            50435637,
            50434352,
            50433911,
            50435681,
            50434866,
            50434981,
            50436177,
            50436562,
            50434700,
            50434131,
            50435258,
            50434348,
            50436340
        ]
    },
    "name": "B. Two Cakes",
    "statement": "Sasha and Dima want to buy two n-tier cakes. Each cake should consist of\r\nn different tiers: from the size of 1 to the size of n. Tiers should go\r\nin order from the smallest to the biggest (from top to bottom).They live\r\non the same street, there are 2\r\ncdot n houses in a row from left to right. Each house has a pastry shop\r\nwhere you can buy a cake tier. Unfortunately, in each pastry shop you\r\ncan buy only one tier of only one specific size: in the i-th house you\r\ncan buy a tier of the size a_i (1\r\nle a_i\r\nle n).Since the guys carry already purchased tiers, and it is impossible\r\nto insert a new tier in the middle of the cake, they agreed to buy tiers\r\nfrom the smallest to the biggest. That is, each of them buys tiers in\r\norder: 1, then 2, then 3 and so on up to n.Initially, Sasha and Dima are\r\nlocated near the first (leftmost) house. Output the minimum distance\r\nthat they will have to walk in total to buy both cakes. The distance\r\nbetween any two neighboring houses is exactly 1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, x;\nlong  long wyn;\nvector <int> v[100010];\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=2*n; ++i)\n\t{\n\t\tscanf(\"%d\", &x);\n\t\tv[x].push_back(i);\n\t}\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tsort(v[i].begin(), v[i].end());\n\t}\n\tx=1;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\twyn+=abs(x-v[i][0]);\n\t\tx=v[i][0];\n\t}\n\tx=1;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\twyn+=abs(x-v[i][1]);\n\t\tx=v[i][1];\n\t}\n\tcout<<wyn;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Two Cakes.json",
    "editorial_link": "https://codeforces.com/blog/entry/65520",
    "editorial": "Let be the set of cells accessible from .Similarly, let be the set of\r\ncells accessible from .We can find and using a search algorithm such as\r\na DFS or a BFS.If , then a tunnel is not needed, so the answer is\r\n.Otherwise, we need to create a tunnel with an endpoint in and the other\r\nin . Now, we can simply iterate through all possible pairs of cells\r\nwhere and to find one that minimizes the cost (i.e., ).The time\r\ncomplexity is .\r\n",
    "hint": []
}