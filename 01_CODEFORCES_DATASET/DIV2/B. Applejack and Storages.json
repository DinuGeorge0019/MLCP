{
    "link": "https://codeforces.com//contest/1393/problem/B",
    "problemId": "693071",
    "problem_idx": "B",
    "shortId": "1393B",
    "contest_number": "1393",
    "problem_submissions": {
        "D": [
            89235864,
            89237678,
            89239942,
            89241904,
            89240571,
            89239873,
            89230308,
            89237378,
            89247700,
            89240803,
            89243160,
            89243648,
            89242883,
            89238243,
            89242864,
            89249422,
            89245780,
            89244250
        ],
        "B": [
            89221116,
            89217441,
            89220933,
            89222989,
            89220509,
            89223779,
            89220401,
            89219535,
            89219377,
            89227149,
            89220055,
            89224518,
            89222569,
            89225245,
            89223599,
            89220060,
            89222338,
            89225655
        ],
        "C": [
            89218957,
            89225521,
            89228764,
            89230329,
            89224448,
            89234176,
            89238147,
            89233693,
            89228718,
            89234223,
            89234984,
            89234287,
            89231225,
            89232086,
            89232825,
            89232005,
            89235490,
            89236144
        ],
        "A": [
            89218814,
            89212583,
            89214268,
            89213479,
            89214230,
            89213219,
            89213191,
            89220955,
            89212600,
            89213989,
            89213307,
            89215648,
            89216757,
            89215210,
            89215943,
            89213088,
            89214183
        ],
        "E1": [
            89281813
        ]
    },
    "name": "B. Applejack and Storages",
    "statement": "This year in Equestria was a year of plenty, so Applejack has decided to\r\nbuild some new apple storages. According to the advice of the farm\r\ndesigners, she chose to build two storages with non-zero area: one in\r\nthe shape of a square and another one in the shape of a rectangle (which\r\npossibly can be a square as well).Applejack will build the storages\r\nusing planks, she is going to spend exactly one plank on each side of\r\nthe storage. She can get planks from her friend’s company. Initially,\r\nthe company storehouse has n planks, Applejack knows their lengths. The\r\ncompany keeps working so it receives orders and orders the planks\r\nitself. Applejack’s friend can provide her with information about each\r\noperation. For convenience, he will give her information according to\r\nthe following format: + x: the storehouse received a plank with length\r\nx - x: one plank with length x was removed from the storehouse (it is\r\nguaranteed that the storehouse had some planks with length x). Applejack\r\nis still unsure about when she is going to order the planks so she wants\r\nto know if she can order the planks to build rectangular and square\r\nstorages out of them after every event at the storehouse. Applejack is\r\nbusy collecting apples and she has completely no time to do the\r\ncalculations so she asked you for help!We remind you that all four sides\r\nof a square are equal, and a rectangle has two pairs of equal sides.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\npriority_queue <int> pq, buang;\nint n, q, a, a1, a2, a3, ct[100010];\nchar c;\n\ninline void buy(int x) {\n\tif (ct[x] > 0) buang.push(ct[x]);\n\tct[x]++;\n\tpq.push(ct[x]);\n}\n\ninline void sell(int x) {\n\tbuang.push(ct[x]);\n\tct[x]--;\n\tif (ct[x] > 0) pq.push(ct[x]);\n}\n\ninline void reset() {\n\twhile (!buang.empty() && pq.top() == buang.top()) {\n\t\tpq.pop();\n\t\tbuang.pop();\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a;\n\t\tbuy(a);\n\t}\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> c >> a;\n\t\tif (c == '+') buy(a);\n\t\telse sell(a);\n\t\treset();\n\t\tif (!pq.empty()) {\n\t\t\ta1 = pq.top();\n\t\t\tpq.pop();\n\t\t}\n\t\treset();\n\t\tif (!pq.empty()) {\n\t\t\ta2 = pq.top();\n\t\t\tpq.pop();\n\t\t}\n\t\treset();\n\t\tif (!pq.empty()) {\n\t\t\ta3 = pq.top();\n\t\t\tpq.pop();\n\t\t}\n\t\tif (a1 >= 4 && ((a1-4)/2 + a2/2 + a3/2) >= 2) {\n\t\t\tcout << \"YES\\n\";\n\t\t} else {\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t\tif (a1 > 0) pq.push(a1);\n\t\tif (a2 > 0) pq.push(a2);\n\t\tif (a3 > 0) pq.push(a3);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Applejack and Storages.json",
    "editorial_link": "https://codeforces.com//blog/entry/81161",
    "editorial": "Letâs maintain the array , in it we are going to store the number of\r\nplanks for each length. Letâs note that to be able to build a square and\r\na rectangle we need to have four planks of the same length and also two\r\npairs of planks of the same length. To check it we can maintain two\r\nvalues: and . Then, you will be able to build a square and a rectangular\r\nstorage if and . The first constraint satisfies the requirement about a\r\nsquare (you should have planks of some length), and the second\r\nconstraint satisfies the requirement about a rectangle (two pairs of the\r\nsame length should be used and also two pairs are already used in the\r\nsquare).\r\n",
    "hint": []
}