{
    "link": "https://codeforces.com//contest/1174/problem/B",
    "problemId": "353391",
    "problem_idx": "B",
    "shortId": "1174B",
    "contest_number": "1174",
    "problem_submissions": {
        "E": [
            55039336,
            55044361,
            55047429,
            55040838,
            55047094,
            55042040,
            55042878,
            55038492,
            55074361,
            55045215,
            55070465,
            55052562,
            55043353,
            55077730,
            55041823,
            55062278,
            55053681
        ],
        "D": [
            55035444,
            55029768,
            55027239,
            55028917,
            55030017,
            55031266,
            55030524,
            55028205,
            55035219,
            55028511,
            55029682,
            55031022,
            55031315,
            55027972,
            55032439,
            55032979,
            55028299,
            55033103,
            55028679,
            55031061
        ],
        "F": [
            55031300,
            55038342,
            55040097,
            55045770,
            55039431,
            55046891,
            55053088,
            55047685,
            55049921,
            55049066,
            55039349,
            55055925,
            55055858,
            55055759,
            55055564,
            55043749,
            55038284,
            55041004,
            55058775,
            55042228,
            55041603,
            55041698,
            55114618,
            55041755,
            55042241
        ],
        "C": [
            55029741,
            55022001,
            55024172,
            55023941,
            55024511,
            55027105,
            55028150,
            55023124,
            55027027,
            55025166,
            55024084,
            55029153,
            55025965,
            55022505,
            55024454,
            55026547,
            55024657,
            55028838,
            55026161,
            55026567
        ],
        "A": [
            55027419,
            55020850,
            55019913,
            55020331,
            55020481,
            55020928,
            55020714,
            55019727,
            55021559,
            55020242,
            55019597,
            55021256,
            55019953,
            55019896,
            55019608,
            55020117,
            55020693,
            55023232,
            55019790,
            55019854
        ],
        "B": [
            55024841,
            55019799,
            55022270,
            55021874,
            55022067,
            55023546,
            55022681,
            55021183,
            55024705,
            55023720,
            55021538,
            55025471,
            55021813,
            55021948,
            55022335,
            55022891,
            55031469,
            55023328,
            55023867,
            55022256
        ]
    },
    "name": "B. Ehab Is an Odd Person",
    "statement": "You’re given an array a of length n. You can perform the following\r\noperation on it as many times as you want: Pick two integers i and j (1\r\nle i,j\r\nle n) such that , then swap a_i and a_j. What is lexicographically the\r\nsmallest array you can obtain?An array x is lexicographically smaller\r\nthan an array y if there exists an index i such that x_i<y_i, and\r\nx_j=y_j for all 1\r\nle j < i. Less formally, at the first index i in which they differ,\r\nx_i<y_i\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> mypair;\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nint n, a[100005];\n\nint main()\n{\n\tn = read(); int even = 0, odd = 0;\n\tfor (int i = 1; i <= n; i ++) a[i] = read(), a[i] & 1 ? odd ++ : even ++;\n\tif (!even || !odd) \n\t{\n\t\tfor (int i = 1; i<= n; i ++) printf(\"%d%c\", a[i], i == n ? 10 : 32);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tsort(a + 1, a + 1 + n);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tprintf(\"%d%c\", a[i], i == n ? 10 : 32);\n\t}\n\t\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Ehab Is an Odd Person.json",
    "editorial_link": "https://codeforces.com//blog/entry/67388",
    "editorial": "Notice that you can only swap 2 elements if they have different\r\nparities. If all elements in the array have the same parity, you canât\r\ndo any swaps, and the answer will just be like the input. Otherwise,\r\nletâs prove you can actually swap any pair of elements. Assume you want\r\nto swap 2 elements, and , and they have the same parity. There must be a\r\nthird element that has a different parity. Without loss of generality,\r\nassume the array is . Youâll do the following swaps: In other words,\r\nyouâll use as an intermediate element to swap and , and itâll return to\r\nits original position afterwards! Since you can swap any pair of\r\nelements, you can always sort the array, which is the lexicographically\r\nsmallest permutation. Code link: https://pastebin.com/xhqGXLiu Time\r\ncomplexity: .\r\n",
    "hint": []
}