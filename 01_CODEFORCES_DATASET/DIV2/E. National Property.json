{
    "link": "https://codeforces.com//contest/876/problem/E",
    "problemId": "128568",
    "problem_idx": "E",
    "shortId": "876E",
    "contest_number": "876",
    "problem_submissions": {
        "B": [
            31407957,
            31390264,
            31393381,
            31391206,
            31391466,
            31392339,
            31391060,
            31390938,
            31390567,
            31392566,
            31390250,
            31392918,
            31393416,
            31394028,
            31401993,
            31389526,
            31389712,
            31390216,
            31389562
        ],
        "A": [
            31405767,
            31391325,
            31391881,
            31389424,
            31389560,
            31388926,
            31389247,
            31393134,
            31389868,
            31389561,
            31394568,
            31390723,
            31391034,
            31389865,
            31400983,
            31389038,
            31388897,
            31389161,
            31389027
        ],
        "C": [
            31404075,
            31392627,
            31389974,
            31393244,
            31393165,
            31389911,
            31392538,
            31389074,
            31392390,
            31391100,
            31389284,
            31395230,
            31394623,
            31401857,
            31389486,
            31390891,
            31391818,
            31392408,
            31390396
        ],
        "E": [
            31403443,
            31404809,
            31410622,
            31404653,
            31403064,
            31401931,
            31411025,
            31411620,
            31408688,
            31405891,
            31410487,
            31405970,
            31410186,
            31407418,
            31435175,
            31531044,
            31402962,
            31506799
        ],
        "D": [
            31396243,
            31396563,
            31404310,
            31398673,
            31397247,
            31395845,
            31404545,
            31404510,
            31397166,
            31396858,
            31397566,
            31401459,
            31403057,
            31403652,
            31393742,
            31395931,
            31396814,
            31396196,
            31396310
        ],
        "F": [
            31393486,
            31413796,
            31413775,
            31407346,
            31399521,
            31409736,
            31411099,
            31410876,
            31400786,
            31401699,
            31407687,
            31412301,
            31409391,
            31411373,
            31408468,
            31411926,
            31398584,
            31404957,
            31405002,
            31406473
        ]
    },
    "name": "E. National Property",
    "statement": "You all know that the Library of Bookland is the largest library in the\r\nworld. There are dozens of thousands of books in the library.The\r\nalphabet of Bookland is so large that its letters are denoted by\r\npositive integers. Each letter can be small or large, the large version\r\nof a letter is denoted by . BSCII encoding, which is used everywhere in\r\nBookland, is made in that way so that large letters are presented in the\r\norder of the numbers they are denoted by, and small letters are\r\npresented in the order of the numbers they are denoted by, but all large\r\nletters are all small letters. For example, the following conditions\r\nhold: , , .A word is not greater than if one of the two following\r\nconditions holds: and , i.e. the first word is the prefix of the second\r\nword; there is a position , such that and , i.e. at the first position\r\nwhere the words differ the first word has a smaller letter than the\r\nsecond word has. For example, the word \" \" is before the word \" \" in\r\nlexicographical order. It is said that sequence of words is in\r\nlexicographical order if each word is not lexicographically greater than\r\nthe next word in the sequence.Denis has a sequence of words consisting\r\nof small letters only. He wants to change some letters to large (let\u2019s\r\ncall this process a ) in such a way that the sequence of words is in\r\nlexicographical order. However, he soon realized that for some reason he\r\ncan\u2019t change a single letter in a single word. He only can choose a\r\nletter and change all of its occurrences in words to large letters. He\r\ncan perform this operation any number of times with arbitrary letters of\r\nBookland\u2019s alphabet.Help Denis to choose which letters he needs to\r\ncapitalize (make large) in order to make the sequence of words\r\nlexicographically ordered, or determine that it is impossible.Note that\r\nsome words can be .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\nmap<int, vector<int>> need;\nset<int> up;\n\nvoid dfs(int a, int b) {\n    if (a < b) {\n        if (up.count(a) == 0 && up.count(b) == 1) {\n            up.insert(a);\n            for (int i : need[a])\n                dfs(i, a);\n        }\n    } else {\n        if (up.count(a) && up.count(b) == 1) {\n            printf(\"No\");\n            exit(0);\n        }\n        up.insert(a);\n        for (int i : need[a])\n            dfs(i, a);\n    }\n}\n\nint main() {\n#ifdef __APPLE__\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    vector<vector<int>> a(n);\n    for (int i = 0; i < n; ++i) {\n        int len;\n        scanf(\"%d\", &len);\n        a[i].resize(len);\n        for (int j = 0; j < len; ++j)\n            scanf(\"%d\", &a[i][j]);\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < a[i].size(); ++j) {\n            if (j == a[i + 1].size())\n                return printf(\"No\"), 0;\n            if (a[i][j] != a[i + 1][j]) {\n                need[a[i + 1][j]].push_back(a[i][j]);\n                break;\n            }\n        }\n    }\n    for (auto it : need) {\n        for (auto it2 : it.second)\n            dfs(it2, it.first);\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < a[i].size(); ++j) {\n            if (j == a[i + 1].size())\n                return printf(\"No\"), 0;\n            if (a[i][j] == a[i + 1][j])\n                continue;\n            if (a[i][j] > a[i + 1][j]) {\n                if (!(up.count(a[i][j]) == 1 && up.count(a[i + 1][j]) == 0))\n                    return printf(\"No\"), 0;\n            } else {\n                if ((up.count(a[i][j]) == 0 && up.count(a[i + 1][j]) == 1))\n                    return printf(\"No\"), 0;\n            }\n            break;\n        }\n    }\n    printf(\"Yes\\n%d\\n\", (int)up.size());\n    for (int i : up)\n        printf(\"%d \", i);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "graphs",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. National Property.json",
    "editorial_link": "https://codeforces.com//blog/entry/55233",
    "editorial": "Let the strings si and si?+?1 are not prefixes of each other. Then it is necessary that si,?k?<?si?+?1,?k, where k is the first position, where si and si?+?1 differ.\n\nConsider strings si and si?+?1. Let k be the first position in which they differ. Then there are two cases:\n\nIf si,?k?>?si?+?1,?k, you capitalize si,?k and not capitalize si,?k?+?1.\n\nIf si,?k?<?si?+?1,?k, both these letters should be capitalized or not capitalizes simultaneously.\n\nLet's make a graph in which letters will be vertexes. If si,?k?>?si?+?1,?k, then mark si,?k as capitalized, otherwise make a directed edge between si?+?1,?k and si,?k. It means that if we capitalize si?+?1,?k, you also should capitalize si,?k.\n\nNote that our graph is acyclic because the edges are directed from big letters to small letters. Using dfs we capitalize all the letters, that are reachable from the capitalized letters and check the answer. If the answer is wrong, there is no answer."
}