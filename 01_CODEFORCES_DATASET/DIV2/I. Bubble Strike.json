{"link": "https://codeforces.com//contest/1600/problem/I", "problemId": "1136958", "problem_idx": "I", "shortId": "1600I", "contest_number": "1600", "problem_submissions": {"D": [131326791, 131319774, 131349265, 131313616, 131318416, 131323729], "F": [131320345, 131329426, 131350388], "E": [131316574, 131313861, 131305576, 131310151, 131314773], "I": [131312786, 131309903, 131307758, 131305198, 131310781], "A": [131307398], "J": [131302886, 131305362, 131303377, 131303391, 131305512], "B": [], "C": [], "G": [], "H": []}, "name": "I. Bubble Strike", "statement": "Little Johnny Bubbles enjoys spending hours in front of his computer\r\nplaying video games. His favorite game is Bubble Strike, fast-paced\r\nbubble shooting online game for two players.Each game is set in one of\r\nthe N maps, each having different terrain configuration. First phase of\r\neach game decides on which map the game will be played. The game system\r\nrandomly selects three maps and shows them to the players. Each player\r\nmust pick one of those three maps to be discarded. The game system then\r\nrandomly selects one of the maps that were not picked by any of the\r\nplayers and starts the game.Johnny is deeply enthusiastic about the game\r\nand wants to spend some time studying maps, thus increasing chances to\r\nwin games played on those maps. However, he also needs to do his\r\nhomework, so he does not have time to study all the maps. That is why he\r\nasked himself the following question: \"What is the minimum number of\r\nmaps I have to study, so that the probability to play one of those maps\r\nis at least P\"?Can you help Johnny find the answer for this question?\r\nYou can assume Johnny\u2019s opponents do not know him, and they will\r\nrandomly pick maps.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\npair<long long, long long> getProb(int p, int n) {\n  pair<long long, long long> pp[4][4];\n  memset(pp, 0, sizeof pp);\n  REP(i, 4) REP(j, 4) pp[i][j] = {0, 1};\n  pp[0][0] = {1, 1};\n\n  FOR(round, 1, 3) {\n    long long total = n - round + 1;\n\n    FOR(i, 0, 3) {     \n      pp[round][i].first = pp[round - 1][i].first * (total - (p - i));\n      pp[round][i].second = pp[round - 1][i].second * total;\n\n      if (1 <= i && i <= p) {\n        long long aa = pp[round - 1][i - 1].first * (p - (i - 1));\n        long long bb = pp[round - 1][i - 1].second * total;\n\n        assert(pp[round][i].second == bb);\n        pp[round][i].first += aa;\n      }\n\n    }\n  }\n  pair<long long, long long> ans;\n  FOR(x, 0, 3) {\n    int good = x;\n    if (good == 3) good = 2;\n    long long aa = pp[3][x].first * good;\n    long long bb = pp[3][x].second * 2;\n\n    if (x == 0) ans = {aa, bb};\n    else {\n      ans.first += aa;\n    }\n  }\n  debug(p, ans);\n  return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    long double p;\n    cin >> n >> p;\n    long long p2 = 10000;\n    long long p1 = (int)round(p * 10000);\n  \n    int ans = -1;\n    int left = 0; \n    int right = n;\n    while (left <= right) {\n      int mid = (left + right) / 2;\n\n      auto curr = getProb(mid, n);\n      debug(curr);\n      if (curr.first * p2 >= p1 * curr.second) {\n        right = mid - 1;\n        ans = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "math", "probabilities"], "dificulty": "2000", "interactive": false}