{
    "link": "https://codeforces.com//contest/1869/problem/F",
    "problemId": "2184997",
    "problem_idx": "F",
    "shortId": "1869F",
    "contest_number": "1869",
    "problem_submissions": {
        "E": [
            222790733,
            222755919,
            223014703,
            222844888,
            222822436,
            222820168
        ],
        "D2": [
            222751076,
            222765748,
            222762229,
            222767685,
            222770713,
            222771349,
            222774390,
            222781618,
            222778821,
            222788639,
            222773236,
            222775336,
            222775900,
            222778257,
            222775220,
            222773627,
            222771492
        ],
        "D1": [
            222743411,
            222768273,
            222754309,
            222754872,
            222757370,
            222757211,
            222762465,
            222761473,
            222755833,
            222757091,
            222752420,
            222764925,
            222765023,
            222761868,
            222761450,
            222761828,
            222765878,
            222760854
        ],
        "C": [
            222734213,
            222799024,
            222739072,
            222743933,
            222748797,
            222742198,
            222748357,
            222740791,
            222743470,
            222743624,
            222737636,
            222744668,
            222749662,
            222742346,
            222741675,
            222752222,
            222753724,
            222751049
        ],
        "B": [
            222728831,
            222759638,
            222728679,
            222733793,
            222732869,
            222730403,
            222734827,
            222731660,
            222733775,
            222732224,
            222728510,
            222735540,
            222734578,
            222733639,
            222729850,
            222736886,
            222733662,
            222738397
        ],
        "A": [
            222725390,
            222757999,
            222725599,
            222726282,
            222727750,
            222725856,
            222726824,
            222727514,
            222730110,
            222726868,
            222725449,
            222728462,
            222727639,
            222725642,
            222725871,
            222727421,
            222725878,
            222731354
        ],
        "F": [
            223418170
        ]
    },
    "name": "F. Flower-like Pseudotree",
    "statement": "A is a connected graph which has cycle and self-loops. Note that a\r\npseudotree . It can be shown that a pseudotree with n vertices always\r\ncontains n edges.After deleting all edges on the cycle in the\r\npseudotree, a forest^{\r\ndagger} will be formed. It can be shown that each tree in the forest\r\nwill contain exactly one vertex which is on cycle before removing the\r\nedges. If all trees in the forest have the same depth^{\r\nddagger} when picking the vertex on cycle as root, we call the original\r\npseudotree .Our friend sszcdjr, had a flower-like pseudotree with n\r\nvertices and n edges. However, he forgot all the edges in the\r\npseudotree. Fortunately, he still remembers the degrees of vertices.\r\nSpecifically, the degree of the i-th vertex is d_i.You have to help\r\nsszcdjr construct a possible flower-like pseudotree with n vertices,\r\nwhere the degree of the i-th vertex is d_i, or tell him that it is\r\nimpossible.^{\r\ndagger} A forest is a graph in which all connectivity components are\r\ntrees. A connected graph without cycles and self-loops is called a\r\ntree.^{\r\nddagger} The depth of a tree with a root is the maximum distance from\r\nthe root to the vertex of this tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define oo 1000000010\n\nconst int N = 1000010;\n\nint n, d[N];\n\nvector< pair< int , int > > arr;\n\nint sum[N] , prnt[N] , comp[N] , mx[N] , depth[N];\n\nbool notake[N];\n\nint qu[N] , ql , qr;\n\nvoid solve(){\n\tscanf(\"%d\",&n);\n\tarr.clear();\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d\",&d[i]);\n\t\tarr.push_back(make_pair(d[i] , i));\n\t\tnotake[i] = false;\n\t\tprnt[i] = -1;\n\t}\n\tsort(arr.begin(),arr.end());\n\tfor(int i = 0 ;i < (int)arr.size();i++){\n\t\tsum[i + 1] = sum[i] + arr[i].first;\n\t\tif(sum[i + 1] > 2 * n){\n\t\t\tputs(\"NO\");\n\t\t\treturn; \n\t\t}\n\t}\n\tif(arr.back().first == 1 || sum[n] != 2 * n){\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tif(arr.back().first == 2){\n\t\tif(arr[0].first == 1){\n\t\t\tputs(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tputs(\"YES\");\n\t\tprintf(\"1 %d\\n\",n);\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tprintf(\"%d %d\\n\",i , i + 1);\n\t\t}\n\t\treturn;\n\t}\n\tint ones = upper_bound(arr.begin(),arr.end(),make_pair(1 , oo)) - arr.begin();\n\n\tif(sum[n] - sum[ones] - 2 * (n - ones) != ones){\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\n\tfor(int cur , last , tmp , give , i = n - 2;i >= 0 && arr[i].first > 2;i--){\n\t\tcur = sum[n] - sum[i] - 2 * (n - i);\n\t\tlast = i - 1;\n\t\tgive = 0;\n\t\twhile(last >= ones){\n\t\t\tif(arr[last].first == 2){\n\t\t\t\tgive += ((last - ones + cur) / cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgive++;\n\t\t\ttmp = last - cur;\n\t\t\tif(tmp < ones)\n\t\t\t\tbreak;\n\t\t\tcur = sum[last + 1] - sum[tmp + 1] - (last - tmp);\n\t\t\tlast = tmp;\n\t\t}\n\t\ttmp = i - ones;\n\t\tif(tmp >= give * (n - i)){\n\t\t\tputs(\"YES\");\n\t\t\tprintf(\"%d %d\\n\",arr[i].second , arr[n - 1].second);\n\t\t\tfor(int j = i ;j < n - 1;j++){\n\t\t\t\tprintf(\"%d %d\\n\",arr[j].second , arr[j + 1].second);\n\t\t\t}\n\t\t\tql = qr = 0;\n\t\t\tfor(int j = n - 1;j >= i;j--){\n\t\t\t\td[arr[j].second] -= 2;\n\t\t\t\tcomp[arr[j].second] = arr[j].second;\n\t\t\t\tmx[arr[j].second] = arr[j].second;\n\t\t\t\tdepth[arr[j].second] = 0;\n\t\t\t\tqu[qr++] = arr[j].second;\n\t\t\t}\n\t\t\tint last = i - 1;\n\t\t\twhile(last >= ones){\n\t\t\t\twhile(ql < qr && d[qu[ql]] == 0) ql++;\n\t\t\t\tprnt[arr[last].second] = qu[ql];\n\t\t\t\tdepth[arr[last].second] = depth[qu[ql]] + 1;\n\t\t\t\tcomp[arr[last].second] = comp[qu[ql]];\n\t\t\t\tmx[comp[arr[last].second]] = arr[last].second;\n\t\t\t\td[qu[ql]]--;\n\t\t\t\td[arr[last].second]--;\n\t\t\t\tqu[qr++] = arr[last].second;\n\t\t\t\tlast--;\n\t\t\t}\n\n\t\t\tfor(int tmp , j = ones ; j < n;j++){\n\t\t\t\ttmp = arr[j].second;\n\t\t\t\tif(mx[comp[tmp]] != tmp) continue;\n\t\t\t\twhile(tmp != -1){\n\t\t\t\t\tnotake[tmp] = true;\n\t\t\t\t\ttmp = prnt[tmp];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlast = ones;\n\t\t\tfor(int j = i;depth[mx[arr[j].second]] < depth[mx[arr[n - 1].second]];j++){\n\t\t\t\twhile(notake[arr[last].second]) last++;\n\t\t\t\td[prnt[arr[last].second]]++;\n\t\t\t\tprnt[arr[last].second] = mx[arr[j].second];\n\t\t\t\td[mx[arr[j].second]]--;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tlast = ones - 1;\n\t\t\tfor(int j = ones ;j < n;j++){\n\t\t\t\twhile(d[arr[j].second] > 0){\n\t\t\t\t\td[arr[j].second]--;\n\t\t\t\t\tprnt[arr[last].second] = arr[j].second;\n\t\t\t\t\tlast--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j = i - 1;j >= 0;j--){\n\t\t\t\tprintf(\"%d %d\\n\",arr[j].second , prnt[arr[j].second]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t}\n\tputs(\"NO\");\n\n}\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\t\n\treturn 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Flower-like Pseudotree.json",
    "editorial_link": "https://codeforces.com//blog/entry/116642",
    "editorial": "If ?ni=1di?2n\n, it's obviously impossible to construct a flower-like psuedotree. So let's just consider the situation when ?ni=1di=2n\n.\n\nSort di\n from largest to smallest. If d1=d2=?=dn=2\n, we can simply construct a cycle. Otherwise d1>2\n, in which case there must be at least two di>2\n and the vertices on the cycle must satisfy di>2\n.\n\nIgnore all vertices with di=1\n as we can just hang them under all the other vertices. The following pictures don't show vertices with di=1\n and the edges with weight 2\n are two multi-edges.\n\nLet cnt\n be the number of vertices with di>1\n.\n\nIf cnt\n is even, we can make a cycle using d1\n and d2\n, with two chains of equal length hanging from d1\n and d2\n.\n\nThe multi-edges have a number 2\n on them.\nIf cnt\n is odd and d1>3\n, it's easy to see that we can hang two vertices below d1\n to transform it to the situation where cnt\n is even. However, we need at least 5\n vertices to make the psuedotree flower-like, which means that cnt?5\n must be satisfied. (In the picture, at least vertices 1?5\n are needed.)\n\n\nIf cnt\n is odd, d1>3\n and cnt=3\n, it's impossible for us to simply build a cycle length 2\n. Thus, we can try to put d1,d2,d3\n in one cycle and the condition is d3>2\n.\n\nIf cnt\n is odd and d1=3\n, it's impossible for us to do the operation above, because we can't hang two vertices under d1\n. It's easy to see that we can't balance the two trees if d3=2\n. For d3=3\n, we can hang d3,d4\n under d1,d2\n, d5,d6\n under d3\n and d7\n under d4\n to make the psuedotree flower-like. However, we need at least 7\n vertices to make it balanced, which means cnt?7\n must be satisfied.\n\n\nIf cnt\n is odd, d1=3\n and cnt=5\n, there are three cases:\n\nd1=d2=d3=3,d4=d5=2\n: It can be proven that there isn't such a psuedotree.\nd1=d2=d3=d4=3,d5=2\n: It can be proven that there isn't such a psuedotree.\nd1=d2=d3=d4=d5=3\n: We can simply build a cycle of length 5\n.\nIf cnt\n is odd, d1=3\n and cnt=3\n, there's only one case:\n\nd1=d2=d3=3\n: We can simply build a cycle of length 3\n.\nThe total complexity depends on the sorting part, which is O(nlogn)\n if you use std::sort or std::stable_sort, and O(n)\n if you use bucket sorting.",
    "hint": []
}