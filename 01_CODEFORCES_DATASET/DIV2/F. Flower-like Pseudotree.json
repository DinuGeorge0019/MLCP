{"link": "https://codeforces.com//contest/1869/problem/F", "problemId": "2184997", "problem_idx": "F", "shortId": "1869F", "contest_number": "1869", "problem_submissions": {"E": [222790733, 222755919, 223014703, 222844888, 222822436, 222820168], "D2": [222751076, 222765748, 222762229, 222767685, 222770713, 222771349, 222774390, 222781618, 222778821, 222788639, 222773236, 222775336, 222775900, 222778257, 222775220, 222773627, 222771492], "D1": [222743411, 222768273, 222754309, 222754872, 222757370, 222757211, 222762465, 222761473, 222755833, 222757091, 222752420, 222764925, 222765023, 222761868, 222761450, 222761828, 222765878, 222760854], "C": [222734213, 222799024, 222739072, 222743933, 222748797, 222742198, 222748357, 222740791, 222743470, 222743624, 222737636, 222744668, 222749662, 222742346, 222741675, 222752222, 222753724, 222751049], "B": [222728831, 222759638, 222728679, 222733793, 222732869, 222730403, 222734827, 222731660, 222733775, 222732224, 222728510, 222735540, 222734578, 222733639, 222729850, 222736886, 222733662, 222738397], "A": [222725390, 222757999, 222725599, 222726282, 222727750, 222725856, 222726824, 222727514, 222730110, 222726868, 222725449, 222728462, 222727639, 222725642, 222725871, 222727421, 222725878, 222731354], "F": [223418170]}, "name": "F. Flower-like Pseudotree", "statement": "A is a connected graph which has cycle and self-loops. Note that a\r\npseudotree . It can be shown that a pseudotree with n vertices always\r\ncontains n edges.After deleting all edges on the cycle in the\r\npseudotree, a forest^{\r\ndagger} will be formed. It can be shown that each tree in the forest\r\nwill contain exactly one vertex which is on cycle before removing the\r\nedges. If all trees in the forest have the same depth^{\r\nddagger} when picking the vertex on cycle as root, we call the original\r\npseudotree .Our friend sszcdjr, had a flower-like pseudotree with n\r\nvertices and n edges. However, he forgot all the edges in the\r\npseudotree. Fortunately, he still remembers the degrees of vertices.\r\nSpecifically, the degree of the i-th vertex is d_i.You have to help\r\nsszcdjr construct a possible flower-like pseudotree with n vertices,\r\nwhere the degree of the i-th vertex is d_i, or tell him that it is\r\nimpossible.^{\r\ndagger} A forest is a graph in which all connectivity components are\r\ntrees. A connected graph without cycles and self-loops is called a\r\ntree.^{\r\nddagger} The depth of a tree with a root is the maximum distance from\r\nthe root to the vertex of this tree.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define oo 1000000010\n\nconst int N = 1000010;\n\nint n, d[N];\n\nvector< pair< int , int > > arr;\n\nint sum[N] , prnt[N] , comp[N] , mx[N] , depth[N];\n\nbool notake[N];\n\nint qu[N] , ql , qr;\n\nvoid solve(){\n\tscanf(\"%d\",&n);\n\tarr.clear();\n\tfor(int i = 1;i <= n;i++){\n\t\tscanf(\"%d\",&d[i]);\n\t\tarr.push_back(make_pair(d[i] , i));\n\t\tnotake[i] = false;\n\t\tprnt[i] = -1;\n\t}\n\tsort(arr.begin(),arr.end());\n\tfor(int i = 0 ;i < (int)arr.size();i++){\n\t\tsum[i + 1] = sum[i] + arr[i].first;\n\t\tif(sum[i + 1] > 2 * n){\n\t\t\tputs(\"NO\");\n\t\t\treturn; \n\t\t}\n\t}\n\tif(arr.back().first == 1 || sum[n] != 2 * n){\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tif(arr.back().first == 2){\n\t\tif(arr[0].first == 1){\n\t\t\tputs(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tputs(\"YES\");\n\t\tprintf(\"1 %d\\n\",n);\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tprintf(\"%d %d\\n\",i , i + 1);\n\t\t}\n\t\treturn;\n\t}\n\tint ones = upper_bound(arr.begin(),arr.end(),make_pair(1 , oo)) - arr.begin();\n\n\tif(sum[n] - sum[ones] - 2 * (n - ones) != ones){\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\n\tfor(int cur , last , tmp , give , i = n - 2;i >= 0 && arr[i].first > 2;i--){\n\t\tcur = sum[n] - sum[i] - 2 * (n - i);\n\t\tlast = i - 1;\n\t\tgive = 0;\n\t\twhile(last >= ones){\n\t\t\tif(arr[last].first == 2){\n\t\t\t\tgive += ((last - ones + cur) / cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgive++;\n\t\t\ttmp = last - cur;\n\t\t\tif(tmp < ones)\n\t\t\t\tbreak;\n\t\t\tcur = sum[last + 1] - sum[tmp + 1] - (last - tmp);\n\t\t\tlast = tmp;\n\t\t}\n\t\ttmp = i - ones;\n\t\tif(tmp >= give * (n - i)){\n\t\t\tputs(\"YES\");\n\t\t\tprintf(\"%d %d\\n\",arr[i].second , arr[n - 1].second);\n\t\t\tfor(int j = i ;j < n - 1;j++){\n\t\t\t\tprintf(\"%d %d\\n\",arr[j].second , arr[j + 1].second);\n\t\t\t}\n\t\t\tql = qr = 0;\n\t\t\tfor(int j = n - 1;j >= i;j--){\n\t\t\t\td[arr[j].second] -= 2;\n\t\t\t\tcomp[arr[j].second] = arr[j].second;\n\t\t\t\tmx[arr[j].second] = arr[j].second;\n\t\t\t\tdepth[arr[j].second] = 0;\n\t\t\t\tqu[qr++] = arr[j].second;\n\t\t\t}\n\t\t\tint last = i - 1;\n\t\t\twhile(last >= ones){\n\t\t\t\twhile(ql < qr && d[qu[ql]] == 0) ql++;\n\t\t\t\tprnt[arr[last].second] = qu[ql];\n\t\t\t\tdepth[arr[last].second] = depth[qu[ql]] + 1;\n\t\t\t\tcomp[arr[last].second] = comp[qu[ql]];\n\t\t\t\tmx[comp[arr[last].second]] = arr[last].second;\n\t\t\t\td[qu[ql]]--;\n\t\t\t\td[arr[last].second]--;\n\t\t\t\tqu[qr++] = arr[last].second;\n\t\t\t\tlast--;\n\t\t\t}\n\n\t\t\tfor(int tmp , j = ones ; j < n;j++){\n\t\t\t\ttmp = arr[j].second;\n\t\t\t\tif(mx[comp[tmp]] != tmp) continue;\n\t\t\t\twhile(tmp != -1){\n\t\t\t\t\tnotake[tmp] = true;\n\t\t\t\t\ttmp = prnt[tmp];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlast = ones;\n\t\t\tfor(int j = i;depth[mx[arr[j].second]] < depth[mx[arr[n - 1].second]];j++){\n\t\t\t\twhile(notake[arr[last].second]) last++;\n\t\t\t\td[prnt[arr[last].second]]++;\n\t\t\t\tprnt[arr[last].second] = mx[arr[j].second];\n\t\t\t\td[mx[arr[j].second]]--;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\tlast = ones - 1;\n\t\t\tfor(int j = ones ;j < n;j++){\n\t\t\t\twhile(d[arr[j].second] > 0){\n\t\t\t\t\td[arr[j].second]--;\n\t\t\t\t\tprnt[arr[last].second] = arr[j].second;\n\t\t\t\t\tlast--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j = i - 1;j >= 0;j--){\n\t\t\t\tprintf(\"%d %d\\n\",arr[j].second , prnt[arr[j].second]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t}\n\tputs(\"NO\");\n\n}\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\t\n\treturn 0;\n} \n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "greedy", "implementation", "trees"], "dificulty": "3000", "interactive": false}