{
    "link": "https://codeforces.com//contest/861/problem/B",
    "problemId": "122870",
    "problem_idx": "B",
    "shortId": "861B",
    "contest_number": "861",
    "problem_submissions": {
        "B": [
            30441262,
            30424376,
            30427161,
            30427960,
            30424359,
            30424926,
            30425840,
            30430094,
            30424319,
            30428309,
            30428624,
            30440366,
            30437511,
            30435804,
            30427921,
            30432832,
            30423882
        ],
        "F": [
            30440095,
            30439628,
            30440266,
            30439498,
            30441670,
            30441500,
            30452319,
            30437084
        ],
        "E": [
            30436514,
            30436701,
            30441404,
            30443472,
            30442827,
            30445184,
            30445314,
            30443353,
            30443911
        ],
        "D": [
            30428168,
            30427382,
            30423887,
            30433533,
            30430871,
            30432293,
            30434646,
            30433520,
            30433941,
            30433630,
            30434459,
            30436865,
            30433644,
            30426019,
            30432738,
            30434925,
            30433542,
            30432317,
            30434703
        ],
        "A": [
            30424689,
            30422095,
            30427679,
            30422354,
            30422107,
            30422516,
            30422863,
            30426215,
            30422101,
            30424813,
            30422256,
            30425576,
            30489148,
            30430836,
            30422849,
            30423019,
            30422141,
            30422002
        ],
        "C": [
            30423987,
            30425801,
            30429852,
            30426800,
            30428131,
            30429744,
            30425472,
            30430400,
            30430892,
            30431289,
            30440032,
            30431284,
            30432065,
            30432412,
            30435482,
            30426919
        ]
    },
    "name": "B. Which floor ",
    "statement": "In a building where Polycarp lives there are number of flats on each\r\nfloor. Unfortunately, Polycarp don’t remember how many flats are on each\r\nfloor, but he remembers that the flats are numbered from from lower to\r\nupper floors. That is, the first several flats are on the first floor,\r\nthe next several flats are on the second and so on. Polycarp don’t\r\nremember the total number of flats in the building, so you can consider\r\nthe building to be infinitely high (i.e. there are infinitely many\r\nfloors). Note that the floors are numbered from .Polycarp remembers on\r\nwhich floors several flats are located. It is guaranteed that this\r\ninformation is not self-contradictory. It means that there exists a\r\nbuilding with equal number of flats on each floor so that the flats from\r\nPolycarp’s memory have the floors Polycarp remembers.Given this\r\ninformation, is it possible to restore the exact floor for flat ?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(\"%d\",&num1)\n#define sll(num1) scanf(\"%lld\",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define TRACE\n \n//FILE *fin = freopen(\"in\",\"cc\",stdin);\n//FILE *fout = freopen(\"out\",\"s2numx\",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << \": \" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << \" | \" << #nn3 << \": \" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << endl;\n#define trace5(num1, bin, ch, d, txx)    cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #txx << \": \" << txx << endl;\n#define trace6(num1, bin, ch, d, txx, det) cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #txx << \": \" << txx << \" | \" << #det << \": \" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, txx)\n#define trace6(num1, bin, ch, d, txx, det)\n \n#endif\n\n#define pi(numx) printf(\"%d\\num1\",numx)\n#define ff first\n#define ss second\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ll long long\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n\n#define lb lower_bound\n#define ub upper_bound\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define freq first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\nbool don[105];\nVI idxx;\nint main(){\n    fast\n    int num1,num2;\n    cin>>num1>>num2;\n    int cc[num2];\n    int freq[num2];\n    for(int i = 0 ; i < num2 ;i++){\n        cin >> cc[i] >> freq[i];\n        \n    }\n    if(num1==1){\n        cout << 1;\n    }\n    else{\n    for(int i=1;i<=100;i++){\n    \tfor(int j=0;j<num2;j++){\n    \t\tif(ceil((double)cc[j]/i)==freq[j]&& j!=num2-1){\n    \t\t\tcontinue;\n    \t\t}\n    \t\telse if(ceil((double)cc[j]/i)==freq[j] && j==num2-1){\n    \t\t\tdon[i]==true;\n    \t\t\tidxx.pb((int)ceil((double)num1/i));\n    \t\t}\n    \t\telse{\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    }\n    if(idxx.size()!=0){\n        sort(idxx.begin(),idxx.end());\n        if(idxx[0]==idxx[idxx.size()-1])\n            cout<<idxx[0];\n        else\n            cout<<-1;\n        }\n        else\n            cout<<-1;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Which floor .json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "We will store our current answer in some variable ans. Initially it is -1.\n\nLet's iterate over the quantity of the flats on each floor (it will be from 1 to 100 inclusive). Let it be cf. Then we have to check that this quantity coincides with given input. If  for any  then this quantity is incorrect.\n\nNow if  then we can't determine on which floor flat n is situated. Print -1. In the other case set .",
    "hint": []
}