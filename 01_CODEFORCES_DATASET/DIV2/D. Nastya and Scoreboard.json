{
    "link": "https://codeforces.com//contest/1341/problem/D",
    "problemId": "599361",
    "problem_idx": "D",
    "shortId": "1341D",
    "contest_number": "1341",
    "problem_submissions": {
        "F": [
            77848250,
            77840090
        ],
        "E": [
            77821518,
            77899755,
            77823133,
            77824849,
            77837980,
            77849952,
            77843481,
            77845012,
            77851732,
            77844281,
            77827942,
            77845115
        ],
        "D": [
            77806595,
            77808901,
            77796444,
            77812229,
            77809547,
            77806349,
            77817033,
            77812671,
            77820011,
            77815726,
            77848086,
            77830454,
            77808246,
            77858849,
            77820964,
            77813001,
            77808174,
            77806131,
            77813874
        ],
        "C": [
            77795777,
            77791932,
            77784729,
            77779572,
            77803941,
            77795669,
            77798417,
            77792949,
            77801051,
            77799331,
            77784061,
            77803420,
            77789866,
            77799759,
            77790437,
            77791028,
            77788622,
            77785381
        ],
        "B": [
            77784814,
            77781931,
            77786979,
            77777635,
            77777444,
            77778027,
            77777282,
            77784813,
            77787430,
            77790189,
            77790670,
            77814054,
            77777959,
            77791325,
            77779844,
            77782238,
            77778289,
            77777782
        ],
        "A": [
            77769516,
            77770127,
            77769168,
            77771475,
            77770045,
            77769414,
            77769437,
            77772206,
            77772461,
            77778892,
            77770438,
            77804897,
            77769675,
            77775846,
            77769311,
            77769798,
            77769599,
            78093030,
            77769512
        ]
    },
    "name": "D. Nastya and Scoreboard",
    "statement": "The poor boy was very upset because of that. He was so sad that he\r\npunched some kind of scoreboard with numbers. The numbers are displayed\r\nin the same way as on an electronic clock: each digit position consists\r\nof 7 segments, which can be turned on or off to display different\r\nnumbers. The picture shows how all 10 decimal digits are displayed:\r\nAfter the punch, some segments stopped working, that is, some segments\r\nmight stop glowing if they glowed earlier. But Denis remembered how many\r\nsticks were glowing and how many are glowing now. Denis broke k segments\r\nand he knows which sticks are working now. Denis came up with the\r\nquestion: what is the maximum possible number that can appear on the\r\nboard if you turn on exactly k sticks (which are off now)? It is that\r\nthe number includes leading zeros.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nchar arr[10][10] = {\n        \"1110111\",\n        \"0010010\",\n        \"1011101\",\n        \"1011011\",\n        \"0111010\",\n        \"1101011\",\n        \"1101111\",\n        \"1010010\",\n        \"1111111\",\n        \"1111011\"\n};\n\nint val[10];\nint dp[2100][2100];\nint dval[2100];\nchar ans[2100];\nchar c[10];\n\nint main() {\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 7; ++j) {\n            if (arr[i][j] == '1') val[i] |= 1 << j;\n        }\n    }\n    int N, K;\n    scanf(\"%d%d \", &N, &K);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%s \", c);\n        for (int j = 0; j < 7; ++j)\n            if (c[j] == '1') dval[i] |= 1 << j;\n    }\n    dp[N][0] = 1;\n    for (int i = N - 1; i >= 0; --i) {\n        for (int t = 0; t < 10; ++t) {\n            if ((val[t] & dval[i]) == dval[i]) {\n                int diff = __builtin_popcount(val[t] ^ dval[i]);\n                for (int j = diff; j <= K; ++j)\n                    dp[i][j] |= dp[i + 1][j - diff];\n            }\n        }\n    }\n    if (dp[0][K]) {\n        int cur = K;\n        for (int i = 0; i < N; ++i) {\n            for (int t = 9; t >= 0; --t) {\n                if ((val[t] & dval[i]) == dval[i]) {\n                    int diff = __builtin_popcount(val[t] ^ dval[i]);\n                    if (dp[i + 1][cur - diff]) {\n                        ans[i] = '0' + t;\n                        cur = cur - diff;\n                        break;\n                    }\n                }\n            }\n        }\n        puts(ans);\n    } else {\n        puts(\"-1\");\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Nastya and Scoreboard.json",
    "editorial_link": "https://codeforces.com//blog/entry/76479",
    "editorial": "Let , if at the suffix you can turn on exactly sticks and get the\r\ncorrect sequence of digits and otherwise. It is easy to recalculate this\r\ndynamics: we will make transitions to all possible digits (the mask at\r\nposition should be a submask of the digit).Asymptotic calculate of the\r\ndynamics .Now let\u00e2\u0080\u0099s go in order from to and will try to eagerly set the\r\nmaximum possible figure using our dynamics. It is easy to understand\r\nthat in this way we get the maximum possible number of digits.\r\n"
}