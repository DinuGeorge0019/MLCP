{
    "link": "https://codeforces.com//contest/675/problem/C",
    "problemId": "60390",
    "problem_idx": "C",
    "shortId": "675C",
    "contest_number": "675",
    "problem_submissions": {
        "E": [
            17948562,
            17949439,
            17951477,
            17952621,
            17953457,
            17950428,
            17953529,
            17947770,
            17951235,
            17951895,
            17951367,
            17951619,
            17948510,
            17952736,
            17951724
        ],
        "C": [
            17943932,
            17938689,
            17941522,
            17944729,
            17944175,
            17953098,
            17943056,
            17944846,
            17947374,
            17939953,
            17962657,
            17966235,
            17954725,
            17940735,
            17941726,
            22255966,
            17952634,
            17944646,
            17957135
        ],
        "D": [
            17942614,
            17940890,
            17945507,
            17947894,
            17948215,
            17945745,
            17947110,
            17948235,
            17945049,
            17945728,
            17947720,
            17940113,
            17945095,
            17943288,
            17943504,
            17946575,
            17949945,
            17942674,
            17945705,
            17947663
        ],
        "B": [
            17938759,
            17936066,
            17938993,
            17938420,
            17938948,
            17938583,
            17948981,
            17937018,
            17940037,
            17964516,
            17938191,
            17942540,
            17939538,
            17937369,
            17937220,
            17939353,
            17954945,
            17936753,
            17939065,
            17939668
        ],
        "A": [
            17936166,
            17934371,
            17935192,
            17936993,
            17935281,
            17935512,
            17947868,
            17934798,
            17935340,
            17934655,
            17934645,
            17943337,
            17937162,
            17934833,
            17935029,
            17935291,
            17934716,
            17934453,
            17934986,
            17937083
        ]
    },
    "name": "C. Money Transfers",
    "statement": "There are banks in the city where Vasya lives, they are located in a\r\ncircle, such that any two banks are neighbouring if their indices differ\r\nby no more than . Also, bank and bank are neighbours if . No bank is a\r\nneighbour of itself.Vasya has an account in each bank. Its balance may\r\nbe negative, meaning Vasya owes some money to this bank.There is only\r\none type of operations available: transfer some amount of money from any\r\nbank to account in any bank. There are no restrictions on the size of\r\nthe sum being transferred or balance requirements to perform this\r\noperation.Vasya doesn’t like to deal with large numbers, so he asks you\r\nto determine the minimum number of operations required to change the\r\nbalance of each bank account to zero. It’s guaranteed, that this is\r\npossible to achieve, that is, the total balance of Vasya in all banks is\r\nequal to zero.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e16;\n\nll p[200200], a[200200];\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    p[0] = a[0];\n    for (int i = 1; i < n; i++)\n        p[i] = a[i] + p[i - 1];\n    sort(p, p + n);\n    p[n] = INF;\n    int ans = 0;\n    int i = 0;\n    while (i < n)\n    {\n        int j = i;\n        while (p[j] == p[i])\n            j++;\n        ans = max (ans, j - i);\n        i = j;\n    }\n    cout << n - ans;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Money Transfers.json",
    "editorial_link": "https://codeforces.com//blog/entry/44902",
    "editorial": "We have array and should make all numbers in it be equal to zero with\r\nminimal number of operations. Sum of all equals to zero. We can divide\r\narray into parts of consecutive elements with zero sum. If part has\r\nlength we can use all pairs of neighbours in operations and make all\r\nnumbers be equal to zero with operations. So, if we sum number of\r\noperations in each part we get where is number of parts. We should\r\nmaximize to get the optimal answer. One of the part consists of some\r\nprefix and probably some suffix. Each of other parts is subarray of .\r\nLetâs calculate prefix sums. Each part has zero sum so prefix sums\r\nbefore each part-subarray are the same. So we can calculate number of\r\noccurencies of the most frequent number in prefix sums and answer will\r\nbe equal to . Bonus: how to hack solutions with overflow? Code\r\n",
    "hint": []
}