{
    "link": "https://codeforces.com//contest/1594/problem/E2",
    "problemId": "1135639",
    "problem_idx": "E2",
    "shortId": "1594E2",
    "contest_number": "1594",
    "problem_submissions": {
        "E2": [
            131201431,
            131189862,
            131190731,
            131204830,
            131335383,
            131226398,
            131198152,
            131201638,
            131204894,
            131232694,
            131217147,
            131214481,
            131205202,
            131197222,
            131203076,
            131208236,
            131224943,
            131226297,
            131228207,
            131205596
        ],
        "F": [
            131193546,
            131198168,
            131204819,
            131191276,
            131194027,
            131211385,
            131209381,
            131214118,
            131206895,
            131201547,
            131217018,
            131226069,
            131219283,
            131221051,
            131209964,
            131207271,
            131214277,
            131238575,
            131228401,
            131201592
        ],
        "E1": [
            131181296,
            131181310,
            131181914,
            131185896,
            131188245,
            131188013,
            131187848,
            131190323,
            131191597,
            131193172,
            131188008,
            131187198,
            131191256,
            131191508,
            131193161,
            131216105,
            131192871,
            131192806,
            131193863
        ],
        "C": [
            131178489,
            131175224,
            131175277,
            131176811,
            131175035,
            131178056,
            131178928,
            131176905,
            131179134,
            131182174,
            131176234,
            131176202,
            131182167,
            131177472,
            131233310,
            131183523,
            131183173,
            131182656,
            131183921,
            131177712
        ],
        "D": [
            131177404,
            131179044,
            131177912,
            131183480,
            131185907,
            131184631,
            131184408,
            131188052,
            131189056,
            131189293,
            131184453,
            131184011,
            131187702,
            131188002,
            131190262,
            131189525,
            131200165,
            131190411,
            131188282
        ],
        "A": [
            131171410,
            131170689,
            131170400,
            131171742,
            131170602,
            131170026,
            131170772,
            131172659,
            131172422,
            131172236,
            131170874,
            131170513,
            131172774,
            131170479,
            131173618,
            131170466,
            131175176,
            131176321,
            131170181
        ],
        "B": [
            131170592,
            131172208,
            131170486,
            131173477,
            131172222,
            131172615,
            131174348,
            131174291,
            131175520,
            131179615,
            131172910,
            131172727,
            131175758,
            131172405,
            131179739,
            131172566,
            131179352,
            131177990,
            131173135
        ]
    },
    "name": "E2. Rubik s Cube Coloring  hard version ",
    "statement": "Theofanis is starving, and he wants to eat his favorite food, sheftalia.\r\nHowever, he should first finish his homework. Can you help him with this\r\nproblem?You have a binary tree of 2^k - 1 nodes a binary tree where all\r\nvertices i from 1 to 2^{k - 1} - 1 have exactly two children: vertices\r\n2i and 2i + 1. Vertices from 2^{k - 1} to 2^k - 1 don’t have any\r\nchildren. You want to color its vertices with the 6 Rubik’s cube colors\r\n(White, Green, Red, Blue, Orange and Yellow).Let’s call a coloring when\r\nall edges connect nodes with colors that are sides in the Rubik’s cube.\r\nMore formally: a white node can be neighboring with white and yellow\r\nnodes; a yellow node can be neighboring with white and yellow nodes; a\r\ngreen node can be neighboring with green and blue nodes; a blue node can\r\nbe neighboring with green and blue nodes; a red node can be neighboring\r\nwith red and orange nodes; an orange node can be neighboring with red\r\nand orange nodes; However, there are n special nodes in the tree, colors\r\nof which are already chosen.You want to calculate the number of the good\r\ncolorings of the binary tree. Two colorings are considered different if\r\nat least one node is colored with a different color.The answer may be\r\ntoo large, so output the answer modulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> \n#define int long long\n/*\n60\n2\n1000000000000 o\n2000000000000 g\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod=1e9+7,inv3=(mod+1)/3; \nint k,n; \nmap<long long,int> ch[2],fla,f[4],vis; \nint fpw(int x,int k,int p) {\n    int ret=1;\n    while (k) {\n        if (k&1) ret=1ll*ret*x%p;\n        x=1ll*x*x%p; k>>=1; \n    }\n    return ret; \n}\nint calcdep(long long x) {\n    int o=0;\n    for (;x<=(1ll<<k)-1;(x<<=1)) o++; \n    return o; \n}\nint add(int x,int y) {\n    return (x+=y)>=mod?x-mod:x; \n}\nint calc(int n) {\n    int q=fpw(2,n,mod-1);\n    q=(q-2)%(mod-1); q=(q+mod-1)%(mod-1);\n    return 1ll*fpw(4,q,mod)*6%mod; \n}\nvoid dfs(long long u) {\n    if (ch[0][u]) dfs(ch[0][u]);\n    if (ch[1][u]) dfs(ch[1][u]); \n    int dep=calcdep(u);\n   // cout<<u<<' '<<dep<<'\\n'; \n    if (dep==1) {\n        if (fla[u]) {\n            f[fla[u]][u]=1; \n        }\n        else {\n            f[1][u]=f[2][u]=f[3][u]=2; \n        }\n        return ; \n    }\n    int F[4],G[4];\n    int t=calc(dep-1); t=1ll*t*inv3%mod;  \n    int sf=0,sg=0;\n    if (vis[ch[0][u]]) {\n        for (int i=1;i<=3;i++) F[i]=f[i][ch[0][u]]; \n    }\n    else {\n        for (int i=1;i<=3;i++) F[i]=t; \n    }\n    if (vis[ch[1][u]]) {\n        for (int i=1;i<=3;i++) G[i]=f[i][ch[1][u]]; \n    }\n    else {\n        for (int i=1;i<=3;i++) G[i]=t; \n    }\n    for (int i=1;i<=3;i++) sf=add(sf,F[i]),sg=add(sg,G[i]);\n    if (fla[u]) {\n        f[fla[u]][u]=1ll*add(sf,mod-F[fla[u]])*add(sg,mod-G[fla[u]])%mod; \n    }\n    else {\n        for (int i=1;i<=3;i++) {\n            f[i][u]=2ll*add(sf,mod-F[i])%mod*add(sg,mod-G[i])%mod; \n        }\n    }\n  //  cout<<u<<' '<<f[1][u]<<' '<<f[2][u]<<' '<<f[3][u]<<'\\n'; \n}\n\nsigned main() {\n    cin>>k>>n;\n    for (int i=1;i<=n;i++) {\n        long long id;\n        cin>>id;\n        string s; \n\n        cin>>s;\n        if (s[0]=='w' || s[0]=='y') {\n            fla[id]=1; \n        }\n        else if (s[0]=='g'||s[0]=='b') {\n            fla[id]=2; \n        }\n        else fla[id]=3; \n        long long u=id;\n        while (u!=0) {\n            vis[u]=1; \n            long long fa=u/2; \n            if (u==fa*2) {\n                ch[0][fa]=u; \n            }\n            else {\n                ch[1][fa]=u; \n            }\n            u=fa;\n        }\n    } \n    dfs(1);\n    printf(\"%d\\n\",add(f[1][1],add(f[2][1],f[3][1]))); \n    return 0; \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Rubik s Cube Coloring  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/95525",
    "editorial": "Letâs define a node as marked if it has a predefined node in its\r\nsubtree. There is always at least marked node since all predefined nodes\r\nare definitely marked. You can see that marked nodes form a path for the\r\nroot to any predefined node. Thus there are at most marked nodes and we\r\ncan run a standard on them (node is colored with ). Depending on the\r\nimplementation the can have time complexity or if you use map.You\r\nmultiply the result with where is the number of unmarked nodes. This\r\nholds because if their parent has a fixed color they always have choices\r\nand so on.\r\n",
    "hint": [
        "Hint If you have a tree with a root with a fixed color and the others are all not predefined the number of colorings is ."
    ]
}