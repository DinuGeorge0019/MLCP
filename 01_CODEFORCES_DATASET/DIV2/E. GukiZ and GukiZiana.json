{
    "link": "https://codeforces.com//contest/551/problem/E",
    "problemId": "29256",
    "problem_idx": "E",
    "shortId": "551E",
    "contest_number": "551",
    "problem_submissions": {
        "E": [
            11555073,
            11556189,
            11556267,
            12093920,
            12093908,
            12093899,
            12093877,
            11569219,
            12075099,
            11560541,
            11974261
        ],
        "C": [
            11550228,
            11551507,
            11551274,
            11549626,
            11554425,
            11552178,
            11551280,
            11551429,
            11550037,
            11552051,
            11552542,
            11553869,
            11554092,
            11551179,
            11554624,
            11555215,
            11554114,
            11556563
        ],
        "B": [
            11547200,
            11548697,
            11548210,
            11548298,
            11557853,
            11549187,
            11548320,
            11548758,
            11553975,
            11549363,
            11548545,
            11548081,
            11548144,
            11549688,
            11551583,
            11555068,
            11550330,
            11549557,
            11552446,
            11549314
        ],
        "A": [
            11546166,
            11546483,
            11546960,
            11546195,
            11546251,
            11547284,
            11546221,
            11546416,
            11546211,
            11546383,
            11546301,
            11546208,
            11546276,
            11546409,
            11547548,
            11546344,
            11547064,
            11546598,
            11546207,
            11546571
        ],
        "D": [
            11557988,
            11557349,
            11552518,
            11560739,
            11558020,
            11557476,
            11555146,
            11555685,
            11602898,
            11557308,
            11561475
        ]
    },
    "name": "E. GukiZ and GukiZiana",
    "statement": "Professor GukiZ was playing with arrays again and accidentally\r\ndiscovered new function, which he called . For given array , indexed\r\nwith integers from to , and number , represents maximum value of , such\r\nthat . If there is no as an element in , then is equal to . GukiZ also\r\nprepared a problem for you. This time, you have two types of queries:\r\nFirst type has form and asks you to increase values of all such that by\r\nthe non-negative integer . Second type has form and asks you to find\r\nvalue of . For each query of type , print the answer and make GukiZ\r\nhappy!\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n\n#define pb push_back\n#define mp make_pair\n#define LL long long\n#define LD long double\n#define maxlongint 2147483647\n\nusing namespace std;\n\nconst int inf = 999999999;\nconst int mod = 1000000007;\n//const int sz = 700;\n\ninline int Getint()\n{\n    char ch = getchar();\n    while (ch < '0' || ch > '9') ch = getchar();\n    int ret = 0;\n    while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();\n    return ret;\n}\n\nvector <pair<int, int> > v[800];\n\nint a[500010], add[500010];\nint n, q, l, r, x, type;\nint sz;\n\ninline int Calc1(int n, int x)\n{\n    x -= add[n];\n    if (x <= 0) return 0;\n    int l = 0, r = v[n].size() - 1, ans = 0;\n    //printf(\"n, x = %d %d\\n\", n, x);\n    //printf(\"l, r = %d %d\\n\", l, r);\n    while (l <= r)\n    {\n        int mid = l + r >> 1;\n        //printf(\"mid = %d %d\\n\", mid, v[n][mid].first);\n        if (v[n][mid].first >= x)\n        {\n            if (v[n][mid].first == x) ans = v[n][mid].second;\n            r = mid - 1;\n        }\n        else\n        {\n            l = mid + 1;\n        }\n    }\n    return ans;\n}\n\ninline int Calc2(int n, int x)\n{\n    x -= add[n];\n    if (x <= 0) return 0;\n    int l = 0, r = v[n].size() - 1, ans = 0;\n    //printf(\"n, x = %d %d\\n\", n, x);\n    //printf(\"l, r = %d %d\\n\", l, r);\n    while (l <= r)\n    {\n        int mid = l + r >> 1;\n        //printf(\"mid = %d %d %d\\n\", mid, v[n][mid].first, v[n][mid].second);\n        if (v[n][mid].first > x)\n        {\n            r = mid - 1;\n        }\n        else\n        {\n            if (v[n][mid].first == x) ans = v[n][mid].second;\n            l = mid + 1;\n        }\n    }\n    //printf(\"ans = %d\\n\", ans);\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"123.in\", \"r\", stdin);\n    n = Getint(), q = Getint();\n    sz = int(sqrt(n));\n    for (int i = 1; i <= n; i++) a[i] = Getint();\n    for (int i = 1, im = n / sz + (n % sz != 0); i <= im; i++)\n    {\n        int bl = (i - 1) * sz + 1, br = min(i * sz, n);\n        for (int j = bl; j <= br; j++) v[i].pb(mp(a[j], j));\n        sort(v[i].begin(), v[i].end());\n    }\n    for (int i = 1; i <= q; i++)\n    {\n        type = Getint();\n        if (type == 1)\n        {\n            l = Getint(), r = Getint(), x = Getint();\n            for (int j = 1, jm = n / sz + (n % sz != 0); j <= jm; j++)\n            {\n                int bl = (j - 1) * sz + 1, br = min(j * sz, n);\n                if (l <= bl && br <= r)\n                {\n                    add[j] += x;\n                    if (add[j] > inf) add[j] = inf + 1;\n                }\n                else if (!(bl > r || br < l))\n                {\n                    //printf(\"good\\n\");\n                    for (int k = 0; k < v[j].size(); k++)\n                    {\n                        if (l <= v[j][k].second && v[j][k].second <= r)\n                        {\n                            v[j][k].first += x;\n                            if (v[j][k].first > inf + 1) v[j][k].first = inf + 2;\n                        }\n                    }\n                    sort(v[j].begin(), v[j].end());\n                }\n            }\n        }\n        else\n        {\n            x = Getint();\n            int ansl = 0, ansr = 0;\n            for (int j = 1, jm = n / sz + (n % sz != 0); j <= jm; j++)\n            {\n                if (!ansl) ansl = Calc1(j, x);\n                ansr = max(ansr, Calc2(j, x));\n            }\n            //printf(\"ans = %d %d\\n\", ansl, ansr);\n            if (!ansl) ansr = -1;\n            printf(\"%d\\n\", ansr - ansl);\n        }\n        //printf(\"===\\n\");\n        //for (int j = 0; j < v[1].size(); j++) printf(\"%d %d\\n\", v[1][j].first, v[1][j].second);\n        //printf(\"===\\n\");\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. GukiZ and GukiZiana.json",
    "editorial_link": "https://codeforces.com/blog/entry/18508",
    "editorial": "First we divide array a in  groups with  numbers. Every group in each moment will be kept sorted. For type 1 query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it's current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let's handle with type 2 queries. When we want find GukiZiana(a,?j), we search for the first and the last occurence of j by groups. One group can be binary searched in , because of sorted values, and most  groups will be searched. Of course, for the first occurence we search for minimum index of value of j, and for the last occurence maximum index of value of j in array. When we find these 2 indexes, we must restore their original positions in array a and print their difference. If there is no occurence of j, print ?-?1. Total complexity is .",
    "hint": []
}