{"link": "https://codeforces.com//contest/237/problem/B", "problemId": "2047", "problem_idx": "B", "shortId": "237B", "contest_number": "237", "problem_submissions": {"D": [2433036, 2432295, 2433500, 2432355, 2433903, 2433329, 2434102, 2434333, 2432248, 2432915, 2696259, 2434308], "E": [2431587, 2432589, 2431675, 2431055, 2432864, 2432954, 2431021, 2430681, 2431544, 2429287, 2431020, 2434055, 2432007, 2431656, 2432219, 2432671, 2432758], "C": [2430148, 2430407, 2429504, 2429737, 2429937, 2428700, 2428982, 2428966, 2427820, 2428219, 2429089, 2428238, 2428941, 2428553, 2429636, 2429650], "B": [2429161, 2428110, 2430688, 2429293, 2429097, 2430858, 2428364, 2428379, 2429868, 2430294, 2429444, 2430807, 2429497, 2429431, 2430215, 2428764, 2429093], "A": [2427471, 2426382, 2427215, 2426994, 2428604, 2426466, 2426659, 2426416, 2427387, 2426339, 2427186, 2426639, 2432021, 2427667, 2426349, 2427479]}, "name": "B. Young Table", "statement": "You\u2019ve got table , consisting of rows, numbered from 1 to . The -th line\r\nof table contains cells, at that for all holds . Let\u2019s denote as the\r\ntotal number of cells of table , that is, . We know that each cell of\r\nthe table contains a single integer from to , at that all written\r\nintegers are distinct. Let\u2019s assume that the cells of the -th row of\r\ntable are numbered from 1 to , then let\u2019s denote the number written in\r\nthe -th cell of the -th row as . Your task is to perform several swap\r\noperations to rearrange the numbers in the table so as to fulfill the\r\nfollowing conditions: for all holds ; for all holds . In one swap\r\noperation you are allowed to choose two different cells of the table and\r\nswap the recorded there numbers, that is the number that was recorded in\r\nthe first of the selected cells before the swap, is written in the\r\nsecond cell after it. Similarly, the number that was recorded in the\r\nsecond of the selected cells, is written in the first cell after the\r\nswap.Rearrange the numbers in the required manner. Note that you are\r\nallowed to perform any number of operations, but not more than . You do\r\nnot have to minimize the number of operations.\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <memory.h>\n#include <cstring>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define down(i,b,a) for(int i=b;i>=a;i--)\n#define foredge(e,x) for(edge *e = x->first;e;e = e->next)\ntypedef long long ll;\nconst int maxn = 50,maxs = maxn*maxn,geps = 1;\nstruct block{\n\tint x,y;\n\tvoid input(int _x,int _y){x = _x,y = _y;}\n}blocks[maxs+geps];\nint n,c[maxn+geps];\nint group[maxs+geps],s;\nbool used[maxs+geps];\nvoid Init(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\",c+i);\n\tint x,ind = 0;\n\trep(i,1,n) rep(j,1,c[i]) scanf(\"%d\",&x),blocks[x].input(i,j),group[++ind] = x;\n\ts = ind;\n}\nint que[maxs+geps];\nint w1[maxs+geps],w2[maxs+geps],w3[maxs+geps],w4[maxs+geps],top = 0;\nvoid push(int q1,int q2,int q3,int q4){\n\t++top;\n\tw1[top] = q1;\n\tw2[top] = q2;\n\tw3[top] = q3;\n\tw4[top] = q4;\n}\nvoid func(int x){\n\tint head = 0;\n\tfor(que[0] = x;group[x]!=que[0];x = group[x]) que[++head] = group[x];\n\trep(i,1,head)\n\t\tpush(blocks[que[i-1]].x,blocks[que[i-1]].y,blocks[que[i]].x,blocks[que[i]].y),\n\t\tswap(blocks[que[i-1]],blocks[que[i]]);\n\trep(i,0,head) used[que[i]] = true;\n}\nvoid solve(){\n\trep(i,1,s) if(!used[i]) func(i);\n\tprintf(\"%d\\n\",top);\n\trep(i,1,top) printf(\"%d %d %d %d\\n\",w1[i],w2[i],w3[i],w4[i]);\n}\n\nint main(){\n\tInit();\n\tsolve();\n\t//system(\"pause\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["implementation", "sortings"], "dificulty": "1500", "interactive": false}