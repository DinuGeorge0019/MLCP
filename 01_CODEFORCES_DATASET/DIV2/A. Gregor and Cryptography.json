{
    "link": "https://codeforces.com//contest/1549/problem/A",
    "problemId": "1062374",
    "problem_idx": "A",
    "shortId": "1549A",
    "contest_number": "1549",
    "problem_submissions": {
        "F2": [
            124954760
        ],
        "B": [
            124947565,
            124545808,
            124541593,
            124946530,
            124553166,
            124545711,
            124536914,
            124556540,
            124566832,
            124527986,
            124941325,
            124545594,
            124575237,
            124552639,
            124521339,
            124527240,
            124534396,
            124536389,
            124529098,
            124547548,
            124525326,
            124539590,
            124546541
        ],
        "A": [
            124947501,
            124518305,
            124519670,
            124946570,
            124520785,
            124519203,
            124517993,
            124517559,
            124518317,
            124518952,
            124941237,
            124534955,
            124569653,
            124519648,
            124517299,
            124518094,
            124521899,
            124520868,
            124518074,
            124519228,
            124517443,
            124519076,
            124518992
        ],
        "F1": [
            124584680,
            124595832,
            124599734,
            124593371,
            124597616,
            124593738,
            124591194,
            124592802,
            124602219,
            124602384,
            124588472,
            124753532,
            124592653,
            124603568,
            124595865
        ],
        "E": [
            124572687,
            124578681,
            124586160,
            124580564,
            124586278,
            124587026,
            124603080,
            124600315,
            124577736,
            124595081,
            124580521,
            124597748,
            124594829,
            124597255,
            124685628,
            124601974
        ],
        "D": [
            124558908,
            124554190,
            124550650,
            124565038,
            124571505,
            124565266,
            124557657,
            124634855,
            124586699,
            124566420,
            124566608,
            124571026,
            124544812,
            124558707,
            124568055,
            124617780,
            124551649,
            124555888,
            124569746,
            124549100,
            124571724,
            124554851
        ],
        "C": [
            124534727,
            124537090,
            124536290,
            124552036,
            124551687,
            124549175,
            124538153,
            124547780,
            124552849,
            124553941,
            124540508,
            124527050,
            124538078,
            124556164,
            124573095,
            124538823,
            124554597,
            124536966,
            124553733,
            124540516
        ]
    },
    "name": "A. Gregor and Cryptography",
    "statement": "Gregor is learning about RSA cryptography, and although he doesn’t\r\nunderstand how RSA works, he is now fascinated with prime numbers and\r\nfactoring them.Gregor’s favorite number is P. Gregor wants to find two\r\nof P. Formally, Gregor is looking for two integers a and b which satisfy\r\nboth of the following properties. P\r\nbmod a = P\r\nbmod b, where x\r\nbmod y denotes the remainder when x is divided by y, and 2\r\nle a < b\r\nle P. Help Gregor find two bases of his favorite prime number!\r\n",
    "solutions": [
        "// Problem: A. Gregor and Cryptography\n// Contest: Codeforces - Codeforces Round #736 (Div. 2)\n// URL: https://codeforces.com/contest/1549/problem/A\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define chkmx(a,b) ((a)=max((a),(b)))\n#define chkmn(a,b) ((a)=min((a),(b)))\nusing namespace std;\ntemplate<typename T>\ninline void read(T &x){x=0;char c=getchar();bool f=false;for(;!isdigit(c);c=getchar())f|=c=='-';for(;isdigit(c);c=getchar())x=x*10+c-'0';if(f)x=-x;}\ntemplate<typename T ,typename ...Arg>inline void read(T &x,Arg &...args){read(x);read(args...);}\ntemplate<typename T>inline void write(T x){if(x<0)putchar('-'),x=-x;if(x>=10)write(x/10);putchar(x%10+'0');}\n//#define int long long\ntypedef long long ll;\nint t,p;\nsigned main(){\n\tread(t);\n\twhile(t--){\n\t\tread(p);\n\t\twrite(2);putchar(' ');\n\t\twrite(p-1);putchar('\\n');\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Gregor and Cryptography.json",
    "editorial_link": "https://codeforces.com//blog/entry/93586",
    "editorial": "SolutionSince and is also a prime number, we know that is an even\r\ncomposite number. A even composite number is guaranteed to have at least\r\n2 unique divisors greater than 1. Let two of these divisors be and . It\r\nis guaranteed that , and thus this selection is valid.For example, we\r\ncan simply pick and , and we will get a correct solution.The time\r\ncomplexity is .\r\n",
    "hint": [
        "Hint 1 Fix into a convenient constant."
    ]
}