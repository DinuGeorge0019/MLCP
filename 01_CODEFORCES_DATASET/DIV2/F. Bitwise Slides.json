{
    "link": "https://codeforces.com//contest/2067/problem/F",
    "problemId": "3199300",
    "problem_idx": "F",
    "shortId": "2067F",
    "contest_number": "2067",
    "problem_submissions": {
        "F": [
            305685907,
            305692347,
            305698935,
            305692774,
            305676497,
            305698856,
            306077498,
            305705678,
            305756151,
            305704889
        ],
        "E": [
            305658599,
            305672236,
            305683533,
            305683773,
            305656801,
            305645614,
            305696470,
            305667416,
            305664383,
            305673487,
            305670822,
            305677487,
            305670853,
            305673781,
            305671527,
            305669540,
            305677992,
            305669569
        ],
        "D": [
            305649366,
            305681166,
            305653626,
            305674453,
            305643643,
            305729660,
            305688166,
            305650701,
            305653886,
            305650207,
            305654910,
            305651908,
            305655288,
            305746455,
            305655141,
            305660113,
            305659896,
            305656329,
            305714910,
            305658443
        ],
        "C": [
            305636369,
            305648878,
            305666557,
            305665235,
            305625887,
            305647363,
            305654112,
            305631231,
            305632643,
            305629967,
            305634943,
            305636497,
            305638128,
            305637135,
            305643511,
            305643488,
            305640674,
            305635570
        ],
        "B": [
            305619994,
            305628659,
            305625583,
            305654171,
            305618751,
            305619632,
            305656230,
            305622837,
            305619493,
            305623632,
            305626730,
            305624964,
            305625007,
            305622467,
            305622926,
            305630860,
            305620471,
            305624035
        ],
        "A": [
            305614513,
            305615491,
            305614195,
            305613169,
            305612940,
            305612785,
            305651426,
            305615731,
            305613408,
            305616051,
            305615564,
            305614161,
            305613236,
            305614353,
            305613295,
            305614069,
            305612838,
            305613240
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139415?locale=en",
    "editorial": "Let us denote the array of prefix s.Notice that after the -th action, it\r\nis always true that , regardless of which actions were chosen.With this\r\nknowledge, we can say that after the -th action, the condition \"the\r\nnumbers are not pairwise distinct\" is equivalent to the condition \"at\r\nleast one of equals .\" This is because if there is a pair of equal\r\nnumbers among , their equals , which means the third number must equal\r\n.Thus, all possible valid states after the -th action look like: for\r\nsome .After this observation, we can try to write a dynamic programming\r\nsolution: the number of ways to reach one of the states of the form\r\nafter the -th action.At first glance, this dynamic programming approach\r\nseems to take an unreasonable amount of time and memory. However, we\r\nwill still outline its base case and recurrence.Base case: .Recurrence:\r\nsuppose we want to recalculate using . From which state can we arrive at\r\nif the last move involved XORing one of the variables with ? There are\r\nthree possible cases: , , .The number of ways to reach the state is\r\nactually equal to , since .What about the case ? For the state to be\r\nvalid from the previous move, two of these numbers must be equal, and\r\nthe third must equal .However, we know that , since . Therefore, either\r\n(which means ), or .If , then the value of is also equal to , because\r\nthe state can be reached from one of the states , , , and the number of\r\nways to reach one of these states after the -th move is literally\r\ndefined as .For : . There are a total of 3 ways to arrive from , and 2\r\nways from the states , , .In summary, the only for which is .Therefore,\r\nunexpectedly, we do not need to recalculate the entire array , but only\r\none of its values. And of course, since the elements of the array are\r\nquite large, we will store this in a regular map.map<int, int> dp;dp[0]\r\n= 1;for i in 1..n: dp[pref[i-1]] = (3 * dp[pref[i-1]] + 2 * dp[pref[i]])\r\n",
    "name": "F. Bitwise Slides",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n. Also, you are given three variables P,Q,R, initially equal\r\nto zero.You need to process all the numbers a_1, a_2,\r\nldots, a_n, . When processing the next a_i, you must perform one of the\r\nthree actions of your choice: P := P\r\noplus a_i Q := Q\r\noplus a_i R := R\r\noplus a_i\r\noplus denotes the bitwise XOR operation. When performing actions, you\r\nmust follow the : it is necessary that after each action, all three\r\nnumbers P,Q,R are pairwise distinct.There are a total of 3^n ways to\r\nperform all n actions. How many of them do not violate the ? Since the\r\nanswer can be quite large, find it modulo 10^9 + 7.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Bitwise Slides.json",
    "hint": []
}