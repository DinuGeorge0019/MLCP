{
    "link": "https://codeforces.com//contest/1934/problem/B",
    "problemId": "2505360",
    "problem_idx": "B",
    "shortId": "1934B",
    "contest_number": "1934",
    "problem_submissions": {
        "D2": [
            249138861,
            249138286,
            249148347,
            249142453,
            249157574,
            249154795,
            249156400,
            249152916,
            249153265,
            249152468,
            249159235,
            249151373,
            249157739,
            249158790,
            249158719,
            249157715,
            249151531,
            249154568
        ],
        "D1": [
            249125699,
            249128677,
            249134651,
            249133932,
            249131438,
            249132804,
            249141726,
            249142358,
            249133864,
            249137039,
            249209635,
            249137420,
            249137703,
            249134521,
            249138551,
            249144781,
            249136421,
            249139126,
            249137860
        ],
        "C": [
            249115447,
            249119119,
            249121601,
            249125691,
            249121785,
            249119998,
            249118653,
            249123649,
            249122623,
            249127946,
            249126111,
            249128427,
            249128773,
            249122463,
            249117989,
            249122384,
            249127040,
            249126459
        ],
        "B": [
            249103913,
            249106551,
            249108288,
            249115212,
            249104799,
            249109733,
            249104490,
            249108744,
            249111760,
            249108303,
            249108953,
            249111319,
            249106725,
            249111924,
            249107412,
            249112945,
            249107802,
            249115127
        ],
        "A": [
            249100199,
            249101211,
            249103188,
            249100104,
            249099925,
            249108944,
            249100108,
            249104411,
            249104537,
            249100853,
            249102757,
            249099965,
            249100710,
            249100333,
            249102042,
            249101590,
            249101009,
            249100585
        ],
        "E": [
            249308601
        ]
    },
    "name": "B. Yet Another Coin Problem",
    "statement": "You have 5 different types of coins, each with a value equal to one of\r\nthe first 5 triangular numbers: 1, 3, 6, 10, and 15. These coin types\r\nare available in abundance. Your goal is to find the minimum number of\r\nthese coins required such that their total value sums up to exactly n.We\r\ncan show that the answer always exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    IOS;\n\n    vi dp(100000 + 10, 1e18); dp[0] = 0;\n    for(int i = 1; i <= 100000; i++){\n        for(int j : {1, 3, 6, 10, 15}){\n            if(i < j) continue;\n            dp[i] = min(dp[i], dp[i - j] + 1);\n        }\n    }\n\n    int T; cin >> T;\n    while(T--){\n        int N; cin >> N;\n        int ans = 0;\n        if(N >= 1e5){\n            int chk = (N - (int)1e5) / 15 + 10;\n            ans = dp[N - chk * 15] + chk;\n        }\n        else ans = dp[N];\n        cout << ans << endl;\n    }\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Yet Another Coin Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/126423",
    "editorial": "SolutionFact: You will never need more than ones, threes, sixes and\r\ntens.Reason: For : Suppose if you used > ones, then you could have used\r\none and ones. For : Suppose if you used > threes, then you could have\r\nused one and threes.For : Suppose if you used > sixes, then you could\r\nhave used two âs and sixes.For : Suppose if you used > tens, then you\r\ncould have used two âs and tens.now since bound on their count is less,\r\nwe can bruteforce on these count.\r\n",
    "hint": [
        "Hint At max how many , , , are required?",
        "Hint When will the greedy logic of choosing the higher-valued coin first work?"
    ]
}