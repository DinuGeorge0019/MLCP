{"link": "https://codeforces.com//contest/1384/problem/B2", "problemId": "681335", "problem_idx": "B2", "shortId": "1384B2", "contest_number": "1384", "problem_submissions": {"D": [87920747, 87898550, 87899799, 87904419, 87905595, 87900804, 87885567, 87904258, 87914433, 87915245, 87916166, 87919718, 87915464, 87919225, 87915479, 87921886, 87920890, 87922578, 87921368, 87920046], "F": [87913933], "B1": [87894001, 87885002, 87901113, 87888080, 87892689, 87910843, 87920006, 87917285, 87898927, 87884228, 87892152, 87886631, 87893715, 87908879, 87900239, 87907063, 87892421, 87898971, 87917937, 87897854], "B2": [87893926, 87884835, 87901230, 87887888, 87903446, 87910900, 87919888, 87917176, 87906127, 87884007, 87892285, 87886523, 87893549, 87908713, 87900384, 87907601, 87892328, 87898841, 87917847, 87897690], "C": [87885628, 87894004, 87882731, 87893702, 87872158, 87889498, 87895035, 87884029, 87889346, 87904942, 87896617, 87893149, 87904403, 87889926, 87909570, 87895224, 87907611, 87906036, 87884342, 87911186], "A": [87871418, 87873285, 87873996, 87872062, 87871221, 87872543, 87898590, 87873955, 87871869, 87871615, 87875627, 87876144, 87877768, 87875116, 87878214, 87873342, 87873019, 87876431, 87871586, 87881479]}, "name": "B2. Koa and the Beach  Hard Version ", "statement": "Koa the Koala is at the beach!The beach consists (from left to right) of\r\na shore, n+1 meters of sea and an island at n+1 meters from the\r\nshore.She measured the depth of the sea at 1, 2,\r\ndots, n meters from the shore and saved them in array d. d_i denotes the\r\ndepth of the sea at i meters from the shore for 1\r\nle i\r\nle n.Like any beach this one has tide, the intensity of the tide is\r\nmeasured by parameter k and affects all depths in the following way: For\r\na total of k seconds, each second, tide all depths by 1. Then, for a\r\ntotal of k seconds, each second, tide all depths by 1. This process\r\nrepeats again and again (ie. depths increase for k seconds then decrease\r\nfor k seconds and so on ...).Formally, let\u2019s define 0-indexed array p =\r\n[0, 1, 2,\r\nldots, k - 2, k - 1, k, k - 1, k - 2,\r\nldots, 2, 1] of length 2k. At time t (0\r\nle t) depth at i meters from the shore equals d_i + p[t\r\nbmod 2k] (t\r\nbmod 2k denotes the remainder of the division of t by 2k). Note that the\r\nchanges occur after each second, see the notes for better understanding.\r\nAt time t=0 Koa is standing at the shore and wants to get to the island.\r\nSuppose that at some time t (0\r\nle t) she is at x (0\r\nle x\r\nle n) meters from the shore: In one second Koa can swim 1 meter further\r\nfrom the shore (x changes to x+1) or not swim at all (x stays the same),\r\nin both cases t changes to t+1. As Koa is a bad swimmer, the depth of\r\nthe sea at the point where she is can\u2019t exceed l at integer points of\r\ntime (or she will drown). More formally, if Koa is at x (1\r\nle x\r\nle n) meters from the shore at the moment t (for some integer t\r\nge 0), the depth of the sea at this point d_x + p[t\r\nbmod 2k] can\u2019t exceed l. In other words, d_x + p[t\r\nbmod 2k]\r\nle l must hold always. Once Koa reaches the island at n+1 meters from\r\nthe shore, she stops and can rest.Note that (ie. she can\u2019t drown while\r\nswimming). Note that and (they are solid ground and she won\u2019t drown\r\nthere). Koa wants to know whether she can go from the shore to the\r\nisland. Help her!\r\n", "solutions": ["#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n#define m_k make_pair\nusing namespace std;\nconst int N=3*1e5+100;\nint t,n,k,l,a[N],b[N],st;\nsigned main()\n{\n\tscanf(\"%d\",&t);\n\twhile (t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&k,&l);\n\t\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\t\tfor (int i=1;i<=n;i++) b[i]=min(k,l-a[i]);\n\t\tbool bl=1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (b[i]<0)\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bl)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tst=b[1];\n\t\tint add;\n\t\tif (st==0) add=1;\n\t\telse add=-1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (st>b[i])\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i==n) break;\n\t\t\tif (b[i]==k) st=b[i+1]+1,add=-1;\n\t\t\telse if (add==-1 && st-1>b[i+1]) st=b[i+1]+1;\n\t\t\tst+=add;\n\t\t\tif (st==0) add=1;\n\t\t\tif (st==k) add=-1;\n\t\t}\n\t\tif (bl) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy", "implementation"], "dificulty": "2200", "interactive": false}