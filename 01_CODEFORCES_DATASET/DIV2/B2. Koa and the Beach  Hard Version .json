{
    "link": "https://codeforces.com//contest/1384/problem/B2",
    "problemId": "681335",
    "problem_idx": "B2",
    "shortId": "1384B2",
    "contest_number": "1384",
    "problem_submissions": {
        "D": [
            87920747,
            87898550,
            87899799,
            87904419,
            87905595,
            87900804,
            87885567,
            87904258,
            87914433,
            87915245,
            87916166,
            87919718,
            87915464,
            87919225,
            87915479,
            87921886,
            87920890,
            87922578,
            87921368,
            87920046
        ],
        "F": [
            87913933
        ],
        "B1": [
            87894001,
            87885002,
            87901113,
            87888080,
            87892689,
            87910843,
            87920006,
            87917285,
            87898927,
            87884228,
            87892152,
            87886631,
            87893715,
            87908879,
            87900239,
            87907063,
            87892421,
            87898971,
            87917937,
            87897854
        ],
        "B2": [
            87893926,
            87884835,
            87901230,
            87887888,
            87903446,
            87910900,
            87919888,
            87917176,
            87906127,
            87884007,
            87892285,
            87886523,
            87893549,
            87908713,
            87900384,
            87907601,
            87892328,
            87898841,
            87917847,
            87897690
        ],
        "C": [
            87885628,
            87894004,
            87882731,
            87893702,
            87872158,
            87889498,
            87895035,
            87884029,
            87889346,
            87904942,
            87896617,
            87893149,
            87904403,
            87889926,
            87909570,
            87895224,
            87907611,
            87906036,
            87884342,
            87911186
        ],
        "A": [
            87871418,
            87873285,
            87873996,
            87872062,
            87871221,
            87872543,
            87898590,
            87873955,
            87871869,
            87871615,
            87875627,
            87876144,
            87877768,
            87875116,
            87878214,
            87873342,
            87873019,
            87876431,
            87871586,
            87881479
        ]
    },
    "name": "B2. Koa and the Beach  Hard Version ",
    "statement": "Koa the Koala is at the beach!The beach consists (from left to right) of\r\na shore, n+1 meters of sea and an island at n+1 meters from the\r\nshore.She measured the depth of the sea at 1, 2,\r\ndots, n meters from the shore and saved them in array d. d_i denotes the\r\ndepth of the sea at i meters from the shore for 1\r\nle i\r\nle n.Like any beach this one has tide, the intensity of the tide is\r\nmeasured by parameter k and affects all depths in the following way: For\r\na total of k seconds, each second, tide all depths by 1. Then, for a\r\ntotal of k seconds, each second, tide all depths by 1. This process\r\nrepeats again and again (ie. depths increase for k seconds then decrease\r\nfor k seconds and so on ...).Formally, let’s define 0-indexed array p =\r\n[0, 1, 2,\r\nldots, k - 2, k - 1, k, k - 1, k - 2,\r\nldots, 2, 1] of length 2k. At time t (0\r\nle t) depth at i meters from the shore equals d_i + p[t\r\nbmod 2k] (t\r\nbmod 2k denotes the remainder of the division of t by 2k). Note that the\r\nchanges occur after each second, see the notes for better understanding.\r\nAt time t=0 Koa is standing at the shore and wants to get to the island.\r\nSuppose that at some time t (0\r\nle t) she is at x (0\r\nle x\r\nle n) meters from the shore: In one second Koa can swim 1 meter further\r\nfrom the shore (x changes to x+1) or not swim at all (x stays the same),\r\nin both cases t changes to t+1. As Koa is a bad swimmer, the depth of\r\nthe sea at the point where she is can’t exceed l at integer points of\r\ntime (or she will drown). More formally, if Koa is at x (1\r\nle x\r\nle n) meters from the shore at the moment t (for some integer t\r\nge 0), the depth of the sea at this point d_x + p[t\r\nbmod 2k] can’t exceed l. In other words, d_x + p[t\r\nbmod 2k]\r\nle l must hold always. Once Koa reaches the island at n+1 meters from\r\nthe shore, she stops and can rest.Note that (ie. she can’t drown while\r\nswimming). Note that and (they are solid ground and she won’t drown\r\nthere). Koa wants to know whether she can go from the shore to the\r\nisland. Help her!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n#define m_k make_pair\nusing namespace std;\nconst int N=3*1e5+100;\nint t,n,k,l,a[N],b[N],st;\nsigned main()\n{\n\tscanf(\"%d\",&t);\n\twhile (t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&k,&l);\n\t\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\t\tfor (int i=1;i<=n;i++) b[i]=min(k,l-a[i]);\n\t\tbool bl=1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (b[i]<0)\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bl)\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tst=b[1];\n\t\tint add;\n\t\tif (st==0) add=1;\n\t\telse add=-1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (st>b[i])\n\t\t\t{\n\t\t\t\tbl=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i==n) break;\n\t\t\tif (b[i]==k) st=b[i+1]+1,add=-1;\n\t\t\telse if (add==-1 && st-1>b[i+1]) st=b[i+1]+1;\n\t\t\tst+=add;\n\t\t\tif (st==0) add=1;\n\t\t\tif (st==k) add=-1;\n\t\t}\n\t\tif (bl) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B2. Koa and the Beach  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/80562",
    "editorial": "Letâs define positions such that () and as safe positions, also\r\npositions and are safe too (ie. the shore and the island respectively).\r\nRemaining positions are unsafe.Koa can wait indefinitely on safe\r\npositions without drowning, so she can reach the island (ie. position )\r\nshe can reach each safe position from the previous one.Suppose Koa is at\r\nsome safe position and wants to reach the next safe position ():A\r\nsolution strategy for Koa is the following: If Koa is at an unsafe\r\nposition at time , she must swim to as soon as she can, that is, at the\r\nfirst moment of time such that (to not drown). If Koa is at a safe\r\nposition at time , she must wait to some moment of time such that tide\r\nis exactly at units. After that she must follow the unsafe positions\r\nstrategy until the next safe position. So a way to go from to would be,\r\napply point on , and apply point to reach each position such that\r\n().This works because: If there exists some position with greater than\r\nshe would drown with any tide so letâs assume that all positions are\r\nless or equal to . Suppose Koa drowns at some position , she can leave\r\nwith some value of tide because and as long as the tide is decreasing\r\nwhether she chooses to wait or not she would be safe. So she must have\r\ndrown with the tide increasing. If she leaves with other tide (different\r\nfrom ): suppose she would be able to reach position , then the tide will\r\nhave increased and it will be higher and therefore she would drown too,\r\nthis is true because the tide never can be and start decreasing again\r\nbetween and because these positions are unsafe ones. Time complexity:\r\nper test case\r\n",
    "hint": []
}