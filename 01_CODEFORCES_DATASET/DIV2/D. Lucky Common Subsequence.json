{
    "link": "https://codeforces.com//contest/347/problem/D",
    "problemId": "3511",
    "problem_idx": "D",
    "shortId": "347D",
    "contest_number": "347",
    "problem_submissions": {
        "C": [
            4518768,
            4513742,
            4517653,
            4518839,
            4520636,
            4513589,
            4515480,
            4513320,
            4513590,
            4521190,
            4514183,
            4515546,
            4513940,
            4516018,
            4514431,
            4512340,
            4514717,
            4516799,
            4519674
        ],
        "D": [
            4515778,
            4520517,
            4519885,
            4520973,
            4523724,
            4519031,
            4523601
        ],
        "B": [
            4512188,
            4512255,
            4513932,
            4514468,
            4511829,
            4511441,
            4512094,
            4512109,
            4512127,
            4512494,
            4511760,
            4512987,
            4512079,
            4512011,
            4512852,
            4513990,
            4514484,
            4513535,
            4513631,
            4514973
        ],
        "A": [
            4510977,
            4511197,
            4511967,
            4512169,
            4511066,
            4511024,
            4511167,
            4511360,
            4511075,
            4511574,
            4515121,
            4511042,
            4511261,
            4512777,
            4514480,
            4513698,
            4511919,
            4511676,
            4512313
        ],
        "E": [
            4519822,
            4520189,
            4521340,
            4522190
        ]
    },
    "name": "D. Lucky Common Subsequence",
    "statement": "In mathematics, a is a sequence that can be derived from another\r\nsequence by deleting some elements without changing the order of the\r\nremaining elements. For example, the sequence is a subsequence of . A of\r\na string is a continuous subsequence of the string. For example, is a\r\nsubstring of .You are given two strings , and another string called .\r\nYour task is to find the longest common subsequence of and , such that\r\nit doesnâ€™t contain as a substring.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cmath>\n\nusing namespace std;\n\n#define DBG(z) cerr << #z << \": \" << (z) << endl\n#define NEWL cerr << endl\n#define passert(x, m) {if (!(x)) {cerr << m << \"  ::  \";} assert(x);}\n#define err(s) cerr << \"\u001b[92m\" << s << \"\u001b[0m\" << endl\n#define LINE cerr << \"DEBUG LINE: \" << __LINE__ << endl\n\n#define IT(v) __typeof((v).begin())\n#define mem(f, a) memset(f, a, sizeof(f))\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define for_each(it, v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define next_int() ({int __t; scanf(\"%d\", &__t); __t;})\n\nconst int N = 101, INF = 10000;\n\nint fail[N], m, n1, n2;\nchar y[N], s1[N], s2[N];\nint dp[N][N][N], next[N][N][N];\n\nint get(char a, int l) {\n    while (l > 0 and a != y[m - 1 - l])\n        l = fail[l - 1];\n    if (a == y[m - 1 - l])\n        ++l;\n    return l;\n}\n\nvoid precomp_fail() {\n    int l = 0;\n    fail[l] = 0;\n    for (int i = 1; i < m; ++i)\n        fail[i] = l = get(y[m - 1 - i], l);\n}\n\n\nint f(int i, int j, int l) {\n    if (l == m)\n        return -INF;\n    if (i == 0 || j == 0)\n        return 0;\n    int &ret = dp[i][j][l];\n    if (ret >= -INF)\n        return ret;\n    ret = -INF;\n    int r1 = f(i - 1, j, l);\n    if (r1 > ret) {\n        next[i][j][l] = 1;\n        ret = r1;\n    }\n    int r2 = f(i, j - 1, l);\n    if (r2 > ret) {\n        next[i][j][l] = 2;\n        ret = r2;\n    }\n    if (s1[i - 1] == s2[j - 1]) {\n        int r3 = f(i - 1, j - 1, get(s1[i - 1], l)) + 1;\n        if (r3 > ret) {\n            next[i][j][l] = 3;\n            ret = r3;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%s\\n%s\\n%s\", s1, s2, y);\n    m = strlen(y), n1 = strlen(s1), n2 = strlen(s2);\n    precomp_fail();\n    for (int i = 0; i <= n1; ++i) \n        for (int j = 0; j <= n2; ++j)\n            for (int k = 0; k <= m; ++k)\n                dp[i][j][k] = -(INF + 1);\n    int len = f(n1, n2, 0);\n    if (len == 0)\n        puts(\"0\");\n    else {\n        int i = n1, j = n2, l = 0;\n        vector <char> ans;\n        while (i > 0 && j > 0) {\n            assert(next[i][j][l] != 0);\n            switch (next[i][j][l]) {\n                case 1: --i; break;\n                case 2: --j; break;\n                case 3: --i, --j, l = get(s1[i], l), ans.push_back(s1[i]); break;\n            }\n        }\n        printf(\"%s\\n\", string(rall(ans)).c_str());\n    }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Lucky Common Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/8903",
    "editorial": "Brief description:\nYou have been given two strings s1, s2 and virus, and you have to find the longest common subsequence of s1 and s2 without virus as a substring.\n\nAnalysis:\nThis is a rather classical problem, let's say if there is no virus, then it is the classical **LCS ** problem. You can solve this by a O(n2) dynamic programing.\n\nWhen consider about the virus, we should add 1 more dimension on the state to trace the growth of the virus. It can be done by wheather Aho-Corasick automation, or KMP when there is only one virus in this case. The overall time complexity is O(n3).",
    "hint": []
}