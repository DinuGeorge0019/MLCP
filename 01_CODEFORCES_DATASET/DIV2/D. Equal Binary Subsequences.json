{
    "link": "https://codeforces.com//contest/1736/problem/D",
    "problemId": "1577264",
    "problem_idx": "D",
    "shortId": "1736D",
    "contest_number": "1736",
    "problem_submissions": {
        "E": [
            175439543,
            175443144,
            175439009,
            175381843,
            175414723,
            175438942,
            175435995,
            175434845,
            177930000,
            177929986,
            175687203
        ],
        "D": [
            175408404,
            175400381,
            175399625,
            175411756,
            175427268,
            175403943,
            175421797,
            175410165,
            175420142,
            175417359,
            175431513,
            175416878,
            175409927,
            175413453,
            175413865,
            175431461,
            175406398,
            175441942
        ],
        "C2": [
            175404703,
            175417134,
            175428380,
            175419086,
            175400852,
            175397797,
            175413006,
            175423651,
            175672172,
            175406068,
            175417021,
            175434137,
            175436814,
            175434363,
            175440989,
            175420969,
            175442300,
            175419890
        ],
        "C1": [
            175375043,
            175383497,
            175388568,
            175387787,
            175381377,
            175379153,
            175385345,
            175386512,
            175389788,
            175382936,
            175394942,
            175375823,
            175386767,
            175379821,
            175383900,
            175387961,
            175384170,
            175389585,
            175383234,
            175389212
        ],
        "B": [
            175370992,
            175375317,
            175373666,
            175375194,
            175374090,
            175375063,
            175373551,
            175376722,
            175374704,
            175379058,
            175374978,
            175547536,
            175411882,
            175380763,
            175374446,
            175376075,
            175375873,
            175378999,
            175381698,
            175373819,
            175381759
        ],
        "A": [
            175370153,
            175370410,
            175370431,
            175371396,
            175370206,
            175371113,
            175370213,
            175370596,
            175371197,
            175370850,
            175370966,
            175408706,
            175371169,
            175370108,
            175370575,
            175370376,
            175370794,
            175373232,
            175370222,
            175370303
        ]
    },
    "name": "D. Equal Binary Subsequences",
    "statement": "Everool has a binary string s of length 2n. Note that a binary string is\r\na string consisting of only characters 0 and 1. He wants to partition s\r\ninto two subsequences. He needs your help to do it.You are allowed to do\r\nthe following operation once. You can choose any subsequence () of s and\r\nrotate it right by one position. In other words, you can select a\r\nsequence of indices b_1, b_2,\r\nldots, b_m, where 1\r\nle b_1 < b_2 <\r\nldots < b_m\r\nle 2n. After that you set s_{b_1} := s_{b_m}, s_{b_2} := s_{b_1},\r\nldots, s_{b_m} := s_{b_{m-1}}.Can you partition s into two subsequences\r\nafter performing the allowed operation once?A partition of s into two\r\ndisjoint equal subsequences s^p and s^q is two arrays of indices p_1,\r\np_2,\r\nldots, p_n and q_1, q_2,\r\nldots, q_n, such that each integer from 1 to 2n is encountered in either\r\np or q exactly once, s^p = s_{p_1} s_{p_2}\r\nldots s_{p_n}, s^q = s_{q_1} s_{q_2}\r\nldots s_{q_n}, and s^p = s^q.If it is not possible to partition after\r\nperforming any kind of operation, report -1. If it is possible to do the\r\noperation and partition s into two disjoint subsequences s^p and s^q,\r\nsuch that s^p = s^q, print elements of b and indices of s^p, i. e. the\r\nvalues p_1, p_2,\r\nldots, p_n.\r\n",
    "solutions": [
        "//\u8fd9\u56de\u53ea\u82b1\u4e86114514min\u5c31\u6253\u5b8c\u4e86\u3002\n//\u771f\u597d\u3002\u8bb0\u5f97\u591a\u624b\u9020\u51e0\u7ec4\u3002ACM\u62cd\u4ec0\u4e48\u62cd\u3002 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n; n<<=1;\n\t\tvector<int> a(n);\n\t\tvector cnt(2,0);\n\t\t{\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor (i=0; i<n; i++) ++cnt[a[i]=s[i]-'0'];\n\t\t}\n\t\tif (cnt[0]&1) { cout<<\"-1\\n\"; continue; }\n\t\tvector<int> pos;\n\t\tint cur=0;\n\t\tfor (i=0; i<n; i+=2) if (a[i]!=a[i+1]) pos.push_back((a[i+1]==cur)+i+1),cur^=1;\n\t\tcout<<pos.size()<<' '<<pos<<'\\n';\n\t\tfor (i=0; i<n; i+=2) cout<<i+1<<\" \\n\"[i==n-2];\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "geometry",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Equal Binary Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/107847",
    "editorial": "SolutionIt is easy to see that a necessary condition for a solution to\r\nexist is that the number of in should be even. It turns out that this\r\ncondition is sufficient too.Here is one valid construction:We make pairs\r\nof the form for .Assume we have pairs in which both elements are\r\ndifferent and pairs in which both elements are same.\r\ntextbf{Claim} should be even.\r\ntextbf{Proof} Assume that among the pairs in which both elements are\r\nsame, we have pairs in which both elements are . So number of in is . We\r\nknow that number of in is even, so for to be even, should also be\r\neven.Now we will select indices; exactly one index from each of the\r\npairs in which both elements are distinct. Take the index of from pair\r\nif is odd, else take the index of . Thus our selected characters = Now\r\non cyclically shifting the selected characters clockwise once, we can\r\nsee that elements at selected indices got flipped.Since, elements in\r\nthose pairs were distinct initially, and we flipped exactly one\r\ncharacter from each of those pairs, both elements of those pairs are\r\nsame now.Hence, in updated , .So, for , we can select characters of all\r\nodd indices.Finally we\u00e2\u0080\u0099ll have . Time complexity is .\r\n"
}