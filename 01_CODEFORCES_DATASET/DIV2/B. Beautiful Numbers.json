{
    "link": "https://codeforces.com//contest/1265/problem/B",
    "problemId": "486709",
    "problem_idx": "B",
    "shortId": "1265B",
    "contest_number": "1265",
    "problem_submissions": {
        "F": [
            66347509,
            66356863,
            66557730,
            66442620,
            66596419
        ],
        "D": [
            66340623,
            66367551,
            66338719,
            66334115,
            66337781,
            66335412,
            66337141,
            66346278,
            66339422,
            66338547,
            66341148,
            66339217,
            66340066,
            66341959,
            66331621,
            66342018,
            66346489,
            66340801,
            66342356,
            66342319,
            66343587
        ],
        "E": [
            66334163,
            66342621,
            66338591,
            66341637,
            66343875,
            66343996,
            66335345,
            66344209,
            66345114,
            66344975,
            66347923,
            66349901,
            66349558,
            66353633,
            66348910,
            66344231,
            66352728,
            66349177,
            66344898,
            66345749
        ],
        "C": [
            66327706,
            66330775,
            66334663,
            66328752,
            66329873,
            66333663,
            66331630,
            66332247,
            66329421,
            66334491,
            66334922,
            66330433,
            66331509,
            66336687,
            66333340,
            66334139,
            66330672,
            66335469,
            66331275,
            66338262
        ],
        "B": [
            66327279,
            66324231,
            66324702,
            66323571,
            66323717,
            66325187,
            66324433,
            66325466,
            66331477,
            66327697,
            66323823,
            66325202,
            66325641,
            66327180,
            66324867,
            66325852,
            66324365,
            66328628,
            66324650,
            66332154
        ],
        "A": [
            66323436,
            66367023,
            66322763,
            66325795,
            66322545,
            66322720,
            66322849,
            66322611,
            66322846,
            66324460,
            66323395,
            66326356,
            66322526,
            66323577,
            66323841,
            66322634,
            66323094,
            66322910,
            66325754,
            66323461,
            66323023
        ]
    },
    "name": "B. Beautiful Numbers",
    "statement": "You are given a permutation p=[p_1, p_2,\r\nldots, p_n] of integers from 1 to n. Letâ€™s call the number m (1\r\nle m\r\nle n) , if there exists two indices l, r (1\r\nle l\r\nle r\r\nle n), such that the numbers [p_l, p_{l+1},\r\nldots, p_r] is a permutation of numbers 1, 2,\r\nldots, m.For example, let p = [4, 5, 1, 3, 2, 6]. In this case, the\r\nnumbers 1, 3, 5, 6 are beautiful and 2, 4 are not. It is because: if l =\r\n3 and r = 3 we will have a permutation [1] for m = 1; if l = 3 and r = 5\r\nwe will have a permutation [1, 3, 2] for m = 3; if l = 1 and r = 5 we\r\nwill have a permutation [4, 5, 1, 3, 2] for m = 5; if l = 1 and r = 6 we\r\nwill have a permutation [4, 5, 1, 3, 2, 6] for m = 6; it is impossible\r\nto take some l and r, such that [p_l, p_{l+1},\r\nldots, p_r] is a permutation of numbers 1, 2,\r\nldots, m for m = 2 and for m = 4. You are given a permutation p=[p_1,\r\np_2,\r\nldots, p_n]. For all m (1\r\nle m\r\nle n) determine if it is a beautiful number or not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=2e5+5;\nint n,a[maxn],pos[maxn],ans[maxn];\nint main(){\n\tint cas=read();\n\twhile(cas--){\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i]=read();\n\t\t\tpos[a[i]]=i;\n\t\t\tans[i]=0;\n\t\t}\n\t\tint l=n+1,r=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tl=min(l,pos[i]);\n\t\t\tr=max(r,pos[i]);\n\t\t\tif(r-l+1==i)ans[i]=1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)cout<<ans[i];cout<<'\\n';\n\t}\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Beautiful Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/71995",
    "editorial": "A number is beautiful if and only if all numbers in range occupies\r\nconsecutive positions in the given sequence . This is equivalent to\r\nwhere are the largest, smallest position of in sequence respectively.We\r\nwill consider in increasing order, that its . For each we will find a\r\nway to update so we can tell either is a beautiful number or not in\r\nconstant time. Denote is the position of number in the sequence . When ,\r\nwe have . When , the value of can be updated by the following formula:\r\nSo we can update them in constant time. The correctness of above formula\r\nis based on the definition of .Total time comlexity:\r\n",
    "hint": []
}