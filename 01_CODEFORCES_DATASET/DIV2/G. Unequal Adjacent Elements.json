{
    "link": "https://codeforces.com//contest/1762/problem/G",
    "problemId": "1695276",
    "problem_idx": "G",
    "shortId": "1762G",
    "contest_number": "1762",
    "problem_submissions": {
        "F": [
            185360973,
            185364441,
            185372202,
            185395910,
            185621065,
            185354232,
            185332491,
            185348264,
            185360759,
            197448951,
            197448921
        ],
        "E": [
            185344507,
            185353525,
            185341937,
            185339289,
            185344504,
            185352316,
            185360035,
            185362208,
            185365484,
            185404755,
            185370016,
            185351528,
            185364233,
            185367555,
            191848003,
            185329145
        ],
        "D": [
            185337625,
            185342301,
            185324406,
            185313736,
            185320476,
            185336684,
            185335575,
            185333725,
            185325437,
            185329719,
            185355407,
            185334757,
            185358794,
            185354685,
            185353510,
            203219751,
            203219727,
            185328017,
            185332700,
            185327767
        ],
        "C": [
            185322060,
            185321446,
            185314988,
            185324570,
            185312857,
            185315091,
            185320564,
            185320295,
            185330972,
            185319388,
            185342558,
            185326201,
            185316184,
            185309915,
            185362472,
            185315926,
            185312437,
            185310609,
            185320776
        ],
        "B": [
            185304175,
            185312988,
            185302843,
            185317620,
            185309312,
            185304849,
            185311399,
            185308703,
            185304961,
            185310615,
            185338037,
            185310014,
            185310646,
            185303730,
            185343806,
            185303744,
            185303718,
            185304581,
            185309640
        ],
        "A": [
            185300504,
            185304250,
            185300255,
            185302050,
            185306620,
            185300445,
            185302307,
            185307731,
            185300743,
            185301230,
            185335246,
            185301137,
            185300437,
            185300430,
            185322563,
            185300790,
            185300333,
            185302002,
            185301784
        ],
        "G": [
            185409628,
            185346613
        ]
    },
    "name": "G. Unequal Adjacent Elements",
    "statement": "You are given an array a consisting of n positive integers. Find any\r\npermutation p of [1,2,\r\ndots,n] such that: p_{i-2} < p_i for all i, where 3\r\nleq i\r\nleq n, and a_{p_{i-1}}\r\nneq a_{p_i} for all i, where 2\r\nleq i\r\nleq n. Or report that no such permutation exists.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=300005;\nint T,n,tot;\nint a[maxn],cnt[maxn],vis[maxn];\nvector< vector<int> >ans;\npriority_queue< pair<int,int> >q;\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d\",&n),ans.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcnt[i]=vis[i]=0;\n\t\twhile(!q.empty())\n\t\t\tq.pop();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(\"%d\",&a[i]),cnt[a[i]]++;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(cnt[i])\n\t\t\t\tq.push(make_pair(cnt[i],i));\n\t\tif(q.top().first>(n+1)/2){\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\ttot=0;\n\t\tfor(int i=1,j;i<=n;i++)\n\t\t\tif(vis[i]==0){\n\t\t\t\tif(tot+1==i)\n\t\t\t\t\tj=i+1,ans.push_back({});\n\t\t\t\twhile(!q.empty()&&q.top().first!=cnt[q.top().second])\n\t\t\t\t\tq.pop();\n\t\t\t\tif(q.top().first==(n-tot+1)/2)\n\t\t\t\t\tbreak;\n\t\t\t\twhile(j<=n&&(vis[j]||a[i]==a[j]))\n\t\t\t\t\tj++;\n\t\t\t\tvis[i]=vis[j]=1,ans.back().push_back(j),ans.back().push_back(i);\n\t\t\t\ttot+=2,cnt[a[i]]--,cnt[a[j]]--,q.push(make_pair(cnt[a[i]],a[i])),q.push(make_pair(cnt[a[j]],a[j]));\n\t\t\t}\n\t\tint col=q.top().second;\n\t\tvector<int>u,v;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(vis[i]==0)\n\t\t\t\t(a[i]==col? u:v).push_back(i);\n\t\tfor(int i=0;i<u.size();i++){\n\t\t\tans.back().push_back(u[i]);\n\t\t\tif(i<v.size())\n\t\t\t\tans.back().push_back(v[i]);\n\t\t}\n\t\tfor(int i=(int)ans.size()-2;i>=0;i--)\n\t\t\tif(a[ans[i].back()]==a[ans[i+1][0]])\n\t\t\t\tfor(int j=0;j<ans[i].size();j+=2)\n\t\t\t\t\tswap(ans[i][j],ans[i][j+1]);\n\t\tputs(\"YES\");\n\t\tfor(int i=0;i<ans.size();i++)\n\t\t\tfor(int j=0;j<ans[i].size();j++)\n\t\t\t\tprintf(\"%d \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Unequal Adjacent Elements.json",
    "editorial_link": "https://codeforces.com//blog/entry/110169",
    "editorial": "Let us continue from where we left off.\n\nSo our motivation is to break the original array into multiple beautiful subarrays and the elements in those subarrays, as mentioned before. Now for condition 1\n to be satisfied, we should not have two adjacent subarrays such that the elements at the end positions of both subarrays(after rearranging the elements) are the same.\n\nHere is one construction using which we can achieve our goal.\n\nSuppose l\n denotes the leftmost point of our concerned subarray.\n\nIf al?al+1\n, we move forward, as subarray a[l,l]\n is good.\n\nOtherwise, we keep moving towards the right till index r\n(here, r\n should be the smallest possible) such that the subarray a[l,r]\n is beautiful and al?ar+1\n. So it is easy to notice the following observations about the subarray a[l,r]\n\nlength of this subarray is odd\n\nal\n occurs exactly ?r?l+12?\n times in this subarray\n\nNow we can rearrange the elements of this subarray a[l,r]\n.\n\nDo note that the subarray a[1,r]\n satisfies both the conditions stated in the statement.\n\nSo our task is to make the subarray a[r+1,n]\n good now.\n\nWe can now update l=r+1\n and continue searching for the corresponding r\n and so on.\n\nNow it might be the case that we did not get a valid r\n for the last search.\n\nFrom here, I assume we did not get valid r\n for the last search. We could print the obtained permutation if we got it, as a\n would satisfy both conditions.\n\nAssume that we had started at pos=l\n and couldn't find r\n.\n\nSubarray a[1,pos?1]\n is already good.\n\nTo fix this issue, we will do a similar search that we did before.\n\nWe start from the back(from index n\n) and move towards left till index m\n such that\n\nm<pos\na[m,n]\n is beautiful\napos\n occurs exactly ?n?m+12?\n times in this subarray\napos?am?1\nNow we arrange elements of this subarray in the same fashion that we did before.\n\nAre we done?\n\nNo. First, we must prove that we will always get some m\n.\n\nLet us have function f(a,l,r,x)\n, which denotes the score of the subarray a[l,r]\n for the element x\n. f(a,l,r,x)=freqx?(r?l+1?freqx)\n, where freqx\n denotes the frequency of element x\n in the subarray a[l,r]\n\nIt is easy to note that f(a,pos,n,apos)>1\n\n(Hint \u0097\n Prove that f(a,pos,r,apos)?0\n for pos?r?n\n. Why?(If it does then a[pos,r?1]\n would be beautiful ))\n\nNow we start from the back and move towards the right to find m\n with n\n as our right endpoint of the concerned subarray.\n\nNote that f(a,1,n,apos)?1\n (Why? apos\n would have occurred at most ?n2?\n times in a\n)\n\nSo while moving from pos\n to 1\n we will indeed find a m\n such that f(a,m,n,apos)=1\n, and am?1?apos\n (assuming a0=?1\n)\n\nAre we done?\n\nNot still :p. We can observe that condition 1\n is satisfied, but sometimes condition 2\n would not be. For example, simulate the above approach on the array a=[1,1,2,3,3]\n.\n\nHow to fix this issue? It's pretty easy to fix this issue.\n\nHint\nYou can refer to the attached code for implementation details."
}