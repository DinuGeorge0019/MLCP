{
    "link": "https://codeforces.com//contest/546/problem/B",
    "problemId": "28216",
    "problem_idx": "B",
    "shortId": "546B",
    "contest_number": "546",
    "problem_submissions": {
        "B": [
            11232801,
            11217801,
            11208207,
            15820713,
            11208988,
            11208163,
            11214179,
            11208024,
            11209235,
            11209062,
            11213108,
            11222587,
            11239965,
            11217308,
            11219421,
            11209692,
            11207894,
            11206528,
            11223244,
            11207437
        ],
        "E": [
            11215556,
            11217224,
            11218687,
            15820839,
            11219998,
            11219690,
            11217920,
            11221959,
            11219074,
            11220044,
            11233270,
            11220684,
            11220215,
            11213115,
            11219305,
            11221891,
            11216762
        ],
        "D": [
            11212652,
            11212575,
            11214113,
            15820823,
            11215486,
            11214182,
            11210539,
            11224701,
            11215757,
            11216672,
            11219688,
            11216346,
            11219045,
            11223515,
            11214913,
            11225307,
            11215385,
            11211036,
            11216929,
            11224645
        ],
        "C": [
            11210837,
            11219636,
            11212924,
            15820760,
            11214060,
            11211479,
            11223248,
            11214103,
            11217677,
            11214503,
            11218679,
            11212971,
            11216434,
            11218455,
            11225176,
            11213620,
            11212347,
            11214814,
            11211103
        ],
        "A": [
            11204918,
            11205173,
            11205306,
            15820687,
            11205477,
            11205623,
            11214865,
            11205868,
            11206683,
            11224290,
            11206459,
            11205182,
            11205880,
            11207069,
            11206553,
            11204997,
            11204938,
            11207566,
            11205034
        ]
    },
    "name": "B. Soldier and Badges",
    "statement": "Colonel has badges. He wants to give one badge to every of his soldiers.\r\nEach badge has a , which shows how much it’s owner reached. Coolness\r\nfactor can be increased by one for the cost of one coin. For every pair\r\nof soldiers one of them should get a badge with strictly higher factor\r\nthan the second one. Exact values of their factors aren’t important,\r\nthey just need to have distinct factors. Colonel knows, which soldier is\r\nsupposed to get which badge initially, but there is a problem. Some of\r\nbadges may have the same factor of coolness. Help him and calculate how\r\nmuch money has to be paid for making all badges have different factors\r\nof coolness.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\nint main(){\n    int n;\n    int x[3005];\n    cin >> n;\n    rep2(i,n) cin >> x[i];\n    sort(x+1,x+n+1);\n    int prev = -1000,res = 0;\n    rep2(i,n){\n    \tif(prev+1 <= x[i]){\n    \t\tprev = x[i];\n    \t}\n    \telse{\n    \t\tres += prev+1-x[i];\n    \t\tprev++;\n    \t}\n    }\n    cout << res << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Soldier and Badges.json",
    "editorial_link": "https://codeforces.com//blog/entry/18034",
    "editorial": "Let's count the number of badges with coolness factor 1, 2 and so on. Then, let's look at the number of badges with value equal to 1. If it's greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n?-?2 (because maximum value of badge which we can achieve is 2n?-?1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.",
    "hint": []
}