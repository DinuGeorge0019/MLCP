{
    "link": "https://codeforces.com//contest/1253/problem/F",
    "problemId": "472863",
    "problem_idx": "F",
    "shortId": "1253F",
    "contest_number": "1253",
    "problem_submissions": {
        "F": [
            65199103,
            65190951,
            65202217,
            65200176,
            65205791,
            65198288,
            65206369,
            65202224,
            65204185,
            65198880,
            71343526,
            65209779,
            69242445
        ],
        "E": [
            65190374,
            65200198,
            65189404,
            65179572,
            65189474,
            65203687,
            65210511,
            65176917,
            65203722,
            65186844,
            65188534,
            65195069,
            65199233,
            65190702,
            65194167,
            65189184,
            65189079,
            65566785,
            65194999,
            65197237
        ],
        "D": [
            65185415,
            65178485,
            65180601,
            65183049,
            65178022,
            65187686,
            65195445,
            65178632,
            65179619,
            65180170,
            65183967,
            65181658,
            65188561,
            65181701,
            65182069,
            65187758,
            65183529,
            65182372,
            65181324
        ],
        "C": [
            65180957,
            65172664,
            65176866,
            65185425,
            65173509,
            65180180,
            65194567,
            65173458,
            65200178,
            65176131,
            65179441,
            65175878,
            65184305,
            65178007,
            65179468,
            65178975,
            65179727,
            65177898,
            65176250
        ],
        "B": [
            65175476,
            65202574,
            65174599,
            65188764,
            65185456,
            65176094,
            65186553,
            65183630,
            65196117,
            65172495,
            65173857,
            65173178,
            65174792,
            65174898,
            65174679,
            65176409,
            65176161,
            65176165,
            65172853
        ],
        "A": [
            65171088,
            65170116,
            65170656,
            65190482,
            65180567,
            65170231,
            65180099,
            65170284,
            65170843,
            65169770,
            65169894,
            65169914,
            65170943,
            65169881,
            65172675,
            65172008,
            65171211,
            65169945,
            65169720
        ]
    },
    "name": "F. Cheap Robot",
    "statement": "You\u2019re given a simple, undirected, connected, weighted graph with n\r\nnodes and m edges.Nodes are numbered from 1 to n. There are exactly k\r\n(recharge points), which are nodes 1, 2,\r\nldots, k.We consider a robot moving into this graph, with a battery of\r\ncapacity c, not fixed by the constructor yet. At any time, the battery\r\ncontains an integer amount x of energy between 0 and c\r\ninclusive.Traversing an edge of weight w_i is possible only if x\r\nge w_i, and costs w_i energy points (x := x - w_i).Moreover, when the\r\nrobot reaches a central, its battery is entirely recharged (x :=\r\nc).You\u2019re given q missions, the i-th mission requires to move the robot\r\nfrom a_i to b_i.For each mission, you should tell the minimum capacity\r\nrequired to acheive it.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nint n,k,m,q;\nvector < pair < int , int > > E[100005];\nLL dist[100005];\nint U[300005], V[300005];\nvector < int > Sfrom[100005], Sto[100005];\nint P[100005];\nLL Answer[300005];\nLL Sum[100005];\nvector < pair < pair < int , int > , LL > > pr;\n\nint f( int x ){\n\tif ( P[x] != x ) return P[x] = f(P[x]);\n\treturn x;\n}\n\nbool cmp( pair < pair < int , int > , LL > a, pair < pair < int , int > , LL > b ){\n\treturn a.se < b.se;\n}\n\nint main(){\n\n\tmemset(Answer,-1,sizeof(Answer));\n\tscanf(\"%d%d%d%d\",&n,&m,&k,&q);\n\tfor ( int i = 1; i <= n; i++ ){\n\t\tP[i] = i;\n\t\tdist[i] = 1e18;\n\t}\n\tfor ( int i = 0; i < m; i++ ){\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tE[u].pb(mp(v,w));\n\t\tE[v].pb(mp(u,w));\n\t}\n\tfor ( int i = 0; i < q; i++ ){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tU[i] = u;\n\t\tV[i] = v;\n\t\tSfrom[u].pb(i);\n\t\tSto[v].pb(i);\n\t\tSfrom[v].pb(i);\n\t\tSto[u].pb(i);\n\t}\n\tpriority_queue < pair < LL , int > > pq;\n\tfor ( int i = 1; i <= k; i++ ){\n\t\tpq.push(mp(0,i));\n\t\tdist[i] = 0;\n\t}\n\n\twhile ( !pq.empty() ){\n\t\tLL z = -pq.top().fi;\n\t\tint u = pq.top().se;\n\t\tpq.pop();\n\t\tif ( dist[u] != z ) continue;\n\t\tfor ( auto it : E[u] ){\n\t\t\tint v = it.fi;\n\t\t\tLL w = it.se;\n\t\t\tif ( dist[v] > z + w ){\n\t\t\t\tdist[v] = z + w;\n\t\t\t\tpq.push(mp(-dist[v],v));\n\t\t\t} else {\n\t\t\t\tpr.push_back(mp(mp(u,v),w + dist[v] + dist[u]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(pr.begin(),pr.end(),cmp);\n\n\tfor ( int id = 0; id < pr.size(); id++ ){\n\t\tint u = pr[id].fi.fi, v = pr[id].fi.se;\n\t\tLL w = pr[id].se;\n\t\tif ( f(u) != f(v) ){\n\t\t\tint pu = f(u), pv = f(v);\n\t\t\tif ( pu > pv ) swap(pu,pv);\n\t\t\tif ( Sfrom[pu].size() + Sto[pu].size() < Sfrom[pv].size() + Sto[pv].size() ){\n\t\t\t\tfor ( auto it : Sfrom[pu] ){\n\t\t\t\t\tint itv = V[it];\n\t\t\t\t\tif ( Answer[it] != -1 ) continue;\n\t\t\t\t\tif ( f(itv) == f(pv) ){\n\t\t\t\t\t\tAnswer[it] = w;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSfrom[pv].push_back(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor ( auto it : Sto[pu] ){\n\t\t\t\t\tint itu = U[it];\n\t\t\t\t\tif ( Answer[it] != -1 ) continue;\n\t\t\t\t\tif ( f(itu) == f(pv) ){\n\t\t\t\t\t\tAnswer[it] = w;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSto[pv].push_back(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tP[pu] = pv;\n\t\t\t} else {\n\t\t\t\tfor ( auto it : Sfrom[pv] ){\n\t\t\t\t\tint itv = V[it];\n\t\t\t\t\tif ( Answer[it] != -1 ) continue;\n\t\t\t\t\tif ( f(itv) == f(pu) ){\n\t\t\t\t\t\tAnswer[it] = w;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSfrom[pu].push_back(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor ( auto it : Sto[pv] ){\n\t\t\t\t\tint itu = U[it];\n\t\t\t\t\tif ( Answer[it] != -1 ) continue;\n\t\t\t\t\tif ( f(itu) == f(pu) ){\n\t\t\t\t\t\tAnswer[it] = w;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSto[pu].push_back(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tP[pv] = pu;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( int i = 0; i < q; i++ ){\n\t\tprintf(\"%lld\\n\",Answer[i]);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dsu",
        "graphs",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Cheap Robot.json",
    "editorial_link": "https://codeforces.com//blog/entry/71489?locale=en",
    "editorial": "Since we always end on a central, at any time our robot have to be able\r\nto reach the nearest central. Since we always start from a central, from\r\nany node , going to the nearest central, then going back to can\u00e2\u0080\u0099t\r\ndecrease the number of energy points in the battery. Firstly, let\u00e2\u0080\u0099s do a\r\nmulti-source Dijkstra from all centrals. We denote the distance from\r\nnode to the nearest central.Consider a fixed capacity . Suppose that\r\nwe\u00e2\u0080\u0099re on node with energy points remaining in the battery. Note that .If\r\n, we can\u00e2\u0080\u0099t do anything, the robot is lost because it can\u00e2\u0080\u0099t reach any\r\ncentral anymore.Otherwise, if , we can go to the nearest central, then\r\ngo back to , hence we can always consider than .This is a simple but\r\nvery powerful observation that allows us to delete the battery level in\r\nstates explored. Hence, we can now solve the problem in , doing binary\r\nsearch on answer and simple DFS for each query. We need to optimize this\r\nsolution. Now, reaching a node will mean reaching it with .During\r\nexploration of nodes, the necessary and sufficient condition for being\r\nable to reach node from , through an edge of weight , is that , i.e.\r\n.Hence, if we replace the weight of each edge by , the problem is\r\nreduced to find a shortest path from to , in terms of weight over edges\r\nused (which will be the capacity required by this path).Sort edges by\r\nnew weight. Add them progressively, maintaining connexity with DSU.As\r\nsoon as two endpoints of a query become connected, we should put current\r\ncapacity (i.e. new weight of the last edge added) as answer for this\r\nquery.To effeciently detect this, we can put tokens on endpoints of each\r\nquery, and each time we do union (of DSU), we make tokens go up to the\r\nparent. If we do union by rank, each token will move at most times.Let\u00e2\u0080\u0099s\r\nconstruct a MST of the new graph with .It is well-known that in this\r\nparticular MST, for every pair of nodes , the only path from to will be\r\na shortest path (in terms of maximum weight over the path).Hence we just\r\nhave to compute the weight of paths in a tree, which can be done with\r\nbinary lifting.These two solutions both run in . Implementation of\r\nsolution 1 is a bit shorter, but solution 2 can deal with online\r\nqueries. Solution 1 (hugopm) Solution 2 (faremy)\r\n"
}