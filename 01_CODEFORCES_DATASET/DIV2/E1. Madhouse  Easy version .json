{"link": "https://codeforces.com//contest/1287/problem/E1", "problemId": "509650", "problem_idx": "E1", "shortId": "1287E1", "contest_number": "1287", "problem_submissions": {"E2": [68292966], "E1": [68275567, 69857829, 68268888, 68267730, 68276517, 68275345, 68277506], "D": [68254686, 69267989, 68263399, 68273154, 68268233, 68260202, 68261652, 68267427, 68261050, 68269506, 68253370, 68261828, 68262781, 68259993, 68263653, 68262032, 68264765, 68263857, 68263835, 68268683], "C": [68251057, 69267378, 68258032, 68258705, 68258307, 68255841, 68251184, 68254777, 68254064, 68259914, 68257391, 68256601, 68256839, 68253229, 68254316, 68258260, 68255773, 68259159, 68259073, 68255080], "B": [68248587, 69266960, 68254034, 68252413, 68256461, 68250437, 68247733, 68281202, 68281106, 68280696, 68280618, 68264095, 68250685, 68253499, 68259982, 68248645, 68435109, 68253464, 68263831, 68250832, 68248995, 68250500, 68255530, 68255702, 68249590], "A": [68244872, 69266641, 68245653, 68244897, 68247583, 68245583, 68244694, 68245113, 68244700, 68244809, 68261293, 68244924, 68435072, 68246461, 68245783, 68245033, 68244706, 68244729, 68245472, 68245512, 68245361], "F": [68641340]}, "name": "E1. Madhouse  Easy version ", "statement": "Venya joined a tour to the madhouse, in which orderlies play with\r\npatients the following game. Orderlies pick a string s of length n,\r\nconsisting only of lowercase English letters. The player can ask two\r\ntypes of queries: ask to list all substrings of s[l..r]. Substrings will\r\nbe returned in random order, and in every substring, all characters will\r\nbe randomly shuffled. guess the string picked by the orderlies. This\r\nquery can be asked exactly once, after that the game will finish. If the\r\nstring is guessed correctly, the player wins, otherwise he loses. The\r\nplayer can ask of the first type.To make it easier for the orderlies,\r\nthere is an additional limitation: the total number of returned\r\nsubstrings in all queries of the first type must not exceed\r\n(n+1)^2.Venya asked you to write a program, which will guess the string\r\nby interacting with the orderlies\u2019 program and acting by the game\u2019s\r\nrules.Your program should immediately terminate after guessing the\r\nstring using a query of the second type. In case your program guessed\r\nthe string incorrectly, or it violated the game rules, it will receive\r\nverdict .Note that in every test case the string is fixed beforehand and\r\nwill not change during the game, which means that the interactor is not\r\nadaptive.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\n\nstring readString() {\n  static char s[N];\n  scanf(\"%s\", s);\n  return (string)s;\n}\n\nint n;\nstring inputS;\n\npair<char, char> possibles[N];\nchar ans[N];\nbool vis[N];\nvector<pair<int, pair<char, char>>> adj[N];\n\nvector<string> generateFromInput(int l, int r) {\n  vector<string> ret;\n  for (int i = l ; i <= r ; i++) {\n    string cur = \"\";\n    for (int j = i ; j <= r ; j++) {\n      cur += inputS[j-1];\n      ret.push_back(cur);\n    }\n  }\n  sort(ret.begin(), ret.end(),\n       [](string a, string b) { return a.length() < b.length(); });\n\n  return ret;\n}\n\nvector<string> ask(int l, int r) {\n  // return generateFromInput(l, r);\n\n  printf(\"? %d %d\\n\", l, r);\n  fflush(stdout);\n\n  int len = r - l + 1;\n  int tot = len * (len + 1) / 2;\n\n  vector<string> ret;\n  for (int i = 0 ; i < tot ; i++) {\n    string s = readString();\n    ret.push_back(s);\n  }\n\n  sort(ret.begin(), ret.end(), [](string a, string b) {\n    return a.length() < b.length();\n  });\n\n  return ret;\n}\n\nvoid answer(string s) {\n  printf(\"! %s\\n\", s.c_str());\n  fflush(stdout);\n}\n\nvoid addEdge(int a, int b, pair<char, char> vals) {\n  adj[a].push_back({b, vals});\n  adj[b].push_back({a, vals});\n  // printf(\"add edge %d %d -> %c %c\\n\", a, b, vals.first, vals.second);\n}\n\nvoid dfs(int now, char cur) {\n  if (vis[now]) return;\n  vis[now] = true;\n  ans[now] = cur;\n\n  for (auto it : adj[now]) {\n    int nxt = it.first;\n\n    char tmp = it.second.first;\n    if (tmp == ans[now]) tmp = it.second.second;\n\n    dfs(nxt, tmp);\n  }\n}\n\nvoid generatePossibleChars(int l, int r) {\n  l--; r--;\n  int _n = r - l + 1;\n  vector<string> v = ask(l+1, r+1);\n\n  int cntAll[26] = {0};\n  for (char ch : v.back()) {\n    cntAll[ch - 'a']++;\n  }\n\n  // for (int k = 0 ; k < 26 ; k++) printf(\"%c val %d\\n\", k + 'a', cntAll[k]);\n\n  int curLength = _n-1;\n  int idx = 0;\n\n  for (int i = v.size()-2 ; i >= 0 ; ) {\n    if (2 * curLength <= _n) {\n      // puts(\"done\");\n      break;\n    }\n\n    int j = i;\n\n    int cnt[26] = {0};\n    while (j >= 0 && v[j].length() == curLength) {\n      // cout << \"isi\" << v[j] << endl;\n      for (char ch : v[j]) {\n        cnt[ch - 'a']++;\n      }\n      j--;\n    }\n\n    // cout << i << \" \" << j << \" \" << curLength << endl;\n\n    for (int k = 0 ; k < 26 ; k++) {\n      cnt[k] = (_n - curLength + 1) * cntAll[k] - cnt[k];\n    }\n    for (int k = 0 ; k < idx ; k++) {\n      int mult = (_n - curLength + 1 - (k+1));\n      // printf(\"mult %d\\n\", mult);\n      cnt[possibles[k + l].first - 'a'] -= mult;\n      cnt[possibles[k + l].second - 'a'] -= mult;\n    }\n\n    // for (int k = 0 ; k < 26 ; k++) {\n    //   printf(\"%c val %d\\n\", k + 'a', cnt[k]);\n    // }\n\n    vector<char> vc;\n    for (int k = 0 ; k < 26 ; k++) {\n      assert(cnt[k] >= 0);\n      // printf(\"%c sekarang %d\\n\", k + 'a', cnt[k]);\n      for (int it = 0 ; it < cnt[k] ; it++) {\n        vc.push_back(k + 'a');\n      }\n    }\n    // cout << vc.size() << endl;\n    assert(vc.size() == 2);\n\n    possibles[idx + l] = {vc[0], vc[1]};\n    possibles[_n - idx - 1 + l] = possibles[idx+l];\n    addEdge(idx + l, _n-idx-1 + l, possibles[idx+l]);\n\n    i = j;\n    curLength--;\n    idx++;\n  }\n\n  // do for the middle\n  for (int i = 0 ; i < idx ; i++) {\n    // cout << possibles[i].first << \" \" << possibles[i].second << endl;\n    cntAll[possibles[i + l].first - 'a']--;\n    cntAll[possibles[i + l].second - 'a']--;\n  }\n\n  vector<char> vc;\n  for (int k = 0; k < 26; k++) {\n    assert(cntAll[k] >= 0);\n    for (int it = 0; it < cntAll[k]; it++) {\n      vc.push_back(k + 'a');\n    }\n  }\n\n  pair<int, int> tmp;\n  if (vc.size() == 1) {\n    tmp = {vc[0], vc[0]};\n  } else {\n    tmp = {vc[0], vc[1]};\n  }\n\n  possibles[(_n-1)/2 + l] = tmp;\n  possibles[_n/2 + l] = tmp;\n  addEdge((_n-1)/2 + l, _n/2 + l, tmp);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  // cin >> inputS;\n\n  if (n == 1) {\n    vector<string> v = ask(1, 1);\n    answer(v[0]);\n    return 0;\n  } else if (n == 2) {\n    vector<string> v0 = ask(1, 2);\n    vector<string> v1 = ask(1, 1);\n\n    string ans = v1[0];\n\n    if (v0[0] == ans) ans += v0[1];\n    else ans += v0[0];\n\n    answer(ans);\n    return 0;\n  }\n\n  generatePossibleChars(1, n);\n  // cout << \"oc\\n\";\n  generatePossibleChars(1, n-1);\n  \n  vector<string> onlyMid = ask(1, 1);\n  dfs(0, onlyMid[0][0]);\n\n  string ret = \"\";\n  for (int i = 0 ; i < n ; i++) {\n    ret += ans[i];\n  }\n  answer(ret);\n  return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "interactive"], "dificulty": "2400", "interactive": false}