{"link": "https://codeforces.com//contest/1647/problem/E", "problemId": "1325139", "problem_idx": "E", "shortId": "1647E", "contest_number": "1647", "problem_submissions": {"E": [149328614, 149306053, 149316265, 149308258, 149317785, 149313427, 149312064, 149315761, 149304431, 149320349, 150085301, 150042558, 149322061, 149314157, 149320038, 149317712, 149323749, 150451628, 149317915, 149318394, 149323507, 149319981], "F": [149303385, 150083877], "D": [149287936, 149297042, 149288719, 149296838, 149289639, 149297770, 149297559, 149297568, 149315595, 149296805, 149293753, 149297523, 149298563, 149301837, 149303949, 149304702, 149307649, 149304812, 149312121], "C": [149278105, 149282014, 149279931, 149284899, 149279456, 149277016, 149284452, 149277474, 149269562, 149281799, 149285826, 149288910, 149285483, 149289384, 149282591, 149290109, 149289945, 149281141, 149290895], "B": [149272671, 149276622, 149275457, 149274250, 149274540, 149272438, 149278573, 149272028, 149276101, 149277049, 149276729, 149282060, 149280768, 149280254, 149275958, 149282515, 149283800, 149273253, 149287993], "A": [149265543, 149268740, 149264746, 149268469, 149267568, 149268599, 149267275, 149265283, 149267772, 149268479, 149269295, 149265276, 149269381, 149271464, 149267445, 149276391, 149271015, 149268133, 149268825]}, "name": "E. Madoka and the Sixth-graders", "statement": "After the most stunning success with the fifth-graders, Madoka has been\r\ntrusted with teaching the sixth-graders.There\u2019s n single-place desks in\r\nher classroom. At the very beginning Madoka decided that the student\r\nnumber b_i (1\r\nle b_i\r\nle n) will sit at the desk number i. Also there\u2019s an infinite line of\r\nstudents with numbers n + 1, n + 2, n + 3,\r\nldots waiting at the door with the hope of being able to learn something\r\nfrom the Madoka herself. Pay attention that each student has his\r\nnumber.After each lesson, the following happens in sequence. The student\r\nsitting at the desk i moves to the desk p_i. All students move\r\nsimultaneously. If there is more than one student at a desk, the student\r\nwith the lowest number keeps the place, and the others are removed from\r\nthe class . For all empty desks in ascending order, the student from the\r\nlowest number from the outside line occupies the desk. Note that in the\r\nend there is exactly one student at each desk again. It is guaranteed\r\nthat the numbers p are such that at least one student is removed after\r\neach lesson. Check out the explanation to the first example for a better\r\nunderstanding.After several (possibly, zero) lessons the desk i is\r\noccupied by student a_i. Given the values a_1, a_2,\r\nldots, a_n and p_1, p_2,\r\nldots, p_n, find the lexicographically smallest suitable initial seating\r\npermutation b_1, b_2,\r\nldots, b_n.The permutation is an array of n different integers from 1 up\r\nto n in any order. For example, [2,3,1,5,4] is a permutation, but\r\n[1,2,2] is not (2 occurs twice). [1,3,4] is not a permutation either\r\n(n=3 but there\u2019s 4 in the array).For two different permutations a and b\r\nof the same length, a is lexicographically less than b if in the first\r\nposition where a and b differ, the permutation a has a smaller element\r\nthan the corresponding element in b.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define f first\n#define s second\n//#define x first\n//#define y second\n//#define int li\n#define err if(debug_out)cout\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pld = pair<ld, ld>;\n\nconst int INF = 1e9 + 13;\nconst li INF64 = 1e18 + 13;\nconst int N = 3e5 + 13;\nconst int LOGN = 40;\nconst int K = 22;\nconst int M = 998244353;//1e9 + 7;\nconst int A = 26;\nconst ld eps = 1e-8;\n\nmt19937 rnd(45768);\n\n/*\n*/\n\n\n\n/*\n*/\n\n\nint p[N], a[N], b[N];\n\n\nint nxt[LOGN][N];\nint q[N];\n\nvector<int> pos[N];\nint mn[N];\nint ind[N];\n\nbool used[N];\nint wh[N];\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    set<int> pst;\n    for(int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n        pst.insert(p[i]);\n    }\n\n    int mx = 0;\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n        a[i]--;\n        mx = max(mx, a[i]);\n    }\n\n    int m = (mx - n + 1) / (n - pst.size());\n\n    for(int i = 0; i < n; i++)\n        nxt[0][i] = p[i];\n\n    for(int i = 1; i < LOGN; i++) {\n        for(int j = 0; j < n; j++) {\n            nxt[i][j] = nxt[i - 1][nxt[i - 1][j]];\n        }\n    }\n\n//    cout << m << endl;\n\n    for(int i = 0; i < n; i++) {\n        int v = i;\n        for(int k = LOGN - 1; k >= 0; k--) {\n            if((1ll << k) & m) {\n                v = nxt[k][v];\n            }\n        }\n\n        q[i] = v;\n\n//        cout << i << ' ' << q[i] << endl;\n    }\n\n    for(int i = 0; i < n; i++) {\n        mn[i] = INF;\n    }\n\n    for(int i = 0; i < n; i++) {\n        pos[q[i]].push_back(i);\n//        mn[q[i]] = min(mn[q[i]], a[i]);\n    }\n\n//    for(int i = 0; i < n; i++)\n//        arr[i] = INF;\n//cout << \"sgf\" << endl;\n    for(int i = 0; i < n; i++) {\n//        cout << i << ' ' << a[i] << ' ' << pos[i].size() << endl;\n        if(a[i] < n) {\n            wh[a[i]] = i;\n            b[pos[i][0]] = a[i];\n//            cout << \"b \" << pos[i][0] << ' ' << a[i] << endl;\n            used[a[i]] = true;\n//            if(pos[i].size() > 1) {\n//                arr[a[i]] = pos[i][1];\n//            }\n            ind[i] = 1;\n        }\n    }\n\n//    build(0, 0, n);\n\n//    cout << \"arr \";\n//    for(int i = 0; i < n; i++)\n//        cout << arr[i] << ' ';\n//    cout << endl;\n    set<int> st;\n    for(int i = 0; i < n; i++) {\n//        cout << i << endl;\n\n        if(!used[i]) {\n            used[i] = true;\n\n            int j = *st.begin();//get(0, 0, n, 0, i);\n            st.erase(st.begin());\n\n            b[j] = i;\n\n//            cout << \"for b \" << j << ' ' << i << endl;\n\n            ind[q[j]]++;\n            if(ind[q[j]] < pos[q[j]].size()) {\n//                update(0, 0, n, a[q[j]], pos[q[j]][ind[q[j]]]);\n                st.insert(pos[q[j]][ind[q[j]]]);\n            }\n//            else {\n//                update(0, 0, n, a[q[j]], INF);\n//            }\n//            cout << \"arr \";\n//            for(int i = 0; i < n; i++)\n//                cout << arr[i] << ' ';\n//            cout << endl;\n        } else if(pos[wh[i]].size() > 1) {\n            st.insert(pos[wh[i]][ind[wh[i]]]);\n        }\n    }\n\n    for(int i = 0; i < n; i++)\n        cout << b[i] + 1 << ' ';\n    cout << endl;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "greedy"], "dificulty": "2500", "interactive": false}