{
    "link": "https://codeforces.com//contest/1956/problem/D",
    "problemId": "2588544",
    "problem_idx": "D",
    "shortId": "1956D",
    "contest_number": "1956",
    "problem_submissions": {
        "E2": [
            256586454,
            256520068,
            256593913,
            256584316,
            256530034,
            256531943,
            256617463,
            256530865,
            256802937,
            256648508,
            256552517
        ],
        "F": [
            256530495,
            256522758,
            256514971,
            256533550,
            256538415
        ],
        "E1": [
            256505148,
            256506481,
            256593956,
            256525162,
            256511611,
            256531463,
            256583839,
            256517737,
            256520564,
            256527984,
            256521079,
            256525566,
            256521334,
            256530001,
            256521675,
            256525396,
            256535359,
            256525874,
            256529271
        ],
        "D": [
            256490682,
            256484072,
            256499658,
            256496427,
            256507516,
            256497830,
            256509043,
            256518890,
            256503281,
            256502580,
            256513745,
            256510694,
            256502427,
            256508396,
            256502061,
            256511658,
            256506094,
            256504568,
            256506260,
            256504200
        ],
        "C": [
            256481140,
            256475175,
            256487231,
            256481616,
            256488132,
            256485599,
            256493794,
            256476985,
            256483699,
            256486860,
            256497932,
            256487782,
            256477155,
            256486111,
            256486350,
            256491079,
            256480941,
            256486971,
            256480982,
            256485785
        ],
        "B": [
            256472484,
            256473000,
            256480823,
            256472874,
            256473325,
            256479701,
            256477112,
            256472735,
            256473445,
            256477448,
            256476511,
            256477221,
            256472449,
            256475342,
            256477910,
            256471353,
            256472967,
            256472966,
            256473168,
            256475591
        ],
        "A": [
            256471122,
            256471242,
            256472786,
            256473979,
            256471107,
            256479866,
            256471283,
            256471128,
            256471039,
            256472531,
            256472351,
            256472781,
            256471086,
            256471438,
            256477739,
            256470907,
            256471074,
            256471160,
            256471053,
            256472375
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128426",
    "editorial": "When , the sum can hit with making at last. Construction: Here,\nsolve(k) will take about operations.Since doing operation will make , if\nfor all , is included in at least one of the operations and are not, the\noptimal strategy will be setting for using the construction\nabove.Finally, we can use DFS or DP to determine whether each element is\nincluded in operations.The number of operations used will not exceed .\n",
    "name": "D. Nene and the Mex Operator",
    "statement": "Nene gave you an array of integers a_1, a_2,\r\nldots, a_n of length n.You can perform the following operation no more\r\nthan 5\r\ncdot 10^5 times (possibly zero): Choose two integers l and r such that 1\r\nle l\r\nle r\r\nle n, compute x as\r\noperatorname{MEX}(\r\n{a_l, a_{l+1},\r\nldots, a_r\r\n}), and simultaneously set a_l:=x, a_{l+1}:=x,\r\nldots, a_r:=x. Here,\r\noperatorname{MEX} of a set of integers\r\n{c_1, c_2,\r\nldots, c_k\r\n} is defined as the smallest non-negative integer m which does not occur\r\nin the set c.Your goal is to maximize the sum of the elements of the\r\narray a. Find the maximum sum and construct a sequence of operations\r\nthat achieves this sum. Note that you don\u2019t need to minimize the number\r\nof operations in this sequence, you only should use no more than 5\r\ncdot 10^5 operations in your solution.\r\n",
    "solutions": [
        "// Problem: D. Nene and the Mex Operator// Contest: Codeforces - Codeforces Round 939 (Div. 2)// URL: https://mirror.codeforces.com/contest/1956/problem/D// Memory Limit: 256 MB// Time Limit: 2000 ms// // Powered by CP Editor (https://cpeditor.org)\u00a0// Author: EnucAI#include <bits/stdc++.h>\u00a0#ifdef LOCAL#include \"debug.h\"#else#define D(...) ((void)0)#endif\u00a0using ll = long long;using ull = unsigned long long;using ld = long double;using vi = std::vector<int>;using pii = std::pair<int, int>;\u00a0constexpr int inf = std::numeric_limits<int>::max() / 2;constexpr ll infll = std::numeric_limits<ll>::max() / 2;constexpr ld eps = 1e-8l;\u00a0#define all(x) (x).begin(), (x).end()#define sz(x) ((int)((x).size()))#define rep(i, j, k) for (int i = (j); i <= (k); i++)#define per(i, j, k) for (int i = (j); i >= (k); i--)#define fi first#define se second#define mp std::make_pair#define pb push_back#define ppb pop_back#define eb emplace_back\u00a0template <class X, class Y> void chkmax(X &x, const Y &y) { if (x < y) x = y; }template <class X, class Y> void chkmin(X &x, const Y &y) { if (x > y) x = y; }\u00a0constexpr int maxn = 18 + 5;\u00a0int n, a[maxn], dp[maxn], fr[maxn];std::vector<pii> ans;\u00a0void work(int l, int r) { // make a[i] = i - l  if (l == r) {    if (a[l]) {      ans.eb(l, l);      a[l] = 0;    }    return;  }  work(l, r - 1);  if (a[r] == r - l) return;  ans.eb(l, r);  std::fill(a + l, a + r + 1, r - l);  work(l, r - 1);}\u00a0int main() {  std::cin.tie(nullptr)->sync_with_stdio(false);  std::cin >> n;  rep(i, 1, n) std::cin >> a[i];  rep(i, 1, n) {    dp[i] = dp[i - 1] + a[i], fr[i] = 0;    rep(j, 1, i) {      int val = dp[j - 1] + (i - j + 1) * (i - j + 1);      if (val > dp[i]) dp[i] = val, fr[i] = j;    }  }  int p = n;  while (p) {    if (fr[p]) {      work(fr[p], p);      ans.eb(fr[p], p);      p = fr[p] - 1;    }    else p--;  }  std::cout << dp[n] << ' ' << sz(ans) << '\\n';  for (auto [l, r] : ans) std::cout << l << ' ' << r << '\\n';}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "divide and conquer",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Nene and the Mex Operator.json"
}