{
    "link": "https://codeforces.com//contest/1345/problem/D",
    "problemId": "600710",
    "problem_idx": "D",
    "shortId": "1345D",
    "contest_number": "1345",
    "problem_submissions": {
        "E": [
            79194179,
            79196032,
            79220297,
            79200684,
            79201329,
            79219340,
            79391989,
            79268362,
            79267373,
            79247234,
            79230319,
            79193699
        ],
        "D": [
            79182685,
            79185329,
            79189475,
            79188511,
            79179864,
            79171870,
            79173915,
            79165263,
            79173257,
            79175980,
            79176898,
            79242598,
            79180486,
            79183462,
            79179438,
            79180644,
            79181066,
            79182336
        ],
        "C": [
            79166678,
            79171676,
            79174223,
            79183005,
            79155393,
            79157900,
            79170332,
            79162910,
            79161162,
            79163028,
            79162951,
            79164149,
            79160726,
            79164483,
            79165533,
            79167519,
            79166191
        ],
        "B": [
            79161444,
            79162895,
            79158056,
            79159769,
            79152511,
            79154234,
            79151562,
            79156943,
            79155510,
            79156024,
            79158727,
            79152661,
            79151997,
            79158730,
            79160284,
            79158238,
            79157754
        ],
        "A": [
            79149423,
            79162373,
            79160953,
            79149853,
            79149101,
            79148773,
            79149875,
            79150362,
            79149364,
            79149646,
            79148884,
            79148772,
            79158375,
            79151373,
            79149772,
            79149372
        ],
        "F": [
            79200676,
            79276017
        ]
    },
    "name": "D. Monopole Magnets",
    "statement": "A monopole magnet is a magnet that only has one pole, either north or\r\nsouth. They don’t actually exist since real magnets have two poles, but\r\nthis is a programming contest problem, so we don’t care.There is an n\r\ntimes m grid. Initially, you may place some north magnets and some south\r\nmagnets into the cells. You are allowed to place as many magnets as you\r\nlike, even multiple in the same cell.An operation is performed as\r\nfollows. Choose a north magnet and a south magnet to activate. If they\r\nare in the same row or the same column and they occupy different cells,\r\nthen the north magnet moves one unit closer to the south magnet.\r\nOtherwise, if they occupy the same cell or do not share a row or column,\r\nthen nothing changes. Note that the south magnets are immovable.Each\r\ncell of the grid is colored black or white. Let’s consider ways to place\r\nmagnets in the cells so that the following conditions are met. There is\r\nat least one south magnet in every row and every column. If a cell is\r\ncolored black, then it is possible for a north magnet to occupy this\r\ncell after some sequence of operations . If a cell is colored white,\r\nthen it is impossible for a north magnet to occupy this cell after some\r\nsequence of operations . Determine if it is possible to place magnets\r\nsuch that these conditions are met. If it is possible, find the minimum\r\nnumber of north magnets required (there are no requirements on the\r\nnumber of south magnets).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nchar forbidden = '.';\nchar required = '#';\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n\n  vector<string> grid(n);\n\n  for (int i = 0; i < n; i++) {\n    cin >> grid[i];\n  }\n\n  bool unusedRows = false;\n\n  for (int i = 0;  i< n; i++) {\n    bool entered = false;\n    bool left = false;\n    for (int j = 0; j < m; j++) {\n      if (grid[i][j] == required) {\n        entered = true;\n        if (left) {\n          cout << \"-1\\n\";\n          return 0;\n        }\n      } else {\n        if (entered) left = true;\n      }\n    }\n    if (!entered) {\n      unusedRows = true;\n    }\n  }\n\n  bool unusedCols = false;\n\n  for (int j = 0;  j < m; j++) {\n    bool entered = false;\n    bool left = false;\n    for (int i = 0; i < n; i++) {\n      if (grid[i][j] == required) {\n        entered = true;\n        if (left) {\n          cout << \"-1\\n\";\n          return 0;\n        }\n      } else {\n        if (entered) left = true;\n      }\n    }\n    if (!entered) {\n      unusedCols = true;\n    }\n  }\n\n  if (unusedCols ^ unusedRows) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int cnt = 0;\n\n  { int i = 0;\n    bool hasRequired = false;\n    for (int j = 0; j < m; j++) {\n      if (grid[i][j] == required) hasRequired = true;\n    }\n    if (hasRequired) cnt++;\n  }\n\n  for (int i = 1; i < n; i++) {\n    int new_mag = true;\n    int hasRequired = false;\n    for (int j = 0; j < m; j++) {\n      if (grid[i][j] == required) hasRequired = true;\n      if (grid[i][j] == required && grid[i-1][j] == required) {\n        new_mag = false;\n      }\n    }\n    if (new_mag && hasRequired) cnt++;\n  }\n  cout << cnt << \"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Monopole Magnets.json",
    "editorial_link": "https://codeforces.com//blog/entry/76819",
    "editorial": "Suppose two cells and are colored black in the same row. Since there\r\nmust be a south magnet in every row, there are segments of black cells\r\nfrom and to the cell with the south magnet. The same result holds for\r\ncolumns. Therefore, for a solution to exist, every row and every column\r\nhas exactly one segment of black cells or is all-white.Suppose there is\r\nan all-white row, but not an all-white column. (Or similarly, an\r\nall-white column but not an all-white row.) Then wherever we place a\r\nsouth magnet in this row, its column will have a black cell. But then\r\nthe south magnet would be reachable, contradicting the fact that the row\r\nis all-white. Therefore, there should be an all-white row if and only if\r\nthere is an all-white column, or no solution exists.Now that we have\r\nexcluded these cases where no solution exists, letâs construct a\r\nsolution. Place a south magnet in a cell if: The cell is colored black,\r\nor Its row and column are both all-white. Then place one north magnet in\r\neach connected component of black cells. A north magnet cannot travel\r\nbetween components, so this is optimal.\r\n",
    "hint": []
}