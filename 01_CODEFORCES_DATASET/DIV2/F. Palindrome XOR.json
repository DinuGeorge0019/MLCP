{
    "link": "https://codeforces.com//contest/1162/problem/F",
    "problemId": "339909",
    "problem_idx": "F",
    "shortId": "1162F",
    "contest_number": "1162",
    "problem_submissions": {
        "F": [
            53760255
        ],
        "E": [
            53755729,
            53755411,
            53755882,
            53754129,
            53757378,
            53756764,
            53757700,
            53758454,
            53758416,
            53754833,
            53757407,
            53756313,
            53758588,
            53756165,
            53758997,
            53756619,
            53758311,
            53759677
        ],
        "D": [
            53752747,
            53753462,
            53754325,
            53757481,
            53752843,
            53755399,
            53755520,
            53755668,
            53754940,
            53755489,
            53758915,
            53755731,
            53754946,
            53755618,
            53759491,
            53755508,
            53758786,
            53755777,
            53756167
        ],
        "C": [
            53749836,
            53750600,
            53751425,
            53750020,
            53750391,
            53752273,
            53751033,
            53751621,
            53752004,
            53752815,
            53754220,
            53751629,
            53753641,
            53751893,
            53752886,
            53751070,
            53756767,
            53753219
        ],
        "B": [
            53748291,
            53748052,
            53748376,
            53747817,
            53748626,
            53748146,
            53748574,
            53749401,
            53805701,
            53749421,
            53749906,
            53748692,
            53758550,
            53750610,
            53749077,
            53749412,
            53749393,
            53748736,
            53751212
        ],
        "A": [
            53746666,
            53746560,
            53746976,
            53746641,
            53746514,
            53746879,
            53746868,
            53747863,
            53805694,
            53747143,
            53747013,
            53746924,
            53746595,
            53746573,
            53747849,
            53746548,
            53747762,
            53747182,
            53748613
        ]
    },
    "name": "F. Palindrome XOR",
    "statement": "You are given a string s consisting of characters \"\", \"\", and \"\". The\r\nfirst character of s is guaranteed to be \"\". Let m be the number of\r\ncharacters in s.Count the number of ways we can choose a pair of\r\nintegers a, b that satisfies the following: 1\r\nleq a < b < 2^m When written without leading zeros, the base-2\r\nrepresentations of a and b are both palindromes. The base-2\r\nrepresentation of of a and b matches the pattern s. We say that t\r\nmatches s if the lengths of t and s are the same and for every i, the\r\ni-th character of t is equal to the i-th character of s, or the i-th\r\ncharacter of s is \"\". Compute this count modulo 998244353.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll MOD = 998244353;\n\nstruct Bip {\n    vector<vector<pii> > ls;\n    vector<vector<pii> > rs;\n    vector<int> lfix;\n    vector<int> rfix;\n    int L, R;\n\n    Bip(int L_, int R_)\n    : ls(L_), rs(R_), lfix(L_, 0), rfix(R_, 0)\n    {\n        L = L_;\n        R = R_;\n    }\n\n    bool fix_l(int i, int val)\n    {\n        if (val && lfix[i] && val != lfix[i]) return false;\n        lfix[i] = val;\n        return true;\n    }\n\n    bool fix_r(int i, int val)\n    {\n        if (val && rfix[i] && val != rfix[i]) return false;\n        rfix[i] = val;\n        return true;\n    }\n\n    void add(int i, int j, int sw)\n    {\n        ls[i].emplace_back(j, sw);\n        rs[j].emplace_back(i, sw);\n    }\n\n    bool lspread(int i, int val, vector<bool>& vstl, vector<bool>& vstr)\n    {\n        vstl[i] = true;\n        if (val && lfix[i] && lfix[i] != val) {\n            return false;\n        }\n\n        for (auto& e : ls[i]) {\n            if (vstr[e.first]) continue;\n            if (!rspread(e.first, val * e.second, vstl, vstr)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    bool rspread(int i, int val, vector<bool>& vstl, vector<bool>& vstr)\n    {\n        vstr[i] = true;\n        if (val && rfix[i] && rfix[i] != val) {\n            return false;\n        }\n\n        for (auto& e : rs[i]) {\n            if (vstl[e.first]) continue;\n            if (!lspread(e.first, val * e.second, vstl, vstr)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\nll work(int N, const char *S, int len)\n{\n    Bip g((len + 1) / 2, (N + 1) / 2);\n    vector<int> a(len);\n    vector<int> b(N);\n    for (int i = 0; i < len; ++i) {\n        if (i < (len + 1) / 2) {\n            a[i] = i;\n        }\n        else {\n            a[i] = len - i - 1;\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (i < (N + 1) / 2) {\n            b[i] = i;\n        }\n        else {\n            b[i] = N - i - 1;\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        int c = S[N - i - 1];\n        if (c == '?') continue;\n        if (i < len) {\n            g.add(a[i], b[i], (c == '0') ? 1 : -1);\n        }\n        else {\n            if (!g.fix_r(b[i], (c == '1') ? 1 : -1)) return 0;\n        }\n    }\n    if (!g.fix_l(0, 1)) return 0;\n\n    vector<bool> vstl((len + 1) / 2, false);\n    vector<bool> vstr((N + 1) / 2, false);\n    for (int l = 0; l < (len + 1) / 2; ++l) {\n        if (g.lfix[l] && !vstl[l]) {\n            if (!g.lspread(l, g.lfix[l], vstl, vstr)) return 0;\n        }\n    }\n    for (int r = 0; r < (N + 1) / 2; ++r) {\n        if (g.rfix[r] && !vstr[r]) {\n            if (!g.rspread(r, g.rfix[r], vstl, vstr)) return 0;\n        }\n    }\n\n    ll res = 1;\n    for (int l = 0; l < (len + 1) / 2; ++l) {\n        if (!vstl[l]) {\n            res = (res * 2) % MOD;\n            g.lspread(l, 0, vstl, vstr);\n        }\n    }\n    for (int r = 0; r < (N + 1) / 2; ++r) {\n        if (!vstr[r]) {\n            res = (res * 2) % MOD;\n            g.rspread(r, 0, vstl, vstr);\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    char S[1002];\n    scanf(\"%s\", S);\n    int N = strlen(S);\n\n    ll res = 0;\n    for (int i = 1; i < N; ++i) {\n        res = (res + work(N, S, i)) % MOD;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Palindrome XOR.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "Since the leading character of s\n is a \"1\", then that means a<2m?1\n and 2m?1?b<2m\n. Let's fix the length of a\n as k\n. I'll describe a more general solution, so there might be simpler solutions that work for this specific problem.\n\nLet's make a graph with n+k+2\n nodes. The first n\n nodes represent the n\n bits of b\n, and the next k\n nodes represent the k\n bits of a\n. The last two nodes represent a 0\n node and 1\n node (which we will explain later). We want to find the number of ways to color the graph with two colors 0\n and 1\n such that they satisfy some conditions.\n\nLet's draw two different types of edges 0\n-edges and 1\n-edges. If two nodes are connected by a 0\n-edge, then that means they must be the same color. If two nodes are connected by a 1\n-edge, then that means they must be a different color.\n\nWe will draw some edges as follows:\n\nDraw a 1\n edge between the 0\n node and 1\n node to represent they must be different colors.\nDraw a 0\n edge between bi\n and bn?i?1\n to represent the palindrome conditions (similarly we can do this for a\n).\nFor the i\n-th bit, if si\n is \"1\", draw a 1\n edge between ai\n and bi\n (if i>k\n, we instead draw an edge from bi\n to 1\n). If si\n is \"0\", then draw a 0\n edge between ai\n and bi\n. If si\n is \"?\", then don't draw any edges, since there are no explicit constraints.\nNow, we want to count the number of valid colorings. We want to split the graph into a two colors, which is a bipartite graph. We want all edges that cross the bipartition to be 1\n edges and all edges within the same bipartition to be 0\n edges.\n\nTo count this, we first collapse all connected components of 0\n edges, then check if the remaining 1\n edges form a bipartite graph. If there is a non-bipartite graph, return 0\n immediately, since this means it's impossible to fulfill the conditions. Otherwise, let C\n be the number of connected components. We add 2C?1\n to our answer. The reason we subtract 1\n is that the component containing the 0\n and 1\n node is fixed to be colored 0\n, but for other components, we are free to color the components in either of two ways.\n\nThere are n\n different lengths to try, each of which take a linear amount of time to get the count, so the overall time complexity is O(n2)\n."
}