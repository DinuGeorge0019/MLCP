{"link": "https://codeforces.com//contest/1162/problem/F", "problemId": "339909", "problem_idx": "F", "shortId": "1162F", "contest_number": "1162", "problem_submissions": {"F": [53760255], "E": [53755729, 53755411, 53755882, 53754129, 53757378, 53756764, 53757700, 53758454, 53758416, 53754833, 53757407, 53756313, 53758588, 53756165, 53758997, 53756619, 53758311, 53759677], "D": [53752747, 53753462, 53754325, 53757481, 53752843, 53755399, 53755520, 53755668, 53754940, 53755489, 53758915, 53755731, 53754946, 53755618, 53759491, 53755508, 53758786, 53755777, 53756167], "C": [53749836, 53750600, 53751425, 53750020, 53750391, 53752273, 53751033, 53751621, 53752004, 53752815, 53754220, 53751629, 53753641, 53751893, 53752886, 53751070, 53756767, 53753219], "B": [53748291, 53748052, 53748376, 53747817, 53748626, 53748146, 53748574, 53749401, 53805701, 53749421, 53749906, 53748692, 53758550, 53750610, 53749077, 53749412, 53749393, 53748736, 53751212], "A": [53746666, 53746560, 53746976, 53746641, 53746514, 53746879, 53746868, 53747863, 53805694, 53747143, 53747013, 53746924, 53746595, 53746573, 53747849, 53746548, 53747762, 53747182, 53748613]}, "name": "F. Palindrome XOR", "statement": "You are given a string s consisting of characters \"\", \"\", and \"\". The\r\nfirst character of s is guaranteed to be \"\". Let m be the number of\r\ncharacters in s.Count the number of ways we can choose a pair of\r\nintegers a, b that satisfies the following: 1\r\nleq a < b < 2^m When written without leading zeros, the base-2\r\nrepresentations of a and b are both palindromes. The base-2\r\nrepresentation of of a and b matches the pattern s. We say that t\r\nmatches s if the lengths of t and s are the same and for every i, the\r\ni-th character of t is equal to the i-th character of s, or the i-th\r\ncharacter of s is \"\". Compute this count modulo 998244353.\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll MOD = 998244353;\n\nstruct Bip {\n    vector<vector<pii> > ls;\n    vector<vector<pii> > rs;\n    vector<int> lfix;\n    vector<int> rfix;\n    int L, R;\n\n    Bip(int L_, int R_)\n    : ls(L_), rs(R_), lfix(L_, 0), rfix(R_, 0)\n    {\n        L = L_;\n        R = R_;\n    }\n\n    bool fix_l(int i, int val)\n    {\n        if (val && lfix[i] && val != lfix[i]) return false;\n        lfix[i] = val;\n        return true;\n    }\n\n    bool fix_r(int i, int val)\n    {\n        if (val && rfix[i] && val != rfix[i]) return false;\n        rfix[i] = val;\n        return true;\n    }\n\n    void add(int i, int j, int sw)\n    {\n        ls[i].emplace_back(j, sw);\n        rs[j].emplace_back(i, sw);\n    }\n\n    bool lspread(int i, int val, vector<bool>& vstl, vector<bool>& vstr)\n    {\n        vstl[i] = true;\n        if (val && lfix[i] && lfix[i] != val) {\n            return false;\n        }\n\n        for (auto& e : ls[i]) {\n            if (vstr[e.first]) continue;\n            if (!rspread(e.first, val * e.second, vstl, vstr)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    bool rspread(int i, int val, vector<bool>& vstl, vector<bool>& vstr)\n    {\n        vstr[i] = true;\n        if (val && rfix[i] && rfix[i] != val) {\n            return false;\n        }\n\n        for (auto& e : rs[i]) {\n            if (vstl[e.first]) continue;\n            if (!lspread(e.first, val * e.second, vstl, vstr)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\nll work(int N, const char *S, int len)\n{\n    Bip g((len + 1) / 2, (N + 1) / 2);\n    vector<int> a(len);\n    vector<int> b(N);\n    for (int i = 0; i < len; ++i) {\n        if (i < (len + 1) / 2) {\n            a[i] = i;\n        }\n        else {\n            a[i] = len - i - 1;\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (i < (N + 1) / 2) {\n            b[i] = i;\n        }\n        else {\n            b[i] = N - i - 1;\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        int c = S[N - i - 1];\n        if (c == '?') continue;\n        if (i < len) {\n            g.add(a[i], b[i], (c == '0') ? 1 : -1);\n        }\n        else {\n            if (!g.fix_r(b[i], (c == '1') ? 1 : -1)) return 0;\n        }\n    }\n    if (!g.fix_l(0, 1)) return 0;\n\n    vector<bool> vstl((len + 1) / 2, false);\n    vector<bool> vstr((N + 1) / 2, false);\n    for (int l = 0; l < (len + 1) / 2; ++l) {\n        if (g.lfix[l] && !vstl[l]) {\n            if (!g.lspread(l, g.lfix[l], vstl, vstr)) return 0;\n        }\n    }\n    for (int r = 0; r < (N + 1) / 2; ++r) {\n        if (g.rfix[r] && !vstr[r]) {\n            if (!g.rspread(r, g.rfix[r], vstl, vstr)) return 0;\n        }\n    }\n\n    ll res = 1;\n    for (int l = 0; l < (len + 1) / 2; ++l) {\n        if (!vstl[l]) {\n            res = (res * 2) % MOD;\n            g.lspread(l, 0, vstl, vstr);\n        }\n    }\n    for (int r = 0; r < (N + 1) / 2; ++r) {\n        if (!vstr[r]) {\n            res = (res * 2) % MOD;\n            g.rspread(r, 0, vstl, vstr);\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    char S[1002];\n    scanf(\"%s\", S);\n    int N = strlen(S);\n\n    ll res = 0;\n    for (int i = 1; i < N; ++i) {\n        res = (res + work(N, S, i)) % MOD;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["graphs"], "dificulty": "2400", "interactive": false}