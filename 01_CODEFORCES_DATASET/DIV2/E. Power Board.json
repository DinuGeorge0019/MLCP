{
    "link": "https://codeforces.com//contest/1646/problem/E",
    "problemId": "1316356",
    "problem_idx": "E",
    "shortId": "1646E",
    "contest_number": "1646",
    "problem_submissions": {
        "F": [
            148377331,
            148376552,
            148380191,
            148408003,
            148407985,
            148407958,
            148625107,
            148397512,
            148614447,
            148385636
        ],
        "E": [
            148347130,
            148358632,
            148360488,
            148333996,
            148354021,
            148353992,
            148359437,
            148353904,
            148361106,
            148406239,
            148363543,
            148355954,
            148360552,
            148359820,
            148358320,
            148361452,
            148368263,
            148351309,
            148353801,
            148370230,
            148352778
        ],
        "D": [
            148336483,
            148341281,
            148366316,
            148319892,
            148345041,
            148346482,
            148342901,
            148349102,
            148343090,
            148339630,
            148343423,
            148345651,
            148350280,
            148350345,
            148349930,
            148341422,
            148364204,
            148362633,
            148344691,
            148349044
        ],
        "C": [
            148310953,
            148326110,
            148330270,
            148306601,
            148323665,
            148325840,
            148321586,
            148311486,
            148322407,
            148317336,
            148321327,
            148327478,
            148321394,
            148325846,
            148315684,
            148317105,
            148328227,
            148404981,
            148319824,
            148313542,
            148332408
        ],
        "B": [
            148304866,
            148306819,
            148315665,
            148302178,
            148310613,
            148314947,
            148310473,
            148304347,
            148306865,
            148309180,
            148307122,
            148311855,
            148309145,
            148315243,
            148304621,
            148305987,
            148317489,
            148404248,
            148306430,
            148304810,
            148327258
        ],
        "A": [
            148300689,
            148300631,
            148308492,
            148300540,
            148301834,
            148303727,
            148301684,
            148300721,
            148300698,
            148302427,
            148311861,
            148301382,
            148301011,
            148301721,
            148300651,
            148301177,
            148301822,
            148404175,
            148300747,
            148300552,
            148302531
        ]
    },
    "name": "E. Power Board",
    "statement": "You have a rectangular board of size n\r\ntimes m (n rows, m columns). The n rows are numbered from 1 to n from\r\ntop to bottom, and the m columns are numbered from 1 to m from left to\r\nright. The cell at the intersection of row i and column j contains the\r\nnumber i^j (i raised to the power of j). For example, if n=3 and m=3 the\r\nboard is as follows: Find the number of distinct integers written on the\r\nboard.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    LL n, m, ans = 1, sum;\n    cin >> n >> m;\n    vector<vector<pair<int, int>>> d(n + 1);\n    for (int i = 2; i <= n; i += 1)\n        if (d[i].empty())\n            for (int j = i; j <= n; j += i) {\n                d[j].emplace_back(i, 0);\n                for (int k = j; k % i == 0; k /= i)\n                    d[j].back().second += 1;\n            }\n    vector<int> mp = {0};\n    for (LL i = 2; i <= n; i += 1) {\n        int x = 0;\n        for (auto [p, r] : d[i])\n            x = gcd(x, r);\n        int y = 1;\n        for (auto [p, r] : d[i])\n            for (int j = 0; j < r / x; j += 1)\n                y *= p;\n        if (y == i) {\n            int k = 1;\n            while (y * i <= n) {\n                y *= i;\n                k += 1;\n            }\n            while (k >= mp.size()) mp.push_back(0);\n            mp[k] += 1;\n        }\n    }\n    vector<int> f((mp.size() - 1) * m + 1);\n    for (int i = 1; i < mp.size(); i += 1) {\n        for (int j = 1; j <= m; j += 1)\n            if (not f[i * j])\n                sum += f[i * j] = 1;\n        ans += sum * mp[i];\n    }\n    cout << ans;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Power Board.json",
    "editorial_link": "https://codeforces.com//blog/entry/100584",
    "editorial": "It is easy to see that the first row only contains the number and that\r\nthis number doesnât appear anywhere else on the board.We say that an\r\ninteger is a if it can be represented as where and are positive integers\r\nand . For each positive integer which is not a perfect power, we call to\r\nthe set of all numbers which appear in rows .Claim: If are not perfect\r\npowers, then and have no elements in common. Proof: Suppose there is a\r\ncommon element, then there exist positive integers such that . This is\r\nthe same as . Because is not a perfect power, has to be a positive\r\ninteger. If then , which cannot happen. So then , which cannot happen as\r\nis not a perfect power. Thus, this common element cannot exist. Based on\r\nthe observation above, for each not perfect power we can compute the\r\nsize of independently and then sum the results. For a fixed , let be the\r\nnumber of rows that start with a power of . Then contains all numbers of\r\nthe form where and . But, the size of this set is the same as the size\r\nof the set containing all numbers of the form where and . Note that the\r\nnumber of elements in this set does not depend on , it just depends on\r\n.Thus, the size of is uniquely determined by the value of . As , then we\r\nhave that . Then, for each we just need to compute the number of\r\ndistinct elements of the form where and . We can do this using an array\r\nof length , and at the -th step (for ) we mark the numbers as visited in\r\nthe array, and add one to the value we are computing for each number\r\nthat was not visited before. After the -th step we have computed this\r\nvalue for .So, to solve the problem it is enough to compute for each not\r\nperfect power , how many rows in the matrix start with a power of and\r\nusing the values we calculated in the last paragraph we can know how\r\nmany distinct numbers are there in . Intended complexity:\r\n",
    "hint": []
}