{
    "link": "https://codeforces.com//contest/1900/problem/B",
    "problemId": "2348159",
    "problem_idx": "B",
    "shortId": "1900B",
    "contest_number": "1900",
    "problem_submissions": {
        "E": [
            234456838,
            234455027,
            234457931,
            234455766,
            234456771,
            234460502,
            234461970,
            234463093,
            234461258,
            234461626,
            235437599,
            234459471,
            234465112,
            234465941,
            234463278,
            234463477,
            234464668,
            234464310,
            234465647,
            234465136
        ],
        "D": [
            234442999,
            234445532,
            234447119,
            234444027,
            234448662,
            234449846,
            234450821,
            234448590,
            234544232,
            234544122,
            234453539,
            234456816,
            234449461,
            234446745,
            234447346,
            234455068,
            234451202,
            234455283,
            234455174,
            234452017,
            234447175
        ],
        "C": [
            234433856,
            234437020,
            234438208,
            234438984,
            234436746,
            234440214,
            234440440,
            234440880,
            234441500,
            234437974,
            234441984,
            234439314,
            234438351,
            234441349,
            234441838,
            234441318,
            234441667,
            234442122,
            234444120
        ],
        "B": [
            234430889,
            234432938,
            234432800,
            234433842,
            234432820,
            234435211,
            234434789,
            234436751,
            234434039,
            234432505,
            234436824,
            234433963,
            234433725,
            234434390,
            234437612,
            234436752,
            234436425,
            234432619,
            234438330
        ],
        "A": [
            234429140,
            234429060,
            234429292,
            234429383,
            234429959,
            234434373,
            234428876,
            234431698,
            234428932,
            234429000,
            234431129,
            234431009,
            234429251,
            234429090,
            234434493,
            234430325,
            234429412,
            234429176,
            234429387
        ],
        "F": [
            234821914,
            234821787
        ]
    },
    "name": "B. Laura and Operations",
    "statement": "Nemanja wrote some digits on the board. All of them are either 1, 2, or\r\n3. The number of digits 1 is a. The number of digits 2 is b and the\r\nnumber of digits 3 is c. He told Laura that in one operation she can do\r\nthe following: Select two different digits and erase them from the\r\nboard. After that, write the digit (1, 2, or 3) different from both\r\nerased digits. For example, let the digits be 1, 1, 1, 2, 3, 3. She can\r\nchoose digits 1 and 3 and erase them. Then the board will look like this\r\n1, 1, 2, 3. After that, she has to write another digit 2, so at the end\r\nof the operation, the board will look like 1, 1, 2, 3, 2.Nemanja asked\r\nher whether it was possible for only digits of one type to remain\r\nwritten on the board after some operations. If so, which digits can they\r\nbe?Laura was unable to solve this problem and asked you for help. As an\r\naward for helping her, she will convince Nemanja to give you some\r\npoints.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < '0' || c > '9') c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x;\n}\nint a, b, c;\nvoid solve(){\n\tscanf(\"%d%d%d\", &a, &b, &c);\n\tprintf(\"%d %d %d\\n\", 1 - (b + c) % 2, 1 - (a + c) % 2, 1 - (a + b) % 2);\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(\"%d\", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Laura and Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/122677",
    "editorial": "SolutionRead the hints.If the parity of and is not the same, then it is\r\nimpossible for only digits to remain on the board, as it would require .\r\nOtherwise, the following construction will leave only digits on the\r\nboard.First remove digits and and write digit while and . If , then we\r\nare done. Otherwise, without loss of generality assume . That means that\r\nafter the operations and is even (Because and are the same parity). Now\r\nwe perform the following operations times to get only digits left.\r\nRemove digits and and add digit . After that remove digits and and add\r\ndigit . An effective change of these operations is the reduction of by\r\n.Time and memory complexities are .\r\n",
    "hint": [
        "Hint 1 Check if only digits can remain. The situation is similar for checking if only digits or only digits can remain.",
        "Hint 2 Try to find something that stays the same after each operation.",
        "Hint 3 Look at the parity of the numbers.",
        "Hint 4 The parity of each number changes after an operation. That means that if numbers have the same parity, they will always have the same parity. If they had different parity, their parities stay different."
    ]
}