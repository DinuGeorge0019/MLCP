{
    "link": "https://codeforces.com//contest/2030/problem/G1",
    "problemId": "2962994",
    "problem_idx": "G1",
    "shortId": "2030G1",
    "contest_number": "2030",
    "problem_submissions": {
        "D": [
            286870605,
            286870097,
            286766067,
            286743790,
            286749704,
            286752517,
            286743540,
            286763694,
            286769489,
            286762215,
            286755968,
            286807582,
            286774479,
            286755264,
            286748829,
            286762354,
            286767397,
            286766307,
            286775817,
            286773805,
            286867460,
            286806694,
            286757030
        ],
        "C": [
            286860734,
            286764785,
            286775512,
            286732737,
            286735870,
            286731279,
            286736529,
            286759035,
            286741312,
            286740209,
            286770332,
            286732276,
            286730948,
            286749099,
            286748589,
            286737019,
            286738816,
            286732618,
            286746919,
            286735952,
            286744382
        ],
        "B": [
            286858184,
            286726117,
            286721582,
            286722000,
            286722997,
            286722179,
            286731090,
            286742656,
            286728669,
            286721456,
            286721616,
            286722634,
            286723485,
            286723817,
            286722712,
            286723090,
            286725291,
            286719819,
            286727047,
            286721215,
            286722880
        ],
        "A": [
            286857205,
            286716570,
            286716508,
            286717068,
            286716187,
            286716722,
            286727391,
            286716522,
            286715165,
            286715628,
            286715445,
            286716659,
            286717260,
            286715083,
            286717340,
            286715258,
            286718621,
            286715888,
            286722488,
            286715834,
            286716388
        ],
        "G1": [
            286855127,
            286854605,
            287072911,
            286866647
        ],
        "F": [
            286768609,
            286793091,
            286802410,
            286804764,
            286807723,
            286808203,
            286799478,
            286806636,
            286814242,
            286786481,
            286811066,
            286813827,
            286813676,
            286816754,
            286814190,
            286813606,
            286813682,
            286795825,
            286808765,
            286817519
        ],
        "E": [
            286766337,
            286759349,
            286779444,
            286786742,
            286788454,
            286791781,
            286783999,
            286800776,
            286780259,
            286764648,
            286793854,
            286792948,
            286789703,
            286779768,
            286799721,
            286794191,
            286791806,
            286816988,
            286786381,
            286789315
        ],
        "G2": [
            287138384
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135218",
    "editorial": "Problem Credits: Proof_by_QED, satyam343 Analysis: satyam343 Solution\r\n(Easy Version)To find the score of a set of intervals , we follow these\r\nsteps:Initially, the score is set to .We perform the following process\r\nrepeatedly: Let be the interval with the smallest among all active\r\nintervals. Let be the interval with the largest among all active\r\nintervals. If , add to the score, mark intervals and as inactive, and\r\ncontinue the process. If , stop the process. At the end of this process,\r\nall active intervals will intersect at least one common point.Now, we\r\nneed to prove that the process indeed gives us the minimum possible\r\nscore. We can prove this by induction.Let be some set of intervals, and\r\nlet and be the intervals defined above. Consider the set (i.e., is the\r\nset excluding and ). We claim that: This is true because, for and to\r\nintersect, we must perform at least operations. Our construction\r\nachieves the lower bound of . Thus, During the process, we pair some\r\nintervals (possibly none). Specifically, in the -th step, we pair the\r\ninterval with the -th smallest with the interval having the -th largest\r\n, and add the distance between them to the score.In the problem G1, we\r\ncan compute the contribution of each pair of intervals as\r\nfollows:Suppose we consider a pair . Without loss of generality, assume\r\nthat .The pair will be considered in some subset if there are exactly\r\nintervals such that and exactly intervals such that , for some\r\nnon-negative integer .Let there be intervals such that and intervals\r\nsuch that .For to be paired in some subset , we must choose intervals\r\nfrom the intervals on the left and intervals from the intervals on the\r\nright, for some non-negative integer . There are no restrictions on the\r\nremaining intervals.Therefore, the contribution of is: We can simplify\r\nthis sum using the identity: (This is a form of the Vandermonde\r\nIdentity.)Thus, the contribution of becomes: This can be computed in\r\ntime.Note that in the explanation above, we assumed that the interval\r\nendpoints are distinct for simplicity. If they are not, we can order the\r\nintervals based on their values to maintain consistency.\r\n",
    "name": "G1. The Destruction of the Universe  Easy Version ",
    "statement": "There are n planets in the universe. Each planet has an [l, r], during\r\nwhich it will be exposed to destruction by orangutans. Orangutans can\r\nalso expand the of any planet by 1 unit.Specifically, suppose the\r\nexpansion is performed on planet p with [l_p, r_p]. Then, the resulting\r\nmay be either [l_p - 1, r_p] or [l_p, r_p + 1].Given a set of planets,\r\norangutans can destroy all planets if the of all planets in the set\r\nintersect at least one common point. Let the of such a set denote the\r\nminimum number of expansions that must be performed.Orangutans are\r\ninterested in the sum of of all subsets of the planets in the universe.\r\nAs the answer can be large, output it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; string to_string(string s) { return s; }template <typename T> string to_string(T v) {  bool first = true;  string res = \"[\";  for (const auto &x : v) {    if (!first)      res += \", \";    first = false;    res += to_string(x);  }  res += \"]\";  return res;} void dbg_out() { cerr << endl; }template <typename Head, typename... Tail> void dbg_out(Head H, Tail... T) {  cerr << ' ' << to_string(H);  dbg_out(T...);} #define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__) using LL = long long; template<class T>constexpr T power(T a, LL b) {    T res = 1;    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;} constexpr LL mul(LL a, LL b, LL p) {    LL res = a * b - LL(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;}template<LL P>struct MLong {    LL x;    constexpr MLong() : x{} {}    constexpr MLong(LL x) : x{norm(x % getMod())} {}        static LL Mod;    constexpr static LL getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(LL Mod_) {        Mod = Mod_;    }    constexpr LL norm(LL x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr LL val() const {        return x;    }    explicit constexpr operator LL() const {        return x;    }    constexpr MLong operator-() const {        MLong res;        res.x = norm(getMod() - x);        return res;    }    constexpr MLong inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MLong &operator*=(MLong rhs) & {        x = mul(x, rhs.x, getMod());        return *this;    }    constexpr MLong &operator+=(MLong rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MLong &operator-=(MLong rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MLong &operator/=(MLong rhs) & {        return *this *= rhs.inv();    }    friend constexpr MLong operator*(MLong lhs, MLong rhs) {        MLong res = lhs;        res *= rhs;        return res;    }    friend constexpr MLong operator+(MLong lhs, MLong rhs) {        MLong res = lhs;        res += rhs;        return res;    }    friend constexpr MLong operator-(MLong lhs, MLong rhs) {        MLong res = lhs;        res -= rhs;        return res;    }    friend constexpr MLong operator/(MLong lhs, MLong rhs) {        MLong res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {        LL v;        is >> v;        a = MLong(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {        return os << a.val();    }    friend constexpr bool operator==(MLong lhs, MLong rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MLong lhs, MLong rhs) {        return lhs.val() != rhs.val();    }}; template<>LL MLong<0LL>::Mod = 1; template<int P>struct MInt {    int x;    constexpr MInt() : x{} {}    constexpr MInt(LL x) : x{norm(x % getMod())} {}        static int Mod;    constexpr static int getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(int Mod_) {        Mod = Mod_;    }    constexpr int norm(int x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr int val() const {        return x;    }    explicit constexpr operator int() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        x = 1LL * x * rhs.x % getMod();        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        LL v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }}; template<>int MInt<0>::Mod = 1; template<int V, int P>constexpr MInt<P> CInv = MInt<P>(V).inv(); constexpr int P = 998244353;using Z = MInt<P>; struct Comb {    int n;    std::vector<Z> _fac;    std::vector<Z> _invfac;    std::vector<Z> _inv;        Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}    Comb(int n) : Comb() {        init(n);    }        void init(int m) {        if (m <= n) return;        _fac.resize(m + 1);        _invfac.resize(m + 1);        _inv.resize(m + 1);                for (int i = n + 1; i <= m; i++) {            _fac[i] = _fac[i - 1] * i;        }        _invfac[m] = _fac[m].inv();        for (int i = m; i > n; i--) {            _invfac[i - 1] = _invfac[i] * i;            _inv[i] = _invfac[i] * _fac[i - 1];        }        n = m;    }        Z fac(int m) {        if (m > n) init(2 * m);        return _fac[m];    }    Z invfac(int m) {        if (m > n) init(2 * m);        return _invfac[m];    }    Z inv(int m) {        if (m > n) init(2 * m);        return _inv[m];    }    Z binom(int n, int m) {        if (n < m || m < 0) return 0;        return fac(n) * invfac(m) * invfac(n - m);    }} comb; using u64 = unsigned long long;std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count()); using mat = vector<vector<Z>>; void init(mat &x, int n, int m) {\tx.resize(n);\tfor (int i = 0; i < n; i++) x[i].resize(m, Z(0));\t} mat operator * (mat A, mat B) {\tint n = A.size(), k = B.size(), m = B[0].size();\tmat rlt; init(rlt, n, m);\tfor (int i = 0; i < n; i++) {\t\tfor (int j = 0; j < m; j++) {\t\t\tfor (int t = 0; t < k; t++) {\t\t\t\trlt[i][j] += A[i][t] * B[t][j];\t\t\t\t}\t\t}\t}\treturn rlt;} mat power_mat(mat A, LL n) {\tif (n == 1) return A;\tmat tp = power_mat(A, n / 2);\ttp = tp * tp;\tif (n & 1) tp = tp * A;\treturn tp;\t} void solve() {\tint n; cin >> n;\tvector<int> a(n), b(n);\tfor (int i = 0; i < n; i++) {\t\tcin >> a[i] >> b[i];\t\t}\tZ ans = 0;\tfor (int i = 1; i < n; i++) {\t\tint aa = 0, bb = 0;\t\tfor (int j = 0; j < n; j++) {\t\t\tif (b[j] <= i) aa ++;\t\t\tif (a[j] >= i + 1) bb ++;\t\t}\t\tint res = n - aa - bb;\t\tvector<Z> A(aa + 1), B(bb + 1);\t\tfor (int j = aa; j >= 0; j--) A[j] = (j == aa ? Z(0) : A[j + 1]) + comb.binom(aa, j);\t\tfor (int j = bb; j >= 0; j--) B[j] = (j == bb ? Z(0) : B[j + 1]) + comb.binom(bb, j);\t\tZ way = 0;\t\tfor (int j = 1; j <= min(aa, bb); j++) way += A[j] * B[j];\t\tway *= power(Z(2), res);\t\tans += way;\t}\tcout << ans << \"\\n\";} int main() {\tios::sync_with_stdio(0);\tcin.tie(0), cout.tie(0);   \tint t = 1;  \tcin >> t;   \twhile (t --) {\t\tsolve();\t}  \treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "greedy",
        "math"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G1. The Destruction of the Universe  Easy Version .json",
    "hint": []
}