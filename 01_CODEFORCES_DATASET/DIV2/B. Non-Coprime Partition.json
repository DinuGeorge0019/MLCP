{"link": "https://codeforces.com//contest/1038/problem/B", "problemId": "216022", "problem_idx": "B", "shortId": "1038B", "contest_number": "1038", "problem_submissions": {"F": [42582709, 42588924], "E": [42575080, 42578573, 42575208, 42576431, 42577789, 42580719, 42575666, 42580571, 42583311, 42581396, 42582088, 42580954, 42583334, 42579643, 42582008, 42580920, 42583129, 42582580, 42583754], "D": [42573485, 42569896, 42569634, 42567012, 42572149, 42570113, 42576120, 42571013, 42565752, 42571052, 42574327, 42570312, 42567294, 42575127, 42575057, 42572394, 42574539, 42573852, 42573051], "C": [42566710, 42563399, 42564810, 42563947, 42567501, 42564966, 42562683, 42566829, 42562396, 42564608, 42563976, 42565121, 42570852, 42564983, 42565516, 42568404, 42566048, 42568514, 42566544], "B": [42560979, 42561635, 42561921, 42561073, 42563881, 42561586, 42565172, 42563091, 42560475, 42561602, 42561362, 42562336, 42564791, 42568121, 42563027, 42564081, 42563007, 42563149, 42562895], "A": [42559251, 42559046, 42559189, 42559233, 42563411, 42559174, 42559467, 42559825, 42558982, 42559283, 42559010, 42559078, 42560087, 42561636, 42561187, 42559807, 42559670, 42559820, 42559436]}, "name": "B. Non-Coprime Partition", "statement": "Find out if it is possible to partition the first n positive integers\r\ninto two disjoint sets S_1 and S_2 such that:\r\nmathrm{gcd}(\r\nmathrm{sum}(S_1),\r\nmathrm{sum}(S_2)) > 1 Here\r\nmathrm{sum}(S) denotes the sum of all elements present in set S and\r\nmathrm{gcd} means thegreatest common divisor.Every integer number from 1\r\nto n should be present in of S_1 or S_2.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(\"%lld\", &x); return x;}\nvoid read(char *s){scanf(\"%s\", s);}\nvoid no(){printf(\"No\"); exit(0);}\n\n#define maxn 120000\n#define maxm\n\n\nint main(){\n\tLL n = read();\n\tLL s = n * (n + 1) / 2;\n\tfor(int i = 2; i <= n; i += 1){\n\t\tif(s % i == 0){\n\t\t\tprintf(\"Yes\\n1 %d\\n%lld \", i, n - 1);\n\t\t\tfor(int j = 1; j <= n; j += 1) if(j != i) printf(\"%d \", j);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tno();\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "1100", "interactive": false}