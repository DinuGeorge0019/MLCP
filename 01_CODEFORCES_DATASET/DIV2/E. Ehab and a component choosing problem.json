{
    "link": "https://codeforces.com//contest/1088/problem/E",
    "problemId": "265515",
    "problem_idx": "E",
    "shortId": "1088E",
    "contest_number": "1088",
    "problem_submissions": {
        "E": [
            46613818,
            46607141,
            46622308,
            46615414,
            46615340,
            46613967,
            46615252,
            46616546,
            46614495,
            46614700,
            46614606,
            46614754,
            46614788,
            46616179,
            46615460,
            46618581,
            46617501,
            46617370,
            46614755,
            46616173,
            46613969
        ],
        "D": [
            46606352,
            46614493,
            46605224,
            46604678,
            46601623,
            46606254,
            46607253,
            46607426,
            46610831,
            46610433,
            46609743,
            46607835,
            46609488,
            46611474,
            46605699,
            46607479,
            46607462,
            46610178,
            46612056,
            46614466
        ],
        "C": [
            46599870,
            46601168,
            46596733,
            46596413,
            46608489,
            46598333,
            46599765,
            46596362,
            46601546,
            46599406,
            46601980,
            46598703,
            46596638,
            46598616,
            46598412,
            46594224,
            46598573,
            46596310,
            46600636,
            46598721
        ],
        "B": [
            46592520,
            46594336,
            46592669,
            46592597,
            46593347,
            46594184,
            46593000,
            46591239,
            46592041,
            46594521,
            46593534,
            46592218,
            46591250,
            46592164,
            46592604,
            46591755,
            46592804,
            46591647,
            46593144,
            46598081
        ],
        "A": [
            46589019,
            46591880,
            46588772,
            46590862,
            46589318,
            46592306,
            46588857,
            46588804,
            46589750,
            46594413,
            46591038,
            46589043,
            46589388,
            46588963,
            46589855,
            46588950,
            46589641,
            46588846,
            46589211,
            46597672
        ],
        "F": [
            46647126,
            46717273
        ]
    },
    "name": "E. Ehab and a component choosing problem",
    "statement": "You’re given a tree consisting of n nodes. Every node u has a weight\r\na_u. You want to choose an integer k (1\r\nle k\r\nle n) and then choose k connected components of nodes that don’t overlap\r\n(i.e every node is in at most 1 component). Let the set of nodes you\r\nchose be s. You want to maximize:\r\nfrac{\r\nsum\r\nlimits_{u\r\nin s} a_u}{k}In other words, you want to maximize the sum of weights of\r\nnodes in s divided by the number of connected components you chose.\r\nAlso, if there are several solutions, you want to .Note that adjacent\r\nnodes belong to different components. Refer to the third sample.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define _ << \" _ \" <<\n#define TRACE(x) cout << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst int MaxN = 3e5 + 10;\nint n;\nll a[MaxN];\nvector<int> e[MaxN];\n\nll m = -1e9 - 10, cnt = 0;\n\nll dfs(int i, int par) {\n    ll sum = a[i];\n\n    for (int j : e[i]) {\n        if (j == par) continue;\n        sum += max(0LL, dfs(j, i));\n    }\n\n    m = max(m, sum);\n\n    return sum;\n}\n\nll dfs2(int i, int par) {\n    ll sum = a[i];\n\n    for (int j : e[i]) {\n        if (j == par) continue;\n        sum += max(0LL, dfs2(j, i));\n    }\n\n    if (sum == m) {\n        cnt++;\n        sum = 0;\n    }\n\n    return sum;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n\n    dfs(0, 0);\n    dfs2(0, 0);\n    \n    cout << cnt * m << \" \" << cnt << \"\\n\"; \n\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ehab and a component choosing problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/63656",
    "editorial": "Assume you already chose the components. Let the sum of nodes in the\r\ncomponent be . Then, the expression in the problem is equivalent to .\r\nAssume we only bother about the fraction maximization problem and donât\r\ncare about . Then, itâll always be better to choose the component with\r\nthe maximum and throw away the rest! This is because of the famous\r\ninequality: and the equality only occurs if all are equal! This means\r\nthat the maximum value of the fraction is simply the maximum sum of a\r\nsub-component in the tree. To calculate it, letâs root the tree at node\r\n1, and calculate , the maximum sum of a sub-component that contains\r\nnode. Now, Iâll put the code, and explain it after. denotes the maximum\r\nsub-component sum. First, we call . We calculate the of all the children\r\nof . For every child , we extend the component of with the component of\r\nif , and do nothing otherwise. Now, we solved the first half of our\r\nproblem, but what about maximizing ? Notice that all components you\r\nchoose must have a sum of weights equal to (because the equality occurs\r\nif and only if all are equal). You just want to maximize their count.\r\nLetâs calculate our again. Assume . We have 2 choices: either mark the\r\nand its component as a component in the answer (but then other nodes\r\nwonât be able to use them because the components canât overlap), or wait\r\nand extend the component. The idea is that thereâs no reason to wait. If\r\nwe extend the component with some nodes, they wonât change the sum, and\r\nthey may even have another sub-component with maximal sum that weâre\r\nmerging to our component and wasting it! Thus, weâll always go with the\r\nfirst choice, making so that its parent canât use it, and increasing :D\r\nCode link: https://pastebin.com/8pCrTfuP Time complexity: .\r\n",
    "hint": []
}