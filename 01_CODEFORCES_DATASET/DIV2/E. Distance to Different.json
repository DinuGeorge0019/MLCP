{
    "link": "https://codeforces.com//contest/1989/problem/E",
    "problemId": "2721698",
    "problem_idx": "E",
    "shortId": "1989E",
    "contest_number": "1989",
    "problem_submissions": {
        "F": [
            267852420,
            267715974,
            267712917,
            267719491,
            267734751,
            267735803,
            267741899,
            267747574,
            267768221,
            267767174,
            267766869,
            267748546,
            267750041,
            267754842,
            267760865,
            267768505,
            267763937,
            267766037,
            267765066,
            267764999,
            267764810
        ],
        "E": [
            267696430,
            267693533,
            267711891,
            267704153,
            267703845,
            267698823,
            267707139,
            267719026,
            267719849,
            267686019,
            267704171,
            267710707,
            267716623,
            267703403,
            267709172,
            267702509,
            267704995,
            267705649,
            267709118
        ],
        "D": [
            267685825,
            267682182,
            267696815,
            267692972,
            267693652,
            267703361,
            267692957,
            267722874,
            267708867,
            267680276,
            267687696,
            267691183,
            267686958,
            267692334,
            267690676,
            267692452,
            267695564,
            267692758,
            267700297
        ],
        "C": [
            267675529,
            267714300,
            267687642,
            267680264,
            267681105,
            267674205,
            267682216,
            267688126,
            267695068,
            267674713,
            267675536,
            267677226,
            267678584,
            267680860,
            267675171,
            267678912,
            267682170,
            267685177,
            267679841
        ],
        "B": [
            267671283,
            267671757,
            267674622,
            267674567,
            267676014,
            267669993,
            267681783,
            267674853,
            267678346,
            267669871,
            267670383,
            267672053,
            267670683,
            267671626,
            267671697,
            267674321,
            267674468,
            267673455,
            267671951
        ],
        "A": [
            267669443,
            267669849,
            267669717,
            267672060,
            267669107,
            267669168,
            267670166,
            267670012,
            267669413,
            267669118,
            267669169,
            267669489,
            267669101,
            267669245,
            267670092,
            267669875,
            267671315,
            267671181,
            267669241
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/130988",
    "editorial": "Consider a block of equal elements in a\n. If we split a\n into such blocks, we can consider each block separately \u0097 for each element, we need only the distance to the closest border of the block (except for the first and the last block, where we consider only one border). It's quite easy to see that if the length of the block is even (let's say it's 2x\n), then the distances for the elements in this block are [1,2,3,\u0085,x?1,x,x,x?1,\u0085,3,2,1]\n. And if the length of the block is odd (let's say it's 2x?1\n), the distances are [1,2,3,\u0085,x?1,x,x?1,\u0085,3,2,1]\n. Now we don't need the actual values in a\n, we only need the information about the blocks of equal elements.\n\nWe need at least k\n blocks of equal elements in a\n, since if the number of blocks is less than k\n, it's impossible for the array a\n to have k\n different values (and if there are at least k\n blocks, it's possible to assign each block a value so that every integer from 1\n to k\n appears). So, it looks like we need to calculate the number of ways to split the array into at least k\n blocks.\n\nHowever, this only works if there is a bijection between the ways to split the array and the resulting arrays b\n. Unfortunately, some ways to split the array might result in the same distance array: for example, the distance array [1,1,1,1]\n can be obtained either by splitting into four blocks of size 1\n, or into three blocks, the middle of which has size 2\n. So, if there is a block of size 2\n, and it is not the first or the last block in the split, it can be replaced with two blocks of size 1\n, and nothing changes (except for the number of blocks, which goes up).\n\nThankfully, this is the only such situation we need to handle: any block longer than 2\n can be uniquely determined by the values in the middle of it (if there is a value x\n which is greater than both its neighbors, it is the middle of a block of size 2x?1\n; and if there is a pair of values x\n which are greater than both the value to the left and the value to the right, it is the middle of a block of size 2x\n).\n\nSo, we need to count the number of ways to split the array of size n\n into at least k\n blocks so that only the first and the last block can have size 2\n. This can be done with the following dynamic programming: let dpi,j\n be the number of ways to split the first i\n elements into j\n blocks.\n\nThis looks like it works in O(n3)\n, but we can use two improvements to speed this up:\n\nthe values j>k\n are treated identically to the values j=k\n, so we can limit the value of j\n to k\n and say that dpi,j\n is the number of ways to split the first i\n elements into at least j\n blocks if j=k\n;\nwe can do transitions in O(1)\n instead of O(n)\n by using partial sums.\nCombining these two optimizations, we get a solution in O(nk)\n.",
    "name": "E. Distance to Different",
    "statement": "Consider an array a of n integers, where every element is from 1 to k,\r\nand every integer from 1 to k appears .Let the array b be constructed as\r\nfollows: for the i-th element of a, b_i is the distance to the closest\r\nelement in a which is not equal to a_i. In other words, b_i =\r\nmin\r\nlimits_{j\r\nin [1, n], a_j\r\nne a_i} |i - j|.For example, if a = [1, 1, 2, 3, 3, 3, 3, 1], then b =\r\n[2, 1, 1, 1, 2, 2, 1, 1].Calculate the number of different arrays b you\r\ncan obtain if you consider all possible arrays a, and print it modulo\r\n998244353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;\u00a0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\u00a0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\u00a0using pii=pair<int,int>;using pll=pair<ll,ll>;\u00a0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\u00a0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\u00a0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\u00a0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\u00a0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\u00a0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\u00a0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\u00a0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\u00a0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;}\u00a0#ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif\u00a0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\u00a0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\u00a0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\u00a0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\u00a0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\u00a0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\u00a0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\u00a0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\u00a0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\u00a0\u00a0\u00a0#include <utility>\u00a0namespace atcoder {\u00a0namespace internal {\u00a0// @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;}\u00a0// Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;\u00a0    // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\u00a0    // @return m    unsigned int umod() const { return _m; }\u00a0    // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay\u00a0        // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }};\u00a0// @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;}\u00a0// Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n);\u00a0// @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};\u00a0    // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;\u00a0    while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\u00a0        // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b\u00a0        auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};}\u00a0// Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0\u00a0#include <cassert>#include <numeric>#include <type_traits>\u00a0namespace atcoder {\u00a0namespace internal {\u00a0#ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>;\u00a0template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type;\u00a0template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type;\u00a0template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type;\u00a0#else\u00a0template <class T> using is_integral = typename std::is_integral<T>;\u00a0template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type;\u00a0#endif\u00a0template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\u00a0template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\u00a0template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0#include <cassert>#include <numeric>#include <type_traits>\u00a0#ifdef _MSC_VER#include <intrin.h>#endif\u00a0namespace atcoder {\u00a0namespace internal {\u00a0struct modint_base {};struct static_modint_base : modint_base {};\u00a0template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\u00a0}  // namespace internal\u00a0template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;\u00a0  public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\u00a0    static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\u00a0    unsigned int val() const { return _v; }\u00a0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\u00a0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\u00a0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\u00a0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }\u00a0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\u00a0  private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;};\u00a0template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;\u00a0  public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\u00a0    dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\u00a0    unsigned int val() const { return _v; }\u00a0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\u00a0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\u00a0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\u00a0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }\u00a0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\u00a0  private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\u00a0using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>;\u00a0namespace internal {\u00a0template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\u00a0template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\u00a0template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\u00a0template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0using namespace atcoder;\u00a0using mint=modint998244353;//using mint=modint1000000007;\u00a0void ahcorz(){    int n,k; cin >> n >> k;    mint dp[2][2][k+1];    dp[0][0][0]=1;    rep(_,n){        mint ndp[2][2][k+1];        rep(2) rep(j,2) rep(cnt,k+1){            if(!(i==0&&j==1)){                ndp[j][0][cnt]+=dp[i][j][cnt];            }            int ncnt=cnt;            if(j==1) ncnt++;            chmin(ncnt,k-1);            ndp[j][1][ncnt]+=dp[i][j][cnt];        }        rep(2) rep(j,2) rep(cnt,k+1) dp[i][j][cnt]=ndp[i][j][cnt];    }    mint res;    rep(2) rep(j,2) if(!(i==0&&j==1)) res+=dp[i][j][k-1];    print(res.val());}\u00a0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Distance to Different.json"
}