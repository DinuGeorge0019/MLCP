{
    "link": "https://codeforces.com//contest/456/problem/E",
    "problemId": "12126",
    "problem_idx": "E",
    "shortId": "456E",
    "contest_number": "456",
    "problem_submissions": {
        "D": [
            7394195,
            7387334,
            7388194,
            7405631,
            7391438,
            7570888,
            7392150,
            7392407,
            7393420,
            7393011,
            7390869,
            7412347,
            7393749,
            7391710,
            7395518,
            7389615
        ],
        "E": [
            7391057,
            7389574,
            7398919,
            7392485,
            7391618,
            7395429,
            7414900,
            7394901,
            7394000,
            7407156,
            7407099,
            7394565
        ],
        "C": [
            7384935,
            7379979,
            7382777,
            7382760,
            7382268,
            7385285,
            7383719,
            7382555,
            7385127,
            7383651,
            7381928,
            7379735,
            7383336,
            7384288,
            7385361,
            7383584,
            7385744,
            7383852,
            7380739
        ],
        "A": [
            7381212,
            7377201,
            7377560,
            7377220,
            7377312,
            7379694,
            7377445,
            7377742,
            7377341,
            7377480,
            7377279,
            7382703,
            7377573,
            7378438,
            7377375,
            7377583,
            7379362,
            7377853,
            7384952
        ],
        "B": [
            7380090,
            7378182,
            7380801,
            7379345,
            7379559,
            7382230,
            7379187,
            7379755,
            7379683,
            7379290,
            7381183,
            7380009,
            7380898,
            7380752,
            7380004,
            7381407,
            7380326,
            7387312
        ]
    },
    "name": "E. Civilization",
    "statement": "Andrew plays a game called \"Civilization\". Dima helps him.The game has\r\ncities and bidirectional roads. The cities are numbered from to .\r\nBetween any pair of cities there either is a single (unique) path, or\r\nthere is no path at all. A path is such a sequence of distinct cities ,\r\nthat there is a road between any contiguous cities and (). The length of\r\nthe described path equals to . We assume that two cities lie in the same\r\nregion if and only if, there is a path connecting these two\r\ncities.During the game events of two types take place: Andrew asks Dima\r\nabout the length of the longest path in the region where city lies.\r\nAndrew asks Dima to merge the region where city lies with the region\r\nwhere city lies. If the cities lie in the same region, then no merging\r\nis needed. Otherwise, you need to merge the regions as follows: choose a\r\ncity from the first region, a city from the second region and connect\r\nthem by a road so as to minimize the length of the longest path in the\r\nresulting region. If there are multiple ways to do so, you are allowed\r\nto choose any of them. Dima finds it hard to execute Andrewâ€™s queries,\r\nso he asks you to help him. Help Dima.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n\nusing namespace std;\n\nint Z[300005], op, num, m;\nint U[300005], Q[300005], V[300005], G[300005], D[300005], ctos, aristas, pregs, a, b, ult, g, son, mas, chico, quien;\nvector<int> L[300005];\n\nvoid up(int dnde){\n    if(U[dnde]==dnde){\n        ult=dnde;\n    }\n    else {\n        up(U[dnde]);\n        U[dnde]=ult;\n    }\n}\n\nvoid une(int x, int y){\n    up(x);\n    up(y);\n    if(U[x]==U[y]){\n        return ;\n    }\n    x=U[x];\n    y=U[y];\n\n\n    G[y]=max(max(G[x], G[y]), V[x]+1+V[y]);\n\n    m=V[x];\n    V[x]=max(V[x], V[y]+1);\n    V[y]=max(V[y], m+1);\n    if(V[x]<V[y]){\n        V[y]=V[x];\n        Q[y]=Q[x];\n    }\n\n    U[x]=y;\n}\n\nvoid aslo(int dnde, int lleva){\n    if(Z[dnde]==son)\n        return ;\n    Z[dnde]=son;\n    if(lleva>mas){\n        mas=lleva;\n        g=dnde;\n    }\n    if(D[dnde]<lleva)\n        D[dnde]=lleva;\n    if(D[dnde]<chico){\n        chico=D[dnde];\n        quien=dnde;\n    }\n    for(int i=0; i<L[dnde].size(); i++){\n        aslo(L[dnde][i], lleva+1);\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d%d\",&ctos,&aristas,&pregs);\n    for(int i=1; i<=ctos; i++){\n        U[i]=i;\n    }\n    for(int i=1; i<=aristas; i++){\n        scanf(\"%d%d\",&a,&b);\n        L[a].push_back(b);\n        L[b].push_back(a);\n        une(a, b);\n    }\n\n    for(int i=1; i<=ctos; i++){\n        if(Z[i]==0){\n            up(i);\n\n            ++son;\n            mas=-1;\n            aslo(i, 0);\n            ++son;\n            mas=-1;\n            aslo(g, 0);\n\n            G[U[i]]=mas;\n\n            ++son;\n            mas=-1;\n            chico=1000000000;\n            aslo(g, 0);\n\n            Q[U[i]]=quien;\n            V[U[i]]=chico;\n        }\n    }\n    for(int i=1; i<=pregs; i++){\n        scanf(\"%d\",&op);\n        if(op==1){\n            scanf(\"%d\",&num);\n            up(num);\n            printf(\"%d\\n\",G[U[num]]);\n        }\n        else {\n            scanf(\"%d%d\",&a,&b);\n            une(a, b);\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Civilization.json",
    "editorial_link": "https://codeforces.com//blog/entry/13336",
    "editorial": "You can see that the road system is a\nforest. For efficient storage component we need to use DSU. First, we\nneed to build the initial system of roads. For each component of the\ninitial road system, we must find the diameter of component. This can be\ndone using a DFS or BFS. Let any vertex of component. Let furthest\nvertex from vertex . Let furthest vertex from vertex . Diameter equal to\ndistance from to . This algorithm for finding the diameter is correct\nonly for tree. For each component in the DSU, we know its diameter. Now\nit is very easy to answer the query of the 1st type: To know the\ncomponent which contains the vertex and output diameter of this\ncomponent. Query of the 2nd type also very easy to process: Let of\ncomponent in which lie the vertex , of component in which lie the vertex\n. If , then we can merge components: The diameter of the new component\nis computed as follows: Asymptotics , inverse Ackermann function.\n",
    "hint": []
}