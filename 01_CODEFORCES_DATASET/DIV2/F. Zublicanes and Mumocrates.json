{
    "link": "https://codeforces.com//contest/581/problem/F",
    "problemId": "36595",
    "problem_idx": "F",
    "shortId": "581F",
    "contest_number": "581",
    "problem_submissions": {
        "F": [
            13269721,
            13273884,
            13274265,
            13275076,
            13273744,
            28883204,
            28746729,
            47707720
        ],
        "D": [
            13265543,
            13266561,
            13267830,
            13267677,
            13269943,
            13268843,
            13267395,
            13266212,
            13271770,
            13271940,
            13275900,
            13267190,
            13291663,
            13273782,
            13269289,
            13268754,
            13272747,
            13271148,
            13266871
        ],
        "C": [
            13263338,
            13262839,
            13263933,
            13262818,
            13262223,
            13263848,
            13264045,
            13262035,
            13264956,
            13270049,
            13269879,
            13263828,
            13264992,
            13264829,
            13264204,
            13266233,
            13265980,
            13264067,
            13263215
        ],
        "B": [
            13262072,
            13261090,
            13262462,
            13261193,
            13266387,
            13261281,
            13260860,
            13260910,
            13262535,
            13261711,
            13263433,
            13261203,
            13261560,
            13261063,
            13261266,
            13262720,
            13262876,
            13261537,
            13260790
        ],
        "A": [
            13260348,
            13259765,
            13260479,
            13259829,
            13262614,
            13259668,
            13259435,
            13259565,
            13260421,
            13259502,
            13259898,
            13259464,
            13259945,
            13259651,
            13259594,
            13259520,
            13260392,
            13260013,
            13259545
        ],
        "E": []
    },
    "name": "F. Zublicanes and Mumocrates",
    "statement": "It\u2019s election time in Berland. The favorites are of course parties of\r\nzublicanes and mumocrates. The election campaigns of both parties\r\ninclude numerous demonstrations on main squares of the capital of\r\nBerland. Each of the squares certainly can have demonstrations of only\r\none party, otherwise it could lead to riots. On the other hand, both\r\nparties have applied to host a huge number of demonstrations, so that on\r\nall squares demonstrations must be held. Now the capital management will\r\ndistribute the area between the two parties.Some pairs of squares are\r\nconnected by bidirectional roads such that between any pair of squares\r\nthere is a unique way to get from one square to another. Some squares\r\nare on the outskirts of the capital meaning that they are connected by a\r\nroad with only one other square, such squares are called squares.The\r\nmayor of the capital instructed to distribute all the squares between\r\nthe parties so that the squares had the same number of demonstrations of\r\nthe first and the second party. It is guaranteed that the number of dead\r\nend squares of the city is even.To prevent possible conflicts between\r\nthe zublicanes and the mumocrates it was decided to minimize the number\r\nof roads connecting the squares with the distinct parties. You, as a\r\ndeveloper of the department of distributing squares, should determine\r\nthis smallest number.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint dp[5010][5010][2];\nstruct Bian\n{\n    int s,t,last;\n}bian[10010];\nint last[5010],maxbian=0,d[10010],v[10010],sz[10010];\nvoid addbian(int s,int t)\n{\n    maxbian++;\n    bian[maxbian].s=s;\n    bian[maxbian].t=t;\n    bian[maxbian].last=last[s];\n    last[s]=maxbian;\n    d[s]++;\n    d[t]++;\n}\nvoid dfs(int i)\n{\n    v[i]=1;\n    int f=0;\n    for(int j=0;j<=5000;j++)\n        dp[i][j][1]=dp[i][j][0]=inf;\n    for(int j=last[i];j;j=bian[j].last)\n        if(!v[bian[j].t])\n        {\n            f++;\n            if(f==1)\n            dp[i][0][0]=dp[i][0][1]=0;\n            dfs(bian[j].t);\n            for(int k=sz[i];k>=0;k--)\n                for(int l=sz[bian[j].t];l>=0;l--)\n                    if(k==sz[i]||l==0)\n                    {\n                        dp[i][k+l][0]=min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]);\n                        dp[i][k+l][1]=min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]);\n                    }\n                    else\n                    {\n                        dp[i][k+l][0]=min(dp[i][k+l][0],min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]));\n                        dp[i][k+l][1]=min(dp[i][k+l][1],min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]));\n                    }   \n            sz[i]+=sz[bian[j].t];\n        }\n    if(f==0)\n    {\n        dp[i][1][1]=dp[i][0][0]=0;\n        sz[i]=1;\n    }\n//  for(int j=0;j<=sz[i];j++)\n    //  for(int k=0;k<=1;k++)\n        //  cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n}\nint main()\n{\n    int n,n1,t1,t2;\n    cin>>n;\n    if(n==2)\n    {\n        cout<<1;\n        return 0;\n    }\n    for(n1=1;n1<n;n1++)\n    {\n        cin>>t1>>t2;\n        addbian(t1,t2);\n        addbian(t2,t1);\n    }\n    int f=0;\n    for(n1=1;n1<=n;n1++)\n    {\n        if(d[n1]==2)\n            f++;\n    }\n    for(n1=1;n1<=n;n1++)\n        if(d[n1]>2)\n        {\n            dfs(n1);\n            cout<<min(dp[n1][f/2][0],dp[n1][f/2][1]);\n            return 0;\n        }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Zublicanes and Mumocrates.json",
    "editorial_link": "https://codeforces.com//blog/entry/20508",
    "editorial": "Let the number of leavs in tree (vertices with degree 1) is equal to c. It said in statement that c is even. If in given graph only 2 vertices the answer is equal to 1. Else we have vertex in graph which do not a leaf \u0097 we hang the three on this vertex.\n\nNow we need to count 2 dynamics. The first z1[v][cnt][col] \u0097 the least amount of colored edges in the subtree rooted at the vertex v, if vertex v already painted in color col (col equals to 0 or to 1), and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0. If we are in the leaf, it is easy to count this value. If we are not in the leaf \u0097 we count value with help of dynamic z1[v][cnt][col]:??=?z2[s][cnt][col], where s \u0097 the first child int the adjacency list of vertex v.\n\nWe need the second dynamic z2[s][cnt][col] to spread cnt leaves with color 0 among subtrees of childs of vertex v. To calc z2[s][cnt][col] we brute the color of child s \u0097 ncol and the number of childs i with color 0, which will be locate in subtree of vertex s and calc the value in the following way \u0097 z2[s][cnt][col]?=?min(z2[s][cnt][col],?z2[ns][cnt\u0096a][col]?+?z1[s][a][ncol]?+?(ncol!?=?col)), where ns \u0097 the next child of vertex v after the child s. Note, that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree \u0097 sizes (because in that case it will not be enough leaves for painting).\n\nThe upper bound of asymptotic for such dynamics O(n3). We show that in fact it works with asymptotic O(n2). Let's count the number of updates: . Note, that every pair of vertices (x,?y) appears in the last sum (x,?y) exactly once when v?=?lca(x,?y). So we have no more than O(n2) updates."
}