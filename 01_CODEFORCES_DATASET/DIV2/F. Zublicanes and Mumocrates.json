{"link": "https://codeforces.com//contest/581/problem/F", "problemId": "36595", "problem_idx": "F", "shortId": "581F", "contest_number": "581", "problem_submissions": {"F": [13269721, 13273884, 13274265, 13275076, 13273744, 28883204, 28746729, 47707720], "D": [13265543, 13266561, 13267830, 13267677, 13269943, 13268843, 13267395, 13266212, 13271770, 13271940, 13275900, 13267190, 13291663, 13273782, 13269289, 13268754, 13272747, 13271148, 13266871], "C": [13263338, 13262839, 13263933, 13262818, 13262223, 13263848, 13264045, 13262035, 13264956, 13270049, 13269879, 13263828, 13264992, 13264829, 13264204, 13266233, 13265980, 13264067, 13263215], "B": [13262072, 13261090, 13262462, 13261193, 13266387, 13261281, 13260860, 13260910, 13262535, 13261711, 13263433, 13261203, 13261560, 13261063, 13261266, 13262720, 13262876, 13261537, 13260790], "A": [13260348, 13259765, 13260479, 13259829, 13262614, 13259668, 13259435, 13259565, 13260421, 13259502, 13259898, 13259464, 13259945, 13259651, 13259594, 13259520, 13260392, 13260013, 13259545], "E": []}, "name": "F. Zublicanes and Mumocrates", "statement": "It\u2019s election time in Berland. The favorites are of course parties of\r\nzublicanes and mumocrates. The election campaigns of both parties\r\ninclude numerous demonstrations on main squares of the capital of\r\nBerland. Each of the squares certainly can have demonstrations of only\r\none party, otherwise it could lead to riots. On the other hand, both\r\nparties have applied to host a huge number of demonstrations, so that on\r\nall squares demonstrations must be held. Now the capital management will\r\ndistribute the area between the two parties.Some pairs of squares are\r\nconnected by bidirectional roads such that between any pair of squares\r\nthere is a unique way to get from one square to another. Some squares\r\nare on the outskirts of the capital meaning that they are connected by a\r\nroad with only one other square, such squares are called squares.The\r\nmayor of the capital instructed to distribute all the squares between\r\nthe parties so that the squares had the same number of demonstrations of\r\nthe first and the second party. It is guaranteed that the number of dead\r\nend squares of the city is even.To prevent possible conflicts between\r\nthe zublicanes and the mumocrates it was decided to minimize the number\r\nof roads connecting the squares with the distinct parties. You, as a\r\ndeveloper of the department of distributing squares, should determine\r\nthis smallest number.\r\n", "solutions": ["#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint dp[5010][5010][2];\nstruct Bian\n{\n    int s,t,last;\n}bian[10010];\nint last[5010],maxbian=0,d[10010],v[10010],sz[10010];\nvoid addbian(int s,int t)\n{\n    maxbian++;\n    bian[maxbian].s=s;\n    bian[maxbian].t=t;\n    bian[maxbian].last=last[s];\n    last[s]=maxbian;\n    d[s]++;\n    d[t]++;\n}\nvoid dfs(int i)\n{\n    v[i]=1;\n    int f=0;\n    for(int j=0;j<=5000;j++)\n        dp[i][j][1]=dp[i][j][0]=inf;\n    for(int j=last[i];j;j=bian[j].last)\n        if(!v[bian[j].t])\n        {\n            f++;\n            if(f==1)\n            dp[i][0][0]=dp[i][0][1]=0;\n            dfs(bian[j].t);\n            for(int k=sz[i];k>=0;k--)\n                for(int l=sz[bian[j].t];l>=0;l--)\n                    if(k==sz[i]||l==0)\n                    {\n                        dp[i][k+l][0]=min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]);\n                        dp[i][k+l][1]=min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]);\n                    }\n                    else\n                    {\n                        dp[i][k+l][0]=min(dp[i][k+l][0],min(dp[i][k][0]+dp[bian[j].t][l][1]+1,dp[i][k][0]+dp[bian[j].t][l][0]));\n                        dp[i][k+l][1]=min(dp[i][k+l][1],min(dp[i][k][1]+dp[bian[j].t][l][0]+1,dp[i][k][1]+dp[bian[j].t][l][1]));\n                    }   \n            sz[i]+=sz[bian[j].t];\n        }\n    if(f==0)\n    {\n        dp[i][1][1]=dp[i][0][0]=0;\n        sz[i]=1;\n    }\n//  for(int j=0;j<=sz[i];j++)\n    //  for(int k=0;k<=1;k++)\n        //  cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n}\nint main()\n{\n    int n,n1,t1,t2;\n    cin>>n;\n    if(n==2)\n    {\n        cout<<1;\n        return 0;\n    }\n    for(n1=1;n1<n;n1++)\n    {\n        cin>>t1>>t2;\n        addbian(t1,t2);\n        addbian(t2,t1);\n    }\n    int f=0;\n    for(n1=1;n1<=n;n1++)\n    {\n        if(d[n1]==2)\n            f++;\n    }\n    for(n1=1;n1<=n;n1++)\n        if(d[n1]>2)\n        {\n            dfs(n1);\n            cout<<min(dp[n1][f/2][0],dp[n1][f/2][1]);\n            return 0;\n        }\n}\n"], "input": "", "output": "", "tags": ["dp", "trees", "two pointers"], "dificulty": "2400", "interactive": false}