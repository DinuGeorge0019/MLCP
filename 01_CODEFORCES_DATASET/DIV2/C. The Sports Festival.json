{
    "link": "https://codeforces.com//contest/1509/problem/C",
    "problemId": "958789",
    "problem_idx": "C",
    "shortId": "1509C",
    "contest_number": "1509",
    "problem_submissions": {
        "F": [
            113256937,
            113452435,
            113285395
        ],
        "E": [
            113232874,
            113219267,
            113224061,
            113223560,
            113233730,
            113226238,
            113242617,
            113234728,
            113229028,
            113234613,
            113236691,
            113233309,
            113237999,
            113236924,
            113234998,
            113244661,
            113248199,
            113294044,
            113242554,
            113241170,
            113238407
        ],
        "D": [
            113221122,
            113205083,
            113211524,
            113212503,
            113218682,
            113218702,
            113210079,
            113222981,
            113224859,
            113213502,
            113222656,
            113222165,
            113224508,
            113227361,
            113205851,
            113214932,
            113213501,
            113214642,
            113227110,
            113229498
        ],
        "C": [
            113210555,
            113197246,
            113200376,
            113200962,
            113204903,
            113197040,
            113198240,
            113210183,
            113210598,
            113200328,
            113196898,
            113203900,
            113204261,
            113210665,
            113209464,
            113204447,
            113203994,
            113206401,
            113202494,
            113202048
        ],
        "B": [
            113194717,
            113193937,
            113192191,
            113190108,
            113198761,
            113232450,
            113190578,
            113195766,
            113197868,
            113220965,
            113207035,
            113194479,
            113196536,
            113224188,
            113200860,
            113198840,
            113198891,
            113192926,
            113195317
        ],
        "A": [
            113186426,
            113184937,
            113185796,
            113185053,
            113185023,
            113184968,
            113185012,
            113185414,
            113185256,
            113188852,
            113200720,
            113185467,
            113185688,
            113212116,
            113186288,
            113188479,
            113188850,
            113184903,
            113188945
        ]
    },
    "name": "C. The Sports Festival",
    "statement": "The student council is preparing for the relay race at the sports\r\nfestival.The council consists of n members. They will run one after the\r\nother in the race, the speed of member i is s_i. The d_i of the i-th\r\nstage is the difference between the maximum and the minimum running\r\nspeed among the first i members who ran. Formally, if a_i denotes the\r\nspeed of the i-th member who participated in the race, then d_i =\r\nmax(a_1, a_2,\r\ndots, a_i) -\r\nmin(a_1, a_2,\r\ndots, a_i).You want to minimize the sum of the discrepancies d_1 + d_2 +\r\ndots + d_n. To do this, you are allowed to change the order in which the\r\nmembers run. What is the minimum possible sum that can be achieved?\r\n",
    "solutions": [
        "#include <ctime>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma warning(disable : 4996)\n#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <math.h>\n#include <cassert>\n#include <unordered_map>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define len(s) (int)(s).size()\n// #define endl '\\n'\n\n\ninline void accell() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n}\n\ntemplate<class T> ostream& operator<< (ostream& out, const pair<int, int>&X) {\n    out << X.first << ' ' << X.second << endl;\n    return out;\n}\n\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T> &X) {\n    for (const auto& it : X)\n        out << it << ' ';\n    return out;\n}\ntemplate<class T> ostream& operator<< (ostream& out, const set<T> &X) {\n    for (const auto& it : X)\n        out << it << ' ';\n    return out;\n}\ntemplate<class T> void dbg(const T &X) {\n    cerr << \"DEBUG: \" << \": \";\n    cerr << X << endl;\n}\nconst int mod = 1e9 + 7;\nconst int N = 1e5 + 5;\n\n\nsigned main() {\n    accell();\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) \n        cin >> a[i];\n    sort(a.begin(), a.end());\n    vector<vector<int>>dp(n, vector<int>(n, 1e18));\n    int ans = 1e18;\n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 0;\n    }\n    for (int len = 0; len < n; ++len) {\n        for (int l = 0; l + len < n; ++l) {\n            int r = l + len;\n            if (r + 1 < n) {\n                dp[l][r + 1] = min(dp[l][r + 1], dp[l][r] + a[r + 1] - a[l]);\n            }\n            if (l) {\n                dp[l - 1][r] = min(dp[l - 1][r], dp[l][r] + a[r] - a[l - 1]);\n            }\n        }\n    }\n    cout << dp[0][n - 1] << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. The Sports Festival.json",
    "editorial_link": "https://codeforces.com//blog/entry/89644",
    "editorial": "Assume that the array of speeds is sorted, i.e. .The key observation is\r\nthat the last running can be assumed to be either or . This is because\r\nif and are both in the prefix of length , then clearly , which is the\r\nmaximum possible value of any discrepancy. Similarly are all equal to .\r\nThis moving either or (whichever appears last) to the very end of the\r\narray cannot possibly increase the sum of these discrepancies, since\r\nthey already have the largest possible value.If we repeat the previous\r\nobservation, we deduce that for each , the prefix of length in an\r\noptimal solution forms a contiguous subarray of the sorted array.\r\nTherefore, we may solve the problem through dynamic programming:\r\nrepresents the minimum possible answer if we solve for the subarray .\r\nClearly , and the transition is given byWhich corresponds to placing\r\neither the smallest or the largest element at the end of the sequence.\r\nThe final answer is . This allows us to solve the problem in .\r\n",
    "hint": [
        "Hint 1 What is the discrepancy of the last stage? How can we make it smaller in previous stages? Answer The discrepancy of the last stage is always the difference between the largest and the smallest . We can make it smaller in the previous stages by placing the smallest or the largest at the end.",
        "Hint 2 Use dynamic programming.",
        "Hint 1 Consider two of the strings. We can obviously achieve our goal using at most characters. How can we save some of them? Answer Take advantage of any common subsequence in our two strings by including the characters in it only once.",
        "Hint 2 Find a long common subsequence that has a simple structure. You'll need to involve the third string as well.",
        "Hint 3 Either or is a subsequence of each string.",
        "Hint 1 What is the general structure of an almost sorted permutation? Answer Start with the identity permutation, choose some disjoint subarrays, and reverse each of them.",
        "Hint 2 How many almost sorted permutations of length exist? In other words, how many ways are there to reverse subarrays? Answer",
        "Hint 3 Two options â€” either solve recursively in a greedy fashion or find a smart bijection.",
        "Hint 1 How can we solve this problem without the restriction that the xor of all edge weights is ? Answer Just assign to every unassigned edge :P",
        "Hint 2 When does the solution to the unrestricted problem fail for the real problem? Answer When any minimum spanning tree (of the graph with every unassigned edge having weight ) contains every unassigned edge, and the xor sum of all the edge weights is not .",
        "Hint 3 Leave the xor sum of the weights of the unassigned edges in the spanning tree fixed. How do we minimize their sum? Answer Assign the entire xor sum to a single edge, and assign weight to every other edge.",
        "Hint 4 Exactly one unassigned edge ends up with a non-zero weight. If we don't use all unassigned edges, which others can we use? Answer Any edge that isn't part of the MST when we consider unassigned edges to have weight , and that doesn't form a cycle with pre-assigned edges with smaller weights.",
        "Hint 1 It is always possible to find the sequence.",
        "Hint 2 There's a simple algorithm that fixes a point and repeatedly moves its current label to the correct position. When does it work? Answer When the permutation of the labels is a single cycle.",
        "Hint 3 Any permutation can be split into one or more cycles. What can we do to these cycles? Answer Merge them, by swapping two elements in different cycles.",
        "Hint 4 We would like to merge all cycles of the permutation by swapping elements in different cycles and then repeatedly move each label from a certain point to its correct location. How can we do this without intersections? Answer Fix a point beforehand to perform the final step, and sort angularly with respect to this point.",
        "Hint 1 During the process, we will repeatedly push the same label down until we no longer can. What happens at this point? Answer The labels that have been fully pushed down will look like a post-order of the tree, while the other labels will look like a pre-order of the tree.",
        "Hint 2 Look at the children of a particular vertex. What can we say about the ones that are fully pushed down in relation to the ones that aren't? Answer Every fully pushed down label is smaller than every other label.",
        "Hint 3 For each node, the order of the labels of its children stays fixed.",
        "Hint 4 How can we use the previous observations to identify the state of the process? Answer We can reconstruct the DFS order and the fully pushed down labels. Then check that the current pushing step of the process is valid.",
        "Hint 1 Start by solving the problem for -encodings only.",
        "Hint 2 We can get an encoding by including every possible edge. Which of them can we exclude? Answer We need to keep an edge if and only if no other path from to exists.",
        "Hint 3 What does the previous observation look like from the perspective of a single vertex? Answer Each vertex has at most two outgoing edges, one on each side, and we can easily characterize when one of them is redundant.",
        "Hint 4 We need to solve the full version now. For a vertex , how do the endpoints of its outgoing edges change when we add a new interval? Answer The endpoints of the right edges increase monotonically, while the endpoints of the left edges decrease monotonically.",
        "Hint 5 How can we use the previous observation to characterize edges becoming redundant more concretely? Answer For each right edge, we can find a particular left edge, such that the right edge becomes redundant once the left edge appears. This gives us an interval of times for each edge during which it is relevant.",
        "Hint 6 Use Mo's algorithm on the input intervals to find the relevant edges."
    ]
}