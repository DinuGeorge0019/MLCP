{
    "link": "https://codeforces.com//contest/1315/problem/D",
    "problemId": "547045",
    "problem_idx": "D",
    "shortId": "1315D",
    "contest_number": "1315",
    "problem_submissions": {
        "E": [
            71717972,
            71722121,
            71723928,
            71729230,
            71974152,
            72008868,
            72008805
        ],
        "B": [
            71712835,
            71705609,
            71705328,
            71705471,
            71703387,
            71704005,
            71704127,
            71704155,
            71704023,
            71705610,
            71706151,
            71706053,
            71706193,
            71704779,
            71704406,
            71705432,
            71705176,
            71707656,
            71704939
        ],
        "A": [
            71711680,
            71703327,
            71702875,
            71702517,
            71702293,
            71702355,
            71702415,
            71702704,
            71703705,
            71703020,
            71702906,
            71703383,
            71703894,
            71702683,
            71702739,
            71702868,
            71702438,
            71703823,
            71702490
        ],
        "D": [
            71705281,
            71711782,
            71710689,
            71709097,
            71706684,
            71712045,
            71709367,
            71709685,
            71709559,
            71709699,
            71712591,
            71718977,
            71710420,
            71711447,
            71712487,
            71711123,
            71711486,
            71711635,
            71712415
        ],
        "C": [
            71703583,
            71708130,
            71708191,
            71706924,
            71704462,
            71705381,
            71706364,
            71706633,
            71705353,
            71706839,
            71709056,
            71708876,
            71707615,
            71706977,
            71706123,
            71708378,
            71708224,
            71705852,
            71707083
        ],
        "F": [
            71735158,
            71754645,
            71744524,
            71744441
        ]
    },
    "name": "D. Recommendations",
    "statement": "VK news recommendation system daily selects interesting publications of\r\none of n disjoint categories for each user. Each publication belongs to\r\nexactly one category. For each category i batch algorithm selects a_i\r\npublications.The latest A/B test suggests that users are reading\r\nrecommended publications more actively if each category has a different\r\nnumber of publications within daily recommendations. The targeted\r\nalgorithm can find a single interesting publication of i-th category\r\nwithin t_i seconds. What is the minimum total time necessary to add\r\npublications to the result of batch algorithm execution, so all\r\ncategories have a different number of publications? You can’t remove\r\npublications recommended by the batch algorithm.\r\n",
    "solutions": [
        "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define R(i,a,b) for (int i=(a);i<(b);i++)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,vis[N],a[N],b[N],su,ans;\npriority_queue <int> q;\npa z[N];\nvoid solve(int x){\n\tF(i,1,x){\n\t\tif (q.empty()) break;\n\t\tint t=q.top();su-=t;\n\t\tq.pop();ans+=su;\n\t}\n}\nvoid ins(int x){\n\tsu+=z[x].se;\n\tq.push(z[x].se);\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n) z[i].fi=read();\n\tF(i,1,n) z[i].se=read();\n\tsort(z+1,z+n+1);\n\tF(i,1,n){\n\t\tint t=z[i].fi-z[i-1].fi;\n\t\tsolve(t);\n\t\tins(i);\n\t}\n\tsolve(n);\n\twrn(ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Recommendations.json",
    "editorial_link": "https://codeforces.com//blog/entry/74214",
    "editorial": "In this problem we have an array a1,,an\n, we can increase each ai\n by one with cost ti\n, and we want to make all ai\n different with minimal total cost.\n\nLet's sort ai\n in a non-decreasing way (and permute the t\n in a corresponding way). Let's see at the minimal number, a1\n. If it is unique, e.g. a1?a2\n, then we don't need to change a1\n  it is already unique, and it can't get equal to something else if we don't increase it. In this case, we can just skip a1\n and solve the smaller problem without a1\n.\n\nOtherwise, suppose there is some j>1\n such that a1=a2==aj\n. Obviously, we should leave at most one of them with the current value, and increase other j?1\n numbers by one. Which one should be not increased? We shouldn't increase the al\n (1?l?j\n) with the maximal tl\n because it minimizes the total cost. So, we should remove the maximal value tl\n among all elements with minimal al\n, and increase all other by one. This effectively reduces our problem to the smaller one, decreasing n\n by one.\n\nThis gives us a O(n2)\n solution  n\n times we discard one minimum from the array and increase all other minimums by one. We can further optimize it by using a multiset of values tl\n for all minimal al\n and its sum. At each iteration, we should (probably) add some values to a multiset, if the number of minimums in array increases, discard one maximum from multiset and add the current sum to the answer. Continue the process until the array becomes empty. This is an O(nlogn)\n solution.",
    "hint": []
}