{"link": "https://codeforces.com//contest/385/problem/E", "problemId": "5935", "problem_idx": "E", "shortId": "385E", "contest_number": "385", "problem_submissions": {"E": [5794434, 5800310, 5798100, 12839340, 5793580, 5807353, 5798624, 5795785], "D": [5791982, 5791338, 5792966, 5793920, 5795427, 5791662, 5796473, 5796329, 5793942], "C": [5788908, 5788383, 5788712, 5790434, 5789032, 5794132, 5791478, 5792236, 5791660, 5800872, 5791637, 5790324, 5790844, 5792509, 5789960, 5787897, 5791710, 5799045], "B": [5786803, 5786394, 5787527, 5788072, 5786967, 5787817, 5788240, 5790217, 5789128, 5788273, 5787714, 5788006, 5786982, 5787829, 5787905, 5791193, 5786254, 5787251, 5788615], "A": [5786226, 5789111, 5786358, 5786644, 5786233, 5788977, 5786318, 5787575, 5786766, 5786887, 5786239, 5786463, 5786289, 5786726, 5786980, 5790591, 5788602, 5792556, 5787159]}, "name": "E. Bear in the Field", "statement": "Our bear\u2019s forest has a checkered field. The checkered field is an\r\ntable, the rows are numbered from 1 to from top to bottom, the columns\r\nare numbered from 1 to from left to right. Let\u2019s denote a cell of the\r\nfield on the intersection of row and column by record . Each cell of the\r\nfield contains growing raspberry, at that, the cell of the field\r\ncontains raspberry bushes.The bear came out to walk across the field. At\r\nthe beginning of the walk his speed is . Then the bear spends exactly\r\nseconds on the field. Each second the following takes place: Let\u2019s\r\nsuppose that at the current moment the bear is in cell . First the bear\r\neats the raspberry from all the bushes he has in the current cell. After\r\nthe bear eats the raspberry from bushes, he increases each component of\r\nhis speed by . In other words, if before eating the bushes of raspberry\r\nhis speed was , then after eating the berry his speed equals . Let\u2019s\r\ndenote the current speed of the bear (it was increased after the\r\nprevious step). Then the bear moves from cell to cell . Then one\r\nadditional raspberry bush grows in each cell of the field. You task is\r\nto predict the bear\u2019s actions. Find the cell he ends up in if he starts\r\nfrom cell . Assume that each bush has infinitely much raspberry and the\r\nbear will never eat all of it.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int kMat[6][6] = {\n    2, 1, 1, 0, 1, 2,\n    1, 2, 0, 1, 1, 2,\n    1, 1, 1, 0, 1, 2,\n    1, 1, 0, 1, 1, 2,\n    0, 0, 0, 0, 1, 1,\n    0, 0, 0, 0, 0, 1\n};\nint n, sx, sy, dx, dy;\nll t;\n\nstruct Matrix {\n    int v[6][6];\n    void clear() {\n        memset(v, 0, sizeof(v));\n    }\n    Matrix() {\n        clear();\n    }\n} e, f, a;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n    Matrix c;\n    for (int i = 0; i < 6; ++ i)\n        for (int j = 0; j < 6; ++ j)\n            for (int k = 0; k < 6; ++ k)\n                c.v[i][j] = (c.v[i][j] + (ll)a.v[i][k] * b.v[k][j] % n) % n;\n    return c;\n}\n\nMatrix mat_pow(const Matrix &a, ll b) {\n    Matrix res = e, tmp = a;\n    while (b) {\n        if (b & 1) res = res * tmp;\n        b >>= 1;\n        tmp = tmp * tmp;\n    }\n    return res;\n}\n\nint main() {\n    scanf(\"%d%d%d%d%d%I64d\", &n, &sx, &sy, &dx, &dy, &t);\n    -- sx, -- sy;\n    dx = (dx % n + n) % n;\n    dy = (dy % n + n) % n;\n    for (int i = 0; i < 6; ++ i) e.v[i][i] = 1;\n    memcpy(f.v, kMat, sizeof(kMat));\n    a.v[0][0] = sx, a.v[1][0] = sy;\n    a.v[2][0] = dx, a.v[3][0] = dy;\n    a.v[4][0] = 0, a.v[5][0] = 1;\n    a = mat_pow(f, t) * a;\n    printf(\"%d %d\\n\", a.v[0][0] + 1, a.v[1][0] + 1);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["math", "matrices"], "dificulty": "2300", "interactive": false}