{
    "link": "https://codeforces.com//contest/1204/problem/D2",
    "problemId": "392655",
    "problem_idx": "D2",
    "shortId": "1204D2",
    "contest_number": "1204",
    "problem_submissions": {
        "D2": [
            59171473,
            59176959,
            59165503,
            59172424,
            59176173,
            59167492,
            59164905,
            59176155,
            59178992,
            59169931,
            59176960,
            59169864,
            59178242,
            59178029,
            59169582,
            59172809,
            59169123,
            59168999,
            59171305,
            59170057
        ],
        "D1": [
            59169891,
            59176544,
            59165271,
            59172261,
            59176126,
            59167259,
            59164656,
            59176100,
            59163490,
            59168508,
            59176724,
            59170026,
            59178274,
            59177894,
            59169407,
            59172673,
            59169296,
            59168747,
            59167871,
            59169828
        ],
        "E": [
            59165621,
            59159508,
            59171204,
            59167827,
            59161848,
            59176920,
            59177089,
            59166777,
            59176127,
            59177175,
            59172161,
            59177722,
            59170117,
            59171712,
            59177233,
            59179201,
            59180220,
            59178891,
            59180477,
            59178723
        ],
        "C": [
            59151501,
            59163669,
            59158012,
            59149471,
            59166332,
            59152299,
            59160440,
            59156718,
            59160290,
            59156826,
            59162942,
            59160646,
            59158205,
            59161710,
            59162530,
            59157292,
            59158762,
            59160352,
            59157314,
            59162180
        ],
        "B": [
            59144349,
            59150576,
            59146764,
            59144554,
            59146379,
            59145028,
            59149730,
            59146608,
            59146122,
            59145946,
            59147391,
            59146291,
            59146819,
            59146767,
            59151379,
            59145774,
            59147183,
            59147977,
            59149695,
            59149226
        ],
        "A": [
            59141665,
            59142146,
            59141563,
            59142710,
            59143581,
            59145777,
            59144224,
            59142379,
            59143868,
            59142387,
            59143522,
            59143089,
            59147328,
            59153631,
            59142559,
            59141790,
            59142894,
            59147085,
            59146105
        ]
    },
    "name": "D2. Kirk and a Binary String  hard version ",
    "statement": "Kirk has a binary string s (a string which consists of zeroes and ones)\r\nof length n and he is asking you to find a binary string t of the same\r\nlength which satisfies the following conditions: For any l and r (1\r\nleq l\r\nleq r\r\nleq n) the length of the longest non-decreasing subsequence of the\r\nsubstring s_{l}s_{l+1}\r\nldots s_{r} is equal to the length of the longest non-decreasing\r\nsubsequence of the substring t_{l}t_{l+1}\r\nldots t_{r}; The number of zeroes in t is the maximum possible.A\r\nnon-decreasing subsequence of a string p is a sequence of indices i_1,\r\ni_2,\r\nldots, i_k such that i_1 < i_2 <\r\nldots < i_k and p_{i_1}\r\nleq p_{i_2}\r\nleq\r\nldots\r\nleq p_{i_k}. The length of the subsequence is k.If there are multiple\r\nsubstrings which satisfy the conditions, output any.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nbool arr[100005];\nbool change[100005];\nint valMax;\nint ones1, ones2;\n\nvoid input();\n\nint main(){\n    input();\n\n    for(int i=n; i>=1; i--){\n        int max1 = 1, max2 = 1;\n        int tmp;\n        if(!arr[i]) max1 = valMax+1;\n        else max1 = ones1+1;\n        max2 = valMax+1;\n\n        if(arr[i] && max1 == max2) change[i] = 1;\n\n        tmp = ones1+1;\n\n        if(arr[i]){\n            ones1++;\n        }\n        else{\n            valMax++;\n        }\n        valMax = max(valMax, tmp);\n    }\n\n    for(int i=1; i<=n; i++){\n        printf(\"%d\", arr[i] && !change[i]);\n    }\n}\n\nvoid input(){\n    string s;\n    cin >> s;\n    n = (int)s.size();\n    for(int i=1; i<=n; i++) arr[i] = (s[i-1] == '1');\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Kirk and a Binary String  hard version .json",
    "editorial_link": "https://codeforces.com/blog/entry/69244",
    "editorial": "Solution 1: Letâs call a string if there isnât another string of the\r\nsame length which satisfies the first condition of the statement (it was\r\nabout the same lengths of the longest nondecreasing subsequences on\r\nsubstrings). The following statements are obivous: string is fixed; if\r\nstrings and are fixed, then their concatenation is fixed; if a string is\r\nfixed, then the string is fixed; each fixed string contains the same\r\nnumber of ones and zeroes; the length of the longest nondecreasing\r\nsubsequence for any fixed string is equal to the half of its length,\r\nwhich can be obtained by taking all zeroes or all ones;So if we erase\r\nall fixed strings from the given string, the remaining parts consists of\r\nzeroes at prefix and ones at suffix; it is obvious that we can change\r\nall these ones to zeroes and the string still satisfies the\r\ncondition.Solution 2: If we change any to and the longest nondecreasing\r\nsequence of the whole string remains the same, then we are able to\r\nchange it to . To count the longest nondecreasing sequence of a new\r\nstring, store and maintain following arrays: the longest nondecreasing\r\nsequence of the substring ; number of zeroes in the substring ; the\r\nlongest nondecreasing sequence of the substring and number of ones in\r\nthe substring ; now, if we change to at a position , then the length of\r\nthe longest nondecreasing sequence of a new string is .\r\n",
    "hint": []
}