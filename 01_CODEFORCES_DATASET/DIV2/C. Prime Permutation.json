{"link": "https://codeforces.com//contest/124/problem/C", "problemId": "659", "problem_idx": "C", "shortId": "124C", "contest_number": "124", "problem_submissions": {"D": [830516, 831052, 830260, 830876, 831073, 831039, 830521, 831685, 831637, 830707, 830117, 831656, 831924, 830160], "C": [829966, 828434, 832481, 830195, 830289, 830286, 831243, 829787, 830553, 831437, 830908, 830422, 830664, 830957], "B": [828282, 830142, 828624, 828524, 828126, 828773, 828303, 828596, 828124, 828824, 831632, 829528, 828350, 831819], "A": [826975, 827420, 827298, 826788, 826903, 827255, 826640, 827252, 826692, 827048, 828119, 827326, 826716, 828544], "E": [831333, 875691, 838710]}, "name": "C. Prime Permutation", "statement": "You are given a string , consisting of small Latin letters. Let\u2019s denote\r\nthe length of the string as . The characters in the string are numbered\r\nstarting from . Your task is to find out if it is possible to rearrange\r\ncharacters in string so that for any prime number and for any integer\r\nranging from to (inclusive) the following condition was fulfilled . If\r\nthe answer is positive, find one way to rearrange the characters.\r\n", "solutions": ["#include <iostream>\n#include <string>\nusing namespace std;\n\nint prime[1000];\nint num_prime = 0;\n\nvoid MakePrime() {\n  bool isPrime[1001];\n  for (int i = 0; i < 1000; ++i) {\n    isPrime[i] = true;\n  }\n  isPrime[0] = isPrime[1] = false;\n  for (int i = 0; i < 700; ++i) {\n    if (!isPrime[i]) {\n      continue;\n    }\n\n    int p = prime[num_prime++] = i;\n    for (int k = p * p; k < 1000; k += p) {\n      isPrime[k] = false;\n    }\n  }\n}\n\nvoid SplitChars(const string &str, string *same_str, string *diff_str) {\n  int count[256];\n  for (int i = 0; i < 256; ++i) {\n    count[i] = 0;\n  }\n  for (int i = 0; i < str.size(); ++i) {\n    ++count[str[i]];\n  }\n\n  int dup_char = 0, id_char = -1;\n  for (int i = 'a'; i <= 'z'; ++i) {\n    if (dup_char < count[i]) {\n      dup_char = count[i];\n      id_char = i;\n    }\n  }\n\n  for (int i = 0; i < str.size(); ++i) {\n    if (str[i] == id_char) {\n      *same_str += str[i];\n    } else {\n      *diff_str += str[i];\n    }\n  }\n}\n\nint CheckSame(const string &str, bool *same) {\n  for (int i = 0; i < str.size(); ++i) {\n    same[i] = false;\n  }\n\n  int num_dup = 0;\n  for (int i = 0; prime[i] <= str.size() / 2; ++i) {\n    const int p = prime[i];\n    for (int j = p; j <= str.size(); j += p) {\n      if (!same[j - 1]) {\n        same[j - 1] = true;\n        ++num_dup;\n      }\n    }\n  }\n\n  return num_dup;\n}\n\nint main(void) {\n  MakePrime();\n  for (string str; cin >> str; ) {\n    const int n = str.size();\n    string same_str, diff_str;\n    SplitChars(str, &same_str, &diff_str);\n    bool same[1001];\n    int num_dup = CheckSame(str, same);\n\n    if (num_dup > same_str.size()) {\n      cout << \"NO\\n\";\n      continue;\n    }\n\n    cout << \"YES\\n\";\n    int id_output = 0;\n    const char *pchar_same = same_str.c_str();\n    const char *pchar_diff = diff_str.c_str();\n    for (int i = 0; i < n; ++i) {\n      if (same[i]) {\n        str[i] = *pchar_same++;\n      } else if (*pchar_diff) {\n        str[i] = *pchar_diff++;\n      } else {\n        str[i] = *pchar_same++;\n      }\n    }\n    cout << str << \"\\n\";\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "dsu", "greedy", "number theory", "sortings", "strings"], "dificulty": "1300", "interactive": false}