{
    "link": "https://codeforces.com//contest/789/problem/E",
    "problemId": "100716",
    "problem_idx": "E",
    "shortId": "789E",
    "contest_number": "789",
    "problem_submissions": {
        "E": [
            25921417,
            25928664,
            25938608,
            26079210,
            25947954,
            26156847,
            25952720,
            25948873,
            25927282,
            25920863
        ],
        "C": [
            25907485,
            25920845,
            25908240,
            25909409,
            25909007,
            25905160,
            25908451,
            25908709,
            25907436,
            25913347,
            25910091,
            25912715,
            25905998,
            25914226,
            25910850,
            25914881,
            25912811,
            25910391
        ],
        "B": [
            25905735,
            25936346,
            25905545,
            25905376,
            25905148,
            25909677,
            25906183,
            25904190,
            25902630,
            25909186,
            25906079,
            25908841,
            25906659,
            25906692,
            25949245,
            25917385,
            25906432,
            25939487
        ],
        "A": [
            25903396,
            25902876,
            25900899,
            25900290,
            25900204,
            25900048,
            25900683,
            25900192,
            25900117,
            25900433,
            25900607,
            25901029,
            25900382,
            25900017,
            25900928,
            25900038,
            25900011,
            25900777
        ],
        "D": [
            25920092,
            25917739,
            25919852,
            25922157,
            25919194,
            25919753,
            25920835,
            25927363,
            25921216,
            25924692,
            25924134,
            25910294,
            25927095,
            25925921,
            25927864
        ]
    },
    "name": "E. The Great Mixing",
    "statement": "Sasha and Kolya decided to get drunk with Coke, again. This time they\r\nhave types of Coke. -th type is characterised by its carbon dioxide\r\nconcentration . Today, on the party in honour of Sergiy of Vancouver\r\nthey decided to prepare a glass of Coke with carbon dioxide\r\nconcentration . The drink should also be tasty, so the glass can contain\r\nonly integer number of liters of each Coke type (some types can be not\r\npresented in the glass). Also, they want to minimize the total volume of\r\nCoke in the glass.Carbon dioxide concentration is defined as the volume\r\nof carbone dioxide in the Coke divided by the total volume of Coke. When\r\nyou mix two Cokes, the volume of carbon dioxide sums up, and the total\r\nvolume of Coke sums up as well.Help them, find the minimal natural\r\nnumber of liters needed to create a glass with carbon dioxide\r\nconcentration . Assume that the friends have unlimited amount of each\r\nCoke type.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nset<int> has;\nconst int inf = 1010;\nvector<int> le;\nvector<int> up;\nint sol[1000010][2];\nvoid knapsack(vector<int> w, int idx)\n{\n    for(int i=1;i<=1000000;i++) sol[i][idx]=inf*inf;\n    for(int i=0;i<=1000000;i++)\n    {\n        for(int j=0;j<w.size();j++)\n        {\n            if(w[j]<=i) sol[i][idx]=min(sol[i][idx], 1 + sol[i-w[j]][idx]);\n        }\n    }\n}\nint main()\n{\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    int mini = inf;\n    int maxi = -inf;\n    while(k--)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        has.insert(x);\n        mini = min(mini, x);\n        maxi = max(maxi, x);\n    }\n    //printf(\"%d %d\\n\",mini,maxi);\n    if(n < mini || n > maxi)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    bool imm = false;\n    for(auto &x : has)\n    {\n        if(x==n)\n        {\n            imm = true;\n            break;\n        }\n        if(x<n) le.push_back(n-x);\n        else if(x>n) up.push_back(x-n);\n    }\n    if(imm)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    sort(le.begin(),le.end());\n    sort(up.begin(),up.end());\n    knapsack(le,0);\n    knapsack(up,1);\n    int ans = inf*inf*inf;\n    //for(int i=0;i<=1000;i+=50) printf(\"%d %d\\n\",sol[i][0],sol[i][1]);\n    for(int i=1;i<=1000000;i++) ans=min(ans, sol[i][0]+sol[i][1]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "graph matchings",
        "graphs",
        "math",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Great Mixing.json",
    "editorial_link": "https://codeforces.com//blog/entry/51312",
    "editorial": "Let   needed concentration and s1,?s2,?...,?sm  concentration of types we'll use.\n\n\n\n\n\n\n\n\n\n\nThen, we can decrease every si by n. So, we reduced the problem to finding a set of numbers with zero sum.\n\nNow we can build a graph, where vertexes are our sum.\n\nThere will be m edges from each vertex, where m  the number of different concentrations. Obviously, we'll have at most 1001 different concentrations, so there are at most 1001 edges from each vertex. Now, we need to find a cycle of smallest length. We can do this using BFS starting from vertex 0. With BFS we can find the first vertex with the existing edge to vertex 0.\n\nWe need at most 1000 vertexes to each side (from -1000 to 1000), so the solution complexity is O(2001·min(k,?1001)).",
    "hint": []
}