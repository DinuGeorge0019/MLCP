{
    "link": "https://codeforces.com//contest/2060/problem/F",
    "problemId": "3147475",
    "problem_idx": "F",
    "shortId": "2060F",
    "contest_number": "2060",
    "problem_submissions": {
        "G": [
            301873530,
            301859046,
            301852803,
            301886996,
            301829945,
            301884074,
            301865362,
            301944483,
            301877663
        ],
        "F": [
            301809977,
            301827952,
            301788384,
            301831904,
            301878286,
            301872767,
            301850953,
            301874252,
            301811774,
            301816800,
            301831940,
            301815743,
            301889712,
            301854030,
            301836262,
            301832755,
            301848647,
            301843962,
            301841616,
            301902407
        ],
        "E": [
            301780977,
            301790293,
            301841004,
            301786821,
            301854824,
            301815095,
            301816295,
            301758990,
            301799665,
            301795284,
            301801086,
            301920235,
            301889573,
            301794741,
            301799175,
            301804483,
            301807413,
            301794652,
            301768541
        ],
        "D": [
            301771562,
            301772155,
            301822748,
            301775745,
            301785461,
            301801939,
            301852011,
            301776457,
            301782878,
            301769755,
            301787487,
            301917787,
            301889434,
            301776569,
            301786371,
            301790878,
            301764610,
            301773754,
            301756989
        ],
        "C": [
            301748633,
            301761322,
            301773736,
            301772188,
            301769620,
            301776760,
            301770890,
            301782439,
            301749719,
            301754417,
            301759048,
            301774305,
            301916945,
            301889316,
            301755362,
            301775118,
            301772704,
            301748352,
            301760800,
            301753236
        ],
        "B": [
            301746021,
            301755202,
            301761527,
            301755925,
            301795537,
            301759408,
            301745641,
            301745397,
            301750029,
            301750098,
            301915984,
            301888995,
            301750358,
            301751304,
            301755984,
            301781169,
            301750274,
            301748735
        ],
        "A": [
            301739564,
            301739279,
            301761253,
            301738865,
            301749974,
            301743163,
            301743222,
            301739250,
            301739375,
            301743095,
            301739024,
            301915381,
            301888689,
            301739666,
            301739726,
            301746215,
            301745343,
            301738637,
            301738767
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/138342",
    "editorial": "The naive solution is to define fk(n)\n as the number of arrays containing n\n elements with a product of k\n. We could then try to compute this by considering the last element of the array among the divisors of k\n, giving us:\n\nfk(n)=?j|kfj(n?1),\nwith fk(1)=1\n.\n\nThe answers would then be ?ni=1f1(i),?ni=1f2(i),\u0085,?ni=1fk(i)\n. However, this leads to an O(nklogk)\n solution, which exceeds our time constraints. We need to optimize this approach.\n\nWe can prove that there are at most 16\n non-1\n elements in our arrays. This is because:\n\nThe prime factorization of k=p1p2?pt\n divides k\n into the most non-1\n elements.\nWith 17\n non-1\n elements, the smallest possible value would be k=217=131072>105\n.\nBased on this observation, we can define our dynamic programming state as:\n\nLet dp[i][j]\n represent the number of arrays with product i\n containing only j\n non-1\n elements.\nThe recurrence relation becomes: dp[i][j]=?p|i,p>1dp[ip][j?1]\n.\nBase case: dp[i][1]=1\n for i>1\n.\nThis computation has a time complexity of O(klog2k)\n, as we perform ?kj=1d(j)=O(klogk)\n additions for each i\n.\n\nTo calculate fk(n)\n, we:\n\nEnumerate the number of non-1\n elements from 1\n to 16\n.\nFor j\n non-1\n elements in the array:\nWe have n?j\n elements that are 1\n.\nWe need to choose j\n positions for non-1\n elements.\nFill these positions with dp[k][j]\n possible sequences.\nThis gives us:\n\nfk(n)=?16j=1(nj)dp[k][j].\nTherefore:\n\n===?i=1nfk(n)?i=1n?j=116(ij)dp[k][j]?j=116(dp[k][j]?i=1n(ij))?j=116(n+1j+1)dp[k][j].\nNote that ?ni=1(ij)=(n+1j+1)\n is given by the Hockey Stick Identity.\n\nEach answer can be calculated in O(log2k)\n time, giving an overall time complexity of O(klog2k)\n.",
    "name": "F. Multiplicative Arrays",
    "statement": "You\u2019re given integers k and n. For each integer x from 1 to k, count the\r\nnumber of integer arrays a such that all of the following are satisfied:\r\n1\r\nleq |a|\r\nleq n where |a| represents the length of a. 1\r\nleq a_i\r\nleq k for all 1\r\nleq i\r\nleq |a|. a_1\r\ntimes a_2\r\ntimes\r\ndots\r\ntimes a_{|a|}=x (i.e., the product of all elements is x). Note that two\r\narrays b and c are different if either their lengths are different, or\r\nif there exists an index 1\r\nleq i\r\nleq |b| such that b_i\r\nneq c_i.Output the answer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0static const int MOD = 998244353;static const int MAXK = 100000;\u00a0inline long long modAdd(long long a, long long b) {\tlong long r = a + b;\tif (r >= MOD) r -= MOD;\treturn r;}inline long long modSub(long long a, long long b) {\tlong long r = a - b;\tif (r < 0) r += MOD;\treturn r;}inline long long modMul(long long a, long long b) {\treturn (a % MOD) * (b % MOD) % MOD;}long long modExp(long long base, long long exp) {\tlong long result = 1 % MOD;\tbase %= MOD;\twhile (exp > 0) {\t\tif (exp & 1) result = (result * base) % MOD;\t\tbase = (base * base) % MOD;\t\texp >>= 1;\t}\treturn result;}inline long long modInv(long long x) {\treturn modExp(x, MOD-2);}\u00a0static int spf[MAXK+1];  void build_spf() {\tfor (int i = 2; i <= MAXK; i++) {\t\tif (!spf[i]) { \t\t\t// i is prime\t\t\tfor (long long j = (long long)i; j <= MAXK; j += i) {\t\t\t\tif (!spf[j]) spf[j] = i;\t\t\t}\t\t}\t}}\u00a0vector<pair<int,int>> factor_small(int x) {\tvector<pair<int,int>> f;\twhile (x > 1) {\t\tint p = spf[x];\t\tint cnt = 0;\t\twhile (spf[x] == p) {\t\t\tx /= p;\t\t\tcnt++;\t\t}\t\tf.push_back({p,cnt});\t}\treturn f;}\u00a0typedef long long ll;typedef vector<ll> Poly;Poly polyMul(const Poly &A, const Poly &B) {\tPoly C(A.size()+B.size()-1, 0LL);\tfor (size_t i=0; i<A.size(); i++){\t\tfor (size_t j=0; j<B.size(); j++){\t\t\tC[i+j] = modAdd(C[i+j], modMul(A[i], B[j]));\t\t}\t}\treturn C;}\u00a0// P(m) = ( (m + 0)*(m + 1)*...*(m + a-1) ) / a!Poly bino(int a) {\tif (a == 0) {\t\treturn Poly(1, 1LL);\t}\tPoly res(1, 1LL); // constant 1\tfor(int j=0; j<a; j++){\t\tPoly tmp(res.size()+1, 0LL);\t\tfor (size_t i=0; i<res.size(); i++){\t\t\tll coeff = res[i];\t\t\t// (m + j) => \t\t\t//    newPoly[i+1] += coeff (coefficient for m^(i+1))\t\t\t//    newPoly[i]   += j*coeff\t\t\ttmp[i+1] = modAdd(tmp[i+1], coeff);\t\t\ttmp[i]   = modAdd(tmp[i], modMul(coeff, j));\t\t}\t\tres.swap(tmp);\t}\u00a0\t// divide by a! mod\tstatic bool factInit = false;\tstatic ll fact[40], invfact[40];\tif (!factInit) {\t\tfactInit = true;\t\tfact[0]=1; for(int i=1;i<40;i++) fact[i]=modMul(fact[i-1], i);\t\tinvfact[39] = modInv(fact[39]);\t\tfor(int i=38;i>=0;i--){\t\t\tinvfact[i] = modMul(invfact[i+1], i+1);\t\t}\t}\tll invA = invfact[a]; // 1/(a!) mod\tfor (auto &c : res) {\t\tc = modMul(c, invA);\t}\treturn res;}static const int MAXP = 16; \u00a0static vector<ll> sumPoly[MAXP+1];long long evalPoly(const Poly &poly, long long x) {\tlong long ans = 0;\tfor (int i=(int)poly.size()-1; i>=0; i--){\t\tans = modMul(ans, x);\t\tans = modAdd(ans, poly[i]);\t}\treturn ans;}long long sumpow(long long n, int p) {\tif (n < 0) return 0; // safety\treturn evalPoly(sumPoly[p], n);}void bsp() {\tfor(int p=0; p<=MAXP; p++){\t\tvector<long long> X(p+2), Y(p+2);\t\tX[0] = 0; Y[0] = 0;\t\tfor(int i=1; i<=p+1; i++){\t\t\tX[i] = i;\t\t\t// i^p mod\t\t\tlong long ipow = 1;\t\t\tfor(int r=0;r<p;r++){\t\t\t\tipow = modMul(ipow, i);\t\t\t}\t\t\tY[i] = modAdd(Y[i-1], ipow); \t\t}\t\tint L = p+2; // number of points\t\tvector<vector<long long>> F(L, vector<long long>(L,0LL));\t\tfor(int i=0;i<L;i++){\t\t\tF[i][0] = Y[i] % MOD;\t\t}\t\tfor(int j=1;j<L;j++){\t\t\tfor(int i=0; i<L-j;i++){\t\t\t\tlong long num = modSub(F[i+1][j-1], F[i][j-1]);\t\t\t\tlong long den = modSub(X[i+j], X[i]); // X[i+j] - X[i]\t\t\t\tlong long invDen = modInv((den+MOD)%MOD);\t\t\t\tF[i][j] = modMul(num, invDen);\t\t\t}\t\t}\t\tPoly res(1, 0LL);\t\tPoly curTerm(1, 1LL);\t\tfor(int j=0;j<L;j++){\t\t\tlong long coeff = F[0][j];\t\t\tPoly polyTerm(curTerm.size());\t\t\tfor(size_t u=0; u<curTerm.size(); u++){\t\t\t\tpolyTerm[u] = modMul(curTerm[u], coeff);\t\t\t}\t\t\tif (polyTerm.size() > res.size())\t\t\t\tres.resize(polyTerm.size(), 0);\t\t\tfor(size_t u=0; u<polyTerm.size(); u++){\t\t\t\tres[u] = modAdd(res[u], polyTerm[u]);\t\t\t}\t\t\tif (j+1 < L) {\t\t\t\tPoly newCur(curTerm.size()+1, 0LL);\t\t\t\tfor(size_t i=0; i<curTerm.size(); i++){\t\t\t\t\tnewCur[i+1] = modAdd(newCur[i+1], curTerm[i]);\t\t\t\t\tlong long tmp = modMul(curTerm[i], (MOD - (X[j] % MOD)));\t\t\t\t\tnewCur[i] = modAdd(newCur[i], tmp);\t\t\t\t}\t\t\t\tcurTerm.swap(newCur);\t\t\t}\t\t}\t\tsumPoly[p] = res;  // store\t}}\u00a0int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr);\u00a0\tbuild_spf();\tbsp();\tint t;\tcin >> t;\twhile(t--){\t\tlong long n;\t\tint k;\t\tcin >> k >> n;\u00a0\t\tvector<long long> ans(k+1, 0);\u00a0\t\tfor(int x=1; x<=k; x++){\t\t\tauto factx = factor_small(x);\t\t\tPoly polyRes(1, 1LL);\t\t\tfor (auto &pe : factx) {\t\t\t\tint expnt = pe.second;\t\t\t\tPoly pf = bino(expnt); \t\t\t\tpolyRes = polyMul(polyRes, pf);\t\t\t}\t\t\tlong long total = 0;\t\t\tfor (int i=0; i<(int)polyRes.size(); i++){\t\t\t\tif (polyRes[i] != 0) {\t\t\t\t\tlong long c = polyRes[i];\t\t\t\t\tlong long sp = sumpow(n, i);\t\t\t\t\ttotal = modAdd(total, modMul(c, sp));\t\t\t\t}\t\t\t}\t\t\tans[x] = total;\t\t}\t\tfor(int x=1; x<=k; x++){\t\t\tcout << ans[x];\t\t\tif (x<k) cout << ' ';\t\t}\t\tcout << '\\n';\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Multiplicative Arrays.json"
}