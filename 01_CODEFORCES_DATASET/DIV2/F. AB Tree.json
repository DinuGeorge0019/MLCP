{
    "link": "https://codeforces.com//contest/1481/problem/F",
    "problemId": "888836",
    "problem_idx": "F",
    "shortId": "1481F",
    "contest_number": "1481",
    "problem_submissions": {
        "E": [
            106575657,
            106580122,
            106571072,
            106587922,
            106596561,
            106601300,
            106598150,
            106588203,
            106555230,
            106601691,
            106603323,
            106598805,
            106606116,
            106598692,
            106597406,
            106601560,
            106559099,
            106600288,
            106602866
        ],
        "D": [
            106568002,
            106573123,
            106565784,
            106576955,
            106573210,
            106578133,
            106576417,
            106596842,
            106581404,
            106583159,
            106580270,
            106581784,
            106581178,
            106589786,
            106588485,
            106598470,
            106585012,
            106578937,
            106593218
        ],
        "C": [
            106554240,
            106561563,
            106587826,
            106564449,
            106557128,
            106554455,
            106561081,
            106556949,
            106593975,
            106567836,
            106563207,
            106566579,
            106560187,
            106560571,
            106563380,
            106553575,
            106571925,
            106575164,
            106574000
        ],
        "B": [
            106545453,
            106545635,
            106575045,
            106557114,
            106546143,
            106544431,
            106547512,
            106547628,
            106600777,
            106555535,
            106546768,
            106552994,
            106545917,
            106549686,
            106553008,
            106544154,
            106594934,
            106546830,
            106553782
        ],
        "A": [
            106540084,
            106539696,
            106539972,
            106539768,
            106541130,
            106540757,
            106539872,
            106540973,
            106602935,
            106540095,
            106541018,
            106540813,
            106540248,
            106541459,
            106539556,
            106539597,
            106547797,
            106540934,
            106542940
        ],
        "F": [
            106632220,
            111955794,
            218518749,
            218505572
        ]
    },
    "name": "F. AB Tree",
    "statement": "Kilani and Abd are neighbors for 3000 years, but then the day came and\r\nKilani decided to move to another house. As a farewell gift, Kilani is\r\ngoing to challenge Abd with a problem written by their other neighbor\r\nwith the same name Abd. The problem is:You are given a connected tree\r\nrooted at node 1.You should assign a character or to every node in the\r\ntree so that the total number of ’s is equal to x and the total number\r\nof ’s is equal to n - x.Let’s define a string for each node v of the\r\ntree as follows: if v is root then the string is just one character\r\nassigned to v: otherwise, let’s take a string defined for the v’s parent\r\np_v and add to the end of it a character assigned to v. You should\r\nassign every node a character in a way that among the strings of all\r\nnodes.\r\n",
    "solutions": [
        "/*\n    ___                         ______      __                  __\n   /   |____  __  ___________ _/ ____/___ _/ /___  ____  ______/ /____\n  / /| /_  / / / / / ___/ __ `/ /   / __ `/ __/ / / / / / / __  / ___/\n / ___ |/ /_/ /_/ (__  ) /_/ / /___/ /_/ / /_/ /_/ / /_/ / /_/ (__  )\n/_/  |_/___/\\__,_/____/\\__,_/\\____/\\__,_/\\__/\\__, /\\__, /\\__,_/____/\n                                            /____//____/\n\n　　　　　／＞　 フ\n　　　　　| 　_　 _|\n　 　　　／`ミ _x 彡\n　　 　 /　　　 　 |\n　　　 /　  ヽ　　 ?\n　／￣|　　 |　|　|\n　| (￣ヽ＿_ヽ_)_)\n　＼二つ\n\n*/\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n\tstatic short st[30];short tp=0;\n\tif(x<0) putchar('-'),x=-x;\n\tdo st[++tp]=x%10,x/=10; while(x);\n\twhile(tp) putchar('0'|st[tp--]);\n\tputchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 200500;\nint ne[N<<1], to[N<<1], h[N], tot;\ninline void add(int x, int y) {\n\tne[++tot] = h[x], to[h[x] = tot] = y;\n}\n\nint cnt[N], D[N], mxdep, n, x;\nvector<int> vec[N];\n#include <bitset>\nbitset< 50019 > bit[355], B[355], nw;\nint ans[N], col[N], deg[N], bl, S = 350;\nvoid dfs(int x, int dep, int fa) {\n\tvec[D[x] = dep].push_back(x);\n\tcnt[dep]++, Mx(mxdep, dep);\n\tfor (int i = h[x]; i; i = ne[i]) \n\t\tif (to[i] != fa) deg[x]++, dfs(to[i], dep + 1, x);\n}\n\nint main() {\n//\tfreopen (\"hs.in\",\"r\",stdin);\n//\tfreopen (\"hs.out\",\"w\",stdout);\n\tread(n), read(x);\n\tfor (int i = 2, x;i <= n; ++i) read(x), add(x, i), add(i, x);\n\tdfs(1, 1, 0);\n\tchar a = 'a', b = 'b';\n\tif (x + x > n) x = n - x, swap(a, b);\n\tnw[0] = 1, bit[++bl] = nw;\n\tfor (int i = 1;i <= n; ++i) {\n\t\tif (!cnt[i]) break;\n\t\tnw |= nw << cnt[i];\n\t\tif (i % S == 0) bit[++bl] = nw;\n\t}\n\tif (!nw[x]) {\n\t\twrite(mxdep + 1);\n\t\tint spj = 0, y = n - x;\n\t\tfor (int i = 1;i <= mxdep; ++i) {\n\t\t\tif (cnt[i] <= x) {\n\t\t\t\tfor (auto t: vec[i]) ans[t] = a;\n\t\t\t\tx -= cnt[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cnt[i] <= y) {\n\t\t\t\tfor (auto t: vec[i]) ans[t] = b;\n\t\t\t\ty -= cnt[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspj = i;\n\t\t}\n\t\tchar tt = x < y ? a : b; int k = min(x, y);\n\t\tfor (auto t: vec[spj]) \n\t\t\tif (!deg[t]) ans[t] = k ? (k -= 1, tt) : (a ^ b ^ tt);\n\t\tfor (auto t: vec[spj])\n\t\t\tif (!ans[t]) ans[t] = a ^ b ^ tt;\n\t\tfor (int i = 1;i <= n; ++i) putchar(ans[i]);\n\t\treturn 0;\n\t}\n\twrite(mxdep);\n\tfor (int i = bl;i >= 1; --i) {\n\t\tint st = (i - 1) * S;\n\t\tB[0] = bit[i];\n\t\tfor (int j = st + 1;j <= st + S; ++j) {\n\t\t\tif (!cnt[j]) break;\n\t\t\tB[j - st] = B[j - 1 - st] | B[j - 1 - st] << cnt[j];\n\t\t}\n\t\twhile (mxdep > st) {\n\t\t\tif (B[mxdep - st][x] && !B[mxdep - st - 1][x]) \n\t\t\t\tx -= cnt[mxdep], col[mxdep] = 1;\n\t\t\t--mxdep;\n\t\t}\n\t}\n\tfor (int i = 1;i <= n; ++i) putchar(col[D[i]] ? a : b);\n\treturn 0;\n}\n\n/*\n\n9 4\n1 2 2 2 2 2 1 2\n\n1 0\n\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. AB Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/87523",
    "editorial": "let the diameter of the tree (the maximum distance between a root and a\r\nleaf) be , then the answer couldnât be less than because you will add\r\nstrings of all lengths between and .In order to have the answer , you\r\nneed all strings with the same length to be equal, so all nodes on the\r\nsame level must have the same character. Letâs define an array of size ,\r\nsuch that = (number of nodes at level ). So if the answer is there must\r\nexist a subset from with sum , so we assign character to all the nodes\r\nwith a level belongs to that subset, and character to all other nodes.To\r\ncheck if there is a subset with sum we can use dynamic programming, the\r\ncomplexity of this solution is , which is in worst case .But since the\r\nsum of array is equal to , the number of unique values in will be at\r\nmost , so lets have an array of size at most having every value with\r\nitâs frequency. Now let be true if it is possible to find a subset with\r\nsum in the suffix . So to check if is true or not we need to check , in\r\nanother way we need to find a value such that is true and , so for every\r\nletâs find the minimum possible , if is true then will be equal to ,\r\notherwise it is equal to .So this way we can check if the answer is in\r\n.Now if the answer is not , then it is . To find the answer letâs start\r\nfrom level to level , when you are at level let the number of remaining\r\nnodes be (the number of nodes with depth greater than or equal to ) and\r\nyou have remaining âs you can still use.If is not greater than or not\r\ngreater than , you can assign all nodes on the current level with the\r\nsame character and move on to the next level.If not then you will have\r\nto use the two characters on the current level so you are going to add\r\nat least one more string on the answer. If you have two nodes on the\r\nsame level having the same character but the nodes have different\r\nprefixes, then the strings will not be considered equal, so to guarantee\r\nnot adding more than one string to the answer later on, you should make\r\nsure to assign the same character to all non-leaf nodes on the current\r\nlevel.Now if we have non-leaf nodes then must be less than or equal to ,\r\nbecause every non-leaf node should have at least one more node in itâs\r\nsub tree, and we know that for any value (), so it is possible to assign\r\nthe same character to all non-leaf nodes, after assigning all non-leaf\r\nnodes with the same character make sure to finish all the remaining\r\ncopies of this character on the current level so you guarantee on the\r\nnext levels all nodes will be the same.This way only one string will be\r\nadded on the current level so the answer will be .Total complexity is\r\n",
    "hint": []
}