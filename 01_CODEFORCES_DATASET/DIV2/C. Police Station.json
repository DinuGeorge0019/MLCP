{
    "link": "https://codeforces.com//contest/208/problem/C",
    "problemId": "1579",
    "problem_idx": "C",
    "shortId": "208C",
    "contest_number": "208",
    "problem_submissions": {
        "E": [
            1931263,
            1927824,
            1940917,
            1948656,
            36290584,
            1939808,
            1937161,
            1932047,
            1932077
        ],
        "C": [
            1928931,
            1931391,
            1928213,
            1929670,
            1928209,
            1928353,
            1929933,
            1927379,
            1929594,
            1928751,
            1930544,
            1930482,
            1930992,
            1929917,
            1931270,
            1930709,
            1931133
        ],
        "B": [
            1927386,
            1932558,
            1929923,
            1928218,
            1930610,
            1930208,
            1928807,
            1930969,
            1927627,
            1930670,
            1928423,
            1927797,
            1928378,
            1928980,
            1928852
        ],
        "D": [
            1925890,
            1925434,
            1926145,
            1926157,
            1925983,
            1925956,
            1925579,
            1928233,
            1930197,
            1926282,
            1926515,
            1926378,
            1926735,
            1926780,
            1925704,
            1929547
        ],
        "A": [
            1925047,
            1924758,
            1924977,
            1925009,
            1924805,
            1924742,
            1924870,
            1924729,
            1925347,
            1924867,
            1924876,
            1925279,
            1925817,
            1925469,
            1924754,
            1925708
        ]
    },
    "name": "C. Police Station",
    "statement": "The Berland road network consists of cities and of bidirectional roads.\r\nThe cities are numbered from 1 to , where the main capital city has\r\nnumber , and the culture capital number . The road network is set up so\r\nthat it is possible to reach any city from any other one by the roads.\r\nMoving on each road in any direction takes the same time.All residents\r\nof Berland are very lazy people, and so when they want to get from city\r\nto city , they always choose one of the shortest paths (no matter which\r\none).The Berland government wants to make this country\u2019s road network\r\nsafer. For that, it is going to put a police station in one city. The\r\npolice station has a rather strange property: when a citizen of Berland\r\nis driving along the road with a police station at one end of it, the\r\ncitizen drives more carefully, so all such roads are considered safe.\r\nThe roads, both ends of which differ from the city with the police\r\nstation, are dangerous.Now the government wonders where to put the\r\npolice station so that the average number of safe roads for the shortest\r\npaths from the cultural capital to the main capital would take the\r\nmaximum value.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<stdlib.h>\n#include<cstring>\n#include<iostream>\n#include<ctype.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<iomanip>\n#include<complex>\n#include<utility>\n\n#define X first\n#define Y second\n#define REP_0(i,n) for(int i=0;i<(n);++i)\n#define REP_1(i,n) for(int i=1;i<=(n);++i)\n#define REP_2(i,a,b) for(int i=(a);i<(b);++i)\n#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))\n#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)\n#define DOW_1(i,n) for(int i=(n);0<i;--i)\n#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)\n#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)\n#define FOREACH(a,b) for(typeof(b.begin()) a=(b).begin();a!=(b).end();++a)\n#define RFOREACH(a,b) for(typeof(b.rbegin()) a=(b).rbegin();a!=b.rend();++a)\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define IS insert\n#define ES erase\n#define IT iterator\n#define RI reserve_iterator\n#define PQ priority_queue\n#define LB lower_bound\n#define UB upper_bound\n\n#define PI 3.1415926535897932384626433832795\n#define EXP 2.7182818284590452353602874713527\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef double DB;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef pair<int,PII> PIII;\ntypedef pair<LD,int> PLDI;\ntypedef vector<PII> VII;\n\ntemplate<class T>\nT By(T x,T y,T P){\n\tT F1=0;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1+=x;\n\t\t\tif(F1<0||F1>=P)F1-=P;\n\t\t}\n\t\tx<<=1;\n\t\tif(x<0||x>=P)x-=P;\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Mul(T x,T y,T P){\n\tT F1=1;x%=P;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1=By(F1,x,P);\n\t\t}\n\t\tx=By(x,x,P);\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Gcd(T x,T y){\n\tif(y==0)return x;\n\tT z;\n\twhile(z=x%y){\n\t\tx=y,y=z;\n\t}\n\treturn y;\n}\n\nstruct EDGE{\n\tint T;EDGE *Nxt;\n};\n\ntemplate<class T>\nvoid UpdataMin(T &x,T y){\n\tif(y<x)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nvoid UpdataMax(T &x,T y){\n\tif(x<y)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nT Sqr(const T x){\n\treturn x*x;\n}\n\n#define MaxBuffer 20000000\nclass ReadBuffer{\n\tchar buff[MaxBuffer];\n\tchar *buf;\n\tvoid init(int size=MaxBuffer)\n\t{\n\t\tfread(buff,1,size,stdin);\n\t}\n\ttemplate<class T>\n\tbool readInterger(T &x)\n\t{\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag;\n\t\tflag=0;\n\t\tif(*buf=='-') flag=true;\n\t\telse x=*buf-'0';\n\t\twhile(isdigit(*++buf)) x=x*10+*buf-'0';\n\t\tif(flag) x=-x;\n\t\treturn true;\n\t}\n\ttemplate<class T>\n\tbool readFloat(T &x)\n\t{\n\t\tlong double nowpos=0.1;\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag,decimal;\n\t\tdecimal=flag=0;\n\t\tif(*buf=='-') flag=true,++buf;\n\t\telse if(*buf=='.') decimal=true;\n\t\twhile(isdigit(*buf)||*buf=='.')\n\t\t{\n\t\t\tif(*buf=='.') decimal=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(decimal)\n\t\t\t\t{\n\t\t\t\t\tx+=nowpos*(*buf-'0');\n\t\t\t\t\tnowpos*=0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx=x*10+*buf-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t++buf;\n\t\t}\n\t\treturn true;\n\t}\n\tbool readChar(char c)\n\t{\n\t\tif(*buf==0) return 0;\n\t\treturn c=*buf++,1;\n\t}\n\tbool readString(char *s)\n\t{\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(!*buf) return false;\n\t\twhile(!isspace(*buf)) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn true;\n\t}\n\tint countSpacetonext(){\n\t\tint total=0;\n\t\twhile(*buf&&*buf==' ') ++total,++buf;\n\t\treturn total;\n\t}\n\tbool splitBycharactor(char *s,char Split='\\n'){\n\t\twhile(*buf&&*buf!=Split) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn *buf!=0;\n\t}\n};\n\nint dis[111][111];\nLL path[111][111];\nint n,m,x,y;\nLL maxans;\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tmemset(dis,63,sizeof(dis));\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdis[x][y]=dis[y][x]=1;\n\t\tpath[x][y]=path[y][x]=1;\n\t}\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tfor(int i=1;i<=n;++i) if(i!=k)\n\t\t{\n\t\t\tfor(int j=1;j<=n;++j) if(j!=k&&j!=i)\n\t\t\t{\n\t\t\t\tif(dis[i][j]>dis[i][k]+dis[k][j])\n\t\t\t\t{\n\t\t\t\t\tdis[i][j]=dis[i][k]+dis[k][j];\n\t\t\t\t\tpath[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(dis[i][j]==dis[i][k]+dis[k][j])\n\t\t\t\t{\n\t\t\t\t\tpath[i][j]+=path[i][k]*path[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmaxans=path[1][n];\n\tfor(int i=2;i<n;++i)\n\t{\n\t\tif(dis[1][i]+dis[i][n]==dis[1][n])\n\t\t{\n\t\t\tUpdataMax(maxans,path[1][i]*path[i][n]*2);\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",maxans*1.0/path[1][n]);\n\tscanf(\"%d\",&n);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Police Station.json",
    "editorial_link": "https://codeforces.com/blog/entry/4930",
    "editorial": "In this problem we will find the sought quantity for every vertex and\r\nfind the maximum value. For this for every vertex count two values: and\r\nnumber of shortest paths from vertex to -th and -st vertices\r\nrespectively. For this you should construct graph of shortest paths and\r\nuse dynamic programming on the constructed graph (because the new graph\r\nwill be acyclic). To construct the graph of shortest paths you should\r\nleave only useful edges in original graph. It can be done, for example,\r\nusing breadth-first search launched from vertices and respectively.\r\nAfter values and are found consider every useful edge ) and add to\r\nvertices and value , which is the contribution of this edge in the\r\nsought quantity for the vertices and . Note that value is the number of\r\nshortest paths between and . All said values can be found in time . The\r\ncomplexity of solution is .\r\n"
}