{
    "link": "https://codeforces.com//contest/540/problem/D",
    "problemId": "26989",
    "problem_idx": "D",
    "shortId": "540D",
    "contest_number": "540",
    "problem_submissions": {
        "E": [
            10950082,
            10942556,
            10951035,
            10952383,
            10951664,
            10948964,
            10952277,
            10951669,
            10951944,
            10983800,
            10953155,
            11577591,
            10950708,
            10959502,
            10959369,
            10949750,
            10950320,
            10951075,
            10955881,
            10955706,
            10948813
        ],
        "D": [
            10947922,
            10944160,
            10947124,
            10947070,
            10947798,
            10941308,
            10948944,
            10944336,
            10946886,
            10946947,
            10949570,
            10959819,
            10950615,
            10948080,
            10945713,
            10950893,
            10948099,
            10946895,
            10951818
        ],
        "C": [
            10944700,
            10945032,
            10944296,
            10945350,
            10951612,
            10946322,
            10949663,
            10954145,
            10962540,
            10944690,
            10944805,
            10959319,
            10950587,
            10948967,
            10953843,
            10947752,
            10960817,
            10948058,
            10945550
        ],
        "B": [
            10942652,
            10942383,
            10948312,
            10942705,
            10949878,
            10942945,
            10950444,
            10942965,
            10962010,
            10943162,
            10942463,
            10958996,
            10943265,
            10953368,
            10944155,
            10957408,
            10953391,
            10944270,
            10952996
        ],
        "A": [
            10940515,
            10940359,
            10941183,
            10940296,
            10949371,
            10940424,
            10950781,
            10940505,
            10961698,
            10940642,
            10940766,
            10947479,
            10940747,
            10940350,
            10941583,
            10943114,
            10940385,
            10940561,
            10940442
        ]
    },
    "name": "D. Bad Luck Island",
    "statement": "The Bad Luck Island is inhabited by three kinds of species: rocks,\r\nscissors and papers. At some moments of time two random individuals meet\r\n(all pairs of individuals can meet equiprobably), and if they belong to\r\ndifferent species, then one individual kills the other one: a rock kills\r\nscissors, scissors kill paper, and paper kills a rock. Your task is to\r\ndetermine for each species what is the probability that this species\r\nwill be the only one to inhabit this island after a long enough period\r\nof time.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define sz(x) int((x).size())\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> PII;\ntypedef std::pair<ll,ll> PLL;\n\ntemplate<class T> inline T pr(T x) { return --x; }\ntemplate<class T> inline T nx(T x) { return ++x; }\n\ntypedef long double ld;\nconst int maxn = 105;\nint r,s,p;\nld f[maxn][maxn][maxn];\nbool v[maxn][maxn][maxn];\n\nld calc(int x,int y,int z) {\n    if (v[x][y][z]) return f[x][y][z];\n    int tot = x+y+z+1;\n    f[x][y][z] = 0;\n    if (x<r && z) f[x][y][z] += calc(x+1,y,z)*z*(x+1)/((x+1)*y+(x+1)*z+y*z);\n    if (y<s && x) f[x][y][z] += calc(x,y+1,z)*x*(y+1)/(x*(y+1)+x*z+(y+1)*z);\n    if (z<p && y) f[x][y][z] += calc(x,y,z+1)*y*(z+1)/(x*y+x*(z+1)+y*(z+1));\n    v[x][y][z] = true;\n    return f[x][y][z];\n}\n\nint main() {\n    int i,j,k,t,tt,T,Test;\n    scanf(\"%d%d%d\",&r,&s,&p);\n    f[r][s][p] = 1; v[r][s][p] = 1;\n    ld a1,a2,a3;\n    a1 = a2 = a3 = 0;\n    for (i=0; i<=r; ++i)\n        for (j=0; j<=s; ++j)\n            for (k=0; k<=p; ++k) if (i || j || k) {\n                f[i][j][k] = calc(i,j,k);\n                if (j==0 && k==0) a1 += f[i][j][k];\n                if (i==0 && k==0) a2 += f[i][j][k];\n                if (i==0 && j==0) a3 += f[i][j][k];\n            }\n    printf(\"%.10f %.10f %.10f\\n\",(double)a1,(double)a2,(double)a3);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bad Luck Island.json",
    "editorial_link": "https://codeforces.com//blog/entry/17643",
    "editorial": "Let\u00e2\u0080\u0099s count the values dp[r][s][p] the probability of the situation when\r\nr rocks, s scissors and p papers are alive. The initial probability is\r\n1, and in order to calculate the others we should perform the\r\ntransitions. Imagine we have r rocks, s scissors and p papers. Let\u00e2\u0080\u0099s\r\nfind the probability of the rock killing scissors (the other\r\nprobabilities are calculated in the same way). The total number of the\r\npossible pairs where one species kills the other one is , and the number\r\nof possible pairs (rock, scissors) is . As all meetings are\r\nequiprobable, the probability we want to find is . This is the\r\nprobability with which we go the the state dp[r][s 1][p], with the\r\nnumber of scissors less by one. In the end, for example, to get the\r\nprobability of the event that the rocks are alive, we should sum all\r\nvalues dp[i][0][0] for i from 1 to r (the same goes to the other\r\nspecies).\r\n"
}