{
    "link": "https://codeforces.com//contest/344/problem/E",
    "problemId": "3466",
    "problem_idx": "E",
    "shortId": "344E",
    "contest_number": "344",
    "problem_submissions": {
        "E": [
            4466832,
            4466881,
            4466839,
            4467938,
            4467852,
            4467906,
            4467882,
            4468520,
            4468666,
            4468956,
            4470309,
            4470343,
            4470890,
            4470646,
            4467178
        ],
        "D": [
            4462598,
            4463520,
            4463970,
            4465391,
            4463898,
            4463951,
            4464720,
            4464711,
            4464808,
            4465291,
            4466089,
            4465147,
            4464978,
            4462443,
            4462461,
            4461439,
            4462978,
            4463724
        ],
        "C": [
            4462080,
            4460954,
            4462735,
            4464740,
            4461891,
            4463048,
            4463380,
            4462836,
            4462940,
            4463239,
            4462139,
            4463864,
            4466720,
            4465356,
            4460855,
            4461389,
            4462577,
            4462304
        ],
        "B": [
            4460105,
            4460097,
            4460219,
            4462525,
            4460360,
            4459970,
            4461098,
            4461404,
            4460184,
            4461242,
            4460727,
            4461556,
            4462077,
            4459824,
            4459969,
            4460167,
            4460213,
            4459935
        ],
        "A": [
            4458731,
            4458719,
            4458834,
            4459218,
            4458679,
            4458789,
            4458804,
            4460231,
            4458819,
            4459697,
            4459355,
            4459770,
            4458622,
            4459629,
            4458794,
            4458666,
            4458710,
            4458866,
            4458867
        ]
    },
    "name": "E. Read Time",
    "statement": "Mad scientist Mike does not use slow hard disks. His modification of a\r\nhard drive has not one, but different heads that can read data in\r\nparallel.When viewed from the side, Mike’s hard drive is an endless\r\narray of tracks. The tracks of the array are numbered from left to right\r\nwith integers, starting with 1. In the initial state the -th reading\r\nhead is above the track number . For each of the reading heads, the hard\r\ndrive’s firmware can move the head exactly one track to the right or to\r\nthe left, or leave it on the current track. During the operation each\r\nhead’s movement does not affect the movement of the other heads: the\r\nheads can change their relative order; there can be multiple reading\r\nheads above any of the tracks. A track is considered if at least one\r\nhead has visited this track. In particular, all of the tracks numbered ,\r\n, , have been read at the beginning of the operation. Mike needs to read\r\nthe data on distinct tracks with numbers , , , . Determine the minimum\r\ntime the hard drive firmware needs to move the heads and read all the\r\ngiven tracks. Note that an arbitrary number of other tracks can also be\r\nread.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#pragma comment(linker, \"/STACK:167772160\")\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\n\nll H[100500], P[100500];\nll dp[100500];\n\nll LLABS(ll x)\n{\n    if (x < 0)\n        return -x;\n    return x;\n}\n\nll get(int x, int i, int p)\n{\n    ll ans1 = LLABS(H[i] - P[x])*2 + LLABS(H[i] - P[p]);\n    ll ans2 = LLABS(H[i] - P[x]) + LLABS(H[i] - P[p])*2;\n    ll ans = min(ans1, ans2);\n    if (x > 0)\n        ans = max(dp[x-1], ans);\n    return ans;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"testE.txt\", \"r\", stdin);\n#endif\n\n    int N, M;\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 0; i < N; ++i)\n    {\n        scanf(\"%I64d\", &H[i]);\n    }\n\n    for (int i = 0; i < M; ++i)\n    {\n        scanf(\"%I64d\", &P[i]);\n    }\n\n    int frm = 0;\n    int to = 0;\n    memset(dp, 0x3f, sizeof(dp));\n    int prvto = 0;\n    for (int i = 0; i < N; ++i)\n    {\n        if (i > 0)\n        {\n            while (frm < M && P[frm] <= H[i-1])\n                ++frm;\n        }\n        if (i + 1 == N)\n        {\n            to = M;\n        }\n        else\n        {\n            while (to < M && P[to] < H[i+1])\n                ++to;\n        }\n\n        int x = prvto;\n        for (int p = to - 1; p >= frm; --p)\n        {\n            if (P[p] <= H[i])\n            {\n                break;\n            }\n            else\n            {\n                ll cur = P[p] - H[i];\n                if (P[prvto] < H[i])\n                    cur = max(cur, dp[prvto]);\n                dp[p] = min(dp[p], cur);\n                while (x > 0 && get(x-1, i, p) <= get(x, i, p))\n                    --x;\n                dp[p] = min(dp[p], get(x, i, p));\n            }\n        }\n        for (int p = frm; p < to; ++p)\n        {\n            if (P[p] <= H[i])\n            {\n                ll cur = H[i] - P[p];\n                if (p > 0)\n                    cur = max(cur, dp[p - 1]);\n                dp[p] = min(dp[p], cur);\n            }\n            else\n            {\n                break;\n            }\n        }\n        prvto = max(0, to - 1);\n    }\n    cout << dp[M-1] << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Read Time.json",
    "editorial_link": "https://codeforces.com//blog/entry/8860",
    "editorial": "Let's search the answer t with the binary search. Fix some value of t. Look at the first head from the left h[i] that can read track p[0]. If p[0]?>?h[i], then h[i] goes to the right t seconds and reads all tracks on its way. Otherwise if p[0]???h[i], then the head has two choices:\n\ngo to the right  seconds, then  to the left and h[i]?-?p[0] again to the left;\ngo to the left h[i]?-?p[0] seconds, then h[i]?-?p[0] to the right and t?-?2·(h[i]?-?p[0]) again to the right.\nObviously, for h[i] it is more advantageous to visit the track positioned as much as possible to the right. So we choose by . Then we move the pointer onto the first unread track, and repeat the algorithm for h[i?+?1], and so on with each head.\n\nSolution complexity: .",
    "hint": []
}