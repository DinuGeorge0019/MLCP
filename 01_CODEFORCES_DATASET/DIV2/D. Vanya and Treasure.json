{
    "link": "https://codeforces.com//contest/677/problem/D",
    "problemId": "61384",
    "problem_idx": "D",
    "shortId": "677D",
    "contest_number": "677",
    "problem_submissions": {
        "E": [
            18198164,
            18204085,
            18197306,
            18200993,
            18200953,
            18195589,
            18203905,
            18215946
        ],
        "D": [
            18193483,
            18198632,
            18200137,
            18203205,
            18194465,
            18198804,
            18199943,
            18195070,
            18202030,
            18197600,
            18197818,
            18198979,
            18200991,
            18199872,
            18199844
        ],
        "B": [
            18190137,
            18189283,
            18188934,
            18189082,
            18188438,
            18189342,
            18189575,
            18188793,
            18188689,
            18189354,
            18191729,
            18192124,
            18189662,
            18190381,
            18192321,
            18189806,
            18199099,
            18189915,
            18189024,
            18192633
        ],
        "C": [
            18189147,
            18192130,
            18193382,
            18190274,
            18190560,
            18190716,
            18189368,
            18190951,
            18190001,
            18192729,
            18189241,
            18189853,
            18190879,
            18188748,
            18189105,
            18191741,
            18199413,
            18194523,
            18189867,
            18194964
        ],
        "A": [
            18185361,
            18186546,
            18186018,
            18185448,
            18185774,
            18186287,
            18186201,
            18185979,
            18185500,
            18187073,
            18192540,
            18186205,
            18189142,
            18189736,
            18185692,
            18198474,
            18185676,
            18185395,
            18188182
        ]
    },
    "name": "D. Vanya and Treasure",
    "statement": "Vanya is in the palace that can be represented as a grid . Each room\r\ncontains a single chest, an the room located in the -th row and -th\r\ncolumns contains the chest of type . Each chest of type contains a key\r\nthat can open any chest of type , and all chests of type are not locked.\r\nThere is exactly one chest of type and it contains a treasure.Vanya\r\nstarts in cell (top left corner). What is the minimum total distance\r\nVanya has to walk in order to get the treasure? Consider the distance\r\nbetween cell (the cell in the row and column ) and is equal to .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst long long inf=1000000000ll*1000000000ll;\nint n,m,p;\nvector<long long> d[1000000];\nvector<pair<int,int> >pos[1000000];\nint a[1000][1000];\nlong long dd[303][303];\nset<pair<long long,pair<int,int> > >s;\n\nint dif(int x,int y,int xx,int yy)\n{\n    return abs(x-xx)+abs(y-yy);\n}\n\nvoid goo(int x,int y,int xx,int yy)\n{\n    if(xx<1 || xx>n || yy<0 || yy>m)\n        return;\n    if(dd[x][y]+1<dd[xx][yy])\n    {\n        s.erase(make_pair(dd[xx][yy],make_pair(xx,yy)));\n        dd[xx][yy]=dd[x][y]+1;\n        s.insert(make_pair(dd[xx][yy],make_pair(xx,yy)));\n    }\n}\n\nvoid go(int h,int h1)\n{\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            dd[i][j]=inf;\n    for(int i=0;i<pos[h].size();i++)\n    {\n        dd[pos[h][i].first][pos[h][i].second]=d[h][i];\n        s.insert(make_pair(d[h][i],make_pair(pos[h][i].first,pos[h][i].second)));\n    }\n    for(;!s.empty();)\n    {\n        pair<long long,pair<int,int> >cur=(*s.begin());\n        s.erase(s.begin());\n        int x=cur.second.first;\n        int y=cur.second.second;\n        for(int i=-1;i<=1;i++)\n            for(int j=-1;j<=1;j++)\n                if(abs(i)+abs(j)==1)\n                {\n                    goo(x,y,x+i,y+j);\n                }\n    }\n    for(int i=0;i<pos[h1].size();i++)\n        d[h1][i]=dd[pos[h1][i].first][pos[h1][i].second];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin>>n>>m>>p;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        {\n            cin>>a[i][j];\n            pos[a[i][j]].push_back(make_pair(i,j));\n        }\n    d[1].resize(pos[1].size());\n    for(int i=0;i<pos[1].size();i++)\n        d[1][i]=dif(1,1,pos[1][i].first,pos[1][i].second);\n    long long inf=1000000000ll*1000000000ll;\n    for(int i=2;i<=p;i++)\n    {\n        d[i].resize(pos[i].size());\n        for(int j=0;j<d[i].size();j++)\n            d[i][j]=inf;\n        if(pos[i-1].size()*1ll*pos[i].size()<n*m*10)\n        {\n            for(int j=0;j<pos[i-1].size();j++)\n                for(int j1=0;j1<pos[i].size();j1++)\n                    d[i][j1]=min(d[i][j1],d[i-1][j]+dif(pos[i-1][j].first,pos[i-1][j].second,pos[i][j1].first,pos[i][j1].second));\n        }else\n            go(i-1,i);\n    }\n    cout<<d[p][0]<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Vanya and Treasure.json",
    "editorial_link": "https://codeforces.com//blog/entry/45181",
    "editorial": "We can make dynamic programming , where is minimal time, that we have\r\nwaste to open the chest in the cell . For the cells of color : . For\r\neach next color we can look over all cells of color and all cells of\r\ncolor , then for each cell of color with coordinates and for each cell\r\nwith color and coordinates . But complexity of this solution is , what\r\nis not enough. We can do such improvement: let be the amount of cells of\r\ncolor , then when , we can do bfs from cells of color to cells of color\r\n. Then we will have complexity . Proof Code\r\n",
    "hint": []
}