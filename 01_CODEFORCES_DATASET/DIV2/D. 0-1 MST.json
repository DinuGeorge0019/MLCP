{
    "link": "https://codeforces.com//contest/1243/problem/D",
    "problemId": "461415",
    "problem_idx": "D",
    "shortId": "1243D",
    "contest_number": "1243",
    "problem_submissions": {
        "E": [
            64413060,
            64469730,
            64408846,
            64417229,
            64399200,
            64470547,
            64416699,
            64442944
        ],
        "D": [
            64391286,
            64397713,
            64431742,
            64397869,
            64387912,
            64386733,
            64389402,
            64387675,
            64408229,
            64380388,
            64396146,
            64395794,
            64394593,
            64392997,
            64394432,
            64400786,
            64397002,
            64396496,
            64397563,
            64397111,
            64393509
        ],
        "C": [
            64384895,
            64387481,
            64390976,
            64405340,
            64382337,
            64385693,
            64385929,
            64394275,
            64434799,
            64386198,
            64382497,
            64383809,
            64377823,
            64389605,
            64376790,
            64385883,
            64378335,
            64383814,
            64387181,
            64382731,
            64387786
        ],
        "B2": [
            64382237,
            64381285,
            64379711,
            64392921,
            64382257,
            64380535,
            64394999,
            64387075,
            64388632,
            64389667,
            64386828,
            64401152,
            64379896,
            64404188,
            64390999,
            64383775,
            64439469,
            64397436,
            64400046
        ],
        "B1": [
            64376943,
            64376875,
            64382975,
            64410900,
            64376252,
            64375532,
            64376537,
            64399066,
            64383882,
            64379534,
            64379185,
            64385521,
            64377760,
            64384722,
            64375586,
            64377602,
            64378450,
            64377183,
            64379613,
            64377830
        ],
        "A": [
            64373589,
            64373694,
            64408041,
            64373563,
            64373607,
            64373538,
            64381662,
            64378360,
            64376936,
            64374179,
            64380404,
            64373751,
            64374463,
            64373629,
            64373483,
            64374884,
            64373477,
            64375133,
            64374905
        ]
    },
    "name": "D. 0-1 MST",
    "statement": "Ujan has a lot of useless stuff in his drawers, a considerable part of\r\nwhich are his math notebooks: it is time to sort them out. This time he\r\nfound an old dusty graph theory notebook with a description of a\r\ngraph.It is an undirected weighted graph on n vertices. It is a complete\r\ngraph: each pair of vertices is connected by an edge. The weight of each\r\nedge is either 0 or 1; exactly m edges have weight 1, and all others\r\nhave weight 0.Since Ujan doesnâ€™t really want to organize his notes, he\r\ndecided to find the weight of the minimum spanning tree of the graph.\r\n(The weight of a spanning tree is the sum of all its edges.) Can you\r\nfind the answer for Ujan so he stops procrastinating?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long   ll;\ntypedef long double ld;\n\n#define all(x)  (x).begin(), (x).end()\n#define sz(x)   (x).size()\n#define pb      push_back\n#define mp      make_pair\n#define fr      first\n#define sc      second\n\nconst int N = 100 * 1000 + 5;\n\nint n, m;\nset<pair<int, int>> st;\nvector<int> gp[N];\nint vals[N];\nint harevanner[N];\n\nvoid input() {\n    cin >> n >> m;\n    for(int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        gp[u].pb(v);\n        gp[v].pb(u);\n        if (min(u, v) == 0) {\n            harevanner[max(u, v)] = 1;\n        }\n    }\n}\n\nvoid solve() {\n    vals[0] = -1;\n    for(int i = 1; i < n; i++) {\n        st.emplace(harevanner[i], i);\n        vals[i] = harevanner[i];\n    }\n    int current = 1, ans = 0;\n    while(!st.empty()) {\n        auto elem = *st.begin();\n        st.erase(st.begin());\n        if (elem.fr == current) {\n            ans++;\n        }\n        int u = elem.sc;\n        vals[u] = -1;\n        for(int v : gp[u]) {\n            if (vals[v] == -1) continue;\n            auto it = st.find(mp(vals[v], v));\n            vals[v]++;\n            st.erase(it);\n            st.emplace(vals[v], v);\n        }\n        current++;\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    int testcases = 1;\n    // scanf(\"%d\", &testcases);\n    while(testcases--) {\n        input();\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. 0-1 MST.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "First examine the given graph where there are only edges of weight 0\n: suppose that the number of connected components in this subgraph is k\n. Then the minimum spanning tree of the given graph is equal to k?1\n. Therefore, we need to find the number of such (zero weight) components in the given graph.\n\nThe following is a O(m+nlogn)\n solution. Let's maintain the zero weight components in the disjoint set union, and let's also store the size of each such component. Then we iterate over all vertices v\n from 1\n to n\n. Put the vertex v\n in a new component of size 1\n. Then we iterate over the weight 1\n edges {u,v}\n such that u<v\n. For each of the zero weight components, we count the number of edges from this component to v\n. If the number of such edges is less than the size of the component of u\n, we should merge the component of u\n with v\n (because there is at least one 0\n weight edge between this component and v\n). Otherwise we should not merge the component with v\n. In the end, we get the number of zero weight components.\n\nWhat is the complexity of such algorithm? In total, n\n new components are created in the course of the algorithm (a new one for each of the n\n vertices). When we merge some old component with v\n, the number of components decreases by 1\n. Thus the total number of such cases during the algorithm is at most O(n)\n, and for each we have one merge call for DSU. This part has O(nlogn)\n complexity.\n\nWhen we don't merge an old component with v\n, there is at least one edge of weight 1\n from this component to v\n. Therefore, the total number of such cases is at most the number of edges, m\n. Thus the complexity of processing these cases is O(m)\n.\n\nHence, the total complexity of the algorithm is O(nlogn+m)\n.",
    "hint": []
}