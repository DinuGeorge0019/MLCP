{
    "link": "https://codeforces.com//contest/1972/problem/B",
    "problemId": "2620243",
    "problem_idx": "B",
    "shortId": "1972B",
    "contest_number": "1972",
    "problem_submissions": {
        "E": [
            258907706,
            258906689,
            258908735,
            258886738,
            258901485,
            258906022,
            258913488,
            258911752,
            258913907,
            258913999,
            258916450,
            258914641,
            258910690,
            258920127,
            258912063,
            258910772,
            258915135,
            258914430
        ],
        "D2": [
            258898687,
            258895159,
            258892501,
            258911037,
            258914022,
            258908970,
            258902827,
            258898337,
            258897157,
            258907327,
            258896398,
            258902164,
            258918202,
            258887350,
            258904678,
            258922033,
            258908345,
            258904117
        ],
        "D1": [
            258879224,
            258887924,
            258886804,
            258889175,
            258886155,
            258888199,
            258887247,
            258892352,
            258882986,
            258888686,
            258890551,
            258888559,
            258871438,
            258899829,
            258888037,
            258891042,
            258898086
        ],
        "C": [
            258877059,
            258881081,
            258882446,
            258885988,
            258877387,
            258876397,
            258878529,
            258880771,
            258878031,
            258885936,
            258887870,
            258877926,
            258892416,
            258887161,
            258883084,
            258878181,
            258887720
        ],
        "B": [
            258867491,
            258869795,
            258867759,
            258890058,
            258867358,
            258869952,
            258866940,
            258871940,
            258871253,
            258870378,
            258871631,
            258870002,
            258877290,
            258868779,
            258871179,
            258886225,
            258878415
        ],
        "A": [
            258864858,
            258865079,
            258865742,
            258864993,
            258865457,
            258865824,
            258864584,
            258865871,
            258870891,
            258866770,
            258865991,
            258864627,
            258872625,
            258865600,
            258867355,
            258871468,
            258864633
        ],
        "F": [
            258956362
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129027",
    "editorial": "It can be proved that Alice will win the game if and only if the number\r\nof facing-up coins is odd.Time complexity: for each case.Proof:Consider\r\nall possible operations: : The number of decreases by . : The number of\r\ndecreases by . : The number of decreases by . : The number of increases\r\nby . It can be seen that the parity always changes.Itâs obvious that if\r\nthe number of is equal to , the player loses because there arenât any\r\navailable operations. So Alice wins if and only if the number of is odd.\r\n",
    "name": "B. Coin Games",
    "statement": "There are n coins on the table forming a circle, and each coin is either\r\nfacing up or facing down. Alice and Bob take turns to play the following\r\ngame, and Alice goes first.In each operation, the player chooses a\r\nfacing-up coin, removes the coin, and flips the two coins that are\r\nadjacent to it. If (before the operation) there are only two coins left,\r\nthen one will be removed and the other won’t be flipped (as it would be\r\nflipped twice). If (before the operation) there is only one coin left,\r\nno coins will be flipped. If (before the operation) there are no\r\nfacing-up coins, the player loses.Decide who will win the game if they\r\nboth play optimally. It can be proved that the game will end in a finite\r\nnumber of operations, and one of them will win.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std; #define int int64_t#define pb push_back#define pii pair<int, int>#define st first#define nd second#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end() int32_t main() {\tios_base::sync_with_stdio(false);\tcin.tie(NULL);\t\tint t;\tcin >> t;\twhile(t--) {\t\tint n;\t\tcin >> n;\t\tint cnt = 0;\t\tfor(int i=0;i<n;i++) {\t\t\tchar c;\t\t\tcin >> c;\t\t\tif(c=='U') cnt++;\t\t}\t\tif(cnt%2) cout << \"YES\\n\";\t\telse cout << \"NO\\n\";\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Coin Games.json",
    "hint": [
        "Hint 1 Is there anything that never / always changes after each operation?",
        "Hint 2 The parity.",
        "Hint 1 What's the answer if and ?",
        "Hint 2 What's the answer if ?",
        "Hint 3 You've already known the solution. How to improve it?",
        "Hint 1 Denote as .",
        "Hint 2 Did you notice that ? How to prove that?",
        "Hint 1 Denote as . Assume that and .",
        "Hint 2 .",
        "Hint 3 How large could and be?",
        "Hint 1 The height of a Fenwick Tree is , so operations like enumerating ancestors of each vertex will be acceptable.",
        "Hint 2 What's the coefficient of in each value of its ancestors?",
        "Hint 1 Binary search on the answer of magics.",
        "Hint 2 You may come up with many solutions with heavy data structures. Unfortunately, none of them is helpful.",
        "Hint 3 The key is to judge times whether vertex is reachable from vertex in steps, instead of querying the minimal value or something else.",
        "Hint 1 Use the simplest way to judge if an is valid.",
        "Hint 2 We've got a solution. Our target time complexity is .",
        "Hint 3 It can be boiled down to a grid path counting problem.",
        "Hint 1 Solve E1 with solution first (The solution doesn't help much in E2).",
        "Hint 2 For a single round of inclusion-exclusion, write down the form of the answer as simple as possible.",
        "Hint 1 How to maintain ? Try .",
        "Hint 2 To maintain , we can use chunking. Just +1 and .",
        "Hint 3 To finish it, consider what we do in segment-beats."
    ]
}