{
    "link": "https://codeforces.com//contest/1244/problem/D",
    "problemId": "438883",
    "problem_idx": "D",
    "shortId": "1244D",
    "contest_number": "1244",
    "problem_submissions": {
        "E": [
            62487832,
            62480584,
            62471612,
            62475861,
            62486535,
            62479379,
            62488595,
            62479897,
            62486004,
            62494290,
            62482838,
            62489756,
            62484611,
            62499649,
            62484119,
            62485010,
            62484457,
            62485159,
            62483197
        ],
        "D": [
            62485326,
            62477683,
            62472795,
            62474275,
            62479070,
            62488986,
            62484645,
            62476151,
            62481028,
            62481710,
            62472497,
            62492732,
            62480440,
            62477599,
            62480225,
            62481677,
            62477177,
            62480820,
            62477275
        ],
        "G": [
            62480107,
            62491796,
            62483655,
            62495208,
            62499859,
            62498484,
            62497339,
            62483129,
            62500589,
            62490894,
            62499284,
            62480915,
            62501144,
            62496112,
            62574872,
            62510517
        ],
        "F": [
            62476907,
            62486766,
            62497660,
            62497231,
            62492999,
            62493234,
            62492928,
            62488841,
            62496876,
            62489625,
            62495061,
            62486153,
            62494792,
            62489424,
            62493134,
            62492962,
            62496077,
            62497856,
            62496551
        ],
        "C": [
            62471680,
            62473970,
            62477877,
            62474334,
            62473816,
            62473208,
            62512963,
            62473668,
            62477041,
            62495125,
            62513108,
            62474572,
            62476360,
            62471677,
            62473875,
            62478860
        ],
        "B": [
            62467959,
            62468158,
            62464148,
            62469867,
            62471265,
            62468289,
            62470934,
            62468364,
            62468024,
            62466207,
            62466240,
            62496223,
            62469290,
            62471104,
            62469292,
            62469059,
            62467915,
            62469090,
            62470225
        ],
        "A": [
            62466123,
            62464793,
            62464086,
            62466602,
            62465923,
            62464447,
            62464989,
            62659829,
            62464905,
            62464254,
            62465585,
            62464807,
            62497112,
            62464806,
            62468732,
            62464268,
            62464707,
            62464160,
            62464768,
            62464533
        ]
    },
    "name": "D. Paint the Tree",
    "statement": "You are given a tree consisting of n vertices. A tree is an undirected\r\nconnected acyclic graph. You have to paint each vertex into one of three\r\ncolors. For each vertex, you know the cost of painting it in every\r\ncolor.You have to paint the vertices so that any path consisting of\r\nexactly three distinct vertices does not contain any vertices with equal\r\ncolors. In other words, let’s consider all triples (x, y, z) such that x\r\nneq y, y\r\nneq z, x\r\nneq z, x is connected by an edge with y, and y is connected by an edge\r\nwith z. The colours of x, y and z should be pairwise distinct. Let’s\r\ncall a painting which meets this condition .You have to calculate the\r\nminimum cost of a painting and find one of the optimal paintings. If\r\nthere is no painting, report about it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nvector<int> son[100010];\nll cost[3][100010];\nll p[3] = {0, 1, 2};\nll ans[3], _min = 1e18;\nll a[100010];\nint out[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", cost[0] + i);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", cost[1] + i);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", cost[2] + i);\n    for(int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        son[u].push_back(v), son[v].push_back(u);\n    }\n    for(int i = 1; i <= n; i++) {\n        if(son[i].size() == 1) a[1] = i;\n    }\n    for(int i = 1; i < n; i++) {\n        if(son[a[i]].size() > 2) return puts(\"-1\"), 0;\n        if(son[a[i]][0] != a[i - 1]) a[i + 1] = son[a[i]][0];\n        else a[i + 1] = son[a[i]][1];\n    }\n    do {\n        long long now = 0;\n        for(int i = 1; i <= n; i++) {\n            now += cost[p[i % 3]][a[i]];\n        }\n        if(now < _min) _min = now, memcpy(ans, p, sizeof p);\n    } while(next_permutation(p, p + 3));\n    cout << _min << endl;\n    for(int i = 1; i <= n; i++) out[a[i]] = ans[i % 3] + 1;\n    for(int i = 1; i <= n; i++) printf(\"%d%c\", out[i], \" \\n\"[i == n]);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Paint the Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/70553",
    "editorial": "The key observation is that if we fix the colors of two adjacent\r\nvertices and , then the color of any vertex adjacent to or to can be\r\nonly . So we can fix the colors of the endpoints of any edge (there are\r\npossibilities to do that), then do a traversal to color all other\r\nvertices, then do another traversal to check that we got a good\r\npainting.To avoid checking that the painting we got is good (which can\r\nbe tricky to code), we can use the fact that, for each vertex, the\r\ncolors of all its neighbours should be different from each other and\r\nfrom the color of the vertex we fixed. So, if some vertex has degree or\r\ngreater, then there is no good painting; otherwise the painting we get\r\nis good, since the graph is a chain.\r\n",
    "hint": []
}