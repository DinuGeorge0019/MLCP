{
    "link": "https://codeforces.com//contest/980/problem/F",
    "problemId": "181719",
    "problem_idx": "F",
    "shortId": "980F",
    "contest_number": "980",
    "problem_submissions": {
        "E": [
            38038539,
            38045785,
            38060701,
            38046614,
            38041883,
            38044896,
            38156095,
            38156078,
            38156061,
            38156040,
            38072066,
            38047353,
            38038047,
            38043388,
            38111608,
            38111590,
            38045284,
            38042270,
            38038266,
            38035504,
            38040125,
            38049313,
            38049169,
            38042734,
            38048647,
            38040602,
            38042070,
            38043155
        ],
        "D": [
            38033907,
            38032813,
            38038724,
            38038674,
            38041057,
            38038837,
            38034371,
            38046473,
            38049113,
            38037846,
            38051369,
            38051240,
            38044218,
            38039452,
            38054307,
            38079043,
            38079024,
            38043863,
            38813838
        ],
        "C": [
            38031306,
            38038468,
            38034397,
            38032152,
            38033603,
            38033400,
            38059857,
            38035211,
            38035303,
            38033154,
            38031809,
            38032840,
            38031754,
            38036211,
            38036608,
            38032601,
            38035163,
            38031869,
            38035397,
            38029282
        ],
        "B": [
            38028530,
            38048301,
            38030919,
            38029470,
            38030897,
            38030105,
            38029818,
            38031146,
            38060661,
            38028845,
            38030045,
            38037463,
            38028546,
            38038973,
            38029430,
            38050585,
            38032687,
            38031932
        ],
        "A": [
            38024341,
            38025152,
            38027637,
            38026879,
            38024463,
            38025009,
            38024567,
            38024355,
            38024220,
            38024988,
            38024959,
            38024227,
            38024460,
            38024685,
            38024924,
            38024456,
            38024718,
            38025274,
            38024545
        ],
        "F": [
            138375213
        ]
    },
    "name": "F. Cactus to Tree",
    "statement": "You are given a special connected undirected graph where each vertex\r\nbelongs to at most one simple cycle.Your task is to remove as many edges\r\nas needed to convert this graph into a tree (connected graph with no\r\ncycles). For each node, independently, output the maximum distance\r\nbetween it and a leaf in the resulting tree, assuming you were to remove\r\nthe edges in a way that minimizes this distance.\r\n",
    "solutions": [
        "///////////////////////////////    _LeMur_\n#define _CRT_SECURE_NO_WARNINGS\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <stack>\n#include <tuple>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <list>\n#include <map>\n#include <set>\n \nusing namespace std;\n \nconst int N = 500005;\nconst int M = 2 * N;\nconst int inf = 1000 * 1000 * 1000;\nconst int mod = 998244353;\nmt19937 myrand(chrono::steady_clock::now().time_since_epoch().count());\n\nint n, m;\nvector < pair<int, int> > g[N];\n\nbool mark[M];\nbool used[N];\nint parent[N], ind[N];\n\nvector < vector<int> > G;\nvector <int> gcycle[N];\n\nvoid dfs(int v, int p) {\n  used[v] = true;\n\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n\n    if (to == p || mark[id]) continue;\n\n    if (used[to]) {\n      vector <int> cycle;\n\n      int gag = v;\n      while (gag != to) {\n        cycle.push_back(gag);\n        mark[ind[gag]] = true;\n        gag = parent[gag];\n      }\n      mark[id] = true;\n      cycle.push_back(gag);\n\n      gcycle[gag].push_back((int)G.size());\n      G.push_back(cycle);\n      continue;\n    }\n\n    parent[to] = v;\n    ind[to] = id;\n    dfs(to, v);\n  }\n}\n\nint dp[N], dpup[N];\n\nint max_in_multiset(multiset <int> &Q) {\n  if ((int)Q.size() == 0) return 0;\n  auto it = Q.end();\n  --it;\n  return *it;\n}\n\nint cycle1(int id) {\n  vector <int> cycle = G[id];\n  cycle.pop_back();\n\n  multiset <int> Q;\n  for (int i = 0; i < (int)cycle.size(); i++) {\n    int v = cycle[i];\n    Q.insert(i + 1 + dp[v]);\n  }\n  int answ = max_in_multiset(Q);\n\n  for (int i = (int)cycle.size() - 1; i >= 0; i--) {\n    int v = cycle[i];\n    Q.erase(Q.find(i + 1 + dp[v]));\n    Q.insert(dp[v] + (int)cycle.size() - i);\n    answ = min(answ, max_in_multiset(Q));\n  }\n\n  return answ;\n}\n\nvector <int> val[N];\n\nvoid dfs1(int v, int p) {\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n    if (to == p || mark[id]) continue;\n    dfs1(to, v);\n    dp[v] = max(dp[v], dp[to] + 1);\n  }\n  for (int i = 0; i < (int)gcycle[v].size(); i++) {\n    int id = gcycle[v][i];\n    for (int j = 0; j < (int)G[id].size() - 1; j++) {\n      int to = G[id][j];\n      dfs1(to, v);\n    }\n    val[v].push_back(cycle1(id));\n    dp[v] = max(dp[v], val[v].back());\n  }\n}\n\nvoid cycle2(int id, int up) {\n  vector <int> vals, cycle;\n  cycle = G[id];\n  cycle.insert(cycle.end(), G[id].begin(), G[id].end());\n  cycle.pop_back();\n\n  int sz = (int)G[id].size();\n  for (int i = 0; i < (int)cycle.size(); i++) {\n    int v = cycle[i];\n    if (i < sz - 1) {\n      vals.push_back(dp[v]);\n    } else if (i == sz - 1) {\n      vals.push_back(up);\n    } else {\n      vals.push_back(dp[v]);\n    }\n  }\n\n  multiset <int> Qleft, Qright;\n  int sz_left = sz / 2;\n  int sz_right = sz - 1 - sz_left;\n\n  for (int i = 0; i < sz; i++) {\n    if (i < sz_left) {\n      Qleft.insert(vals[i] - i);\n    } else if (i > sz_left) {\n      Qright.insert(vals[i] + i);\n    }\n  }\n\n  for (int i = sz_left; i < sz_left + sz; i++) {\n    int v = cycle[i];\n    if (v != G[id][sz - 1]) {\n      dpup[v] = max(max_in_multiset(Qleft) + i, max_in_multiset(Qright) - i);\n    }\n    ///\n    Qleft.erase(Qleft.find(vals[i - sz_left] - (i - sz_left)));\n    Qleft.insert(vals[i] - i);\n    ///\n    Qright.erase(Qright.find(vals[i + 1] + i + 1));\n    Qright.insert(vals[i + 1 + sz_right] + i + 1 + sz_right);\n  }\n}\n\nvoid dfs2(int v, int p) {\n  multiset <int> Q;\n\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n    if (to == p || mark[id]) continue;\n    Q.insert(dp[to] + 1);\n  }\n  for (int x: val[v]) Q.insert(x);\n\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n    if (to == p || mark[id]) continue;\n    Q.erase(Q.find(dp[to] + 1));\n    dpup[to] = max(dpup[v], max_in_multiset(Q)) + 1;\n    Q.insert(dp[to] + 1);\n\n    dfs2(to, v);\n  }\n\n  for (int i = 0; i < (int)gcycle[v].size(); i++) {\n    int id = gcycle[v][i];\n\n    Q.erase(Q.find(val[v][i]));\n    int up = max(dpup[v], max_in_multiset(Q));\n    Q.insert(val[v][i]);\n\n    cycle2(id, up);\n\n    for (int j = 0; j < (int)G[id].size() - 1; j++) {\n      int to = G[id][j];\n      dfs2(to, v);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a].push_back(make_pair(b, i));\n    g[b].push_back(make_pair(a, i));\n  }\n\n  dfs(1, -1);\n  dfs1(1, -1);\n  dfs2(1, -1);\n  \n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", max(dp[i], dpup[i]));\n  }\n  cout << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Cactus to Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/59350",
    "editorial": "The following solution is implemented in 136 lines, but most of it is a\r\nsimple BFS and two DFS functions for finding bridges and marking cycles,\r\nthe main part of the solution is implemented in 38 lines. Please check\r\nthe code after (or while?) reading if it is not clear.Note that if we\r\nrun a BFS from a node , the BFS spanning tree will represent the edges\r\nthat we should keep to minimize the answer for node . So we actually\r\nneed to find the maximum length out of all shortest paths that starts at\r\nand end at every other node.We will first focus on finding the answer\r\nfor each node on one cycle: For each node on the cycle, we can compute ,\r\nthe length of the longest shortest path that starts at node and uses\r\nonly the edges that do not belong to the cycle. This can be done using\r\nBFS in for one cycle.Using the computed values, we can find the final\r\nanswer for all nodes on the cycle in , or , where is the number of nodes\r\non the cycle.For a node , we need to find a node on the cycle such that\r\nis maximized, where is the length of the shortest path between and on\r\nthe cycle. Therefore, the answer with regards to each node will be the\r\nmaximum between and , for each node in the same cycle as .We can do this\r\nusing a heap and prefix sums idea as follows: loop for iterations over\r\nthe cycle nodes, in the iteration () add the value to the heap with the\r\ntime it was added in (, time is decreasing), that is, add the pair ().\r\nNow at a given iteration , pop from the heap all top values added at\r\ntime greater than , as canât exceed . Now assuming the top pair in the\r\nqueue is (), then is a possible answer for this node.We need to do this\r\nagain in counter-clockwise. Since we will visit each node four times,\r\nkeep the maximum distance found for each node in the cycle and the final\r\nanswer for that node will be .Now if we have the answer for one cycle,\r\nwhen we move using an edge () to another cycle (or node), we only need\r\nto know one value to be able to solve the next cycle, that value is the\r\nmaximum between and the length of the longest path that goes through\r\nbridges other than (). This value is increased by when passed since we\r\nwill move through the edge ().Marking the bridges will help in deciding\r\nif an edge will take us outside a cycle or not so we can compute . Also\r\nremoving the bridges will make it easy to find which nodes form each\r\ncycle.We can find any BFS spanning tree and use it to find the length of\r\nthe longest path that starts at a node and uses a bridge first, note\r\nthat this distance goes only down as the tree is rooted at the starting\r\nnode, but the values for every in the first cycle will be correct so we\r\ncan start with them.\r\n",
    "hint": []
}