{
    "link": "https://codeforces.com//contest/909/problem/F",
    "problemId": "142272",
    "problem_idx": "F",
    "shortId": "909F",
    "contest_number": "909",
    "problem_submissions": {
        "D": [
            33703562,
            33684475,
            33687934,
            33679960,
            33681845,
            33678239,
            33681778,
            33682813,
            33684628,
            33683979,
            33684264,
            33683734,
            33682267,
            33684172,
            33684972,
            33684951,
            37837707,
            33689232,
            33685173
        ],
        "C": [
            33702243,
            33685781,
            33688791,
            33678737,
            33677527,
            33680778,
            33679730,
            33677867,
            33678218,
            33679090,
            33681226,
            33679711,
            33679799,
            33678914,
            33682105,
            33681294,
            33679526,
            33680909
        ],
        "F": [
            33682616,
            33683222,
            33692268,
            33694692,
            33695944
        ],
        "E": [
            33680057,
            33686075,
            33684461,
            33682298,
            33685101,
            33681929,
            33683773,
            33684555,
            33682566,
            33680995,
            33686514,
            33687842,
            33689439,
            33687234,
            33687184,
            33690952,
            33683720,
            33689497
        ],
        "B": [
            33678984,
            33689620,
            33681003,
            33675642,
            33677938,
            33674594,
            33675218,
            33675981,
            33675928,
            33676067,
            33676981,
            33677469,
            33675490,
            33680062,
            33675898,
            33676219,
            33677187
        ],
        "A": [
            33675962,
            33690137,
            33674036,
            33674451,
            33674005,
            33674337,
            33674208,
            33673945,
            33674163,
            33674088,
            33674166,
            33675518,
            33673927,
            33674572,
            33673981,
            33673915,
            33676471
        ]
    },
    "name": "F. AND-permutations",
    "statement": "Given an integer , find two permutations: Permutation of numbers from 1\r\nto such that and for all . Permutation of numbers from 1 to such that\r\nand for all . is the bitwise AND operation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n#define lbt(x) ((x)&(-(x)))\nconst int MX=100005;\nint lg2[MX];\nint n;\nint p[MX],visp[MX];\nbool dfsp(int k){\n\tif(k>n){\n\t\tfor(int i=1;i<=n;i++)if(p[i]==i)return false;\n\t\tfor(int i=1;i<=n;i++)if(p[i]&i)return false;\n\t\treturn true;\n\t}else{\n\t\tfor(int i=1;i<=n;i++)if(!visp[i]){\n\t\t\tvisp[i]=1,p[k]=i;\n\t\t\tif(dfsp(k+1))return true;\n\t\t\tp[k]=0,visp[i]=0;\n\t\t}\n\t\treturn false;\n\t}\n}\nvoid solp(){\n\tif(n<=9){\n\t\tif(dfsp(1)){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tfor(int i=1;i<=n;i++)cout<<p[i]<<' ';cout<<endl;\n\t\t}else cout<<\"NO\"<<endl;\n\t\treturn;\t\n\t}\n\tif(n&1){cout<<\"NO\"<<endl;return;}\n\tfor(int i=n,j;i;i=j){\n\t\tfor(j=i;j&&lg2[j]==lg2[i];j--);\n\t\tint it=j;\n\t\tfor(j=i;j&&lg2[j]==lg2[i];j--)p[j]=it*2-j+1,p[it*2-j+1]=j;\n\t\tj=2*it-i;\n\t}\n\tfor(int i=1;i<=n;i++)if(p[i]==i)cerr<<\"!!!!!!!!!p1\"<<i<<endl;\n\tfor(int i=1;i<=n;i++)if(p[i]&i)cerr<<\"!!!!!!!!!p2\"<<i<<endl;\n\tcout<<\"YES\"<<endl;\n\tfor(int i=1;i<=n;i++)cout<<p[i]<<' ';cout<<endl;\n}\nint q[MX],visq[MX];\nbool dfsq(int k){\n\tif(k>n){\n\t\tfor(int i=1;i<=n;i++)if(q[i]==i)return false;\n\t\tfor(int i=1;i<=n;i++)if(!(q[i]&i))return false;\n\t\treturn true;\n\t}else{\n\t\tfor(int i=1;i<=n;i++)if(!visq[i]){\n\t\t\tvisq[i]=1,q[k]=i;\n\t\t\tif(dfsq(k+1))return true;\n\t\t\tq[k]=0,visq[i]=0;\n\t\t}\n\t\treturn false;\n\t}\n}\nint bel[MX],t[MX];\nvoid solq(){\n\tif(n<=9){\n\t\tif(dfsq(1)){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tfor(int i=1;i<=n;i++)cout<<q[i]<<' ';cout<<endl;\n\t\t}else cout<<\"NO\"<<endl;\n\t\treturn;\n\t}\n\tif(n==lbt(n)){cout<<\"NO\"<<endl;return;}\n\tmemset(bel,-1,sizeof(int)*(n+1));\n\tfor(int i=1;i<=n;i++){\n\t\tif(i==lbt(i)){\n\t\t\tbel[i]=lg2[lbt(i)];\n\t\t\tif(i>1)bel[i+1]=lg2[lbt(i)];\n\t\t}\n\t}\n\tbel[7]=0;\n\tfor(int i=1;i<=n;i++)if(bel[i]==-1)bel[i]=lg2[lbt(i)];\n\tfor(int i=0;i<=lg2[n];i++){\n\t\tint tc=0;\n\t\tfor(int j=1;j<=n;j++)if(bel[j]==i)t[tc++]=j;\n\t\tif(!tc)continue;\n\t\tfor(int j=0;j<tc;j++)q[t[j]]=t[(j+1)%tc];\n\t}\n\tfor(int i=1;i<=n;i++)if(q[i]==i)cerr<<\"!!!!!!!!!q1\"<<i<<endl;\n\tfor(int i=1;i<=n;i++)if(!(q[i]&i))cerr<<\"!!!!!!!!!q2\"<<i<<endl;\n\tcout<<\"YES\"<<endl;\n\tfor(int i=1;i<=n;i++)cout<<q[i]<<' ';cout<<endl;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tlg2[1]=0;\n\tfor(int i=2;i<=n;i++)lg2[i]=lg2[i>>1]+1;\n\tsolp();\n\tsolq();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. AND-permutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/56666",
    "editorial": "If is odd, the answer is NO. Indeed, any number in odd-numbered position\r\nmust be even, otherwise the last bit of is 1. For odd there are less\r\neven numbers than odd-numbered positions, so at least one of the\r\npositions will hold an odd number, thus itâs impossible to construct a\r\nrequired permutation. If is even, the required permutation exists. To\r\nbuild it, first observe that . For example, for : and so on. We can use\r\nthis fact to always match and with each other, that is, set and . The\r\nfull procedure for constructing the required permutation is as follows.\r\nFor a given even , find the maximum power of two that is less than or\r\nequal to . Match pairs of numbers and for each . If we are not done yet,\r\nnumbers from to are still unmatched. Repeat the process for . For\r\nexample, for on the first step we set and match numbers 15-16, 14-17 and\r\n13-18. On the second step unmatched numbers are from 1 to 12, so we set\r\nand match numbers 7-8, 6-9, 5-10, 4-11 and 3-12. On the third and the\r\nlast step the remaining unmatched numbers are 1 and 2, so we set and\r\nmatch numbers 1 and 2 with each other. After this no unmatched numbers\r\nare left, and we are done. We can do a simple case analysis for\r\nmanually, noticing that the answer is NO for , a possible answer for is\r\ntextbf{3 6 2 5 1 4} as given in problem statement, and a possible answer\r\nfor is\r\ntextbf{7 3 6 5 1 2 4}. If is a power of two, then it is represented in\r\nbinary as . We must have , therefore , so the binary representation of\r\nis shorter than that of . It follows that , so the answer is NO in this\r\ncase. Finally, if and is not a power of two, the required permutation\r\nalways exists, and can be built in the following way. Split all numbers\r\nfrom 1 to into the following groups ( is the largest power of two which\r\nis still less than ): 1..7 8..15 16..31\r\nldots For the first group use the permutation that we found manually.\r\nFor each of the remaining groups, use any permutation of numbers in this\r\ngroup (for example, a cyclic permutation). The numbers in each group\r\nhave leading non-zero bit at the same position (which corresponds to the\r\npower of two at the beginning of the group), so it is guaranteed that\r\ncontains a non-zero bit at least in that position.\r\n",
    "hint": []
}