{
    "link": "https://codeforces.com//contest/1935/problem/F",
    "problemId": "2510290",
    "problem_idx": "F",
    "shortId": "1935F",
    "contest_number": "1935",
    "problem_submissions": {
        "F": [
            249811158,
            249879664,
            249914146,
            253436865,
            253436779,
            249829995,
            249883407,
            250140723,
            250140588
        ],
        "E": [
            249795863,
            249806897,
            249806016,
            249798150,
            249809204,
            249810510,
            249813605,
            249811376,
            249815627,
            249812083,
            249809741,
            249806184,
            249812511,
            249817539,
            249815136,
            249812113,
            249814837,
            249819842
        ],
        "B": [
            249781740,
            249751689,
            249753292,
            249765548,
            249748977,
            249751802,
            249753680,
            249757222,
            249771661,
            249760318,
            249763328,
            249766386,
            249759882,
            249765172,
            249756443,
            249760201,
            249770177,
            249763394,
            249755331
        ],
        "C": [
            249775741,
            249762276,
            249765158,
            249776179,
            249761477,
            249764700,
            249766485,
            249776568,
            249788464,
            249770693,
            249776753,
            249780744,
            249769798,
            249778919,
            249777602,
            249777662,
            249785568,
            249777744,
            249769139
        ],
        "D": [
            249754703,
            249774116,
            249776894,
            249784670,
            249778866,
            249776850,
            249778167,
            249792030,
            249756994,
            249781860,
            249794874,
            249794304,
            249791400,
            249793376,
            249789336,
            249797727,
            249794804,
            249793568,
            249791344
        ],
        "A": [
            249745747,
            249745965,
            249747700,
            249754230,
            249752123,
            249745614,
            249941865,
            249747635,
            249746024,
            249765018,
            249751275,
            249749292,
            249756879,
            249748862,
            249749602,
            249746174,
            249751494,
            249751493,
            249747948,
            249747369
        ]
    },
    "name": "F. Andrey s Tree",
    "statement": "Master Andrey loves trees^{\r\ndagger} very much, so he has a tree consisting of n vertices.But it\u2019s\r\nnot that simple. Master Timofey decided to steal one vertex from the\r\ntree. If Timofey stole vertex v from the tree, then vertex v and all\r\nedges with one end at vertex v are removed from the tree, while the\r\nnumbers of other vertices remain unchanged. To prevent Andrey from\r\ngetting upset, Timofey decided to make the resulting graph a tree again.\r\nTo do this, he can add edges between any vertices a and b, but when\r\nadding such an edge, he must pay |a - b| coins to the Master\u2019s\r\nAssistance Center.Note that the resulting tree vertex v.Timofey has not\r\nyet decided which vertex v he will remove from the tree, so he wants to\r\nknow for each vertex 1\r\nleq v\r\nleq n, the minimum number of coins needed to be spent to make the graph\r\na tree again after removing vertex v, as well as which edges need to be\r\nadded.^{\r\ndagger}A tree is an undirected connected graph without cycles.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)\n#define cln cerr<<\"Line:   \"<<__LINE__<<\"    \"\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]='\\n';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,ans,sz[N],f[N];\nint gf(int x){while(x!=f[x])x=f[f[f[f[x]]]];return x;}\nvector<int>lk[N];\nint stk[N],tp;\nstruct dat{\n    int l,r;\n    dat operator+(const dat &z)\n    const{return{min(l,z.l),max(r,z.r)};}\n}bc[N],d[N];\nbitset<N>vs;\nvoid mg(int x,int y){\n    x=gf(x),y=gf(y);\n    if(x!=y){\n        if(sz[x]<sz[y])swap(x,y);\n        sz[f[y]=x]+=sz[y];\n        stk[++tp]=y,bc[tp]=d[x],d[x]=d[x]+d[y];\n    }\n}\nvoid rec(){\n    int x=stk[tp];\n    d[f[x]]=bc[tp--];\n    sz[f[x]]-=sz[x],f[x]=x;\n}\nstruct Eg{int x,y;}g[N];\nint gt;\nvoid sol(int l,int r){\n    if(l==r){\n        int i,y,k,lt=tp;\n        gt=0;\n        for(int x:lk[l]){\n            y=gf(x);\n            // printf(\"_l:%d y:%d l:%d r:%d\\n\",l,y,d[y].l,d[y].r);\n            if(d[y].l>1&&d[y].l-1!=l){\n                k=gf(d[y].l-1);\n                g[++gt]={d[y].l-1,d[y].l};\n                mg(k,y);\n            }y=gf(x);\n            if(d[y].r<n&&d[y].r+1!=l){\n                k=gf(d[y].r+1);\n                g[++gt]={d[y].r,d[y].r+1};\n                mg(k,y);\n            }\n        }\n        for(int x:lk[l]){\n            y=gf(x);\n            if(d[y].r==l-1&&l<n){\n                g[++gt]={l-1,l+1};\n                break;\n            }\n        }\n        while(tp>lt)rec();\n        for(i=1,k=0;i<=gt;++i)k+=g[i].y-g[i].x;\n        printf(\"%d %d\\n\",k,gt);\n        for(i=1;i<=gt;++i)printf(\"%d %d\\n\",g[i].x,g[i].y);\n        puts(\"\");\n    }else{\n        int md=l+r>>1,lt=tp,i,x;\n        for(x=r;x>md;--x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(l,md);\n        for(x=r;x>md;--x)vs[x]=0;\n        while(tp>lt)rec();\n        for(x=l;x<=md;++x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(md+1,r);\n        for(x=l;x<=md;++x)vs[x]=0;\n        while(tp>lt)rec();\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<n;++i){\n            cin>>x>>y;\n            lk[x].push_back(y);\n            lk[y].push_back(x);\n        }\n        for(x=1;x<=n;++x)\n            sz[f[x]=x]=1,d[x]={x,x};\n        sol(1,n);\n        for(x=1;x<=n;++x)lk[x].clear();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "dsu",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Andrey s Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/126662",
    "editorial": "TutorialLet\u00e2\u0080\u0099s fix some vertex for which the answer is being calculated.\r\nSuppose the degree of the vertex in the tree is , then it\u00e2\u0080\u0099s clear that\r\nit\u00e2\u0080\u0099s necessary to add edges. Consider the components that appear after\r\nremoving . Then, the goal is to use the new edges to unite all the\r\ncomponents into one, using the minimum total cost. This is the same as\r\nfinding the minimum spanning tree in a graph, where the vertices are the\r\ncomponents that resulted from removing , and for every , an edge with a\r\nweight of is drawn between the components containing and .Let\u00e2\u0080\u0099s simulate\r\nKruskal\u00e2\u0080\u0099s algorithm for this graph. Consider all the single-weight edges\r\nin this graph: . It\u00e2\u0080\u0099s clear that using the single-weight edges, the\r\nvertices with numbers will definitely end up in one component, and the\r\nvertices with numbers will also end up in one component. To unite these\r\ntwo components, it would be optimal to add an edge .It turns out that\r\nit\u00e2\u0080\u0099s sufficient to consider only all the single-weight edges and the\r\nedge . Let\u00e2\u0080\u0099s limit the number of single-weight edges to . For this, in\r\neach component , calculate and the minimum and maximum in the component,\r\nrespectively. Claim: among the single-weight edges, it\u00e2\u0080\u0099s sufficient to\r\nconsider edges of the form , . ProofFirst, understand when it\u00e2\u0080\u0099s\r\nnecessary to add the edge . Note that if there\u00e2\u0080\u0099s at least one component\r\nsuch that , then the edge won\u00e2\u0080\u0099t be needed; otherwise, it will be. This\r\nis quite easy to show by simulating Kruskal\u00e2\u0080\u0099s algorithm.Let . We\u00e2\u0080\u0099ll show\r\nthat using edges , all components will unite. Go through the vertices\r\nfrom to and maintain the invariant that all vertices from to are in one\r\ncomponent. At , this holds. When is the minimum in some component, then\r\nthe edge will be added, and since is in one component with , will now\r\nalso be. When is not the minimum in some component, then the minimum in\r\nthe component will be in one component with (, the invariant holds),\r\nmeaning will also be in one component with . Thus, it turns out that all\r\nwill be in one component.Now consider an arbitrary . Separately consider\r\nthe prefix of vertices and the suffix . Then, similarly to , it can be\r\nshown that for the prefix of vertices , using edges of the form , you\r\ncan unite . Similarly, for the suffix of vertices , using edges of the\r\nform , you can unite .Now, if the edge is necessary, then add it to the\r\nanswer. Otherwise, there\u00e2\u0080\u0099s at least one component such that , meaning\r\nthe prefix of vertices and the suffix will unite into one\r\ncomponent.Finding , for each component is straightforward; what remains\r\nis to determine which components are connected by the edges , . This can\r\nbe done with binary search through the Euler tour of the tree. After\r\nthat, Kruskal\u00e2\u0080\u0099s algorithm can be initiated to calculate the answer.Let\u00e2\u0080\u0099s\r\nestimate the time complexity. For a specific vertex , the time\r\ncomplexity will be , so the total time complexity is .Depending on the\r\nimplementation of the last step, the problem can be solved in , , where\r\nis the inverse Ackermann function relative to .\r\n"
}