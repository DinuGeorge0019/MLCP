{
    "link": "https://codeforces.com//contest/1778/problem/F",
    "problemId": "1760991",
    "problem_idx": "F",
    "shortId": "1778F",
    "contest_number": "1778",
    "problem_submissions": {
        "F": [
            191602138,
            191602532,
            191585447,
            191594114,
            191608712,
            191599535,
            191655210,
            191599057,
            191639606,
            191639396,
            194532248,
            191803468
        ],
        "E": [
            191585870,
            191584814,
            191630281,
            191592729,
            191585095,
            191596251,
            191595141,
            191596106,
            191592952,
            191595620,
            191594841,
            191592544,
            191599842,
            192093615,
            191596381,
            191597065,
            191595454
        ],
        "D": [
            191578502,
            191573421,
            191565024,
            191574576,
            191564042,
            191573088,
            191575933,
            191584703,
            191563224,
            191573409,
            191579570,
            191582926,
            191579755,
            191563101,
            191580474,
            191576462,
            192093593,
            191580965,
            191580785,
            191581424
        ],
        "C": [
            191564515,
            191569583,
            191570422,
            191567662,
            191567630,
            191565698,
            191566998,
            191565471,
            191569851,
            191564933,
            191565678,
            191572047,
            191565438,
            191575434,
            191578186,
            191570415,
            192093564,
            191571887,
            191568771,
            191569498
        ],
        "B": [
            191559138,
            191557434,
            191555391,
            191555255,
            191553335,
            191555438,
            191554286,
            191555414,
            191559515,
            191556063,
            191555690,
            191562726,
            191558781,
            191582547,
            191561046,
            191559475,
            192093542,
            191562296,
            191558152,
            191563075
        ],
        "A": [
            191546307,
            191548742,
            191545919,
            191546220,
            191545819,
            191546256,
            191546020,
            191545963,
            191558184,
            191545949,
            191545987,
            191550651,
            191554728,
            191565464,
            191546734,
            191548201,
            192093519,
            191547332,
            191546175,
            191551024
        ]
    },
    "name": "F. Maximizing Root",
    "statement": "You are given a rooted tree consisting of n vertices numbered from 1 to\r\nn. Vertex 1 is the root of the tree. Each vertex has an integer value.\r\nThe value of i-th vertex is a_i. You can do the following operation at\r\nmost k times. Choose a vertex v and an integer x such that x is a common\r\ndivisor of the values of all vertices of the subtree of v. Multiply by x\r\nthe value of each vertex in the subtree of v. What is the maximum\r\npossible value of the root node 1 after at most k operations? Formally,\r\nyou have to maximize the value of a_1.A tree is a connected undirected\r\ngraph without cycles. A rooted tree is a tree with a selected vertex,\r\nwhich is called the root. The subtree of a node u is the set of all\r\nnodes y such that the simple path from y to the root passes through u.\r\nNote that u is in the subtree of u.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\nconst int N=1e5+5;\nint dp[N][1005],G[1005][1005],tmp[1005],a[N];\nvector<int> d[1005],Tr[N];\nint T,n,k,u,v;\nvoid dfs(int u, int f){\n\tfor (int i=0; i<=1000; i++) dp[u][i]=1e9;\n\tfor (int i:d[a[u]]) dp[u][i]=0;\n\tfor (int v:Tr[u]){\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t\tfor (int i:d[a[u]]){\n\t\t\tfor (int j:d[a[v]]){\n\t\t\t\tint r=G[i][j],r2=G[i/r][j];\n\t\t\t\ttmp[r]=min(tmp[r],dp[u][i]+dp[v][j]);\n\t\t\t\ttmp[r*r2]=min(tmp[r*r2],dp[u][i]+dp[v][j]+1);\n\t\t\t}\n\t\t}\n\t\tfor (int i:d[a[u]]) dp[u][i]=tmp[i],tmp[i]=1e9;\n\t}\n}\nint main(){\n\tfor (int i=1; i<=1000; i++)\n\t\tfor (int j=1; j<=1000; j++) G[i][j]=__gcd(i,j);\n\tfor (int i=1; i<=1000; i++)\n\t\tfor (int j=i; j<=1000; j+=i) d[j].push_back(i);\n\tmemset(tmp,0x3f,sizeof(tmp));\n\tfor (cin>>T; T; T--){\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\t\tfor (int i=1; i<n; i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tTr[u].push_back(v),Tr[v].push_back(u);\n\t\t}\n\t\t\n\t\tdfs(1,0); int ans=a[1];\n\t\tfor (auto i:d[a[1]]){\n\t\t\tif (dp[1][i]<=k) ans=max(ans,i);\n\t\t\tif (dp[1][i]<k) ans=max(ans,a[1]*i);\n//\t\t\tprintf(\"%d %d\\n\",i,dp[1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tfor (int i=1; i<=n; i++) Tr[i].clear();\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Maximizing Root.json",
    "editorial_link": "https://codeforces.com//blog/entry/112149",
    "editorial": "Let, be the value of node and be the minimum number of moves required to\r\nmake the GCD of the subtree of equal to a multiple of .Now, if the\r\nsubtree GCD of node is already a multiple of and if is not a multiple of\r\n.For each divisor of , suppose, we want to perform the move on the\r\nsubtree of by multiplying each node value of the subtree with iff is a\r\nmultiple of and is a divisor of . In this case, we have to make the GCD\r\nof all the subtree of child nodes of equal to a multiple of before\r\nperforming the move on the subtree of . This is because we have to make\r\neach node of the subtree a multiple of to get the multiple of after\r\nperforming the move on the subtree of node using . Also, to perform the\r\nmove of multiplying by , the value of each subtree node should be a\r\nmultiple of . So we have to make each node value a multiple of .So, will\r\nbe calculated from for each divisor of for all child of .Now, is the\r\nanswer where is the largest divisor of such that .Time Complexity: where\r\nis the number of divisors of .\r\n"
}