{"link": "https://codeforces.com//contest/347/problem/A", "problemId": "3508", "problem_idx": "A", "shortId": "347A", "contest_number": "347", "problem_submissions": {"C": [4518768, 4513742, 4517653, 4518839, 4520636, 4513589, 4515480, 4513320, 4513590, 4521190, 4514183, 4515546, 4513940, 4516018, 4514431, 4512340, 4514717, 4516799, 4519674], "D": [4515778, 4520517, 4519885, 4520973, 4523724, 4519031, 4523601], "B": [4512188, 4512255, 4513932, 4514468, 4511829, 4511441, 4512094, 4512109, 4512127, 4512494, 4511760, 4512987, 4512079, 4512011, 4512852, 4513990, 4514484, 4513535, 4513631, 4514973], "A": [4510977, 4511197, 4511967, 4512169, 4511066, 4511024, 4511167, 4511360, 4511075, 4511574, 4515121, 4511042, 4511261, 4512777, 4514480, 4513698, 4511919, 4511676, 4512313], "E": [4519822, 4520189, 4521340, 4522190]}, "name": "A. Difference Row", "statement": "You want to arrange integers in some order in a row. Let\u2019s define the\r\nvalue of an arrangement as the sum of differences between all pairs of\r\nadjacent integers.More formally, let\u2019s denote some arrangement as a\r\nsequence of integers , where sequence is a permutation of sequence . The\r\nvalue of such an arrangement is .Find the largest possible value of an\r\narrangement. Then, output the lexicographically smallest sequence that\r\ncorresponds to an arrangement of the largest possible value.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cmath>\n\nusing namespace std;\n\n#define DBG(z) cerr << #z << \": \" << (z) << endl\n#define NEWL cerr << endl\n#define passert(x, m) {if (!(x)) {cerr << m << \"  ::  \";} assert(x);}\n#define err(s) cerr << \"\u001b[92m\" << s << \"\u001b[0m\" << endl\n#define LINE cerr << \"DEBUG LINE: \" << __LINE__ << endl\n\n#define IT(v) __typeof((v).begin())\n#define mem(f, a) memset(f, a, sizeof(f))\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define for_each(it, v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)\n#define next_int() ({int __t; scanf(\"%d\", &__t); __t;})\n\nint main() {\n    int n = next_int();\n    vector <int> a(n);\n    for (int i = 0; i < a.size(); ++i) a[i] = next_int();\n    sort(all(a));\n    swap(a[0], a[n - 1]);\n    for (int i = 0; i < a.size(); ++i) {\n        if (i) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n}\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation", "sortings"], "dificulty": "1300", "interactive": false}