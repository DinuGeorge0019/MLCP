{
    "link": "https://codeforces.com//contest/1694/problem/F",
    "problemId": "1430899",
    "problem_idx": "F",
    "shortId": "1694F",
    "contest_number": "1694",
    "problem_submissions": {
        "E": [
            160856186,
            160866174,
            160873008,
            160869335,
            160868951,
            160877330,
            160898676,
            160877174,
            160875442,
            160876502,
            160879470,
            160875237,
            160876355,
            160882396,
            160879879,
            160879629,
            160876481,
            160881373,
            160884964,
            160881275
        ],
        "D": [
            160848272,
            160842517,
            160849905,
            160853063,
            160857057,
            160853921,
            160854624,
            160847127,
            160845187,
            160855341,
            160850688,
            160860686,
            160857001,
            160853657,
            160862452,
            160862852,
            160864038,
            160855376,
            160858063
        ],
        "C": [
            160836570,
            160829494,
            160839678,
            160844593,
            160847177,
            160836731,
            160843728,
            160843693,
            160838092,
            160845965,
            160845179,
            160854286,
            160843446,
            160844276,
            160856430,
            160857207,
            160844960,
            160846963,
            160849978
        ],
        "B": [
            160832238,
            160835941,
            160831844,
            160834416,
            160835663,
            160829339,
            160834030,
            160840102,
            160851072,
            160836730,
            160864814,
            160845534,
            160830377,
            160835010,
            160833897,
            160845509,
            160927414,
            160837907,
            160860824,
            160841779
        ],
        "A": [
            160832046,
            160833611,
            160826245,
            160824355,
            160825264,
            160825514,
            160825648,
            160826360,
            160852110,
            160825530,
            160855429,
            160829525,
            160824626,
            160825478,
            160825695,
            160824627,
            160922182,
            160921765,
            160830254,
            160825318,
            160825557
        ],
        "F": [
            160914915
        ]
    },
    "name": "F. Decinc Dividing",
    "statement": "Letâ€™s call an array a of m integers a_1, a_2,\r\nldots, a_m if a can be made increasing by removing a decreasing\r\nsubsequence (possibly empty) from it. For example, if a = [3, 2, 4, 1,\r\n5], we can remove the decreasing subsequence [a_1, a_4] from a and\r\nobtain a = [2, 4, 5], which is increasing.You are given a permutation p\r\nof numbers from 1 to n. Find the number of pairs of integers (l, r) with\r\n1\r\nle l\r\nle r\r\nle n such that p[l\r\nldots r] (the subarray of p from l to r) is a array.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <set>\n#define lowbit(i)((i)&(-(i)))\n#define N 201000\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-') flag = true; c = getchar(); }\n\twhile (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();\n\tif (flag) x = -x;\n}\nusing namespace std;\ntemplate<typename T> inline void MAX(T &a, T b) {\n\tif (b > a)\ta = b;\n}\nint n;\nint p[N], pos[N];\nint pre[N], nxt[N];\nset<int> st;\ninline void init() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tset<int>::iterator it = st.insert(pos[i]).first;\n\t\tif (it != st.begin()) --it, pre[pos[i]] = *it;\n\t}\n\tst.clear();\n\tfor (int i = n; i; --i) {\n\t\tset<int>::iterator it = st.insert(pos[i]).first;\n\t\tif ((++it) != st.end()) nxt[pos[i]] = *it;\n\t}\n\tst.clear();\n}\nint tre[N];\ninline void add(int p, int v) {\n\tfor (int i = p; i <= n; i += lowbit(i))\n\t\tMAX(tre[i], v);\n}\ninline int query(int p) {\n\tint res = 0;\n\tfor (int i = p; i; i -= lowbit(i))\n\t\tMAX(res, tre[i]);\n\treturn res;\n}\nint tol[N];\ninline void find_tol() {\n\tfor (int i = n; i; --i) {\n\t\tint p = pos[i];\n\t\tif (pre[p]) MAX(tol[p], query(pre[p]));\n\t\tif (nxt[p]) add(nxt[p], p);\n\t}\n\tmemset(tre, 0, sizeof(tre));\n\tmemset(pre, 0, sizeof(pre));\n\tmemset(nxt, 0, sizeof(nxt));\n}\ninline void work() { init(); find_tol(); }\ninline void get_ans() {\n\tfor (int i = 2; i <= n; ++i) MAX(tol[i], tol[i - 1]);\n\tlong long res = 0;\n\tfor (int i = 1; i <= n; ++i) res += i - tol[i];\n\t//for (int i = 1; i <= n; ++i) printf(\"tol[%d] = %d\\n\", i, tol[i]);\n\tprintf(\"%lld\\n\", res);\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) read(p[i]), pos[p[i]] = i;\n\twork();\n\tfor (int i = 1; i <= n; ++i) p[i] = n - p[i] + 1, pos[p[i]] = i;\n\twork();\n\tget_ans();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "data structures",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Decinc Dividing.json",
    "editorial_link": "https://codeforces.com//blog/entry/103952",
    "editorial": "Let's solve the problem for a single subarray.\n\nAssume the i\n-th element belongs to the increasing subsequence. Define dpl,i\n for the interval [l,i]\n as the maximum value the last element of the decreasing subsequence can have. It's +?\n in case the decreasing subsequence is empty. It's ??\n if the array is not possible.\n\nAssume the i\n-th element belongs to the decreasing subsequence. Define pdl,i\n for the interval [l,i]\n as the minimum value the last element of the increasing subsequence can have. It's ??\n in case the increasing subsequence is empty. It's +?\n if the array is not possible.\n\nThe interval [l,r]\n is not Decinc if and only if dpl,r=??\n and pdl,r=+?\n.\n\nIterate over l\n from n\n to 1\n and keep the dp\n and pd\n values updated (shown in the implementation).\n\nWe claim that each dp\n or pd\n value will change at most three times throughout the algorithm.\n\nFor some index i\n assume j\n is the largest index smaller than i\n such that aj>aj+1\n.\n\ndpi\n can only be one of these four values: ??,+?,aj,aj+1\n.\n\nBecause the last element of the decreasing subsequence can't be before the j\n-th element. And if it's some k\n that lies on the interval [j+2,i?1]\n you can simply move it to the increasing subsequence since both (k?1\n)-th and (k+1\n)-th elements belong to the increasing subsequence.\n\nThe same applies for pdi\n.\n\nSo the upd\n function is called O(n)\n times in total.\n\nTime complexity: O(n)",
    "hint": []
}