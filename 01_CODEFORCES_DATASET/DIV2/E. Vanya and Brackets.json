{"link": "https://codeforces.com//contest/552/problem/E", "problemId": "29865", "problem_idx": "E", "shortId": "552E", "contest_number": "552", "problem_submissions": {"E": [11646876, 11645914, 11646152, 11649972, 11649705, 11649254, 11649323, 11649002, 11652530, 11648502, 11648682, 11644488, 11651947], "D": [11640438, 11641253, 11643031, 11645042, 11638109, 11641642, 11643248, 11642812, 11645189, 11653069, 11638747, 11644748, 11637258, 11646037, 11643577, 11645065, 11645584, 11650005], "C": [11638883, 11643048, 11640597, 11643428, 11643543, 11646030, 11644783, 11645127, 11637655, 11645256, 11659993, 11639889, 11660703, 11640924, 11642914], "B": [11636441, 11637487, 11637412, 11638261, 11639028, 11636467, 11638358, 11637713, 11644065, 11640586, 11636843, 11637147, 11640517, 11646494, 11637818, 11638869, 11636892], "A": [11635963, 11636114, 11636315, 11636121, 11639545, 11635795, 11635940, 11635876, 11635929, 11637062, 11635777, 11635996, 11641441, 11647153, 11636326, 11637141, 11635979]}, "name": "E. Vanya and Brackets", "statement": "Vanya is doing his maths homework. He has an expression of form , where\r\nare digits from to , and sign represents either a plus \u201d or the\r\nmultiplication sign . Vanya needs to add pair of brackets in this\r\nexpression so that to maximize the value of the resulting expression.\r\n", "solutions": ["#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nconst int MAXV = 12345;\n\nint N = 0;\nll ans = 0;\n\nstring s;\nint vals[MAXV];\nbool mult[MAXV];\n\npair<ll, ll> pref[MAXV];\npair<ll, ll> suff[MAXV];\n\nint main(){\n    setup();\n    cin >> s;\n    N = (s.size()+1)/2;\n\n    for(int i=0; i<N; i++){\n        vals[i] = s[2*i]-'0';\n        if(i) mult[i-1] = s[2*i-1]=='*';\n    }\n\n    if(N == 1){ cout << vals[0] << endl; return 0; }\n    if(N == 2){ cout << (mult[0] ? vals[0] * vals[1] : vals[0] + vals[1]) << endl; return 0; }\n\n    pref[0] = {1, 0};\n    for(int i=1; i<N; i++){\n        if(mult[i-1]){\n            pref[i].first = pref[i-1].first * vals[i-1];\n            pref[i].second = pref[i-1].second;\n        }\n        else{\n            pref[i].first = 1;\n            pref[i].second = vals[i-1] * pref[i-1].first + pref[i-1].second;                 \n        }\n    }    \n\n    suff[N-1] = {1, 0};\n    for(int i=N-1; i>=1; i--){\n        if(i<N-1){\n            if(mult[i]){\n                suff[i].first = suff[i+1].first * vals[i+1];\n                suff[i].second = suff[i+1].second;\n            }\n            else{\n                suff[i].first = 1;\n                suff[i].second = vals[i+1] * suff[i+1].first + suff[i+1].second;\n            }\n        }\n  \n        ll sum = 0;\n        ll prod = vals[i]; \n        for(int j=i; j>=0; j--){\n            ll cand = pref[j].first * suff[i].first * (sum + prod)\n                    + pref[j].second + suff[i].second;\n            ans = max(ans, cand);\n            \n            if(!j) break;\n            if(mult[j-1]) prod *= vals[j-1];\n            else{ sum += prod; prod = vals[j-1]; }\n        } \n    }\n\n    cout << ans << endl;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "expression parsing", "greedy", "implementation", "strings"], "dificulty": "2100", "interactive": false}