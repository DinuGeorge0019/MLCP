{"link": "https://codeforces.com//contest/63/problem/D", "problemId": "339", "problem_idx": "D", "shortId": "63D", "contest_number": "63", "problem_submissions": {"E": [311463, 311795, 311658, 312041, 311459, 311614, 312617, 312614, 312611, 311794, 313907], "D": [310975, 311092, 311255, 311536, 312237, 314064, 312662, 313516, 311785, 311719, 311559, 312152, 311462, 311572], "C": [310530, 310622, 311964, 310809, 310631, 310750, 310684, 311187, 310895, 310934, 311409, 312431, 312213], "B": [310080, 310144, 310881, 310482, 310197, 310082, 310056, 310432, 310241, 310401, 310624, 310354, 310493], "A": [309670, 309659, 310177, 310020, 309894, 309667, 309653, 309878, 309812, 309824, 309970, 309929, 310031]}, "name": "D. Dividing Island", "statement": "A revolution took place on the Buka Island. New government replaced the\r\nold one. The new government includes parties and each of them is\r\nentitled to some part of the island according to their contribution to\r\nthe revolution. However, they can\u2019t divide the island.The island can be\r\nconventionally represented as two rectangles and unit squares in size\r\ncorrespondingly. The rectangles are located close to each other. At\r\nthat, one of the sides with the length of and one of the sides with the\r\nlength of lie on one line. You can see this in more details on the\r\npicture. The -th party is entitled to a part of the island equal to unit\r\nsquares. Every such part should fully cover several squares of the\r\nisland (it is not allowed to cover the squares partially) and be a\r\nconnected figure. A \"connected figure\" presupposes that from any square\r\nof this party one can move to any other square of the same party moving\r\nthrough edge-adjacent squares also belonging to that party.Your task is\r\nto divide the island between parties.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nchar s[105][105];\n\n#define h(x) (x >= a ? d : b)\n\nint main (void)\n{\n  int a, b, c, d, n;\n  scanf(\"%d%d%d%d%d\", &a, &b, &c, &d, &n);\n\n  for (int i=0; i<max(b,d); i++)\n    memset(s[i], '.', a + c);\n\n  int x = 0, y = 0, dy = 1;\n  if (a % 2 == 1) {\n    y = b - 1;\n    dy = -1;\n  }\n\n  for (int i=0; i<n; i++) {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n//      cerr << y << \" \" << x << \" \" << i << endl;\n      s[y][x] = 'a' + i;\n      y += dy;\n      if (y < 0) {\n        y = 0;\n        x++;\n        dy = 1;\n      } else if (y >= h(x)) {\n        x++;\n        y=h(x) - 1;\n        dy = -1;\n      }\n    }\n  }\n\n  puts(\"YES\");\n\n  for (int i=0; i<max(b,d); i++)\n    puts(s[i]);\n  \n  return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1900", "interactive": false}