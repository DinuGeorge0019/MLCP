{
    "link": "https://codeforces.com//contest/1638/problem/A",
    "problemId": "1297615",
    "problem_idx": "A",
    "shortId": "1638A",
    "contest_number": "1638",
    "problem_submissions": {
        "E": [
            146394309,
            146388037,
            146392264,
            146392799,
            146383148,
            146391230,
            146412303,
            146401025,
            146403078,
            146402136,
            179550421,
            146406748,
            146402980,
            146407733,
            146480267,
            146392395,
            146416198,
            146408751,
            146407567,
            146399245,
            146416242,
            146413814
        ],
        "D": [
            146373961,
            146380846,
            146385038,
            146375477,
            146392500,
            146381733,
            146401310,
            146378870,
            146384454,
            146387386,
            146387880,
            146390053,
            146382176,
            146480222,
            146406431,
            146388651,
            146388267,
            146392625,
            146412206,
            146374640,
            146389515
        ],
        "C": [
            146366299,
            146372352,
            146371729,
            146367670,
            146366106,
            146373666,
            146370507,
            146365761,
            146370642,
            146376834,
            146376510,
            146371594,
            146370051,
            146480186,
            146375503,
            146369319,
            146374946,
            146378437,
            146373206,
            146367076,
            146373277
        ],
        "B": [
            146362311,
            146363442,
            146362707,
            146365725,
            146364605,
            146363885,
            146366228,
            146383066,
            146364746,
            146368584,
            146368423,
            146367380,
            146366091,
            146480117,
            146369102,
            146364936,
            146367883,
            146370547,
            146366764,
            146364119,
            146368017
        ],
        "A": [
            146361810,
            146361860,
            146361937,
            146362725,
            146362534,
            146362379,
            146363944,
            146381318,
            146362119,
            146362820,
            146362493,
            146479991,
            146363108,
            146363259,
            146480100,
            146363531,
            146362617,
            146363968,
            146362163,
            146363256,
            146362105,
            146365613
        ],
        "F": [
            154464206,
            146479912,
            146613983,
            146474726,
            146640126
        ]
    },
    "name": "A. Reverse",
    "statement": "You are given a permutation p_1, p_2,\r\nldots, p_n of length n. You have to choose two integers l,r (1\r\nle l\r\nle r\r\nle n) and reverse the subsegment [l,r] of the permutation. The\r\npermutation will become p_1,p_2,\r\ndots, p_{l-1},p_r,p_{r-1},\r\ndots, p_l,p_{r+1},p_{r+2},\r\ndots ,p_n.Find the lexicographically smallest permutation that can be\r\nobtained by performing one reverse operation on the initial\r\npermutation.Note that for two distinct permutations of equal length a\r\nand b, a is lexicographically smaller than b if at the first position\r\nthey differ, a has the smaller element.A permutation is an array\r\nconsisting of n distinct integers from 1 to n in arbitrary order. For\r\nexample, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation\r\n(2 appears twice in the array) and [1,3,4] is also not a permutation\r\n(n=3 but there is 4 in the array).\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\nconst int N=1000005;\n\nint p[N],n;\n\nvoid solve(){\n\tn=read();\n\trep(i,1,n)p[i]=read();\n\trep(i,1,n){\n\t\tif(p[i]!=i){\n\t\t\trep(j,i,n)if(p[j]==i){\n\t\t\t\treverse(p+i,p+j+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trep(i,1,n)printf(\"%d \",p[i]);puts(\"\");\n}\n\nint main(){\n\tint T=read();\n\twhile(T--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Reverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/99942",
    "editorial": "The key idea is to start merging from the beginning using a stack.\r\nAssume that the connected components are always segments in the\r\npermutation (this solution also proves this by induction).We will\r\niterate the prefix and maintain in our stack the minimum/maximum element\r\nof all the segments in order. When we increase the prefix adding the\r\nnext position , we add to the top of the stack. Then, we merge the top\r\ntwo segments while we are able to. If the top two segments have their\r\nminimum/maximum elements and , in this order from the top, we will merge\r\nthem only if , because this means that an edge exist between the\r\ntwo.When we reach the end, our stack contains all connected components.\r\nNote that merging two adjacent intervals forms a new interval, so we\r\nhave proven by induction that our first assumption is correct.Time\r\ncomplexity: .\r\n"
}