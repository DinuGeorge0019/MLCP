{
    "link": "https://codeforces.com//contest/567/problem/F",
    "problemId": "32465",
    "problem_idx": "F",
    "shortId": "567F",
    "contest_number": "567",
    "problem_submissions": {
        "E": [
            12368419,
            12374631,
            12397425,
            12788088,
            12389152,
            12406146
        ],
        "D": [
            12361936,
            12364905,
            12366026,
            12367144,
            12362999,
            12362187,
            12362197,
            12363830,
            12363930,
            12363691,
            12364368,
            12363078,
            12362951,
            12369923,
            12364411,
            12364518,
            12365344,
            12364031,
            12364332
        ],
        "C": [
            12358359,
            12361761,
            12364757,
            12364566,
            12375712,
            12357726,
            12357396,
            12357507,
            12355472,
            12358430,
            12360526,
            12359721,
            12359102,
            12360618,
            12360834,
            12358973,
            12358889,
            12361330
        ],
        "B": [
            12356896,
            12358133,
            12362101,
            12361060,
            12355833,
            12356064,
            12358845,
            12355641,
            12356983,
            12356330,
            12357412,
            12355553,
            12354653,
            12356634,
            12358468,
            12356890,
            12356104,
            12359549
        ],
        "A": [
            12353500,
            12353898,
            12359353,
            12355278,
            12353802,
            12353454,
            12354645,
            12353575,
            12353588,
            12353804,
            12354250,
            12353515,
            12353505,
            12353940,
            12356166,
            12354753,
            12353585,
            12355460
        ],
        "F": [
            12373751,
            12373972,
            12370851,
            12374943
        ]
    },
    "name": "F. Mausoleum",
    "statement": "King of Berland Berl IV has recently died. Hail Berl V! As a sign of the\r\nhighest achievements of the deceased king the new king decided to build\r\na mausoleum with Berl IV\u2019s body on the main square of the capital.The\r\nmausoleum will be constructed from blocks, each of them has the shape of\r\na cuboid. Each block has the bottom base of a meter square. Among the\r\nblocks, exactly two of them have the height of one meter, exactly two\r\nhave the height of two meters, ..., exactly two have the height of\r\nmeters.The blocks are arranged in a row without spacing one after the\r\nother. Of course, not every arrangement of blocks has the form of a\r\nmausoleum. In order to make the given arrangement in the form of the\r\nmausoleum, it is necessary that when you pass along the mausoleum, from\r\none end to the other, the heights of the blocks first were (i.e.,\r\nincreasing or remained the same), and then (decrease or remained\r\nunchanged). It is possible that any of these two areas will be omitted.\r\nFor example, the following sequences of block height meet this\r\nrequirement: ; ; ; . Suddenly, more requirements appeared. Each of the\r\nrequirements has the form: \" \", where is the height of the -th block,\r\nand a is one of the five possible signs: \u201d (equals), \u201d (less than), \u201d\r\n(more than), \u201d (less than or equals), \u201d (more than or equals). Thus,\r\neach of the additional requirements is given by a pair of indexes , ()\r\nand sign .Find the number of possible ways to rearrange the blocks so\r\nthat both the requirement about the shape of the mausoleum (see\r\nparagraph 3) and the additional requirements were met.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define ll long long\nusing namespace std;\nint n,k;\nll f[110][110];\nstruct P{\n    int c,x,y;\n}a[110];\nbool check(int p,int q,int l,int r){\n    for (int i=1;i<=k;i++){\n        if (a[i].x==a[i].y){\n            if (a[i].c==1) return false;else continue;\n        }\n        if (a[i].c==0){\n            if (a[i].x==p&&a[i].y!=q) return false;\n            if (a[i].x==q&&a[i].y!=p) return false;\n            if (a[i].x>=l&&a[i].x<=r&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n            if (a[i].y>=l&&a[i].y<=r&&(!(a[i].x>=l&&a[i].x<=r))) return false; \n        }\n        if (a[i].c==1){\n            if (a[i].x==p&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n            if (a[i].x==q&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n            if ((a[i].x>=l&&a[i].x<=r)&&(!(a[i].y>=l&&a[i].y<=r))) return false; \n        }\n        if (a[i].c==2){\n            if (a[i].x==p&&(!((a[i].y>=l&&a[i].y<=r)||(a[i].y==q)))) return false;\n            if (a[i].x==q&&(!((a[i].y>=l&&a[i].y<=r)||(a[i].y==p)))) return false;\n            if (a[i].x>=l&&a[i].x<=r&&(!(a[i].y>=l&&a[i].y<=r))) return false;\n        } \n    }\n    return true;\n}\nint main(){\n//  freopen(\"test.in\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&k);\n    char ch1,ch2;\n    for (int i=1;i<=k;i++){\n        scanf(\"%d%c%c%c%d\\n\",&a[i].x,&ch1,&ch1,&ch2,&a[i].y);\n        if (ch1=='=') a[i].c=0;\n        if (ch1=='<'&&ch2==' ') a[i].c=1;\n        if (ch1=='<'&&ch2=='=') a[i].c=2;\n        if (ch1=='>'&&ch2==' ') a[i].c=3;\n        if (ch1=='>'&&ch2=='=') a[i].c=4;\n        if (a[i].c==3) a[i].c=1,swap(a[i].x,a[i].y);\n        if (a[i].c==4) a[i].c=2,swap(a[i].x,a[i].y);\n    }\n    memset(f,0,sizeof(f));\n    for (int i=1;i<2*n;i++) if (check(i,i+1,0,0)) f[i][i+1]=1;\n    for (int l=4;l<=2*n;l+=2)\n        for (int i=1;i+l-1<=2*n;i++){\n            int j=i+l-1;\n            if (check(i,j,i+1,j-1)) f[i][j]+=f[i+1][j-1];\n            if (check(i,i+1,i+2,j)) f[i][j]+=f[i+2][j];\n            if (check(j-1,j,i,j-2)) f[i][j]+=f[i][j-2];\n        }\n    printf(\"%I64d\",f[1][2*n]);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mausoleum.json",
    "editorial_link": "https://codeforces.com//blog/entry/19604",
    "editorial": "Consider that we are placing blocks by pairs, one pair by one, starting\r\nfrom leftmost and rightmost places. Thus, for example, two blocks of\r\nheight 1 we could place in positions 1 and 2, 1 and , or and . The\r\nsegment of unused positions will be changed that way and the next block\r\npairs should be placed on new leftmost and rightmost free places. At\r\nlast only two positions will be free and we should place two blocks of\r\nheight on them. Any correct sequence of blocks could be builded that\r\nway. Let\u00e2\u0080\u0099s try to review the requirements consider such way of placing\r\nblocks. As soon as we place blocks one by one, the requirements are now\r\nonly describes the order of placing blocks. For example, requirement\r\n\u00e2\u0080\u009d3 >= 5\u00e2\u0080\u009d means that we should place block in position 3 only if block in\r\nposition 5 is already placed (and thus it have lesser height), or we\r\nplace pair of blocks of same height on them at one moment. For counting\r\nrequired number of sequences we will use dynamic programming approach.\r\nLet\u00e2\u0080\u0099s count the number of ways to place some blocks in the way that only\r\npositions at segment are free. The height of current placed pair of\r\nblocks is counted from the segment borders itself (. Fix one way of\r\nplacing current block pair (exclusion is ). Now check if such placing\r\nmeets the requirements. We will consider only requirements that meets\r\none of the current-placing positions. For every \"current\" position \"<\"\r\nmust be true only for free positions (positions in , which do not equal\r\nto current positions), \">\" must be true for already-placed positions\r\n(out of ) and \"=\" must be true only for second current position. This DP\r\ncould be easily calculated using \"lazy\" approach. Author solution\r\n"
}