{
    "link": "https://codeforces.com//contest/919/problem/F",
    "problemId": "152092",
    "problem_idx": "F",
    "shortId": "919F",
    "contest_number": "919",
    "problem_submissions": {
        "E": [
            34759854,
            34759008,
            34755530,
            34755071,
            34767384,
            34769825,
            34762286,
            34765859,
            34757902,
            34756808,
            34754350,
            34754906,
            34754485,
            34764184,
            34764060,
            34765778,
            34765644,
            34766112,
            34770806,
            34758487
        ],
        "D": [
            34759692,
            34756182,
            34766669,
            34747857,
            34750540,
            34761944,
            34744086,
            34755286,
            34747306,
            34747805,
            34758206,
            34746635,
            34748995,
            34743941,
            34750352,
            34751132,
            34754972,
            34756086,
            34749125,
            34751985
        ],
        "F": [
            34756268,
            34770726,
            34767209,
            34940216,
            34940205,
            34940167,
            34768110
        ],
        "C": [
            34755543,
            34745303,
            34743775,
            34749427,
            34742058,
            34751454,
            34747057,
            34746048,
            34744189,
            34743121,
            34786015,
            34743288,
            34741969,
            34754924,
            34754196,
            34743195,
            34748307,
            34749924,
            34748253,
            34744412
        ],
        "A": [
            34741202,
            34738877,
            34738230,
            34738207,
            34743521,
            34740387,
            34738030,
            34738271,
            34738995,
            34738099,
            34737984,
            34739113,
            34738625,
            34738247,
            34738122,
            34738762,
            34738024,
            34737950,
            34738747
        ],
        "B": [
            34740191,
            34740735,
            34740551,
            34773488,
            34738696,
            34749487,
            34740570,
            34740622,
            34740449,
            34739728,
            34741488,
            34740826,
            34738595,
            34739371,
            34739374,
            34739976,
            34741055,
            34741170,
            34739403,
            34740674
        ]
    },
    "name": "F. A Game With Numbers",
    "statement": "Imagine that Alice is playing a card game with her friend Bob. They both\r\nhave exactly 8 cards and there is an integer on each card, ranging from\r\n0 to 4. In each round, Alice or Bob in turns choose two cards from\r\ndifferent players, let them be a and b, where a is the number on the\r\nplayer\u2019s card, and b is the number on the opponent\u2019s card. It is\r\nnecessary that a\r\ncdot b\r\nne 0. Then they calculate c = (a + b)\r\nbmod 5 and replace the number a with c. The player who ends up with\r\nnumbers on all 8 cards being 0, wins.Now Alice wants to know who wins in\r\nsome situations. She will give you her cards\u2019 numbers, Bob\u2019s cards\u2019\r\nnumbers and the person playing the first round. Your task is to\r\ndetermine who wins if both of them choose the best operation in their\r\nrounds.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct sta{\n\tint a[8];\n\tvoid srt(){sort(a,a+8);}\n\tsta(){memset(a,0,sizeof(a));}\n\tsta(int hs){for(int i=7;i>=0;i--)a[i]=hs%5,hs/=5;}\n\tint& operator[](const int x){return a[x];}\n\tint hs()const{\n\t\tint ans=0;\n\t\tfor(int i=0;i<8;i++)ans=ans*5+a[i];\n\t\treturn ans;\n\t}\n\tvoid rd(){for(int i=0;i<8;i++)cin>>a[i];}\n};\nconst int MX=10000005;\ntypedef long long LL;\nint F[10000005],S[10000005];int c=0;\nint ans[10000005];\ninline int NO(int i,int j){return (i-1)*c+j;}\n//LL hs(const int f,const sta &a,const sta &b){return f|(LL)a.hs()<<30|(LL)b.hs()<<1;}\nvoid dfs(int k,int lst,int hs){\n\tif(k==8){S[++c]=hs,F[hs]=c;return;}\n\tfor(int i=lst;i<=5;i++)dfs(k+1,i,hs*5+i);\n}\nstruct edge{\n\tint t,nxt;\n}e[10000005];\nint hed[10000005],ec;\nint q[10000005],ind[10000005];\ninline void ade(int f,int t){++ind[t];++ec;e[ec].t=t,e[ec].nxt=hed[f],hed[f]=ec;}\nvoid buildg(){\n\tfor(int i=1;i<=c;i++)\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tsta a(S[i]),b(S[j]);\n\t\t\tfor(int k=7;k>=0&&a[k];k--){\n\t\t\t\tint vis[5];memset(vis,0,sizeof(vis));\n\t\t\t\tsta c;\n\t\t\t\tfor(int l=7;l>=0&&b[l];l--)\n\t\t\t\t\tvis[(a[k]+b[l])%5]=1;\n\t\t\t\tfor(int l=0,t;l<5;l++)if(vis[l]){\n\t\t\t\t\tc=a;c[k]=l;c.srt();\n\t\t\t\t\tt=F[c.hs()];\n\t\t\t\t\tade(NO(j,t),NO(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tint h=0,t=0;\n\tfor(int i=2;i<=c;i++)\n\t\tans[NO(i,1)]=-1,q[++t]=NO(i,1);\n\twhile(h<t){\n\t\tint r=q[++h];\n\t\tfor(int i=hed[r];i;i=e[i].nxt)if(!ans[e[i].t]){\n\t\t\tif(ans[r]==-1)ans[e[i].t]=1,q[++t]=e[i].t;\n\t\t\telse if(--ind[e[i].t]==0)ans[e[i].t]=-1,q[++t]=e[i].t;\n\t\t}\n\t}\n}\nchar _s[3][10]={\n\t\"Bob\",\n\t\"Deal\",\n\t\"Alice\"\n};\nint main(){\n\tios::sync_with_stdio(false);\n\tdfs(0,0,0);//cerr<<c<<endl;\n\tbuildg();//cerr<<ec<<endl;\n\tint T;cin>>T;\n\twhile(T--){\n\t\tint f;cin>>f;\n\t\tsta a,b;a.rd(),b.rd();\n\t\tif(f)swap(a,b);\n\t\ta.srt(),b.srt();\n\t\tint r=ans[NO(F[a.hs()],F[b.hs()])];\n\t\tif(f)r*=-1;\n\t\tcout<<_s[r+1]<<endl;\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. A Game With Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/57462",
    "editorial": "First we should notice that the useful number of states isn\u00e2\u0080\u0099t something\r\nlike , because the order of the numbers in each player\u00e2\u0080\u0099s hand does not\r\nmatter. Therefore, the useful states of each player is . Then the useful\r\nstates is estimated as , which is .Then we can abstract those states as\r\nnodes, then link those nodes with directed edges which shows the\r\ntransformation between two states (i.e. one can make one step to the\r\nother). Then we run BFS (or topological sort) on that graph. For a\r\ncertain state, if all states it links out: has a state that the current\r\nplayer will win. Then the current player will win. has a state that the\r\nwill get into a deal. Then the current player will make it deal. are all\r\nlose states. Then the current player will lose. It is because the\r\ncurrent player can choose the best way to go.So we can do some\r\ninitialization to get the \"Win\", \"Lose\" or \"Deal\" status for all\r\npossible states. Follow these steps shown below. Give all states that is\r\neasily to identify a status \"Win\" or \"Lose\". Then push them into a\r\nqueue. For other states, give \"Deal\" temporarily. Take a state from the\r\nfront of the queue. Update all states that can reach this state in one\r\nstep (i.e. has an edge between them) using the rule shown above. If the\r\nstate can be defined as one status, push it into the queue and go to the\r\nsecond step. Or you can ignore it and go to the second step instantly.\r\nAfter this step (or we can say \"Initialization\"), we can answer those\r\nqueries easily. , where is the card number one player has, and is the\r\nmodulo. Here we have and . Can you prove that the useful state of each\r\nplayer is ?\r\n"
}