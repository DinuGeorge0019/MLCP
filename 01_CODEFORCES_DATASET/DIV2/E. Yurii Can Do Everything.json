{
    "link": "https://codeforces.com//contest/1438/problem/E",
    "problemId": "793476",
    "problem_idx": "E",
    "shortId": "1438E",
    "contest_number": "1438",
    "problem_submissions": {
        "F": [
            98319461
        ],
        "E": [
            98311897,
            98314215,
            98306470,
            98317401,
            98315562,
            98322785,
            98318720,
            99208201,
            99208187,
            99208130,
            98328285,
            98328073,
            98322490,
            98320922,
            98318257,
            98322974,
            98321581
        ],
        "D": [
            98297867,
            98301844,
            98300240,
            98304054,
            98318299,
            98309651,
            98315030,
            98308693,
            98315767,
            98313297,
            98316364,
            98315158,
            98303678,
            98304345,
            98304632,
            98306346,
            98305264,
            98305346,
            98303552,
            98306335
        ],
        "C": [
            98289953,
            98289036,
            98308314,
            98293256,
            98292637,
            98297135,
            98292890,
            98294300,
            98300290,
            98319932,
            98304074,
            98317336,
            98290569,
            98289827,
            98289903,
            98288415,
            98294636,
            98293103,
            98292335,
            98295796
        ],
        "B": [
            98286960,
            98285186,
            98298192,
            98293037,
            98287297,
            98288613,
            98287215,
            98290416,
            98288546,
            98286932,
            98293844,
            98285378,
            98286885,
            98286961,
            98287702,
            98285226,
            98286945,
            98289425,
            98287421,
            98290261
        ],
        "A": [
            98283268,
            98281489,
            98282933,
            98292930,
            98282693,
            98281140,
            98281789,
            98285668,
            98284421,
            98282468,
            98283785,
            98281307,
            98281791,
            98283429,
            98281766,
            98282741,
            98281310,
            98282372,
            98281634,
            98285176
        ]
    },
    "name": "E. Yurii Can Do Everything",
    "statement": "Yurii is sure he can do everything. Can he solve this task, though?He\r\nhas an array a consisting of n positive integers. Let\u2019s call a subarray\r\na[l...r] if the following conditions are simultaneously satisfied: l+1\r\nleq r-1, i. e. the subarray has length at least 3; (a_l\r\noplus a_r) = (a_{l+1}+a_{l+2}+\r\nldots+a_{r-2}+a_{r-1}), where\r\noplus denotes the bitwise XOR operation. In other words, a subarray is\r\ngood if the bitwise XOR of the two border elements is equal to the sum\r\nof the rest of the elements. Yurii wants to calculate the total number\r\nof good subarrays. What is it equal to?An array c is a subarray of an\r\narray d if c can be obtained from d by deletion of several (possibly,\r\nzero or all) elements from the beginning and several (possibly, zero or\r\nall) elements from the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e5 + 3;\nconst int LOG_N = 30;\n\nint a[N], n;\nll prefix[N];\n\nll get_sum(int l, int r){\n    if(!l) return prefix[r];\n    return prefix[r] - prefix[l - 1];\n}\n\nbool check(int l, int r){\n    //cout << \"check \" << l << \" \" << r << endl; \n    if(r - l + 1 < 3) return false;\n    if(get_sum(l + 1, r - 1) != (a[l] ^ a[r])) return false;\n    return true;\n}\n\nint solve(int l, int r){\n    if(r - l + 1 < 3) return 0;\n    //cout << \"solve \" << l << \" \" << r << endl; \n\n    int mx = 0;\n    for(int i = l; i <= r; ++i)\n        mx = max(mx, a[i]);\n\n    int bit = LOG_N - 1;\n    while(!((mx >> bit) & 1)) bit--;\n\n    vector<int> pos;\n    for(int i = l; i <= r; ++i)\n        if((a[i] >> bit) & 1)\n            pos.push_back(i);\n\n    int ans = 0;\n    for(int i = 0; i < (int)pos.size() - 1; ++i)\n        ans += check(pos[i], pos[i + 1]);\n\n    for(int i = 0; i < (int)pos.size(); ++i){\n        int from;\n        int to;\n\n        if(i) from = pos[i - 1] + 1;\n        else from = l;\n\n        if(i != (int)pos.size() - 1) to = pos[i + 1] - 1;\n        else to = r;\n\n        for(int j = from; j <= to; ++j){\n            if(j == pos[i]) continue;\n            if(j < pos[i]) ans += check(j, pos[i]);\n            else ans += check(pos[i], j);\n        }\n    }\n\n    for(int i = 0; i < (int)pos.size(); ++i){\n        if(i){\n            int to;\n            if(i != (int)pos.size() - 1) to = pos[i + 1] - 1;\n            else to = r;\n\n            for(int j = pos[i] + 1; j <= to; ++j)\n                ans += check(pos[i - 1], j);\n        }\n        if(i != (int)pos.size() - 1){\n            int to;\n            if(i) to = pos[i - 1] + 1;\n            else to = l;\n\n            for(int j = pos[i] - 1; j >= to; --j)\n                ans += check(j, pos[i + 1]);\n        }\n    }\n\n    pos.insert(pos.begin(), l - 1);\n    pos.push_back(r + 1);\n    for(int i = 0; i < (int)pos.size() - 1; ++i)\n        ans += solve(pos[i] + 1, pos[i + 1] - 1);\n\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i)\n        cin >> a[i];\n\n    prefix[0] = a[0];\n    for(int i = 1; i < n; ++i)\n        prefix[i] = prefix[i - 1] + a[i];\n\n    cout << solve(0, n - 1) << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "divide and conquer",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Yurii Can Do Everything.json",
    "editorial_link": "https://codeforces.com//blog/entry/84589",
    "editorial": "It\u00e2\u0080\u0099s natural to think that the number of good subarrays cannot be very\r\nlarge; this is indeed true.The following algorithm works: Fix the left\r\nendpoint . Let be the most significant set bit in . Check every in\r\nincreasing order by bruteforce while is smaller than . Reverse the\r\narray, and do the same again. Note that we need to be careful here since\r\nwe might count the same subarray twice. We, now, prove its correctness\r\nand efficiency. Consider any good subarray , let be the most significant\r\nset bit in and the most significant set bit in . We must have because\r\nall bits greater than will be unset in , but is set. Hence, the\r\nalgorithm counts all possible good subarrays. We now prove the number of\r\nsubarrays our algorithm checks is of the order . For every , let\u00e2\u0080\u0099s count\r\nthe number of \u00e2\u0080\u0099s it can be reached by. For a particular , notice that\r\nonly the closest \u00e2\u0080\u0099s to the left with this bit set can reach this . For\r\nthe third one and beyond, the sum will be at least simply due the to the\r\ncontribution of the closest two. Since there are right endpoints and\r\nonly possible values of , our claim is true.\r\n"
}