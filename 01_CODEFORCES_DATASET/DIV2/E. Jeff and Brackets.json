{"link": "https://codeforces.com//contest/352/problem/E", "problemId": "3591", "problem_idx": "E", "shortId": "352E", "contest_number": "352", "problem_submissions": {"E": [4667737], "D": [4664116, 4669332, 4670267, 4669900, 4670195, 4671657, 4671016, 4669165, 4670919, 4670816, 4671725, 31033346, 4671793, 4665026, 4659734, 4666137, 4667776, 4667764], "B": [4659499, 4662158, 4659664, 4660907, 4661558, 4661871, 4660825, 4661149, 4664680, 4664793, 4661677, 4661204, 4667188, 4662338, 4659824, 4660585, 4662790], "A": [4658073, 4658936, 4657931, 4658166, 4658735, 4659595, 4659351, 4658482, 4661534, 4658039, 4658678, 4658642, 4661345, 4659615, 4667305, 4658757, 4658902], "C": [4664756, 4666666, 4667043, 4666668, 4667109, 4668609, 4670916, 4667108, 4669438, 4667628, 4666115, 4671493, 4674130]}, "name": "E. Jeff and Brackets", "statement": "Jeff loves regular bracket sequences.Today Jeff is going to take a piece\r\nof paper and write out the regular bracket sequence, consisting of\r\nbrackets. Let\u2019s number all brackets of this sequence from to - from left\r\nto right. Jeff knows that he is going to spend liters of ink on the -th\r\nbracket of the sequence if he paints it opened and liters if he paints\r\nit closed.You\u2019ve got sequences , and numbers , . What minimum amount of\r\nink will Jeff need to paint a regular bracket sequence of length\r\n?Operation means taking the remainder after dividing number by number .\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#if __cplusplus > 201103L\n#include <initializer_list>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#define DEBUG\n#endif\n\n#define oo 0x3F3F3F3F\n#define fst first\n#define snd second\n#define PB push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, a, b) for (int _end_ = (b), i = (a); i <= _end_; ++i)\n#define ROF(i, a, b) for (int _end_ = (b), i = (a); i >= _end_; --i)\n\ntypedef unsigned int uint;\ntypedef long long int64;\ntypedef unsigned long long uint64;\ntypedef long double real;\n\nint64 fpm(int64 b, int64 e, int64 m) { int64 t = 1; for (; e; e >>= 1, b = b * b % m) e & 1 ? t = t * b % m : 0; return t; }\ntemplate<class T> inline bool chkmin(T &a, T b) {return a > b ? a = b, true : false;}\ntemplate<class T> inline bool chkmax(T &a, T b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline T sqr(T x) {return x * x;}\ntemplate <typename T> T gcd(T x, T y) {for (T t; x; ) t = x, x = y % x, y = t; return y; }\n\ntemplate<class edge> struct Graph {\n    vector<vector<edge> > adj;\n    Graph(int n) {adj.clear(); adj.resize(n + 5);}\n    Graph() {adj.clear(); }\n    void resize(int n) {adj.resize(n + 5); }\n    void add(int s, edge e){adj[s].push_back(e);}\n    void del(int s, edge e) {adj[s].erase(find(iter(adj[s]), e)); }\n    vector<edge>& operator [](int t) {return adj[t];}\n};\n\nconst int N = 22;\n\nint a[N], b[N];\nint f[N * 2][N * 2];\nint g[N * 100][N * 100];\n\nint main(int argc, char **argv) {\n#ifndef ONLINE_JUDGE\n    freopen(\"E.in\" , \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    FOR (i, 0, n - 1) cin >> a[i];\n    FOR (i, 0, n - 1) cin >> b[i];\n\n    // fill(f[0], f[n * 2 + 1], oo), f[0][0] = 0;\n    // FOR (i, 0, n * 2 - 1) {\n    //     FOR (j, 0, n) {\n    //         chkmin(f[i + 1][j    ], f[i][j] + a[i % n]);\n    //         if (j < n)\n    //             chkmin(f[i + 1][j + 1], f[i][j] + b[i % n]);\n    //     }\n    // }\n    // int delta = f[n * 2][n];\n\n    int LMT = min(m, 100) * n;\n    fill(g[0], g[LMT + 1], oo), g[0][0] = 0;\n    FOR (i, 0, LMT - 1) {\n        FOR (j, 0, i) {\n            chkmin(g[i + 1][j + 1], g[i][j] + a[i % n]);\n            if (j) chkmin(g[i + 1][j - 1], g[i][j] + b[i % n]);\n        }\n    }\n    int delta = g[LMT][0] - g[LMT - n * 2][0];\n    cout << g[LMT][0] + (m - min(m, 100)) / 2 * delta << endl;\n\n    return 0; \n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2500", "interactive": false}