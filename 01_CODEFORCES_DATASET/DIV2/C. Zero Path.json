{"link": "https://codeforces.com//contest/1695/problem/C", "problemId": "1432673", "problem_idx": "C", "shortId": "1695C", "contest_number": "1695", "problem_submissions": {"E": [161099994, 161385353], "D1": [161071005, 161074543, 161081125, 161072748, 161085205, 161076792, 161086180, 161088285, 161078663, 161087570, 161090981, 161081382, 161096600, 161083265, 161094007, 161083359, 161087191, 161099464, 161103072], "D2": [161070538, 161074164, 161080949, 161072924, 161085070, 161077074, 161086067, 161090573, 161078799, 161087356, 161091244, 161098503, 161096503, 161083640, 161093884, 161083859, 161106845, 161102938, 161103184], "C": [161049795, 161059348, 161063490, 161060415, 161055337, 161053834, 161061413, 161054883, 161053215, 161065273, 161068360, 161076346, 161062519, 161063339, 161079032, 161066869, 161096184, 161063492, 161059254, 161053168], "B": [161047262, 161053402, 161051570, 161054862, 161050104, 161049992, 161050979, 161048731, 161049540, 161057199, 161054074, 161054984, 161050691, 161052531, 161068152, 161056401, 161053679, 161049800, 161064268, 161048819], "A": [161046762, 161046971, 161046828, 161047950, 161046933, 161046876, 161047188, 161046813, 161046805, 161048336, 161047711, 161049772, 161046830, 161047996, 161062872, 161046949, 161047484, 161047163, 161047431, 161046827]}, "name": "C. Zero Path", "statement": "You are given a grid with n rows and m columns. We denote the square on\r\nthe i-th (1\r\nle i\r\nle n) row and j-th (1\r\nle j\r\nle m) column by (i, j) and the number there by a_{ij}. All numbers are\r\nequal to 1 or to -1. You start from the square (1, 1) and can move one\r\nsquare down or one square to the right at a time. In the end, you want\r\nto end up at the square (n, m).Is it possible to move in such a way so\r\nthat the sum of the values written in all the visited cells (including\r\na_{11} and a_{nm}) is 0?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n, m;\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        vector<vector<int>> a(n, vector<int>(m, 0)), l(n, vector<int>(m, 0)), r(n, vector<int>(m, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> a[i][j];\n                if (i == 0 && j == 0) {\n                    l[i][j] = r[i][j] = 0;\n                } else if (i == 0) {\n                    l[i][j] = l[i][j - 1];\n                    r[i][j] = r[i][j - 1];\n                } else if (j == 0) {\n                    l[i][j] = l[i - 1][j];\n                    r[i][j] = r[i - 1][j];\n                } else {\n                    l[i][j] = min(l[i - 1][j], l[i][j - 1]);\n                    r[i][j] = max(r[i - 1][j], r[i][j - 1]);\n                }\n                l[i][j] += a[i][j]; r[i][j] += a[i][j];\n            }\n        }\n        if ((n + m - 1) % 2 == 1) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n        if (l[n - 1][m - 1] <= 0 && 0 <= r[n - 1][m - 1]) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "data structures", "dp", "graphs", "greedy", "shortest paths"], "dificulty": "1700", "interactive": false}