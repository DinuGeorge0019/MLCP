{
    "link": "https://codeforces.com//contest/1695/problem/C",
    "problemId": "1432673",
    "problem_idx": "C",
    "shortId": "1695C",
    "contest_number": "1695",
    "problem_submissions": {
        "E": [
            161099994,
            161385353
        ],
        "D1": [
            161071005,
            161074543,
            161081125,
            161072748,
            161085205,
            161076792,
            161086180,
            161088285,
            161078663,
            161087570,
            161090981,
            161081382,
            161096600,
            161083265,
            161094007,
            161083359,
            161087191,
            161099464,
            161103072
        ],
        "D2": [
            161070538,
            161074164,
            161080949,
            161072924,
            161085070,
            161077074,
            161086067,
            161090573,
            161078799,
            161087356,
            161091244,
            161098503,
            161096503,
            161083640,
            161093884,
            161083859,
            161106845,
            161102938,
            161103184
        ],
        "C": [
            161049795,
            161059348,
            161063490,
            161060415,
            161055337,
            161053834,
            161061413,
            161054883,
            161053215,
            161065273,
            161068360,
            161076346,
            161062519,
            161063339,
            161079032,
            161066869,
            161096184,
            161063492,
            161059254,
            161053168
        ],
        "B": [
            161047262,
            161053402,
            161051570,
            161054862,
            161050104,
            161049992,
            161050979,
            161048731,
            161049540,
            161057199,
            161054074,
            161054984,
            161050691,
            161052531,
            161068152,
            161056401,
            161053679,
            161049800,
            161064268,
            161048819
        ],
        "A": [
            161046762,
            161046971,
            161046828,
            161047950,
            161046933,
            161046876,
            161047188,
            161046813,
            161046805,
            161048336,
            161047711,
            161049772,
            161046830,
            161047996,
            161062872,
            161046949,
            161047484,
            161047163,
            161047431,
            161046827
        ]
    },
    "name": "C. Zero Path",
    "statement": "You are given a grid with n rows and m columns. We denote the square on\r\nthe i-th (1\r\nle i\r\nle n) row and j-th (1\r\nle j\r\nle m) column by (i, j) and the number there by a_{ij}. All numbers are\r\nequal to 1 or to -1. You start from the square (1, 1) and can move one\r\nsquare down or one square to the right at a time. In the end, you want\r\nto end up at the square (n, m).Is it possible to move in such a way so\r\nthat the sum of the values written in all the visited cells (including\r\na_{11} and a_{nm}) is 0?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n, m;\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        vector<vector<int>> a(n, vector<int>(m, 0)), l(n, vector<int>(m, 0)), r(n, vector<int>(m, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> a[i][j];\n                if (i == 0 && j == 0) {\n                    l[i][j] = r[i][j] = 0;\n                } else if (i == 0) {\n                    l[i][j] = l[i][j - 1];\n                    r[i][j] = r[i][j - 1];\n                } else if (j == 0) {\n                    l[i][j] = l[i - 1][j];\n                    r[i][j] = r[i - 1][j];\n                } else {\n                    l[i][j] = min(l[i - 1][j], l[i][j - 1]);\n                    r[i][j] = max(r[i - 1][j], r[i][j - 1]);\n                }\n                l[i][j] += a[i][j]; r[i][j] += a[i][j];\n            }\n        }\n        if ((n + m - 1) % 2 == 1) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n        if (l[n - 1][m - 1] <= 0 && 0 <= r[n - 1][m - 1]) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Zero Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/103996",
    "editorial": "Note that if is even, then the sum of any path from the top left to\r\nbottom right will be odd, and therefore nonzero. So in this case, there\r\nis no solution.Otherwise, every path from top left to bottom right will\r\nhave even sum. For each position in the grid, we define to be the\r\nmaximum possible sum of a path starting at the top left and ending at .\r\nSimilarly, is defined to be the minimum possible sum starting at the top\r\nleft and ending at . These values can be computed using an DP, where If\r\nor , there is no path adding up to zero. Otherwise, lies in the range ,\r\nand we can show that there is a valid solution path. Proof: Let be a\r\npath from to adding up to , and be another such path adding up to . Each\r\nof these paths consists of down moves and right moves, so it can be\r\nrepresented as a string of \"R\" and \"D\" of length . We can move to by a\r\nsequence of operations where we swap two adjacent (and different)\r\ncharacters. Visually, what we are doing is replacing one square on the\r\npath with a square diagonally adjacent to it. The below picture shows\r\none possible operation on a path.Note that in each step, the sum of\r\nvalues on the path changes by either or . So after performing this\r\nsequence of operations taking to , we have moved the path with sum to a\r\npath with sum , changing the sum by or at each step. Therefore, because\r\nboth and are even, and , at some point in this sequence of operations,\r\nthe sum of the path must be zero.Complexity:\r\n"
}