{
    "link": "https://codeforces.com//contest/1682/problem/B",
    "problemId": "1407920",
    "problem_idx": "B",
    "shortId": "1682B",
    "contest_number": "1682",
    "problem_submissions": {
        "F": [
            158050798,
            158077786,
            158086685,
            158039286,
            158069961,
            158110252,
            158078476,
            158248901
        ],
        "D": [
            158028363,
            158027200,
            158028814,
            158069864,
            158039569,
            158036346,
            158030046,
            158050282,
            158037974,
            158041123,
            158041068,
            158036998,
            158042298,
            158032953,
            158041526,
            158029661,
            158056637,
            158029667
        ],
        "C": [
            158015824,
            158013904,
            158013129,
            158070941,
            158017154,
            158019512,
            158011476,
            158017137,
            158021257,
            158018627,
            158020682,
            158022180,
            158021471,
            158039652,
            158019776,
            158037446,
            158028182
        ],
        "B": [
            158006894,
            158007821,
            158007318,
            158071816,
            158008119,
            158009978,
            158007984,
            158008572,
            158013225,
            158009923,
            158010666,
            158009973,
            158013386,
            158010013,
            158016214,
            158026210,
            158017588,
            158010270
        ],
        "A": [
            158004280,
            158004512,
            158004427,
            158072894,
            158004570,
            158007124,
            158005591,
            158005462,
            158005647,
            158004983,
            158006433,
            158004812,
            158012816,
            158004216,
            158013837,
            158039471,
            158008517,
            158004710
        ],
        "E": [
            158050246,
            158056393,
            158060063,
            158060073,
            158067774,
            158059309,
            158065396,
            158067467,
            158070762,
            158068042,
            158070815,
            158073429,
            158070617,
            158069678,
            158075426,
            158064743
        ]
    },
    "name": "B. AND Sorting",
    "statement": "You are given a permutation p of integers from 0 to n-1 (each of them\r\noccurs exactly once). Initially, the permutation is (that is,\r\np_i>p_{i+1} for at least one 1\r\nle i\r\nle n - 1). The permutation is called X-sortable for some non-negative\r\ninteger X if it is possible to sort the permutation by performing the\r\noperation below some finite number of times: Choose two indices i and j\r\n(1\r\nle i\r\nlt j\r\nle n) such that p_i\r\n& p_j = X. Swap p_i and p_j. Here\r\n& denotes the bitwise AND operation.Find the value of X such that p is\r\nX-sortable. It can be shown that there always exists some value of X\r\nsuch that p is X-sortable.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint p[200005],pos[200005];\nint main()\n{\n\tint t,n,ans=0;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)p[i]=read(),pos[p[i]]=i;\n\t\tans=-1;\n\t\tfor(int i=0;i<=n-1;i++)\n\t\t{\n\t\t\tif(pos[i]!=i+1)\n\t\t\t{\n\t\t\t\tif(ans==-1)ans=i;\n\t\t\t\telse ans&=i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. AND Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/103097",
    "editorial": "TutorialWe always have to make at least one swap for the elements which\r\nare not at their correct positions. Hence an upper bound of answer would\r\nbe the bitwise AND of those elements. Let the value be . It turns out\r\nthat the given permutation is -sortable. Proof:First, notice that would\r\nalways be present in . Let be the position of in initially. Letâs say at\r\nsome point we want to swap two values and , then and would always be a\r\nsupermask of i.e. & and & . We can make the following moves to swap and\r\nwithout disturbing any other element. Swap values at indices and . Swap\r\nvalues at indices and . Swap values at indices and . It can be seen that\r\nin every swap the bitwise AND of two values which we are swapping is\r\nalways . Hence we can swap any two values which were not at their\r\ncorrect positions, therefore we can sort the permutation .Overall\r\nComplexity: .\r\n",
    "hint": [
        "Hint 1 You must have to make at least one swap on the elements which are not at their correct positions initially. So must be a submask of all elements which are not at their correct positions.",
        "Hint 2 What is the maximum possible value of from Hint ? It is the bitwise AND of all elements which are not at their correct positions. It turns out that this value is achievable too."
    ]
}