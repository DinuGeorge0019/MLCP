{
    "link": "https://codeforces.com//contest/1859/problem/E",
    "problemId": "2156545",
    "problem_idx": "E",
    "shortId": "1859E",
    "contest_number": "1859",
    "problem_submissions": {
        "F": [
            218569170,
            218581836,
            218617250,
            218736861,
            218605159
        ],
        "D": [
            218563678,
            218527706,
            218524461,
            218541850,
            218525597,
            218533314,
            218548787,
            218533112,
            218538546,
            218539655,
            218537786,
            218535818,
            218553386,
            218535886,
            218533896,
            218537893,
            218542381,
            218547154,
            218542928,
            218544612
        ],
        "C": [
            218525956,
            218512705,
            218513334,
            218516401,
            218517178,
            218520064,
            218534501,
            218519799,
            218514853,
            218522631,
            218518290,
            218523903,
            218538315,
            218515860,
            218520699,
            218536075,
            218518723,
            218526393,
            218525882,
            218528439
        ],
        "B": [
            218515214,
            218505180,
            218504011,
            218503415,
            218502676,
            218525570,
            218527334,
            218505003,
            218504876,
            218514112,
            218504039,
            218506274,
            218520756,
            218506233,
            218506628,
            218509261,
            218509278,
            218510852,
            218512080,
            218508258
        ],
        "E": [
            218512348,
            218540759,
            218543571,
            218531440,
            218546842,
            218542828,
            218514089,
            218548356,
            218551376,
            218551561,
            218551316,
            218556871,
            218531000,
            218554570,
            218561645,
            218555675,
            218563500,
            218560618,
            218560551,
            218559090
        ],
        "A": [
            218503604,
            218499919,
            218498316,
            218498529,
            218498173,
            218498480,
            218520556,
            218498189,
            218499252,
            218502725,
            218498470,
            218499540,
            218499799,
            218500335,
            218498354,
            218508385,
            218499358,
            218498918,
            218499379,
            218503053
        ]
    },
    "name": "E. Maximum Monogonosity",
    "statement": "You are given an array a of length n and an array b of length n. The of\r\na segment [l, r], 1\r\nle l\r\nle r\r\nle n, is defined as |b_l - a_r| + |b_r - a_l|.Recall that two segments\r\n[l_1, r_1], 1\r\nle l_1\r\nle r_1\r\nle n, and [l_2, r_2], 1\r\nle l_2\r\nle r_2\r\nle n, are non-intersecting if one of the following conditions is\r\nsatisfied: r_1 < l_2 or r_2 < l_1.The length of a segment [l, r], 1\r\nle l\r\nle r\r\nle n, is defined as r - l + 1.Find the maximum possible sum of costs of\r\nnon-intersecting segments [l_j, r_j], 1\r\nle l_j\r\nle r_j\r\nle n, whose total length is equal to k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n#define double long double\nusing namespace std;\nint a[3005],b[3005];\nint dp[3005][3005][5];\nsigned main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tint n,k; cin>>n>>k;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=1;i<=n;i++) cin>>b[i];\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=3000;j++) for(int l=0;l<5;l++) dp[i][j][l]=-1e18;\n\t\tdp[0][0][0]=0; \n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<=k;j++){\n\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\tif(l==0){\n\t\t\t\t\t\tdp[i][j][0]=max(dp[i][j][0],dp[i-1][j][l]);\n\t\t\t\t\t\tdp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+llabs(a[i]-b[i])*2);\n\t\t\t\t\t\tdp[i][j+1][1]=max(dp[i][j+1][1],dp[i-1][j][l]+a[i]+b[i]);\n\t\t\t\t\t\tdp[i][j+1][2]=max(dp[i][j+1][2],dp[i-1][j][l]+a[i]-b[i]);\n\t\t\t\t\t\tdp[i][j+1][3]=max(dp[i][j+1][3],dp[i-1][j][l]-a[i]+b[i]);\n\t\t\t\t\t\tdp[i][j+1][4]=max(dp[i][j+1][4],dp[i-1][j][l]-a[i]-b[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j+1][l]=max(dp[i][j+1][l],dp[i-1][j][l]);\n\t\t\t\t\t\tif(l==1) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]-a[i]-b[i]);\n\t\t\t\t\t\tif(l==2) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+a[i]-b[i]);\n\t\t\t\t\t\tif(l==3) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]-a[i]+b[i]);\n\t\t\t\t\t\tif(l==4) dp[i][j+1][0]=max(dp[i][j+1][0],dp[i-1][j][l]+a[i]+b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n][k][0]<<\"\\n\";\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Maximum Monogonosity.json",
    "editorial_link": "https://codeforces.com//blog/entry/119287",
    "editorial": "TutorialLet\u00e2\u0080\u0099s call the value of a segment .Let\u00e2\u0080\u0099s write maximum value of\r\nsegments of total length that end before .The obvious way to recalc is\r\nthe following:.This works in and is too slow.Now let\u00e2\u0080\u0099s consider the\r\nfollowing: instead of getting the absolute value of segment , we\r\nconsider the maximum of the following four combinations: , , , . We can\r\nsee that this always gives us the correct answer to the absolute value,\r\nsince we check all of the possibilities.Now we can look at out dp states\r\nas a table, and notice that we recalc over the diagonal (we recalc over\r\nall states that have the same value of n1 k1). Now, for each \"diagonal\",\r\nwe maintain four maximum combinations: , and when we want to recalc\r\nstate , we just consider all of the four possibilities.\r\n"
}