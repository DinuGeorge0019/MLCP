{"link": "https://codeforces.com//contest/1731/problem/E", "problemId": "1711455", "problem_idx": "E", "shortId": "1731E", "contest_number": "1731", "problem_submissions": {"F": [186914595, 186916746, 188609637, 186918241, 186915978, 186924114, 186923167, 186928435, 186940850, 186934089, 186928158, 186942000, 186931590, 186939314, 186931829, 186925046, 187042657, 186976314, 186961335, 186947151, 186935943, 186943841, 186947800, 187100429, 186936912], "E": [186902388, 186907542, 188609583, 186907228, 186922877, 186908811, 186913909, 186909533, 186905298, 186914796, 186914318, 186909008, 186915275, 186912330, 186916821, 186935842, 186913227, 186922201, 186915075, 186915635, 186916449], "D": [186894672, 186898337, 188609534, 186899725, 186899215, 186903320, 186903576, 186904113, 186896689, 186902110, 186905198, 186902394, 186905223, 186904629, 186906063, 186899445, 186905463, 186908692, 186911370, 186906776, 186904962], "C": [186891713, 186894904, 188609500, 186897483, 186895982, 186900151, 186899934, 186901212, 186894367, 186897519, 186898993, 186897615, 186900357, 186899391, 186902000, 186905696, 186894285, 186902878, 186897844, 186898614, 186901628], "B": [186886340, 186890465, 188609426, 186888165, 186892347, 186894409, 186892290, 186893227, 186887848, 186893176, 186892310, 186890495, 186892951, 186895205, 186908452, 186891159, 186900599, 186895520, 186894487, 186892361, 186896199], "A": [186884556, 186884624, 188609361, 186884628, 186886996, 186885867, 186884614, 186885171, 186884576, 186884932, 186885049, 186884957, 186885253, 186885130, 186885370, 186887288, 186885246, 186886527, 186884899, 186885189, 186885071]}, "name": "E. Graph Cost", "statement": "You are given an initially empty undirected graph with n nodes, numbered\r\nfrom 1 to n (i. e. n nodes and 0 edges). You want to add m edges to the\r\ngraph, so the graph won\u2019t contain any self-loop or multiple edges.If an\r\nedge connecting two nodes u and v is added, its weight must be equal to\r\nthe greatest common divisor of u and v, i. e.\r\ngcd(u, v).In order to add edges to the graph, you can repeat the\r\nfollowing process any number of times (possibly zero): choose an integer\r\nk\r\nge 1; add exactly k edges to the graph, each having a weight equal to\r\nk + 1. Adding these k edges costs k + 1 in total. Note that you can\u2019t\r\ncreate self-loops or multiple edges. Also, if you can\u2019t add k edges of\r\nweight k + 1, you can\u2019t choose such k.For example, if you can add 5 more\r\nedges to the graph of weight 6, you may add them, and it will cost 6 for\r\nthe whole pack of 5 edges. But if you can only add 4 edges of weight 6\r\nto the graph, you can\u2019t perform this operation for k = 5.Given two\r\nintegers n and m, find the minimum total cost to form a graph of n\r\nvertices and exactly m edges using the operation above. If such a graph\r\ncan\u2019t be constructed, output -1.Note that the final graph may consist of\r\nseveral connected components.\r\n", "solutions": ["//\u8fd9\u56de\u53ea\u82b1\u4e86114514min\u5c31\u6253\u5b8c\u4e86\u3002\n//\u771f\u597d\u3002\u8bb0\u5f97\u591a\u624b\u9020\u51e0\u7ec4\u3002ACM\u62cd\u4ec0\u4e48\u62cd\u3002 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nnamespace Prime\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll M=(ll)(N-1)*(N-1);\n\tui pr[N],mn[N],phi[N],cnt;\n\tint mu[N];\n\tvoid init_prime()\n\t{\n\t\tui i,j,k;\n\t\tphi[1]=mu[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tif (!mn[i])\n\t\t\t{\n\t\t\t\tpr[cnt++]=i;\n\t\t\t\tphi[i]=i-1; mu[i]=-1;\n\t\t\t\tmn[i]=i;\n\t\t\t}\n\t\t\tfor (j=0; (k=i*pr[j])<N; j++)\n\t\t\t{\n\t\t\t\tmn[k]=pr[j];\n\t\t\t\tif (i%pr[j]==0)\n\t\t\t\t{\n\t\t\t\t\tphi[k]=phi[i]*pr[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tphi[k]=phi[i]*(pr[j]-1);\n\t\t\t\tmu[k]=-mu[i];\n\t\t\t}\n\t\t}\n\t\t//for (i=2;i<N;i++) if (mu[i]<0) mu[i]+=p;\n\t}\n\ttemplate<typename T> T getphi(T x)\n\t{\n\t\tassert(M>=x);\n\t\tT r=x;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\tif (x>=N) return r/x*(x-1);\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp;\n\t\t\tr=r/y*(y-1);\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<typename T> vector<pair<T,ui>> getw(T x)\n\t{\n\t\tassert(M>=x);\n\t\tvector<pair<T,ui>> r;\n\t\tfor (ui i=0; i<cnt&&(T)pr[i]*pr[i]<=x&&x>=N; i++) if (x%pr[i]==0)\n\t\t{\n\t\t\tui y=pr[i],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\tif (x>=N)\n\t\t{\n\t\t\tr.push_back({x,1});\n\t\t\treturn r;\n\t\t}\n\t\twhile (x>1)\n\t\t{\n\t\t\tui y=mn[x],z=1,tmp;\n\t\t\tx/=y;\n\t\t\twhile (x==(tmp=x/y)*y) x=tmp,++z;\n\t\t\tr.push_back({y,z});\n\t\t}\n\t\treturn r;\n\t}\n}\nusing Prime::pr,Prime::phi,Prime::getw;\nusing Prime::mu,Prime::init_prime;\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tinit_prime();\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j;\n\t\tll m;\n\t\tcin>>n>>m;\n\t\tvector<ll> cnt(n+1);\n\t\tfor (i=1; i<=n; i++) cnt[i]=(ll)(n/i)*(n/i);\n\t\tfor (i=1; i<=n; i++) for (j=2; j*i<=n; j++) cnt[i]+=cnt[j*i]*mu[j];\n\t\tfor (i=2; i<=n; i++) cnt[i]=(cnt[i]-1>>1)/(i-1);\n\t\tll res=0;\n\t\t// dbg(cnt);\n\t\tfor (i=n; i>=2; i--)\n\t\t{\n\t\t\tll d=min(cnt[i],m/(i-1));\n\t\t\tm-=d*(i-1);\n\t\t\tres+=d*i;\n\t\t\t// dbg(m,res,i);\n\t\t}\n\t\tif (m) cout<<\"-1\\n\";\n\t\telse cout<<res<<'\\n';\n\t}\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy", "math", "number theory"], "dificulty": "2000", "interactive": false}