{
    "link": "https://codeforces.com//contest/743/problem/D",
    "problemId": "84654",
    "problem_idx": "D",
    "shortId": "743D",
    "contest_number": "743",
    "problem_submissions": {
        "C": [
            22970568,
            22954819,
            22955931,
            22959540,
            22960803,
            22954630,
            22967024,
            22964712,
            22959281,
            22956710,
            22956672,
            22954587,
            22959020,
            22956501,
            22953944,
            22955848,
            22960168,
            22960967
        ],
        "E": [
            22965880,
            22967434,
            22967306,
            22968969,
            22967268,
            22973387,
            22967640,
            22968707,
            22974150,
            22967996,
            22970034,
            22971822,
            22987515,
            22975131,
            41741833,
            22975215,
            22975586,
            22974342
        ],
        "B": [
            22955029,
            22952524,
            22952071,
            22953395,
            22954814,
            22952559,
            22951675,
            22954634,
            22953589,
            22953782,
            22953874,
            22953034,
            22954309,
            22952189,
            22955346,
            22951377,
            22952875,
            22956475,
            22953744
        ],
        "D": [
            22953950,
            22961837,
            22961932,
            22962256,
            22961186,
            22961360,
            22956645,
            22961156,
            22963404,
            22962979,
            22963931,
            22963003,
            22964853,
            22959856,
            22961283,
            22968732,
            22964847,
            22966379,
            22964407
        ],
        "A": [
            22950683,
            22950781,
            22950661,
            22966387,
            22969695,
            22950835,
            22950658,
            22952400,
            22951347,
            22956844,
            22951276,
            22950972,
            22951766,
            22950741,
            22951008,
            22953378,
            22951284
        ]
    },
    "name": "D. Chloe and pleasant prizes",
    "statement": "Generous sponsors of the olympiad in which Chloe and Vladik took part\r\nallowed all the participants to choose a prize for them on their own.\r\nChristmas is coming, so sponsors decided to decorate the Christmas tree\r\nwith their prizes. They took prizes for the contestants and wrote on\r\neach of them a unique id (integer from to ). A gift is characterized by\r\ninteger pleasantness of the gift. The pleasantness of the gift can be\r\npositive, negative or zero. Sponsors placed the gift on the top of the\r\ntree. All the other gifts hung on a rope tied to some other gift so that\r\neach gift hung on the first gift, possibly with a sequence of ropes and\r\nanother gifts. Formally, the gifts formed a rooted tree with\r\nvertices.The prize-giving procedure goes in the following way: the\r\nparticipants come to the tree one after another, choose any of the\r\nremaining gifts and cut the rope this prize hang on. Note that all the\r\nropes which were used to hang other prizes on the chosen one are not\r\ncut. So the contestant gets the chosen gift as well as the all the gifts\r\nthat hang on it, possibly with a sequence of ropes and another gifts.Our\r\nfriends, Chloe and Vladik, shared the first place on the olympiad and\r\nthey will choose prizes at the same time! To keep themselves from\r\nfighting, they decided to choose two different gifts so that the sets of\r\nthe gifts that hang on them with a sequence of ropes and another gifts\r\ndon’t intersect. In other words, there shouldn’t be any gift that hang\r\nboth on the gift chosen by Chloe and on the gift chosen by Vladik. From\r\nall of the possible variants they will choose such pair of prizes that\r\nthe sum of pleasantness of all the gifts that they will take after\r\ncutting the ropes is as large as possible.Print the maximum sum of\r\npleasantness that Vladik and Chloe can get. If it is impossible for them\r\nto choose the gifts without fighting, print .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1<<20;\nconst long long INF = (1e18) + 7;\n\nlong long ans;\nint n;\nlong long a[N];\nvector < int > g[N],v[N];\npair < long long, long long > p;\nbool used[N];\nlong long dp[N];\nlong long sum[N];\n\nvoid dfs(int node) {\n    used[node]=true;\n    int i;\n    sum[node]=a[node];\n    dp[node]=-INF;\n    for(i=0;i<(int)(g[node].size());i++) if(!used[g[node][i]]) {\n        v[node].push_back(g[node][i]);\n        dfs(g[node][i]);\n        sum[node]+=sum[g[node][i]];\n        dp[node]=max(dp[node],dp[g[node][i]]);\n    }\n    dp[node]=max(dp[node],sum[node]);\n}\n\npair < long long, long long > mrg(pair < long long, long long > a, long long b) {\n    vector < long long > v;\n    v.push_back(b);\n    v.push_back(a.first);\n    v.push_back(a.second);\n    sort(v.rbegin(),v.rend());\n    return make_pair(v[0],v[1]);\n}\n\nint main() {\n    int i,j,x,y;\n    \n    scanf(\"%d\", &n);\n    for(i=1;i<=n;i++) scanf(\"%lld\", &a[i]);\n    for(i=1;i<n;i++) {\n        scanf(\"%d\", &x);\n        scanf(\"%d\", &y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    dfs(1);\n    ans=-INF;\n    for(i=1;i<=n;i++) {\n        if(v[i].size()>=2) {\n            p=make_pair(-INF,-INF);\n            for(j=0;j<(int)(v[i].size());j++) {\n                p=mrg(p,dp[v[i][j]]);\n            }\n            ans=max(ans,p.first+p.second);\n        }\n    }\n    if(ans==-INF) printf(\"Impossible\\n\");\n    else printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Chloe and pleasant prizes.json",
    "editorial_link": "https://codeforces.com//blog/entry/49049",
    "editorial": "Our task is to choose two disjoint subtrees, such that sum of numbers in\r\nthe first plus the sum in the second is maximal.Lets calculate for each\r\nvertex this dynamic programming using dfs seach: sum of all the numbers\r\nin subtree of vertex , and maximal value from all in subtree of vertex (\r\nbelongs to subtree of ). We can calculate the answer using another dfs\r\nsearch, maintaining the value of maximal subtree, which is outside of\r\ncurrent subtree. For example, if we are in vertex , to update this value\r\nwhen going to call (where is some son of ) we have to find maximal from\r\nall other sons of .The complexity is .\r\n",
    "hint": []
}