{
    "link": "https://codeforces.com//contest/1591/problem/E",
    "problemId": "1225717",
    "problem_idx": "E",
    "shortId": "1591E",
    "contest_number": "1591",
    "problem_submissions": {
        "E": [
            138939759,
            138896286,
            138892087,
            138904906,
            138899099,
            138912542,
            138905319,
            138942968,
            138922159,
            138917295,
            138909678,
            138916267,
            138912773,
            142180374,
            138919614,
            138909983,
            141705495,
            138930168,
            138928555,
            138925316,
            138913022,
            138892012,
            138926540,
            138931077,
            138931064,
            138930963,
            138930485,
            138930038,
            138902474,
            138912155
        ],
        "F": [
            138896881,
            138908816,
            138884874,
            138909478,
            138884427,
            138908517,
            138891044,
            138904560,
            138893395,
            138899285,
            138915632,
            142180394,
            138899469,
            138921469,
            138919710,
            138905703,
            138891520,
            138877610,
            138877802,
            138894139
        ],
        "D": [
            138884909,
            138887502,
            138910689,
            138885286,
            138904549,
            138890635,
            138896357,
            138890254,
            138899856,
            138910347,
            138894967,
            142180350,
            138908889,
            138894185,
            138899015,
            138918606,
            138885986,
            138899645,
            138900772
        ],
        "C": [
            138879406,
            138882062,
            138878466,
            138879202,
            138893756,
            138887313,
            138887413,
            138881365,
            138897506,
            138896182,
            138887184,
            142180334,
            138892648,
            138885173,
            138883573,
            138910386,
            138882034,
            138887438,
            138893006,
            138887255
        ],
        "B": [
            138872954,
            138874823,
            138871917,
            138872565,
            138874131,
            138872675,
            138878614,
            138874098,
            138894802,
            138876267,
            138881546,
            142180302,
            138877235,
            138875059,
            138878573,
            138912046,
            138876941,
            138876177,
            138883593,
            138876483
        ],
        "A": [
            138869941,
            138869454,
            138869620,
            138869532,
            138871744,
            138869648,
            138874054,
            138870679,
            138872074,
            138872428,
            138873158,
            142180273,
            138870902,
            138870272,
            138873798,
            138910683,
            138871332,
            138872992,
            138880205,
            138869700
        ]
    },
    "name": "E. Frequency Queries",
    "statement": "Petya has a rooted tree with an integer written on each vertex. The\r\nvertex 1 is the root. You are to answer some questions about the tree.A\r\ntree is a connected graph without cycles. A rooted tree has a special\r\nvertex called the root. The parent of a node v is the next vertex on the\r\nshortest path from v to the root.Each question is defined by three\r\nintegers v, l, and k. To get the answer to the question, you need to\r\nperform the following steps: First, write down the sequence of all\r\nintegers written on the shortest path from the vertex v to the root\r\n(including those written in the v and the root). Count the number of\r\ntimes each integer occurs. Remove all integers with less than l\r\noccurrences. Replace the sequence, removing all duplicates and ordering\r\nthe elements by the number of occurrences in the original list in\r\nincreasing order. In case of a tie, you can choose the order of these\r\nelements arbitrary. The answer to the question is the k-th number in the\r\nremaining sequence. Note that the answer is not always uniquely\r\ndetermined, because there could be several orderings. Also, it is\r\npossible that the length of the sequence on this step is less than k, in\r\nthis case the answer is -1. For example, if the sequence of integers on\r\nthe path from v to the root is [2, 2, 1, 7, 1, 1, 4, 4, 4, 4], l = 2 and\r\nk = 2, then the answer is 1.Please answer all questions about the tree.\r\n",
    "solutions": [
        "#pragma GCC optimize(2,3,\"Ofast\")\n#pragma GCC target(\"avx\",\"avx2\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nconst int N=1000005;\n\nstruct Info{int l,k,id;};\nvector<Info>ask[N];\n\nvector<int>adj[N];\nint n,m;\nint a[N],ans[N];\n\nset<int>who[N];\nint times[N],all;\n\nstruct fen{\n    int c[N];\n    void add(int x,int dlt){\n        if(!x)return; \n        while(x<=n){\n            c[x]+=dlt;\n            x+=x&-x;\n        }\n    }    \n    int qry(int x){\n        int ret=0;\n        while(x){\n            ret+=c[x];\n            x^=x&-x; \n        }\n        return ret;\n    }\n    int query(int rk){\n        int x=0;\n        for(int i=19;i>=0;i--){\n            if(x+(1<<i)<=n&&c[x+(1<<i)]<rk)\n                x+=(1<<i),rk-=c[x];\n        }\n        return x+1;\n    }\n}tr;\n\nvoid dfs(int u,int fa){\n    \n//    printf(\"now dfs %d\\n\",u);\n    \n//    all++;\n    who[ times[a[u]] ].erase(a[u]);\n    tr.add(times[a[u]], -1);\n    times[a[u]]++;\n    who[ times[a[u]] ].insert(a[u]);\n    tr.add(times[a[u]], 1);\n    \n//    printf(\"ok!\\n\");\n    \n    for (auto &it:ask[u]){\n        int qaq=tr.qry(it.l-1);\n        it.k+=qaq;\n//        printf(\"id=%d,it.k=%d\\n\",it.id,it.k);\n//        printf(\"all=%d\\n\",tr.qry(n));\n        if(it.k>tr.qry(n))ans[it.id]=-1;\n        else {\n            int tmp=tr.query(it.k);\n            assert(SZ(who[tmp]));\n            ans[it.id]=*who[tmp].begin();\n        }\n    }\n    \n//    printf(\"ask ok!\\n\");\n    \n    for(auto v:adj[u]){\n        if(v==fa)continue;\n        dfs(v,u);\n    }\n    \n//    all--;\n    who[ times[a[u]] ].erase(a[u]);\n    tr.add(times[a[u]], -1);\n    times[a[u]]--;\n    who[ times[a[u]] ].insert(a[u]);\n    tr.add(times[a[u]], 1);\n}\nvoid solve(){\n    n=read(),m=read();\n    rep(i,1,n)adj[i].clear();\n    rep(i,1,n)ask[i].clear();\n    rep(i,1,n)a[i]=read();\n    rep(i,2,n){\n        int fa=read();\n        adj[fa].pb(i);\n    }\n    rep(i,1,m){\n        int u=read(),l=read(),k=read();\n        ask[u].pb({l,k,i});\n    }\n    dfs(1,0);\n    rep(i,1,m){\n        print(ans[i],\" \\n\"[i==m]);\n    }    \n}\n\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "trees",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Frequency Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/97845",
    "editorial": "Let's traverse through the tree with depth-first-search from the root and maintain counting array (cntx\n := \"number of occasions of x in the sequence\"). When dfs enters vertex v\n, it increases cntav\n by 1\n, then it proceeds all queries correspondent to v\n. When dfs leaves the vertex, it decreases cntav\n by 1\n.\n\nLet's maintain this quantities:\n\nSorting permuation p\n of cnt\n, initially \u0097 1,2,\u0085,n\n.\nInverse permuation p?1\n.\nFor each x?{0,1,\u0085,n}\n, \"lower_bound\" lbx\n in sorted array. More formally, minimal i\n such that cntpi?x\n.\nWhen we want to increase cntx\n by 1\n:\n\nMove x\n in the end of block of same values in sorted array. So we need to swap (p?1i\n)-th and (lbcntx+1?1\n)-th positions of p\n.\nChange p?1\n accrodingly to the change of p\n.\nDecrease lbcntx+1\n by 1\n. Note: that's the only lb\n value that after during this operation.\nIncrease cntx\n.\nOperation of decreasing cntx\n by 1\n can be done symmetrically.\n\nNote: if answer exists, then one of possible answers is plbl+k?1\n.\n\nTotal complexity: O(n+q)\n."
}