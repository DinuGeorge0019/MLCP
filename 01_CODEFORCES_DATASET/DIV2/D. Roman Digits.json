{"link": "https://codeforces.com//contest/998/problem/D", "problemId": "194448", "problem_idx": "D", "shortId": "998D", "contest_number": "998", "problem_submissions": {"E": [39844279, 39844719, 39842563, 39860454, 39860368], "D": [39839915, 39841332, 39842999, 39838622, 39833588, 39834360, 39835519, 39835358, 39836436, 39839136, 39835483, 39834881, 39832459, 39838234, 39834518, 39836090, 39838820, 39836619], "B": [39829464, 39826160, 39828535, 39827534, 39825326, 39826819, 39826965, 39827064, 39824985, 39826413, 39828466, 39828134, 39827004, 39829078, 39829375, 39828106, 39826996, 39829712], "C": [39826150, 39829299, 39830565, 39832057, 39827518, 39829277, 39828734, 39829936, 39831699, 39829124, 39832064, 39831642, 39829279, 39831274, 39831057, 39831568, 39830502, 39831907], "A": [39824455, 39823644, 39825721, 39823552, 39823494, 39823346, 39825072, 39824102, 39823293, 39823771, 39825353, 39823995, 39824239, 39823343, 39835371, 39823495, 39823392, 39823469]}, "name": "D. Roman Digits", "statement": "Let\u2019s introduce a number system which is based on a roman digits. There\r\nare digits , , , which correspond to the numbers 1, 5, 10 and 50\r\nrespectively. The use of other roman digits is not allowed.Numbers in\r\nthis system are written as a sequence of one or more digits. We define\r\nthe value of the sequence simply as the sum of digits in it.For example,\r\nthe number evaluates to 35 and the number to 12.Pay attention to the\r\ndifference to the traditional roman system in our system any sequence of\r\ndigits is valid, moreover the order of digits doesn\u2019t matter, for\r\nexample means 11, not 9.One can notice that this system is ambiguous,\r\nand some numbers can be written in many different ways. Your goal is to\r\ndetermine how many distinct integers can be represented by n roman\r\ndigits , , , .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B> inline ostream& operator<<(ostream&os, const pair<A, B> &v) {return os << v.first << ' ' << v.second;}\ntemplate <typename A> inline ostream& operator<<(ostream&os, const vector<A> &v){\n    auto it = v.begin(); os << *it;for (++it; it != v.end(); os << ' ' << *it++); return os;\n}\n#ifdef Wavator\n#define de(...) cout << #__VA_ARGS__ << \" = \", W(__VA_ARGS__)\n#else\n#define de(...) 42\n#define cerr if (false) cout\n#endif\nvoid W(){cout<<endl;}\ntemplate <typename H, typename...T> inline void W(H head, T... tail){\n    cout << head << ' ';\n    W(tail...);\n}\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define per(i, a, b) for (int i = (b) - 1, i##_end_ = (a); i >= i##_end_; --i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst db eps = 1e-9, PI = acos(-1);\nconst ll mod = (ll)1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nmt19937 rnd((ull)time(0));\nll pow_mod(ll a, ll b) {\n    assert(b >= 0); ll res = 1;\n    for (a %= mod; b; b >>= 1, a = a * a % mod) if (b & 1)res = res * a % mod;\n    return res;\n}\n/////////////////////////////////////////////////////////////////////////\nvoid solve();\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    solve();\n    return 0;\n}\n\nconst ll add = 49;\nll n;\nset<int> s;\ninline ll count(int n = 20) {\n    for(int a=0;a<=n;a++)\n        for(int b=0;a+b<=n;b++)\n            for(int c=0;a+b+c<=n;c++) {\n                int d=n-a-b-c;\n                s.insert(a+5*b+10*c+50*d);\n            }\n    return SZ(s);\n}\nvoid solve() {\n    cin >> n;\n    if(n <= 12) {\n        cout << count(n) << endl;\n        return;\n    }\n    cout << add*(n - 20) + count();\n    return;\n}"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "greedy"], "dificulty": "2000", "interactive": false}