{
    "link": "https://codeforces.com//contest/998/problem/D",
    "problemId": "194448",
    "problem_idx": "D",
    "shortId": "998D",
    "contest_number": "998",
    "problem_submissions": {
        "E": [
            39844279,
            39844719,
            39842563,
            39860454,
            39860368
        ],
        "D": [
            39839915,
            39841332,
            39842999,
            39838622,
            39833588,
            39834360,
            39835519,
            39835358,
            39836436,
            39839136,
            39835483,
            39834881,
            39832459,
            39838234,
            39834518,
            39836090,
            39838820,
            39836619
        ],
        "B": [
            39829464,
            39826160,
            39828535,
            39827534,
            39825326,
            39826819,
            39826965,
            39827064,
            39824985,
            39826413,
            39828466,
            39828134,
            39827004,
            39829078,
            39829375,
            39828106,
            39826996,
            39829712
        ],
        "C": [
            39826150,
            39829299,
            39830565,
            39832057,
            39827518,
            39829277,
            39828734,
            39829936,
            39831699,
            39829124,
            39832064,
            39831642,
            39829279,
            39831274,
            39831057,
            39831568,
            39830502,
            39831907
        ],
        "A": [
            39824455,
            39823644,
            39825721,
            39823552,
            39823494,
            39823346,
            39825072,
            39824102,
            39823293,
            39823771,
            39825353,
            39823995,
            39824239,
            39823343,
            39835371,
            39823495,
            39823392,
            39823469
        ]
    },
    "name": "D. Roman Digits",
    "statement": "Let’s introduce a number system which is based on a roman digits. There\r\nare digits , , , which correspond to the numbers 1, 5, 10 and 50\r\nrespectively. The use of other roman digits is not allowed.Numbers in\r\nthis system are written as a sequence of one or more digits. We define\r\nthe value of the sequence simply as the sum of digits in it.For example,\r\nthe number evaluates to 35 and the number to 12.Pay attention to the\r\ndifference to the traditional roman system in our system any sequence of\r\ndigits is valid, moreover the order of digits doesn’t matter, for\r\nexample means 11, not 9.One can notice that this system is ambiguous,\r\nand some numbers can be written in many different ways. Your goal is to\r\ndetermine how many distinct integers can be represented by n roman\r\ndigits , , , .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B> inline ostream& operator<<(ostream&os, const pair<A, B> &v) {return os << v.first << ' ' << v.second;}\ntemplate <typename A> inline ostream& operator<<(ostream&os, const vector<A> &v){\n    auto it = v.begin(); os << *it;for (++it; it != v.end(); os << ' ' << *it++); return os;\n}\n#ifdef Wavator\n#define de(...) cout << #__VA_ARGS__ << \" = \", W(__VA_ARGS__)\n#else\n#define de(...) 42\n#define cerr if (false) cout\n#endif\nvoid W(){cout<<endl;}\ntemplate <typename H, typename...T> inline void W(H head, T... tail){\n    cout << head << ' ';\n    W(tail...);\n}\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define per(i, a, b) for (int i = (b) - 1, i##_end_ = (a); i >= i##_end_; --i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst db eps = 1e-9, PI = acos(-1);\nconst ll mod = (ll)1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nmt19937 rnd((ull)time(0));\nll pow_mod(ll a, ll b) {\n    assert(b >= 0); ll res = 1;\n    for (a %= mod; b; b >>= 1, a = a * a % mod) if (b & 1)res = res * a % mod;\n    return res;\n}\n/////////////////////////////////////////////////////////////////////////\nvoid solve();\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    solve();\n    return 0;\n}\n\nconst ll add = 49;\nll n;\nset<int> s;\ninline ll count(int n = 20) {\n    for(int a=0;a<=n;a++)\n        for(int b=0;a+b<=n;b++)\n            for(int c=0;a+b+c<=n;c++) {\n                int d=n-a-b-c;\n                s.insert(a+5*b+10*c+50*d);\n            }\n    return SZ(s);\n}\nvoid solve() {\n    cin >> n;\n    if(n <= 12) {\n        cout << count(n) << endl;\n        return;\n    }\n    cout << add*(n - 20) + count();\n    return;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Roman Digits.json",
    "editorial_link": "https://codeforces.com//blog/entry/60357",
    "editorial": "TL; DR  among all the sequences, select the one, which contains the maximum number of 50\n, in case of tie, select one with largest number of 9\n. Bruteforce all configurations in such way, that each number is counted only in it's \"maximum\" configuration.\n\nSince the length of sequence is fixed, we can solve problem not for digits {1,5,10,50}\n, but for digits {0,4,9,49}\n.\n\nLet's solve the problem for digits {0,4,9}\n first.\n\nWe have a problem that some numbers have many representations. But this, in fact, is easy to deal with  if we have at least nine digits \"4\" than we can convert them no some number of \"9\" digits, and fill the rest with zeroes.\n\nIn this case, the solution is to bruteforce the number of \"4\" from 0\n to min(8,n)\n, and then from the remaining digits select any arbitrary number of \"9\", each such choice leads to an unique number.\n\nLet's return to the original problem with {0,4,9,49}\n.\n\nIn this case we can also face the situation, when the number of 49\n can be increased. We need to identify all pairs (x,y)\n where x,y?50\n, such that they can be transformed to other pair (x?,y?)\n with detachment of few 49\n.\n\nWe can bruteforce all x\n, y\n, x?\n, y?\n with four nested for-loops and check, that the sum of first differs from sum of latter by few number of 49\n removed, in such case we mark the pair (x,y)\n as broken.\n\nWe can also note, that if some pair is marked as broken, than all \"dominating\" pairs also marked as broken.\n\nWhen we discovered which pairs are good we can simply:",
    "hint": []
}