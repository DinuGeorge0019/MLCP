{
    "link": "https://codeforces.com//contest/2082/problem/B",
    "problemId": "3268232",
    "problem_idx": "B",
    "shortId": "2082B",
    "contest_number": "2082",
    "problem_submissions": {
        "C": [
            310757662,
            310738839,
            310741948,
            310755345,
            310747809,
            310754991,
            310750033,
            310742245,
            310745992,
            310739427,
            310766291,
            310770365,
            310774496,
            310738439,
            310742256
        ],
        "B": [
            310756193,
            310762836,
            310736704,
            310738531,
            310762205,
            310765739,
            310741348,
            310948734,
            310739682,
            310748022,
            310769249,
            310747145,
            310731841,
            310735775
        ],
        "A": [
            310752338,
            310731483,
            310732296,
            310731957,
            310751405,
            310733958,
            310731435,
            310736063,
            310731710,
            310738741,
            310755946,
            310768406,
            310734097,
            310731262,
            310731419
        ],
        "F": [
            310740415,
            310756365,
            310763981,
            310765480,
            310763103,
            310764545,
            310754661,
            310762420,
            310770297,
            310753852,
            310773942
        ],
        "D": [
            310780095,
            310748052,
            310761917,
            310773885,
            310767254
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140702",
    "editorial": "SolutionLetâ€™s consider how to find the maximum value first. Consider in\r\nbinary form. Let the number formed by the last bits of be denoted as ,\r\nand the remaining higher bits form the number (for instance, if , , ,\r\nthen , ), then the final value of after operations will be either or ,\r\ndepending on whether a carry-over occurs in during the last operation.If\r\nthere are no s in the higher bits of , then the carry-over in during the\r\nlast operation can never occur (operating on some small tests may give\r\nyou a better understanding). Otherwise, we can choose to perform floor\r\noperations first followed by ceil operations, which can guarantee a\r\ncarry-over in during the last operation.This demonstrates that\r\nperforming floor operations first followed by ceil operations will\r\nalways yield the maximum value. Similarly, performing ceil operations\r\nfirst followed by floor operations will always produce the minimum\r\nvalue. We can simply simulate these operations because after same\r\noperations, will remain unchanged.The time complexity is .\r\n",
    "name": "B. Floor or Ceil",
    "statement": "Ecrade has an integer x. There are two kinds of operations. Replace x\r\nwith\r\nleft\r\nlfloor\r\ndfrac{x}{2}\r\nright\r\nrfloor, where\r\nleft\r\nlfloor\r\ndfrac{x}{2}\r\nright\r\nrfloor is the greatest integer\r\nle\r\ndfrac{x}{2}. Replace x with\r\nleft\r\nlceil\r\ndfrac{x}{2}\r\nright\r\nrceil, where\r\nleft\r\nlceil\r\ndfrac{x}{2}\r\nright\r\nrceil is the smallest integer\r\nge\r\ndfrac{x}{2}. Ecrade will perform exactly n first operations and m second\r\noperations in any order. He wants to know the minimum and the maximum\r\npossible value of x after n+m operations. However, it seems a little\r\ndifficult, so please help him!\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Floor or Ceil.json",
    "hint": [
        "Hint 1 Consider in binary form.",
        "Hint 2 What are all possible values of after operations?",
        "Hint 2 What are all possible numbers of operations to make equal to ?",
        "Hint 3 Consider using dynamic programming to calculate the answer.",
        "Hint 1 Let's only consider the comparison between adjacent pairs first. Call a pair an inversion pair if . In each operation, how can the number of inversion pairs change?",
        "Hint 2 Under what circumstances can we decrease the maximum number of inversion pairs in every operation?",
        "Hint 1 Do we really have to consider the problem on the whole matrix?",
        "Hint 2 Use greedy algorithm and guess some possible conclusions. Can you prove them (or construct some counterexamples) ?",
        "Hint There are only edges that are truly useful in the whole graph.",
        "Hint 1 Move each chip as deep as possible in descending order of labels. Can we simplify the operations after that?",
        "Hint 2 Now we only need to move the chips upward and swap adjacent chips with the same color. What can we do after that?",
        "Hint 3 We can perform dynamic programming (DP) to calculate the numbers. What information do we need to record?",
        "Hint 4 We need to record the color and the length of the top monochromatic segment. How can we perform the DP in time complexity?",
        "Hint 1 If , then unless or .",
        "Hint 2 Think about the method of sieve.",
        "Hint 1 Consider the DFS structure of sieve. What kind of nodes are important? How many of nodes are important?",
        "Hint 2 Consider using Du Sieve to get some important functions."
    ]
}