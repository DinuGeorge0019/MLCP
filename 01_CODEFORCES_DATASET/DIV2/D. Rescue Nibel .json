{
    "link": "https://codeforces.com//contest/1420/problem/D",
    "problemId": "735853",
    "problem_idx": "D",
    "shortId": "1420D",
    "contest_number": "1420",
    "problem_submissions": {
        "E": [
            93699813,
            93707260,
            93695968,
            93707648,
            93705681,
            93709151,
            93715432,
            93730964,
            93708580,
            93714548,
            93716147,
            93715550,
            93736542,
            93717442,
            93710855,
            93715981,
            93697763,
            93711132,
            93762507
        ],
        "D": [
            93676952,
            93680084,
            93692950,
            93670877,
            93690670,
            93693136,
            93730971,
            93710781,
            93702357,
            93681953,
            93695104,
            93691378,
            93699248,
            93698024,
            93665582,
            93680861,
            93671056,
            93667892,
            93675623
        ],
        "C2": [
            93674880,
            93671167,
            93692067,
            93741708,
            93681627,
            93659881,
            93679255,
            93686831,
            93676610,
            93670869,
            93669089,
            93684016,
            93707465,
            93690589,
            93710188,
            93716769,
            93662876,
            93683514,
            93665601
        ],
        "C1": [
            93658399,
            93663408,
            93681461,
            93660059,
            93679792,
            93666232,
            93663489,
            93671318,
            93669597,
            93684191,
            93665522,
            93690460,
            93659663,
            93716842,
            93670252,
            93662639,
            93658224,
            93665421
        ],
        "B": [
            93652358,
            93659482,
            93658665,
            93669626,
            93664158,
            93660524,
            93657692,
            93655021,
            93655235,
            93677044,
            93656189,
            93674995,
            93653603,
            93704106,
            93656350,
            93653174,
            93653888,
            93653561
        ],
        "A": [
            93651966,
            93651886,
            93654562,
            93660205,
            93652727,
            93651674,
            93651632,
            93674907,
            93652710,
            93659767,
            93651617,
            93706046,
            93651985,
            93651435,
            93651489,
            93651367
        ]
    },
    "name": "D. Rescue Nibel ",
    "statement": "Ori and Sein have overcome many difficult challenges. They finally lit\r\nthe Shrouded Lantern and found Gumon Seal, the key to the Forlorn Ruins.\r\nWhen they tried to open the door to the ruins... nothing happened.Ori\r\nwas very surprised, but Sein gave the explanation quickly: clever Gumon\r\ndecided to make an additional defence for the door.There are n lamps\r\nwith Spirit Tree’s light. Sein knows the time of turning on and off for\r\nthe i-th lamp l_i and r_i respectively. To open the door you have to\r\nchoose k lamps in such a way that there will be a moment of time when\r\nthey all will be turned on.While Sein decides which of the k lamps to\r\npick, Ori is interested: how many ways there are to pick such k lamps\r\nthat the door will open? It may happen that Sein may be wrong and there\r\nare no such k lamps. The answer might be large, so print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=1e6+5,Mod=998244353;\nint n,a[N],s1[N],s2[N],fac[N]={1,1},finv[N]={1,1},k,ans,l[N],r[N],cnt;\nint C(int n,int m){\n\tif(m>n||n<0||m<0) return 0;\n\treturn 1ll*fac[n]*finv[m]%Mod*finv[n-m]%Mod;\n}\npair<int,int>b[N];\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,2,n) fac[i]=1ll*fac[i-1]*i%Mod;\n\trep(i,2,n) finv[i]=1ll*(Mod-Mod/i)*finv[Mod%i]%Mod;\n\trep(i,1,n) finv[i]=1ll*finv[i-1]*finv[i]%Mod;\n\trep(i,1,n){\n\t\tint l,r; scanf(\"%d%d\",&l,&r);\n\t\tb[i*2]=make_pair(l,i*2);\n\t\tb[i*2+1]=make_pair(r,i*2+1);\n\t\t/*s1[l]++,s1[r+1]--;\n\t\ts2[l+1]++,s2[r+1]--;*/\n\t}\n\tsort(b+2,b+2*n+1+1);\n\trep(i,2,2*n+1){\n\t\tint p=b[i].second;\n\t\tif(b[i].first!=b[i-1].first) cnt++;\n\t\tif(p&1){\n\t\t\tr[p/2]=cnt;\n\t\t}else{\n\t\t\tl[p/2]=cnt;\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts1[l[i]]++; s1[r[i]+1]--;\n\t\ts2[l[i]+1]++; s2[r[i]+1]--;\n\t}\n\trep(i,1,cnt) s1[i]=s1[i-1]+s1[i],s2[i]=s2[i-1]+s2[i];\n\trep(i,1,cnt){\n\t\tans=(1ll*ans+C(s1[i],k)+Mod-C(s2[i],k))%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Rescue Nibel .json",
    "editorial_link": "https://codeforces.com//blog/entry/82978",
    "editorial": "In this task, we need to find the number of sets of segments such that\r\nthese segments intersect at least in one point.Letâs look at the\r\nstarting point of the intersection. This point will always be the\r\nbeginning of a segment. Let us find the number of sets of segments that\r\ntheir intersection begins at the point . Let us denote as number of\r\nsegments that pass through this point, and as numbers of segments that\r\nstart at this point. Then all the segments must pass through and at\r\nleast one segment must start at . The number of sets of segments passing\r\nthrough is and the number of sets of segments passing through , none of\r\nwhich starts at , is . From here we obtain that the required number of\r\npiece sets is . By summing up all possible values, we get the answer to\r\nthe task.It should be noted that and can be easily supported using the\r\nevent method. Then, the total runtime will be .\r\n",
    "hint": [
        "Hint The intersection of any segments is either empty or is a segment. Let's fix the left bound of the intersection and calculate the number of sets of segments such that their intersection starts in this left bound."
    ]
}