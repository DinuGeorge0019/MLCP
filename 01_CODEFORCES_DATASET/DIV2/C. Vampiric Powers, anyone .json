{
    "link": "https://codeforces.com//contest/1847/problem/C",
    "problemId": "1996640",
    "problem_idx": "C",
    "shortId": "1847C",
    "contest_number": "1847",
    "problem_submissions": {
        "F": [
            212433608,
            212431110,
            212414836,
            212437044,
            212436646,
            212438573,
            212439809,
            212461142,
            212444034,
            212441048,
            212442560,
            212446414,
            212448526,
            212446363,
            212477387,
            212473113,
            212447258,
            212445412,
            212440060,
            212484613,
            212430011,
            212447626,
            212448642,
            212429172
        ],
        "D": [
            212389437,
            212405663,
            212427981,
            212401825,
            212406614,
            212408665,
            212391793,
            212412178,
            212420289,
            212416938,
            212416798,
            212415041,
            212411965,
            212408607,
            212417943,
            212402342,
            212440813,
            212424407,
            212414209,
            212448028
        ],
        "C": [
            212379554,
            212388481,
            212381978,
            212383167,
            212391492,
            212395637,
            212408363,
            212918680,
            212459952,
            212459679,
            212387499,
            212392748,
            212401136,
            212392067,
            212389261,
            212394523,
            212454918,
            212396638,
            212395742,
            212387056,
            212410808,
            212403757,
            212388758,
            212439567
        ],
        "B": [
            212375586,
            212386366,
            212383195,
            212377114,
            212379209,
            212382779,
            212400416,
            212381176,
            212374781,
            212381202,
            212383485,
            212376778,
            212384302,
            212388840,
            212379283,
            212442148,
            212382593,
            212383125,
            212398777,
            212403514
        ],
        "A": [
            212372531,
            212381099,
            212372843,
            212372985,
            212372832,
            212383462,
            212396957,
            212372898,
            212372422,
            212372468,
            212373223,
            212373301,
            212373237,
            212373415,
            212375604,
            212372629,
            212374004,
            212375662,
            212372722,
            212387500
        ],
        "E": [
            212780531,
            212480822
        ]
    },
    "name": "C. Vampiric Powers, anyone ",
    "statement": "DIO knows that the Stardust Crusaders have determined his location and\r\nwill be coming to fight him. To foil their plans he decides to send out\r\nsome Stand users to fight them. Initially, he summoned n Stand users\r\nwith him, the i-th one having a strength of a_i. Using his vampiric\r\npowers, he can do the following as many times as he wishes: Let the\r\nnumber of Stand users be m. DIO chooses an index i (1\r\nle i\r\nle m). Then he summons a new Stand user, with index m+1 and strength\r\ngiven by: a_{m+1} = a_i\r\noplus a_{i+1}\r\noplus\r\nldots\r\noplus a_m,where the operator\r\noplus denotes the bitwise XOR operation. Now, the number of Stand users\r\nbecomes m+1. Unfortunately for DIO, by using Hermit Purple\u2019s divination\r\npowers, the Crusaders know that he is plotting this, and they also know\r\nthe strengths of the original Stand users. Help the Crusaders find the\r\nmaximum possible of a Stand user among all possible ways that DIO can\r\nsummon.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define N 300'005\n\nint n, k, a[N];\nvoid solve()\n{\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    int ans = 0;\n    set<int> s;\n    s.insert(0);\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] ^= a[i - 1];\n        for (int j : s)\n        {\n            ans = max(ans, a[i] ^ j);\n        }\n        s.insert(a[i]);\n    }\n    cout << ans << '\\n';\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Vampiric Powers, anyone .json",
    "editorial_link": "https://codeforces.com//blog/entry/117928",
    "editorial": "Lets assume you know string . String is made by positions in . Lets\r\ndenote position in from which is made. For maximising you need to make\r\nthe starting elements in as large as possible. Now, to make\r\nlexicographically as large as possible, we need to swap positions in .\r\nWe can swap positions greedily. We first try making . Then we try making\r\nand so on. Now, suppose for two indices , () such that , we know that\r\nindex is waste. is basically the preference of indices in which should\r\nbe equal to . If is to be set , then it would already be set because\r\nbefore setting equal to we would have already set equal to because is\r\nequal to . Hence, for each index in , we only add its first occurrence\r\nin . This makes the size of bound by size of . Now, this can be found\r\nusing various pbds like set,dsu,segment tree,etc. Now, before answering\r\nthe queries, we find the answer for the current string . We know that\r\nthere are ones and zeros in . So, for each (), we make . Hence, the\r\nnumber of swaps needed will become number of positions () such that\r\n.Now, in each query, there is exactly one positions that is either\r\ngetting flipped from to or from to . That is, is either getting changed\r\nto or . You already know the answer for . Now, if is getting reduced,\r\nthen you need to decrease the answer by one if and . If is increasing by\r\none, then you need to add one to the answer if and . Time complexity - .\r\n"
}