{
    "link": "https://codeforces.com//contest/787/problem/E",
    "problemId": "99626",
    "problem_idx": "E",
    "shortId": "787E",
    "contest_number": "787",
    "problem_submissions": {
        "E": [
            25747805,
            25769219,
            25744553,
            26717332,
            25755415,
            25762542
        ],
        "B": [
            25745774,
            25737596,
            25738540,
            25745875,
            25737776,
            25744359,
            25738056,
            25737770,
            25738864,
            25741107,
            25738246,
            25737616,
            25739109,
            25738592,
            25739173,
            25738726,
            25737800,
            25737780,
            25738984,
            25738382
        ],
        "D": [
            25744630,
            25741896,
            25745115,
            25749718,
            25746276,
            25756806,
            25761778,
            25761748
        ],
        "C": [
            25741086,
            25747033,
            25750675,
            25741659,
            25745560,
            25745890,
            25749024,
            25741922,
            25743935,
            25744643,
            25745202,
            25745392,
            25745995,
            25746453,
            25745702,
            25745999,
            25746587
        ],
        "A": [
            25736581,
            25736552,
            25743791,
            25736575,
            25739966,
            25736705,
            25736522,
            25736956,
            25738154,
            25736876,
            25736540,
            25736830,
            25737058,
            25737179,
            25737189,
            25736539,
            25736641,
            25737439,
            25736572
        ]
    },
    "name": "E. Till I Collapse",
    "statement": "Rick and Morty want to find MR. PBH and they can\u2019t do it alone. So they\r\nneed of Mr. Meeseeks. They Have generated Mr. Meeseeks, standing in a\r\nline numbered from to . Each of them has his own color. -th Mr.\r\nMeeseeks\u2019 color is . Rick and Morty are gathering their army and they\r\nwant to divide Mr. Meeseeks into some squads. They don\u2019t want their\r\nsquads to be too colorful, so each squad should have Mr. Meeseeks of at\r\nmost different colors. Also each squad should be a continuous subarray\r\nof Mr. Meeseeks in the line. Meaning that for each , if Mr. Meeseeks\r\nnumber and Mr. Meeseeks number are in the same squad then Mr. Meeseeks\r\nnumber should be in that same squad. Also, each squad needs its own\r\npresidio, and building a presidio needs money, so they want the total\r\nnumber of squads to be minimized.Rick and Morty haven\u2019t finalized the\r\nexact value of , so in order to choose it, for each between and\r\n(inclusive) need to know the minimum number of presidios needed.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 101010, MAXD = 300;\nint n, a[MAXN], ans[MAXN];\nint visit[MAXN], vn = 0;\nint b[MAXD][MAXN];\nint bn[MAXD], pos[MAXD];\nvoid getans(int v)\n{\n\tvn++;\n\tint now = 0;\n\tint nowans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(visit[a[i]] != vn)\n\t\t{\n\t\t\tif(++now > v)\n\t\t\t{\n\t\t\t\tnowans++;\n\t\t\t\tvn++;\n\t\t\t\tnow = 1;\n\t\t\t}\n\t\t\tvisit[a[i]] = vn;\n\t\t}\n\tif(now)\n\t\tnowans++;\n\tans[v] = nowans;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tmemset(visit, 0, sizeof(visit));\n\tint now = 1;\n\twhile(now <= n)\n\t{\n\t\tgetans(now);\n\t\tif(ans[now] < MAXD - 1 && ans[now] < now)\n\t\t\tbreak;\n\t\tnow++;\n\t}\n\tif(++now <= n)\n\t{\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(bn, 0, sizeof(bn));\n\t\tint tmp = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif(!b[tmp][a[i]] && bn[tmp] == now)\n\t\t\t{\n\t\t\t\tpos[tmp] = i;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tif(!b[tmp][a[i]]++)\n\t\t\t\tbn[tmp]++;\n\t\t}\n\t\tpos[tmp] = n + 1;\n\t\tans[now] = tmp;\n\t\twhile(++now <= n)\n\t\t{\n\t\t\tfor(int i = 1; i <= tmp; i++)\n\t\t\t{\n\t\t\t\twhile(pos[i] <= n)\n\t\t\t\t{\n\t\t\t\t\tif(!b[i][a[pos[i]]] && bn[i] == now)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(!--b[i + 1][a[pos[i]]])\n\t\t\t\t\t\tbn[i + 1]--;\n\t\t\t\t\tif(!b[i][a[pos[i]++]]++)\n\t\t\t\t\t\tbn[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(tmp > 1 && pos[tmp - 1] > n)\n\t\t\t\ttmp--;\n\t\t\tans[now] = tmp;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tprintf(\"%d \", ans[i]);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Till I Collapse.json",
    "editorial_link": "https://codeforces.com//blog/entry/51163",
    "editorial": "Your task is to find the minimum number of parts needed to partition this such that each part contains no more than k different numbers.\n\nFor a fixed k, we can greedily find the answer. First, fix a maximal partition with at most k different numbers in it, then a maximal after that and so on. If answer for k is ans(k), we can find this number in . The only thing we want is to find maximum r for a fixed l so that [l,?r] has at most k distinct numbers.\n\nThis can be done with binary search + segment tree, but it's too slow. We can do this using a persistent segment tree in : for a fixed l, we define fl(i) to be 1 if l???i and there's no such j that l???j?<?i and ai?=?aj otherwise 0. So, if we have a segment tree on every fl, we can use this segment tree to find the first r for an arbitrary k (it's like finding k?-?th one in this array).\n\nSo we find the answer in , so the total complexity is , and because , , so:"
}