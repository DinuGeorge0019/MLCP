{
    "link": "https://codeforces.com//contest/2021/problem/E2",
    "problemId": "2929697",
    "problem_idx": "E2",
    "shortId": "2021E2",
    "contest_number": "2021",
    "problem_submissions": {
        "D": [
            284590256,
            284590001,
            284586301,
            284623851,
            284569171,
            284578878,
            284712748,
            284578625,
            284581515,
            284581353,
            284637993
        ],
        "E3": [
            284578176,
            284565599,
            284600842,
            284850992,
            284584216,
            284618196,
            284597636,
            284599022,
            284585148,
            286020331,
            284745105
        ],
        "E1": [
            284577293,
            284599054,
            284566976,
            284599574,
            284568532,
            284584477,
            284579805,
            284586608,
            284600476,
            284585423,
            284594051,
            284576473,
            284592731,
            284581221,
            284582830,
            284576965,
            286020463,
            284573682,
            284745154,
            284585073
        ],
        "E2": [
            284576481,
            284599368,
            284566551,
            284571784,
            284584447,
            284580377,
            284586193,
            284585357,
            284576258,
            284585492,
            284583546,
            284582548,
            286020438,
            284593395,
            284766277,
            284587863
        ],
        "C2": [
            284552959,
            284550125,
            284578847,
            284570668,
            284557743,
            284572571,
            284559765,
            284559531,
            284592443,
            284564745,
            284553608,
            284551809,
            284555032,
            284564040,
            284565535,
            284591262,
            284564727,
            284560092
        ],
        "C1": [
            284543395,
            284545189,
            284579118,
            284555011,
            284551439,
            284544381,
            284549845,
            284558858,
            284582609,
            284556392,
            284545368,
            284554154,
            284545358,
            284546156,
            284555833,
            284553560,
            284550666,
            284546712,
            284545533,
            284552561
        ],
        "B": [
            284537997,
            284541648,
            284545572,
            284550280,
            284536827,
            284538339,
            284543136,
            284541306,
            284577835,
            284541582,
            284538597,
            284539525,
            284540971,
            284538476,
            284541915,
            284545007,
            284543924,
            284540121,
            284540098,
            284544260
        ],
        "A": [
            284536034,
            284541336,
            284535964,
            284545882,
            284543072,
            284535980,
            284537720,
            284537149,
            284572305,
            284541440,
            284535781,
            284536205,
            284539247,
            284535865,
            284537520,
            284541705,
            284541775,
            284537231,
            284537773,
            284536991
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134873",
    "editorial": "Since the cost of a path uses the maximum edge weight in the path, we can use a Kruskal-like algorithm that is similar to finding the MST (Minimum Spanning Tree). Initially, the graph has no edges, and we add each edge one by one starting from the smallest values of wi\n, while maintaining the connected components in the graph using DSU (Disjoint Set Union).\n\nWhile doing the MST algorithm, we simultaneously construct the reachability tree of the graph, whose structure represents the sequence of mergings of connected components in the algorithm. Each vertex in the reachability tree corresponds to some connected component at some point in time in the algorithm. Each non-leaf vertex in the reachability tree always has two children, which are the two connected components that are merged to form the connected component represented by that vertex, so every time two connected components merge in the algorithm, we make a new vertex in the reachability tree that is connected to its two corresponding children.\n\nAfter doing all that, we've constructed a reachability tree that is a rooted binary tree with 2n?1\n vertices, n\n of which are leaves. For each non-leaf vertex x\n, we write down weight[x]\n which is the weight of the edge that forms its connected component. For each leaf, we mark it as special if and only if it corresponds to a house that needs internet. Then, for each vertex x\n, we calculate cnt[x]\n, which is the number of special leaves in the subtree of x\n. These values will be used later.\n\nConsider a non-leaf x\n in the reachability tree. It can be obtained that two vertices in the original graph corresponding to any two leaves in the subtree of x\n can have a path between them in the original graph with a weight of at most weight[x]\n.\n\nLet's solve for some value of k\n. For each special vertex x\n, we want to choose a target vertex y\n that's an ancestor of x\n. Then, we choose a set of k\n leaves for the houses with installed servers. We want it such that each chosen target has at least one leaf in its subtree that is a member of the set. The total path cost of this is the sum of weight[y]\n for all chosen targets y\n.\n\nLet's say we've fixed the set of k\n leaves. Then, we mark every ancestor of these leaves. If we only consider the marked vertices with the edges between them, we have a reduced tree. For each special leaf, we want to choose its nearest ancestor that is in the reduced tree for its target to get the one with the smallest weight.\n\nKnowing this, we can solve the problem in another point of view. Initially, we have the original reachability tree. We want to reduce it into a reduced tree with k\n leaves. We want to do it while maintaining the chosen targets of the special leaves and their costs. Initially, for each special leaf, we choose itself as its target. In one operation, we can do the following:\n\nChoose a vertex that's currently a leaf.\nMove every target that's currently in that leaf to its parent.\nRemove that leaf and the edge connecting it to its parent.\nWe want to do that until the reduced tree has k\n leaves.\n\nFor each edge connecting a vertex x\n to its parent y\n in the reachability tree, calculate (weight[y]?weight[x])×cnt[x]\n. That is the cost to move every target in vertex x\n to vertex y\n. Define that as the edge's length.\n\nWe want to do operations with the minimum cost so that the reduced tree has k\n leaves. We want to minimize the sum of lengths of the deleted edges. If we look at it in a different way, we want to choose edges to be in the reduced tree with the maximum sum of lengths.\n\nFor some value of k\n, the edges of the reduced tree can be decomposed into k\n paths from some vertex to its descendant. We want the total sum of lengths of these paths to be as big as possible. But how do we solve it for every k\n from 1\n to n\n?\n\nLet's say k=1\n. We can choose the path from the root to its furthest leaf. How do we solve for k=2\n onwards? It turns out that we can use the optimal solution for some value of k\n to make the optimal solution for k+1\n, by just adding the longest possible available path. That means, for each k\n from 1\n to n\n, we just find the current longest available path and add it to our reduced tree.\n\nWhat if at some point. there are more than one possible longest paths? It can be proven that we can choose any of these paths and the optimal solutions for the next values of k\n will still be optimal.\n\nThe proof for this greedy strategy involves the convexity of the total length as k\n goes from 1\n to n\n. However, we won't explain it in detail here.\n\nSo to solve the problem, we do DFS in the reachability tree to calculate for each vertex x\n, the furthest leaf and the second furthest leaf in its subtree. For each k\n from 1\n to n\n, we add the current longest available path using this precalculation.\n\nTime complexity: O(nlogn+mlogm)",
    "name": "E2. Digital Village  Hard Version ",
    "statement": "Pak Chanek is setting up internet connections for the village of\r\nKhuntien. The village can be represented as a connected simple graph\r\nwith n houses and m internet cables connecting house u_i and house v_i,\r\neach with a latency of w_i.There are p houses that require internet. Pak\r\nChanek can install servers in at most k of the houses. The houses that\r\nneed internet will then be connected to one of the servers. However,\r\nsince each cable has its latency, the latency experienced by house s_i\r\nrequiring internet will be the latency of the cables between that house\r\nand the server it is connected to.For each k = 1,2,\r\nldots,n, help Pak Chanek determine the minimum latency that can be\r\nachieved for all the houses requiring internet.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}struct Edge{int u,v,w;}l[200010];bool operator<(Edge A,Edge B){return A.w<B.w;}int n,m,p;int rt,fa[200010],siz[200010],cnt[200010];int get_fa(int a){return a==fa[a]?a:fa[a]=get_fa(fa[a]);}long long bas[200010],del,tk;vector<long long> S[200010],tmp;void solve(){\tmemset(cnt,0,(n+1)<<2),memset(bas,0,(n+1)<<2); \tn=Qread(),m=Qread(),p=Qread();\tfor(int i=1;i<=p;i++) cnt[Qread()]=1; \tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=1,S[i].resize(2,0ll); \tfor(int i=1;i<=m;i++) l[i].u=Qread(),l[i].v=Qread(),l[i].w=Qread();\tsort(l+1,l+m+1); \tfor(int i=1,u,v;i<=m;i++) if(get_fa(l[i].u)!=get_fa(l[i].v))\t{\t\tu=get_fa(l[i].u),v=get_fa(l[i].v);\t\tif(siz[u]<siz[v]) swap(u,v); \t\tS[u][0]=1ll*cnt[u]*l[i].w,\t\tS[v][0]=1ll*cnt[v]*l[i].w; \t\ttmp.resize(siz[u]+siz[v]+1,0x3f3f3f3f3f3f3f3f);\t\tfor(int i=0;i<=siz[u];i++)\t\tfor(int j=0;j<=siz[v];j++)\t\t\ttmp[i+j]=min(tmp[i+j],S[u][i]+S[v][j]); \t\tfa[v]=u,siz[u]+=siz[v],cnt[u]+=cnt[v],bas[u]+=bas[v];\t\tswap(S[u],tmp);\t\tvector<long long>().swap(tmp);\t\tvector<long long>().swap(S[v]);\t}\trt=get_fa(1);\tfor(int i=1;i<=n;i++)\t\tprintf(\"%lld \",S[rt][i]);\tprintf(\"\\n\"); \tvector<long long>().swap(S[rt]);}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "dsu",
        "graphs",
        "math",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Digital Village  Hard Version .json",
    "hint": []
}