{
    "link": "https://codeforces.com//contest/244/problem/E",
    "problemId": "2195",
    "problem_idx": "E",
    "shortId": "244E",
    "contest_number": "244",
    "problem_submissions": {
        "D": [
            2571247,
            2570676,
            2575346,
            2576494,
            2682903,
            2585837,
            2585755,
            2572212,
            2572142,
            2579013,
            3418813,
            2572107,
            2574421
        ],
        "C": [
            2569289,
            2572891,
            2570409,
            2570513,
            2641304,
            2570920,
            2572105,
            2569437,
            2570373,
            2571030,
            2570901,
            2571143,
            2571722,
            2571723,
            3289288,
            2571234,
            2571110
        ],
        "B": [
            2568269,
            2572132,
            2568654,
            2569576,
            19961131,
            2568814,
            2570231,
            2570819,
            2569055,
            2570885,
            2568719,
            2569755,
            2569459,
            2569334,
            2568410,
            2569135,
            2570454,
            2569964,
            2569449
        ],
        "A": [
            2567788,
            2570624,
            2567790,
            2568110,
            2567940,
            2568024,
            2569710,
            2567812,
            2568427,
            2567980,
            2568379,
            2567844,
            2567847,
            2569075,
            2567791,
            2567881,
            2567930,
            2567996
        ],
        "E": [
            2585587,
            2630732
        ]
    },
    "name": "E. Colorado Potato Beetle",
    "statement": "Old MacDonald has a farm and a large potato field, square meters in\r\nsize. The field is divided into square garden beds, each bed takes up\r\none square meter.Old McDonald knows that the Colorado potato beetle is\r\nabout to invade his farm and can destroy the entire harvest. To fight\r\nthe insects, Old McDonald wants to spray some beds with insecticides.So\r\nOld McDonald went to the field, stood at the center of the central field\r\nbed and sprayed this bed with insecticides. Now he’s going to make a\r\nseries of movements and spray a few more beds. During each movement Old\r\nMcDonald moves left, right, up or down the field some integer number of\r\nmeters. As Old McDonald moves, he sprays all the beds he steps on. In\r\nother words, the beds that have any intersection at all with Old\r\nMcDonald’s trajectory, are sprayed with insecticides.When Old McDonald\r\nfinished spraying, he wrote out all his movements on a piece of paper.\r\nNow he wants to know how many beds won’t be infected after the invasion\r\nof the Colorado beetles.It is known that the invasion of the Colorado\r\nbeetles goes as follows. First some bed on the field border gets\r\ninfected. Than any bed that hasn’t been infected, hasn’t been sprayed\r\nwith insecticides and has a common side with an infected bed, gets\r\ninfected as well. Help Old McDonald and determine the number of beds\r\nthat won’t be infected by the Colorado potato beetle.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define N 1111\ntypedef long long LL;\nvector<pair<LL,LL> > segx,segy;\nvector<pair<pair<LL,LL>,pair<LL,LL> > > segment;\nint matrix[N*4][N*4];\nvoid add(LL x1, LL y1, LL x2, LL y2){\n    if(x1 > x2) swap(x1,x2);\n    if(y1 > y2) swap(y1,y2);\n    segment.push_back(make_pair( make_pair(x1,y1), make_pair(x2,y2) ) );\n}\n\nvoid dfs(int x, int y){\n    if(x < 0 || y < 0 || x >= segx.size() || y >= segy.size() || matrix[x][y] != 0) return;\n    matrix[x][y] = 2;\n    dfs(x-1,y);\n    dfs(x+1,y);\n    dfs(x,y-1);\n    dfs(x,y+1);\n}\nint main(){\n    int n;\n    cin >> n;\n    LL sx = 0, sy = 0;\n    LL tx,ty;\n    segx.push_back(make_pair(-2e9,0));\n    segx.push_back(make_pair(2e9,0));\n    segy.push_back(make_pair(-2e9,0));\n    segy.push_back(make_pair(2e9,0));\n    segx.push_back(make_pair(0,1));\n    segy.push_back(make_pair(0,1));\n    for(int i = 1; i <= n; i++){\n        char d;\n        LL mvstep;\n        LL wx = 0,wy = 0;\n        cin >> d >> mvstep;\n        wx = (int)(d == 'R') - (int)(d == 'L');\n        wy = (int)(d == 'D') - (int)(d == 'U');\n        tx = sx + wx * mvstep;\n        ty = sy + wy * mvstep;\n        segx.push_back(make_pair(tx,1));\n        segy.push_back(make_pair(ty,1));\n        add(sx,sy,tx,ty);\n        sx = tx; sy = ty;\n        //cout << sx << \" \" << sy << endl;\n    }\n    //\n    sort(segx.begin(),segx.end());\n    sort(segy.begin(),segy.end());\n    segx.resize(unique(segx.begin(),segx.end()) - segx.begin());\n    segy.resize(unique(segy.begin(),segy.end()) - segy.begin());\n    //for(int j = 0; j < segx.size(); j++)\n    //    cout << segx[j].first << \" \" << segx[j].second << endl;\n    //for(int j = 0; j < segy.size(); j++)\n    //    cout << segy[j].first << \" \" << segy[j].second << endl;\n    //cout << segx.size() << \" \" << segy.size() << endl;\n    int xsz = segx.size();\n    int ysz = segy.size();\n    for(int i = 0; i < xsz - 1; i++)\n        if(segx[i+1].first > 1 + segx[i].first){\n            segx.push_back(make_pair(segx[i].first+1,segx[i+1].first-segx[i].first-1));\n        }\n    for(int i = 0; i < ysz - 1; i++)\n        if(segy[i+1].first > 1 + segy[i].first){\n            segy.push_back(make_pair(segy[i].first+1,segy[i+1].first-segy[i].first-1));\n        }\n    sort(segx.begin(),segx.end());\n    sort(segy.begin(),segy.end());\n\n    for(int i = 0; i < n; i++){\n        int xsz = segx.size();\n        int ysz = segy.size();\n        int x1,x2,y1,y2;\n        //cout << i << endl;\n        for(int j = 0; j < xsz; j++){\n            if(segx[j].first == segment[i].first.first)\n                x1 = j;\n            if(segx[j].first == segment[i].second.first)\n                x2 = j;\n        }\n        for(int j = 0; j < ysz; j++){\n            if(segy[j].first == segment[i].first.second)\n                y1 = j;\n            if(segy[j].first == segment[i].second.second)\n                y2 = j;\n        }\n        //cout << x1 << \" \" << x2 << endl;\n        //cout << y1 << \" \" << y2 << endl;\n        for(int j = x1; j <= x2; j++)\n            for(int k = y1; k <= y2; k++){\n                //cout << j << \" \" << k << endl;\n                matrix[j][k] = 1;\n\n            }\n    }//cout << \" dkfjkdfj\"<<endl;\n    dfs(0,0);\n    LL ans = 0;\n    //cout << segx.size() << \" \" << segy.size() << endl;\n    for(int j = 0; j < segx.size(); j++)\n        for(int k = 0; k < segy.size(); k++){\n\n            if(matrix[j][k] != 2){\n                ans += segx[j].second * segy[k].second;\n                //cout << segx[j].second << \" \" << segy[k].second << endl;\n            }\n        }\n    cout << ans << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Colorado Potato Beetle.json",
    "editorial_link": "https://codeforces.com//blog/entry/5895",
    "editorial": null
}