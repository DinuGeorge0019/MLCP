{"link": "https://codeforces.com//contest/699/problem/F", "problemId": "65787", "problem_idx": "F", "shortId": "699F", "contest_number": "699", "problem_submissions": {"F": [19254979], "D": [19246128, 19238145, 19243994, 19244671, 19244055, 19240256, 19244440, 19243946, 19242445, 19244114, 19244888, 19248232, 19245369, 19243420, 19242965, 19246841, 19244016, 19246279, 19245771, 19248614], "C": [19238575, 19234685, 19237143, 19235854, 19236952, 19235501, 19237560, 19233107, 19236256, 19238050, 19237219, 19240071, 19233148, 19236181, 19237922, 19238682, 19238483, 19238795, 19237556, 19239587], "B": [19235764, 19233222, 19235273, 19233766, 19234773, 19233727, 19234737, 19236748, 19232804, 19234744, 19234328, 19236200, 19240174, 19238029, 19236795, 19234746, 19234487, 19234011, 19235700, 19235759], "A": [19233122, 19232168, 19232143, 19232104, 19232384, 19232378, 19232697, 19238171, 19232180, 19232809, 19232842, 19233530, 19236710, 19232307, 19233403, 19232204, 19232321, 19232485, 19232270, 19233389], "E": []}, "name": "F. Limak and Shooting Points", "statement": "Bearland is a dangerous place. Limak can t travel on foot. Instead, he\r\nhas magic teleportation stones. Each stone can be used . The -th stone\r\nallows to teleport to a point . Limak can use stones .There are monsters\r\nin Bearland. The -th of them stands at .The given points are pairwise\r\ndistinct.After each teleportation, Limak can shoot an arrow in some\r\ndirection. An arrow will hit the first monster in the chosen direction.\r\nThen, both an arrow and a monster disappear. It s dangerous to stay in\r\none place for long, so Limak can shoot only one arrow from one place.A\r\nmonster should be afraid if it s possible that Limak will hit it. How\r\nmany monsters should be afraid of Limak?\r\n", "solutions": ["#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#define bll long long\n#define dou double\n#define For(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define Rof(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define rep(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define rek(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define Cpy(a,b) memcpy(a,b,sizeof(b))\n//__builtin_popcountll\n\nconst int maxn=1000+10,maxL=(1<<7)+10;\nstruct Point\n{\n    int x,y;\n    Point() { x=y=0; }\n    Point(int a,int b) { x=a,y=b; }\n    void init() { scanf(\"%d%d\",&x,&y); }\n    friend Point operator - (const Point &a,const Point &b)\n    {\n        return Point(a.x-b.x,a.y-b.y);\n    }\n    long long crossdot(const Point &a) const\n    {\n        return (bll)x*a.y-(bll)y*a.x;\n    }\n    friend bool operator < (const Point &a,const Point &b)\n    {\n        if (a.x!=b.x) return a.x<b.x;\n        return a.y<b.y;\n    }\n}stone[10],monster[maxn];\nint K,N,M,G;\nbool vis[maxn];\nvector <int> R[5040+10000];\nvector <int> Q[maxn][10];\n\nint gcd(int a,int b)\n{\n    if (b==0) return a;\n    return gcd(b,a%b);\n}\n\nvoid minpoint(Point &t)\n{\n    int x=t.x,y=t.y;\n    int d=gcd(x,y);\n    if (d<0) d=-d;\n    if (d>1) t.x/=d,t.y/=d;\n}\n\n\nbool check_in(const Point &a,const Point &b,const Point &c)\n{\n    Point v1=b-a;\n    Point v2=c-a;\n    long long s=v1.crossdot(v2);\n    if (s!=0) return 0;\n    int x1=a.x,x2=b.x,x3=c.x;\n    if (x1==x2) x1=a.y,x2=b.y,x3=c.y;\n    if (x1<x3 && x3<x2) return 1;\n    if (x1>x3 && x3>x2) return 1;\n    return 0;\n}\n\nvoid Prepare()\n{\n    static int p[12];\n    M=0;\n    For(i,0,K-1) p[i]=i;\n    do\n    {\n        R[M].resize(K);\n        For(i,0,K-1) R[M][i]=p[i];\n        M++;\n    }while(next_permutation(p,p+K));\n    For(i,0,N-1)\n    {\n        Point v=monster[i];\n        For(j,0,K-1)\n        {\n            Q[i][j].clear();\n            Point u=stone[j];\n            For(kk,0,N-1)\n            {\n                if (i==kk) continue;\n                if (check_in(u,v,monster[kk]))\n                {\n                    Q[i][j].push_back(kk);\n                }\n            }\n        }\n    }\n}\n\n\nbool check(int x,vector <int> &T)\n{\n    static int o[maxn];\n    int h=0,t=0,ss=x;\n    o[h]=x; vis[x]=1;\n    for (; h<=t && h<K; h++)\n    {\n        x=o[h]; int w=T[h];\n        Point u=stone[w];\n        Point v=monster[x];\n        For(i,0,Q[x][w].size()-1)\n        {\n            int y=Q[x][w][i];\n            if (vis[y]) continue;\n            o[++t]=y;\n            vis[y]=1;\n            if (t>=K) \n            {\n                For(ttt,0,t) vis[o[ttt]]=0;\n                return 0;\n            }\n        }\n    }\n    For(i,0,t) vis[o[i]]=0;\n    if (t>=K) return 0;\n    return 1;\n}\n\nint main(int argc, char* argv[])\n{\n    for (; scanf(\"%d%d\",&K,&N)!=EOF; )\n    {\n        For(i,0,K-1) stone[i].init();\n        For(i,0,N-1) monster[i].init();\n        Prepare();\n        int ans=0,bs=(1<<K)-1;\n        Mem(vis,0);\n        For(i,0,N-1)\n        {\n            bool flag=0;\n            For(j,0,M-1)\n                if (check(i,R[j]))\n                {\n                    flag=1;\n                    break;\n                }\n            if (flag) ans++;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": [], "dificulty": "2600", "interactive": false}