{"link": "https://codeforces.com//contest/466/problem/D", "problemId": "13620", "problem_idx": "D", "shortId": "466D", "contest_number": "466", "problem_submissions": {"E": [7763666, 7769585, 7768735, 7765359, 7770616, 7766927, 7769884, 7936642, 7936570, 7804886], "D": [7760155, 7763392, 7765904, 7759889, 7764966, 7764929, 7766580, 7764380, 7763942, 7761240, 7768596, 7764705, 7771255, 7771465, 7770057, 7768205, 7768615, 7771047], "C": [7757835, 7757048, 7761148, 7755629, 7761932, 7754727, 7758439, 7760456, 7753794, 7759346, 7760630, 7760707, 7767525, 7760730, 7766019, 7761785, 7755926, 7763063], "B": [7756023, 7760247, 7761532, 7779459, 7760026, 7758357, 7756812, 7758808, 7762686, 7763357, 7765778, 7757733, 7758154, 7761303, 7770307, 7779355, 7764832], "A": [7753709, 7753409, 7756375, 7767138, 7753599, 7759314, 7753051, 7754371, 7755884, 7753912, 7754692, 7753400, 7753875, 7756172, 7753401, 7753155, 7754269]}, "name": "D. Increase Sequence", "statement": "Peter has a sequence of integers . Peter wants all numbers in the\r\nsequence to equal . He can perform the operation of \"adding one on the\r\nsegment \": add one to all elements of the sequence with indices from to\r\n(inclusive). At that, Peter never chooses any element as the beginning\r\nof the segment twice. Similarly, Peter never chooses any element as the\r\nend of the segment twice. In other words, for any two segments and ,\r\nwhere Peter added one, the following inequalities hold: and .How many\r\ndistinct ways are there to make all numbers in the sequence equal ?\r\nPrint this number of ways modulo . Two ways are considered distinct if\r\none of them has a segment that isn\u2019t in the other way.\r\n", "solutions": ["#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 2005\n#define mod 1000000007\nusing namespace std ;\ntypedef long long LL ;\n\nint N, H ;\nint dp[MAXN][MAXN] ;\nint p[MAXN] ;\n\nint main()\n{\n\tint i, j ;\n\tscanf(\"%d %d\", &N, &H) ;\n\tfor(i = 1; i <= N; i ++)\n\t\tscanf(\"%d\", &p[i]), p[i] = H-p[i] ;\n\tdp[0][0] = 1 ;\n\tfor(i = 0; i < N; i ++)\n\t\tfor(j = 0; j <= i; j ++)\n\t\t\tif(dp[i][j])\n\t\t\t{\n\t\t\t\tif(j == p[i+1])\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j] = (dp[i+1][j]+dp[i][j])%mod ;\n\t\t\t\t\tif(j > 0) dp[i+1][j-1] = (dp[i+1][j-1]+(LL)dp[i][j]*j)%mod ;\n\t\t\t\t}\n\t\t\t\tif(j+1 == p[i+1])\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j] = (dp[i+1][j]+(LL)dp[i][j]*(j+1))%mod ;\n\t\t\t\t\tdp[i+1][j+1] = (dp[i+1][j+1]+dp[i][j])%mod ;\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\\n\", dp[N][0]) ;\n\t//system(\"pause\") ;\n\treturn 0 ;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2100", "interactive": false}