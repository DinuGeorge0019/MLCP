{"link": "https://codeforces.com//contest/682/problem/C", "problemId": "62840", "problem_idx": "C", "shortId": "682C", "contest_number": "682", "problem_submissions": {"E": [18561879, 18561336, 18563426, 18572191, 18568838], "D": [18555791, 18558610, 18560557, 18552272, 18555181, 18555531, 18555300, 18555970, 18554396, 18555899, 18557118, 18557764, 18557208, 18556682, 18552327, 18556733, 18558689, 18554285, 18556142, 18557417], "C": [18552544, 18555995, 18556311, 18552880, 18552350, 18565999, 18551727, 18552070, 18553200, 18552786, 18550786, 18553141, 18554015, 18554928, 18554671, 18557194, 18554246, 18553490, 18557896, 18552468, 18554757], "B": [18548869, 18549933, 18550925, 18548469, 18549125, 18547478, 18548571, 18548891, 18548990, 18548117, 18548700, 18549479, 18547648, 18549616, 18547660, 18549624, 18549820, 18555517, 18549964, 18549305], "A": [18548806, 18547357, 18547853, 18549155, 18547571, 18566378, 18547486, 18547744, 18547663, 18548239, 18547470, 18547490, 18548002, 18547325, 18548103, 18548001, 18547695, 18548749, 18554886, 18547503, 18547920]}, "name": "C. Alyona and the Tree", "statement": "Alyona decided to go on a diet and went to the forest to get some\r\napples. There she unexpectedly found a magic rooted tree with root in\r\nthe vertex , every vertex and every edge of which has a number written\r\non.The girl noticed that some of the tree\u2019s vertices are , so she\r\ndecided to play with them. Let\u2019s call vertex if there is a vertex in\r\nsubtree of vertex such that , where is the number written on vertex , is\r\nthe sum of the numbers written on the edges on the path from to . of a\r\ntree are vertices connected to a single vertex by a single edge, but the\r\nroot of a tree is a if and only if the tree consists of a single vertex\r\nroot.Thus Alyona decided to remove some of tree leaves until there will\r\nbe no any sad vertex left in the tree. What is the minimum number of\r\nleaves Alyona needs to remove?\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxm = 1e5+10;\nstruct self\n{\n\tint x,y,w,nxt;\n}s[maxm*2];\nint fst[maxm];\nint son[maxm];\nlong long dep[maxm];\nlong long maxdep[maxm];\nlong long sad[maxm];\nint flag[maxm];\nint m,n,x,y,w;\nint ans;\nint f[maxm];\n\nvoid dfs(int u,int fa)\n{\n\tf[u]=fa;\n\t//cout<<\"dfs \"<<u<<\" fa=\"<<f[u]<<endl;\n\tfor(int e=fst[u];e!=-1;e=s[e].nxt)\n\t{\n\t\tint v=s[e].y;\n\t\tif(v!=fa)\n\t\t{\n\t\t\tdep[v]=dep[u]+(long long)s[e].w;\n\t\t\tmaxdep[v]=max(maxdep[u]+(long long)s[e].w,(long long)s[e].w);\n\t\t\tmaxdep[v]=max(maxdep[v],0LL);\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nvoid remove(int u)\n{\n\tflag[u]=1;\n\tans++;\n\tfor(int e=fst[u];e!=-1;e=s[e].nxt)\n\t{\n\t\tint v=s[e].y;\n\t\tif(v!=f[u] && !flag[v])\n\t\t{\n\t\t\tremove(v);\n\t\t}\n\t}\n}\n\nvoid add(int x,int y,int w)\n{\n\tn++;s[n].x=x;s[n].y=y;s[n].w=w;\n\ts[n].nxt=fst[x];fst[x]=n;\n}\nint main()\n{\n\tscanf(\"%d\",&m);\n\tmemset(fst,-1,sizeof(fst));\n\tfor(int i=1;i<=m;i++)scanf(\"%I64d\",&sad[i]);\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&y,&w);\n\t\tadd(i+1,y,w);\n\t\tadd(y,i+1,w);\n\t}\n\tdfs(1,1);\n\t//cout<<\"ok\"<<endl;\n\tfor(int i=1;i<=m;i++)\n\t\tif(sad[i]<maxdep[i] && !flag[i])\n\t\t{\n\t\t\t//cout<<\"sad[\"<<i<<\"]=\"<<sad[i]<<\" maxdep=\"<<maxdep[i]<<endl;\n\t\t\tremove(i);\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "trees"], "dificulty": "1600", "interactive": false}