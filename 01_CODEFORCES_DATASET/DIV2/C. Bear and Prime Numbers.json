{
    "link": "https://codeforces.com//contest/385/problem/C",
    "problemId": "5933",
    "problem_idx": "C",
    "shortId": "385C",
    "contest_number": "385",
    "problem_submissions": {
        "E": [
            5794434,
            5800310,
            5798100,
            12839340,
            5793580,
            5807353,
            5798624,
            5795785
        ],
        "D": [
            5791982,
            5791338,
            5792966,
            5793920,
            5795427,
            5791662,
            5796473,
            5796329,
            5793942
        ],
        "C": [
            5788908,
            5788383,
            5788712,
            5790434,
            5789032,
            5794132,
            5791478,
            5792236,
            5791660,
            5800872,
            5791637,
            5790324,
            5790844,
            5792509,
            5789960,
            5787897,
            5791710,
            5799045
        ],
        "B": [
            5786803,
            5786394,
            5787527,
            5788072,
            5786967,
            5787817,
            5788240,
            5790217,
            5789128,
            5788273,
            5787714,
            5788006,
            5786982,
            5787829,
            5787905,
            5791193,
            5786254,
            5787251,
            5788615
        ],
        "A": [
            5786226,
            5789111,
            5786358,
            5786644,
            5786233,
            5788977,
            5786318,
            5787575,
            5786766,
            5786887,
            5786239,
            5786463,
            5786289,
            5786726,
            5786980,
            5790591,
            5788602,
            5792556,
            5787159
        ]
    },
    "name": "C. Bear and Prime Numbers",
    "statement": "Recently, the bear started studying data structures and faced the\r\nfollowing problem.You are given a sequence of integers of length and\r\nqueries, each of them is characterized by two integers . Let\u2019s introduce\r\nto represent the number of such indexes , that is divisible by . The\r\nanswer to the query is the sum: , where is a set of prime numbers from\r\nsegment (both borders are included in the segment).Help the bear cope\r\nwith the problem.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxX = 10000000, kMaxP = 664579;\nint n, pr[kMaxP + 1];\nbool not_pr[kMaxX + 1];\nint sum[kMaxX + 1];\n\nvoid init() {\n    for (int i = 2; i <= kMaxX; ++ i) {\n        if (!not_pr[i]) pr[++ pr[0]] = i;\n        for (int j = 1, k; j <= pr[0] && (k = pr[j] * i) <= kMaxX; ++ j) {\n            not_pr[k] = true;\n            if (i % pr[j] == 0) break;\n        }\n    }\n}\n\nint main() {\n    init();\n    scanf(\"%d\", &n);\n    for (int x; n --; ) {\n        scanf(\"%d\", &x);\n        for (int i = 1; pr[i] * pr[i] <= x; ++ i)\n            if (x % pr[i] == 0) {\n                ++ sum[pr[i]];\n                while (x % pr[i] == 0) x /= pr[i];\n            }\n        if (x != 1) ++ sum[x];\n    }\n    for (int i = 3; i <= kMaxX; ++ i) sum[i] += sum[i - 1];\n    scanf(\"%d\", &n);\n    for (int l, r; n --; ) {\n        scanf(\"%d%d\", &l, &r);\n        l = min(l, kMaxX);\n        r = min(r, kMaxX);\n        printf(\"%d\\n\", sum[r] - sum[l - 1]);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bear and Prime Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/10514",
    "editorial": "In order to solve given problem, contestant should solve several\r\nsubproblems : 1) First one is to compute amount of entries of each\r\nnatural number between and in given list. This subproblem can be solved\r\nby creating array of elements and increasing corresponding element when\r\nscanning input. 2) Second one is to compute . First of all, we need to\r\nfind all primes less than and then for each prime compute . How to\r\ncompute ? We should sum ,,,,... How to compute ? We should sum ,,,,...\r\nHow to compute ? We should sum ,,,,... It can be seen that given algo is\r\nvery similar to Sieve of Eratosthenes. (Info here\r\nhttp://e-maxx.ru/algo/eratosthenes_sieve) So we can use this algo if we\r\nchange it a little bit. Also, we will store results of calculation in\r\narray, e.g. . Namely, = . 3) Now we can calculate partial sums of array.\r\nIt can be made in a single pass just adding to . 4) If we know partial\r\nsums of array then we can calculate sum of array elements between and in\r\ntime proportional , just calculate . 5) Now we can read queries and\r\nimmediately response to them. You shouldn\u00e2\u0080\u0099t forget that right boundaries\r\nof intervals can be greater than , so you can always decrease it to ,\r\nbecause all numbers in given list are less than .\r\n"
}