{"link": "https://codeforces.com//contest/474/problem/D", "problemId": "14848", "problem_idx": "D", "shortId": "474D", "contest_number": "474", "problem_submissions": {"F": [8116116, 8111347, 8114247, 8117109, 8119759, 8119274, 8115617, 8117848, 8117464, 8117692, 8128068, 8128022, 8117327, 8118237, 8119671, 8142598, 8120637, 8119403, 8120748, 8142553, 8142542, 8142530, 8124718], "E": [8115184, 8114217, 8112389, 8114867, 8116240, 8115244, 8120717, 8120099, 8115954, 8123772, 8128154, 8128134, 8116067, 8117086, 8119886, 8115878, 8118972, 8118469, 8118934, 8119664, 8118899, 8119466], "C": [8112567, 8114486, 8117872, 8117009, 8121035, 8124320, 8113338, 8116442, 8121988, 8120682, 8122009, 8128422, 8130552, 8113770, 8117339, 8116750], "D": [8110246, 8110989, 8115114, 8112497, 8111050, 8112447, 8109737, 8115431, 8111354, 8111585, 8113528, 8114235, 8114084, 8108822, 8113696, 8116276, 8114733, 8114795, 8112957, 8112642], "B": [8108782, 8109337, 8115774, 8108967, 8110289, 8109920, 8110734, 8108738, 8109834, 8112357, 8109436, 8112150, 8112245, 8109821, 8112135, 8108859, 8109140, 8108856, 8110418, 8108483], "A": [8107723, 8108745, 8116336, 8108373, 8107695, 8108517, 8107682, 8107784, 8107553, 8108585, 8107565, 8112928, 8110053, 8110849, 8110377, 8107596, 8107999, 8107713, 8108893, 8107595]}, "name": "D. Flowers", "statement": "We saw the little game Marmot made for Mole\u2019s lunch. Now it\u2019s Marmot\u2019s\r\ndinner time and, as we all know, Marmot eats flowers. At every dinner he\r\neats some red and white flowers. Therefore a dinner can be represented\r\nas a sequence of several flowers, some of them white and some of them\r\nred.But, for a dinner to be tasty, there is a rule: Marmot wants to eat\r\nwhite flowers only in groups of size .Now Marmot wonders in how many\r\nways he can eat between and flowers. As the number of ways could be very\r\nlarge, print it modulo ().\r\n", "solutions": ["#include <cstdio>\n\nconst int kMaxN = 100000;\nconst int kMod = 1000000007;\nint t, k;\nint f[kMaxN + 1], s[kMaxN + 1];\n\n#define UPT(x, y) { \\\n    (x) += (y); \\\n    if ((x) >= kMod) (x) -= kMod; \\\n}\n\nint main() {\n    scanf(\"%d%d\", &t, &k);\n    f[0] = 1;\n    for (int i = 0; i < kMaxN; ++ i) {\n        UPT(f[i + 1], f[i]);\n        if (i + k <= kMaxN) {\n            UPT(f[i + k], f[i]);\n        }\n    }\n    for (int i = 1; i <= kMaxN; ++ i) {\n        s[i] = s[i - 1];\n        UPT(s[i], f[i]);\n    }\n    for (int a, b; t --; ) {\n        scanf(\"%d%d\", &a, &b);\n        int res = s[b] - s[a - 1];\n        if (res < 0) res += kMod;\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "1700", "interactive": false}