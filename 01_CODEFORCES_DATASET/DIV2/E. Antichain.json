{"link": "https://codeforces.com//contest/353/problem/E", "problemId": "3647", "problem_idx": "E", "shortId": "353E", "contest_number": "353", "problem_submissions": {"E": [4734608, 4735346, 4733123, 4737143, 4736547, 4742461, 4742408], "D": [4732406, 4731843, 4732120, 4730587, 4734474, 4733362, 4732298, 4733722, 4732919, 4733388, 4737051, 4734992, 4735113, 4734496, 4731987, 4733739], "B": [4730384, 4730404, 4729843, 4733146, 4728118, 4733276, 4731155, 4728754, 4730614, 4729913, 4731086, 4732452, 4732464, 4729592, 4732612, 4730638, 4733247, 4732145], "C": [4727160, 4729197, 4728938, 4728842, 4730078, 4728441, 4729412, 4730353, 4729606, 4731302, 4728675, 4728539, 4728797, 4730952, 4729543, 4729905, 4733939, 4730129], "A": [4726296, 4726231, 4726277, 4727313, 4726417, 4726322, 4726817, 4726268, 4726421, 4726333, 4726847, 4726895, 4726809, 4726263, 4728018, 4726437, 4734686, 4726429]}, "name": "E. Antichain", "statement": "You have a directed acyclic graph , consisting of vertexes, numbered\r\nfrom to . The graph contains edges numbered from to . An edge with\r\nnumber connects vertexes and , and it can be directed in either\r\ndirection (from to , or vise versa).Operation means taking the remainder\r\nafter dividing number by number .Let\u2019s call two vertexes and in graph\r\ncomparable if the graph contains a path either from to or from to .\r\nWe\u2019ll assume that an antichain is a set of vertexes of graph , where any\r\ntwo distinct vertexes are not comparable. The size of an antichain is\r\nthe number of vertexes in the corresponding set. An antichain is maximum\r\nif the graph doesn\u2019t have antichains of a larger size.Your task is to\r\nfind the size of the maximum antichain in graph .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n    cin.sync_with_stdio(0);\n    string s; cin >> s;\n    int N =s.length();\n\n    vector<int> cons;\n    for(int i =0; i < N; i++) if(s[N-1] != s[i]) {\n        for(int j =0; j < i; j++) s +=s[j];\n        int a =0, b =i;\n        for(int j =i; j < s.length(); j++) {\n            if(s[j] == s[b]) a++;\n            else {\n                cons.push_back(a+1);\n                a =1;\n                b =j;}}\n        if(a > 0) cons.push_back(a+1);\n        break;}\n    \n    int ans =0;\n    N =cons.size();\n//  for(int j =0; j < N; j++) cout << cons[j] << \"\\n\";\n    for(int j =0; j < N; j++) if(cons[j] > 2) {\n        ans++;\n        cons[j] =0;}\n    \n    for(int j =0; j < N; j++) if(cons[j] == 0) {\n        int i =j+1; if(i >= N) i =0;\n        if(cons[i] == 0) continue;\n        int a =0;\n        while(i != j) {\n            if(cons[i] == 0) break;\n            a++;\n            i++; if(i == N) i =0;}\n        ans +=a/2;}\n    if(ans == 0) ans =cons.size()/2;\n    cout << ans << \"\\n\";\n    return 0;}\n"], "input": "", "output": "", "tags": ["dp", "graph matchings", "greedy"], "dificulty": "2200", "interactive": false}