{
    "link": "https://codeforces.com//contest/2040/problem/C",
    "problemId": "3075497",
    "problem_idx": "C",
    "shortId": "2040C",
    "contest_number": "2040",
    "problem_submissions": {
        "E": [
            295634858,
            295598220,
            295603659,
            295602852,
            295609062,
            295608956,
            295609438,
            295613265,
            295617536,
            295622256,
            295615426,
            295623087,
            295613034,
            295632243,
            295615757,
            295623729,
            295822197,
            295614576,
            295629623,
            295677087,
            295677053,
            295616459,
            295615739
        ],
        "F": [
            295625297,
            295602948,
            295765575,
            295764437,
            295628810,
            295613638,
            295772184
        ],
        "C": [
            295613817,
            295578002,
            295582361,
            295582510,
            295585319,
            295585121,
            295589541,
            295584238,
            295583765,
            295584198,
            295582424,
            295585127,
            295590138,
            295581996,
            295587456,
            295580712,
            295586116,
            295581622,
            295590178,
            295583863
        ],
        "D": [
            295602955,
            295588244,
            295593423,
            295591690,
            295596226,
            295661257,
            295596632,
            295595711,
            295594858,
            295602270,
            295597697,
            295602059,
            295598368,
            295600419,
            295605426,
            295590011,
            295601199,
            295607620
        ],
        "B": [
            295586789,
            295590381,
            295574073,
            295576257,
            295574329,
            295574189,
            295580781,
            295572257,
            295573109,
            295573299,
            295575453,
            295572099,
            295577165,
            295593436,
            295571846,
            295572279,
            295571755,
            295574449,
            295577717,
            295572094
        ],
        "A": [
            295581636,
            295569030,
            295573127,
            295568276,
            295571294,
            295574905,
            295568027,
            295568114,
            295567840,
            295567999,
            295568293,
            295568412,
            295569901,
            295568913,
            295567935,
            295568054,
            295568783,
            295570941,
            295568578
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137074",
    "editorial": "These permutations are generated as follows. We will greedily go through\r\nthe numbers in order from to , and we will put each one either in the\r\nfirst free cell or in the last one. For example, if we want to put in\r\nthe permutation , we can put it either in the third cell or in the\r\nsecond from the end. That is, the permutation first increases and then\r\ndecreases.We can prove that the greedy algorithm works like this. Let us\r\nnow want to put the number . When we put this number, we can immediately\r\nsay that the minimum on the segments, one of the ends of which is the\r\nchosen position, is equal to (we do not take into account already placed\r\nnumbers smaller than ). The number of these segments is equal to . The\r\nanswer we get is equal to the sum of this fixed number and what we get\r\nin the future. Assume we put the number not at the end of the array.\r\nLet\u00e2\u0080\u0099s consider the optimal further answer: . Now let\u00e2\u0080\u0099s put at the end of\r\nthe array and leave the order of the following elements unchanged. All\r\nsegments whose ends lie on elements that are larger than may no longer\r\ncover the number , but the sets of numbers larger than that they cover\r\nhave not changed. So the answer got better.Since we choose one of the\r\nends independently, there are of such permutations, and we can find the\r\n-th one using a simple loop, similar to converting a number into binary\r\nnotation.\r\n",
    "name": "C. Ordered Permutations",
    "statement": "Consider a permutation^{\r\ntext{ }} p_1, p_2,\r\nldots, p_n of integers from 1 to n. We can introduce the following sum\r\nfor it^{\r\ntext{ }}:S(p) =\r\nsum_{1\r\nle l\r\nle r\r\nle n}\r\nmin(p_l, p_{l + 1},\r\nldots, p_r)Let us consider all permutations of length n with the maximum\r\npossible value of S(p). Output the k-th of them in lexicographical^{\r\ntext{ }}order, or report that there are less than k of them.^{\r\ntext{ }}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray). ^{\r\ntext{ }}For example: For the permutation [1, 2, 3] the value of S(p) is\r\nequal to\r\nmin(1) +\r\nmin(1, 2) +\r\nmin(1, 2, 3) +\r\nmin(2) +\r\nmin(2, 3) +\r\nmin(3) = 1 + 1 + 1 + 2 + 2 + 3 = 10 For the permutation [2, 4, 1, 3] the\r\nvalue of S(p) is equal to\r\nmin(2) +\r\nmin(2, 4) +\r\nmin(2, 4, 1) +\r\nmin(2, 4, 1, 3)\r\n+\r\nmin(4) +\r\nmin(4, 1) +\r\nmin(4, 1, 3)\r\n+\r\nmin(1) +\r\nmin(1, 3)\r\n+\r\nmin(3) = 2 + 2 + 1 + 1 + 4 + 1 + 1 + 1 + 1 + 3 = 17. ^{\r\ntext{ }}An array a is lexicographically smaller than an array b if and\r\nonly if one of the following holds: a is a prefix of b, but a\r\nne b; or in the first position where a and b differ, the array a has a\r\nsmaller element than the corresponding element in b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>;\u00a0constexpr int MOD = 1000000007;constexpr int INF = 1000000000;constexpr ll LINF = 1000000000000000000LL;constexpr ld EPS = 1e-9;\u00a0#define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define pb push_back#define eb emplace_back#define fi first#define se second#define sz(x) ((int)(x).size())#define dbg(x) cerr << #x << \" = \" << (x) << '\\n'\u00a0void solve() {    unsigned long long n,k;    cin>>n>>k;    static unsigned long long dp[200000+5];    dp[1]=1;    for(unsigned long long i=2;i<=n;i++){        dp[i]=2ULL*dp[i-1];        if(dp[i]>k) dp[i]=1000000000000000009ULL;    }    if(dp[n]<k){        cout<<\"-1\\n\";        return;    }    static unsigned long long v[200000+5];    unsigned long long ps=1, pd=n;    for(unsigned long long i=1;i<=n;i++){        if(dp[n-i]>=k){            v[ps++]=i;        } else {            k-=dp[n-i];            v[pd--]=i;        }    }    for(unsigned long long i=1;i<=n;i++)        cout<<v[i]<<\" \";    cout<<\"\\n\";}\u00a0int main() {    fast_io();    int t = 1;    cin >> t;    while (t--) solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "math",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Ordered Permutations.json"
}