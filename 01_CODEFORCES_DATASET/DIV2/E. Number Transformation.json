{"link": "https://codeforces.com//contest/252/problem/E", "problemId": "2354", "problem_idx": "E", "shortId": "252E", "contest_number": "252", "problem_submissions": {"B": [2710060, 2706628, 2708313, 2705063, 2702778, 2703423, 2715482, 2706557, 2703833, 2705102], "D": [2707052, 2709984, 2706767, 2709595, 2711529, 2710054, 2708487, 2707438, 2708692, 2709215, 2706501, 2709216], "C": [2702661, 2701836, 2705668, 2703665, 2707566, 2704785, 2705259, 2705065, 2702929, 2704890, 2702757, 2705646, 2704360, 2708601, 2705908, 2703255, 2704699, 2702535], "A": [2701161, 2709874, 2701848, 2700918, 2701349, 2700912, 2701131, 2701230, 2700948, 2701753, 2703055, 2700974, 2713381, 2703052, 2702820, 2702346, 2700994, 2701240, 2701290], "E": [2709470, 2708307]}, "name": "E. Number Transformation", "statement": "Little Petya likes positive integers a lot. Recently his mom has\r\npresented him a positive integer . There\u2019s only one thing Petya likes\r\nmore than numbers: playing with little Masha. It turned out that Masha\r\nalready has a positive integer . Petya decided to turn his number into\r\nthe number consecutively performing the operations of the following two\r\ntypes: Subtract 1 from his number. Choose any integer from to ,\r\ninclusive. Then subtract number from his number . Operation means taking\r\nthe remainder from division of number by number . Petya performs one\r\noperation per second. Each time he chooses an operation to perform\r\nduring the current move, no matter what kind of operations he has\r\nperformed by that moment. In particular, this implies that he can\r\nperform the same operation any number of times in a row.Now he wonders\r\nin what minimum number of seconds he could transform his number into\r\nnumber . Please note that numbers in the operations of the second type\r\nare selected anew each time, independently of each other.\r\n", "solutions": ["#define LOCAL\n\n/** ` Micro Mezzo Macro Flation -- Overheated Economy ., Ver 0.1 **/\n\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (n____=int(n),i=0;i<n____;++i)\n#define FOR_C_N(i, a, b) for (b____=int(b),i=a;i<b____;++i)\n#define DWN_C_N(i, b, a) for (a____=int(a),i=b-1;i>=a____;--i)\n#define REP_1_C_N(i, n) for (n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (a____=int(a),i=b;i>=a____;--i)\n\n//#define ECH(it, A) for (typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define REP_S(it, str) for (char*it=str;*it;++it)\n#define REP_G(it, u) for (int it=hd[u];it;it=suc[it])\n#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, X) find(ALL(A), X) // != A.end()\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define fi first\n#define se second\n\n#define Rush int T____; RD(T____); DO(T____)\n\n#define Display(A, n, m) {                      \\\n\tREP(i, n){\t\t                            \\\n        REP(j, m) cout << A[i][j] << \" \";       \\\n        cout << endl;\t\t\t\t            \\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#define Display_1(A, n, m) {\t\t\t\t    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m) cout << A[i][j] << \" \";     \\\n\t\tcout << endl;\t\t            \t\t\\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define Ruby system(\"ruby main.rb\")\n#define Haskell system(\"runghc main.hs\")\n#define Python system(\"python main.py\")\n#define Pascal system(\"fpc main.pas\")\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VD;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef set<LL> SL;\ntypedef set<DB> SD;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef map<LL, int> MLI;\ntypedef map<DB, int> MDI;\ntypedef pair<int, int> PII;\ntypedef pair<int, bool> PIB;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\ninline LL RD(){LL x; return RD(x);}\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\ninline DB& RF(DB &x){scanf(\"%lf\", &x); return x;}\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s){scanf(\"%s\", s); return s;}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(T &A){A.clear();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\n\n/** Add - On **/\n\nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\n\nconst int dx8[] = {-1, 0, 1, 0 , -1 , -1 , 1 , 1};\nconst int dy8[] = {0, 1, 0, -1 , -1 , 1 , -1 , 1};\n\nconst int MOD = 1000000007;\n//int MOD = 99990001;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 1LL << 60;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = acos(-1.0); //M_PI;\n\n// <<= ` 0. Daily Use .,\n\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (a<b) a=b;}\ntemplate<class T> inline void checkMin(T &a, T &b, const T x){checkMin(a, x), checkMin(b, x);}\ntemplate<class T> inline void checkMax(T &a, T &b, const T x){checkMax(a, x), checkMax(b, x);}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ninline int Ceil(int x, int y){return (x - 1) / y + 1;}\n\n// <<= ` 1. Bitwise Operation .,\n\nnamespace BO{\n\ninline bool _1(int x, int i){return bool(x&1<<i);}\ninline bool _1(LL x, int i){return bool(x&1LL<<i);}\ninline LL _1(int i){return 1LL<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n\ninline int reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\ninline LL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\ntemplate<class T> inline bool odd(T x){return x&1;}\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\ntemplate<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\ntemplate<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\ninline int low_idx(int x){return __builtin_ffs(x);}\ninline int low_idx(LL x){return __builtin_ffsll(x);}\ninline int high_idx(int x){return low_idx(reverse_bits(x));}\ninline int high_idx(LL x){return low_idx(reverse_bits(x));}\ninline int clz(int x){return __builtin_clz(x);}\ninline int clz(LL x){return __builtin_clzll(x);}\ninline int ctz(int x){return __builtin_ctz(x);}\ninline int ctz(LL x){return __builtin_ctzll(x);}\ninline int parity(int x){return __builtin_parity(x);}\ninline int parity(LL x){return __builtin_parityll(x);}\ninline int lg2(int a){return 31 - __builtin_clz(a);}\ninline int count_bits(int x){return __builtin_popcount(x);}\ninline int count_bits(LL x){return __builtin_popcountll(x);}\n\n} using namespace BO;\n\n\n// <<= ` 2. Number theory .,\n\nnamespace NT{\n\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\n\ninline int pow(int a, LL b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T> inline T pow(T a, LL b){\n    T c(1); while (b){\n        if (b&1) c *= a;\n        a *= a, b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIA(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\n\ninline int phi(int n){\n    int res = n; for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\ntemplate <class T>\nT GCD(T a, T b)\n{\n    return b ? GCD(b, a % b) : a;\n}\ntemplate <class T>\nT extendGCD(T a, T b, T& x, T& y)\n{\n    if(!b) return x = 1, y = 0, a;\n    T res = extendGCD(b, a % b, x, y), tmp = x;\n    x = y, y = tmp - (a / b) * y;\n    return res;\n}\ntemplate <class T>\ninline T inv(T w , T M){\n    if (M <= 0) return -1;\n    T x , y , d;\n    d = extendGCD(w , M , x , y);\n    if (d != 1) return -1;\n    x = ((x % M) + M) % M;\n    return x;\n}\n} using namespace NT;\n\n// <<= ' A. Random Event ..\n\nnamespace RNG{\n//srand((unsigned)time(NULL));\ninline unsigned int rand16(){return (bool(rand()&1) << 15) | rand();}\ninline unsigned int rand32(){return (rand16() << 16) | rand16();}\ninline ULL rand64(){return ((LL)rand32() << 32) | rand32();}\ninline ULL random(LL l, LL r){return rand64() % (r - l) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return bool(rand() % 2);}\n} using namespace RNG;\n\n// <<= ' B. Clock\n\nnamespace CLOCK{\nDB s0, s1, rd, k, T;\ninline DB getTime(){\n#ifdef LOCAL\n    return 1.0 * clock() / CLOCKS_PER_SEC;\n#else\n    timeval tv;\n    gettimeofday(&tv, 0);\n    return tv.tv_sec + tv.tv_usec * 1e-6;\n#endif\n}\n\ninline void st0(DB _T = 0.98){T = _T, s0 = getTime();}\ninline void st1(DB _k = 1.618){k = _k, s1 = getTime();}\ninline void ed1(){rd = getTime() - s1;}\ninline DB elapsed(){return getTime() - s0;}\ninline bool safe(){return elapsed() + rd * k < T;}\n} //using namespace CLOCK;\n\n// <<= ' C. Temp .. .\n\ntemplate<class T> PTT operator+(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi + p2.fi, p1.se + p2.se);\n}\n\ntemplate<class T> PTT operator-(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi - p2.fi, p1.se - p2.se);\n}\n\ntemplate<class T> PTT operator*(const PTT &lhs, T k){\n    return PTT(lhs.fi * k, lhs.se * k);\n}\n\n// <<= ' 0. I/O Accelerator interface .,\n\ntemplate<class T> inline T& RD(T &x){\n    //cin >> x;\n    //scanf(\"%d\", &x);\n    char c; for (c = getchar(); c < '0'; c = getchar()); x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';\n    //char c; c = getchar(); x = c - '0'; for (c = getchar(); c >= '0'; c = getchar()) x = x * 10 + c - '0';\n    return x;\n}\n\nint ____Case; template<class T> inline void OT(const T &x){\n    //if (x == -1) printf(\"Case %d: NO\\n\", ++____Case);\n    //else printf(\"Case %d: %d\\n\", ++____Case, x);\n    //printf(\"%I64d\\n\", x);\n    //printf(\"%.2lf\\n\", x);\n    cout << x << endl;\n    //cout << x << endl;\n}\n\n/* .................................................................................................................................. */\n\n\n\n/* .................................................................................................................................. */\n\n//const int L = 10000 * 10;\n\nconst int L = 360360, N = 100009;\n\nint __lcm(int a, int b){\n    return a*b/__gcd(a,b);\n}\n\nLL a, b, k; int aa, bb, lcm;\nVI adj[L];\n\n//int DD[L];\n\n\nint D[3*L];\n\ninline int f(int s, int t){\n    //if (t <= s) t += lcm;\n    //t += lcm;\n    return D[t];\n}\n\nvoid bfs(){\n\n    int s = aa; FLC(D, 0x3f); D[0] = 0;\n\n    REP(i, 3 * lcm){\n\n        int u = (s - i) % lcm; if (u < 0) u += lcm;\n\n        int Du = D[i];\n\n        if (Du == INF) continue;\n\n        REP(ii, SZ(adj[u])){\n            checkMin(D[i + adj[u][ii]], Du + 1);\n        }\n    }\n\n    /*REP(i, 3 * lcm)\n        cout << D[i] << \" \";\n    cout << endl;*/\n\n}\n\n\nint main(){\n\n\n    RD(a, b, k);\n\n    lcm = 1; FOR_1(i, 2, k){\n        lcm = __lcm(lcm, i);\n    }\n\n    REP(i, lcm){\n        adj[i].PB(1);\n        FOR_1(j, 2, k) if (i % j) adj[i].PB(i % j);\n    }\n\n    LL tt = (a - b) / lcm;\n\n\n    aa = a % lcm, bb = b % lcm;\n\n    LL step = INF; int h;\n\n    bfs();\n\n\n\n//    if (h > a) --tt;\n  //  if (b > h) --tt;\n\n    //OT( f(aa, h) + step * tt + f(h, bb));*/\n\n    //int t = ((b - a) % lcm + lcm) % lcm;\n\n    //cout << (aa - bb + lcm ) % lcm << endl;\n    bb = (aa - bb + 3 * lcm) % lcm;\n\n    tt *= (LL) (D[bb+lcm] - D[bb]);\n\n    OT(D[bb] + tt);\n}\n\n\n"], "input": "", "output": "", "tags": ["dp", "number theory"], "dificulty": "2000", "interactive": false}