{
    "link": "https://codeforces.com//contest/1802/problem/G",
    "problemId": "1817560",
    "problem_idx": "G",
    "shortId": "1802G",
    "contest_number": "1802",
    "problem_submissions": {
        "F": [
            196663888,
            196625008,
            196625749,
            196635602,
            196634743,
            196643091,
            196651329,
            196656599,
            196633915,
            196648089,
            196652202,
            196632881,
            196638320,
            196651695,
            196637871,
            196638608,
            196644590,
            196711680
        ],
        "G": [
            196633429,
            196750849
        ],
        "A": [
            196608625,
            196601765,
            196601430,
            196604403,
            196601551,
            196601415,
            196601637,
            196621554,
            197609656,
            196604338,
            196602290,
            196601755,
            196624562,
            196602593,
            196601829,
            196602885,
            196603556,
            196602800,
            196601750,
            196602859,
            196601468
        ],
        "C": [
            196603858,
            196634826,
            196613689,
            196616450,
            196615629,
            196606590,
            196615213,
            196643285,
            196614451,
            196642605,
            196612216,
            196636938,
            196666118,
            196610483,
            196616792,
            196626477,
            196610562,
            196619309,
            196615002,
            196608792
        ],
        "D": [
            196603459,
            196611669,
            196611547,
            196620657,
            196623482,
            196612856,
            196623750,
            196629627,
            197067794,
            196623474,
            196620294,
            196724558,
            196619887,
            196617809,
            196618077,
            196620127,
            196622956,
            196623094,
            196616226
        ],
        "B": [
            196601817,
            196604589,
            196605912,
            196607950,
            196604989,
            196602908,
            196605368,
            196624195,
            197609716,
            196611451,
            196608455,
            196605092,
            196630916,
            196608589,
            196607012,
            196607509,
            196609282,
            196615569,
            196605751,
            196607659,
            196606374
        ],
        "E": [
            196616155,
            196623146,
            196626388,
            196631009,
            196622442,
            196634549,
            196631368,
            196632011,
            196635287,
            196622016,
            196653867,
            196631106,
            196668550,
            196632178,
            196624422,
            196629837,
            196626927,
            196632190,
            196635404
        ]
    },
    "name": "G. Gasoline prices",
    "statement": "Berland is a huge country consisting of n cities. The road network of\r\nBerland can be represented as a root tree, that is, there is only n - 1\r\nroad in the country, and you can get from any city to any other exactly\r\none way, if you do not visit any city twice. For the convenience of\r\nrepresenting the country, for each city i, the city p_i is fixed, equal\r\nto the first city to which you need to go from the city i to get to the\r\ncity 1. In other words, the city p_i is equal to the ancestor of the\r\ncity i if the tree is hung for the city 1.There is one gas station in\r\neach city of Berland. Gas stations have special pricing, and for each\r\ngas station there is a fixed range of prices for which they are ready to\r\nsell gasoline. A gas station in the city with the number i is ready to\r\nsell gasoline at any price from l_i to r_i inclusive.The King of Berland\r\nis an exemplary family man, and for m years, two sons were born to him\r\nevery year. The king\u2019s children have been involved in public affairs\r\nsince early childhood, and at the end of each year they check the\r\nhonesty of gasoline prices. From birth, the king\u2019s children, who are\r\nborn in the year i, are responsible for checking gasoline prices on the\r\nways from the city of a_i to the city of b_i and from the city of c_i to\r\nthe city of d_i, respectively.The check is as follows: both children\r\nsimultaneously start their journey from the cities a_i and c_i,\r\nrespectively. The first son of the king, born in the year i, moves along\r\nthe path from the city a_i to the city b_i, and the second from the city\r\nc_i to the city d_i. Children check that the price of gasoline in the\r\ncity of a_i coincides with the price of gasoline in the city of c_i.\r\nNext, they check that the price of gasoline in the second city on the\r\nway from a_i to b_i coincides with the price in the second city on the\r\nway from c_i to d_i. Then they repeat the same thing for a couple of\r\nthird cities on their paths and so on. At the end, they check that the\r\nprice of gasoline in the city of b_i coincides with the price of\r\ngasoline in the city of d_i. It is guaranteed that the length of the\r\npath from the city a_i to the city b_i coincides with the length of the\r\npath from the city c_i to the city d_i.Gas stations must strictly obey\r\nthe laws, and therefore all checks of gasoline prices should not reveal\r\nviolations. Help Berland gas stations find out how many ways they can\r\nset gasoline prices for m years. In other words, for each i from 1 to m,\r\ncalculate how many ways you can set gasoline prices at all gas stations\r\nso that after the birth of the first i pairs of the king\u2019s children, all\r\ntheir checks did not reveal violations, and at any gas station the price\r\nwas in the acceptable price range. Since the number of such methods can\r\nbe large, calculate the answer modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntemplate <typename T> inline void read(T &F) {\n    int R = 1; F = 0; char CH = getchar();\n    for(; !isdigit(CH); CH = getchar()) if(CH == '-') R = -1;\n    for(; isdigit(CH); CH = getchar()) F = F * 10 + CH - 48;\n    F *= R;\n}\nconst LL mod = 1e9 + 7;\nconst int N = 4e5 + 10, Log = 20;\nint n, m, fa[Log][N], L[N], R[N], cnt[N], a[N], b[N], tr[N]; LL ans = 1;\nint get_fa(int k, int x) {\n    return fa[k][x] == x ? x : fa[k][x] = get_fa(k, fa[k][x]); \n}\nLL Qpow(LL x, LL k) {\n    if(k <= 1) return k ? x : 1;\n    LL h = Qpow(x, k / 2); h = h * h % mod;\n    return k & 1 ? h * x % mod : h;\n}\n\nLL suan(int x) {\n    return max(R[x] - L[x] + 1, 0);\n}\n\nvoid merge(int x, int y, int k) {\n    const int a = get_fa(k, x), b = get_fa(k, y);\n    if(a == b) return; fa[k][a] = b;\n    if(k == 0) {\n        ans = ans * Qpow(suan(a), mod - 2) % mod * Qpow(suan(b), mod - 2) % mod;\n        cnt[b] += cnt[a]; L[b] = max(L[b], L[a]); R[b] = min(R[b], R[a]);\n        ans = ans * suan(b) % mod;\n        return;\n    }\n    merge(x, y, k - 1), merge(x + (1 << (k - 1)), y + (1 << (k - 1)), k - 1);\n}\nint lg[N];\nvoid merge(int l, int r, int ll, int rr) {\n    const int k = lg[r - l + 1];\n    merge(l, ll, k);\n    merge(r - (1 << k) + 1, rr - (1 << k) + 1, k);\n}\nvoid init() {\n    for(int i = 1; i <= 2 * n; i++)\n        for(int k = 0; k < Log; k++) {\n            fa[k][i] = i;\n            if(k == 0) L[i] = a[tr[i]], R[i] = b[tr[i]], cnt[i] = (i <= n) * 2;\n        }\n    for(int i = n + 1; i <= 2 * n; i++) fa[0][i] = 2 * n - i + 1;\n}\n\nint siz[N], dfn[N], s[N], f[N], tp[N], d, dep[N]; vector<int> edge[N];\nvoid dfs(int x) {\n    siz[x] = 1;\n    for(int i : edge[x]) {\n        f[i] = x; dep[i] = dep[x] + 1;\n        dfs(i);\n        if(siz[i] > siz[s[x]]) s[x] = i;\n        siz[x] += siz[i];\n    }\n}\nvoid solve(int x) {\n    dfn[x] = ++d; tr[d] = tr[2 * n - d + 1] = x;\n    if(s[x]) tp[s[x]] = tp[x], solve(s[x]);\n    for(int i : edge[x])\n        if(i != s[x])\n            tp[i] = i, solve(i);\n}\nvector<pair<int, int> > qry(int x, int y) {\n    int op = 0; vector<pair<int, int> > p[2];\n    while(tp[x] != tp[y]) {\n        if(dep[tp[x]] < dep[tp[y]])\n            swap(x, y), op ^= 1;\n        p[op].emplace_back(dfn[x], dfn[tp[x]]);\n        x = f[tp[x]];\n    }\n    if(dep[x] < dep[y]) swap(x, y), op ^= 1;\n    p[op].emplace_back(dfn[x], dfn[y]);\n    vector<pair<int, int> > tmp;\n    reverse(p[1].begin(), p[1].end());\n    for(auto i : p[0]) tmp.emplace_back(2 * n - i.first + 1, 2 * n - i.second + 1);\n    for(auto i : p[1]) tmp.emplace_back(i.second, i.first);\n    for(auto i : tmp) assert(i.first <= i.second);\n    return tmp;\n}\nvoid calc(vector<pair<int, int> > X, vector<pair<int, int> > Y) {\n    while(!X.empty() && !Y.empty()) {\n        const int la = X.back().second - X.back().first + 1;\n        const int lb = Y.back().second - Y.back().first + 1;\n        const int len = min(la, lb);\n        merge(X.back().second - len + 1, X.back().second, Y.back().second - len + 1, Y.back().second);\n        X.back().second -= len, Y.back().second -= len;\n        if(len == la) X.pop_back();\n        if(len == lb) Y.pop_back();\n    }\n    assert(X.empty() && Y.empty());\n}\nint main() {\n\tread(n); lg[0] = -1;\n    for(int i = 1; i <= 2 * n; i++) lg[i] = lg[i >> 1] + 1;\n    for(int i = 2; i <= n; i++) {\n        read(f[i]); edge[f[i]].emplace_back(i);\n    }\n    for(int i = 1; i <= n; i++) read(a[i]), read(b[i]), ans = ans * (b[i] - a[i] + 1) % mod;\n    tp[1] = 1;\n    dfs(1), solve(1); init();\n    /*\n    auto ttt = qry(4, 3);\n    for(auto i : ttt) cout << i.first << ' ' << i.second << \"??\" << endl;\n    return 0;*/\n\n    read(m);\n    for(int i = 1; i <= m; i++) {\n        int l, r, ll, rr; read(l), read(r), read(ll), read(rr);\n        auto A = qry(l, r), B = qry(ll, rr);\n        calc(A, B);\n        cout << ans << '\\n';\n    }\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Gasoline prices.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "To begin with, let's understand what is required of us. A tree is given, in each vertex of which the price range for this vertex is recorded. A query is a pair of paths of equal length, the prices at the i\n-th vertices along these paths should be equal for all i\n. We need to find the number of ways to place prices at the vertices for each prefix of restrictions\n\nLet's start with a slow solution of the problem. We will store the connectivity components (in each vertex prices should be equal). For each of them, we store an acceptable price range. The answer will be the product of the lengths of the ranges over all components. We will go along the paths and combine 2 vertices into one component using DSU. It is clear that to speed up this solution, it is necessary to search faster for the moments when two vertices are combined into one component.\n\nFirst, let's analyze the long solution. Let's make a heavy-light decomposition, with which we will hash the paths in the tree, taking the root number of its components as a symbol for the vertex. Now, with the help of bin search, we will look for the first moment when the hashes on the path prefixes differ, that is, two vertices are combined into one component. With the help of transfusions, we will update the roots of their components for vertices and the tree of segments for hld. We will get n\n unions, we will find each one for O(log2(n))\n using hld. There will also be O(n?log(n))\n updates in the segment tree due to overflows. For each request there will be O(log2(n))\n from hld. The final asymptotic O((n+q)?log2(n))\n\nNow let's give a beautiful solution to this problem. Let's start with bamboo.\n\nReplace the equality of prices on a pair of paths with two pairs of paths with lengths equal to the maximum power of two, less than the length of the original path (as in sparse table). Now the path lengths of all constraints have become powers of two. We will iterate over the powers of two in descending order 2k\n, for each path of length 2k\n we will get a vertex in the graph, we will also get a vertex for each such path in reverse order. Now the constraints define edges in such a graph. Let's spend them, select the spanning tree. For each edge from the backbone, we divide the constraints into 2 constraints with path lengths half as long and continue the process. On a layer with lengths 1, we will get the spanning tree we need, which will be responsible for the first moments when some pairs of vertices were combined into components. Note that no more than 2n\n edges will be added down from each layer, as well as no more than 2q\n edges from queries. That is, each layer will work for O((n+q)??(n))\n, where ?(n)\n is the average operating time in DSU, the inverse of the Ackerman function. We got the solution in O((n+q)??(n)?log(n))\n\nFor a complete solution on the tree, first we divide a pair of paths into three pairs of corresponding vertical paths (take from the 4 end vertices of these paths the pair of vertices closest to the lca on its path, then we pair this path with a vertical path (part of another path), now we get one vertical path and an arbitrary path in the tree, let's split the second path by lca and the first by the corresponding lengths). Next, we will proceed similarly to bamboo, only the place of the vertex responsible for the segment, we will get the vertex responsible for the binary ascent in the tree to a height equal to the power of two."
}