{
    "link": "https://codeforces.com//contest/2007/problem/E",
    "problemId": "2845544",
    "problem_idx": "E",
    "shortId": "2007E",
    "contest_number": "2007",
    "problem_submissions": {
        "F": [
            278829889,
            278836909,
            278834397,
            278833574,
            278834465,
            278838066,
            278835361,
            278842334,
            278824105,
            278831692,
            278838908,
            278836968,
            278839548,
            278831301,
            278823086,
            278840296,
            278841111,
            278842601
        ],
        "E": [
            278819100,
            278812531,
            278814740,
            278819903,
            278822295,
            278825462,
            278818230,
            278822054,
            278840929,
            278825485,
            278828447,
            278833891,
            278799229,
            278838138,
            278839019,
            278828512,
            278831250,
            278831388,
            278817583,
            278815781
        ],
        "D": [
            278799468,
            278799575,
            278803157,
            278799799,
            278806603,
            278804232,
            278798668,
            278803495,
            278817444,
            278796667,
            278805268,
            278809906,
            278809488,
            278817233,
            278829523,
            278808086,
            278804865,
            278814312,
            278803553,
            278802384
        ],
        "C": [
            278780728,
            278781086,
            278788227,
            278789504,
            278792493,
            278790375,
            278787480,
            278788281,
            278794086,
            278818650,
            278789734,
            278788169,
            278787429,
            278793363,
            278793381,
            278800135,
            278810824,
            278793278,
            278788023,
            278790440
        ],
        "B": [
            278776959,
            278776203,
            278777907,
            278784810,
            278782747,
            278782953,
            278836748,
            278778704,
            278778803,
            278775898,
            278785508,
            278778671,
            278810717,
            278784596,
            278792140,
            278786468,
            278796546,
            278777191,
            278777412,
            278786342
        ],
        "A": [
            278773744,
            278773692,
            278774098,
            278774399,
            278775464,
            278777680,
            278775772,
            278775250,
            278773819,
            278773814,
            278774248,
            278884949,
            278773664,
            278780595,
            278777213,
            278780108,
            278778288,
            278781544,
            278774028,
            278774012,
            278778642
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "The nodes are numbered by dfs order, which tells us the vertex numbers in one subtree are always consecutive. Let's consider an edge connecting vertex i\n and pi\n. Suppose the size of the subtree i\n is si\n, so the vertices are numbered between [i,i+si?1]\n. Then for each j\n that i?j<i+si?1\n, the path between node j\n and j+1\n is always in the subtree, so it doesn't pass the edge. The only two paths that passes edge (i,pi)\n is the path between i?1\n and i\n, and between i+si?1\n and i+si\n.\n\nLet's calculate the maximum value of dist(i,(imodn)+1)\n. First, if all of the weights of its edges have been determined, then it's already calculated. Otherwise, it's optimal to set one of the edges with undetermined weight with weight w?sum of weights of the known edges\n. Then the answer is w?sum of weights of the known edges outside the path\n.\n\nHow to maintain the process? Each time we know the weight of an edge, we specially check whether the weights of the two paths that passes this edge are uniquely determined or not. For all other paths that are not uniquely determined, the contribution of the edge is ?y\n (y\n is the weight). We can use addition tags to handle this.\n\nThe time complexity is O(n)\n.",
    "name": "E. Iris and the Tree",
    "statement": "Given a rooted tree with the root at vertex 1. For any vertex i (1 < i\r\nleq n) in the tree, there is an edge connecting vertices i and p_i (1\r\nleq p_i < i), with a weight equal to t_i.Iris does not know the values\r\nof t_i, but she knows that\r\ndisplaystyle\r\nsum_{i=2}^n t_i = w and each of the t_i is a .The vertices of the tree\r\nare numbered in a special way: the numbers of the vertices in each\r\nsubtree are consecutive integers. In other words, the vertices of the\r\ntree are numbered in the order of a depth-first search. We define\r\noperatorname{dist}(u, v) as the length of the simple path between\r\nvertices u and v in the tree.Next, there will be n - 1 events: Iris is\r\ngiven integers x and y, indicating that t_x = y. After each event, Iris\r\nwants to know the maximum possible value of\r\noperatorname{dist}(i, i\r\nbmod n + 1) for each i (1\r\nle i\r\nle n). She only needs to know the sum of these n values. Please help\r\nIris quickly get the answers.Note that when calculating the maximum\r\npossible values of\r\noperatorname{dist}(i, i\r\nbmod n + 1) and\r\noperatorname{dist}(j, j\r\nbmod n + 1) for i\r\nne j, the unknown edge weights .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; const int maxN = 220000;int fa[maxN], mx[maxN], len[maxN], d[maxN];vector<int> v[maxN];long long sum[maxN]; int main() {\tios::sync_with_stdio(0);\tcin.tie(0); cout.tie(0);\tint T;\tfor (cin >> T; T; T--) {\t\tint n; long long w; cin >> n >> w;\t\tfor (int i = 1; i <= n; i++) {\t\t\tmx[i] = i;\t\t\tv[i].clear();\t\t}\t\tfor (int i = 2; i <= n; i++) {\t\t\tcin >> fa[i];\t\t\tv[fa[i]].push_back(i);\t\t}\t\tfor (int i = 1; i <= n; i++)\t\t\tfor (auto u : v[i])\t\t\t\td[u] = d[i] + 1;\t\tfor (int i = n; i >= 2; i--)\t\t\tmx[fa[i]] = max(mx[fa[i]], mx[i]);\t\tfor (int i = 1; i < n; i++)\t\t\tlen[i] = d[i] + d[i + 1] - 2 * d[fa[i + 1]];\t\tlen[n] = d[n];\t\tint ct = 0;\t\tlong long ans = 0, s = 0, hp = 0;\t\tfor (int i = 1; i < n; i++) {\t\t\tint x; long long y;\t\t\tcin >> x >> y;\t\t\tint p = x - 1, q = mx[x];\t\t\tsum[p] += y, sum[q] += y;\t\t\ts += y;\t\t\thp += 2 * y;\t\t\tlen[p]--, len[q]--;\t\t\tif (!len[p]) {\t\t\t\tans += sum[p];\t\t\t\thp -= sum[p];\t\t\t\tct++;\t\t\t}\t\t\tif (!len[q]) {\t\t\t\tans += sum[q];\t\t\t\thp -= sum[q];\t\t\t\tct++;\t\t\t}\t\t\tcout << ans + (n - ct) * (w - s) + hp << \" \\n\"[i == n - 1];\t\t}\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "math",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Iris and the Tree.json",
    "hint": []
}