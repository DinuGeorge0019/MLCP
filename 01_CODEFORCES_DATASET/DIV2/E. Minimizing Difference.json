{
    "link": "https://codeforces.com//contest/1244/problem/E",
    "problemId": "438884",
    "problem_idx": "E",
    "shortId": "1244E",
    "contest_number": "1244",
    "problem_submissions": {
        "E": [
            62487832,
            62480584,
            62471612,
            62475861,
            62486535,
            62479379,
            62488595,
            62479897,
            62486004,
            62494290,
            62482838,
            62489756,
            62484611,
            62499649,
            62484119,
            62485010,
            62484457,
            62485159,
            62483197
        ],
        "D": [
            62485326,
            62477683,
            62472795,
            62474275,
            62479070,
            62488986,
            62484645,
            62476151,
            62481028,
            62481710,
            62472497,
            62492732,
            62480440,
            62477599,
            62480225,
            62481677,
            62477177,
            62480820,
            62477275
        ],
        "G": [
            62480107,
            62491796,
            62483655,
            62495208,
            62499859,
            62498484,
            62497339,
            62483129,
            62500589,
            62490894,
            62499284,
            62480915,
            62501144,
            62496112,
            62574872,
            62510517
        ],
        "F": [
            62476907,
            62486766,
            62497660,
            62497231,
            62492999,
            62493234,
            62492928,
            62488841,
            62496876,
            62489625,
            62495061,
            62486153,
            62494792,
            62489424,
            62493134,
            62492962,
            62496077,
            62497856,
            62496551
        ],
        "C": [
            62471680,
            62473970,
            62477877,
            62474334,
            62473816,
            62473208,
            62512963,
            62473668,
            62477041,
            62495125,
            62513108,
            62474572,
            62476360,
            62471677,
            62473875,
            62478860
        ],
        "B": [
            62467959,
            62468158,
            62464148,
            62469867,
            62471265,
            62468289,
            62470934,
            62468364,
            62468024,
            62466207,
            62466240,
            62496223,
            62469290,
            62471104,
            62469292,
            62469059,
            62467915,
            62469090,
            62470225
        ],
        "A": [
            62466123,
            62464793,
            62464086,
            62466602,
            62465923,
            62464447,
            62464989,
            62659829,
            62464905,
            62464254,
            62465585,
            62464807,
            62497112,
            62464806,
            62468732,
            62464268,
            62464707,
            62464160,
            62464768,
            62464533
        ]
    },
    "name": "E. Minimizing Difference",
    "statement": "You are given a sequence a_1, a_2,\r\ndots, a_n consisting of n integers.You may perform the following\r\noperation on this sequence: choose any element and either increase or\r\ndecrease it by one.Calculate the minimum possible difference between the\r\nmaximum element and the minimum element in the sequence, if you can\r\nperform the aforementioned operation k times.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n, k;\nll a[100010];\nint l, r;\nvoid done() {\n\tputs(\"0\");\n\texit(0);\n}\nvoid move_left() {\n\twhile(1) {\n\t\tif(l == r) done();\n\t\tif(a[l] != a[l + 1]) break;\n\t\tl++;\n\t}\n}\nvoid move_right(){\n\twhile(1) {\n\t\tif(r == l) done();\n\t\tif(a[r] != a[r - 1]) break;\n\t\tr--;\n\t}\n}\nint main() {\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tl = 0;\n\tr = n - 1;\n\twhile(k > 0) {\n\t\tmove_left();\n\t\tmove_right();\n\t\tint lc = l + 1;\n\t\tint rc = n - r;\n\t\tif(lc < rc) {\n\t\t\tll c = a[l + 1] - a[l];\n\t\t\tif(k < c * lc){\n\t\t\t\ta[0] += k / lc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk -= c * lc;\n\t\t\ta[0] = a[l] = a[l + 1];\n\t\t}\n\t\telse{\n\t\t\tll c = a[r] - a[r - 1];\n\t\t\tif(k < c * rc){\n\t\t\t\ta[n - 1] -= k / rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk -= c * rc;\n\t\t\ta[n - 1] = a[r] = a[r - 1];\n\t\t}\n\t}\n\tcout << (a[n - 1] - a[0]) << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "sortings",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Minimizing Difference.json",
    "editorial_link": "https://codeforces.com//blog/entry/70553",
    "editorial": "Suppose that the maximum value in the resulting array should be , and\r\nthe minimum value should be . Letâs estimate the required number of\r\noperations to make an array with such properties. All elements that are\r\nless than should be increased to , and all elements that are greater\r\nthan should be decreased to and we donât have to do any operation with\r\nremaining elements.Now we claim that either or should belong to the\r\ninitial array. Why so? Suppose we constructed an answer such that and .\r\nIf the number of elements we increased to is not less than the number of\r\nelements we decreased to , then we could construct the answer with\r\nminimum equal to and maximum equal to , and it would not require more\r\noperations. And if the number of elements we increased to is less than\r\nthe number of elements we decreased to , then we construct the answer\r\nfor as minimum and as maximum. So we can shift the range so that one of\r\nits endpoints belongs to the initial array.Now we can solve the problem\r\nas follows: iterate on the maximum in the resulting array and find the\r\nlargest minimum we can obtain with binary search, and then do it vice\r\nversa: iterate on the minimum in the resulting array and find the\r\nlargest maximum we can obtain with binary search. To check how many\r\noperations we need, for example, to make all values not less than , we\r\ncan find the number of elements that we have to change with another\r\nbinary search (let the number of such elements be ), and find their sum\r\nwith prefix sums (let their sum be ). Then the required number of\r\noperations is exactly . The same approach can be used to find the number\r\nof operations to make all elements not greater than .This is the way the\r\nproblem was supposed to solve, but, unfortunately, we failed to find a\r\nmuch easier greedy solution.\r\n",
    "hint": []
}