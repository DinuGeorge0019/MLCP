{"link": "https://codeforces.com//contest/58/problem/D", "problemId": "305", "problem_idx": "D", "shortId": "58D", "contest_number": "58", "problem_submissions": {"D": [270336, 270674, 270811, 270851, 270887, 271132, 271142, 271330, 271389, 271766, 271154], "C": [269533, 270101, 270025, 269917, 270200, 269750, 270685, 270162, 270751, 270141, 269530, 269933, 269606, 269716, 271773], "B": [268900, 268864, 269230, 269259, 269499, 268848, 268646, 268854, 269609, 270244, 268607, 269049, 268695, 268750, 269087, 268968], "A": [268535, 268577, 268985, 268522, 268973, 268444, 268395, 268432, 268537, 268387, 268418, 268427, 268476, 268567, 268554]}, "name": "D. Calendar", "statement": "BerOilGasDiamondBank has branches in cities, at that is an even number.\r\nThe bank management wants to publish a calendar with the names of all\r\nthose cities written in two columns: the calendar should consist of\r\nexactly lines of strictly equal length, each of which contains exactly\r\ntwo names and exactly one separator character between them. The name of\r\nevery city should be used in the calendar exactly once. For historical\r\nreasons the symbol is used as the separator of words in the calendar.\r\nThe BerOilGasDiamondBank management wants to show that all its branches\r\nare equally important to it, that\u2019s why the order of their appearance in\r\nthe calendar should be following: if we \"glue\"(concatinate) all the\r\ncalendar lines (from top to bottom) to make a single line, then the\r\nlexicographically minimal line is obtained. No separator character will\r\nbe used to separate calendar lines. For example, if the lines are\r\n\"bertown!berville\", \"newberville!bera\", then the resulting line is\r\n\"bertown!bervillenewberville!bera\". In some sense one has to find the\r\nlexicographically minimal calendar, where the comparison of calendars\r\nhappens line by line.Help BerOilGasDiamondBank and construct the\r\nrequired calendar.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define MM(a , x) memset(a , x , sizeof(a))\n#define sqr(x) ((x) * (x))\n#define abs(x) ((x > 0) ? (x) : -(x))\n#define REP(i , n) for ((i) = 0; (i) < (n); ++(i))\n#define FOR(i , a , b) for ((i) = (a); (i) <= (b); ++(i))\n#define FORD(i , a , b) for ((i) = (a); (i) >= (b); --(i))\ntypedef long long LL;\n\nint n , m , tot , l , r;\nstring ans , data[10008];\nchar sep;\nint cnt[18];\nvector<int> index[18];\nbool vis[10008];\n\ninline bool cmp(const string &a , const string &b)\n{\n\tint i , j , k , l1 , l2;\n\tl1 = a.length(); l2 = b.length();\n\tREP (i , min(l1 , l2))\n\t{\n\t\tif (a[i] != b[i]) return a[i] < b[i];\n\t}\n\tif (l1 == l2) return 0;\n\tif (l1 < l2)\n\t{\n\t\tif (sep <= b[l1]) return 1; else return 0;\n\t}\n\telse\n\t{\n\t\tif (sep >= a[l2]) return 1; else return 0;\n\t}\n}\n\nvoid init()\n{\n\tcin >> n;\n\tint i;\n\tFOR (i , 1 , n) cin >> data[i];\n\tcin >> sep;\n}\n\nvoid work()\n{\n\tsort(data + 1 , data + n + 1 , cmp);\n\tint i , j , k , tp;\n\tl = 11; r = 0;\n\tFOR (i , 1 , n)\n\t{\n\t\tk = data[i].length();\n\t\tl = min(l , k);\n\t\tr = max(r , k);\n\t\tindex[k].push_back(i);\n\t}\n\tm = l + r;\n\tMM(vis , 0);\n\tFOR (i , 1 , n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tk = data[i].length();\n\t\tans.clear();\n\t\tans += data[i];\n\t\tcnt[k]++;\n\t\tans.push_back(sep);\n\t\tj = index[m - k][cnt[m - k]++];\n\t\tans += data[j];\n\t\tvis[i] = vis[j] = 1;\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tinit();\n\twork();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["greedy", "strings"], "dificulty": "2000", "interactive": false}