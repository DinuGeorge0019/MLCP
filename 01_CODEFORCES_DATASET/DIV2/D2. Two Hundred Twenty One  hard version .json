{
    "link": "https://codeforces.com//contest/1562/problem/D2",
    "problemId": "1090691",
    "problem_idx": "D2",
    "shortId": "1562D2",
    "contest_number": "1562",
    "problem_submissions": {
        "D1": [
            127110573,
            127085719,
            127084796,
            127084014,
            127082028,
            127085521,
            127097411,
            127086825,
            127084098,
            127152628,
            127086357,
            127091256,
            127089578,
            127094935,
            127087378,
            127145842,
            127096913,
            127085638,
            127093081,
            127092946,
            127097887
        ],
        "C": [
            127103744,
            127070687,
            127073196,
            127078874,
            127072653,
            127077271,
            127080224,
            127080082,
            127076281,
            127152605,
            127080001,
            127084225,
            127080395,
            127079018,
            127078269,
            127145835,
            127074373,
            127074883,
            127071594,
            127080320,
            127084605
        ],
        "F": [
            127097089,
            127135208,
            127161728,
            127161600,
            127229394,
            127157826,
            127137600,
            127137538
        ],
        "B": [
            127076926,
            127064047,
            127067878,
            127063714,
            127064849,
            127070358,
            127068285,
            127074157,
            127067634,
            127152598,
            127071567,
            127066882,
            127070574,
            127066706,
            127070386,
            127145825,
            127065946,
            127063213,
            127065381,
            127068953,
            127075580
        ],
        "E": [
            127072906,
            127104112,
            127107000,
            127110960,
            127115711,
            127114212,
            127106853,
            127106260,
            127114534,
            127115452,
            127152643,
            127119064,
            127113726,
            127111252,
            127120883,
            127122598,
            127145862,
            127118199,
            127123949,
            127112032,
            127125984,
            127116259
        ],
        "A": [
            127058831,
            127058219,
            127058722,
            127058582,
            127058274,
            127060830,
            127061981,
            127062185,
            127059322,
            127061493,
            127152592,
            127059028,
            127058289,
            127059753,
            127058370,
            127060017,
            127145811,
            127058384,
            127058502,
            127058367,
            127058839,
            127058595
        ],
        "D2": [
            127087276,
            127093820,
            127092460,
            127093109,
            127096811,
            127100821,
            127112348,
            127097441,
            127096385,
            127152634,
            127098403,
            127095759,
            127102138,
            127094867,
            127102605,
            127145854,
            127108326,
            127092734,
            127119011,
            127100809,
            127104819
        ]
    },
    "name": "D2. Two Hundred Twenty One  hard version ",
    "statement": "Stitch likes experimenting with different machines with his friend\r\nSparky. Today they built another machine.The main element of this\r\nmachine are n rods arranged along one straight line and numbered from 1\r\nto n inclusive. Each of these rods must carry an electric charge\r\nquantitatively equal to either 1 or -1 (otherwise the machine will not\r\nwork). Another condition for this machine to work is that the\r\nsign-variable sum of the charge on all rods must be zero.More formally,\r\nthe rods can be represented as an array of n numbers characterizing the\r\ncharge: either 1 or -1. Then the condition must hold: a_1 - a_2 + a_3 -\r\na_4 +\r\nldots = 0, or\r\nsum\r\nlimits_{i=1}^n (-1)^{i-1}\r\ncdot a_i = 0.Sparky charged all n rods with an electric current, but\r\nunfortunately it happened that the rods were not charged correctly (the\r\nsign-variable sum of the charge is not zero). The friends decided to\r\nleave only some of the rods in the machine. Sparky has q questions. In\r\nthe ith question Sparky asks: if the machine consisted only of rods with\r\nnumbers l_i to r_i inclusive, what minimal number of rods could be\r\nremoved from the machine so that the sign-variable sum of charges on the\r\nremaining ones would be zero? . Perhaps the friends got something wrong,\r\nand the sign-variable sum is already zero. In that case, you don’t have\r\nto remove the rods at all.If the number of rods is zero, we will assume\r\nthat the sign-variable sum of charges is zero, that is, we can always\r\nremove all rods.Help your friends and answer all of Sparky’s questions!\r\n",
    "solutions": [
        "// Skyqwq\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long LL;\n\ntemplate <typename T> void chkMax(T &x, T y) { if (y > x) x = y; }\ntemplate <typename T> void chkMin(T &x, T y) { if (y < x) x = y; }\n\ntemplate <typename T> void inline read(T &x) {\n    int f = 1; x = 0; char s = getchar();\n    while (s < '0' || s > '9') { if (s == '-') f = -1; s = getchar(); }\n    while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = getchar();\n    x *= f;\n}\n\nconst int N = 300005, S = N << 1;\n\nint n, q, s[N], B = 3e5;\n\nchar g[N];\n\nvector<int> e1[S], e2[S];\n\nint inline g1(int x, int l) {\n    x += B; \n    int p = lower_bound(e1[x].begin(), e1[x].end(), l) - e1[x].begin();\n    return e1[x][p];\n}\n\nint inline g2(int x, int l) {\n    x += B; \n    int p = lower_bound(e2[x].begin(), e2[x].end(), l) - e2[x].begin();\n    return e2[x][p];\n}\n\nint inline get(int l, int r) {\n    int t = s[r] - s[l - 1];\n    if (t > 0) {\n        int g = t / 2 + 1;\n        int pos = g1(g + s[l - 1], l);\n        return pos;\n    } else {\n        int g = t / 2 - 1;\n        int pos = g2(g + s[l - 1], l);\n        return pos;\n    }\n}\n \nint main() {\n    int T; read(T);\n    while (T--) {\n        read(n), read(q);\n        scanf(\"%s\", g + 1);\n        for (int i = 1; i <= n; i++) {\n            int v = g[i] == '+' ? 1 : -1;\n            if (i % 2 == 0) v = -v;\n            s[i] = s[i - 1] + v;\n            if (v == 1) {\n                e1[s[i] + B].pb(i);\n            } else {\n                e2[s[i] + B].pb(i);\n            }  \n        }\n        while (q--) {\n            int l, r; read(l), read(r);\n            int t = s[r] - s[l - 1];\n            if (!t) puts(\"0\");\n            else if (t & 1) {\n                puts(\"1\");\n                printf(\"%d\\n\", get(l, r));\n            } else {\n                puts(\"2\");\n                printf(\"%d %d\\n\", r, get(l, r - 1));\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            int v = g[i] == '+' ? 1 : -1;\n            if (i % 2 == 0) v = -v;\n            if (v == 1) {\n                e1[s[i] + B].clear();\n            } else {\n                e2[s[i] + B].clear();\n            }  \n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Two Hundred Twenty One  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/94278",
    "editorial": "We will use the facts already obtained, given in the solution of problem\r\nD1.To quickly check the value of the sign-variable sum on the segment\r\nwith deletion of one element, slightly modify the prefix-sum. We will\r\nnot concentrate on this in detail; you can see how to make it in the\r\nsolution.Now letâs see how to search for a matching element inside an\r\nodd-length segment. We will do this with a binary search. Suppose\r\ninitially , , and we know that the numbers and are different signs, or\r\none of them is zero.Now consider the following algorithm: Find equal to\r\n. If , or , or , then the answer is found. Otherwise, either the numbers\r\nand have different signs, or the numbers and have different signs. In\r\nthe first case, assign to , in the second case, assign to . This\r\nalgorithm will stop sooner or later and produce an answer, since we know\r\nthat the matching item exactly exists. This can be shown using the fact\r\nthat , and all are even.So finally we have the following solution: if\r\nthe sign-variable sum is already zero, output zero; otherwise, if the\r\nsegment is of odd length, search for a suitable element by the above\r\nalgorithm; otherwise, take, for example, the left boundary of the\r\nsegment as the first element to remove, and search for the second\r\nelement using the above algorithm on the segment without a left\r\nelement.Asymptotics: per test case.\r\n",
    "hint": [
        "Hint 4 Consider how to quickly check the value of a sign-variable sum on a segment if you know that exactly one element is removed from it (and know the number of that element).",
        "Hint 5 From the solution of Problem D1 it is clear that for any odd segment only one element has to be removed. Consider how to find such an element, based on the proof of its existence given above."
    ]
}