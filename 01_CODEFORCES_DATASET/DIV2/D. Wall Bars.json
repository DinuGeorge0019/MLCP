{"link": "https://codeforces.com//contest/268/problem/D", "problemId": "2561", "problem_idx": "D", "shortId": "268D", "contest_number": "268", "problem_submissions": {"E": [3029362, 3027005, 3026499, 3026194, 3026632, 3027097, 3026470, 3026693, 3027609, 3027536, 3027449, 3029652, 3027603, 3027497, 3027682, 3029387, 3028099, 3028892], "D": [3029086, 3037705, 3037697, 3037608, 3037604, 3037597, 3037586], "C": [3022125, 3024460, 3023115, 3022875, 3022947, 3022255, 3024092, 3024462, 3022033, 3022803, 3024394, 3025519, 3024680, 3023628, 3024663, 3025736, 3024616, 3023126], "B": [3021486, 3022962, 3021236, 3021634, 3022054, 3021375, 3022451, 3021884, 3023790, 3021388, 3022861, 3022930, 3022093, 3022237, 3022694, 3023334, 3021661, 3021427], "A": [3020792, 3021158, 3020508, 3020555, 3021108, 3020432, 3020678, 3021068, 3020421, 3020463, 3021924, 3020884, 3020808, 3020977, 3021030, 3020567, 3022196, 3022929]}, "name": "D. Wall Bars", "statement": "Manao is working for a construction company. Recently, an order came to\r\nbuild wall bars in a children\u2019s park. Manao was commissioned to develop\r\na plan of construction, which will enable the company to save the most\r\nmoney.After reviewing the formal specifications for the wall bars, Manao\r\ndiscovered a number of controversial requirements and decided to treat\r\nthem to the company\u2019s advantage. His resulting design can be described\r\nas follows: Let\u2019s introduce some unit of length. The construction center\r\nis a pole of height . At heights exactly one horizontal bar sticks out\r\nfrom the pole. Each bar sticks in one of four pre-fixed directions. A\r\nchild can move from one bar to another if the distance between them does\r\nnot exceed and they stick in the same direction. If a child is on the\r\nground, he can climb onto any of the bars at height between and . In\r\nManao\u2019s construction a child should be able to reach at least one of the\r\nbars at heights if he begins at the ground. Manao is wondering how many\r\ndistinct construction designs that satisfy his requirements exist. As\r\nthis number can be rather large, print the remainder after dividing it\r\nby . Two designs are considered distinct if there is such height , that\r\nthe bars on the height in these designs don\u2019t stick out in the same\r\ndirection.\r\n", "solutions": ["#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n#define mo 1000000009\n\nint d[2][31][31][31][31];\nint h;\n\nvoid solve(int now,int i,int j,int k,int l,int ii,int jj,int kk,int ll)\n{\n  if (d[now][i][j][k][l]>0)\n  {\n    //printf(\"%d %d %d %d %d %d\\n\",now,i,j,k,l,d[now][i][j][k][l]);\n    //printf(\"%d %d %d %d\\n\",ii,jj,kk,ll);\n    if (i==h)\n    {\n      d[1-now][jj][kk][ll][h]+=d[now][i][j][k][l];\n      if (d[1-now][jj][kk][ll][h]>=mo)\n        d[1-now][jj][kk][ll][h]-=mo;\n    }\n    else\n    {\n      d[1-now][0][jj][kk][ll]+=d[now][i][j][k][l];\n      if (d[1-now][0][jj][kk][ll]>=mo)\n        d[1-now][0][jj][kk][ll]-=mo;\n    }\n\n    if (j==h)\n    {\n      d[1-now][ii][kk][ll][h]+=d[now][i][j][k][l];\n      if (d[1-now][ii][kk][ll][h]>=mo)\n        d[1-now][ii][kk][ll][h]-=mo;\n    }\n    else\n    {\n      d[1-now][0][ii][kk][ll]+=d[now][i][j][k][l];\n      if (d[1-now][0][ii][kk][ll]>=mo)\n        d[1-now][0][ii][kk][ll]-=mo;\n    }\n\n    if (k==h)\n    {\n      d[1-now][ii][jj][ll][h]+=d[now][i][j][k][l];\n      if (d[1-now][ii][jj][ll][h]>=mo)\n        d[1-now][ii][jj][ll][h]-=mo;\n    }\n    else\n    {\n      d[1-now][0][ii][jj][ll]+=d[now][i][j][k][l];\n      if (d[1-now][0][ii][jj][ll]>=mo)\n        d[1-now][0][ii][jj][ll]-=mo;\n    }\n\n    if (l==h)\n    {\n      d[1-now][ii][jj][kk][h]+=d[now][i][j][k][l];\n      if (d[1-now][ii][jj][kk][h]>=mo)\n        d[1-now][ii][jj][kk][h]-=mo;\n    }\n    else\n    {\n      d[1-now][0][ii][jj][kk]+=d[now][i][j][k][l];\n      if (d[1-now][0][ii][jj][kk]>=mo)\n        d[1-now][0][ii][jj][kk]-=mo;\n    }\n    d[now][i][j][k][l]=0;\n  }\n}\n\nint main()\n{\n  int i,j,k,o,n,now,l,jj,kk,ll,ans;\n  scanf(\"%d%d\",&n,&h);\n  memset(d,0,sizeof(d));\n  d[0][0][0][0][0]=1;\n  now=0;\n  for (i=0;i<n;i++)\n  {\n    //printf(\"%d\\n\",i);\n    //memset(d[1-now],0,sizeof(d[1-now]));\n    //printf(\"wawa:%d\\n\",d[0][0][0][0][0]);\n    for (j=0;j<=h;j++)\n      for (k=j;k<=h;k++)\n        for (l=k;l<=h;l++)\n        {\n          jj=j+1;kk=k+1;ll=l+1;\n          if (jj>h) jj=h;\n          if (kk>h) kk=h;\n          if (ll>h) ll=h;\n          solve(now,0,j,k,l,1,jj,kk,ll);\n          solve(now,j,k,l,h,jj,kk,ll,h);\n          /*\n          if ((j!=0)&&(j!=h))\n          {\n            solve(now,j,0,k,l,jj,1,kk,ll);\n            solve(now,j,h,k,l,jj,h,kk,ll);\n          }\n          if ((j!=0)&&(j!=h)&&(k!=0)&&(k!=h))\n          {\n            solve(now,j,k,0,l,jj,kk,1,ll);\n            solve(now,j,k,h,l,jj,kk,h,ll);\n          }\n          if ((j!=0)&&(j!=h)&&(k!=0)&&(k!=h)&&(l!=0)&&(l!=h))\n          {\n            solve(now,j,k,l,0,jj,kk,ll,1);\n            solve(now,j,k,l,h,jj,kk,ll,h);\n          }\n          */\n        }\n    now=1-now;\n  }\n  ans=0;\n  for (i=0;i<=h;i++)\n    for (j=0;j<=h;j++)\n      for (k=0;k<=h;k++)\n        for (l=0;l<=h;l++)\n          if ((i!=h)||(j!=h)||(k!=h)||(l!=h))\n          {\n            ans+=d[now][i][j][k][l];\n            //printf(\"%d %d %d %d %d %d\\n\",now,i,j,k,l,d[now][i][j][k][l]);\n            if (ans>=mo)\n              ans-=mo;\n          }\n  printf(\"%d\\n\",ans);\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2300", "interactive": false}