{"link": "https://codeforces.com//contest/1546/problem/E", "problemId": "1042728", "problem_idx": "E", "shortId": "1546E", "contest_number": "1546", "problem_submissions": {"E": [122125227, 122124148], "D": [122105872, 122107863, 122096889, 122095603, 122105333, 122096936, 122095472, 122118686, 122098923, 122101207, 122099148, 122104914, 122098428, 122104640, 122105136, 122100488, 122105772, 122099537, 122110448], "B": [122090097, 122085108, 122076540, 122081488, 122082915, 122087734, 122082809, 122086822, 122082800, 122087773, 122082175, 122080119, 122083530, 122081814, 122079226, 122091795, 122081873, 122092861, 122090128], "A": [122086851, 122077567, 122075663, 122076476, 122076552, 122078623, 122076889, 122078972, 122076287, 122076026, 122077753, 122076449, 122078299, 122077156, 122075823, 122076339, 122075922, 122080175, 122215627, 122079018], "C": [122093146, 122079907, 122085065, 122080664, 122088293, 122092424, 122089139, 122082548, 122092063, 122084125, 122087870, 122085723, 122081465, 122087209, 122087382, 122088738, 122085153]}, "name": "E. AquaMoon and Permutations", "statement": "Cirno has prepared n arrays of length n each. Each array is a\r\npermutation of n integers from 1 to n. These arrays are special: for all\r\n1\r\nleq i\r\nleq n, if we take the i-th element of each array and form another array\r\nof length n with these elements, the resultant array is also a\r\npermutation of n integers from 1 to n. In the other words, if you put\r\nthese n arrays under each other to form a matrix with n rows and n\r\ncolumns, this matrix is a Latin square.Afterwards, Cirno added\r\nadditional n arrays, each array is a permutation of n integers from 1 to\r\nn. For all 1\r\nleq i\r\nleq n, there exists position 1\r\nleq k\r\nleq n, such that for the i-th array and the (n + i)-th array, the k-th\r\nelement of both arrays is the same. Notice that the arrays indexed from\r\nn + 1 to 2n form a Latin square. Also, Cirno made sure that for all 2n\r\narrays, no two arrays are completely equal, i. e. for all pair of\r\nindices 1\r\nleq i < j\r\nleq 2n, there exists position 1\r\nleq k\r\nleq n, such that the k-th elements of the i-th and j-th array are\r\n.Finally, Cirno arbitrarily changed the order of 2n arrays.AquaMoon\r\ncalls a subset of all 2n arrays of size n if these arrays from a Latin\r\nsquare.AquaMoon wants to know how many good subsets exist. Because this\r\nnumber may be particularly large, find it modulo 998\r\n,244\r\n,353. Also, she wants to find any good subset. Can you help her?\r\n", "solutions": ["#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\") \n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 998244353;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n,cnt[505][505];\nint h[505][505],c[1005],c2[1005];\nint a[1005][505];\nvec v[1005];\nset <int> s[505][505];\nvec an;\n\nvoid Cor(int x);\nvoid Rem(int x);\n\nvoid dfs(int x,int op) {\n    if(c[x]&&c[x] != op) exit(-1);\n    if(c[x]) return;\n    c[x] = op;\n    if(op == 1) an.pb(x);\n    for(int i : v[x]) dfs(i,3-op);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        an.clear();\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= n;j++) cnt[i][j] = h[i][j] = 0, s[i][j].clear();\n        }\n        for(int i = 1;i <= 2*n;i++) {\n            c[i] = c2[i] = 0;\n        }\n        for(int i = 1;i <= n*2;i++) v[i].clear();\n        for(int i = 1;i <= n*2;i++) {\n            for(int j = 1;j <= n;j++) {\n                cin >> a[i][j];\n                cnt[j][a[i][j]]++;\n                s[j][a[i][j]].insert(i);\n            }\n        }\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= n;j++) {\n                if(cnt[i][j] == 1) {\n                    if(!h[i][j]) Cor(*s[i][j].begin());\n                    else Rem(*s[i][j].begin());\n                }\n            }\n        }\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= n;j++) {\n                if(cnt[i][j] == 1) {\n                    if(!h[i][j]) Cor(*s[i][j].begin());\n                    else Rem(*s[i][j].begin());\n                }\n            }\n        }\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= n;j++) {\n                if(cnt[i][j] == 1) {\n                    if(!h[i][j]) Cor(*s[i][j].begin());\n                    else Rem(*s[i][j].begin());\n                }\n            }\n        }\n        int la;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= n;j++) {\n                la = -1;\n                for(auto k : s[i][j]) {\n                    if(la == -1) la = k;\n                    else {\n                        v[k].pb(la), v[la].pb(k);\n                        la = k;\n                    }\n                }\n            }\n        }\n        ll ans = 1;\n        for(int i = 1;i <= 2*n;i++) {\n            if(c2[i]||c[i]) continue;\n            ans = ans*2%mod;\n            dfs(i,1);\n        }\n        cout << ans << '\\n';\n        for(int i = 1;i <= 2*n;i++) {\n            if(c2[i] == 1) an.pb(i);\n        }\n        sort(all(an));\n        for(int i = 1;i < an.size();i++) {\n            if(an[i] == an[i-1]) return -1;\n        }\n        for(int i : an) cout << i << ' ';\n        cout << '\\n';\n    }\n}\n\nvoid Cor(int x) {\n    if(c2[x] == 2) exit(-1);\n    if(c2[x]) return;\n    c2[x] = 1;\n    vec vv;\n    for(int i = 1;i <= n;i++) {\n        s[i][a[x][i]].erase(x);\n        cnt[i][a[x][i]]--;\n        h[i][a[x][i]] = 1;\n        for(int j : s[i][a[x][i]]) {\n            vv.pb(j);\n        }\n    }\n    sort(all(vv)), vv.erase(unique(all(vv)),vv.end());\n    for(int i : vv) Rem(i);\n}\n\nvoid Rem(int x) {\n    if(c2[x] == 1) exit(-1);\n    if(c2[x]) return;\n    c2[x] = 2;\n    vec vv,rv;\n    for(int i = 1;i <= n;i++) {\n        s[i][a[x][i]].erase(x);\n        cnt[i][a[x][i]]--;\n        if(cnt[i][a[x][i]] == 1) {\n            if(!h[i][a[x][i]]) vv.pb(*s[i][a[x][i]].begin());\n            else rv.pb(*s[i][a[x][i]].begin());\n        }\n    }\n    sort(all(vv)), vv.erase(unique(all(vv)),vv.end());\n    for(int i : vv) Cor(i);\n    sort(all(rv)), rv.erase(unique(all(rv)),rv.end());\n    for(int i : rv) Rem(i);\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "graphs"], "dificulty": "2800", "interactive": false}