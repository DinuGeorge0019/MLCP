{
    "link": "https://codeforces.com//contest/384/problem/C",
    "problemId": "5719",
    "problem_idx": "C",
    "shortId": "384C",
    "contest_number": "384",
    "problem_submissions": {
        "E": [
            5754820,
            5756457,
            5757218,
            5768768,
            5754973,
            5757082,
            5757773,
            5753824,
            5757669,
            5759993,
            5759984,
            5759937
        ],
        "C": [
            5752253,
            5751497,
            5752881,
            5756887,
            5754090,
            5753464,
            5757534,
            5753590,
            5750204,
            5750062,
            5751623,
            5750722,
            5749880,
            5751415,
            5751385,
            5750837,
            5751269,
            5751529,
            5751672,
            5751983
        ],
        "B": [
            5748010,
            5749890,
            5748064,
            5751405,
            5751229,
            5751814,
            5754578,
            5753247,
            5749239,
            5750952,
            5748962,
            5749250,
            5750859,
            5749807,
            5750164,
            5749512,
            5750591,
            5750157,
            5750184,
            5749558
        ],
        "A": [
            5747255,
            5747392,
            5747271,
            5747721,
            5748251,
            5749148,
            5747297,
            5749334,
            5748038,
            5747882,
            5747312,
            5747613,
            5747325,
            5747593,
            5747897,
            5747709,
            5747419,
            5747633,
            5747362,
            5747257
        ],
        "D": [
            5759668,
            5766263
        ]
    },
    "name": "C. Milking cows",
    "statement": "Iahub helps his grandfather at the farm. Today he must milk the cows.\r\nThere are cows sitting in a row, numbered from to from left to right.\r\nEach cow is either facing to the left or facing to the right. When Iahub\r\nmilks a cow, all the cows that see the current cow get scared and lose\r\none unit of the quantity of milk that they can give. A cow facing left\r\nsees all the cows with lower indices than her index, and a cow facing\r\nright sees all the cows with higher indices than her index. A cow that\r\ngot scared once can get scared again (and lose one more unit of milk). A\r\ncow that has been milked once cannot get scared and lose any more milk.\r\nYou can assume that a cow never loses all the milk she can give (a cow\r\ngives an infinitely amount of milk).Iahub can decide the order in which\r\nhe milks the cows. But he must milk each cow exactly once. Iahub wants\r\nto lose as little milk as possible. Print the minimum amount of milk\r\nthat is lost.\r\n",
    "solutions": [
        "//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname \"\"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(\"%d\" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(\"%d\" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint a[sz], s1, s2, p1, p2, t[2][sz], c1, c2, c, n, L[sz], R[sz];\nlong long ans;\n\nvoid upd(int g, int v, int l, int r, int p, int x)\n{\n\tif (l == r)\n\t\tt[g][v] = x;\n\telse\n\t{\n\t\tint m = (l + r) >> 1;\n\t\tif (p <= m)\n\t\t\tupd(g, v + v, l, m, p, x);\n\t\telse\n\t\t\tupd(g, v + v + 1, m + 1, r, p, x);\n\t\tt[g][v] = t[g][v + v] + t[g][v + v + 1];\n\t}\n}\n\n\nint get(int g, int v, int tl, int tr, int l, int r)\n{\n\tif (l > r)\n\t\treturn 0;\n\tif (l == tl && r == tr)\n\t\treturn t[g][v];\n\tint m = (tl + tr) >> 1;\n\treturn get(g, v + v, tl, m, l, min(r, m)) + get(g, v + v + 1, m + 1, tr, max(m + 1, l), r);\n}\n\nint main(){\n\t//freopen(fname\"in\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\tcin >> n;\n\tfor (1, n, i)\n\t{\n\t\tcin >> a[i];\n\t\tif (a[i])\n\t\t\tL[++c1] = i;\n\t\telse\n\t\t\tR[++c2] = i;\n\t\tupd(a[i], 1, 1, n, i, 1);\t\n\t}\n\tc = 1;\n\tfor (1, n, i)\n\t{\n\t\tif (c <= c1 && c2)\n\t\t{\n\t\t\tp1 = L[c];\n\t\t\tp2 = R[c2];\n\t\t\ts1 = get(1, 1, 1, n, 1, p1 - 1) + get(0, 1, 1, n, p1 + 1, n);\n\t\t\ts2 = get(1, 1, 1, n, 1, p2 - 1) + get(0, 1, 1, n, p2 + 1, n);\n\t\t\tans += min(s1, s2);\n\t\t\tif (s1 < s2)\n\t\t   \t{\n\t\t   \t\tupd(1, 1, 1, n, p1, 0);\n\t\t   \t\tc++;\n\t\t   \t}\n\t\t   \telse\n\t\t   \t{\n\t\t   \t\tupd(0, 1, 1, n, p2, 0);\n\t\t   \t\tc2--;\n\t\t   \t}\n\t\t}\n\t\telse\n\t\tbreak;\n\t}\n\tcout << ans;\n    \treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Milking cows.json",
    "editorial_link": "https://codeforces.com//blog/entry/10476",
    "editorial": "A good strategy to approach this problem is to think how optimal\r\nordering should look like. For this, let s calculate for each 2\r\ndifferent cows i and j if cow i needs to be milked before or after cow\r\nj. As we ll show, having this information will be enough to build\r\noptimal ordering. It is enough to consider only cases when i < j, case\r\nwhen i > j is exactly the opposite of case i < j. For formality, I ll\r\ncall the optimal ordering permutation and lost milk the cost of\r\npermutation. So, for an optimal permutation P let s take 2 numbers i < j\r\nand see in which cases i should appear before j in permutation (i is\r\nbefore j if P[pos1] = i, P[pos2] = j and pos1 < pos2; otherwise we ll\r\ncall i is after j). We have 4 possible cases: 1/ A[i] = 0 and A[j] = 0\r\nIf we put i before j, no additional cost will be added. Since j is in\r\nright of i and i only adds cost when it finds elements in left of i, j\r\nwon t be affected when processing i. When processing j, i will be\r\nalready deleted so it won t affect the cost either. Hence, we can put i\r\nbefore j and no cost will be added. 2/ A[i] = 0 and A[j] = 1 Here, i and\r\nj can appear in arbitrary order in permutation (i can be before or after\r\nj). No matter how we choose them, they won t affect each other and cost\r\nwill remain the same. 3/ A[i] = 1 and A[j] = 0 As well, here i and j can\r\nappear in arbitrary order. If we choose i first, j will be in right of\r\nit, so cost of permutation will increase by one. If we choose j first, i\r\nwill be in left of it so cost of permutation will increase as well. No\r\nmatter what we do, in this case cost of permutation increases by 1. 4/\r\nA[i] = 1 and A[j] = 1 Here, i needs to be after j. This adds 0 cost.\r\nTaking i before j will add 1 cost to permutation (since j is in right of\r\ni). Those 4 cases show us how a minimal cost permutation should look. In\r\na permutation like this, only case 3/ contributes to final cost, so we\r\nneed to count number of indices i, j such as i < j and A[i] = 1 and A[j]\r\n= 0 (*). If we show a permutation following all rules exists, task\r\nreduces to (*). By cases 2/ and 3/ it follows that in an optimal\r\npermutation, it only matters order of elements having same value in A[].\r\nWe can put firstly all elements having value 0 in A[], then all elements\r\nhaving value 1 in A[]. We can order elements having value 0 by case 1/\r\nand elements having value 1 by case 4/. More exactly, suppose i1 < i2 <\r\n... < im and (A[i1] = A[i2] = ... = A[im] = 0) and j1 > j2 > ... > jn\r\n(A[j1] = A[j2] = ... = A[jn] = 1). Then, a permutation following all\r\nrules is {i1, i2, ..., im, j1, j2, ..., jn}. This permutation can always\r\nbe built. Hence, task reduces to (*): count number of indices i, j such\r\nas i < j and A[i] = 1 and A[j] = 0. We can achieve easily an O(N)\r\nalgorithm to do this. Let s build an array cnt[j] = number of 0s in\r\nrange {j, j + 1, ..., N} from array A. We can easily implement it by\r\ngoing backwards from N to 1. The result is sum of cnt[i], when A[i] = 1.\r\nCode: http://pastie.org/8651813 Our first observation is that if there\r\nis a path from (1, 1) to (N, N), then the length of path is 2 * N 2.\r\nSince all paths have length 2 * N 2, it follows that if there is at\r\nleast one path, the answer is 2 * N 2 and if there isn t, the answer is\r\n-1. How to prove it? Every path from (1, 1) to (N, N) has exactly N 1\r\ndown directions and exactly N 1 right directions. So, total length for\r\neach path is N 1 + N 1 = 2 * N 2. So we reduced our problem to determine\r\nif there is at least one path from (1, 1) to (N, N). This is the\r\nchallenging part of this task, considering that N <= 10 ^ 9. How would\r\nyou do it for a decently small N, let s say N <= 10^3 . One possible\r\napproach would be, for each row, keep a set of reachable columns. We\r\ncould easily solve this one by doing this: if (i, j) denotes element\r\nfrom ith row and jth column, then (i, j) is (is not) reachable if: if\r\n(i, j) contains a volcano, then (i, j) is not reachable. Otherwise, if\r\nat least one of (i 1, j) and (i, j 1) is reachable, then (i, j) is\r\nreachable. Otherwise, (i, j) is not reachable. What s the main problem\r\nof this approach? It needs to keep track of 10^9 lines and in worst\r\ncase, each of those lines can have 10^9 reachable elements. So, worst\r\ncase we need 10^9 * 10^9 = 10^18 operations and memory. Can we optimize\r\nit? We can note for beginning that we don t need to keep track of 10^9\r\nlines, only m lines are really necessarily. We need only lines\r\ncontaining at least one obstacle (in worst case when each line contains\r\nonly one obstacle, we need m lines). How to solve it this way? Suppose\r\nline number x contains some obstacles and lines x + 1, x + 2, x + 3 do\r\nnot contain any obstacle. Suppose we calculated set S = {y | cell (x, y)\r\nis reachable}. How would look S1, S2, S3 corresponding to lines x + 1,\r\nx + 2, x + 3? For S1, we can reach cell (x + 1, ymin), where ymin is\r\nminimal value from set S. Then, we can also reach {ymin + 1, ymin + 2,\r\n..., N}, by moving right from (x + 1, ymin). So S1 = {ymin, ymin + 1,\r\n..., N}. How do S2 and S3 look? It s easy to see that they ll be as well\r\n{ymin, ymin + 1, ..., N}. So we get following optimization: suppose set\r\nof lines containing at least one obstacle is {L1, L2, ..., Lk}. We need\r\nto run algorithm only for lines L1, L1 + 1, L2, L2 + 1, L3, L3 + 1, ...,\r\nLk, Lk + 1. It looks like we didn t make anything with this\r\noptimization. Even if we calculate for m lines, each line can still have\r\n10^9 reachable positions. So worst case we perform 10^14 operations. We\r\nneed something better for managing information from a line. You can note\r\nthat for a given line y, there are a lot of positions having consecutive\r\nvalues. There are a lot of positions (x, y) and (x, y + 1) both\r\nreachable. This should give us following idea: what if instead of\r\nkeeping reachable positions, we keep reachable ranges? That is, for each\r\nline x we keep a set of ranges S = {(a, b) | all cells (x, k) with a <=\r\nk <= b are reachable}. How many ranges can it be for a line? If the line\r\ncontains m obstacles, there are m + 1 ranges. Suppose for line x all\r\ncells are reachable, but for line x + 1 cells (x + 1, 3) (x + 1, 5) (x +\r\n1, N 1) are blocked. Then, the ranges of reachable cells are [1, 2] [4,\r\n4], [6, N 2] and [N, N]. By now, we get worst case m lines and worst\r\ncase each line having m elements, so in worst case we d have to handle\r\nm * m = 10 ^ 10 events. This may still look too much, but happily this\r\nbound is over estimated. If a line has o obstacles, there can be at most\r\no + 1 ranges. If lines L1, L2, ..., Lk have {o1, o2, ..., ok} obstacles,\r\nthere ll be at most o1 + o2 + ... + ok + k ranges. But o1 + o2 + ... +\r\nok = m and also k is at most m (proved above why we re interested in at\r\nmost m lines), so in worst case we get m + m = 2 * m ranges. Yaay,\r\nfinally a decent number of states for this problem :) So, we iterate\r\neach line we re interested in. Let s find set of ranges for this line,\r\nthinking that all cells from line above are reachable. This is easy to\r\ndo. After we get our ranges like all cells from above can be visited,\r\nlet s think how having obstacles above can influence current ranges.\r\nAfter adding ranges from above, current ranges can t increase\r\n(obviously), they can only decrease, remain the same or some of them can\r\nbecome empty. So, let s take each range [a, b] from current line and see\r\nhow it will transform after adding ranges from previous line. Given\r\nrange [a, b], it can transform only in [a , b] with a >= a. If a > b,\r\nthen obviously range is empty. Why second number of range keeps\r\nconstant? Let a smallest reachable column from current line which is in\r\nrange [a, b]. It s enough to check a >= a, as if a > b, range will be\r\nempty. It s obviously why we need to keep a smallest value possible >=\r\na: we re interested to keep range as big as possible and as less as we\r\ncut from left, as big it is. Once we ve found a in range [a, b] (or a >\r\nb if range is empty) all cells {a + 1, a + 2, ..., b} are reachable as\r\nwell by going right from a , so if interval is not empty, then second\r\nnumber defining it remains b. Next question is how to find a fast\r\nenough. In order a point a to be reachable on current range, it also\r\nneeds to exist a range on previous line containing it. If the range from\r\nprevious line is [pa, pb] then a needs to follow 3 conditions: a minimal\r\nsuch as pa <= a <= pb a >= a What if instead of finding a we find [pa,\r\npb]? Then a is max(pa, a). In order a to be as small as possible, since\r\na is constant, pa needs to be as small as possible. So we reduced it to:\r\npa minimal pb >= a >= a <=> pb >= a Intervals from previous line are\r\ndisjoint, no 2 intervals cross each other. It means that if pb is\r\nminimal, than pa is minimal too (if we increase pb, then pa will\r\nincrease too, so it won t be minimal). Hence, you need to find an\r\ninterval [pa, pb] such as pb is minimal and pb >= a. Then, a is max(a,\r\npa). This is easy to do if we sort all intervals from previous line\r\nincreasing by second value (pb), then we binary search for value a.\r\nFinally, after running algorithm for all lines, last range from last\r\nline has second number N (assuming ranges are sorted increasing by\r\nsecond value), then there exist a path, otherwise there does not exist.\r\nThis algorithm should run O(m * logm) worst case, good enough to pass.\r\nCode: http://pastie.org/8651817 This is kind of task that needs to be\r\nbreak into smaller subproblems that you can solve independently, then\r\nput them together and get solution. Let s define level of a node the\r\nnumber of edges in the path from root to the node. Root (node 1) is at\r\nlevel 0, sons of root are at level 1, sons of sons of root are at level\r\n2 and so on. Now suppose you want to do an operation of type 1 to a node\r\nx. What nodes from subtree of x will be added +val (a positive value)?\r\nObviously, x will be first, being located at level L. Sons of x, located\r\nat level L + 1 will be added val. Sons of sons, located at level L + 2,\r\nwill be added value +val again. So, nodes from subtree of x located at\r\nlevels L, L + 2, L + 4, ... will be added a +val, and nodes located at\r\nlevels L + 1, L + 3, L + 5 will be added a val. Let s take those values\r\nof L modulo 2. All nodes having remainder L modulo 2 will be added a\r\n+val, and nodes having reminder (L + 1) modulo 2 will be added val. In\r\nother words, for a fixed x, at a level L, let y a node from subtree of\r\nx, at level L2. If L and L2 have same parity, +val will be added to y.\r\nOtherwise, -val will be added to y. From here we have the idea to split\r\nnodes of tree in 2 sets those being located at even level and those\r\nbeing located at odd level. What still makes the problem hard to solve?\r\nThe fact that we have a tree. If nodes from a subtree would be a\r\ncontiguous sequence instead of some nodes from a tree, problem would be\r\nsimpler: the problem would reduce to add / subtract values to all\r\nelements of a subarray and query about a current value of an element of\r\narray. So, how can we transform tree to an array, such as for a node x,\r\nall nodes from subtree of x to be a subarray of array? The answer is\r\nyes. We can do this by properties of DFS search. Before reading on, make\r\nsure that you know what is discovery time and finish time in a DFS\r\nsearch. Let s build 3 arrays now discover[], representing nodes in order\r\nof their discover times (a node is as before in discover as it has a\r\nsmall discover time), begin[] = for a node, in which time it was\r\ndiscovered and end[] = what s last time of a discovered node before this\r\nnode finishes. For a subtree of x, all nodes in the subtree are nodes in\r\ndiscover from position begin[x] to end[x]. Example: suppose you have\r\ntree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3 Discover is {1, 5, 6, 7, 4, 2, 3}.\r\nbegin is {1, 6, 7, 5, 2, 3, 4}. end is {7, 6, 7, 7, 2, 7, 4}. What s\r\nsubtree of node 6? elements of discover from position begin[6] to\r\nend[6]. In this case, from 3 to 7, so elements {6, 7, 4, 2, 3}. You can\r\nsee it s correct and take more examples if you want :) Now, we reduced\r\nproblem to: you re given an array A. you can perform 2 operations: 1/\r\nincrease all elements from a range [x, y] to a value val (val can be\r\nnegative, to treat subtractions) 2/ what s current value of an element\r\nfrom position pos. Those who solved Iahub and Xors from my last round,\r\nCF 198, should probably say they saw something similar before. If you\r\ndidn t solve problem before, I encourage you to do it after you solve\r\nthis one, it uses a similar idea to what will follow now. Also, if you\r\ndon t know Fenwick trees, please read them before moving on. An\r\nalternative would be for this task using segment trees with lazy update,\r\nbut I see this one more complicated than needed. I ll use now a not so\r\ncommon approach when dealing with data structures. Instead of keeping in\r\na node the result, like you usually do, I ll keep just an auxiliary\r\ninformation. So what algorithm proposed does: Let A an array, initially\r\nwith all elements 0. When you need to update range [x, y] with value\r\nval, you simply do A[x] += val and A[y + 1] -= val. When you need to\r\nanswer a query about position pos, you output A[1] + A[2] + ... +\r\nA[pos]. Implemented brute force, you get O(1) per update and O(N) per\r\nquery. However, these both are operations supported by a Fenwick tree,\r\nso you can get O(logN) per operation. It may not be very clear why this\r\nalgorithm works. Let s take a closer look: an update needs to add value\r\nval only to range [x, y]. When you query a position pos, let s see if\r\nalgorithm handles it correctly: 1/ pos < x. In this case, result must\r\nnot be affected by my update. Since pos < x and I only updated 2 values\r\nwith indices >= x, when doing A[1] + A[2] + ... + A[pos] it won t matter\r\nat all I did that update at least not for this query. 2/ x <= pos <= y.\r\nHere, for a pos, I need to add value val only once. We add it only at\r\nA[x] in this way it will be counted once, and it will be considered for\r\neach elements from range [x, y] (since an element at position p from\r\nrange [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I ll have to\r\nconsider A[x]). 3/ pos > y. Here I don t have to consider the query. But\r\nit would be considered when processing A[x]. But if I add to A[y + 1]\r\nvalue val I ll just cancel the value previously added. Code (actually we\r\nuse just one Fenwick tree instead of 2, can you think why it works? :) )\r\n: http://pastie.org/8651824\r\n"
}