{
    "link": "https://codeforces.com//contest/1186/problem/F",
    "problemId": "364219",
    "problem_idx": "F",
    "shortId": "1186F",
    "contest_number": "1186",
    "problem_submissions": {
        "F": [
            56216938,
            56221830,
            56221641,
            56218857,
            56211953,
            58409345,
            56299282,
            56213956,
            56210718,
            56211243,
            56212157,
            56210745,
            56214646,
            56218371,
            56217250,
            56211887,
            56220407,
            56219870
        ],
        "E": [
            56211447,
            56208778,
            56218701,
            56208813,
            58409358,
            56275284,
            56222796,
            56249700,
            56215465,
            56216547,
            56237690,
            56250633,
            56250552,
            56216656,
            56220314
        ],
        "D": [
            56200749,
            56201695,
            56206642,
            56211181,
            56202747,
            56201586,
            56205150,
            56206151,
            56203320,
            56252310,
            56249710,
            56202028,
            56208820,
            56205852,
            56200883,
            56207730,
            56204717,
            56257061,
            56203062,
            56206927,
            56205301,
            56202759
        ],
        "C": [
            56199249,
            56199765,
            56204054,
            56222663,
            56199984,
            56199510,
            56203530,
            56202685,
            56205514,
            56200910,
            56249725,
            56199768,
            56206169,
            56202363,
            56198182,
            56204569,
            56218666,
            56537912,
            56199932,
            56203944,
            56202070,
            56199969
        ],
        "A": [
            56196758,
            56193054,
            56194739,
            56209279,
            56193033,
            56192921,
            56196291,
            56192487,
            56193111,
            56249716,
            56195272,
            56199424,
            56197233,
            56193792,
            56192618,
            56195433,
            56193194,
            56192578,
            56193852,
            56194487
        ]
    },
    "name": "F. Vus the Cossack and a Graph",
    "statement": "Vus the Cossack has a simple graph with n vertices and m edges. Let d_i\r\nbe a degree of the i-th vertex. Recall that a degree of the i-th vertex\r\nis the number of conected edges to the i-th vertex.He needs to remain\r\nnot more than\r\nlceil\r\nfrac{n+m}{2}\r\nrceil edges. Let f_i be the degree of the i-th vertex after removing. He\r\nneeds to delete them in such way so that\r\nlceil\r\nfrac{d_i}{2}\r\nrceil\r\nleq f_i for each i. In other words, the degree of each vertex should not\r\nbe reduced more than twice. Help Vus to remain the needed edges!\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n#define pb push_back\ntypedef pair<int,int> pii;\n#define mp make_pair\nconst int MAXN=1000005,INF=1<<30;\n\nint n;\nvector<int> G[MAXN];\nint Min[MAXN<<2|1],Max[MAXN<<2|1],ind[MAXN],rem[MAXN]; \nvoid build(int id,int l,int r)\n{\n\tif(l==r){Min[id]=rem[l];return;}\n\tint mid=(l+r)>>1;\n\tbuild(id<<1,l,mid);\n\tbuild(id<<1|1,mid+1,r);\n\tMin[id]=min(Min[id<<1],Min[id<<1|1]);\n}\nint querymin(int id,int l,int r)\n{\n\tif(l==r)return l;\n\tint mid=(l+r)>>1;\n\tif(Min[id<<1]<Min[id<<1|1])return querymin(id<<1,l,mid);\n\treturn querymin(id<<1|1,mid+1,r);\n}\nvoid modify(int id,int l,int r,int x,int c)\n{\n\tif(l==r){Min[id]=c;return;}\n\tint mid=(l+r)>>1;\n\tif(x<=mid)modify(id<<1,l,mid,x,c);\n\telse modify(id<<1|1,mid+1,r,x,c);\n\tMin[id]=min(Min[id<<1],Min[id<<1|1]);\n}\nset<pii> del;\ninline bool cmp(int x,int y){return rem[x]>rem[y];}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"code.in\",\"r\",stdin);\n    //freopen(\"code.out\",\"w\",stdout);\n    #endif\n    int E,u,v;\n    scanf(\"%d%d\",&n,&E);\n    for(int i=1;i<=E;i++)\n    {\n    \tscanf(\"%d%d\",&u,&v);\n    \tG[u].pb(v);G[v].pb(u);\n    \t++ind[u];++ind[v];\n    }\n    for(int i=1;i<=n;i++)rem[i]=ind[i]/2;\n    build(1,1,n);\n    for(int i=1;i<=n;i++)\n    {\n    \tu=querymin(1,1,n);\n    \tmodify(1,1,n,u,INF);\n    \tsort(G[u].begin(),G[u].end(),cmp);\n    \tfor(int j=0;j<rem[u];j++)\n    \t{\n    \t\tv=G[u][j];\n    \t\tif(!rem[v])break;\n    \t\t--rem[v];\n    \t\tmodify(1,1,n,v,rem[v]);\n    \t\tdel.insert(mp(u,v));\n    \t}\n    \trem[u]=0;\n    }\n    printf(\"%d\\n\",E-del.size());\n    for(u=1;u<=n;u++)\n    \tfor(auto v:G[u])\n    \t\tif(v>u && !del.count(mp(u,v)) && !del.count(mp(v,u)))\n\t\t\t\tprintf(\"%d %d\\n\",u,v);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Vus the Cossack and a Graph.json",
    "editorial_link": "https://codeforces.com/blog/entry/68027",
    "editorial": "At first, let\u00e2\u0080\u0099s create a fictive vertex (I\u00e2\u0080\u0099ll call it vertex) and\r\nconnect it with all of the vertices which have odd degree. Now all the\r\nvertices including vertex have even degree. The statement that vertex\r\nwill have even degree too can be easily proven using the fact that the\r\nsum of degrees of all vertices equals to the number of edges multiplied\r\nby two. Let\u00e2\u0080\u0099s denote the number of edges in the new graph as .There were\r\nedges initially and we added at most new edges that connect fictive\r\nvertex with the real ones, so it always holds that .Now, since all the\r\nvertices have even degree we can find Euler cycle of the new graph.\r\nLet\u00e2\u0080\u0099s define as an array of all edges of the graph, ordered as in found\r\nEuler cycle. Now we can iterate over the array and delete all the edges\r\non even positions. Due to this action now the new graph contains at most\r\nedges. That is exactly what we needed!It is interesting that in the new\r\ngraph by deleting the edges the way mentioned above, the degree of each\r\nvertex would not be reduced more than twice. How to prove that? Well,\r\nyou can think about it the following way:Let\u00e2\u0080\u0099s say that the edge\r\nconnects some vertices and , that means that the edge connects vertex\r\nwith some vertex . If is odd, then we will delete only the edge, and if\r\nis even, then we will delete only the edge. And that happens for every\r\nvertex: if some edge enters it, then we will either delete -th edge or\r\n-th edge. So at most half of edges connected to a vertex will be\r\ndeleted. If the length of Euler cycle is odd, then the last edge in it\r\nwon\u00e2\u0080\u0099t be deleted at all, so the algorithm will still work correctly.But\r\nthat works for the new graph, which contains fictive vertex. But we need\r\nto solve the problem for the real graph. We can not simply delete all\r\nthe edges from the real graph, that were on even positions in Euler\r\ncycle mentioned above. Here is the examle where it does not work\r\n(numbers near the edges show their positions in array, edges that would\r\nneed to be removed are highlited with red): If we removed edge between\r\nvertices and , degree of vertex would become which is definetely less\r\nthen . How do we avoid this bad situation? We can simply do the\r\nfollowing: If is a fictive edge (i.e. it connects a real vertex with\r\nfictive one), then we do not really care about it, since we have to\r\noutput answer about the real graph. If is a real edge (i.e it connects\r\nonly real vertices) and we have to delete it, then we should look if or\r\nis a ficive edge. If either of them is one, then we can delete the\r\nfictive edge instead of the real edge (i.e. we simply do not delete from\r\nthe graph), otherwise we delete the edge. (Note that if is the last edge\r\nin the Euler cycle, then instead of checking the edge which does not\r\nexist, you check if is fictive or not, similar goes for the case if ).\r\nIt is obvious that by doing so we do not change the number of edges\r\ndeleted. It is also easy to see that the degree of a vertex in the new\r\ngraph is at most . We still delete at most edges connected to it (or if\r\nit initially had an even degree), but in case when it\u00e2\u0080\u0099s degree was\r\n\"artificially\" increased, we prefer to delete the fictive edge, which we\r\ndo not care about. The last question is: whether there we will a fictive\r\nedge which we will try to delete more than once? It is easy to prove\r\nthat there is no such edge, you can try it by yourself.That\u00e2\u0080\u0099s it, the\r\nproblem is solved. Note that the graph is not necessarily connected, so\r\nyou should find Euler cycle and do the following steps for each\r\ncomponent independently.In order to better understand the solution,\r\ncheck out author\u00e2\u0080\u0099s source code:\r\n"
}