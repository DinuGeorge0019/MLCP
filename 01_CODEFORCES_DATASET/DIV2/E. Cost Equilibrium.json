{
    "link": "https://codeforces.com//contest/1513/problem/E",
    "problemId": "954482",
    "problem_idx": "E",
    "shortId": "1513E",
    "contest_number": "1513",
    "problem_submissions": {
        "F": [
            112704242,
            112708449,
            112692430,
            112693367,
            112715319,
            112703491,
            112694811,
            127489679,
            112714894,
            112706130
        ],
        "E": [
            112694829,
            112692532,
            112741611,
            112740521,
            112688817,
            112693970,
            112694924,
            112695544,
            112697383,
            112699670,
            112696818,
            112699923,
            112700793
        ],
        "D": [
            112684276,
            112682550,
            112679745,
            112679949,
            112677500,
            112683697,
            112682474,
            112682520,
            113011471,
            113011359,
            113011120,
            113011016,
            113009370,
            112680944,
            112706307,
            112684078,
            112683480,
            112687888,
            112686211,
            112688484,
            112694241
        ],
        "C": [
            112675074,
            112673956,
            112673377,
            112672093,
            112671463,
            112675182,
            112671664,
            112676030,
            112671692,
            112674449,
            112673953,
            112672990,
            112673437,
            112678260,
            112672998,
            112674969
        ],
        "B": [
            112671476,
            112670228,
            112670172,
            112670205,
            112668144,
            112670061,
            112665513,
            112670183,
            112667846,
            112669295,
            112667797,
            112667641,
            112669249,
            112668199,
            112668800,
            112667109
        ],
        "A": [
            112663904,
            112665049,
            112664695,
            112668785,
            112662814,
            112664430,
            112662730,
            112664013,
            112662970,
            112664151,
            112662873,
            112663063,
            112663560,
            112664683,
            112663477,
            112662816
        ]
    },
    "name": "E. Cost Equilibrium",
    "statement": "An array is called beautiful if all the elements in the array are\r\nequal.You can transform an array using the following steps any number of\r\ntimes: Choose two indices i and j (1\r\nleq i,j\r\nleq n), and an integer x (1\r\nleq x\r\nleq a_i). Let i be the source index and j be the sink index. Decrease\r\nthe i-th element by x, and increase the j-th element by x. The resulting\r\nvalues at i-th and j-th index are a_i-x and a_j+x respectively. The cost\r\nof this operation is x\r\ncdot |j-i| . Now the i-th index can no longer be the sink and the j-th\r\nindex can no longer be the source. The total cost of a transformation is\r\nthe sum of all the costs in step 3.For example, array [0, 2, 3, 3] can\r\nbe transformed into a beautiful array [2, 2, 2, 2] with total cost 1\r\ncdot |1-3| + 1\r\ncdot |1-4| = 5.An array is called balanced, if it can be transformed\r\ninto a beautiful array, and the cost of such transformation is defined.\r\nIn other words, the minimum cost of transformation into a beautiful\r\narray equals the maximum cost.You are given an array a_1, a_2,\r\nldots, a_n of length n, consisting of non-negative integers. Your task\r\nis to find the number of balanced arrays which are permutations of the\r\ngiven array. Two arrays are considered different, if elements at some\r\nposition differ. Since the answer can be large, output it modulo 10^9 +\r\n7.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int N = 200010;\nconst int M = 200010;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nint f[N], invf[N];\nmap<int, int> mp;\nint c(int n, int k) {\n    return f[n] * 1ll * invf[k] % mod * invf[n - k] % mod;\n}\n\nvoid solve() {\n    int n;\n    scanf(\"%d\", &n);\n    long long sum = 0;\n    f[0] = 1;\n    for (int i = 1; i <= n; ++i) f[i] = f[i - 1] * 1ll * i % mod;\n    invf[0] = invf[1] = 1;\n    for (int i = 2; i <= n; ++i) invf[i] = (mod - invf[mod % i] * 1ll * (mod / i) % mod) % mod;\n    for (int i = 2; i <= n; ++i) invf[i] = invf[i - 1] * 1ll * invf[i] % mod;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i]);\n        sum += a[i];\n    }\n    if (sum % n != 0) {\n        puts(\"0\");\n        return;\n    }\n    sum /= n;\n    sort(a, a + n);\n    if (a[0] == sum) {\n        puts(\"1\");\n        return;\n    }\n    int cnt = 0, cnt2 = 0;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < sum) cnt++;\n        if (a[i] > sum) cnt2++;\n    }\n    if (cnt == 1 || cnt2 == 1) {\n        for (int i = 0; i < n; ++i) mp[a[i]]++;\n        int ans = 1;\n        for (auto it : mp) {\n            ans = ans * 1ll * c(n, it.second) % mod;\n            n -= it.second;\n        }\n        printf(\"%d\\n\", ans);\n        return;\n    }\n    int ans = c(n, n - cnt - cnt2);\n    for (int i = 0; i < n; ++i) mp[a[i]]++;\n    int ans2 = 1;\n    for (auto it : mp) {\n        if (it.first < sum) {\n            ans2 = ans2 * 1ll * c(cnt, it.second) % mod;\n            cnt -= it.second;\n        } else if (it.first > sum) {\n            ans2 = ans2 * 1ll * c(cnt2, it.second) % mod;\n            cnt2 -= it.second;\n        }\n    }\n    printf(\"%d\\n\", ans * 2ll * ans2 % mod);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cost Equilibrium.json",
    "editorial_link": "https://codeforces.com//blog/entry/89550",
    "editorial": "let = .The first and foremost condition is that , and the final values\r\nin the beautiful array will be equal to .Since a node cannot operate as\r\nboth, a source and a sink, therefore: Nodes with can only be the source\r\nvertices. Nodes with can only be the sink vertices. Nodes with with not\r\nbe used as a source or a sink. The given condition, condition holds when\r\nof the below condition holds: Number of source vertices are zero or one.\r\nNumber of sink vertices are zero or one. All the source vertices are\r\nbefore the sink vertices in the permutation. All the source vertices are\r\nafter the sink vertices in the permutation. denotes the factorial of .\r\nThus, the answer would be: If the number of source or sink is less than\r\nor equal to one, we need to consider all the unique permutations. where\r\nare frequencies of different values. Else, ways arranging source nodes\r\nwhere are frequencies of different values in source nodes. ways\r\narranging sink nodes where are frequencies of different values in sink\r\nnodes. ways filling identical values in places) = . We have an\r\nadditional factor of to cover the two possibilities: all sources before\r\nall sinks, and all sources after all sinks. The overall complexity of\r\nthe solution would be .\r\n",
    "hint": []
}