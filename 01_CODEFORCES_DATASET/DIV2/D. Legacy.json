{
    "link": "https://codeforces.com//contest/787/problem/D",
    "problemId": "99625",
    "problem_idx": "D",
    "shortId": "787D",
    "contest_number": "787",
    "problem_submissions": {
        "E": [
            25747805,
            25769219,
            25744553,
            26717332,
            25755415,
            25762542
        ],
        "B": [
            25745774,
            25737596,
            25738540,
            25745875,
            25737776,
            25744359,
            25738056,
            25737770,
            25738864,
            25741107,
            25738246,
            25737616,
            25739109,
            25738592,
            25739173,
            25738726,
            25737800,
            25737780,
            25738984,
            25738382
        ],
        "D": [
            25744630,
            25741896,
            25745115,
            25749718,
            25746276,
            25756806,
            25761778,
            25761748
        ],
        "C": [
            25741086,
            25747033,
            25750675,
            25741659,
            25745560,
            25745890,
            25749024,
            25741922,
            25743935,
            25744643,
            25745202,
            25745392,
            25745995,
            25746453,
            25745702,
            25745999,
            25746587
        ],
        "A": [
            25736581,
            25736552,
            25743791,
            25736575,
            25739966,
            25736705,
            25736522,
            25736956,
            25738154,
            25736876,
            25736540,
            25736830,
            25737058,
            25737179,
            25737189,
            25736539,
            25736641,
            25737439,
            25736572
        ]
    },
    "name": "D. Legacy",
    "statement": "Rick and his co-workers have made a new radioactive formula and a lot of\r\nbad guys are after them. So Rick wants to give his legacy to Morty\r\nbefore bad guys catch them. There are planets in their universe numbered\r\nfrom to . Rick is in planet number (the earth) and he doesn\u2019t know where\r\nMorty is. As we all know, Rick owns a portal gun. With this gun he can\r\nopen one-way portal from a planet he is in to any other planet\r\n(including that planet). But there are limits on this gun because he\u2019s\r\nstill using its free trial. By default he can not open any portal by\r\nthis gun. There are plans in the website that sells these guns. Every\r\ntime you purchase a plan you can only use it once but you can purchase\r\nit again if you want to use it more.Plans on the website have three\r\ntypes: With a plan of this type you can open a portal from planet to\r\nplanet . With a plan of this type you can open a portal from planet to\r\nany planet with index in range . With a plan of this type you can open a\r\nportal from any planet with index in range to planet . Rick doesn\u2019t\r\nknown where Morty is, but Unity is going to inform him and he wants to\r\nbe prepared for when he finds and start his journey immediately. So for\r\neach planet (including earth itself) he wants to know the minimum amount\r\nof money he needs to get from earth to that planet.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <utility>\nusing namespace std;\nconst int MAXN = 505050, MAXM = 8080808;\nconst long long oo = 1020304050607080ll;\nclass Edge\n{\npublic:\n\tint to, v, next;\n};\nEdge e[MAXM];\nint head[MAXN], en = 1, numtot;\nvoid insert(int u, int v, int w)\n{\n\te[++en].to = v;\n\te[en].v = w;\n\te[en].next = head[u];\n\thead[u] = en;\n}\nclass Segment_tree\n{\npublic:\n\tint st, ed, num;\n\tSegment_tree *l, *r;\n\tvoid build(int st_, int ed_)\n\t{\n\t\tst = st_;\n\t\ted = ed_;\n\t\tif(st == ed)\n\t\t{\n\t\t\tnum = st;\n\t\t\treturn;\n\t\t}\n\t\tnum = ++numtot;\n\t\tl = new Segment_tree();\n\t\tl->build(st, (st + ed) >> 1);\n\t\tr = new Segment_tree();\n\t\tr->build(((st + ed) >> 1) + 1, ed);\n\t}\n\tvoid work(int st_, int ed_, int to, int v, bool rev) const\n\t{\n\t\tif(st >= st_ && ed <= ed_)\n\t\t{\n\t\t\tif(rev)\n\t\t\t\tinsert(to, num, v);\n\t\t\telse\n\t\t\t\tinsert(num, to, v);\n\t\t\treturn;\n\t\t}\n\t\tif(l->ed >= st_)\n\t\t\tl->work(st_, ed_, to, v, rev);\n\t\tif(r->st <= ed_)\n\t\t\tr->work(st_, ed_, to, v, rev);\n\t}\n\tvoid dfs(bool tp) const\n\t{\n\t\tif(st == ed)\n\t\t\treturn;\n\t\tif(tp)\n\t\t{\n\t\t\tinsert(num, l->num, 0);\n\t\t\tinsert(num, r->num, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinsert(l->num, num, 0);\n\t\t\tinsert(r->num, num, 0);\n\t\t}\n\t\tl->dfs(tp);\n\t\tr->dfs(tp);\n\t}\n}*rt1, *rt2;\nint n, qq, s;\nlong long dist[MAXN];\npriority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > q;\nvoid dijkstra()\n{\n\tmemset(dist, 63, sizeof(dist));\n\tq.push(make_pair(dist[s] = 0, s));\n\twhile(!q.empty())\n\t{\n\t\tint now = q.top().second;\n\t\tif(dist[now] != q.top().first)\n\t\t{\n\t\t\tq.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tq.pop();\n\t\tfor(int i = head[now]; i > 0; i = e[i].next)\n\t\t\tif(dist[e[i].to] > dist[now] + e[i].v)\n\t\t\t\tq.push(make_pair(dist[e[i].to] = dist[now] + e[i].v, e[i].to));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &qq, &s);\n\tmemset(head, -1, sizeof(head));\n\tnumtot = n;\n\trt1 = new Segment_tree();\n\trt1->build(1, n);\n\trt1->dfs(true);\n\trt2 = new Segment_tree();\n\trt2->build(1, n);\n\trt2->dfs(false);\n\tfor(int i = 1; i <= qq; i++)\n\t{\n\t\tint t, v, l, r, w;\n\t\tscanf(\"%d\", &t);\n\t\tif(t == 1)\n\t\t{\n\t\t\tscanf(\"%d%d%d\", &v, &l, &w);\n\t\t\tinsert(v, l, w);\n\t\t}\n\t\telse if(t == 2)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", &v, &l, &r, &w);\n\t\t\trt1->work(l, r, v, w, true);\n\t\t}\n\t\telse if(t == 3)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", &v, &l, &r, &w);\n\t\t\trt2->work(l, r, v, w, false);\n\t\t}\n\t}\n\tdijkstra();\n\tfor(int i = 1; i <= n; i++)\n\t\tprintf(\"%I64d \", dist[i] > oo ? -1 : dist[i]);\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Legacy.json",
    "editorial_link": "https://codeforces.com//blog/entry/51163",
    "editorial": "Consider a weighted directed graph (initially it has n vertices and no edges). We will construct a segment tree to handle queries of second type (and one for the third type but with similar approach).\n\nBuild a segment tree on number 1,?...,?n. For each node of segment tree consider a vertex in the graph. For each leaf in this tree (like one with interval [l,?l?+?1)), add an edge with weight equal to 0 from vertex corresponding to this node to vertex l in the original graph. And for each non-leaf node, add an edge with weight equal to 0 from vertex corresponding to this node to the vertex corresponding to node of each of its children.\n\nSo we're adding about 4n vertices and edges to the graph. For each query of second type, we will add an edge from v to each maximal node of segment tree that [l,?r) contains (lg(n) nodes for each query) with weight equal to w.\n\nAnd construct a segment tree in the same way for queries of third type. Finally run Dijkstra's algorithm on this graph."
}