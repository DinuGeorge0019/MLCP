{
    "link": "https://codeforces.com//contest/761/problem/D",
    "problemId": "90961",
    "problem_idx": "D",
    "shortId": "761D",
    "contest_number": "761",
    "problem_submissions": {
        "E": [
            24312697,
            24311709,
            24310168,
            24311976,
            24311188,
            24315381,
            24312128,
            24315134,
            24315757,
            24315051,
            24311586,
            24318302,
            24316465,
            24310698,
            24314080,
            24317203,
            24314720,
            24307483,
            24315644,
            24308867
        ],
        "D": [
            24308080,
            24302806,
            24306764,
            24303840,
            24312711,
            24310952,
            24308712,
            24308632,
            24304486,
            24318361,
            24305083,
            24314765,
            24313344,
            24306662,
            24308564,
            24311519,
            24304640,
            24301778,
            24312201,
            24302140
        ],
        "C": [
            24304705,
            24303281,
            24303086,
            24315151,
            24314006,
            24300409,
            24305328,
            24308132,
            24307670,
            24308073,
            24301179,
            24311655,
            24307103,
            24301133,
            24303312,
            24299854,
            24299226,
            24307641,
            24303935
        ],
        "A": [
            24296943,
            24297317,
            24293268,
            24295355,
            24314899,
            24301549,
            24295024,
            24293258,
            24293478,
            24294436,
            24294254,
            24298618,
            24301924,
            24304008,
            24305575,
            24293046,
            24297813
        ],
        "B": [
            24295947,
            24297573,
            24299480,
            24314233,
            24314669,
            24296673,
            24301229,
            24303624,
            24311945,
            24304611,
            24297096,
            24300811,
            24301955,
            24297423,
            24296616,
            24298776,
            24296843,
            24310580,
            24301114,
            24295172
        ],
        "F": [
            24322841,
            24309197,
            24319670
        ]
    },
    "name": "D. Dasha and Very Difficult Problem",
    "statement": "Dasha logged into the system and began to solve problems. One of them is\r\nas follows:Given two sequences and of length each you need to write a\r\nsequence of length , the -th element of which is calculated as follows:\r\n.About sequences and we know that their elements are in the range from\r\nto . More formally, elements satisfy the following conditions: and .\r\nAbout sequence we know that all its elements are distinct. Dasha wrote a\r\nsolution to that problem quickly, but checking her work on the standard\r\ntest was not so easy. Due to an error in the test system only the\r\nsequence and the of the sequence were known from that test.Let’s give\r\nthe definition to a . A of sequence of length is a sequence of length ,\r\nso that equals to the number of integers which are less than or equal to\r\nin the sequence . For example, for the sequence the compressed sequence\r\nwill be . Pay attention that in all integers are distinct. Consequently,\r\nthe contains all integers from to inclusively.Help Dasha to find any\r\nsequence for which the calculated of sequence is correct.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == '-')\n\t\t\ts = -1, c = getChar();\n\t\twhile ('0' <= c && c <= '9')\n\t\t\tx = x * 10 + c - '0', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar('-'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)('0' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 2e5;\n\nint a[N], c[N], b[N];\n\nint main()\n{\n\tint n, l, r;\n\tn = readInt(), l = readInt(), r = readInt();\n\tfor (int i = 0; i < n; ++i)\n\t\ta[i] = -readInt();\n\tset <pair <int, int> > s;\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = readInt(),\n\t\ts.insert({ c[i], i });\n\tint cur = 0;\n\tauto it = s.begin();\n\tcur = a[it->second] + l;\n\tb[it->second] = l;\n\ts.erase(s.begin());\n\twhile (!s.empty())\n\t{\n\t\tit = s.begin(); \n\t\tint value = cur + 1;\n\t\tif (a[it->second] + r < value)\n\t\t{\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tint canput = max(value, a[it->second] + l);\n\t\tb[it->second] = canput - a[it->second];\n\t\ts.erase(s.begin());\n\t\tcur = canput;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\twriteInt(b[i], ' ');\n\twriteChar('\\n');\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Dasha and Very Difficult Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/50179",
    "editorial": "Letâs match each element of interval of values, which corresponding\r\nelement of could take, i.e for -th element interval . Let be the index\r\nof element equal to in permutation . Now you can know, that solving the\r\ninitial task is reduced to picking a number of each interval, so that\r\nthis numbers form an increasing sequence in order from to . It is easy\r\nto know that we can pick the numbers greedily, picking a number that is\r\ngreater than previous and belongs to current interval.\r\n",
    "hint": []
}