{"link": "https://codeforces.com//contest/1647/problem/F", "problemId": "1325140", "problem_idx": "F", "shortId": "1647F", "contest_number": "1647", "problem_submissions": {"E": [149328614, 149306053, 149316265, 149308258, 149317785, 149313427, 149312064, 149315761, 149304431, 149320349, 150085301, 150042558, 149322061, 149314157, 149320038, 149317712, 149323749, 150451628, 149317915, 149318394, 149323507, 149319981], "F": [149303385, 150083877], "D": [149287936, 149297042, 149288719, 149296838, 149289639, 149297770, 149297559, 149297568, 149315595, 149296805, 149293753, 149297523, 149298563, 149301837, 149303949, 149304702, 149307649, 149304812, 149312121], "C": [149278105, 149282014, 149279931, 149284899, 149279456, 149277016, 149284452, 149277474, 149269562, 149281799, 149285826, 149288910, 149285483, 149289384, 149282591, 149290109, 149289945, 149281141, 149290895], "B": [149272671, 149276622, 149275457, 149274250, 149274540, 149272438, 149278573, 149272028, 149276101, 149277049, 149276729, 149282060, 149280768, 149280254, 149275958, 149282515, 149283800, 149273253, 149287993], "A": [149265543, 149268740, 149264746, 149268469, 149267568, 149268599, 149267275, 149265283, 149267772, 149268479, 149269295, 149265276, 149269381, 149271464, 149267445, 149276391, 149271015, 149268133, 149268825]}, "name": "F. Madoka and Laziness", "statement": "Madoka has become too lazy to write a legend, so let\u2019s go straight to\r\nthe formal description of the problem.An array of integers a_1, a_2,\r\nldots, a_n is called a hill if it is not empty and there is an index i\r\nin it, for which the following is true: a_1 < a_2 <\r\nldots < a_i > a_{i + 1} > a_{i + 2} >\r\nldots > a_n.A sequence x is a subsequence of a sequence y if x can be\r\nobtained from y by deletion of several (possibly, zero or all) elements\r\nkeeping the order of the other elements. For example, for an array [69,\r\n1000, 228, -7] the array [1000, -7] is a subsequence, while [1] and [-7,\r\n1000] are not.Splitting an array into two subsequences is called good if\r\neach element belongs to exactly one subsequence, and also each of these\r\nsubsequences is a hill.You are given an array of positive integers a_1,\r\na_2,\r\nldots a_n. It is required to find the number of different pairs of\r\nmaxima of the first and second subsequences among all good splits. Two\r\npairs that only differ in the order of elements are considered same.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define f first\n#define s second\n//#define x first\n//#define y second\n//#define int li\n#define err if(debug_out)cout\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pld = pair<ld, ld>;\n\nconst int INF = 1e9 + 13;\nconst li INF64 = 1e18 + 13;\nconst int N = 3e5 + 13;\nconst int LOGN = 20;\nconst int K = 22;\nconst int M = 998244353;//1e9 + 7;\nconst int A = 26;\nconst ld eps = 1e-8;\n\nmt19937 rnd(45768);\n\n/*\n*/\n\nint sum(int a, int b) {\n    a += b;\n    return (a >= M ? a - M : a);\n}\n\nint mul(int a, int b) {\n    return a * 1ll * b % M;\n}\n\nint dif(int a, int b) {\n    return sum(a, M - b);\n}\n\nint pow2(int n, int k) {\n    if(k == 0)\n        return 1;\n\n    int pw = pow2(n, k / 2);\n    pw = mul(pw, pw);\n\n    return (k % 2 == 0 ? pw : mul(pw, n));\n}\n\n/*\n*/\n\nset<int> ans;\n\nvoid solve(int n, vector<int> a) {\n    int mx = 0;\n    for(int i = 0; i < n; i++)\n        if(a[i] > a[mx])\n            mx = i;\n\n    int mx2 = -1;\n    int pref = -1;\n    for(int i = 0; i < mx; i++) {\n        if(a[i] > pref) {\n            pref = a[i];\n        } else if(a[i] > mx2) {\n            mx2 = a[i];\n        } else\n            return;\n    }\n\n    vector<int> suf(n, INF);\n    suf[n - 1] = -1;\n    for(int i = n - 2; i > mx; i--) {\n        int x = a[i];\n        if(a[i] > a[i + 1])\n            suf[i] = min(suf[i], suf[i + 1]);\n        if(a[i] > suf[i + 1])\n            suf[i] = min(suf[i], a[i + 1]);\n    }\n\n    vector<pii> dp(n, pii(INF, -1));\n    dp[mx] = {mx2, -1};\n\n    for(int i = mx + 1; i < n; i++) {\n        if(a[i] < a[i - 1]) {\n            dp[i].f = min(dp[i].f, dp[i - 1].f);\n        }\n\n        if(a[i] < dp[i - 1].s) {\n            dp[i].f = min(dp[i].f, a[i - 1]);\n        }\n\n        if(a[i] > a[i - 1]) {\n            dp[i].s = max(dp[i].s, dp[i - 1].s);\n        }\n\n        if(a[i] > dp[i - 1].f) {\n            dp[i].s = max(dp[i].s, a[i - 1]);\n        }\n\n        if(dp[i].s > suf[i])\n            ans.insert(a[i]);\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    solve(n, a);\n    reverse(a.begin(), a.end());\n    solve(n, a);\n\n    cout << ans.size() << endl;\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy"], "dificulty": "3100", "interactive": false}