{
    "link": "https://codeforces.com//contest/1332/problem/F",
    "problemId": "578666",
    "problem_idx": "F",
    "shortId": "1332F",
    "contest_number": "1332",
    "problem_submissions": {
        "G": [
            74991585,
            75037266,
            77351427
        ],
        "F": [
            74972207,
            74968358,
            74971720,
            74973348,
            74978859,
            74982724,
            74982735,
            74986275,
            74983269,
            74987837,
            74986665,
            74991793,
            74983515,
            74979782,
            74972196,
            74981046,
            74990576,
            74985479,
            74988801,
            74990228
        ],
        "E": [
            74961161,
            74955523,
            74954162,
            74962710,
            74964351,
            74963597,
            74954423,
            74965477,
            74965579,
            74964400,
            74967235,
            74963711,
            74965887,
            74966494,
            74989155,
            74967207,
            74974070,
            74976881,
            74974061,
            74976693
        ],
        "D": [
            74952985,
            74945715,
            74946665,
            74947888,
            74950207,
            74948751,
            74939741,
            74946829,
            74947089,
            74946824,
            74948968,
            74945728,
            74948946,
            74959413,
            74956458,
            74959082,
            74952408,
            74962224,
            74953788,
            74952090
        ],
        "C": [
            74942005,
            74937624,
            74936343,
            74941037,
            74943187,
            74945247,
            74948388,
            74939023,
            74936776,
            74940250,
            74942517,
            74933392,
            74937059,
            74947682,
            74933984,
            74947387,
            74935824,
            74944324,
            74945827,
            74930594
        ],
        "B": [
            74937320,
            74934172,
            74933187,
            74935530,
            74936050,
            74936599,
            74943429,
            74933909,
            74931708,
            74932124,
            74935133,
            74939689,
            74933624,
            74939412,
            74938935,
            74936225,
            74945372,
            74938477,
            74936882,
            74941959
        ],
        "A": [
            74930167,
            74929341,
            74931394,
            74930114,
            74930077,
            74932449,
            74934529,
            74928977,
            74928761,
            74928547,
            74928820,
            74928500,
            74928970,
            74929648,
            74959446,
            74929583,
            74931416,
            74933421,
            74928735,
            74938510
        ]
    },
    "name": "F. Independent Set",
    "statement": "Eric is the teacher of graph theory class. Today, Eric teaches\r\nindependent set and edge-induced subgraph.Given a graph G=(V,E), an is a\r\nsubset of vertices V\u2019\r\nsubset V such that for every pair u,v\r\nin V\u2019, (u,v)\r\nnot\r\nin E (i.e. no edge in E connects two vertices from V\u2019).An consists of a\r\nsubset of edges E\u2019\r\nsubset E and all the vertices in the original graph that are incident on\r\nat least one edge in the subgraph.Given E\u2019\r\nsubset E, denote G[E\u2019] the edge-induced subgraph such that E\u2019 is the\r\nedge set of the subgraph. Here is an illustration of those definitions:\r\nIn order to help his students get familiar with those definitions, he\r\nleaves the following problem as an exercise:Given a tree G=(V,E),\r\ncalculate the sum of w(H) over all except null edge-induced subgraph H\r\nof G, where w(H) is the number of independent sets in H. Formally,\r\ncalculate\r\nsum\r\nlimits_{\r\nemptyset\r\nnot= E\u2019\r\nsubset E} w(G[E\u2019]).Show Eric that you are smarter than his students by\r\nproviding the correct answer as quickly as possible. Note that the\r\nanswer might be large, you should output the answer modulo 998,244,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\nconst int N = 3e5 + 5, M = N << 1, djq = 998244353;\n\nint n, ecnt, nxt[M], adj[N], go[M], f[N][2][2];\n\nvoid add_edge(int u, int v)\n{\n\tnxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;\n\tnxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;\n}\n\nvoid dfs(int u, int fu)\n{\n\tfor (int a = 0; a < 2; a++) for (int b = 0; b < 2; b++)\n\t\tf[u][a][b] = 1;\n\tint delta = 1;\n\tfor (int e = adj[u], v; e; e = nxt[e])\n\t\tif ((v = go[e]) != fu)\n\t\t{\n\t\t\tdfs(v, u);\n\t\t\tf[u][0][0] = 1ll * f[u][0][0] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0] + f[v][1][1]) % djq;\n\t\t\tf[u][1][0] = 1ll * f[u][1][0] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0] + f[v][1][1]) % djq;\n\t\t\tf[u][0][1] = 1ll * f[u][0][1] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0]) % djq;\n\t\t\tf[u][1][1] = 1ll * f[u][1][1] * (1ll * f[v][0][0] + f[v][0][1]\n\t\t\t\t+ f[v][1][0]) % djq;\n\t\t\tdelta = 1ll * delta * (f[v][0][0] + f[v][0][1]) % djq;\n\t\t}\n\tf[u][0][1] = (f[u][0][1] - delta + djq) % djq;\n}\n\nint main()\n{\n\tint x, y;\n\tread(n);\n\tfor (int i = 1; i < n; i++) read(x), read(y), add_edge(x, y);\n\tdfs(1, 0);\n\treturn std::cout << (1ll * f[1][0][0] + f[1][0][1] + djq - 1) % djq << std::endl, 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Independent Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/75432",
    "editorial": "We will call one vertice is colored if and only if it is in the\r\nindependent set. And a coloring is valid if and only if no two adjacent\r\nvertices are both colored.Therefore, we are asked to calculate the sum\r\nof number of valid colorings over all edge induced subgraphs.To deal\r\nwith the task, one should notice that for a edge induced subgraph and\r\none valid coloring, we may add those vertices which are removed due to\r\nthe generation of edge induced subgraph, and remain it\r\nuncolored.Therefore, for a coloring on the original graph , we could\r\nconsider removing edges such that it will behave the same with above\r\nprocedure.In fact, given a coloring, we can define edge removing is\r\nvalid if and only if there is no adjacent colored vertice and . We can\r\nactually show that there is almost a one to one corresponding relation\r\nbetweeen those two procedure except for the case where all vertices\r\nremains uncolored and all edges are removed.Therefore, we can actually\r\nsolve the following task:Given a tree , for any given coloring, define a\r\nedge removal is valid if it satisfies above constrains.And it will\r\nsuddenly becoming something easy to solve with tree dp. Define be the\r\nanswer for subtree rooted at with additional constraint such that is not\r\ncolored, be the answer where is colored and be the answer where edges\r\nfrom to its children are removed.Therefore, the dp formula should be The\r\nanswer is easily calculated with those three states.\r\n"
}