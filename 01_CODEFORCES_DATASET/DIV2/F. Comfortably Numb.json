{
    "link": "https://codeforces.com//contest/1777/problem/F",
    "problemId": "1746206",
    "problem_idx": "F",
    "shortId": "1777F",
    "contest_number": "1777",
    "problem_submissions": {
        "F": [
            189999253,
            189998361,
            189995169,
            190011490,
            190011116,
            190013769,
            190004003,
            190169577,
            190021489,
            190008226,
            190022277,
            190024196,
            190001976,
            190021500,
            190024711,
            190004961,
            190022857,
            190022045,
            190022993,
            190023276
        ],
        "E": [
            189990969,
            189994239,
            190006715,
            190001929,
            190054762,
            190054746,
            190004086,
            189987917,
            190017805,
            190001567,
            190021800,
            189999439,
            190005213,
            190019127,
            190007828,
            190009522,
            190469875,
            190020733,
            190022555,
            190013627,
            190011832,
            190008524,
            190011505
        ],
        "D": [
            189985748,
            189986829,
            189987429,
            189993541,
            189993926,
            189998094,
            189993119,
            189991582,
            189993898,
            189993229,
            189996303,
            190011551,
            189999620,
            189998025,
            189985279,
            189989471,
            190001136,
            190003775,
            189995371
        ],
        "C": [
            189982736,
            189982649,
            189981053,
            189986400,
            189987697,
            189986317,
            189985767,
            189986390,
            189987035,
            189982802,
            189983463,
            189984656,
            189988557,
            189987620,
            190014819,
            189984186,
            189995951,
            189999181,
            189985198
        ],
        "B": [
            189976042,
            189976916,
            189975827,
            189979459,
            189978444,
            189990271,
            189980176,
            189980492,
            189982493,
            189987295,
            189978177,
            189974359,
            189977682,
            189978251,
            190006967,
            189977343,
            189982864,
            189993219,
            189987444
        ],
        "A": [
            189973782,
            189974189,
            189973729,
            189974335,
            189974674,
            189974171,
            189975493,
            189974143,
            189973720,
            189987925,
            189975596,
            189973718,
            189975380,
            189974227,
            189988175,
            189973870,
            189975652,
            189992324,
            189990668
        ]
    },
    "name": "F. Comfortably Numb",
    "statement": "You are given an array a consisting of n non-negative integers.The of a\r\nsubarray a_l, a_{l+1},\r\nldots, a_r (for arbitrary l\r\nleq r) is defined as\r\nmax(a_l, a_{l+1},\r\nldots, a_r)\r\noplus (a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_r), where\r\noplus denotes the bitwise XOR operation.Find the maximum numbness over\r\nall subarrays.\r\n",
    "solutions": [
        "//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nvector<int> lg(2);\ntemplate <typename T> struct maxtable\n{\n\tvector<T> a;\n\tvector<vector<T>> st;\n\tmaxtable(const vector<T> &b) :a(all(b))\n\t{\n\t\tint n=a.size(),i,j,k,r;\n\t\twhile (lg.size()<=n) lg.push_back(lg[lg.size()>>1]+1);\n\t\tst.assign(lg[n]+1,vector<T>(n));\n\t\tiota(all(st[0]),0);\n\t\tfor (j=1; j<=lg[n]; j++)\n\t\t{\n\t\t\tr=n-(1<<j);\n\t\t\tk=1<<j-1;\n\t\t\tfor (i=0; i<=r; i++) st[j][i]=a[st[j-1][i]]<a[st[j-1][i+k]]?st[j-1][i+k]:st[j-1][i];\n\t\t}\n\t}\n\tT rmq(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn max(a[st[z][l]],a[st[z][r-(1<<z)+1]]);\n\t}\n\tint rmp(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn a[st[z][l]]<a[st[z][r-(1<<z)+1]]?st[z][r-(1<<z)+1]:st[z][l];\n\t}\n};\nconst int N=7e6+5;\nint c[N][2],s[N];\nint id;\nvoid insert(int &x,int y,int w,int dep)\n{\n\tx=++id; s[x]=s[y]+1;\n\tif (dep==-1) return;\n\tint o=w>>dep&1;\n\tc[x][o^1]=c[y][o^1];\n\tinsert(c[x][o],c[y][o],w,dep-1);\n}\nint ask(int x,int y,int w)\n{\n\tint r=0,o;\n\tfor (int i=29; i>=0; i--)\n\t{\n\t\to=1^w>>i&1;\n\t\tif (s[c[x][o]]==s[c[y][o]]) o^=1;\n\t\telse r|=1<<i;\n\t\tx=c[x][o]; y=c[y][o];\n\t}\n\treturn r;\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tfor (i=1; i<=id; i++) c[i][0]=c[i][1]=s[i]=0;\n\t\tcin>>n;\n\t\tvector<int> a(n+1),sum(n+1);\n\t\tfor (i=1; i<=n; i++) cin>>a[i];\n\t\t// for (i=1; i<=n; i++) a[i]=i;\n\t\tfor (i=1; i<=n; i++) sum[i]=sum[i-1]^a[i];\n\t\tvector<int> rt(n+1);\n\t\tid=0;\n\t\tfor (i=0; i<=n; i++) insert(rt[i],i==0?0:rt[i-1],sum[i],29);\n\t\tmaxtable t(a);\n\t\tint ans=0;\n\t\tfunction<void(int,int)> dfs=[&](int l,int r)\n\t\t{\n\t\t\tif (l>r) return;\n\t\t\tint m=t.rmp(l,r);\n\t\t\t//[l-1,m-1],[m,r]\n\t\t\tif (m-l<r-m)\n\t\t\t{\n\t\t\t\tfor (int i=l-1; i<=m-1; i++) cmax(ans,ask(rt[m-1],rt[r],sum[i]^a[m]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i=m; i<=r; i++) cmax(ans,ask(l==1?0:rt[l-2],rt[m-1],sum[i]^a[m]));\n\t\t\t}\n\t\t\tdfs(l,m-1); dfs(m+1,r);\n\t\t};\n\t\tdfs(1,n);\n\t\tcout<<ans<<'\\n';\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "divide and conquer",
        "strings",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Comfortably Numb.json",
    "editorial_link": "https://codeforces.com//blog/entry/111729",
    "editorial": "The problem can be solved recursively. Keep dividing the array into\r\nsubarrays at the maximum element of the current subarray. Letâs say the\r\nmaximum element of the initial array is at index , so the array gets\r\ndivided into two subarrays and . Say we have already calculated the\r\nanswer for the left and right subarrays. Now, we need to calculate the\r\nanswer for all the subarrays containing to complete the process for the\r\narray. To do this, we will maintain two separate tries for both the left\r\nand right parts. This trie will contain all the prefix xor values for\r\nall the indices in the respective part. We will iterate over the smaller\r\nsubarray out of the two. For every index, we will try to find the\r\nlargest answer that can be obtained from a subarray with one end at this\r\nindex. This can be done by moving the prefix xor value at the current\r\nindex (xorâed with ) over the âprefix xor trieâ of the other subarray.\r\nThis will cover all the subarrays containing , and so the entire array\r\nwill now get covered. After the process, we will merge the two tries\r\ninto one by again iterating over the smaller subarray.Similarly, we can\r\nsolve for left subarray and right subarray by finding their respective\r\nmaximum element, and dividing the subarray at that element.As we follow\r\nsmall-to-large merging, there are about operations on the trie, and so\r\nthe overall time complexity is .\r\n",
    "hint": [
        "Hint 1 Can we somehow fix the maximum element ?",
        "Hint 2 To calculate the answer over all subarrays with the same maximum element, can we use the trie trick for calculating the maximum xor."
    ]
}