{
    "link": "https://codeforces.com//contest/1191/problem/D",
    "problemId": "371221",
    "problem_idx": "D",
    "shortId": "1191D",
    "contest_number": "1191",
    "problem_submissions": {
        "E": [
            56930360,
            56932667,
            56928716,
            56939088,
            56921323,
            56912974,
            57115550,
            56932804,
            56928990,
            56929337
        ],
        "F": [
            56920637,
            56922296,
            56916787,
            56919049,
            56925732,
            56927861,
            56918099,
            56924133,
            56926209,
            56927829,
            56929051,
            56926532,
            56918795,
            56929264,
            56925632
        ],
        "D": [
            56909567,
            56895679,
            56907074,
            56908396,
            56910207,
            56924101,
            56908587,
            56910537,
            56910111,
            56912606,
            56912357,
            56914322,
            56913159,
            56915287,
            56927088,
            56914751,
            56910068,
            56910772
        ],
        "C": [
            56903274,
            56901059,
            56900847,
            56901577,
            56899620,
            56896966,
            56900160,
            56902858,
            56901879,
            56903244,
            56905051,
            56904771,
            56905406,
            56905745,
            56906709,
            56903940,
            56907892,
            56901275,
            56900697
        ],
        "B": [
            56898378,
            56936114,
            56896298,
            56896362,
            56892729,
            56894831,
            56896705,
            56898252,
            56898407,
            56897313,
            56900034,
            56899250,
            56894956,
            56901112,
            56898471,
            56900914,
            56897260,
            56894862
        ],
        "A": [
            56890181,
            56923779,
            56890755,
            56890634,
            56890043,
            56890012,
            56890112,
            56897182,
            56894935,
            56890461,
            56890221,
            56891378,
            56893934,
            56889978,
            56892226,
            56896066,
            56891166,
            56896868,
            56890375
        ]
    },
    "name": "D. Tokitsukaze, CSL and Stone Game",
    "statement": "Tokitsukaze and CSL are playing a little game of stones.In the\r\nbeginning, there are n piles of stones, the i-th pile of which has a_i\r\nstones. The two players take turns making moves. Tokitsukaze moves\r\nfirst. On each turn the player chooses a nonempty pile and removes\r\nexactly one stone from the pile. A player loses if all of the piles are\r\nempty before his turn, or if after removing the stone, two piles\r\n(possibly empty) contain the same number of stones. Supposing that both\r\nplayers play optimally, who will win the game?Consider an example: n=3\r\nand sizes of piles are a_1=2, a_2=3, a_3=0. It is impossible to choose\r\nthe empty pile, so Tokitsukaze has two choices: the first and the second\r\npiles. If she chooses the first pile then the state will be [1, 3, 0]\r\nand it is a good move. But if she chooses the second pile then the state\r\nwill be [2, 2, 0] and she immediately loses. So the only good move for\r\nher is to choose the first pile. Supposing that both players always take\r\ntheir best moves and never make mistakes, who will win the game?Note\r\nthat even if there are two piles with the same number of stones at the\r\nbeginning, Tokitsukaze may still be able to make a valid first move. It\r\nis only necessary that there are no two piles with the same number of\r\nstones after she moves.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 100005;\n\nint n,a[N];\n\nint main() {\n\n\tn=read(); rep(i,1,n) a[i]=read();\n\tsort(a+1,a+n+1);\n\tint num=0,pos;\n\trep(i,1,n-1) if (a[i]==a[i+1]) num++,pos=i;\n\tif (num>=2) puts(\"cslnb\");\n\telse if (num==0) {\n\t\tLL sum=0,aim=(LL)n*(LL)(n-1)/2;\n\t\trep(i,1,n) sum+=(LL)a[i];\n\t\tif ((sum-aim)&1) puts(\"sjfnb\");\n\t\telse puts(\"cslnb\");\n\t} else {\n\t\tif (a[pos]==0) puts(\"cslnb\");\n\t\telse {\n\t\t\tif (pos==1||a[pos-1]!=a[pos]-1) {\n\t\t\t\tLL sum=0,aim=(LL)n*(LL)(n-1)/2;\n\t\t\t\trep(i,1,n) sum+=(LL)a[i];\n\t\t\t\tif ((sum-aim)&1) puts(\"sjfnb\");\n\t\t\t\telse puts(\"cslnb\");\n\t\t\t} else puts(\"cslnb\");\n\t\t}\n\t}\n\n\n\treturn 0;\n\t\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tokitsukaze, CSL and Stone Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/68314",
    "editorial": "TutorialUnless the first player must lose after the first move, the\r\nnumbers of stones in these piles should form a permutation obtained from\r\nto in the end, in order to ensure that there are no two piles include\r\nthe same number of stones.Letâs use to represent the number of piles\r\nwhich have exactly stones in the beginning. There are four cases that\r\nTokitsukaze will lose after the first move: ; for some ; and for some ,\r\n(); and for some . If Tokitsukaze wonât lose after the first move, then\r\nwe only need to check the parity of the total number of stones that can\r\nbe taken.By the way, if you donât want to discuss the above four cases,\r\nyou can just enumerate her first move.\r\n",
    "hint": []
}