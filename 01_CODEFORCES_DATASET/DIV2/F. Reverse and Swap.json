{
    "link": "https://codeforces.com//contest/1401/problem/F",
    "problemId": "704918",
    "problem_idx": "F",
    "shortId": "1401F",
    "contest_number": "1401",
    "problem_submissions": {
        "E": [
            90589999,
            90578154,
            90605920,
            90584030,
            90594969,
            90593911,
            90572580,
            90599304,
            90615088,
            90675249,
            90605781,
            90590132,
            90599391,
            90594214,
            90758857,
            90645951,
            90601216
        ],
        "F": [
            90580393,
            90597215,
            90579684,
            90610107,
            90603479,
            90603116,
            90603512,
            90617786,
            90601646,
            90675259,
            90613571,
            90583132,
            90589402,
            90594866,
            90604055,
            90620941,
            90598510,
            90646625
        ],
        "D": [
            90560258,
            90565538,
            90550432,
            90567225,
            90569423,
            90571869,
            90587693,
            90567049,
            90578884,
            90577112,
            90563897,
            90566957,
            90557267,
            90573179,
            90565326,
            90564972,
            90565503,
            90568268,
            90571582
        ],
        "C": [
            90551509,
            90552981,
            90554787,
            90547352,
            90555070,
            90559549,
            90607672,
            90556632,
            90562455,
            90568524,
            90549734,
            90553714,
            90548534,
            90548686,
            90550222,
            90543917,
            90550988,
            90557805,
            90555836
        ],
        "B": [
            90546499,
            90547295,
            90558760,
            90542536,
            90550631,
            90551851,
            90549294,
            90545681,
            90553940,
            90549432,
            90563346,
            90548659,
            90544907,
            90558972,
            90545692,
            90550414,
            90545438,
            90550179,
            90547970
        ],
        "A": [
            90541721,
            90542770,
            90541219,
            90541087,
            90544810,
            90561361,
            90543645,
            90541402,
            90544925,
            90541955,
            90542350,
            90543732,
            90541094,
            90542063,
            90541725,
            90541822,
            90542174,
            90542376,
            90542708
        ]
    },
    "name": "F. Reverse and Swap",
    "statement": "You are given an array a of length 2^n. You should process q queries on\r\nit. Each query has one of the following 4 types: Replace(x, k) change\r\na_x to k; Reverse(k) reverse each subarray [(i-1)\r\ncdot 2^k+1, i\r\ncdot 2^k] for all i (i\r\nge 1); Swap(k) swap subarrays [(2i-2)\r\ncdot 2^k+1, (2i-1)\r\ncdot 2^k] and [(2i-1)\r\ncdot 2^k+1, 2i\r\ncdot 2^k] for all i (i\r\nge 1); Sum(l, r) print the sum of the elements of subarray [l, r]. Write\r\na program that can quickly process given queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MAX = 18;\nint n, q, rev[MAX+1], sw[MAX+1];\nll sum[1<<MAX+1];\n\nvoid op1(int l1, ll a, int i=1, int k=n, int l2=0, int r2=(1<<n)-1) {\n\tif(l2==r2) {\n\t\tsum[i]=a;\n\t\treturn;\n\t}\n\tint m2=(l2+r2) / 2;\n\tif(rev[k]&1) {\n\t\tl1=r2-(l1-l2);\n\t}\n\tif(sw[k]&1) {\n\t\tif(l1<=m2) {\n\t\t\tl1+=m2+1-l2;\n\t\t} else {\n\t\t\tl1-=m2+1-l2;\n\t\t}\n\t}\n\tif(l1<=m2) {\n\t\top1(l1, a, 2*i, k-1, l2, m2);\n\t} else {\n\t\top1(l1, a, 2*i+1, k-1, m2+1, r2);\n\t}\n\tsum[i]=sum[2*i]+sum[2*i+1];\n}\n\nll op4(int r1, int i=1, int k=n, int l2=0, int r2=(1<<n)-1) {\n\tif(r1<l2) {\n\t\treturn 0;\n\t}\n\tif(r2<=r1) {\n\t\treturn sum[i];\n\t}\n\tint m2=(l2+r2) / 2;\n\tll init=0, f=1;\n\tif(rev[k]&1) {\n\t\tr1=r2-(r1-l2)-1;\n\t\tinit=sum[i];\n\t\tf=-1;\n\t}\n\tif(sw[k]&1) {\n\t\tinit+=f*(op4(r1-(m2+1-l2), 2*i, k-1, l2, m2)+op4(r1+(m2+1-l2), 2*i+1, k-1, m2+1, r2));\n\t} else {\n\t\tinit+=f*(op4(r1, 2*i, k-1, l2, m2)+op4(r1, 2*i+1, k-1, m2+1, r2));\n\t}\n\treturn init;\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n >> q;\n\tfor(int i=0; i<1<<n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\top1(i, a);\n\t}\n\n\twhile(q--) {\n\t\tint type;\n\t\tcin >> type;\n\t\tif(type==1) {\n\t\t\tint x, k;\n\t\t\tcin >> x >> k;\n\t\t\top1(x-1, k);\n\t\t} else if(type==2) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\trev[k]+=1;\n\t\t} else if(type==3) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tsw[k+1]+=1;\n\t\t} else if(type==4) {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r, --l, --r;\n\t\t\t//cout << op4(r) << \" \" << op4(l-1) << \"\\n\";\n\t\t\tcout << op4(r)-op4(l-1) << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Reverse and Swap.json",
    "editorial_link": "https://codeforces.com//blog/entry/81700",
    "editorial": "Let\u00e2\u0080\u0099s consider the sequence as -based. Then we can find the following\r\ntwo facts: If we do operation once, becomes . If we do operation once,\r\nbecomes So in any state there is an integer that makes the current equal\r\nto the initial and current is equal to the initial for each (). (Don\u00e2\u0080\u0099t\r\nconsider the change of the values by operation.)Therefore, if we can\r\ncalculate fast for arbitrary , also can solve the problem, and it can be\r\ndone using segment tree. When processing queries, replace as . And when\r\nprocessing or queries, just replace as or .And queries are left. To\r\ncalculate this value, divide the segment into smaller segments, in which\r\nlength of each segment is power of and can be found in the segment tree.\r\n(ex : segment is divided into three segments - , , )Next, find the sum\r\nof numbers in which index is in each segment. For divided segment in\r\nwhich length is , the values are, when sorted, form another segment ,\r\nwhich means the largest of multiples of not greater than . So you can\r\nfind the sum of numbers in each divided segment (current ) as (initial\r\n). Repeat this and we can find the answer for each query.Time complexity\r\n:\r\n"
}