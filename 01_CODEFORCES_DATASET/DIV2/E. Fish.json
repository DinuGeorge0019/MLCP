{"link": "https://codeforces.com//contest/16/problem/E", "problemId": "76", "problem_idx": "E", "shortId": "16E", "contest_number": "16", "problem_submissions": {"E": [70472, 70287, 71317, 71555, 71009, 2823445, 70557, 71514, 71526, 71256, 71545, 71259, 70518, 71999, 73011], "D": [70195, 70680, 70666, 70921, 71632, 2869290, 71074, 70915, 71037, 71486, 70532, 71544, 71595, 70760], "C": [69769, 69933, 69973, 70337, 70580, 70313, 70299, 72753, 70416, 70325, 69894, 70966, 71276, 70125], "B": [69600, 69688, 69697, 69888, 69866, 69936, 69851, 69883, 69690, 70057, 69594, 70701, 69726, 69706], "A": [69453, 69471, 69475, 69541, 69630, 69660, 69596, 69456, 69746, 69452, 71841, 69827, 69528, 69489]}, "name": "E. Fish", "statement": "fish, numbered from to , live in a lake. Every day right one pair of\r\nfish meet, and the probability of each other pair meeting is the same.\r\nIf two fish with indexes i and j meet, the first will eat up the second\r\nwith the probability , and the second will eat up the first with the\r\nprobability . The described process goes on until there are at least two\r\nfish in the lake. For each fish find out the probability that it will\r\nsurvive to be the last in the lake.\r\n", "solutions": ["#include <algorithm> \n#include <iostream> \n#include <sstream> \n#include <string> \n#include <vector> \n#include <queue> \n#include <set> \n#include <map> \n#include <cstdio> \n#include <cstdlib> \n#include <cctype> \n#include <cmath> \n#include <list> \nusing namespace std; \n\n#define PB push_back \n#define MP make_pair \n#define SZ(v) ((int)(v).size()) \n#define FOR(i,a,b) for(int i=(a);i<(b);++i) \n#define REP(i,n) FOR(i,0,n) \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i) \n#define REPE(i,n) FORE(i,0,n) \n#define FORSZ(i,a,v) FOR(i,a,SZ(v)) \n#define REPSZ(i,v) REP(i,SZ(v)) \ntypedef long long ll; \n\nvoid run() {\n\tint n; scanf(\"%d\",&n);\n\tvector<vector<double> > a(n,vector<double>(n));\n\tREP(i,n) REP(j,n) scanf(\"%lf\",&a[i][j]);\n//\tprintf(\"%d\\n\",n); REP(i,n) { REP(j,n) printf(\"%4lf \",a[i][j]); puts(\"\"); }\n\tvector<double> p((1<<n),0);\n\tp[(1<<n)-1]=1;\n\tfor(int i=(1<<n)-1;i>=0;--i) {\n\t\tint cnt=0; REP(j,n) if(i&(1<<j)) ++cnt;\n\t\tREP(j,n) if(i&(1<<j)) FOR(k,j+1,n) if(i&(1<<k)) {\n\t\t\tp[i-(1<<j)]+=a[k][j]*p[i]/(cnt*(cnt-1)/2);\n\t\t\tp[i-(1<<k)]+=a[j][k]*p[i]/(cnt*(cnt-1)/2);\n\t\t}\n\t}\n\tREP(i,n) { if(i!=0) printf(\" \"); printf(\"%.6lf\",p[1<<i]); } printf(\"\\n\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp", "probabilities"], "dificulty": "1900", "interactive": false}