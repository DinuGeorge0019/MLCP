{
    "link": "https://codeforces.com//contest/1715/problem/D",
    "problemId": "1513952",
    "problem_idx": "D",
    "shortId": "1715D",
    "contest_number": "1715",
    "problem_submissions": {
        "F": [
            169148274,
            169155365,
            169130889,
            169155985,
            169108945,
            169574810,
            169163231,
            169141940,
            169196708
        ],
        "E": [
            169127780,
            169131038,
            169118368,
            169119601,
            169121517,
            169134266,
            169131152,
            169132329,
            169132606,
            169133682,
            169162968,
            169135131,
            169132730,
            169135556,
            169141593,
            169136787,
            169114950,
            169142196,
            169141933,
            169141598
        ],
        "D": [
            169113859,
            169112143,
            169123073,
            169198160,
            169109801,
            169126906,
            169218994,
            169116160,
            169193819,
            169119863,
            169123507,
            169122322,
            169117695,
            169108158,
            169121681,
            169123192,
            169123408,
            169275333,
            169121118,
            169125621,
            169118823,
            169120372,
            169123621,
            169124629
        ],
        "C": [
            169107451,
            169103179,
            169137078,
            169101370,
            169129288,
            169102686,
            169112899,
            169107306,
            169108346,
            169113649,
            169121461,
            169112477,
            169108680,
            169197238,
            169116719,
            169112431,
            169195068,
            169118011,
            169144372,
            169114599,
            169111934,
            169113718
        ],
        "B": [
            169102135,
            169098162,
            169135707,
            169097670,
            169093858,
            169101514,
            169098876,
            169101987,
            169101035,
            169096282,
            169099222,
            169103628,
            169099009,
            169100124,
            169100205,
            169104726,
            169103909,
            169104946,
            169099294
        ],
        "A": [
            169092934,
            169092062,
            169134952,
            169093933,
            169091995,
            169093151,
            169092986,
            169094481,
            169092501,
            169092283,
            169092715,
            169094922,
            169093338,
            169093831,
            169094306,
            169125908,
            169096348,
            169096156,
            169094226
        ]
    },
    "name": "D. 2+ doors",
    "statement": "The Narrator has an integer array a of length n, but he will only tell\r\nyou the size n and q statements, each of them being three integers i, j,\r\nx, which means that a_i\r\nmid a_j = x, where | denotes the bitwise OR operation.Find the\r\nlexicographically smallest array a that satisfies all the statements.An\r\narray a is lexicographically smaller than an array b of the same length\r\nif and only if the following holds: in the first position where a and b\r\ndiffer, the array a has a smaller element than the corresponding element\r\nin b.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n\tint x;\n\tscanf(\"%d\",&x);\n\treturn x;\n}\nconst int N=2e5+5;\nint n,q;\nint lst[N],to[N],nxt[N],len[N],ec;\ninline void ae(int x,int y,int z){\n\tto[++ec]=y,nxt[ec]=lst[x],len[ec]=z,lst[x]=ec;\t\n}\nint mark[N];\nint ans[N];\nvoid solve(int k){\n\tfill(mark+1,mark+n+1,-1);\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\tint y=to[i];\n\t\t\tif((len[i]&1<<k)==0)mark[x]=mark[y]=0;\t\n\t\t}\n\t}\n\tfor(int x=1;x<=n;x++){\n\t\tif(mark[x]==1)continue;\n\t\tbool flag=1;\n\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\tif((len[i]&1<<k)==0)continue;\n\t\t\tint y=to[i];\n\t\t\tif(mark[y]==0)flag=0;\n\t\t}\n\t\tif(!flag)mark[x]=1;\n\t\telse{\n\t\t\tmark[x]=0;\n\t\t\tfor(int i=lst[x];i;i=nxt[i]){\n\t\t\t\tif((len[i]&1<<k)==0)continue;\n\t\t\t\tint y=to[i];\n\t\t\t\tmark[y]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)if(mark[i])ans[i]|=1<<k;\n}\nint main(){\n\tn=in(),q=in();\n\twhile(q--){\n\t\tint x=in(),y=in(),z=in();\n\t\tif(x>y)swap(x,y);\n\t\tae(x,y,z);\t\n\t}\n\tfor(int i=0;i<30;i++)solve(i);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "bitmasks",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. 2+ doors.json",
    "editorial_link": "https://codeforces.com//blog/entry/104261",
    "editorial": "The first observation is that we can solve the task separately bit by\r\nbit, because of bitwise or operation is \"bit-independent\": bits of one\r\nparticular power donât affect other bits to gen a lexicographically\r\nminimal solution, we can combine solutions for each bit separately This\r\nmakes it possible for us to create a solution for a boolean array, and\r\nthen run it times for all numbers and statements, considering only -th\r\nbit in each run.For ease of understanding letâs speak in a language of\r\ngraphs: we have an undirected graph with vertices, on each vertex, there\r\nis either or , and on each edge, there is a bitwise or of numbers, that\r\nare written on vertices connected by that edge. We have to recover the\r\nnumbers on the vertices after they were somehow lost, knowing, that\r\nnumbers on the vertices create a lexicographically minimal sequence\r\npossible.Initially, letâs write on each of the vertices. Then walk\r\nthrough them and consider incidental edges. If any of the edges contain\r\n, we must also write on our current vertex and the neighbor by that\r\nedge. After zeroing all the required vertices, letâs try to make our\r\nsequence lexicographically minimal. Walk through the vertices again and\r\ntry to write on each: to check if everything is ok, iterate over the\r\nincidental edges again. If any of them contains and connects us with a\r\nvertex with , then we cannot make our vertex . Such solution works in\r\ntime.For a better understanding and more details, we suggest you look\r\nover the authorsâ solutions.\r\n",
    "hint": [
        "Hint #1 We can solve the task separately by bits.",
        "Hint #2 What are the most useful conditions? Those, that state that bitwise or of some bits in -th and -th numbers is because we can null both of these bits for sure.",
        "Hint #3 Solve the task separately by bits. Firstly, satisfy conditions from the second hint, then try to null the bits from the beginning."
    ]
}