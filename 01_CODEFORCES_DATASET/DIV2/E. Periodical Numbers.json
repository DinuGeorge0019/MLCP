{"link": "https://codeforces.com//contest/215/problem/E", "problemId": "1596", "problem_idx": "E", "shortId": "215E", "contest_number": "215", "problem_submissions": {"E": [1988426, 1988413, 1989426, 1987138, 1988487, 1984276], "D": [1986997, 1985615, 1985958, 1986118, 1984659, 1984383, 1985972, 1986126, 1986307, 1984613, 1988881, 1988871, 1989546, 1987659, 1983883], "C": [1986856, 1984272, 1983953, 1984682, 1985985, 1986019, 1984687, 1984757, 1985135, 1984027, 1984854, 1984906, 1984541, 1984950, 1985064, 1985527], "B": [1982023, 1982547, 1982033, 1981911, 1982756, 1983055, 1982575, 1982679, 1982354, 1982420, 1982182, 1982502, 1981865, 1982128, 1983569, 1982637, 1982851, 1982669], "A": [1980998, 1981260, 1981033, 1981084, 1981265, 1981202, 1981211, 1981385, 1981158, 1981203, 1981153, 1981321, 1980992, 1981069, 1982692, 1981261, 1980948, 1981122, 1981152]}, "name": "E. Periodical Numbers", "statement": "A non-empty string is called , if it consists only of characters \"\" and\r\n\"\". Let\u2019s number the characters of binary string from 1 to the string\u2019s\r\nlength and let\u2019s denote the -th character in string as .Binary string\r\nwith length is , if there is an integer such that: is a divisor of\r\nnumber for all , the following condition fulfills: For example, binary\r\nstrings \"101010\" and \"11\" are periodical and \"10\" and \"10010\" are not.A\r\npositive integer is , if its binary representation (without leading\r\nzeroes) is a periodic string.Your task is to calculate, how many\r\nperiodic numbers are in the interval from to (both ends are included).\r\n", "solutions": ["#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint prime[100],flag[100],num,u[100];\nlong long cal(long long x,int n)\n{\n    long long temp,ans=0,sum;\n    for(int i=1;i<n;i++)\n    if(n%i==0)\n    {\n        temp=x>>(n-i);\n        sum=0;\n        for(int j=0;j<n/i;j++)sum+=1LL<<(j*i);\n        sum*=temp;\n        if(sum>x)temp--;\n        temp=temp-(1LL<<(i-1))+1;\n        ans-=temp*u[n/i];\n    }\n    return ans;\n}\nlong long solve(long long n)\n{\n    long long A=0;\n    for(int i=1;(1LL<<(i-1))<=n;i++)\n    A+=cal(min((1LL<<i)-1,n),i);\n    return A;\n}\nint main()\n{\n    u[1]=1;\n    for(int i=2;i<100;i++)\n    {\n        if(!flag[i])prime[++num]=i,u[i]=-1;\n        for(int j=1;j<=num&&i*prime[j]<100;j++)\n        {\n            flag[i*prime[j]]=1;\n            if(i%prime[j]==0)break;\n            else u[i*prime[j]]=-u[i];\n        }\n    }\n    long long l,r;\n    while(~scanf(\"%I64d %I64d\",&l,&r))\n    printf(\"%I64d\\n\",solve(r)-solve(l-1));\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "number theory"], "dificulty": "2100", "interactive": false}