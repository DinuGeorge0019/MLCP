{
    "link": "https://codeforces.com//contest/358/problem/E",
    "problemId": "3808",
    "problem_idx": "E",
    "shortId": "358E",
    "contest_number": "358",
    "problem_submissions": {
        "E": [
            4889715,
            4889265,
            4888936,
            4885014
        ],
        "D": [
            4886230,
            4884597,
            4886065,
            4886102,
            4887047,
            4885262,
            4886058,
            4889330,
            4888287,
            4889122,
            4884736,
            4887257,
            4890403,
            4886697,
            4887096,
            4889295,
            4888527,
            4887412,
            4885636
        ],
        "C": [
            4885109,
            4886954,
            4891424,
            4885421,
            4888165,
            4889963,
            4886269,
            4889009,
            4887295,
            4888075,
            4890489,
            4887470,
            4890195,
            4890011,
            4887260,
            4890178,
            4884373
        ],
        "B": [
            4882466,
            4881745,
            4881543,
            4888752,
            4888613,
            4882959,
            4882359,
            4882560,
            4883488,
            4883313,
            4882506,
            4883848,
            4881903,
            4883587,
            4883338,
            4882307,
            4882280,
            4890873,
            4882809
        ],
        "A": [
            4880868,
            4894891,
            4880938,
            4889684,
            4881359,
            4881277,
            4880937,
            4881564,
            4882155,
            4881794,
            4891559,
            4881953,
            4880986,
            4882605,
            4882019,
            4881030,
            4881035,
            4881111,
            4881523
        ]
    },
    "name": "E. Dima and Kicks",
    "statement": "Dima is a good person. In fact, he\u2019s great. But all good things come to\r\nan end...Seryozha is going to kick Dima just few times.. For this reason\r\nhe divides the room into unit squares. Now the room is a rectangle\r\nconsisting of unit squares.For the beginning, Seryozha put Dima in a\r\ncenter of some square. Then he started to kick Dima (it is known, that\r\nhe kicks Dima at least once). Each time when Dima is kicked he flyes up\r\nand moves into one of four directions (up, left, right, down). On each\r\nmove Dima passes unit of the length in the corresponding direction.\r\nSeryozha is really kind, so he kicks Dima in such way that Dima never\r\nmeets the walls (in other words, Dima never leave the room\u2019s space).\r\nSeryozha is also dynamic character so Dima never flies above the same\r\nsegment, connecting a pair of adjacent squares, twice.Seryozha kicks\r\nDima for a long time, but Dima is not vindictive Dima writes. Dima\r\nmarked all squares in which he was staying or above which he was flying.\r\nThanks to kicks, Dima does not remember the value, so he asks you to\r\nfind all possible values which matches to the Dima\u2019s records.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define FI first\n#define SE second\n#define MP make_pair\n#define PII pair<int,int>\n#define flt double\n#define INF (0x3f3f3f3f)\n#define MaxN 1020300\n#define MaxNode 1020304\n#define MD 1000000007\n#define UPD(a,b) { a = max(a,(b)); }\n\nconst int pi[] = {0,1,0,-1};\nconst int pj[] = {1,0,-1,0};\n\nint n,m,A[1111][1111],u[1111][1111],l[1111][1111],vis[1111][1111];\nint can[6];\nPII q[MaxN];\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tcin >> n >> m;\n\tFill(A,0);\n\tFor(i,1,n) For(j,1,m) scanf(\"%d\",&A[i][j]);\n\tFill(vis,0); int cnt = 0; \n\tFor(i,1,n) For(j,1,m) if (!vis[i][j] && A[i][j] == 1) {\n\t\t++cnt;\n\t\tint hd = 0, tl = 1;\n\t\tvis[i][j] = true; q[1] = MP(i,j);\n\t\twhile (hd < tl) {\n\t\t\tPII vex = q[++hd];\n\t\t\tFor(p,0,3) {\n\t\t\t\tint ni = vex.FI + pi[p], nj = vex.SE + pj[p];\n\t\t\t\tif (!vis[ni][nj] && ni && nj && ni <= n && nj <= m && A[ni][nj] == 1) {\n\t\t\t\t\tvis[ni][nj] = true;\n\t\t\t\t\tq[++tl] = MP(ni,nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt > 1) {\n\t\tputs(\"-1\"); return 0;\n\t}\n\tint odd = 0,GCD = 0;\n\tFor(i,1,n) For(j,1,m) {\n\t\tif (!A[i][j]) {\n\t\t\tl[i][j] = u[i][j] = 0; continue ;\n\t\t}\n\t\tl[i][j] = l[i][j - 1] + 1;\n\t\tu[i][j] = u[i - 1][j] + 1;\n\t\tFill(can,0);\n\t\tint sm = 0;\n\t\tFor(p,0,3) {\n\t\t\tint ni = i + pi[p], nj = j + pj[p];\n\t\t\tif (A[ni][nj]) can[p] = true;\n\t\t\tsm += can[p];\n\t\t}\n\t\tif (sm == 2 && ((can[0] && can[2]) || (can[1] && can[3]))) continue ;\n\t\todd += sm & 1;\n\t\tGCD = __gcd(GCD,l[i][j] - 1);\n\t\tGCD = __gcd(GCD,u[i][j] - 1);\n\t}\n\tif (GCD <= 1 || (odd != 0 && odd != 2)) {\n\t\tputs(\"-1\"); return 0;\n\t}\n\tFor(i,2,max(n,m)) if (GCD % i == 0) printf(\"%d \",i); puts(\"\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dsu",
        "graphs",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Dima and Kicks.json",
    "editorial_link": "https://codeforces.com/blog/entry/9334",
    "editorial": "The first thing to understand is that the answer is the\ndivisor of maximal-length sequence of standing one by one ones. Let s\niterate trough this number. Now we should check the table knowing the\nvalue of . Let s find the most left of ones, and choose from them the\nmost top. Let it be . then after each step Dima can appear inly in cells\nwhich look like: . Let such cells are the vertexes of the graph. And\nsequences of ones the ribs. We will build the graph. We should check\nthat there are no additional ones in table. We should also check if the\ngraph is connected and has en Euler s path. The value of K is the next\nanswer under the all conditions. The correct implementation will have\nthe complexity . In reality it will be never achieved.\n"
}