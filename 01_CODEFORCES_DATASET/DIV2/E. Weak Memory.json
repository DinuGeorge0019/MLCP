{
    "link": "https://codeforces.com//contest/189/problem/E",
    "problemId": "1320",
    "problem_idx": "E",
    "shortId": "189E",
    "contest_number": "189",
    "problem_submissions": {
        "E": [
            1678506,
            1678460,
            1678211,
            1678693,
            1677477,
            1677700,
            1680381,
            1677887,
            1678428,
            1681566
        ],
        "D": [
            1676682,
            1676035,
            1677096,
            1677898,
            1674240,
            1680791,
            1676256,
            1676755,
            1676792,
            1677405,
            1676745,
            1676612,
            1677482,
            1677225,
            1676566
        ],
        "C": [
            1674208,
            1675081,
            1675273,
            1676086,
            1673529,
            1673748,
            1674530,
            1675036,
            1674970,
            1674691,
            1674910,
            1675504,
            1675160,
            1673957,
            1675084,
            1674909
        ],
        "B": [
            1673360,
            1673410,
            1674214,
            1674813,
            1672769,
            1673156,
            1673373,
            1673917,
            1674026,
            1673370,
            1673358,
            1672790,
            1673649,
            1674219,
            1672936,
            1673608,
            1675358
        ],
        "A": [
            1672718,
            1672777,
            1673274,
            1672957,
            1672602,
            1672581,
            1672722,
            1673173,
            1673083,
            1672709,
            1672650,
            1672579,
            1672834,
            1672816,
            1674499,
            1672796,
            1672817
        ]
    },
    "name": "E. Weak Memory",
    "statement": "is qualified for ICPC World Finals in Harbin, China. After team\r\nexcursion to Sun Island Park for snow sculpture art exposition, PMP\r\nshould get back to buses before they leave. But the park is really big\r\nand he does not know how to find them.The park has intersections\r\nnumbered through . There are bidirectional roads that connect some pairs\r\nof these intersections. At intersections, ICPC volunteers are helping\r\nthe teams and showing them the way to their destinations. Locations of\r\nvolunteers are fixed and distinct.When PMP asks a volunteer the way to\r\nbus station, he/she can tell him the whole path. But the park is fully\r\ncovered with ice and snow and everywhere looks almost the same. So PMP\r\ncan only memorize at most intersections after each question (excluding\r\nthe intersection they are currently standing). He always tells\r\nvolunteers about his weak memory and if there is no direct path of\r\nlength (in number of roads) at most that leads to bus station, the\r\nvolunteer will guide PMP to another volunteer (who is at most\r\nintersections away, of course). ICPC volunteers know the area very well\r\nand always tell PMP the best way. So if there exists a way to bus\r\nstations, PMP will definitely find it.PMP’s initial location is\r\nintersection and the buses are at intersection . There will always be a\r\nvolunteer at intersection . Your job is to find out the minimum which\r\nguarantees that PMP can find the buses.\r\n",
    "solutions": [
        "/*\n * Author: code6\n * Created Time:  2012/5/11 0:43:40\n * File Name: E.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n#define out(v) cerr << #v << \": \" << (v) << endl\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntypedef long long ll;\nconst double PI=acos(-1.0);\nconst double eps=1e-11;\nconst int MAX = 1000000 + 50;\n\ntypedef pair<int, int> PII;\n#define mp make_pair\n\nint n, m, vol;\nint sta, end;\nbool is_vol[MAX];\nvector<int>g[MAX];\n\nint dp[MAX];\npriority_queue< PII, vector<PII>, greater<PII> >  Q;\n\nbool ok(int q)\n{\n    int i, j;\n    memset(dp, -1, sizeof(dp));\n    dp[sta] = 0;\n    Q.push(mp(0, sta));\n    while (!Q.empty()) {\n        PII cur = Q.top();\n        Q.pop();\n        if (cur.first > dp[cur.second]) {\n            continue;\n        }\n        for (i = 0; i < g[cur.second].size(); i++) {\n            PII next;\n            next.second = g[cur.second][i];\n            next.first = cur.first + 1;\n            if (next.first > q) {\n                continue;\n            }\n            \n            if (is_vol[next.second]) {\n                next.first = 0;\n            }\n            \n            //printf(\"dp[2] = %d cur = %d, %d, next = %d, %d\\n\", dp[1], cur.first, cur.second + 1, next.first, next.second + 1);\n            \n            if (dp[next.second] == -1 || dp[next.second] > next.first) {\n             //   printf(\"sta = %d, dp = %d, reach %d at q = %d from cur = %d, %d\\n\", sta, dp[next.second], next.second + 1, next.first, cur.first, cur.second + 1);\n                dp[next.second] = next.first;\n                if (next.second == end) {\n                    return true;\n                }\n                Q.push(next);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &vol);\n    int i, j, k;\n    for (i = 0; i < vol; i++) {\n        int v;\n        scanf(\"%d\", &v);\n        v--;\n        is_vol[v] = true;\n    }\n    for (i = 0; i < m; i++) {\n        int u, v ;\n        scanf(\"%d%d\", &u, &v);\n        u--;\n        v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    scanf(\"%d%d\", &sta, &end);\n    sta--;\n    end--;\n    \n    int low, high, mid;\n    \n    low = 1;\n    high = n;\n    \n    while (low <= high) {\n        mid = (low + high) / 2;\n        if (ok(mid)) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    if (low > n) {\n        low = -1;\n    }\n    \n    printf(\"%d\\n\", low);\n    \n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Weak Memory.json",
    "editorial_link": "https://codeforces.com//blog/entry/4540",
    "editorial": "There were many different correct approaches to this problem during the contest. But I will explain authors solution.\n\nFirst we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.\n\nLet K be the set of all intersections with volunteers union s and t. One can use BFS from each k?K, one by one. Then build a graph G with vertices K. For each two vertices k1,k2?K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.\n\nWe can optimize the above solution by initiating BFS from all k?K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)\n\nBFS takes O(m) time and we add at most O(m) edges to G, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).",
    "hint": []
}