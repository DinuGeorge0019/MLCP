{
    "link": "https://codeforces.com//contest/834/problem/D",
    "problemId": "116227",
    "problem_idx": "D",
    "shortId": "834D",
    "contest_number": "834",
    "problem_submissions": {
        "A": [
            29008155,
            28994281,
            28993223,
            28993383,
            28993299,
            28998453,
            28993114,
            29004117,
            28996516,
            28993649,
            28993425,
            28992926,
            28993510,
            28995590,
            28994499,
            28992928,
            28997910,
            28993023,
            28993758,
            28994961
        ],
        "B": [
            29006607,
            28994310,
            28996695,
            28995339,
            28995566,
            28997950,
            28994742,
            29001213,
            28994365,
            28997334,
            28993196,
            28996141,
            28998138,
            28998574,
            28996986,
            28993597,
            29001178,
            28994781,
            28995788,
            28998348
        ],
        "D": [
            29003125,
            29012205,
            29010300,
            29010636,
            29106415,
            29106137,
            29011585,
            29009751,
            29011863,
            29014000,
            29030352,
            29012705,
            29015197,
            29012485,
            29012573,
            29017014,
            29013068,
            29016244,
            29027664,
            29015960,
            29015461,
            29013386,
            32498451,
            29017312,
            29015875
        ],
        "C": [
            28993611,
            28993624,
            29000277,
            29001499,
            29003185,
            29003274,
            29002460,
            28995797,
            29001808,
            29003104,
            29004949,
            29000425,
            29000467,
            29008986,
            29000566,
            29367098,
            29002153,
            29002279,
            29005747,
            29003864,
            29006871
        ],
        "E": [
            29044757,
            29044567
        ]
    },
    "name": "D. The Bakery",
    "statement": "Some time ago Slastyona the Sweetmaid decided to open her own bakery!\r\nShe bought required ingredients and a wonder-oven which can bake several\r\ntypes of cakes, and opened the bakery.Soon the expenses started to\r\novercome the income, so Slastyona decided to study the sweets market.\r\nShe learned it’s profitable to pack cakes in boxes, and that the more\r\ncake types a box contains (let’s denote this number as the of the box),\r\nthe higher price it has.She needs to change the production technology!\r\nThe problem is that the oven chooses the cake types on its own and\r\nSlastyona can’t affect it. However, she knows the types and order of\r\ncakes the oven is going to bake today. Slastyona has to pack exactly\r\nboxes with cakes today, and she has to put in each box several (at least\r\none) cakes the oven produced one (in other words, she has to put in a\r\nbox a continuous segment of cakes).Slastyona wants to maximize the total\r\nvalue of all boxes with cakes. Help her determine this maximum possible\r\ntotal value.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing db = double;\n#define pb push_back\n#define fir first\n#define sec second\n\nconst int mxn = 35006;\nconst int mxk = 52;\nconst int MXL = 0x3f3f3f3f;\n\nstruct Val {\n\tint x;\n\tVal(int x = -MXL) : x(x) {}\n\tVal operator+(Val b) { return max(x, b.x); }\n\tVal operator+(int b) { return x + b; }\n};\n\nusing Ope = int;\n\nstruct Segtree {\n\tVal val_[mxn * 2 + 1];\n\tOpe laz_[mxn * 2 + 1];\n\t#define val val_[l+r|l!=r]\n\t#define laz laz_[l+r|l!=r]\n\t#define m (l+r>>1)\n\t#define X l,r\n\t#define L l,m\n\t#define R m+1,r\n\t#define S sl,sr\n\tVal &operator[](int x) {\n\t\treturn val_[x + x];\n\t}\n\tvoid build(int l, int r) {\n\t\tlaz = Ope();\n\t\tif (l == r)\n\t\t\treturn;\n\t\tbuild(L);\n\t\tbuild(R);\n\t\trenew(X);\n\t}\n\tvoid renew(int l, int r) {\n\t\tval = get(L, X) + get(R, X);\n\t}\n\tvoid down(int l, int r) {\n\t\tif (laz) {\n\t\t\tset(L, X, laz);\n\t\t\tset(R, X, laz);\n\t\t\tlaz = Ope();\n\t\t}\n\t}\n\tVal get(int l, int r, int sl, int sr) {\n\t\tif (sl > sr) return Val();\n\t\tif (sl <= l && r <= sr)\n\t\t\treturn val;\n\t\tdown(X);\n\t\tif (sr <= m)\n\t\t\treturn get(L, S);\n\t\tif (m < sl)\n\t\t\treturn get(R, S);\n\t\treturn get(L, S) + get(R, S);\n\t}\n\tvoid set(int l, int r, int sl, int sr, Ope ope) {\n\t\tif (sl > sr) return;\n\t\tif (sl <= l && r <= sr) {\n\t\t\tval = val + ope;\n\t\t\tlaz = laz + ope;\n\t\t\treturn;\n\t\t}\n\t\tdown(X);\n\t\tif (sl <= m)\n\t\t\tset(L, S, ope);\n\t\tif (m < sr)\n\t\t\tset(R, S, ope);\n\t\trenew(X);\n\t}\n\t#undef val\n\t#undef laz\n\t#undef m\n\t#undef X\n\t#undef L\n\t#undef R\n\t#undef S\n};\n\nSegtree Q;\n\nint n, k;\n\nint f[mxk][mxn];\nint last[mxn];\nint L[mxn];\n\nint main() {\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tL[i] = last[x];\n\t\tlast[x] = i;\n\t}\n\t\n\tfor (int i = 1; i <= k; ++i) {\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tQ[j] = f[i - 1][j];\n\t\tQ.build(0, n);\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tQ.set(0, n, L[j], j - 1, +1);\n\t\t\tf[i][j] = Q.get(0, n, 0, j - 1).x;\n\t\t}\n\t}\n\t\n\tcout << f[k][n] << endl;\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Bakery.json",
    "editorial_link": "https://codeforces.com//blog/entry/53567",
    "editorial": "Imagine we're trying to compute the k-th dp layer and our currect position is i, maintaining a max segment tree with the sum dp(k?-?1,?j)?+?c(j?+?1,?i) in j-th cell where 0???j?<?i. The answer for dp(k,?n) is just a prefix query.\n\nHow do we move i the right? Let's denote i-th cake type as y. Notice that the i ??? i?+?1 transition increases the segment tree values for all cells j such that there's no y in range [j?+?1,?i] by one (since we've added a new distinct element).\n\nMore formal, we increase all j's between the previous position of y plus one (or the beginning of the array if we haven't marked y before) to i. Hence we got a lazy update segment tree and a simple prev[i] precalc. There's a single  for both updating and computing a single dp(k,?n) and a total complexity of .",
    "hint": []
}