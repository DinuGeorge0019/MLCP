{
    "link": "https://codeforces.com//contest/1527/problem/B2",
    "problemId": "990895",
    "problem_idx": "B2",
    "shortId": "1527B2",
    "contest_number": "1527",
    "problem_submissions": {
        "D": [
            116815110,
            116809404,
            116791032,
            116828575,
            116792418,
            116804682,
            116790154,
            116835794,
            116845531,
            116905646,
            116813710,
            116859388,
            117355591,
            116924969,
            116847643
        ],
        "E": [
            116803777,
            116781667,
            116811124,
            116796120,
            116809821,
            116778009,
            116805495,
            116805635,
            116810211,
            116816164,
            116795407,
            116798117,
            116858484,
            116831292,
            116785094,
            123210634,
            116826695,
            116821286,
            116806456,
            116822934,
            116825433
        ],
        "B2": [
            116779583,
            116824497,
            116839392,
            116808334,
            116863718,
            116773876,
            116814004,
            116802164,
            116826569,
            116803739,
            116800671,
            116833299,
            116836369,
            116807478
        ],
        "C": [
            116768817,
            116763349,
            116757962,
            116777964,
            116765975,
            116809173,
            116768519,
            116774311,
            116777675,
            116761218,
            116817305,
            116773251,
            116794638,
            116759497,
            116781691,
            116771054,
            116772322,
            116802912
        ],
        "B1": [
            116758740,
            116815267,
            116826483,
            116782539,
            116761604,
            116831651,
            116786152,
            116771964,
            116779790,
            116822211,
            116765970,
            116802975,
            116804039,
            116787374,
            116833209,
            116785198,
            116777321
        ],
        "A": [
            116752292,
            116752502,
            116752724,
            116753777,
            116753108,
            116820306,
            116752554,
            116757169,
            116752471,
            116755373,
            116825258,
            116752544,
            116831071,
            116753774,
            116752394,
            116754330,
            116756044,
            116754569
        ]
    },
    "name": "B2. Palindrome Game  hard version ",
    "statement": "A palindrome is a string that reads the same left to right and right to\r\nleft. For example, \"\" is a palindrome, while \"\" is not.Alice and Bob are\r\nplaying a game on a string s of length n consisting of the characters ”\r\nand ”. Both players take alternate turns with Alice going first.In each\r\nturn, the player can perform one of the following operations: Choose any\r\ni (1\r\nle i\r\nle n), where s[i] = ” and change s[i] to ”. Pay 1 dollar. Reverse the\r\nwhole string, pay 0 dollars. This operation is only allowed if the\r\nstring is currently a palindrome, and the last operation was not\r\nreverse. That is, if Alice reverses the string, then Bob can’t reverse\r\nin the next move, and vice versa. Reversing a string means reordering\r\nits letters from the last to the first. For example, \"\" becomes \"\" after\r\nreversing.The game ends when every character of string becomes ”. The\r\nplayer who spends minimum dollars till this point wins the game and it\r\nis a draw if both spend equal dollars. If both players play optimally,\r\noutput whether Alice wins, Bob wins, or if it is a draw.\r\n",
    "solutions": [
        "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC optimize(\"fast-math\")\n//#pragma GCC target(\"avx2\")\n// if avx2 not supported, use this instead\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n// something\n//#pragma GCC optimize(\"O3\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n//#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n//#pragma GCC target(\"avx\")  //Enable AVX\n\n#include <bits/stdc++.h>\n#ifdef ONPC\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n#define all(x) (x).begin(), (x).end()\n#define fr first\n#define sc second\n#define m_p make_pair\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define low_bo(a, x) ((int)(lower_bound(a.begin(), a.end(), x) - a.begin()))\n#define up_bo(a, x) ((int)(upper_bound(a.begin(), a.end(), x) - a.begin()))\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n#define popcnt(x) __builtin_popcount(x)\n#define shuffle(a) shuffle(a.begin(), a.end(), rnd)\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\nusing namespace std;\n\n/*\nconst int MEMSIZE = 1e9;\nchar memory[MEMSIZE];\nint memorypos;\ninline void * operator new(size_t n){\n    if (memorypos + n >= MEMSIZE)\n        memorypos = MEMSIZE / 3;\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\ninline void operator delete(void *){}\n*/\n\nusing ll = long long;\n\n#ifndef ONPC\n#define cerr cerr_maksim\nstruct Cerr : public ostream {\n    template<typename T>\n    Cerr& operator<<(T const&) {\n        return *this;\n    }\n} cerr;\n#endif\n\n#ifdef ONPC\nmt19937 rnd(223);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\n\ntemplate<typename T>\nvoid setmin(T &x, T y) {\n    x = min(x, y);\n}\n\ntemplate<typename T>\nvoid setmax(T &x, T y) {\n    x = max(x, y);\n}\n\nnamespace Ment {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n\n    template<typename T>\n    class Modular {\n    public:\n        using Type = typename decay<decltype(T::value)>::type;\n\n        constexpr Modular() : value() {}\n\n        template<typename U>\n        Modular(const U &x) {\n            value = normalize(x);\n        }\n\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n\n        const Type &operator()() const { return value; }\n\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n\n        constexpr static Type mod() { return T::value; }\n\n        Modular &operator+=(const Modular &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n\n        Modular &operator-=(const Modular &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n\n        template<typename U>\n        Modular &operator+=(const U &other) { return *this += Modular(other); }\n\n        template<typename U>\n        Modular &operator-=(const U &other) { return *this -= Modular(other); }\n\n        Modular &operator++() { return *this += 1; }\n\n        Modular &operator--() { return *this -= 1; }\n\n        Modular operator++(int) {\n            Modular result(*this);\n            *this += 1;\n            return result;\n        }\n\n        Modular operator--(int) {\n            Modular result(*this);\n            *this -= 1;\n            return result;\n        }\n\n        Modular operator-() const { return Modular(-value); }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n#ifdef _WIN32\n            uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n            uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n            asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n            );\n            value = m;\n#else\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n\n        template<typename U = T>\n        typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &\n        operator*=(const Modular &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n\n        Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n        template<typename U>\n        friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\n    private:\n        Type value;\n    };\n\n    template<typename T>\n    bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\n\n    template<typename T, typename U>\n    bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\n\n    template<typename T, typename U>\n    bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\n    template<typename T>\n    bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\n\n    template<typename T, typename U>\n    bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\n    template<typename T>\n    bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\n    template<typename T>\n    Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\n    template<typename T>\n    Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\n    template<typename T>\n    Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\n    template<typename T>\n    Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\n    template<typename T, typename U>\n    Modular<T> power(const Modular<T> &a, const U &b) {\n        assert(b >= 0);\n        Modular<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    string to_string(const Modular<T> &number) {\n        return to_string(number());\n    }\n\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n        return stream << number();\n    }\n\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n        typename common_type<typename Modular<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = Modular<T>::normalize(x);\n        return stream;\n    }\n\n    constexpr int md = 1e9 + 7;\n    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n}\nusing Ment::Mint;\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\n#define TIME (clock() * 1.0 / CLOCKS_PER_SEC)\n\n// WARNING!!!!!!\n// Maksim reads solution\n// be careful!!!!\n\n// solution starts here\n\nusing ld = double;\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 1e5 + 100, maxw = (1 << 20) + 5, inf = 1e9 + 100;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    string t = s;\n    reverse(t.begin(), t.end());\n    int z = 0;\n    for (char o : s)\n        z += (o == '0');\n    if (s == t) {\n        if (z > 1 && s.size() % 2 == 1 && s[s.size() / 2] == '0')\n            cout << \"ALICE\\n\";\n        else\n            cout << \"BOB\\n\";\n    } else {\n        bool draw = 0;\n        if (s.size() % 2 == 1) {\n            int c = 0;\n            for (int i = 0; i < s.size() / 2; i++)\n                if (s[i] != s[s.size() - 1 - i])\n                    c++;\n            if (c == 1 && z == 2) {\n                draw = 1;\n            }\n        }\n        if (draw)\n            cout << \"DRAW\\n\";\n        else\n            cout << \"ALICE\\n\";\n    }\n}\n\n// check test counter\n\nint main() {\n#ifdef ONPC\n    freopen(\"../a.in\", \"r\", stdin);\n    freopen(\"../a.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed;\n    cout.precision(20);\n    //precalc();\n    if (false) {\n        int te = 0;\n        while (1) {\n            cerr << ++te << '\\n';\n            solve();\n        }\n    }\n    int ts;\n    ts = 1;\n    cin >> ts;\n    for (int its = 1; its <= ts; its++) {\n        //cerr << \"\\nts \" << its << '\\n';\n        //cout << \"Case #\" << its << \": \";\n        solve();\n    }\n#ifdef ONPC\n    cerr << \"\\n\\nConsumed \" << TIME << '\\n';\n#endif\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B2. Palindrome Game  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/90939",
    "editorial": "The case when is a palindrome is discussed in B1. Otherwise, Alice will\r\nwin or the game will end with a draw. If it is optimal for Alice to\r\nperform operation in the first move, she will perform it else she will\r\nperform operation forcing Bob to perform operation (which is not optimal\r\notherwise Alice would have performed it in the first move). Alice will\r\nkeep reversing the string till string is one move short to become a\r\npalindrome with an even number of zeros. This time Alice will perform\r\noperation instead of reversing and will make string a palindrome. Now,\r\nstring is a palindrome containing an even number of zeros, with Bobâs\r\nturn. Here, Alice can take dollars advantage using the strategy\r\nmentioned in B1. This way Bob will spend at least dollars more than\r\nAlice resulting in Aliceâs win. In some cases like â, â Alice will just\r\nkeep on reversing the string and Bob has to change all â to â. Thereâs\r\nonly case when thereâs a draw if the length of string is odd and\r\ncontains zeros ( zero is in mid of string ).As constraints on were\r\nsmall, the problem can also be solved using dynamic\r\nprogramming.Following parameters of string is enough define current\r\nstate of game: = count of symmetric pair (â as well as â) = count of\r\nsymmetric or pair ( is not equal to ) = if mid character exists (length\r\nof string is odd) and it is â else = if previous move was operation else\r\nIf any player encounters the game state , we define to be the minimum\r\ncost difference he/she can achieve from here.Transition is pretty simple\r\nif is and : if : if : if is : Finally, If , Alice wins If , Bob wins If\r\n, Draw We can precompute this dp and answer all test cases in . Overall\r\ntime complexity -\r\n",
    "hint": []
}