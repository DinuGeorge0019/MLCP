{
    "link": "https://codeforces.com//contest/864/problem/F",
    "problemId": "124138",
    "problem_idx": "F",
    "shortId": "864F",
    "contest_number": "864",
    "problem_submissions": {
        "F": [
            30716015,
            30722402,
            30723225,
            30725964,
            30739740
        ],
        "E": [
            30710484,
            30714856,
            30715154,
            30723143,
            30713586,
            30730131,
            30715426,
            30713107,
            30711368,
            30718758,
            30718806,
            30718477,
            30714033,
            30714286,
            30715582,
            30713724,
            30713502,
            30738356,
            30717401,
            30713777,
            30716171,
            30715998
        ],
        "D": [
            30707520,
            30709478,
            30708092,
            30709303,
            30709255,
            30703697,
            30709397,
            30707026,
            30712505,
            30709061,
            30711433,
            30710302,
            30710827,
            30707816,
            30706829,
            30708611,
            30705451,
            30707869,
            30706715,
            30708055
        ],
        "C": [
            30705528,
            30707197,
            30704462,
            30712744,
            30706231,
            30710658,
            30706244,
            30713235,
            30708256,
            30705517,
            30708760,
            30706819,
            30708546,
            30705215,
            30711574,
            30711162,
            30709362,
            30710824,
            30709705,
            30706376
        ],
        "B": [
            30703070,
            30703231,
            30706404,
            30704293,
            30702498,
            30701721,
            30702746,
            30704552,
            30702131,
            30702339,
            30704226,
            30703770,
            30702687,
            30701947,
            30704004,
            30702177,
            30703567,
            30708307,
            30703521,
            30704217
        ],
        "A": [
            30701411,
            30701464,
            30701236,
            30703640,
            30701582,
            30701091,
            30701629,
            30704524,
            30701158,
            30701293,
            30701284,
            30701912,
            30701498,
            30701066,
            30701818,
            30701174,
            30701687,
            30701585,
            30701750,
            30701329
        ]
    },
    "name": "F. Cities Excursions",
    "statement": "There are cities in Berland. Some pairs of them are connected with\r\ndirected roads. One can use only these roads to move from one city to\r\nanother. There are no roads that connect a city to itself. For each pair\r\nof cities there is at most one road from to .A path from city to city is\r\na sequence of cities , , ... , , where , , and there is a road from city\r\nto city for each from to . The path can pass multiple times through each\r\ncity except . It can’t pass through more than once.A path from to is if\r\nit is the lexicographically minimal such path. In other words, is path\r\nfrom to if for any other path from to , where is the minimum integer\r\nsuch that .There is a tourist agency in the country that offers unusual\r\nexcursions: the -th excursion starts at city and ends in city . For each\r\npair , help the agency to study the ideal path from to . Note that it is\r\npossible that there is no ideal path from to . This is possible due to\r\ntwo reasons: there is no path from to ; there are paths from to , but\r\nfor every such path there is another path from to , such that , where is\r\nthe minimum integer for which . The agency would like to know for the\r\nideal path from to the -th city in that path (on the way from to ).For\r\neach triple , , () find if there is an ideal path from to and print the\r\n-th city in that path, if there is any.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<bitset>\n#include<list>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nlist<int> l[3010];\nint c[3010][3010];\nint ti;\nint b[3010];\nint d[3010][3010];\nint start;\nvoid dfs(int x)\n{\n\tb[x]=1;\n\tc[start][x]=1;\n\tfor(auto v:l[x])\n\t\tif(!b[v])\n\t\t\tdfs(v);\n}\nstruct p\n{\n\tint x,y,k,id;\n};\np a[400010];\nint ans[400010];\nint cmp(p a,p b)\n{\n\treturn a.y<b.y;\n}\nlist<int> l2[3010];\nlist<int> l3[3010];\nint e[3010];\nint st[3010];\nvoid dfs2(int x,int d)\n{\n\tst[d]=x;\n\tfor(auto v:l3[x])\n\t\tif(a[v].k<=d)\n\t\t\tans[a[v].id]=st[d-a[v].k+1];\n\tb[x]=1;\n\tfor(auto v:l2[x])\n\t\tif(!b[v])\n\t\t\tdfs2(v,d+1);\n}\nint main()\n{\n\tmemset(c,0,sizeof c);\n\tmemset(d,0,sizeof d);\n\tint n,m,q;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tint i;\n\tint x,y;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tl[x].push_back(y);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tstart=i;\n\t\tmemset(b,0,sizeof b);\n\t\tdfs(i);\n\t}\n\tint j;\n\tfor(i=1;i<=n;i++)\n\t\tfor(auto v:l[i])\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tif(c[v][j])\n\t\t\t\t\tif(!d[i][j]||v<d[i][j])\n\t\t\t\t\t\td[i][j]=v;\n\tfor(i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].k);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+q+1,cmp);\n\tint k;\n\tmemset(ans,-1,sizeof ans);\n\tfor(i=1;i<=q;i++)\n\t\tif(i==1||a[i].y!=a[i-1].y)\n\t\t{\n\t\t\tk=i;\n\t\t\twhile(k<q&&a[k].y==a[k+1].y)\n\t\t\t\tk++;\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tl2[j].clear();\n\t\t\t\tl3[j].clear();\n\t\t\t}\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tif(d[j][a[i].y])\n\t\t\t\t\tl2[d[j][a[i].y]].push_back(j);\n\t\t\tfor(j=i;j<=k;j++)\n\t\t\t\tl3[a[j].x].push_back(j);\n\t\t\tmemset(b,0,sizeof b);\n\t\t\tdfs2(a[i].y,1);\n\t\t}\n\tfor(i=1;i<=q;i++)\n\t\tprintf(\"%d\\n\",ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Cities Excursions.json",
    "editorial_link": "https://codeforces.com//blog/entry/54765",
    "editorial": "There is a direct graph. For each query, you need to find the -th vertex\r\nin the lexicographically minimal path from to .First group the queries\r\non the vertex and find all vertices from which the vertex is achievable.\r\nFor this you can invert all the arcs and run dfs from the vertex .Now\r\nconsider the query (, ). For this query, you need to find the\r\nlexicographically minimal path from to . If the vertex is not achievable\r\nfrom , then the answer is â. Otherwise, in the lexicographically minimal\r\npath from to the vertex () is the minimal vertex from vertices such that\r\nthere exists an arc () and is achievable from .Thus, we can build a new\r\ngraph consisting of arcs satisfying the previous condition. Let us\r\ninvert the arcs in this graph. Consider the vertices achievable from in\r\nthis graph. They form an outgoing tree. Only for these vertices there is\r\na lexicographically minimal path to . The lexicographically minimal path\r\nfrom the vertex to the vertex is equal to the inverted path from to in\r\nthis tree.So, we can use binary climb to get the -th vertex on this\r\npath.\r\n",
    "hint": []
}