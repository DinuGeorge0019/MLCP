{"link": "https://codeforces.com//contest/369/problem/E", "problemId": "4127", "problem_idx": "E", "shortId": "369E", "contest_number": "369", "problem_submissions": {"D": [5305237, 5312782, 5302575, 5302522, 5304036, 5303475, 5298828, 5304364, 5302322, 5304435, 5307669, 5304261, 5348610], "E": [5299924, 5300916, 5302442, 5306132, 5309865, 5324849, 5304462, 5346294, 5312977, 5302205, 5302615], "C": [5297353, 5298610, 5300018, 5298007, 5298088, 5296130, 5300828, 5301779, 5300657, 5301152, 5298538, 5299357, 5297721, 5300161, 5297375, 5299374, 5298853], "B": [5295698, 5301934, 5295966, 5296687, 5296491, 5297164, 5297880, 5302888, 5299175, 5297625, 5304937, 5296913, 5307548, 5298564, 5304878, 5301724, 5298054], "A": [5294961, 5295577, 5296970, 5295370, 5295286, 5297542, 5295335, 5303463, 5295020, 5295091, 5295149, 5295306, 5295147, 5295682, 5295086, 5295265, 5294962]}, "name": "E. Valera and Queries", "statement": "Valera loves segments. He has recently come up with one interesting\r\nproblem.The axis of coordinates has segments, the -th segment starts in\r\nposition and ends in position (we will mark it as ). Your task is to\r\nprocess queries, each consists of number and a set of coordinates of\r\npoints located on the axis. The answer to the query is the number of\r\nsegments, such that each of them contains at least one point from the\r\nquery. Segment point , if .Valera found the solution of this problem too\r\ndifficult. So he asked you to help him. Help Valera.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define lowbit(x) ((x) & (-(x)))\nusing namespace std;\ntypedef long long LL;\nconst int N = 300005;\nconst int M = 10000005;\nstruct persistent_tree{  \n    int lson[M],rson[M],c[M],T[M];  \n    int tot,m;  \n    void Init(int t,int _m){  \n        tot=0;m=_m;  \n        T[t]=bulid(1,m);  \n    }  \n    int bulid(int l,int r){  \n        int root=tot++;  \n        c[root]=0;  \n        if(l!=r){  \n            int m=(l+r)>>1;  \n            lson[root]=bulid(l,m);  \n            rson[root]=bulid(m+1,r);  \n        }  \n        return root;  \n    }  \n    int update(int root,int pos,int val = 1){  \n        int newroot=tot++,tmp=newroot;  \n        c[newroot]=c[root]+val;  \n        int l=1,r=m;  \n        while(l<r){  \n            int mid=(l+r)>>1;  \n            if(pos<=mid){  \n                rson[newroot]=rson[root];  \n                lson[newroot]=tot++;  \n                newroot=lson[newroot];  \n                root=lson[root];  \n                r=mid;  \n            }  \n            else{  \n                lson[newroot]=lson[root];  \n                rson[newroot]=tot++;  \n                newroot=rson[newroot];  \n                root=rson[root];  \n                l=mid+1;  \n            }  \n            c[newroot]=c[root]+val;  \n        }  \n        return tmp;  \n    }  \n    int query(int root,int l,int r,int L,int R){  \n        if(R<L) return 0;  \n        if(l==L&&r==R)  \n            return c[root];  \n        int m=(l+r)>>1;  \n        if(R<=m) return query(lson[root],l,m,L,R);  \n        else if(L>m) return query(rson[root],m+1,r,L,R);  \n        else return query(lson[root],l,m,L,m)+query(rson[root],m+1,r,m+1,R);  \n    }  \n    void insert(int now,int old,int pos,int val){  \n        T[now]=update(T[old],pos,val);  \n    }  \n}tree; \nint n , m;\nvector <int> v[1000005];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (\"input.txt\" , \"r\" , stdin);\n    #endif\n    scanf (\"%d%d\" , &n , &m);\n    for (int i = 0 ; i < n ; i ++) {\n        int l , r;\n        scanf (\"%d %d\" , &l , &r);\n        v[l].push_back (r);\n    }\n    tree.Init (1000000 + 1 , 1000000);\n    for (int i = 1000000 ; i >= 1 ; i --) {\n        sort (v[i].begin () , v[i].end ());\n        if (v[i].size() == 0) {\n            tree.T[i] = tree.T[i + 1];\n        }\n        else {\n            tree.T[i] = tree.update (tree.T[i + 1] , v[i][0]);\n            for (int j = 1 ; j < v[i].size() ; j ++)\n                tree.T[i] = tree.update (tree.T[i] , v[i][j]);\n        }\n    }\n    while (m --) {\n        int k , a[N];\n        scanf (\"%d\" , &k);\n        for (int i = 0 ; i < k ; i ++)\n            scanf (\"%d\" , &a[i]);\n        a[k ++] = 0;a[k ++] = 1000001;\n        sort (a , a + k);\n        int ans = n;\n        for (int i = 1 ; i < k ; i ++) {\n            ans -= tree.query (tree.T[a[i - 1] + 1] , 1 , 1000000 , a[i - 1] + 1 , a[i] - 1);\n        }\n        printf (\"%d\\n\" , ans);\n    }\n    return 0;  \n}"], "input": "", "output": "", "tags": ["binary search", "data structures"], "dificulty": "2200", "interactive": false}