{"link": "https://codeforces.com//contest/266/problem/C", "problemId": "2551", "problem_idx": "C", "shortId": "266C", "contest_number": "266", "problem_submissions": {"C": [2989194, 2989322, 2989384, 2989374, 2990143, 2990040, 2989950, 2990381, 2989426, 2990294, 2990289, 2990276, 2990477, 2990536, 2990530, 2990542, 2990578, 2990675], "B": [2985804, 2985949, 2985263, 2986112, 2986385, 2986429, 2986401, 2986077, 2989758, 2987333, 2987763, 2987236, 2986921, 2986571, 2986945, 2986418, 2987432], "A": [2984619, 2984631, 2984505, 2985937, 2984987, 2984610, 2984803, 2984855, 2985014, 2985823, 2985798, 2985353, 2984968, 2985697, 2985287, 2985009, 2986181], "D": [2992984, 3412192, 3756396]}, "name": "C. Below the Diagonal", "statement": "You are given a square matrix consisting of rows and columns. We assume\r\nthat the rows are numbered from to from top to bottom and the columns\r\nare numbered from to from left to right. Some cells ( cells in total) of\r\nthe the matrix are filled with ones, the remaining cells are filled with\r\nzeros. We can apply the following operations to the matrix: Swap -th and\r\n-th rows of the matrix; Swap -th and -th columns of the matrix. You are\r\nasked to transform the matrix into a special form using these\r\noperations. In that special form all the ones must be in the cells that\r\nlie below the main diagonal. Cell of the matrix, which is located on the\r\nintersection of the -th row and of the -th column, lies below the main\r\ndiagonal if .\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\nusing namespace std;\n\ntypedef long long ll;\nconst int BIGINT = 0x0FFFFFFF;\nconst ll BIGLL = 0x0FFFFFFFFFFFFFFFll;\nconst int MAXN = 1005;\n\n\nint n,m,x,y;\nint p[MAXN][2];\nbool ct[MAXN];\nvector< pair< int , pair<int,int> > > ans;\n\nvoid swap_and_commit(int t,int a,int b)\n{\n    if(t==1)\n    {\n        for(int i=0;i<m;i++)\n        {\n            if(p[i][0]==a) p[i][0]=b;\n            else if(p[i][0]==b) p[i][0]=a;\n        }\n        ans.push_back(make_pair(1,make_pair(a,b)));\n    }\n    else\n    {\n        for(int i=0;i<m;i++)\n        {\n            if(p[i][1]==a) p[i][1]=b;\n            else if(p[i][1]==b) p[i][1]=a;\n        }\n        ans.push_back(make_pair(2,make_pair(a,b)));\n    }\n}\n\nvoid solve(int l)\n{\n    if(l==n) return;\n    for(int i=1;i<=n;i++) ct[i]=false;\n    for(int i=0;i<m;i++)\n        if( p[i][1]>=l)\n            ct[p[i][0]]=true; \n    int freect=-1;\n    for(int i=1;i<=n;i++) if(!ct[i]) freect=i;\n    if(freect!=-1&&freect!=l)\n        swap_and_commit(1,l,freect);\n    for(int i=0;i<m;i++) \n        if(p[i][1]>l)\n        {\n            swap_and_commit(2,l,p[i][1]);\n            break;\n        }\n    solve(l+1);\n}\n\nint main()\n{\n    cin>>n; m=n-1;\n    for(int i=0;i<m;i++)\n        cin>>p[i][0]>>p[i][1];\n\n    solve(1);\n\n    cout << ans.size() << '\\n';\n    for(size_t i=0;i<ans.size();i++)\n        cout << ans[i].first << ' ' << ans[i].second.first << ' ' << ans[i].second.second << '\\n';\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "math"], "dificulty": "2100", "interactive": false}