{
    "link": "https://codeforces.com//contest/1780/problem/G",
    "problemId": "1751021",
    "problem_idx": "G",
    "shortId": "1780G",
    "contest_number": "1780",
    "problem_submissions": {
        "B": [
            190535258,
            190498086,
            190497202,
            190504885,
            190496777,
            190498615,
            190498275,
            190497689,
            190505348,
            190506760,
            190497685,
            190497528,
            190501759,
            190525276,
            190496999,
            190500082,
            190500545,
            190502064,
            190519356,
            190503567
        ],
        "D": [
            190533820,
            190533379,
            190523919,
            190522645,
            190511882,
            190524576,
            190524419,
            190528918,
            190542496,
            190522478,
            190522893,
            190531155,
            190529105,
            190551665,
            190525303,
            190533171,
            190519573,
            190527940,
            190532781
        ],
        "A": [
            190529026,
            190496355,
            190496107,
            190513521,
            190496187,
            190496359,
            190496570,
            190496143,
            190505208,
            190497564,
            190496513,
            190499602,
            190498096,
            190517182,
            190496208,
            190496566,
            190497285,
            190498375,
            190517649,
            190499548
        ],
        "E": [
            190527049,
            190548713,
            190543230,
            190508008,
            190529273,
            190540087,
            190536127,
            190560235,
            190552095,
            190550324,
            190520594,
            190570059,
            190569996,
            190559193,
            190547102,
            190544599,
            190538906,
            190514425,
            190551048
        ],
        "F": [
            190517191,
            190517201,
            190529995,
            190532767,
            190538925,
            190546993,
            190547096,
            190541658,
            190557282,
            190555255,
            190536356,
            190536733,
            190551167,
            190514623,
            190538687,
            190557956,
            191454311,
            190563201,
            190556137,
            190561572
        ],
        "G": [
            190503495,
            190523768,
            190518506,
            190545041,
            190560974,
            190562076,
            190559215,
            190552122,
            190532760,
            190564681,
            190527891,
            190541029,
            190559585,
            190602710,
            190635446,
            190533062
        ]
    },
    "name": "G. Delicious Dessert",
    "statement": "Today is an important day for chef Tonio an auditor has arrived in his\r\nhometown of Morioh. He has also arrived at Tonio’s restaurant and\r\nordered dessert. Tonio has not been prepared for this turn of events.As\r\nyou know, dessert is a string of lowercase English letters. Tonio\r\nremembered the rule of desserts a string s of length n. Any dessert t is\r\nif the number of occurrences of t in s as a substring is by the length\r\nof t.Now Tonio wants to know the number of delicious substrings of s. If\r\nthe substring occurs several times in the string s, then all occurrences\r\nmust be taken into account.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int N = 2e6 + 5;\nint tot = 1, lst = 1, fa[N], len[N], sz[N];\narray<int, 26> ch[N];\nvector<int> adj[N];\n\nvoid ins(int c) {\n    int p = lst, np = lst = ++tot;\n    len[np] = len[p] + 1;\n    for (; p && !ch[p][c]; p = fa[p]) {\n        ch[p][c] = np;\n    }\n    if (!p) {\n        fa[np] = 1;\n        return;\n    }\n    int q = ch[p][c];\n    if (len[q] == len[p] + 1) {\n        fa[np] = q;\n    } else {\n        int nq = ++tot;\n        len[nq] = len[p] + 1, ch[nq] = ch[q];\n        fa[nq] = fa[q], fa[q] = fa[np] = nq;\n        for (; ch[p][c] == q; p = fa[p]) {\n            ch[p][c] = nq;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    int n;\n    string s;\n    cin >> n >> s;\n    for (char c : s) {\n        ins(c - 'a');\n        sz[lst]++;\n    }\n    for (int i = 2; i <= tot; i++) {\n        adj[fa[i]].push_back(i);\n    }\n    vector<vector<pair<int, int>>> coef(n + 1);\n    auto dfs = [&](auto self, int u) -> void {\n        for (int v : adj[u]) {\n            self(self, v);\n            sz[u] += sz[v];\n        }\n        if (u == 1) return;\n        coef[len[fa[u]]].emplace_back(sz[u], -sz[u]);\n        coef[len[u]].emplace_back(sz[u], sz[u]);\n    };\n    dfs(dfs, 1);\n    long long ans = 0;\n    vector<int> d(n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j <= n; j += i) {\n            d[j]++;\n        }\n        for (auto [j, w] : coef[i]) {\n            ans += 1LL * d[j] * w;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dsu",
        "hashing",
        "math",
        "number theory",
        "string suffix structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Delicious Dessert.json",
    "editorial_link": "https://codeforces.com//blog/entry/111841",
    "editorial": "TutorialThis problem has several solutions using different suffix\r\nstructures. We will tell two of them using suffix array, and using\r\nsuffix automaton. Suffix array (t4m0fey)Letâs build suffix array and\r\narray (largest common prefixes) on the string . Fix some consider about\r\nall substring length . Match to positions array , such that , and match\r\nto other positions. One in position means that the substrings length\r\nstarting at and are equal. Consider any block of units length , then for\r\nsubstrings length number of occurrences in , then in order for the\r\nsubstrings in this block to be delicious, it is necessary that divided\r\nby .Letâs brute from to sustain all sizes blocks. Then, when shift to a\r\nnew should events change to , for all , such that . To do this you can\r\nsustain DSU (Disjoint set union). Then for each block size we know the\r\nnumber of blocks with this size. Then it is enough to consider all\r\nblocks of length , such as divider . It can be done explicitly, just\r\nbrute , , ..., as . And this works in sum of harmonic series: .For ,\r\nobviously, any substring length satisfies, so you can just add to the\r\nanswer.Overall time complexity is . Suffix automaton (AndreyPavlov)The\r\nsolution with the suffix automaton is as follows: letâs build the suffix\r\nautomaton itself, now we calculate for each vertex of the suffix\r\nautomaton the dynamics this is the number of paths from the vertex to\r\nthe terminal vertices. This dynamics means the number of occurrences of\r\nthe substring corresponding to this vertex in the entire string. Letâs\r\nintroduce the function the length of the longest substring leading to\r\nthe vertex . We know that all substrings of length from to lead to the\r\nvertex of the suffix automaton each once. Where and , where is the\r\nsuffix link of . Why is it so? All substrings of the form lead to the\r\nvertex of the suffix automaton, and there is a suffix link to which lead\r\nall substrings of the form .In order to solve the problem, letâs go\r\nthrough the vertex and look at the number of occurrences of any\r\nsubstring that leads to the vertex, then fix the number of such , that\r\nis evenly divisible by . Therefore, must be added to the answer. All\r\ndivisors can be stored in and each time find the number of such by\r\nbinsearch.Asymptotics\r\n",
    "hint": []
}