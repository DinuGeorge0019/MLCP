{
    "link": "https://codeforces.com//contest/754/problem/D",
    "problemId": "88003",
    "problem_idx": "D",
    "shortId": "754D",
    "contest_number": "754",
    "problem_submissions": {
        "C": [
            23598952,
            23602731,
            23600404,
            23598770,
            23595631,
            23604849,
            23604549,
            23600905,
            23597681,
            23600418,
            23605322,
            23605304,
            23598917,
            23597491,
            23604104,
            23598918,
            23606632
        ],
        "D": [
            23593184,
            23593323,
            23595150,
            23595085,
            23598162,
            23593559,
            23596735,
            23599764,
            23604175,
            23599201,
            23597364,
            23604779,
            23603085,
            23598699,
            23605480,
            23605421,
            23600608,
            23604207,
            23599681
        ],
        "B": [
            23588442,
            23588177,
            23589652,
            23588551,
            23588951,
            23588531,
            23591530,
            23589211,
            23589887,
            23588557,
            23594523,
            23590126,
            23593242,
            23593078,
            23590225,
            23588316,
            23588990,
            23589935,
            23595966
        ],
        "A": [
            23587499,
            23595001,
            23587629,
            23607118,
            23587407,
            23587483,
            23589634,
            23587559,
            23587954,
            23587405,
            23587857,
            23587707,
            23599756,
            23587979,
            23587428,
            23587560,
            23588096,
            23590086
        ],
        "E": [
            23607022,
            23650416,
            23650411,
            23650402,
            23621680,
            24024004,
            23676163
        ]
    },
    "name": "D. Fedor and coupons",
    "statement": "All our characters have hobbies. The same is true for Fedor. He enjoys\r\nshopping in the neighboring supermarket. The goods in the supermarket\r\nhave unique integer ids. Also, for every integer there is a product with\r\nid equal to this integer. Fedor has discount coupons, the -th of them\r\ncan be used with products with ids ranging from to , inclusive. Today\r\nFedor wants to take exactly coupons with him.Fedor wants to choose the\r\ncoupons in such a way that the number of such products that all coupons\r\ncan be used with this product is as large as possible (for better\r\nunderstanding, see examples). Fedor wants to save his time as well, so\r\nhe asks you to choose coupons for him. Help Fedor!\r\n",
    "solutions": [
        "//No exams!\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back \n#define MP make_pair\ntypedef long long ll;\nconst ll INF=1<<28;\nconst ll LINF=1ll<<61;\nint n,k;\npair<pair<int,int>,int> id[300111];\npair<int,int> a[300111];\nset<pair<int,int> >st;\nint solve(int tmp=0)\n{\n\tst.clear();\n\tint ans=0,ansid=k;\n\tfor(int i=1;i<k;i++)st.insert(MP(a[i].SS,i));\n\tfor(int i=k;i<=n;i++)\n\t{\n\t\tst.insert(MP(a[i].SS,i));\n\t\twhile(st.size()>k)\n\t\t{\n\t\t\tst.erase(st.begin());\n\t\t}\n\t\tint t=max(0,st.begin()->FF-a[i].FF+1);\n\t\tif(t>ans)\n\t\t{\n\t\t\tans=t;\n\t\t\tansid=i;\n\t\t}\n\t\tif(tmp==i)\n\t\t{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t\tfor(auto x:st)\n\t\t\t{\n\t\t\t\tprintf(\"%d \",id[x.SS].SS);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t\texit(0);\n\t\t}\n\t}\n\treturn ansid;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i].FF,&a[i].SS);\n\t\tid[i]=MP(a[i],i);\n\t}\n\tsort(a+1,a+n+1);\n\tsort(id+1,id+n+1);\n\tsolve(solve());\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Fedor and coupons.json",
    "editorial_link": "https://codeforces.com//blog/entry/49637",
    "editorial": "Formalized version of this problem:Given segments, we need to choose of\r\nthem, such that intersection of chosen segments has maximum possible\r\nlength.Let\u00e2\u0080\u0099s use binary search to find maximum possible length of\r\nintersection.Let\u00e2\u0080\u0099s this length equals to . If exist segments, which have\r\nlength of intersection greater or equals to , then if we decrease right\r\nborder of this segments by , then length of intersection will be greater\r\nthan of equal to .So solution is:Fix length of intersection by binary\r\nsearch. Now we should check if there is exist such segments, that their\r\nintersection length greater than or equal to . This can be done as\r\nfollows. Decrease right border of every segment by . Now we should check\r\nif there is exist such segments, which have intersection length greater\r\nor equals to . This can be done by different ways. For example using\r\nmethod of events segment starts, segment ends. And we should find such\r\npoint, which covered by segments.Time complexity , where .\r\n"
}