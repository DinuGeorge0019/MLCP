{
    "link": "https://codeforces.com//contest/1365/problem/F",
    "problemId": "643141",
    "problem_idx": "F",
    "shortId": "1365F",
    "contest_number": "1365",
    "problem_submissions": {
        "G": [
            82837838,
            82865836,
            82846144,
            82865744,
            83288423,
            83288390,
            83115367,
            83113068,
            82891046,
            83317408
        ],
        "F": [
            82823576,
            82831163,
            82869715,
            82841291,
            82797913,
            82821383,
            82823224,
            82820878,
            82825962,
            82827764,
            82819318,
            82822994,
            82828397,
            82835003,
            82834772,
            82828790,
            83116114,
            82838680,
            82843357,
            82850042
        ],
        "E": [
            82816827,
            82806889,
            82828546,
            82852781,
            82820451,
            82809338,
            82811048,
            82815094,
            82813767,
            82818099,
            82819025,
            82806699,
            82809270,
            82814661,
            82803838,
            82820792,
            82820031,
            82816700,
            82817857,
            82816698
        ],
        "D": [
            82812948,
            82823500,
            82822183,
            82824676,
            82812570,
            82806668,
            82804333,
            82805751,
            82808225,
            82811038,
            82801401,
            82805193,
            82808495,
            82818445,
            82814370,
            83282843,
            82816083,
            82808400,
            82807406,
            82806087
        ],
        "C": [
            82796097,
            82796764,
            82804011,
            82805788,
            82786984,
            82796314,
            82793579,
            82793092,
            82796581,
            82800342,
            82827239,
            82793084,
            82792671,
            82807140,
            82802231,
            82801070,
            82793918,
            82793032,
            82794670
        ],
        "B": [
            82789379,
            82791264,
            82799267,
            82793610,
            82787860,
            82790701,
            82790486,
            82792963,
            82793820,
            82794046,
            82787508,
            82790351,
            82789454,
            82795420,
            82796086,
            83567414,
            83567289,
            83567233,
            83566819,
            83566572,
            83566088,
            83137777,
            83136749,
            83136555,
            82797438,
            82788975,
            82789229,
            82789419
        ],
        "A": [
            82787406,
            82788164,
            82795856,
            82788300,
            82789945,
            82787354,
            82787533,
            82792868,
            82790605,
            82788592,
            83313475,
            82823189,
            82788613,
            82787440,
            82788379,
            82788620,
            82787269,
            82787662,
            82787203,
            82787209
        ]
    },
    "name": "F. Swaps Again",
    "statement": "Ayush, Ashish and Vivek are busy preparing a new problem for the next\r\nCodeforces round and need help checking if their test cases are\r\nvalid.Each test case consists of an integer n and two arrays a and b, of\r\nsize n. If after some (possibly zero) operations described below, array\r\na can be transformed into array b, the input is said to be . Otherwise,\r\nit is .An operation on array a is: select an integer k (1\r\nle k\r\nle\r\nlfloor\r\nfrac{n}{2}\r\nrfloor) swap the prefix of length k with the suffix of length k For\r\nexample, if array a initially is\r\n{1, 2, 3, 4, 5, 6\r\n}, after performing an operation with k = 2, it is transformed into\r\n{5, 6, 3, 4, 1, 2\r\n}.Given the set of test cases, help them determine if each one is or .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint t=1;\n\tscanf(\"%d\" ,&t);\n\twhile(t--){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector <int> a(n), b(n);\n\t\tfor(int&i:a){\n\t\t\tscanf(\"%d\", &i);\n\t\t}\n\t\tfor(int&i:b){\n\t\t\tscanf(\"%d\", &i);\n\t\t}\n\t\tvector <pair <int, int> > pairsa, pairsb;\n\t\tfor(int i = 0;i < n/2;i ++){\n\t\t\tpair <int, int> inp;\n\t\t\tinp=make_pair(a[i], a[n-1-i]);\n\t\t\tif(inp.first>inp.second)\n\t\t\t\tswap(inp.first, inp.second);\n\t\t\tpairsa.push_back(inp);\n\t\t\tinp=make_pair(b[i], b[n-1-i]);\n\t\t\tif(inp.first>inp.second)\n\t\t\t\tswap(inp.first, inp.second);\n\t\t\tpairsb.push_back(inp);\n\t\t}\n\t\tsort(pairsa.begin(), pairsa.end());\n\t\tsort(pairsb.begin(), pairsb.end());\n\t\tbool can=true;\n\t\tfor(int i = 0;i < n/2;i ++){\n\t\t\tif(pairsa[i]!=pairsb[i])\n\t\t\t\tcan=false;\n\t\t}\n\t\tif(n&1){\n\t\t\tif(a[n/2]!=b[n/2])\n\t\t\t\tcan=false;\n\t\t}\n\t\tprintf(can?\"Yes\\n\":\"No\\n\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Swaps Again.json",
    "editorial_link": "https://codeforces.com//blog/entry/78504",
    "editorial": "If we consider the unordered pair of elements , then after any\r\noperation, the multiset of these pairs (irrespective of the ordering of\r\nelements within the pair) stays the same!First of all, if the multiset\r\nof numbers in and are not the same, the answer is \"\".Moreover, if is\r\nodd, it is not possible to change the middle element of , i.e., . So\r\nwhen is odd and elements at the position do not match in and , the\r\nanswer is again \"\".Suppose we pair up the elements at equal distance\r\nfrom the middle element in (if is even, the middle element does not\r\nexist but we can treat it as the one between positions and ). That is,\r\nwe pair up (their individual order within the pair doesnât matter).\r\nAfter any operation on , the multiset of these pairs does not change!If\r\nwe swap a prefix of length with the suffix of length , then consider any\r\nelement at position before the swap. Itâs new position is and the\r\nelement it was paired with, i.e. the element at position goes to the\r\nposition . , so these two elements are still paired after the swap.For\r\nexample, if is , then the pairs are and (their individual ordering in\r\nthe pair doesnât matter). Suppose we first apply the operation on the\r\nprefix of length and then the prefix of length . After the first\r\noperation, is and after the second operation, is . Note that in both\r\nthese arrays, the pairings are still the same, i.e., and .We conclude\r\nthat in any array resulting after some number of operations, these\r\npairings do not change with respect to the initial array. It turns out\r\nthat all such arrays with same pairings as the initial array can be\r\nformed by performing these operations! So we only need to check if the\r\nmultiset of these pairs in is the same as the multiset of pairs in\r\n.Proof:We will show that given any array such that the multiset of pairs\r\nin is the same as the multiset of pairs in , then we can form from in\r\natmost operations. We will start constructing the pairs in starting from\r\nto , i.e., we first bring elements and to their position in followed by\r\nand so on. Note that if we bring the elements and to their respective\r\npositions in then we can delete them in both and and continue the\r\nconstruction. Suppose we currently want to bring elements and to their\r\nrespective positions in . If is at position in , then must be at the\r\nposition . There are three cases: If , then we can swap the prefix and\r\nsuffix of length in to achieve this. Otherwise if , then we can first\r\nswap prefix and suffix of length and then swap prefix and suffix of\r\nlength . Else we can swap prefix and suffix of length in and proceed to\r\nsteps and . In atmost steps, we can bring each pair in to its required\r\nposition in . So we need atmost operations overall.Time complexity:\r\n",
    "hint": []
}