{
    "link": "https://codeforces.com//contest/604/problem/D",
    "problemId": "42008",
    "problem_idx": "D",
    "shortId": "604D",
    "contest_number": "604",
    "problem_submissions": {
        "D": [
            14596500,
            14593346,
            14595214,
            14597164,
            14594625,
            14591286,
            14596851,
            14596627,
            14597744,
            14595935,
            14605132,
            14596012,
            14596656,
            14597363,
            14604366
        ],
        "E": [
            14595112,
            14597709,
            14599612,
            14601657,
            14601583,
            14602620,
            14601006,
            14598712,
            14611507,
            14600405,
            14603271,
            14606898,
            14598106
        ],
        "C": [
            14591727,
            14591485,
            14590401,
            14591803,
            14590167,
            14598812,
            14590931,
            14593957,
            14594227,
            14592838,
            14592345,
            14591994,
            14604053,
            14594007,
            14591853,
            14592988
        ],
        "B": [
            14589366,
            14588467,
            14587631,
            14589936,
            14596744,
            23519332,
            14588532,
            14589419,
            14589534,
            14587511,
            14588487,
            14588973,
            14588129,
            14588264,
            14589189
        ],
        "A": [
            14587013,
            14586403,
            14586260,
            14587679,
            14595485,
            14586765,
            14586177,
            14586973,
            14586715,
            14586347,
            14586267,
            14586259,
            14587001,
            14586457,
            14586288,
            14586867
        ]
    },
    "name": "D. Moodular Arithmetic",
    "statement": "As behooves any intelligent schoolboy, Kevin Sun is studying psycowlogy,\r\ncowculus, and cryptcowgraphy at the Bovinia State University (BGU) under\r\nFarmer Ivan. During his Mathematics of Olympiads (MoO) class, Kevin was\r\nconfronted with a weird functional equation and needs your help. For two\r\nfixed integers and , where is an odd prime number, the functional\r\nequation states that for some function . (This equation should hold for\r\nany integer in the range to , inclusive.)It turns out that can actually\r\nbe many different functions. Instead of finding a solution, Kevin wants\r\nyou to count the number of distinct functions that satisfy this\r\nequation. Since the answer may be very large, you should print your\r\nresult modulo .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, K, P, mod, ans, ap[1000009];\n\nint pow (int a, int b, int pm)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = (1LL * p * a) % pm;\n        a = (1LL * a * a) % pm;\n    }\n    return p;\n}\n\nint main()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &P, &K), mod = 1e9 + 7;\nif (K == 0)\n{\n    printf (\"%d\\n\", pow (P, P - 1, mod));\n    return 0;\n}\n///K > 0 e practic permutare ca exitsa invers modular\nans = 1;\nfor (int i=0; i<P; i++)\n    if (ap[i] == 0)\n    {\n        int j = i, L = 0;\n        while (1)\n        {\n            ap[j] = 1, L ++;\n            j = (1LL * j * K) % P;\n            if (ap[j]) break;\n        }\n//        printf (\"%d\\n\", L);\n        if (pow (K, L, P) == 1) ans = (1LL * ans * P) % mod;\n    }\nprintf (\"%d\\n\", ans);\n\nreturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dsu",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Moodular Arithmetic.json",
    "editorial_link": "https://codeforces.com//blog/entry/21885",
    "editorial": "Hint: First there are special cases k?=?0 and k?=?1. After clearing these out, think about the following: given the value of f(n) for some n, how many other values of f can we find?\n\nWe first have the degenerate cases where k?=?0 and k?=?1. If k?=?0, then the functional equaton is equivalent to f(0)?=?0. Therefore, pp?-?1 functions satisfy this, because the values f(1),?f(2),?...,?f(p?-?1) can be anything in {0,?1,?2,?...,?p?-?1}.\n\nIf k?=?1, then the equation is just f(x)?=?f(x). Therefore pp functions satisfy this, because the values f(0),?f(1),?f(2),?...,?f(p?-?1) can be anything in {0,?1,?2,?...,?p?-?1}.\n\nNow assume that k???2, and let m be the least positive integer such that  This is called the \\emph{order} of  First, plug in x?=?0 to find that  as p is prime, and . Now for some integer , choose a value for f(n). Given this value, we can easily show that  just by plugging in x?=?ki?-?1n into the functional equation and using induction. Note that the numbers n,?kn,?k2n,?...,?km?-?1n are distinct , since m is the smallest number such that . Therefore, if we choose the value of f(n), we get the value of m numbers (). Therefore, if we choose f(n) of  integers n, we can get the value of all p?-?1 nonzero integers. Since f(n) can be chosen in p ways for each of the  integers, the answer is .\n\nAnother way to think about this idea is to view each integer from 0 to p?-?1 as a vertex in a graph, where n is connected to  for every integer i. If we fix the value of f(n) for some n, then f also becomes fixed for all other vertices in its connected component. Thus our answer is p raised to the the number of connected components in the graph.",
    "hint": []
}