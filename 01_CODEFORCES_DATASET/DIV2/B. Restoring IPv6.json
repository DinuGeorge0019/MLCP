{
    "link": "https://codeforces.com//contest/250/problem/B",
    "problemId": "2292",
    "problem_idx": "B",
    "shortId": "250B",
    "contest_number": "250",
    "problem_submissions": {
        "D": [
            2661219,
            2661302,
            2661169,
            2662484,
            2661663,
            2661650,
            2663624,
            2661614,
            2662775,
            2662098,
            2661832,
            2662182,
            2662202,
            2662743,
            2662343,
            2662306
        ],
        "E": [
            2660453,
            2662495,
            2662431,
            2662896,
            2662159,
            2663414,
            2662356,
            2666687,
            2663326,
            3224559
        ],
        "C": [
            2659482,
            2660436,
            2660472,
            2658939,
            2660327,
            2660252,
            2659990,
            2660985,
            2659709,
            2660447,
            2660653,
            2678663,
            2660908,
            2661315,
            2660197,
            2661069,
            2661058
        ],
        "B": [
            2659124,
            2659956,
            2659963,
            2660324,
            2659809,
            2659468,
            2659350,
            2660518,
            2660539,
            2659612,
            2660025,
            2660108,
            2659586,
            2659566,
            2660019,
            2659920
        ],
        "A": [
            2658537,
            2658807,
            2658632,
            2658949,
            2658816,
            2658618,
            2658590,
            2658601,
            2658691,
            2658849,
            2658966,
            2659142,
            2658749,
            2658817,
            2659154,
            2658983
        ]
    },
    "name": "B. Restoring IPv6",
    "statement": "An IPv6-address is a 128-bit number. For convenience, this number is\r\nrecorded in blocks of 16 bits in hexadecimal record, the blocks are\r\nseparated by colons 8 blocks in total, each block has four hexadecimal\r\ndigits. Here is an example of the correct record of a IPv6 address: \"\".\r\nWe’ll call such format of recording an IPv6-address .Besides the full\r\nrecord of an IPv6 address there is a record format. The record of an\r\nIPv6 address can be shortened by removing one or more leading zeroes at\r\nthe beginning of each block. However, each block should contain at least\r\none digit in the short format. For example, the leading zeroes can be\r\nremoved like that: \"\" \"\". There are more ways to shorten zeroes in this\r\nIPv6 address.Some IPv6 addresses contain long sequences of zeroes.\r\nContinuous sequences of 16-bit zero blocks can be shortened to \"\". A\r\nsequence can consist of one or several , with all 16 bits equal to 0.\r\nYou can see examples of zero block shortenings below: \"\" \"\"; \"\" \"\"; \"\"\r\n\"\"; \"\" \"\"; \"\" \"\". It is not allowed to shorten zero blocks in the\r\naddress more than once. This means that the short record can’t contain\r\nthe sequence of characters \"\" more than once. Otherwise, it will\r\nsometimes be impossible to determine the number of zero blocks, each\r\nrepresented by a double colon.The format of the record of the IPv6\r\naddress after removing the leading zeroes and shortening the zero blocks\r\nis called .You’ve got several short records of IPv6 addresses. Restore\r\ntheir full record.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define FOR(it,a) for (__typeof((a).begin()) it=(a).begin();it!=(a).end();++it)\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\ninline int sign(double x)\n{\n    if (x<-eps) return -1;\n    return x>eps;\n}\n\nstruct Tpoint\n{\n    double x,y;\n    Tpoint(){}\n    Tpoint(double x,double y):x(x),y(y){}\n    inline double norm(){return sqrt(x*x+y*y);}\n    inline void rotate(double ang)\n    {\n        double co=cos(ang),si=sin(ang);\n        double tx=x,ty=y;\n        x=tx*co-ty*si;\n        y=tx*si+ty*co;\n    }\n};\n\ninline Tpoint operator +(const Tpoint &a,const Tpoint &b){return Tpoint(a.x+b.x,a.y+b.y);}\ninline Tpoint operator -(const Tpoint &a,const Tpoint &b){return Tpoint(a.x-b.x,a.y-b.y);}\ninline Tpoint operator *(const Tpoint &a,const double &b){return Tpoint(a.x*b,a.y*b);}\ninline Tpoint operator /(const Tpoint &a,const double &b){return Tpoint(a.x/b,a.y/b);}\ninline double det(const Tpoint &a,const Tpoint &b){return a.x*b.y-a.y*b.x;}\ninline double dot(const Tpoint &a,const Tpoint &b){return a.x*b.x+a.y*b.y;}\n//================================\n\nint main()\n{\n    int T;\n    for (scanf(\"%d\",&T);T--;){\n        char s[1000];\n        scanf(\"%s\",s);\n        int n=strlen(s);\n        for (int i=0;i<n;++i){\n            if (s[i]==':' && s[i+1]==':'){\n                for (int j=n;j>=i+1;--j){\n                    s[j+1]=s[j];\n                }\n                s[i+1]='$';\n                ++n;\n            }\n        }\n//intf(\"    \");puts(s);\n        for (int i=0;i<n;++i){\n            if (s[i]==':'){\n                s[i]=' ';\n            }\n        }\n        stringstream in(s);\n        VS a;\n        for (string t;in >> t;){\n            a.PB(t);\n        }\n        \n        int zero=8-a.size()+1;\n//printf(\"zero= %d %d\\n\",zero,a.size());\n//cout << a[0] << endl;\n        string ans=\"\";\n        FOR (it,a){\n            string t=*it;\n            if (t==\"$\"){\n                for (int i=0;i<zero;++i){\n                    ans+=\"0000:\";\n                }\n            }else{\n                while (t.size()<4) t=\"0\"+t;\n                ans+=t+\":\";\n            }\n        }\n        for (int i=0;i+1<ans.size();++i){\n            printf(\"%c\",ans[i]);\n        }\n        puts(\"\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Restoring IPv6.json",
    "editorial_link": "https://codeforces.com//blog/entry/5973",
    "editorial": "Firstly you should split string into substrings using \":\" as separator. All empty substrings will go in the row; you should leave only one of them. Then you should calculate number of nonempty substrings and determine number of zero-blocks whic? will replace empty substring. After replacing you should increase every substring to length 4 inserting leading zeros. After all you should output the answer.",
    "hint": []
}