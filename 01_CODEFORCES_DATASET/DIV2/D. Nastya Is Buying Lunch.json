{
    "link": "https://codeforces.com//contest/1136/problem/D",
    "problemId": "311123",
    "problem_idx": "D",
    "shortId": "1136D",
    "contest_number": "1136",
    "problem_submissions": {
        "E": [
            51189467,
            51191046,
            51188149,
            51188855,
            51190741,
            51191408,
            51191033,
            51190850,
            51194968,
            51193904,
            51191352,
            51194243,
            51193372,
            51194410,
            51195041,
            51186939,
            51301458,
            51187400,
            108142946
        ],
        "D": [
            51180882,
            51177336,
            51181079,
            51182192,
            51180429,
            51179730,
            51184359,
            51186400,
            51182377,
            51185059,
            51181346,
            51187131,
            51180821,
            51187135,
            51188443,
            51182185,
            51181190,
            51180808,
            51185600
        ],
        "C": [
            51175111,
            51174280,
            51177685,
            51177311,
            51177103,
            51175422,
            51178344,
            51175375,
            51179187,
            51176703,
            51175880,
            51179438,
            51181887,
            51178846,
            51181563,
            51198833,
            51176953,
            51176740,
            51179104
        ],
        "B": [
            51173283,
            51172239,
            51175677,
            51174542,
            51172486,
            51175496,
            51178841,
            51174659,
            51174225,
            51173330,
            51175893,
            51182729,
            51176296,
            51176824,
            51173811,
            51174832,
            51175088,
            51177269
        ],
        "A": [
            51171549,
            51171474,
            51171656,
            51171563,
            51171471,
            51172689,
            51176507,
            51172194,
            51172348,
            51171636,
            51172774,
            51183297,
            51171952,
            51174150,
            51171613,
            51171562,
            51173429,
            51171702
        ]
    },
    "name": "D. Nastya Is Buying Lunch",
    "statement": "At the big break Nastya came to the school dining room. There are n\r\npupils in the school, numbered from 1 to n. Unfortunately, Nastya came\r\npretty late, so that all pupils had already stood in the queue, i.e.\r\nNastya took the last place in the queue. Of course, it\u2019s a little bit\r\nsad for Nastya, but she is not going to despond because some pupils in\r\nthe queue can agree to change places with some other pupils.Formally,\r\nthere are some pairs u, v such that if the pupil with number u stands\r\ndirectly in front of the pupil with number v, Nastya can ask them and\r\nthey will change places. Nastya asks you to find the maximal number of\r\nplaces in queue she can move forward.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint N, M;\nset<int> S[303030];\nint P[303030];\nint main()\n{\n  scanf(\"%d%d\", &N, &M);\n  for(int i=1; i<=N; ++i) scanf(\"%d\", P+i);\n  for(int i=0; i<M; ++i)\n  {\n    int u, v; scanf(\"%d%d\", &u, &v);\n    S[u].insert(v);\n  }\n  set<int> reqs; reqs.insert(P[N]);\n  int ans = 0;\n  for(int i=N-1; i>=1; --i)\n  {\n    bool flag = true;\n    for(auto x: reqs)\n    {\n      if(S[P[i]].find(x) == S[P[i]].end())\n      {\n        flag = false;\n        break;\n      } \n    }\n    if(flag) ++ans;\n    else reqs.insert(P[i]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Nastya Is Buying Lunch.json",
    "editorial_link": "https://codeforces.com/blog/entry/65905",
    "editorial": "Solution 1: Let\u00e2\u0080\u0099s solve the proiblem, iterating from the end, adding\r\npupils one by one. I. e for every suffix we are solving original problem\r\nwithout pupils, which don\u00e2\u0080\u0099t belong to this suffix. What happens when we\r\nadd pupil to the suffix?By the time when we add pupil we have answer for\r\nthe previous suffix. In this answer there are, probably, pupils, which\r\nNastya can\u00e2\u0080\u0099t overtake. Let this subset of pupils be . Then, if -th pupil\r\ncan give place for Nastya and all pupils from , we will swap them.\r\nOtherwise, we can add this pupil to . In order to check this condition\r\nwe can iterate through pupils, who can swap with -th pupil, and\r\ncalculate how many are contained in . This solution works in .\r\nObviously, when we consider all suffixes, answer will be .Solution 2:\r\nLet\u00e2\u0080\u0099s build directed graph, where -th vertex corresponds -th pupil and\r\nedge from to exists if and only if pupil can\u00e2\u0080\u0099t give place to pupil and\r\nis closer to the beginning of queue than . We can note that answer is\r\nnumber of vertexes in this graph, which are unreachable from Nastya\u00e2\u0080\u0099s\r\nvertex. Proof:(1) Obviously, if edge from to exists, pupil will always\r\nbe in front of .(2) If vertex is reachable from vertex , the same\r\ncondition is true.Let\u00e2\u0080\u0099s prove that Nastya can overtake pupils, who are\r\nunreachable in graph by giving an algorithm how to do it. Let there are\r\nunreachable vertexes in front of Nastya, - the closest from them. If is\r\ndirectly in front of Nastya, they can swap and number of such vertexes\r\nwill decrease.Otherwise, let be the next pupil after (further from the\r\nbeginning). Because is the closest unreachable vertex, is reachable. So,\r\nthere is no edge from to and they can change their places. We can\r\nsimilarly move further and then swap him with Nastya.Using this\r\nalgorithm, Nastya can overtake all pupils, which correspond unreachable\r\nvertexes.Fine, now we just have to calculate number of such vertexes. It\r\ncan be done with standard algorithm \"DFS by complement graph\".\r\n"
}