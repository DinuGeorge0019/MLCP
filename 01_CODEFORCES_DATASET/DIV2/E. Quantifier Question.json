{
    "link": "https://codeforces.com//contest/1345/problem/E",
    "problemId": "600711",
    "problem_idx": "E",
    "shortId": "1345E",
    "contest_number": "1345",
    "problem_submissions": {
        "E": [
            79194179,
            79196032,
            79220297,
            79200684,
            79201329,
            79219340,
            79391989,
            79268362,
            79267373,
            79247234,
            79230319,
            79193699
        ],
        "D": [
            79182685,
            79185329,
            79189475,
            79188511,
            79179864,
            79171870,
            79173915,
            79165263,
            79173257,
            79175980,
            79176898,
            79242598,
            79180486,
            79183462,
            79179438,
            79180644,
            79181066,
            79182336
        ],
        "C": [
            79166678,
            79171676,
            79174223,
            79183005,
            79155393,
            79157900,
            79170332,
            79162910,
            79161162,
            79163028,
            79162951,
            79164149,
            79160726,
            79164483,
            79165533,
            79167519,
            79166191
        ],
        "B": [
            79161444,
            79162895,
            79158056,
            79159769,
            79152511,
            79154234,
            79151562,
            79156943,
            79155510,
            79156024,
            79158727,
            79152661,
            79151997,
            79158730,
            79160284,
            79158238,
            79157754
        ],
        "A": [
            79149423,
            79162373,
            79160953,
            79149853,
            79149101,
            79148773,
            79149875,
            79150362,
            79149364,
            79149646,
            79148884,
            79148772,
            79158375,
            79151373,
            79149772,
            79149372
        ],
        "F": [
            79200676,
            79276017
        ]
    },
    "name": "E. Quantifier Question",
    "statement": "Logical quantifiers are very useful tools for expressing claims about a\r\nset. For this problem, let’s focus on the set of real numbers\r\nspecifically. There are two kinds of quantifiers: universal (\r\nforall) and existential (\r\nexists). You can read more about them here.The universal quantifier is\r\nused to make a claim that a statement holds . For example:\r\nforall x,x<100 is read as: for all real numbers x, x is less than 100.\r\nThis statement is false.\r\nforall x,x>x-1 is read as: for all real numbers x, x is greater than\r\nx-1. This statement is true. The existential quantifier is used to make\r\na claim that for which the statement holds. For example:\r\nexists x,x<100 is read as: there exists a real number x such that x is\r\nless than 100. This statement is true.\r\nexists x,x>x-1 is read as: there exists a real number x such that x is\r\ngreater than x-1. This statement is true. Moreover, these quantifiers\r\ncan be nested. For example:\r\nforall x,\r\nexists y,x<y is read as: for all real numbers x, there exists a real\r\nnumber y such that x is less than y. This statement is true since for\r\nevery x, there exists y=x+1.\r\nexists y,\r\nforall x,x<y is read as: there exists a real number y such that for all\r\nreal numbers x, x is less than y. This statement is false because it\r\nclaims that there is a maximum real number: a number y larger than every\r\nx. There are n variables x_1,x_2,\r\nldots,x_n, and you are given some formula of the form f(x_1,\r\ndots,x_n):=(x_{j_1}<x_{k_1})\r\nland (x_{j_2}<x_{k_2})\r\nland\r\ncdots\r\nland (x_{j_m}<x_{k_m}), where\r\nland denotes logical AND. That is, f(x_1,\r\nldots, x_n) is true if every inequality x_{j_i}<x_{k_i} holds.\r\nOtherwise, if at least one inequality does not hold, then f(x_1,\r\nldots,x_n) is false.Your task is to assign quantifiers Q_1,\r\nldots,Q_n to either universal (\r\nforall) or existential (\r\nexists) so that the statement Q_1 x_1, Q_2 x_2,\r\nldots, Q_n x_n, f(x_1,\r\nldots, x_n) is true, and , or determine that the statement is false for\r\nevery possible assignment of quantifiers. For example, if\r\nf(x_1,x_2):=(x_1<x_2) then you are not allowed to make x_2 appear first\r\nand use the statement\r\nforall x_2,\r\nexists x_1, x_1<x_2. If you assign Q_1=\r\nexists and Q_2=\r\nforall, it will be interpreted as\r\nexists x_1,\r\nforall x_2,x_1<x_2.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nbool dfs(int pos, vector<vector<int>>& graph, vector<bool>& visited, vector<bool>& onPath) {\n  if (onPath[pos]) return true;\n  if (visited[pos]) return false;\n  onPath[pos] = true;\n  visited[pos] = true;\n\n  for (int adj : graph[pos]) {\n    if (dfs(adj, graph, visited, onPath)) return true;\n  }\n  onPath[pos] = false;\n  return false;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> up(n);\n  vector<vector<int>> down(n);\n\n  vector<bool> up_visited(n, false);\n  vector<bool> down_visited(n, false);\n\n  vector<bool> onPath(n, false);\n\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    up[a].push_back(b);\n    down[b].push_back(a);\n  }\n\n  string result = \"\";\n  int universals = 0;\n\n  for (int i = 0; i < n; i++) {\n    if (up_visited[i] || down_visited[i]) result.push_back('E');\n    else {\n      universals++;\n      result.push_back('A');\n    }\n    if (dfs(i, up, up_visited, onPath) || dfs(i, down, down_visited, onPath)) {\n      cout << \"-1\\n\";\n      return 0;\n    }\n  }\n\n  cout << universals << \"\\n\";\n  cout << result << \"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Quantifier Question.json",
    "editorial_link": "https://codeforces.com//blog/entry/76819",
    "editorial": "Build a directed graph of variables, where an edge corresponds to an\r\ninequality Say that two variables are comparable if there is a directed\r\npath from one variable to the other.Suppose and are comparable with .\r\nThen cannot be universal since is determined before in the order and\r\ntheir comparability restricts the value of . So, a requirement for\r\nuniversality is that the variable is only comparable with larger-indexed\r\nvariables.If there is a cycle of inequalities, then there is no solution\r\nsince the formula is contradictory. Otherwise, the graph is acyclic, so\r\nwe can find a topological order. For each variable, we can find the\r\nminimum index of a node comparable to it by doing DP in forward and\r\nreverse topological order. Then for every variable not comparable to a\r\nsmaller indexed variable, let it be universal. All other variables must\r\nbe existential. Our requirement of universality proves this is\r\noptimal.Letâs prove this assignment gives a true statement (other than\r\nproof by AC). First, we can decrease the index of existential variables,\r\nwhich only strengthens the statement. So letâs decrease the index of\r\neach existential variable to appear just after its largest-indexed\r\ncomparable universal variable.An existential variable may be comparable\r\nto many universal variables, but must be either greater than them all or\r\nless than them all. (Otherwise, we would have two comparable\r\nuniversals.) Without loss of generality, say is greater than its\r\ncomparable universals. And suppose is less than another existential\r\nvariable . Then is comparable to the same universals as , so we can\r\ndetermine the value of later such that it depends on . Therefore, each\r\nexistential variable is only restricted by a lower bound or an upper\r\nbound of smaller-indexed variables. We can properly assign values to\r\nthem, satisfying all inequalities.\r\n",
    "hint": []
}