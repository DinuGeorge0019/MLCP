{
    "link": "https://codeforces.com//contest/1382/problem/C1",
    "problemId": "672679",
    "problem_idx": "C1",
    "shortId": "1382C1",
    "contest_number": "1382",
    "problem_submissions": {
        "E": [
            87580740,
            87589411,
            87581646,
            87592012,
            87582927,
            87692528,
            87775376,
            87717136
        ],
        "D": [
            87555489,
            87548847,
            87561646,
            87566268,
            87542684,
            87550389,
            87559938,
            87557650,
            87551427,
            87566193,
            87564529,
            87561452,
            87563995,
            87564259,
            87570645,
            87563751,
            87565987,
            87569150,
            87571590
        ],
        "C2": [
            87546116,
            87555702,
            87548714,
            87552069,
            87538337,
            87550493,
            87568748,
            87548658,
            87549905,
            87553287,
            87550271,
            87552175,
            87546582,
            87555140,
            87546998,
            87548618,
            87546324
        ],
        "C1": [
            87545885,
            87534226,
            87549038,
            87551870,
            87577593,
            87538735,
            87550728,
            87547738,
            87548907,
            87549506,
            87553050,
            87549957,
            87552439,
            87547080,
            87548161,
            87546830,
            87544742,
            87546462
        ],
        "B": [
            87532814,
            87538666,
            87535698,
            87538451,
            87544080,
            87530844,
            87530725,
            87531828,
            87532147,
            87535077,
            87537243,
            87537711,
            87538752,
            87530008,
            87533230,
            87538244,
            87535683,
            87533610
        ],
        "A": [
            87524660,
            87526155,
            87619468,
            87524613,
            87533175,
            87523893,
            87526148,
            87532501,
            87524134,
            87525800,
            87526012,
            87524222,
            87523259,
            87523315,
            87524086,
            87524062,
            87526273,
            87523705
        ]
    },
    "name": "C1. Prefix Flip  Easy Version ",
    "statement": "There are two binary strings a and b of length n (a binary string is a\r\nstring consisting of symbols 0 and 1). In an operation, you select a\r\nprefix of a, and simultaneously invert the bits in the prefix (0 changes\r\nto 1 and 1 changes to 0) and reverse the order of the bits in the\r\nprefix.For example, if a=001011 and you select the prefix of length 3,\r\nit becomes 011011. Then if you select the entire string, it becomes\r\n001001.Your task is to transform the string a into b in at most 3n\r\noperations. It can be proved that it is always possible.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:10000000000\")\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <set>\n#include <stack>\n#include <vector>\n#include <time.h>\n#include <random>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <complex>\n#define rt return\n#define mp make_pair\n#define endl '\\n'\n#define sqr(x) ((x) * (x))\n#define all(x) (x).begin(), (x).end()\n#define rep(x) for (int rep_iter = 0; rep_iter < x; ++rep_iter)\n#define fnd(x, y) (x.find(y) != x.end())\n#define fndv(x, y) (find(all(x), y) != end(x))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<db, db> pdd;\ntypedef unsigned char bt;\ntypedef unsigned int uint;\nconst int MOD = 1000000007;\nconst int INF = 1000000007LL;\nconst ll INF2 = 1LL << 62LL;\nconst long double EPS = 1e-9;\n#ifdef _DEBUG\nconst int SIZE = 120;\n#endif\n#ifndef _DEBUG\nconst int SIZE = 200010; //200010\n#endif\nmt19937 rng(time(0));\nuniform_int_distribution<int> uid(-1000000000, 1000000000);\n\nint flag, u[SIZE], d[SIZE], a[SIZE], n;\n\nint rec(int i) {\n\tif (i == n - 1)\n\t\trt 1;\n\tif (u[i] == flag)\n\t\trt d[i];\n\tu[i] = flag;\n\tif (a[i] == 1) {\n\t\trt d[i] = !rec(i + 1);\n\t}\n\trt d[i] = 1;\n}\n\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tint tt;\n\tcin >> tt;\n\trep(tt) {\n\t\tint n;\n\t\tcin >> n;\n\t\tstring a, b;\n\t\tcin >> a >> b;\n\t\tint l = 0, r = n - 1, inv = 0;\n\t\tfor (auto& i : a)\n\t\t\ti -= '0';\n\t\tfor (auto& i : b)\n\t\t\ti -= '0';\n\t\tvector<int> ans;\n\t\tfor (int len = n; len >= 1; --len) {\n\t\t\tif ((a[r] ^ inv) != b[len - 1]) {\n\t\t\t\tif ((a[l] ^ inv) == b[len - 1]) {\n\t\t\t\t\tans.push_back(1);\n\t\t\t\t\ta[l] = !a[l];\n\t\t\t\t}\n\t\t\t\tans.push_back(len);\n\t\t\t\tinv = !inv;\n\t\t\t\tswap(r, l);\n\t\t\t}\n\t\t\tif (r >= l)\n\t\t\t\t--r;\n\t\t\telse\n\t\t\t\t++r;\n\t\t}\n\t\tcout << ans.size() << ' ';\n\t\tfor (auto& i : ans)\n\t\t\tcout << i << ' ';\n\t\tcout << endl;\n\t}\n\n\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C1. Prefix Flip  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/80427",
    "editorial": "The easy version has two main solutions:The idea is to fix the bits\r\none-by-one. That is, make , then make , etc. To fix the bit (when ), we\r\ncan flip the prefix of length , then flip the prefix of length , and\r\nagain flip the prefix of length . These three operations do not change\r\nany other bits in , so it\u00e2\u0080\u0099s simple to implement in . Since we use\r\noperations per bit, we use at most operations overall.In this solution,\r\nwe take a similar approach to solution 1, in that we fix the bits\r\none-by-one. This time, we will fix the bits in reverse order. To fix the\r\nbit , we can either flip the prefix of length , or flip the first bit\r\nand then flip the prefix of length . Since we do this in reverse order,\r\nthe previously fixed bits do not get messed up by this procedure. And we\r\nuse at most operations per bit, so operations overall.However, we do\r\nhave to simulate the operations in order to check if we should flip the\r\nfirst bit. Simulating an operation can easily be done in time per\r\noperation, or time to simulate all operations.\r\n"
}