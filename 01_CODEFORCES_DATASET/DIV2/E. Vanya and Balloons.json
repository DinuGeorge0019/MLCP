{
    "link": "https://codeforces.com//contest/677/problem/E",
    "problemId": "61385",
    "problem_idx": "E",
    "shortId": "677E",
    "contest_number": "677",
    "problem_submissions": {
        "E": [
            18198164,
            18204085,
            18197306,
            18200993,
            18200953,
            18195589,
            18203905,
            18215946
        ],
        "D": [
            18193483,
            18198632,
            18200137,
            18203205,
            18194465,
            18198804,
            18199943,
            18195070,
            18202030,
            18197600,
            18197818,
            18198979,
            18200991,
            18199872,
            18199844
        ],
        "B": [
            18190137,
            18189283,
            18188934,
            18189082,
            18188438,
            18189342,
            18189575,
            18188793,
            18188689,
            18189354,
            18191729,
            18192124,
            18189662,
            18190381,
            18192321,
            18189806,
            18199099,
            18189915,
            18189024,
            18192633
        ],
        "C": [
            18189147,
            18192130,
            18193382,
            18190274,
            18190560,
            18190716,
            18189368,
            18190951,
            18190001,
            18192729,
            18189241,
            18189853,
            18190879,
            18188748,
            18189105,
            18191741,
            18199413,
            18194523,
            18189867,
            18194964
        ],
        "A": [
            18185361,
            18186546,
            18186018,
            18185448,
            18185774,
            18186287,
            18186201,
            18185979,
            18185500,
            18187073,
            18192540,
            18186205,
            18189142,
            18189736,
            18185692,
            18198474,
            18185676,
            18185395,
            18188182
        ]
    },
    "name": "E. Vanya and Balloons",
    "statement": "Vanya plays a game of balloons on the field of size , where each cell\r\ncontains a balloon with one of the values , , or . The goal is to\r\ndestroy a cross, such that the product of all values of balloons in the\r\ncross is maximum possible. There are two types of crosses: normal and\r\nrotated. For\r\nexample:**o****o**ooooo**o****o**oro***o*o*o***o***o*o*o***oFormally,\r\nthe cross is given by three integers , and , such that . The normal\r\ncross consists of balloons located in cells (where stay for the number\r\nof the row and for the number of the column), such that and . Rotated\r\ncross consists of balloons located in cells , such that and .Vanya wants\r\nto know the maximum possible product of the values of balls forming one\r\ncross. As this value can be large, output it modulo .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int md=1e9+7;\nint n;\nint a[1003][1003];\nchar q;\nlong double d2[100000];\nlong double d3[100000];\nint up[1003][1003][4];\nint dn[1003][1003][4];\nint lt[1003][1003][4];\nint rt[1003][1003][4];\nint lu[1003][1003][4];\nint ru[1003][1003][4];\nint lulu[1003][1003];\nint ruru[1003][1003];\nint rdrd[1003][1003];\nint ldld[1003][1003];\nint ll[1003][1003];\nint rr[1003][1003];\nint dd[1003][1003];\nint uu[1003][1003];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin>>n;\n    long double k2=log(2.);\n    long double k3=log(3.);\n    for(int i=1;i<=10000;i++)\n    {\n        d2[i]=d2[i-1]+k2;\n        d3[i]=d3[i-1]+k3;\n    }\n    bool f=false;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            cin>>q;\n            a[i][j]=q-'0';\n            if(a[i][j]==1)\n                f=true;\n            for(int k=0;k<=3;k++)\n            {\n                up[i][j][k]=up[i-1][j][k];\n                lt[i][j][k]=lt[i][j-1][k];\n                lu[i][j][k]=lu[i-1][j-1][k];\n            }\n            up[i][j][a[i][j]]++;\n            lt[i][j][a[i][j]]++;\n            lu[i][j][a[i][j]]++;\n            if(a[i][j]==0)\n            {\n                uu[i][j]=0;\n                ll[i][j]=0;\n            }else\n            {\n                uu[i][j]=uu[i-1][j]+1;\n                ll[i][j]=ll[i][j-1]+1;\n            }\n        }\n    for(int i=n;i>0;--i)\n        for(int j=n;j>0;--j)\n        {\n            for(int k=0;k<=3;k++)\n            {\n                dn[i][j][k]=dn[i+1][j][k];\n                rt[i][j][k]=rt[i][j+1][k];\n            }\n            dn[i][j][a[i][j]]++;\n            rt[i][j][a[i][j]]++;\n            if(a[i][j]==0)\n            {\n                dd[i][j]=0;\n                rr[i][j]=0;\n            }else\n            {\n                dd[i][j]=dd[i+1][j]+1;\n                rr[i][j]=rr[i][j+1]+1;\n            }\n        }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            if(a[i][j])\n                lulu[i][j]=1+lulu[i-1][j-1];\n        }\n    for(int i=1;i<=n;i++)\n        for(int j=n;j;--j)\n        {\n            for(int k=0;k<=4;k++)\n                ru[i][j][k]=ru[i-1][j+1][k];\n            ru[i][j][a[i][j]]++;\n            if(a[i][j])\n               ruru[i][j]=1+ruru[i-1][j+1];\n        }\n    for(int i=n;i;--i)\n        for(int j=1;j<=n;j++)\n            if(a[i][j])\n                ldld[i][j]=1+ldld[i+1][j-1];\n    for(int i=n;i;--i)\n        for(int j=n;j;--j)\n            if(a[i][j])\n                rdrd[i][j]=1+rdrd[i+1][j+1];\n    pair<int,int> ans=make_pair(0,0);\n    long double rans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(a[i][j])\n            {\n                int kek=n;\n                kek=min(kek,dd[i][j]);\n                kek=min(kek,uu[i][j]);\n                kek=min(kek,ll[i][j]);\n                kek=min(kek,rr[i][j]);\n                int a2=up[i+kek-1][j][2]-up[i-kek][j][2]+lt[i][j+kek-1][2]-lt[i][j-kek][2];\n                int a3=up[i+kek-1][j][3]-up[i-kek][j][3]+lt[i][j+kek-1][3]-lt[i][j-kek][3];\n                if(a[i][j]==2)\n                    --a2;\n                else\n                if(a[i][j]==3)\n                    --a3;\n                if(d2[a2]+d3[a3]>rans)\n                {\n                    rans=d2[a2]+d3[a3];\n                    ans=make_pair(a2,a3);\n                }\n                kek=n;\n                kek=min(kek,lulu[i][j]);\n                kek=min(kek,ruru[i][j]);\n                kek=min(kek,ldld[i][j]);\n                kek=min(kek,rdrd[i][j]);\n                a2=lu[i+kek-1][j+kek-1][2]-lu[i-kek][j-kek][2]+ru[i+kek-1][j-kek+1][2]-ru[i-kek][j+kek][2];\n                a3=lu[i+kek-1][j+kek-1][3]-lu[i-kek][j-kek][3]+ru[i+kek-1][j-kek+1][3]-ru[i-kek][j+kek][3];\n                if(a[i][j]==2)\n                    --a2;\n                else\n                if(a[i][j]==3)\n                    --a3;\n                if(d2[a2]+d3[a3]>rans)\n                {\n                    rans=d2[a2]+d3[a3];\n                    ans=make_pair(a2,a3);\n                }\n            }\n    long long cur_ans=1;\n    if(ans==make_pair(0,0))\n    {\n        if(f)\n            cout<<\"1\\n\";\n        else\n            cout<<\"0\\n\";\n    }else\n    {\n        for(int i=0;i<ans.first;i++)\n            cur_ans=(cur_ans+cur_ans)%md;\n        for(int i=0;i<ans.second;i++)\n            cur_ans=(cur_ans+cur_ans+cur_ans)%md;\n        cout<<cur_ans<<\"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Vanya and Balloons.json",
    "editorial_link": "https://codeforces.com//blog/entry/45181",
    "editorial": "For each cell take the maximum possible cross with center in this cell,\r\nthat doesn\u00e2\u0080\u0099t contains zeros. To do it fast, we can make arrays of\r\npartial sums for all possible directions, in which each cell will\r\ncontain the number of non-zero balloons in each direction. For example,\r\nif we want to know, how many non-zero balloons are right to cell , we\r\ncan create an array , where if else So now we can for each cell we can\r\nfind the maximum size of cross with the centre in this cell, that will\r\nnot contain zeros. We can compare product for crosses with centers in\r\nthe cells and radius using logarythms. For example, if we need to\r\ncompare 2 crosses with values and , we can compare and , what will be\r\nequivalent to comparing and . We can also use partial sum arrays to find\r\nvalue for each cross, so we can find the product of the values in each\r\ncross for time. Complexity . Code\r\n"
}