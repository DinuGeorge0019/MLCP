{"link": "https://codeforces.com//contest/1316/problem/B", "problemId": "552821", "problem_idx": "B", "shortId": "1316B", "contest_number": "1316", "problem_submissions": {"F": [72472310, 72461023, 73149710, 76233934, 76759743, 72468426], "D": [72446577, 72435880, 72446350, 72433935, 72552354, 72445851, 72441671, 72440731, 72441946, 72448620, 72449884, 72443275, 72430235, 72442450, 72455002, 72438222, 72450604, 72450271, 72453451, 72444636, 72446410], "E": [72439852, 72445012, 72437670, 72448064, 72552368, 72441953, 72444842, 72445763, 72447311, 72441940, 72445222, 72448678, 72435875, 72451508, 72441755, 72436908, 72445710, 72444493, 72446787, 72453158, 72452797], "C": [72433832, 72430966, 72433288, 72428640, 72552344, 72432747, 72431625, 72434362, 72434375, 72433220, 72429941, 72438552, 72442079, 72433103, 72430036, 72452619, 72434221, 72436747, 72434315, 72436157, 72435969], "B": [72429931, 72429194, 72429286, 72432383, 72552325, 72429081, 72434265, 72430795, 72431025, 72431357, 72428379, 72429255, 72460222, 72429093, 72433129, 72438863, 72431653, 72431631, 72430316, 72431406, 72429986], "A": [72421838, 72421944, 72423224, 72422468, 72552315, 72422813, 72422138, 72421848, 72423996, 72421816, 72422254, 72422463, 72428261, 72422024, 72422458, 72422846, 72422294, 72426353, 72423021, 72422856, 72423629]}, "name": "B. String Modification", "statement": "Vasya has a string s of length n. He decides to make the following\r\nmodification to the string: Pick an integer k, (1\r\nleq k\r\nleq n). For i from 1 to n-k+1, reverse the substring s[i:i+k-1] of s.\r\nFor example, if string s is and k = 2, below is the series of\r\ntransformations the string goes through: (original string) (after\r\nreversing the first substring of length 2) (after reversing the second\r\nsubstring of length 2) (after reversing the last substring of length 2)\r\nHence, the resulting string after modifying s with k = 2 is . Vasya\r\nwants to choose a k such that the string obtained after the\r\nabove-mentioned modification is lexicographically smallest possible\r\namong all choices of k. Among all such k, he wants to choose the\r\nsmallest one. Since he is busy attending Felicity 2020, he asks for your\r\nhelp.A string a is lexicographically smaller than a string b if and only\r\nif one of the following holds: a is a prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar str[10001];\nint t;\nint n;\nint b[6001][6001];\nint p[6001];\nbool cmp(const int& x, const int& y) {\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (str[b[x][i]] != str[b[y][i]]) return str[b[x][i]] < str[b[y][i]];\n\t}\n\treturn x < y;\n}\n\nint main( ) {\n\tscanf(\"%d\", &t);\n\twhile (t --) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tfor (int j = i; j <= n; j ++)\n\t\t\t\tb[i][j - i + 1] = j;\n\t\t\tint cur = n - i + 1;\n\t\t\tfor (int j = 1; j < i; j ++) {\n\t\t\t\tif ((n - i + 1) % 2 == 1) {\n\t\t\t\t\tb[i][++ cur] = i - j;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb[i][++ cur] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i ++) p[i] = i;\n\t\tsort(p + 1, p + 1 + n, cmp);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tprintf(\"%c\", str[b[p[1]][i]]);\n\t\tputs(\"\");\n\t\tprintf(\"%d\\n\", p[1]);\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "implementation", "sortings", "strings"], "dificulty": "1400", "interactive": false}