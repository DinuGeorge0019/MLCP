{
    "link": "https://codeforces.com//contest/1521/problem/D",
    "problemId": "977646",
    "problem_idx": "D",
    "shortId": "1521D",
    "contest_number": "1521",
    "problem_submissions": {
        "D": [
            115581818,
            115594850,
            115598612,
            115603691,
            115599448,
            115601993,
            115608478,
            115569159,
            115612872,
            115604589,
            115610795,
            115602271,
            115608146,
            115607408,
            115599985
        ],
        "C": [
            115571933,
            115576814,
            115571686,
            115575287,
            115554792,
            115578008,
            115583346,
            115581715,
            115563254,
            115563941,
            115569253,
            115571673,
            115577961,
            115579502,
            115578223,
            115583699
        ],
        "B": [
            115555782,
            115541222,
            115542122,
            115539078,
            115535984,
            115537884,
            115535617,
            115535973,
            115540952,
            115589944,
            115543027,
            115535929,
            115532822,
            115550853,
            115551249,
            115536556,
            115547431,
            115535420
        ],
        "A": [
            115533383,
            115523492,
            115530232,
            115525696,
            115523586,
            115527609,
            115525343,
            115525115,
            115586248,
            115523901,
            115524582,
            115523559,
            115530582,
            115527602,
            115524514,
            115526011,
            115524612
        ],
        "E": [
            115603853,
            115608158,
            115614666,
            116024421,
            115649428,
            115659057,
            115613282,
            115649743,
            115610712
        ]
    },
    "name": "D. Nastia Plays with a Tree",
    "statement": "The girl will perform the following operation with her tree, as long as\r\nshe needs: Remove any existing edge. Add an edge between any pair of\r\nvertices. What is the number of operations Nastia needs to get a bamboo\r\nfrom a tree? A bamboo is a tree in which no node has a degree greater\r\nthan 2.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \n#define int long long\n \n#define ext exit(0)\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define data data228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n \nconst int maxn = 3e5 + 7, mod = 1e9 + 7, MAXN = 2e6 + 7;\nconst double eps = 1e-9;                                        \nconst ll INF = 1e18, inf = 1e15;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());                       \nint n; \nvector<int> gr[maxn]; \nint dp[maxn][2]; \nint PR[maxn]; \n \nvoid dfs(int u, int pr) {\n    PR[u] = pr; \n    vector<int> vertex; \n    for (auto v : gr[u]) {\n        if (v == pr) continue; \n        dfs(v, u); \n        vertex.pb(v); \n    }\n    dp[u][0] = inf; \n    {\n        int cur = 0; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n        }\n        dp[u][0] = cur + 1; \n    }\n \n    {\n        int cur = 0; \n        vector<pii> type; \n        bool ok = false; \n        int mn = inf; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            if (dp[x][0] <= dp[x][1]) {\n                ok = true; \n            } else {\n                mn = min(mn, dp[x][0] - dp[x][1]); \n            }\n        }\n        if (ok) {\n            dp[u][0] = min(dp[u][0], cur); \n        } else {\n            dp[u][0] = min(dp[u][0], cur + mn); \n        }                      \n    }\n \n \n    dp[u][1] = inf; \n    if ((int)vertex.size() < 2) return; \n    {\n        int cur = 0; \n        vector<int> change; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            change.pb(max(0ll, dp[x][0] - dp[x][1])); \n        }\n        sort(all(change)); \n        cur += change[0]; \n        cur += change[1]; \n        dp[u][1] = cur - 1;             \n    }\n}\n \nint color[maxn]; \nint pt = 0; \n \nvoid solve(int u, int type, int cl) {\n    vector<int> vertex; \n    for (auto v : gr[u]) {\n        if (v == PR[u]) continue; \n        vertex.pb(v); \n    }\n    color[u] = cl; \n    if (type == 0) {\n        {\n \n        int cur = 0; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n        }\n        if (dp[u][0] == cur + 1) {\n            for (auto x : vertex) {\n                if (dp[x][0] < dp[x][1]) {\n                    ++pt; \n                    solve(x, 0, pt); \n                } else {\n                    ++pt; \n                    solve(x, 1, pt); \n                }\n            }                   \n            return; \n        }\n \n        }\n \n        /////////////////////////////////////////////////////////////////////////////////\n        {\n \n        int cur = 0; \n        vector<pii> type; \n        for (auto x : vertex) {\n            cur += min(dp[x][0], dp[x][1]); \n            type.pb({max(0ll, dp[x][0] - dp[x][1]), x}); \n        }\n        sort(all(type)); \n \n        solve(type[0].ss, 0, cl); \n        for (auto x : vertex) {\n            if (x == type[0].ss) continue;\n            if (dp[x][0] < dp[x][1]) {\n                ++pt; \n                solve(x, 0, pt); \n            } else {\n                ++pt; \n                solve(x, 1, pt); \n            }\n        }\n        return; \n        }\n        return;                    \n    }\n \n    int cur = 0; \n    vector<pii> change; \n    for (auto x : vertex) {\n        cur += min(dp[x][0], dp[x][1]); \n        change.pb({max(0ll, dp[x][0] - dp[x][1]), x}); \n    }\n    sort(all(change)); \n    int v1 = change[0].ss; \n    int v2 = change[1].ss; \n    solve(v1, 0, cl); \n    solve(v2, 0, cl); \n    for (auto x : vertex) {\n        if (x == v1 || x == v2) continue; \n        if (dp[x][0] > dp[x][1]) {  \n            ++pt; \n            solve(x, 1, pt); \n        } else {\n            ++pt; \n            solve(x, 0, pt); \n        }\n    }\n}\n \nvector<int> start[maxn]; \n \nvoid solve() {\n    cin >> n; \n    for (int i = 0; i < n; ++i) {\n        gr[i].clear(); \n        start[i].clear(); \n        PR[i] = -1; \n        dp[i][0] = dp[i][1] = inf; \n    }\n    vector<pii> e; \n    for (int i = 0; i < n - 1; ++i) {\n        int a, b; cin >> a >> b, --a, --b; \n        gr[a].pb(b); \n        gr[b].pb(a); \n        e.pb({a, b}); \n    }\n    dfs(0, 0); \n    cout << min(dp[0][0], dp[0][1]) - 1 << '\\n'; \n    pt = 0; \n    if (dp[0][0] < dp[0][1]) {\n        solve(0, 0, 0); \n    } else {\n        solve(0, 1, 0); \n    }\n    vector<pii> del; \n    for (auto v : e) {\n        if (color[v.ff] != color[v.ss]) {\n            del.pb(v); \n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        int bad = 0; \n        for (auto v : gr[i]) {\n            if (color[i] == color[v]) {\n                ++bad; \n            }\n        } \n        if (bad <= 1) {\n            start[color[i]].pb(i);                        \n        }\n    }\n    for (int i = 0; i <= pt; ++i) {\n        if (start[i].size() == 1) {\n            start[i].pb(start[i][0]);         \n        }                \n    }         \n    vector<pii> ms; \n    for (int i = 0; i <= pt; ++i) ms.pb({start[i][0], start[i][1]}); \n    int lst = ms[0].ss; \n    for (int i = 1; i < (int)ms.size(); ++i) {\n        pii x = del.back(); \n        del.pop_back(); \n        cout << x.ff + 1 << \" \" << x.ss + 1 << \" \"; \n        cout << lst + 1 << \" \" << ms[i].ff + 1 << '\\n'; \n        lst = ms[i].ss; \n    }\n}                                \n \nsigned main() {          \n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#endif // LOCAL                                                                             \n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; cin >> t; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "dp",
        "dsu",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Nastia Plays with a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/90477",
    "editorial": "Let\u00e2\u0080\u0099s define the variable as a minimum number of operations that we need\r\nto get bamboo from a tree.Let\u00e2\u0080\u0099s remove edges first and then add new ones\r\nto the graph.Consider the structure of the graph after removing edges.\r\nThis is a with a connected components.Easy to notice each of the\r\nconnected components in the getting forest of trees to get the bamboo\r\nafter adding new edges. Thus, we can get the bamboo from the forest of\r\nbamboo after removing edges by times adding the conjunction between\r\nleaves that are in the different components of connectivity of the\r\nforest. So, the task is to find the minimum number of the removing edges\r\nneeds to get the forest of bamboos. Here works the following greedy:\r\nLet\u00e2\u0080\u0099s define any vertice of the tree as a root.We will solve the problem\r\nfor each of the subtrees .First, solve the problem for all child\r\nvertices of . Then define the value as the number of the children and\r\nthe value as the ancestor for vertex . There are cases: If , then we\r\ndon\u00e2\u0080\u0099t remove anything. If , then we remove the edge if exists. If , then\r\nwe remove the edge if exists and any existing edges from to one of the\r\nchildren vertex. Take a look at the picture:\r\n"
}