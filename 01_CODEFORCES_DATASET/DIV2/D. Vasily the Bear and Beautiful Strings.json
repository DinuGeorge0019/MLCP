{
    "link": "https://codeforces.com//contest/336/problem/D",
    "problemId": "3389",
    "problem_idx": "D",
    "shortId": "336D",
    "contest_number": "336",
    "problem_submissions": {
        "B": [
            4252446,
            4252041,
            4252175,
            4255383,
            4250433,
            4250826,
            4251128,
            4257354,
            4249500,
            4257697,
            4249279,
            4251826,
            4253179,
            4253015,
            4250519,
            4253007,
            4257525,
            4251753,
            4250638,
            4250520
        ],
        "D": [
            4251068,
            4253042,
            4254798,
            4253278,
            4254794,
            4256123,
            4256029,
            4253747,
            4256423,
            4258039,
            4253197,
            4257068,
            4261819,
            4257260,
            4262308
        ],
        "C": [
            4249560,
            4248916,
            4250118,
            4250374,
            4251654,
            4252453,
            4253538,
            4250581,
            4251537,
            4250614,
            4255076,
            4251620,
            4249815,
            4250761,
            4250492,
            4252198,
            4251350,
            4249415,
            4252572,
            4253045
        ],
        "A": [
            4247902,
            4248269,
            4249017,
            4250360,
            4247866,
            4277601,
            4277596,
            4277589,
            4248086,
            4247723,
            4248114,
            4248490,
            4249405,
            4257844,
            4256193,
            4247759,
            4247857,
            4248505,
            4247955,
            4248126,
            4249141,
            4250100,
            4248707,
            4248271
        ],
        "E": [
            4275638
        ]
    },
    "name": "D. Vasily the Bear and Beautiful Strings",
    "statement": "Vasily the Bear loves strings. String is if it meets the following\r\ncriteria: String only consists of characters and , at that character\r\nmust occur in string exactly times, and character must occur exactly\r\ntimes. We can obtain character from string with some (possibly, zero)\r\nnumber of modifications. The character equals either zero or one. A of\r\nstring with length at least two is the following operation: we replace\r\ntwo last characters from the string by exactly one other character. This\r\ncharacter equals one if it replaces two zeros, otherwise it equals zero.\r\nFor example, one modification transforms string \"01010\" into string\r\n\"0100\", two modifications transform it to \"011\". It is forbidden to\r\nmodify a string with length less than two.Help the Bear, count the\r\nnumber of strings. As the number of beautiful strings can be rather\r\nlarge, print the remainder after dividing the number by .\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define mo 1000000007\n#define ll long long\n\nusing namespace std;\n\nll n, m, g, len, last;\nll Now, Ans, i, N, M;\nll f[200005];\n\nll sumi(ll a, ll b);\n\nint main()\n{\n\tscanf(\"%I64d %I64d %I64d\", &n, &m, &g);\n\tlen = n + m;\n\tif (m == 0)\n\t{\n\t\tlast = 1 - (n & 1);\n\t\tif (last == g)\n\t\t\tprintf(\"1\\n\");\n\t\telse\n\t\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\t\n\tif (m == 1)\n\t{\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((i & 1) == 0)\n\t\t\t\tlast = 0;\n\t\t\telse\n\t\t\t\tlast = 1;\n\t\t\tif (last == g)\n\t\t\t\tAns++;\n\t\t}\n\t\t\n\t\tif ((n & 1) == 0)\n\t\t\tlast = 1;\n\t\telse\n\t\t\tlast = 0;\n\t\tif (last == g)\n\t\t\tAns++;\n\t\tprintf(\"%I64d\\n\", Ans);\n\t\treturn 0;\n\t}\n\t\n\tf[0] = 1;\n\tfor (i = 1; i <= n + m; i++)\n\t\tf[i] = f[i - 1] * i % mo;\n\tfor (i = 0; i <= n; i++)\n\t{\n\t\tif ((i & 1) == 0)\n\t\t\tlast = 0;\n\t\telse\n\t\t\tlast = 1;\n\t\tif (last == g)\n\t\t{\n\t\t\tNow = 1;\n\t\t\tN = n + m - i - 1;\n\t\t\tM = m - 1;\n\t\t\tNow *= f[N], Now %= mo;\n\t\t\tNow *= sumi(f[M], mo - 2), Now %= mo;\n\t\t\tNow *= sumi(f[N - M], mo - 2), Now %= mo;\n\t\t\tAns += Now, Ans %= mo;\n\t\t}\n\t}\n\t\n\tprintf(\"%I64d\\n\", Ans);\n\t\n\treturn 0;\n}\n\nll sumi(ll a, ll b)\n{\n\tll ret = 1, c = a, i;\n\tfor (i = 1; i <= b; (i <<= 1))\n\t{\n\t\tif ((b & i) > 0)\n\t\t\tret *= c, ret %= mo;\n\t\tc *= c, c %= mo;\n\t}\n\t\n\treturn ret;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Vasily the Bear and Beautiful Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/8574",
    "editorial": "random binary string, concatenation of strings, . String always\r\ntransforms into , string into . String always transforms into , string\r\ninto . String transforms into , string into , and so on. Using these\r\nfacts let\u00e2\u0080\u0099s consider following solution. Cases like strings without ones\r\nor zeroes are easy. For every (in zero-based numbering) let\u00e2\u0080\u0099s assume\r\nthat it is position of the first occurence of in our string. Using\r\nalready known facts we can understand what is the final result of\r\ntransformations for such string. If the result equals to , we add to the\r\nanswer. Calculation of binomial coefficients is following: , , , where\r\ninverse element modulo . , because is prime number. Author\u00e2\u0080\u0099s solution\r\n"
}