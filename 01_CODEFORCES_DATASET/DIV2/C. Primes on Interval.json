{"link": "https://codeforces.com//contest/237/problem/C", "problemId": "2048", "problem_idx": "C", "shortId": "237C", "contest_number": "237", "problem_submissions": {"D": [2433036, 2432295, 2433500, 2432355, 2433903, 2433329, 2434102, 2434333, 2432248, 2432915, 2696259, 2434308], "E": [2431587, 2432589, 2431675, 2431055, 2432864, 2432954, 2431021, 2430681, 2431544, 2429287, 2431020, 2434055, 2432007, 2431656, 2432219, 2432671, 2432758], "C": [2430148, 2430407, 2429504, 2429737, 2429937, 2428700, 2428982, 2428966, 2427820, 2428219, 2429089, 2428238, 2428941, 2428553, 2429636, 2429650], "B": [2429161, 2428110, 2430688, 2429293, 2429097, 2430858, 2428364, 2428379, 2429868, 2430294, 2429444, 2430807, 2429497, 2429431, 2430215, 2428764, 2429093], "A": [2427471, 2426382, 2427215, 2426994, 2428604, 2426466, 2426659, 2426416, 2427387, 2426339, 2427186, 2426639, 2432021, 2427667, 2426349, 2427479]}, "name": "C. Primes on Interval", "statement": "You\u2019ve decided to carry out a survey in the theory of prime numbers. Let\r\nus remind you that a prime number is a positive integer that has exactly\r\ntwo distinct positive integer divisors.Consider positive integers , , ,\r\n. You want to find the minimum integer such that for any integer among\r\nintegers , , , there are at least prime numbers. Find and print the\r\nrequired minimum . If no value meets the described limitations, print\r\n-1.\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <memory.h>\n#include <cstring>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define down(i,b,a) for(int i=b;i>=a;i--)\n#define foredge(e,x) for(edge *e = x->first;e;e = e->next)\ntypedef long long ll;\nconst int maxnum = 1000000,geps = 1; \nbool not_prime[maxnum];\nint prime[maxnum+geps],pi = 0;\nint sum[maxnum];\nvoid getprime(int top){\n\tnot_prime[1] = true;\n\trep(i,2,top){\n\t\tif(!not_prime[i]) prime[++pi] = i;\n\t\tfor(int j=1;j<=pi && i*prime[j]<=top;j++){\n\t\t\tnot_prime[i*prime[j]] = true;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\nint a,b,k;\nvoid Init(){\n\tscanf(\"%d%d%d\",&a,&b,&k);\n\tgetprime(b);\n\trep(i,1,b) sum[i] = sum[i-1] + (!not_prime[i]);\n}\nbool check(int l){\n\trep(i,a+l-1,b)\n\t\tif(sum[i]-sum[i-l]<k) return false;\n\treturn true;\n}\nvoid solve(){\n\tint l = 1,r = b-a+1;\n\tfor(int m = (l+r)>>1;l<=r;m = (l+r)>>1)\n\t\tcheck(m)?r=m-1:l=m+1;\n\tif(l==b-a+2) printf(\"%d\\n\",-1);\n\telse printf(\"%d\\n\",l);\n}\n\nint main(){\n\tInit();\n\tsolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "number theory", "two pointers"], "dificulty": "1600", "interactive": false}