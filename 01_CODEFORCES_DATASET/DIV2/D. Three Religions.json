{
    "link": "https://codeforces.com//contest/1150/problem/D",
    "problemId": "337488",
    "problem_idx": "D",
    "shortId": "1150D",
    "contest_number": "1150",
    "problem_submissions": {
        "B": [
            53540534,
            53507569,
            53508198,
            53505953,
            53507902,
            53502830,
            53513376,
            53506258,
            53506938,
            53507029,
            53505090,
            53506786,
            53507919,
            53505701,
            53508136,
            53505737,
            53510148,
            53505896,
            53509474,
            53506927
        ],
        "A": [
            53540520,
            53504501,
            53501762,
            53504323,
            53502423,
            53506385,
            53503912,
            53503441,
            53502508,
            53503428,
            53501838,
            53503271,
            53503651,
            53502306,
            53502491,
            53507914,
            53502081,
            53502083,
            53506610,
            53502822
        ],
        "D": [
            53516414,
            53520400,
            53521416,
            53522657,
            53528159,
            53520710,
            53520700,
            53521674,
            53520691,
            53521939,
            53524571,
            53524486,
            53563821,
            53526080,
            53525497,
            53525654,
            53525306,
            53525173,
            53524887,
            53526333,
            53526204
        ],
        "C": [
            53509607,
            53510070,
            53509423,
            53505062,
            53510041,
            53509499,
            53512010,
            53510164,
            53511943,
            53509231,
            53509848,
            53515668,
            53510065,
            53514034,
            53514382,
            53512626,
            53511942,
            53512622,
            53512550
        ],
        "E": [
            53531623,
            53531513,
            53525648
        ]
    },
    "name": "D. Three Religions",
    "statement": "During the archaeological research in the Middle East you found the\r\ntraces of three ancient religions: First religion, Second religion and\r\nThird religion. You compiled the information on the evolution of each of\r\nthese beliefs, and you now wonder if the followers of each religion\r\ncould coexist in peace.The is a long word containing the lowercase\r\nEnglish characters only. At each moment of time, each of the religion\r\nbeliefs could be described by a word consisting of lowercase English\r\ncharacters.The three religions can coexist in peace if their\r\ndescriptions form disjoint subsequences of the . More formally, one can\r\npaint some of the characters of the in three colors: 1, 2, 3, so that\r\neach character is painted in one color, and the description of the i-th\r\nreligion can be constructed from the by removing all characters that\r\naren’t painted in color i.The religions however evolve. In the\r\nbeginning, each religion description is empty. Every once in a while,\r\neither a character is appended to the end of the description of a single\r\nreligion, or the last character is dropped from the description. After\r\neach change, determine if the religions could coexist in peace.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nconst int MAXN=100000,MAXQ=1000,inf=1e9;\nint n,q;\nchar s[MAXN+5];\nint next[MAXN+5][26];\nint len[4];\nchar a[4][255];\nint dp[255][255][255];\nvoid update(int x){\n\tfor(int i=x==1?len[1]:0;i<=len[1];++i){\n\t\tfor(int j=x==2?len[2]:0;j<=len[2];++j){\n\t\t\tfor(int k=x==3?len[3]:0;k<=len[3];++k){\n\t\t\t\tdp[i][j][k]=inf;\n\t\t\t\tif(i&&dp[i-1][j][k]!=inf){\n\t\t\t\t\tdp[i][j][k]=std::min(dp[i][j][k],next[dp[i-1][j][k]+1][a[1][i]-'a']);\n\t\t\t\t}\n\t\t\t\tif(j&&dp[i][j-1][k]!=inf){\n\t\t\t\t\tdp[i][j][k]=std::min(dp[i][j][k],next[dp[i][j-1][k]+1][a[2][j]-'a']);\n\t\t\t\t}\n\t\t\t\tif(k&&dp[i][j][k-1]!=inf){\n\t\t\t\t\tdp[i][j][k]=std::min(dp[i][j][k],next[dp[i][j][k-1]+1][a[3][k]-'a']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tscanf(\"%s\",s+1);\n\tfor(int c=0;c<26;++c){\n\t\tnext[n+1][c]=inf;\n\t\tfor(int i=n;i;--i){\n\t\t\tif(s[i]=='a'+c){\n\t\t\t\tnext[i][c]=i;\n\t\t\t}else{\n\t\t\t\tnext[i][c]=next[i+1][c];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tchar opt,c;\n\t\tint x;\n\t\tscanf(\" %c%d\",&opt,&x);\n\t\tif(opt=='+'){\n\t\t\tscanf(\" %c\",&c);\n\t\t\ta[x][++len[x]]=c;\n\t\t\tupdate(x);\n\t\t}else{\n\t\t\t--len[x];\n\t\t}\n\t\tif(dp[len[1]][len[2]][len[3]]!=inf){\n\t\t\tputs(\"YES\");\n\t\t}else{\n\t\t\tputs(\"NO\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Three Religions.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "For our convenience, construct a two-dimensional helper array where is\r\nthe location of the first occurrence of character in the on position or\r\nlater (or if no such character exists). This array can be created in a\r\nstraightforward in time, by iterating the word from the end to the\r\nbeginning. Consider the equal to . The helper array looks as follows:\r\nActually, for our purposes itâs easier to set (in our example, ) and\r\nalso consider additional links from indices and to index . Why? Weâll\r\nlater need the index of the first occurrence of some character some\r\nlocation . If this already happens to be (, as we already established),\r\nwe can easily see that no requested occurrence exists: Letâs now try to\r\nanswer each query in time. We can do it using dynamic programming: let\r\nbe the length of the shortest prefix of the that contains the disjoint\r\noccurrences of the prefix of length of the first religionâs description,\r\nthe prefix of length of the second religionâs description, and the\r\nprefix of length of the third religionâs description. Each state can be\r\nevaluated in constant time by checking for each religion , what the\r\nprefix length would be if the last character of the prefix is a part of\r\nthe -th religionâs description. (We use the helper array to speed up the\r\nsearch.)How to write the state transitions? For each : chop the last\r\ncharacter of the -th descriptionâs prefix, find the shortest prefix of\r\nthe containing all three descriptions, and then reappend this last\r\ncharacter. We can do that using our helper array:Now, if the lengths of\r\nthe descriptions are , , and , respectively, then the embedding of these\r\ndescriptions as distinct subsequences exists if and only if .However,\r\ndue to the nature of queries, we can do a single update in time: if we\r\ndrop a character, we donât need to recompute any states; if we add a\r\ncharacter to the -th description, we only need to recompute the states\r\nwith equal to the length of the description and there are at most of\r\nthem! This allows us to solve the problem in time.\r\n",
    "hint": []
}