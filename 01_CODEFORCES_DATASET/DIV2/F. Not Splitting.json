{
    "link": "https://codeforces.com//contest/1627/problem/F",
    "problemId": "1262395",
    "problem_idx": "F",
    "shortId": "1627F",
    "contest_number": "1627",
    "problem_submissions": {
        "A": [
            142856858,
            142829078,
            142831063,
            142828619,
            142829282,
            142829501,
            142828956,
            142828768,
            142829546,
            142828636,
            142829064,
            142830437,
            142829297,
            142829030,
            142829071,
            142830213,
            142829290,
            142834401,
            142829511,
            142828971
        ],
        "B": [
            142855615,
            142836231,
            143077575,
            142843639,
            142833513,
            142834057,
            142834633,
            142836507,
            142832659,
            142835053,
            142835365,
            142833153,
            142834936,
            142836596,
            142833128,
            142834428,
            142837068,
            142835176,
            142841259,
            142840070,
            142832942
        ],
        "C": [
            142853368,
            142841436,
            142848282,
            142837534,
            142840619,
            142840854,
            142841599,
            142841065,
            142841353,
            142842344,
            142840078,
            142839450,
            142843531,
            142839772,
            142838837,
            142843623,
            142841636,
            142846207,
            142840529,
            142843637
        ],
        "D": [
            142850438,
            142848536,
            143170284,
            142854619,
            142844350,
            142843215,
            142846147,
            142845730,
            142844598,
            142844258,
            142848096,
            142845506,
            142844896,
            142848460,
            142849869,
            142841967,
            142847523,
            142848652,
            142849056,
            142845741,
            142849286
        ],
        "E": [
            142848975,
            142862261,
            142856441,
            142857018,
            142861778,
            142861405,
            142859738,
            142864236,
            142861113,
            142866137,
            142865452,
            142865639,
            142862871,
            142864756,
            142864934,
            142867450,
            142864191,
            142861812,
            142865000
        ],
        "F": [
            142838000,
            142875000,
            142859934,
            142890898,
            147974497
        ]
    },
    "name": "F. Not Splitting",
    "statement": "There is a k\r\ntimes k grid, where k is even. The square in row r and column c is\r\ndenoted by (r,c). Two squares (r_1, c_1) and (r_2, c_2) are considered\r\nif\r\nlvert r_1 - r_2\r\nrvert +\r\nlvert c_1 - c_2\r\nrvert = 1.An array of adjacent pairs of squares is called if it is\r\npossible to cut the grid along grid lines into two connected, congruent\r\npieces so that each pair is part of the piece. Two pieces are congruent\r\nif one can be matched with the other by translation, rotation, and\r\nreflection, or a combination of these. The picture above represents the\r\nfirst test case. Arrows indicate pairs of squares, and the thick black\r\nline represents the cut. You are given an array a of n pairs of adjacent\r\nsquares. Find the size of the largest strong subsequence of a. An array\r\np is a subsequence of an array q if p can be obtained from q by deletion\r\nof several (possibly, zero or all) elements.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int N=505,INF=0X3F3F3F3F,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint T,n,K,dw[N][N],ri[N][N],dis[N][N];\nbool vis[N][N];\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d%d\",&n,&K);\n\t\trep(i,0,K)rep(j,0,K){\n\t\t\tdw[i][j]=ri[i][j]=0,dis[i][j]=INF;\n\t\t}\n\t\trep(i,1,n){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tif(c<a||d<b)swap(a,c),swap(b,d);\n\t\t\tif(c==a+1){\n\t\t\t\tri[a][b-1]+=1;\n\t\t\t}else{\n\t\t\t\tdw[a-1][b]+=1;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int,pair<int,int> > >que;\n\t\tdis[K/2][K/2]=0;\n\t\tque.emplace(0,make_pair(K/2,K/2));\n\t\tauto calc=[&](int a,int b,int c,int d){\n\t\t\tif(c<a||d<b)swap(a,c),swap(b,d);\n\t\t\tif(c==a+1){\n\t\t\t\treturn dw[a][b];\n\t\t\t}else{\n\t\t\t\treturn ri[a][b];\n\t\t\t}\n\t\t};\n\t\trep(i,0,K)rep(j,0,K)vis[i][j]=0;\n\t\twhile(!que.empty()){\n\t\t\tint x,y;\n\t\t\ttie(x,y)=get<1>(que.top());\n\t\t\tque.pop();\n\t\t\tif(vis[x][y])continue;\n\t\t\tvis[x][y]=1;\n\t\t\trep(k,0,3){\n\t\t\t\tint xx=x+dx[k],yy=y+dy[k];\n\t\t\t\tif(xx>=0&&xx<=K&&yy>=0&&yy<=K){\n\t\t\t\t\tint cur=dis[x][y]+calc(x,y,xx,yy)+calc(K-x,K-y,K-xx,K-yy);\n\t\t\t\t\tif(cur<dis[xx][yy]){\n\t\t\t\t\t\tdis[xx][yy]=cur;\n\t\t\t\t\t\tque.emplace(-dis[xx][yy],make_pair(xx,yy));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,0,K)rep(j,0,K){\n\t\t\tif(i==0||i==K||j==0||j==K){\n\t\t\t\tans=min(ans,dis[i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",n-ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Not Splitting.json",
    "editorial_link": "https://codeforces.com//blog/entry/99067",
    "editorial": "Any cut that splits the square into two congruent parts is rotationally\r\nsymmetric about the center by . It is a special case when the cut is a\r\nvertical or horizontal line. Assume otherwise. Then: One piece has a row\r\ncontaining more than , but less than squares. One piece has a column\r\ncontaining more than , but less than squares. Both exactly pieces\r\ncontain two of the corners of the grid. Now consider the isometry of the\r\nplane bringing one piece to the other. Then the corners of the grid of\r\none piece must map to the corners of the grid of the other piece, since\r\nthere has to be a straight edge connecting them with length , which only\r\nexists between two corners. There are precisely two such isometries that\r\nfit within the bounds of the square: a reflection and a rotation,\r\npictured below, respectively. However if one piece has a row containing\r\nmore than but less than squares, then in the first case the number of\r\nsquares in that row is greater than . The same holds in the case of a\r\nvertical reflection. Hence the cut must be rotationally symmetric. Now\r\nwe can turn the problem into a graph problem. Consider the graph whose\r\nvertices are vertices of the grid and whose edges are edges of the grid.\r\nWe need to minimize the number of pairs of squares that we \"split up\" in\r\nour cut. Note that each pair of squares shares an edge. Thus, we want to\r\nminimize the number of these edges we pass through. Let\u00e2\u0080\u0099s initially\r\nweight all edges with , and increase the weight by for each edge\r\ngiven.Since each cut is rotationally symmetric about the center, we can\r\njust consider finding a minimal-weight path from the boundary to the\r\ncenter, and then rotating this path to find a valid cut. However, there\r\nare three details we need to iron out: The cut may pass through other\r\nweighted edges when rotated. We need to find an efficient way to find\r\nthe shortest path from each boundary point to the center. The cut may be\r\nself-intersecting. The first point can be accounted for by weighting\r\neach edge its rotated counterpart, so both the path and its rotation\r\nwill be counted when finding the shortest path.The second point can be\r\naccounted for by noticing that the boundary of the square has all edges\r\nof weight , so we can just run single source shortest paths from any\r\nsingle point on the boundary.For the third point, consider some path\r\nthat intersects itself when rotated. Suppose we build the path\r\nedge-by-edge, along with its mirror copy. At some point we will hit the\r\nmirror copy. But that means that there is a way with strictly fewer\r\nedges to reach the same point: just take the path from this intersection\r\nto the start of the mirror copy. See the image below. Instead of taking\r\nthe long path (in blue/orange), we can take the shorter path (in\r\ngreen/purple). So now all our details are successfully ironed out. We\r\ncan just run Dijkstra\u00e2\u0080\u0099s algorithm from any vertex and find the length of\r\nthe shortest path, solving the problem in .\r\n"
}