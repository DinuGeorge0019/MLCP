{
    "link": "https://codeforces.com//contest/1957/problem/F1",
    "problemId": "2603604",
    "problem_idx": "F1",
    "shortId": "1957F1",
    "contest_number": "1957",
    "problem_submissions": {
        "F2": [
            257624433,
            257624489,
            257628560,
            257621420,
            257758223,
            257757604,
            257757158,
            257717832,
            257717730,
            257717258,
            257717094,
            257702987,
            257702893,
            257653582,
            257653503,
            257653382,
            257648260,
            257648200,
            257641190,
            257634868,
            258552083,
            257634246,
            257634091,
            257829923,
            257637903,
            257630367,
            257637563,
            257640902,
            257704441,
            257700658,
            257703241,
            257675512
        ],
        "F1": [
            257621694,
            257624482,
            257625658,
            257622086,
            257648013,
            257642139,
            257635215,
            257625683,
            257633642,
            258551844,
            257633990,
            257634721,
            257829841,
            257638057,
            257627166,
            257647697,
            257636396,
            257640746,
            257705007,
            257704891,
            257704777,
            257704536,
            257700768,
            257627958
        ],
        "E": [
            257613753,
            257614244,
            257616954,
            257640621,
            257621102,
            257640619,
            257640273,
            257640555,
            259401179,
            257624465,
            258075127,
            258075029,
            257758887,
            257629108,
            257623748,
            257629560,
            257710288,
            257703200,
            257629906
        ],
        "D": [
            257596630,
            257598457,
            257598487,
            257603992,
            257647200,
            257596253,
            257607704,
            257604728,
            257613557,
            257603006,
            257615450,
            257603399,
            257750188,
            257750155,
            257615591,
            257640469,
            257600270,
            257625077,
            257609428,
            257606452,
            257699780,
            257597686,
            257607920
        ],
        "C": [
            257588829,
            257601875,
            257591094,
            257606559,
            257647316,
            257588836,
            257594613,
            257599149,
            257595684,
            257596544,
            257603207,
            257596444,
            257750051,
            257601967,
            257593914,
            257592224,
            257605529,
            257595109,
            257707171,
            257596812,
            257597956
        ],
        "B": [
            257581790,
            257579250,
            257586196,
            257583617,
            257579912,
            257584731,
            257593706,
            257593301,
            257585131,
            257584270,
            257581125,
            257750016,
            257588415,
            257583409,
            257582823,
            257585712,
            257597823,
            257594421,
            257595763,
            257581837
        ],
        "A": [
            257576275,
            257575809,
            257577678,
            257575791,
            257575498,
            257575836,
            257579145,
            257575454,
            257576815,
            257575470,
            257575437,
            257749968,
            257582519,
            257575927,
            257575935,
            257576650,
            257596800,
            257590104,
            257582071,
            257575937
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128716",
    "editorial": "Let\u00e2\u0080\u0099s start by first solving the problem for , and extend the idea to\r\nlater. To solve for , we\u00e2\u0080\u0099ll find the smallest value that occurs with\r\ndifferent frequencies on the two paths.We\u00e2\u0080\u0099ll solve an easier version by\r\nsolving for two static arrays, instead of solving the problem of two\r\npaths. To find the smallest value that has a different frequency between\r\nthe two arrays, we can have a segment tree on the frequency array for\r\neach static array. Then, we can store the hash of each segment tree node\r\nand perform a descent to find the first point at which the hashes in the\r\ntwo segment trees differ. The hash of a node is the polynomial hash of\r\nthe subarray it corresponds to.Now, in order to use the same technique\r\non the path, we want the frequency array of the path . To achieve this,\r\nwe can use persistent segment trees. We define to be the segment tree\r\nthat corresponds to the frequency array of the values on the path . With\r\nthe idea of persistence, we can quickly compute for all , when we root\r\nat .To compute , we can use this: for every node in the segment tree\r\nthat we want.Hence, we are able to get the segment tree for the two\r\npaths we need to compare in a query. In our solution with the static\r\narrays, we used the polynomial hash to find the first point of\r\ndifference between the two frequency arrays. So, we need a way to\r\nquickly compute the hash of the pseudo node we computed for .If we have\r\ntwo frequency arrays , , , where the hash of a node is the polynomial\r\nhash of the subarray that corresponds to that node.Hence, we can\r\nsay:Hence, we can perform the same descent that we talked about earlier\r\non the derived segment tree.Now to solve this for , you can perform a\r\ndfs on , and keep entering nodes of the segment tree which have\r\ndiffering hashes, until we find values.The total time complexity comes\r\nout to\r\n",
    "name": "F1. Frequency Mismatch  Easy Version ",
    "statement": "You are given an undirected tree of n nodes. Each node v has a value a_v\r\nwritten on it. You have to answer queries related to the tree.You are\r\ngiven q queries. In each query, you are given 5 integers, u_1, v_1, u_2,\r\nv_2, k. Denote the count of nodes with value c on path u_1\r\nrightarrow v_1 with x_c, and the count of nodes with value c on path u_2\r\nrightarrow v_2 with y_c. If there are z such values of c such that x_c\r\nneq y_c, output any\r\nmin(z, k) such values in any order.\r\n",
    "solutions": [
        "/*\u5728\u53d1\u89c9\u90a3\u4e00\u5929 \u5728\u90a3\u4e00\u5929\u6f6e\u6c5b\u6cdb\u4e0a\u9ad8\u7b51\u57ce\u5899\u65f6\u95f4\u8bf7\u5c06\u4e00\u5207\u8bc1\u660e*/#include<bits/stdc++.h>#define mid (l+r>>1)using namespace std;const int maxn=100005,maxt=maxn*30,V=1e5,maxk=20;int n,m,anss,dfns,tot;int a[maxn],rt[maxn],lc[maxt],rc[maxt],ans[maxn],dfn[maxn],st[maxk][maxn],dep[maxn],lg[maxn];unsigned long long sum[maxt],rd[maxn];vector<int>v[maxn];mt19937_64 rnd(time(0));void modify(int l,int r,int &now,int p,unsigned long long v){\ttot++,lc[tot]=lc[now],rc[tot]=rc[now],sum[tot]=sum[now],now=tot;\tsum[now]+=v;\tif(l==r)\t\treturn ;\tif(p<=mid)\t\tmodify(l,mid,lc[now],p,v);\telse modify(mid+1,r,rc[now],p,v);}unsigned long long query(int l,int r,int now,int L,int R){\tif(L<=l&&r<=R)\t\treturn sum[now];\tunsigned long long res=0;\tif(L<=mid)\t\tres+=query(l,mid,lc[now],L,R);\tif(mid<R)\t\tres+=query(mid+1,r,rc[now],L,R);\treturn res;}void dfs(int x,int last){\tdfn[x]=++dfns,st[0][dfns]=last,dep[x]=dep[last]+1;\tmodify(1,V,rt[x],a[x],rd[a[x]]);\tfor(int i=0;i<v[x].size();i++){\t\tint y=v[x][i];\t\tif(y==last)\t\t\tcontinue;\t\trt[y]=rt[x],dfs(y,x);\t}}int calc(int a,int b){\treturn dep[a]<dep[b]? a:b;}int lca(int x,int y){\tif(x==y)\t\treturn x;\tint l=min(dfn[x],dfn[y])+1,r=max(dfn[x],dfn[y]),k=lg[r-l+1];\treturn calc(st[k][l],st[k][r-(1<<k)+1]);}unsigned long long C(int u,int v,int w,int L,int R){\treturn query(1,V,rt[u],L,R)+query(1,V,rt[v],L,R)-2*query(1,V,rt[w],L,R)+(L<=a[w]&&a[w]<=R? rd[a[w]]:0);}int main(){\tscanf(\"%d\",&n),lg[0]=-1;\tfor(int i=1;i<=n;i++)\t\tlg[i]=lg[i>>1]+1;\tfor(int i=1;i<=n;i++)\t\tscanf(\"%d\",&a[i]);\tfor(int i=1;i<=V;i++)\t\trd[i]=rnd();\tfor(int i=1,x,y;i<n;i++)\t\tscanf(\"%d%d\",&x,&y),v[x].emplace_back(y),v[y].emplace_back(x);\tdfs(1,0);\tfor(int i=1;i<=18;i++)\t\tfor(int j=1;j+(1<<i)-1<=n;j++)\t\t\tst[i][j]=calc(st[i-1][j],st[i-1][j+(1<<(i-1))]);\tscanf(\"%d\",&m);\tfor(int T=1,u1,v1,u2,v2,k;T<=m;T++){\t\tscanf(\"%d%d%d%d%d\",&u1,&v1,&u2,&v2,&k);\t\tint w1=lca(u1,v1),w2=lca(u2,v2);\t\tint lst=0;\t\tanss=0;\t\tfor(int i=1;i<=k;i++){\t\t\tint L=lst,R=V+1;\t\t\twhile(L+1<R){\t\t\t\tint MID=(L+R>>1);//\t\t\t\tprintf(\"MID=%d %llu %llu\\n\",MID,C(u1,v1,w1,lst+1,MID),C(u2,v2,w2,lst+1,MID));\t\t\t\tif(C(u1,v1,w1,lst+1,MID)==C(u2,v2,w2,lst+1,MID))\t\t\t\t\tL=MID;\t\t\t\telse R=MID;\t\t\t}\t\t\tif(R>V)\t\t\t\tbreak;\t\t\tans[++anss]=R,lst=R;\t\t}\t\tprintf(\"%d \",anss);\t\tfor(int i=1;i<=anss;i++)\t\t\tprintf(\"%d%c\",ans[i],i==anss? '\\n':' ');\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "hashing",
        "probabilities",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Frequency Mismatch  Easy Version .json"
}