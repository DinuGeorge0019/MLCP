{
    "link": "https://codeforces.com//contest/1719/problem/D2",
    "problemId": "1509974",
    "problem_idx": "D2",
    "shortId": "1719D2",
    "contest_number": "1719",
    "problem_submissions": {
        "B": [
            168566227,
            168520938,
            168532485,
            168523483,
            168546606,
            168527651,
            168529090,
            168521682,
            168524157,
            168525651,
            168544350,
            168524093,
            168532781,
            168524676,
            168524799,
            168528931,
            168523245,
            168535265,
            168542247,
            168526151
        ],
        "C": [
            168564590,
            168527055,
            168563913,
            168534688,
            168554638,
            168544738,
            168548686,
            168548105,
            168536891,
            168541394,
            168530142,
            168539695,
            168544769,
            168539081,
            168537531,
            168544593,
            168539888,
            168546396,
            168551142,
            168534597
        ],
        "D1": [
            168558558,
            168542679,
            168557284,
            168554279,
            168564803,
            171062245,
            168563518,
            168568656,
            168554712,
            168565935,
            168563890,
            168565575,
            168554859,
            168570422,
            168552272,
            168561513,
            168560338,
            168564995,
            168562859,
            168577517
        ],
        "D2": [
            168558497,
            168553599,
            168557602,
            168553982,
            168564623,
            171062226,
            168563176,
            168568769,
            168554473,
            168565713,
            168570996,
            168565418,
            168574779,
            168570083,
            168576109,
            168574448,
            168567511,
            168565085,
            168562615,
            168586718
        ],
        "E": [
            168554365,
            168598287,
            168578854,
            168574119,
            168542245,
            168581099,
            168583743,
            168579840,
            168595833,
            168593319,
            168587676,
            168594973,
            168588543,
            168587843,
            168593966,
            168594751,
            168583071,
            168590461,
            168594089
        ],
        "F": [
            168534987,
            168577836,
            168600287,
            168607443,
            168579023,
            168704091,
            168637926,
            168609385,
            168607981,
            168607715,
            168585958
        ],
        "A": [
            168519209,
            168515375,
            168527134,
            168516968,
            168548303,
            168516013,
            168516695,
            168515925,
            168516176,
            168516243,
            168534710,
            168515665,
            168518019,
            168515902,
            168516007,
            168515846,
            168515950,
            168515461,
            168516618,
            168515960
        ]
    },
    "name": "D2. Burenka and Traditions  hard version ",
    "statement": "Burenka is the crown princess of Buryatia, and soon she will become the\r\nn-th queen of the country. There is an ancient tradition in Buryatia\r\nbefore the coronation, the ruler must show their strength to the\r\ninhabitants. To determine the strength of the n-th ruler, the\r\ninhabitants of the country give them an array of a of exactly n numbers,\r\nafter which the ruler must turn all the elements of the array into zeros\r\nin the shortest time. The ruler can do the following two-step operation\r\nany number of times: select two indices l and r, so that 1\r\nle l\r\nle r\r\nle n and a non-negative integer x, then for all l\r\nleq i\r\nleq r assign a_i := a_i\r\noplus x, where\r\noplus denotes the bitwise XOR operation. It takes\r\nleft\r\nlceil\r\nfrac{r-l+1}{2}\r\nright\r\nrceil seconds to do this operation, where\r\nlceil y\r\nrceil denotes y rounded up to the nearest integer. Help Burenka\r\ncalculate how much time she will need.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1e9+7;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint T,n,a[100005],dp[100005];\nmap<int,int>lst;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;lst.clear();\n\t\tfor(int i=1;i<=n;i++)cin>>a[i];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tlst[a[i-1]]=i-1;\n\t\t\ta[i]^=a[i-1];\n\t\t\tdp[i]=dp[i-1]+1;\n\t\t\tif(lst.count(a[i])){\n\t\t\t\tdp[i]=min(dp[i],dp[lst[a[i]]]+(i-lst[a[i]]-1));\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n]<<endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Burenka and Traditions  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/106049",
    "editorial": "There is an answer where the time spent is minimal and the lengths of all the segments taken are 1 and 2. because of the segment l,r,x\n can be replaced to ?r?l+12?\n of segments of length 2 and 1, or rather [l,l+1,x],[l+2,l+3,x],,[r,r,x]\n(or [r?1,r,x]\n if (l?r+1)\n even).\n\nNote that if al?al+1??ar=0\n is executed for l,r\n, then we can fill the l,r\n subsections with zeros for r?l\n seconds with queries [l,l+1,al],[l+1,l+2,al?al+1],...[r?1,r,al?al+1??ar]\n.\n\nNote that if a segment of length 2 intersects with a segment of length 1, they can be changed to 2 segments of length 1.\n\nIt follows from all this that the answer consists of segments of length 1 and cover with segments of length 2. Then it is easy to see that the answer is (n\n minus (the maximum number of disjoint sub-segments with a xor of 0)), because in every sub-segments with a xor of 0 we can spend 1 second less as I waited before. this amount can be calculated by dynamic programming or greedily. Our solution goes greedy with a set and if it finds two equal prefix xors(prefixl=prefixr\n means that al+1?al+2??ar=0\n), it clears the set.",
    "hint": []
}