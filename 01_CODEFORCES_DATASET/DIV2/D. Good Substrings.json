{
    "link": "https://codeforces.com//contest/271/problem/D",
    "problemId": "2620",
    "problem_idx": "D",
    "shortId": "271D",
    "contest_number": "271",
    "problem_submissions": {
        "E": [
            3100960,
            3101029,
            3101071,
            3101158,
            3100866,
            3102870,
            3101166,
            3102181,
            3104424,
            3101146
        ],
        "D": [
            3097603,
            3098148,
            3098618,
            3105470,
            3097962,
            3097553,
            3102341,
            3095933,
            3103085,
            3099231,
            3098903,
            3234423,
            3234279,
            3097880,
            3098244,
            3098489,
            3098417,
            3098350
        ],
        "C": [
            3096548,
            3096735,
            3096791,
            3098514,
            3096739,
            3100014,
            3097999,
            3096954,
            3097536,
            3097492,
            3096753,
            3096325,
            3097045,
            3096662,
            3097008,
            3099380,
            3096917
        ],
        "B": [
            3095583,
            3095688,
            3095491,
            3095629,
            3097325,
            3094921,
            3095378,
            3095747,
            3095596,
            3095729,
            3095110,
            3095423,
            3095894,
            3095694,
            3096439,
            3095824
        ],
        "A": [
            3094225,
            3094352,
            3094125,
            3094074,
            3095532,
            3094090,
            3094248,
            3094063,
            3094079,
            3094404,
            3093980,
            3094108,
            3094610,
            3094523,
            3094534,
            3094629
        ]
    },
    "name": "D. Good Substrings",
    "statement": "You’ve got string , consisting of small English letters. Some of the\r\nEnglish letters are , the rest are .A substring () of string (where is\r\nthe length of string ) is string .The substring is , if among the\r\nletters there are ones (look at the sample’s explanation to understand\r\nit more clear).Your task is to find the number of distinct good\r\nsubstrings of the given string . Two substrings and are considered\r\ndistinct if their content is different, i.e. .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\nint ans,n,k;\nchar    a[50],C[2000];\nint T[1200000][26];\nint main(){\n    gets(C);n=strlen(C);\n    for(int i=0;i<26;i++){\n        char    c;\n        for(c=getchar();c!='0'&&c!='1';c=getchar());\n        a[i]=c;\n    }\n    scanf(\"%d\",&k);\n    for(int i=0;i<n;i++){\n        int x=0,cnt=0;\n        for(int j=i;j<n;j++){\n            if(a[C[j]-'a']=='0')cnt++;\n            if(cnt>k)break;\n            if(!T[x][C[j]-'a'])T[x][C[j]-'a']=++ans;\n            x=T[x][C[j]-'a'];\n        }\n    }\n    printf(\"%d\",ans);\n    getchar(),getchar();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Good Substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/6662",
    "editorial": "At first, build a trie containing all suffixes of given string (this\r\nstructure is also called explicit suffix tree). Letâs iterate over all\r\nsubstrings in order of indexesâ increasing, i. e. first then Note, that\r\nmoving from a substring to the next one is just adding a single\r\ncharacter to the end. So we can easily maintain the number of bad\r\ncharacters, and also the \"current\" node in the trie. If the number of\r\nbad characters doesnât exceed , then the substring is good. And we need\r\nto mark the corresponding node of trie, if we never did this before. The\r\nanswer will be the number of marked nodes in the trie. There is also an\r\neasier solution, where instead of trie we use Rabin-Karp rolling hash to\r\ncount substrings that differ by content. Just sort the hashes of all\r\ngood substrings and find the number of unique hashes (equal hashes will\r\nbe on adjacent positions after sort). But these hashes are unreliable in\r\ngeneral, so itâs always better to use precise algorithm.\r\n",
    "hint": []
}