{
    "link": "https://codeforces.com//contest/1627/problem/E",
    "problemId": "1262394",
    "problem_idx": "E",
    "shortId": "1627E",
    "contest_number": "1627",
    "problem_submissions": {
        "A": [
            142856858,
            142829078,
            142831063,
            142828619,
            142829282,
            142829501,
            142828956,
            142828768,
            142829546,
            142828636,
            142829064,
            142830437,
            142829297,
            142829030,
            142829071,
            142830213,
            142829290,
            142834401,
            142829511,
            142828971
        ],
        "B": [
            142855615,
            142836231,
            143077575,
            142843639,
            142833513,
            142834057,
            142834633,
            142836507,
            142832659,
            142835053,
            142835365,
            142833153,
            142834936,
            142836596,
            142833128,
            142834428,
            142837068,
            142835176,
            142841259,
            142840070,
            142832942
        ],
        "C": [
            142853368,
            142841436,
            142848282,
            142837534,
            142840619,
            142840854,
            142841599,
            142841065,
            142841353,
            142842344,
            142840078,
            142839450,
            142843531,
            142839772,
            142838837,
            142843623,
            142841636,
            142846207,
            142840529,
            142843637
        ],
        "D": [
            142850438,
            142848536,
            143170284,
            142854619,
            142844350,
            142843215,
            142846147,
            142845730,
            142844598,
            142844258,
            142848096,
            142845506,
            142844896,
            142848460,
            142849869,
            142841967,
            142847523,
            142848652,
            142849056,
            142845741,
            142849286
        ],
        "E": [
            142848975,
            142862261,
            142856441,
            142857018,
            142861778,
            142861405,
            142859738,
            142864236,
            142861113,
            142866137,
            142865452,
            142865639,
            142862871,
            142864756,
            142864934,
            142867450,
            142864191,
            142861812,
            142865000
        ],
        "F": [
            142838000,
            142875000,
            142859934,
            142890898,
            147974497
        ]
    },
    "name": "E. Not Escaping",
    "statement": "Major Ram is being chased by his arch enemy Raghav. Ram must reach the\r\ntop of the building to escape via helicopter. The building, however, is\r\non fire. Ram must choose the optimal path to reach the top of the\r\nbuilding to lose the minimum amount of health.The building consists of n\r\nfloors, each with m rooms each. Let (i, j) represent the j-th room on\r\nthe i-th floor. Additionally, there are k ladders installed. The i-th\r\nladder allows Ram to travel from (a_i, b_i) to (c_i, d_i), but . Ram\r\nalso gains h_i health points if he uses the ladder i. If Ram is on the\r\ni-th floor, he can move either left or right. Travelling across floors,\r\nhowever, is treacherous. If Ram travels from (i, j) to (i, k), he loses\r\n|j-k|\r\ncdot x_i health points.Ram enters the building at (1, 1) while his\r\nhelicopter is waiting at (n, m). What is the minimum amount of health\r\nRam loses if he takes the most optimal path? Note this answer may be\r\nnegative (in which case he gains health). Output \"\" if no matter what\r\npath Ram takes, he cannot escape the clutches of Raghav.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntemplate<class T>bool umin(T&x,const T&y){return y<x?x=y,1:0;}\ntemplate<class T>bool umax(T&x,const T&y){return x<y?x=y,1:0;}\nconst int N=100005;\nconst long long INFLL=0X3F3F3F3F3F3F3F3FLL;\nint T,n,m,K,x[N],aa[N],bb[N],cc[N],dd[N],hh[N];\nlong long dp[N];\nvector<pair<int,int> >in[N],out[N];\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d%d%d\",&n,&m,&K);\n\t\trep(i,1,n)scanf(\"%d\",&x[i]);\n\t\trep(i,1,n)in[i].clear(),out[i].clear();\n\t\trep(i,1,K){\n\t\t\tscanf(\"%d%d%d%d%d\",&aa[i],&bb[i],&cc[i],&dd[i],&hh[i]);\n\t\t\tin[aa[i]].eb(bb[i],i);\n\t\t\tout[cc[i]].eb(dd[i],i);\n\t\t\tdp[i]=INFLL;\n\t\t}\n\t\trep(i,1,n){\n\t\t\tif(i==1){\n\t\t\t\tout[i].eb(1,0);\n\t\t\t}\n\t\t\tsort(in[i].begin(),in[i].end());\n\t\t\tsort(out[i].begin(),out[i].end());\n\t\t\tmap<int,long long>f;\n\t\t\teach(x,out[i])if(get<1>(x)<INFLL){\n\t\t\t\tif(f.find(get<0>(x))==f.end()){\n\t\t\t\t\tf[get<0>(x)]=dp[get<1>(x)];\n\t\t\t\t}else{\n\t\t\t\t\tumin(f[get<0>(x)],dp[get<1>(x)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f.empty()){\n\t\t\t\tfor(auto it=f.begin();it!=f.end();++it){\n\t\t\t\t\tif(next(it)!=f.end()){\n\t\t\t\t\t\tumin(get<1>(*next(it)),get<1>(*it)+1LL*(get<0>(*next(it))-get<0>(*it))*x[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(auto it=prev(f.end());;--it){\n\t\t\t\t\tif(it!=f.begin()){\n\t\t\t\t\t\tumin(get<1>(*prev(it)),get<1>(*it)+1LL*(get<0>(*it)-get<0>(*prev(it)))*x[i]);\n\t\t\t\t\t}else break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto query=[&](int pos)->long long{\n\t\t\t\tauto it=f.lower_bound(pos);\n\t\t\t\tlong long res=INFLL;\n\t\t\t\tif(it!=f.end()){\n\t\t\t\t\tres=min(res,get<1>(*it)+1LL*(get<0>(*it)-pos)*x[i]);\n\t\t\t\t}\n\t\t\t\tif(it!=f.begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tres=min(res,get<1>(*it)+1LL*(pos-get<0>(*it))*x[i]);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t};\n\t\t\teach(x,in[i]){\n\t\t\t\tumin(dp[get<1>(x)],-hh[get<1>(x)]+query(get<0>(x)));\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tlong long ans=query(m);\n\t\t\t\tif(ans<1e18)printf(\"%lld\\n\",ans);else printf(\"NO ESCAPE\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "implementation",
        "shortest paths",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Not Escaping.json",
    "editorial_link": "https://codeforces.com//blog/entry/99067",
    "editorial": "The building plan of the input consists of rooms, which in the worst\r\ncase is however, most of these rooms are unimportant to us. We can\r\ninstead use a much reduced version of the building consisting of at most\r\nrooms, both endpoints of each ladder, as well as our starting and target\r\nrooms.As every ladder connects a lower floor to a higher floor and is\r\none-directional, we can process the rooms floor by floor, from floor to\r\nfloor . On each floor, let\u00e2\u0080\u0099s sort all the rooms in non-decreasing order.\r\nNow, we can use dynamic programming, as well as the compression\r\npreviously mentioned to calculate the minimum distance to get to all\r\nimportant rooms. First, we calculate the minimum cost to get to each\r\nroom using a room on the same floor as an intermediate. We can do this\r\nby iterating over the rooms on a floor twice, once from left to right,\r\nand then once from right to left. Then, for each room on the floor, if\r\nit has a ladder going up from it, we can update the value of the room\r\nwhere the ladder ends.Our answer is the value of the target room.This\r\ncan be implemented in time per test case.\r\n"
}