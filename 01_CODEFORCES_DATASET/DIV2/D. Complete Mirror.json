{
    "link": "https://codeforces.com//contest/1182/problem/D",
    "problemId": "356989",
    "problem_idx": "D",
    "shortId": "1182D",
    "contest_number": "1182",
    "problem_submissions": {
        "D": [
            55455650,
            55586970,
            55459316,
            55455659,
            55458949,
            55453924,
            55478512,
            55482188,
            55498428,
            55481213,
            55567538,
            55453786
        ],
        "E": [
            55450747,
            55461164,
            55449899,
            55449075,
            55460684,
            55454104,
            55453180,
            55453677,
            55453916,
            55451090,
            55454249,
            55453623,
            55476218,
            55446106,
            55449885,
            55454784,
            55483027,
            55456083,
            55457367,
            55456526
        ],
        "A": [
            55445533,
            55434238,
            55434241,
            55436061,
            55434955,
            55434411,
            55437033,
            55434181,
            55435131,
            55435071,
            55434914,
            55434583,
            55476206,
            55434538,
            55436427,
            55434458,
            55434180,
            55434233,
            55434292,
            55434474
        ],
        "B": [
            55445010,
            55437924,
            55440985,
            55440064,
            55439189,
            55438618,
            55443275,
            55439911,
            55437513,
            55438913,
            55441336,
            55438725,
            55438778,
            55476210,
            55439290,
            55442014,
            55440569,
            55438740,
            55438330,
            55438657,
            55438254
        ],
        "C": [
            55442056,
            55444294,
            55448723,
            55461519,
            55444763,
            55447324,
            55449390,
            55446594,
            55444945,
            55447149,
            55449216,
            55447861,
            55449136,
            55476215,
            55459225,
            55455453,
            55447166,
            55483042,
            55444199,
            55447099,
            55446909,
            55445149
        ],
        "F": [
            55479857
        ]
    },
    "name": "D. Complete Mirror",
    "statement": "You have given tree consist of n vertices. Select a vertex as root\r\nvertex that satisfies the condition below. For all vertices v_{1} and\r\nv_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then\r\ndegree(v_{1}) = degree(v_{2}), where degree means the number of vertices\r\nconnected to that vertex, and distance means the number of edges between\r\ntwo vertices. Determine and find if there is such root vertex in the\r\ntree. If there are multiple answers, find any of them.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nint n;\nstruct R{int v,z;}e[222222];\nint K[111111],ce;\nint q[111111],du,my;\nint d[111111],pa[111111];\nint qaq[111111],deg[111111],dep[111111],siz[111111];\n#define push(x) (q[++my]=x)\n#define pop() q[du++]\n#define front() q[du]\n#define clear() (du=1,my=0)\nvoid ins(int a,int b)\n{\n\te[++ce]=(R){b,K[a]};\n\tK[a]=ce;\n\t++deg[a];\n}\nint measure(int u)\n{\n\tclear();\n\tdep[u]=0;\n\tpa[u]=0;\n\tint tot=0;\n\tfor(push(u);du<=my;++tot)\n\t{\n\t\tint u=pop();\n\t\tsiz[u]=1;\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].v!=pa[u])\n\t\t{\n\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\tpa[e[i].v]=u;\n\t\t\tpush(e[i].v);\n\t\t}\n\t}\n\tfor(int i=my;i;--i)\n\t{\n\t\tint u=q[i];\n\t\tif(siz[u]>=(tot+1)>>1)return u;\n\t\tsiz[pa[u]]+=siz[u];\n\t}\n\tassert(0);\n}\nint is_link(int u,int pa)\n{\n\tint cnt=0,z=u;\n\tfor(int i=K[u];i;i=e[i].z)if(e[i].v!=pa)\n\t{\n\t\tz=is_link(e[i].v,u);\n\t\tif(z==-1)return -1;\n\t\t++cnt;\n\t}\n\tif(cnt>1)return -1;\n\treturn z;\n}\nvpii vec;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tins(u,v);\n\t\tins(v,u);\n\t}\n\tint rt=measure(1);\n\tmeasure(rt);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(!qaq[dep[i]])qaq[dep[i]]=deg[i];\n\t\telse if(qaq[dep[i]]!=deg[i])goto hell;\n\t}\n\tprintf(\"%d\\n\",rt);\n\treturn 0;\n\thell:;\n\tbool nlink=0;\n\tint clink=0;\n\tfor(int i=K[rt];i;i=e[i].z)\n\t{\n\t\tint qwq=is_link(e[i].v,rt);\n\t\tif(qwq!=-1)vec.push_back(pii(dep[qwq],e[i].v)),++clink;\n\t}\n\tif(clink==0)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tmap<int,int>mp;\n\tfor(vpii::itr it=vec.begin();it!=vec.end();++it)++mp[it->first];\n\tfor(map<int,int>::itr it=mp.begin();it!=mp.end();++it)\n\t{\n\t\tif(it->second==1)\n\t\t{\n\t\t\tfor(int i=K[rt];i;i=e[i].z)\n\t\t\t{\n\t\t\t\tint qwq=is_link(e[i].v,rt);\n\t\t\t\tif(qwq!=-1)\n\t\t\t\t{\n\t\t\t\t\tif(dep[qwq]==it->first)\n\t\t\t\t\t{\n\t\t\t\t\t\tmeasure(qwq);\n\t\t\t\t\t\tmemset(qaq,0,sizeof(qaq));\n\t\t\t\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!qaq[dep[i]])qaq[dep[i]]=deg[i];\n\t\t\t\t\t\t\telse if(qaq[dep[i]]!=deg[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"%d\\n\",qwq);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "hashing",
        "implementation",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Complete Mirror.json",
    "editorial_link": "https://codeforces.com//blog/entry/67614",
    "editorial": "First, the valid tree should form like the picture below unless the\r\nwhole tree is completely linear. : This node is the top of the tree.\r\nThis node has always degree . This node is always one of the possible\r\nanswers of valid tree. There might be no top node in the tree. : This\r\nnode is the closest children from the top node that satisfies . In other\r\nwords, this node is the end of the leaf branch which includes top node\r\nas leaf. This node can be one of the possible answers of valid tree. If\r\nthere is no semitop in the tree, the whole tree is invalid. : This is\r\nthe area of nodes between semitop node and semibottom nodes. : These\r\nnodes are the closest ancestors from each leaf nodes which satisfies .\r\nIn other words, these nodes are the end of each leaf branches. : These\r\nnodes are the leaves except top node. And also let\u00e2\u0080\u0099s define and are if\r\nthere are only nodes with between and exclusive.There are two ways to\r\nfind the top node and the semitop node. Lawali\u00e2\u0080\u0099s solution. Find the\r\ndiameter path and validate for two leaves of the diameter path. If no\r\nvalid vertex found(i.e. top is not in the diameter path), then the\r\nsemitop should be the middle of the diameter path. Now validate for the\r\nsemitop and the closest directly reachable leaf from semitop. If any\r\nvalid vertex found, print it. Otherwise print . The first case of\r\ndiameter path in valid tree. Semitop node is the middle of diameter\r\npath. The second case of diameter path in valid tree. Top node is the\r\nend of diameter path. McDic\u00e2\u0080\u0099s solution. Clone the whole tree and cut the\r\nleaf branches(include top) from the cloned tree. Let\u00e2\u0080\u0099s call this tree as\r\n\"\". Inner tree consists of only semitop, mid level nodes and semibottom\r\nnodes. Then you can find the semitop by collapsing each level from leaf\r\nnodes of inner tree. Now validate for semitop, the furthest directly\r\nreachable leaf node from semitop, and the closest directly reachable\r\nleaf node from semitop. It is guaranteed that the top node is one of\r\nthose two leaves. If any valid vertex found, print it. Otherwise print .\r\nThis is the inner tree of original tree. You can find the semitop easier\r\nthan before since top is removed in inner tree. Time complexity is .\r\n"
}