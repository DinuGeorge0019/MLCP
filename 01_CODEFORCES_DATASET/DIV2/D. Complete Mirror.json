{"link": "https://codeforces.com//contest/1182/problem/D", "problemId": "356989", "problem_idx": "D", "shortId": "1182D", "contest_number": "1182", "problem_submissions": {"D": [55455650, 55586970, 55459316, 55455659, 55458949, 55453924, 55478512, 55482188, 55498428, 55481213, 55567538, 55453786], "E": [55450747, 55461164, 55449899, 55449075, 55460684, 55454104, 55453180, 55453677, 55453916, 55451090, 55454249, 55453623, 55476218, 55446106, 55449885, 55454784, 55483027, 55456083, 55457367, 55456526], "A": [55445533, 55434238, 55434241, 55436061, 55434955, 55434411, 55437033, 55434181, 55435131, 55435071, 55434914, 55434583, 55476206, 55434538, 55436427, 55434458, 55434180, 55434233, 55434292, 55434474], "B": [55445010, 55437924, 55440985, 55440064, 55439189, 55438618, 55443275, 55439911, 55437513, 55438913, 55441336, 55438725, 55438778, 55476210, 55439290, 55442014, 55440569, 55438740, 55438330, 55438657, 55438254], "C": [55442056, 55444294, 55448723, 55461519, 55444763, 55447324, 55449390, 55446594, 55444945, 55447149, 55449216, 55447861, 55449136, 55476215, 55459225, 55455453, 55447166, 55483042, 55444199, 55447099, 55446909, 55445149], "F": [55479857]}, "name": "D. Complete Mirror", "statement": "You have given tree consist of n vertices. Select a vertex as root\r\nvertex that satisfies the condition below. For all vertices v_{1} and\r\nv_{2}, if distance(root, v_{1}) = distance(root, v_{2}) then\r\ndegree(v_{1}) = degree(v_{2}), where degree means the number of vertices\r\nconnected to that vertex, and distance means the number of edges between\r\ntwo vertices. Determine and find if there is such root vertex in the\r\ntree. If there are multiple answers, find any of them.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nint n;\nstruct R{int v,z;}e[222222];\nint K[111111],ce;\nint q[111111],du,my;\nint d[111111],pa[111111];\nint qaq[111111],deg[111111],dep[111111],siz[111111];\n#define push(x) (q[++my]=x)\n#define pop() q[du++]\n#define front() q[du]\n#define clear() (du=1,my=0)\nvoid ins(int a,int b)\n{\n\te[++ce]=(R){b,K[a]};\n\tK[a]=ce;\n\t++deg[a];\n}\nint measure(int u)\n{\n\tclear();\n\tdep[u]=0;\n\tpa[u]=0;\n\tint tot=0;\n\tfor(push(u);du<=my;++tot)\n\t{\n\t\tint u=pop();\n\t\tsiz[u]=1;\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].v!=pa[u])\n\t\t{\n\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\tpa[e[i].v]=u;\n\t\t\tpush(e[i].v);\n\t\t}\n\t}\n\tfor(int i=my;i;--i)\n\t{\n\t\tint u=q[i];\n\t\tif(siz[u]>=(tot+1)>>1)return u;\n\t\tsiz[pa[u]]+=siz[u];\n\t}\n\tassert(0);\n}\nint is_link(int u,int pa)\n{\n\tint cnt=0,z=u;\n\tfor(int i=K[u];i;i=e[i].z)if(e[i].v!=pa)\n\t{\n\t\tz=is_link(e[i].v,u);\n\t\tif(z==-1)return -1;\n\t\t++cnt;\n\t}\n\tif(cnt>1)return -1;\n\treturn z;\n}\nvpii vec;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tins(u,v);\n\t\tins(v,u);\n\t}\n\tint rt=measure(1);\n\tmeasure(rt);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(!qaq[dep[i]])qaq[dep[i]]=deg[i];\n\t\telse if(qaq[dep[i]]!=deg[i])goto hell;\n\t}\n\tprintf(\"%d\\n\",rt);\n\treturn 0;\n\thell:;\n\tbool nlink=0;\n\tint clink=0;\n\tfor(int i=K[rt];i;i=e[i].z)\n\t{\n\t\tint qwq=is_link(e[i].v,rt);\n\t\tif(qwq!=-1)vec.push_back(pii(dep[qwq],e[i].v)),++clink;\n\t}\n\tif(clink==0)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tmap<int,int>mp;\n\tfor(vpii::itr it=vec.begin();it!=vec.end();++it)++mp[it->first];\n\tfor(map<int,int>::itr it=mp.begin();it!=mp.end();++it)\n\t{\n\t\tif(it->second==1)\n\t\t{\n\t\t\tfor(int i=K[rt];i;i=e[i].z)\n\t\t\t{\n\t\t\t\tint qwq=is_link(e[i].v,rt);\n\t\t\t\tif(qwq!=-1)\n\t\t\t\t{\n\t\t\t\t\tif(dep[qwq]==it->first)\n\t\t\t\t\t{\n\t\t\t\t\t\tmeasure(qwq);\n\t\t\t\t\t\tmemset(qaq,0,sizeof(qaq));\n\t\t\t\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!qaq[dep[i]])qaq[dep[i]]=deg[i];\n\t\t\t\t\t\t\telse if(qaq[dep[i]]!=deg[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"%d\\n\",qwq);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "dp", "hashing", "implementation", "trees"], "dificulty": "2400", "interactive": false}