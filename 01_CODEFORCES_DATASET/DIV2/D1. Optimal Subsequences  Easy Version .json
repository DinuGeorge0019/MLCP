{"link": "https://codeforces.com//contest/1262/problem/D1", "problemId": "479740", "problem_idx": "D1", "shortId": "1262D1", "contest_number": "1262", "problem_submissions": {"F1": [65643346, 65653823, 65643705, 65644730, 65690605, 65651588, 65651277, 66034817, 65646761, 65654524, 65651505, 65653937, 65645081, 65645973, 65647100, 65654475, 65687063, 65647622, 65647339, 65645959], "F2": [65643279, 65653692, 65828965, 65686253, 65649254, 65653062, 65651757, 71816951, 71815917, 71815485, 71815448, 71815068, 71814941, 71814802, 65654320, 65687047, 65652597, 65652697, 65651173], "E": [65639530, 65645042, 65648892, 65652057, 65690596, 65647275, 65647634, 65653097, 65651461, 65648284, 65647900, 97249054, 97246746, 65648360, 65650087, 65951237, 65651779], "D1": [65634593, 65638676, 65638313, 65637479, 65640274, 65640849, 65636529, 65639533, 65642238, 65648533, 65640691, 65638549, 65642536, 65639709, 65635698, 65639724, 65643528, 65642432, 65642224, 65638684], "D2": [65634523, 65638577, 65638418, 65637413, 65640211, 65640949, 65642851, 65639443, 65642574, 65642451, 65640796, 65638763, 65642667, 65639589, 65635638, 65639633, 65643328, 65643512, 65642176, 65638616], "C": [65629762, 65634294, 65634237, 65633719, 65632321, 65635540, 65633375, 65635292, 65633541, 65633864, 65634698, 65633061, 65637189, 65634072, 65640938, 65633298, 65638202, 65638218, 65637587, 65633967], "B": [65627254, 65629631, 65628216, 65627679, 65628556, 65630807, 65628279, 65630765, 65628901, 65628780, 65629802, 65628147, 65626929, 65628945, 65629119, 65627530, 65632823, 65631394, 65633894, 65629398], "A": [65626237, 65626820, 65626466, 65626311, 65627028, 65627733, 65626343, 65627142, 65629675, 65626752, 65627572, 65626402, 65628146, 65626239, 65626787, 65626257, 65626896, 65628642, 65626213, 65626672]}, "name": "D1. Optimal Subsequences  Easy Version ", "statement": "You are given a sequence of integers a=[a_1,a_2,\r\ndots,a_n] of length n. Its is obtained by removing zero or more elements\r\nfrom the sequence a (they do not necessarily go consecutively). For\r\nexample, for the sequence a=[11,20,11,33,11,20,11]:\r\n[11,20,11,33,11,20,11], [11,20,11,33,11,20], [11,11,11,11], [20],\r\n[33,20] are subsequences (these are just some of the long list); [40],\r\n[33,33], [33,20,20], [20,20,11,11] are not subsequences. Suppose that an\r\nadditional non-negative integer k (1\r\nle k\r\nle n) is given, then the subsequence is called if: it has a length of k\r\nand the sum of its elements is the maximum possible among all\r\nsubsequences of length k; and among all subsequences of length k that\r\nsatisfy the previous item, it is minimal. Recall that the sequence\r\nb=[b_1, b_2,\r\ndots, b_k] is lexicographically smaller than the sequence c=[c_1, c_2,\r\ndots, c_k] if the first element (from the left) in which they differ\r\nless in the sequence b than in c. Formally: there exists t (1\r\nle t\r\nle k) such that b_1=c_1, b_2=c_2, ..., b_{t-1}=c_{t-1} and at the same\r\ntime b_t<c_t. For example: [10, 20, 20] lexicographically less than [10,\r\n21, 1], [7, 99, 99] is lexicographically less than [10, 21, 1], [10, 21,\r\n0] is lexicographically less than [10, 21, 1]. You are given a sequence\r\nof a=[a_1,a_2,\r\ndots,a_n] and m requests, each consisting of two numbers k_j and pos_j\r\n(1\r\nle k\r\nle n, 1\r\nle pos_j\r\nle k_j). For each query, print the value that is in the index pos_j of\r\nthe optimal subsequence of the given sequence a for k=k_j.For example,\r\nif n=4, a=[10,20,30,20], k_j=2, then the optimal subsequence is [20,30]\r\nit is the minimum lexicographically among all subsequences of length 2\r\nwith the maximum total sum of items. Thus, the answer to the request\r\nk_j=2, pos_j=1 is the number 20, and the answer to the request k_j=2,\r\npos_j=2 is the number 30.\r\n", "solutions": ["//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint F[N];\n\nvoid add(int x) {\n    for (; x < N; x = (x | (x + 1))) {\n        F[x]++;\n    }\n}\n\nint get(int x) {\n    int res = 0;\n    for (; x >= 0; x = (x & (x + 1)) - 1) {\n        res += F[x];\n    }\n    return res;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n];\n    rep(i, 0, n) {\n        cin >> a[i];\n    }\n    map<int, vector<int> > mapa;\n    rep(i, 0, n) {\n        mapa[a[i]].push_back(i);\n    }\n    auto it = --mapa.end();\n    int q;\n    cin >> q;\n    vector<pair<int, pair<int, int> > > Q(q);\n    rep(i, 0, q) {\n        int k, pos;\n        cin >> k >> pos;\n        Q[i] = {k, {pos, i}};\n    }\n    sort(Q.begin(), Q.end());\n    int ans[q];\n    int cur = 0;\n    for (auto item : Q) {\n        int k = item.fi, pos = item.se.fi;\n        while (cur + sz(it->se) < k) {\n            for (int p : it->se) {\n                add(p);\n            }\n            cur += sz(it->se);\n            it--;\n        }\n        int need = k - cur;\n        vector<int> &tmp = it->se;\n        int p_good = need - 1;\n        int l = -1, r = n - 1, mid;\n        while (r - l > 1) {\n            mid = (l + r) / 2;\n            int cnt = get(mid);\n            int p_tmp = upper_bound(tmp.begin(), tmp.end(), mid) - tmp.begin() - 1;\n            cnt += min(p_good, p_tmp) + 1;\n            if (cnt >= pos) {\n                r = mid;\n            } else {\n                l = mid;\n            }\n        }\n        ans[item.se.se] = a[r];\n    }\n    rep(i, 0, q) {\n        cout << ans[i] << \"\\n\";\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "1600", "interactive": false}