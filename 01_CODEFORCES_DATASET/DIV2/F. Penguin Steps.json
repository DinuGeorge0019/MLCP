{
    "link": "https://codeforces.com//contest/2109/problem/F",
    "problemId": "3390993",
    "problem_idx": "F",
    "shortId": "2109F",
    "contest_number": "2109",
    "problem_submissions": {
        "C2": [
            320118950,
            320073736,
            320068679,
            320124378,
            320088007,
            320099914,
            320088056,
            320105924,
            320094095,
            320054092,
            320088375,
            320117252,
            320159702,
            320297948,
            320129461
        ],
        "E": [
            320106052,
            320125847,
            320119663,
            320112747,
            320118295,
            320121207,
            320131663,
            320110730,
            320128078,
            320129236,
            320110744,
            320127177,
            320108066,
            320117106,
            320128297,
            320112511,
            320120975
        ],
        "D": [
            320084454,
            320096087,
            320086735,
            320070362,
            320102091,
            320074349,
            320103285,
            320093531,
            320100400,
            320105158,
            320078822,
            320113231,
            320125387,
            320105790,
            320100126,
            320105353,
            320099936
        ],
        "C1": [
            320061130,
            320073433,
            320068905,
            320093298,
            320088271,
            320100091,
            320074252,
            320072104,
            320084300,
            320083297,
            320050083,
            320088782,
            320116287,
            320087460,
            320071464,
            320092016,
            320091499
        ],
        "B": [
            320050560,
            320061643,
            320055414,
            320051017,
            320057316,
            320061436,
            320061341,
            320059001,
            320056714,
            320064357,
            320163023,
            320069479,
            320059381,
            320057224,
            320059103,
            320056729,
            320106329
        ],
        "A": [
            320046103,
            320049390,
            320046455,
            320052253,
            320046661,
            320045885,
            320049476,
            320051953,
            320049481,
            320055558,
            320125055,
            320054117,
            320047392,
            320045825,
            320051802,
            320046883,
            320046433
        ],
        "C3": [
            320075162,
            320252987,
            320173697,
            320298218
        ],
        "F": [
            320205542,
            320345282
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142960",
    "editorial": "Idea by MOUFLESS, prepared by MOUFLESS. SolutionFirst, find using\r\nDijkstra’s algorithm or DSU.Define to be true if you can make greater\r\nthan or equal to , and false otherwise. It’s clear that if is true, then\r\nis also true, which leads us to perform a binary search on the value of\r\n.Suppose we choose a set of black cells with values strictly less than\r\nand decide to apply operations on them; the optimal strategy is to make\r\nthe values of all chosen cells equal to .Now, suppose we don’t care\r\nabout . How can we find the maximum possible ?We need to create a cage\r\nthat separates Fouad from the exit. The cage consists of the borders of\r\nthe grid, in addition to cells with values greater than or equal to\r\n(after applying operations), forming a connected chain such that every\r\ntwo consecutive cells in the chain share an edge or corner.By using\r\nmulti-source Dijkstra’s algorithm, start from one border and try to\r\nreach another, where the weight of each cell represents how many\r\noperations are needed to raise its value to at least . If it cannot be\r\nreached (e.g., if the cell is white and its value is less than ), then\r\nset the weight to infinity.We have six cases to build the cage, as\r\ndescribed in the picture below: Now we have two cases to consider: : In\r\nthis scenario, will remain unchanged regardless of the set we choose. :\r\nHere, we must ensure that at least one path for Mouf has a cost equal to\r\n, while ensuring that no cell in this path is included in . But which\r\npath should we retain?Suppose Mouf takes a path . This action divides\r\nthe grid into two parts: Every cell reachable from without passing\r\nthrough any cell in . This portion belongs to Fouad (if is already in ,\r\nthen there are no cells that belong to Fouad’s part). The remaining\r\ncells belong to Mouf. As we observe, the more cells allocated to Fouad’s\r\npart, the greater the options we have for constructing a cage.\r\nTherefore, we define a super path as a path that leaves the maximum\r\nnumber of cells available for Fouad’s part. But how many super paths\r\nexist?In fact, there is only one super path; the proof can be found\r\nbelow. ProofSuppose we have two super paths that intersect at certain\r\ncells (including the first and last cells). In this case, we have two\r\nscenarios to consider: They only intersect at the first and last cells.\r\nIn this situation, one of the paths cannot be a super path, leading to a\r\ncontradiction. They intersect at other cells: If this is the case, then\r\nneither of the paths can be considered a super path. We can take the\r\noptimal segments from each path to construct a superior path, which also\r\nleads to a contradiction. For further clarification, please refer to the\r\nillustration below. Now, how do we identify that super path?We begin by\r\nperforming a multi-source BFS, initializing the queue with the cells in\r\nthe first row and the first cells of the last column (as they always\r\nbelong to Mouf’s part). When visiting a cell, we mark it. If its value\r\nis less than or equal to , we pop it from the queue and continue;\r\notherwise, we spread to the eight neighboring cells.Through this\r\nprocess, we will have certainly marked the super path (and potentially\r\nsome additional cells from Mouf’s part). If , it becomes impossible to\r\nutilize any marked cell to construct the cage therefore, we set the\r\nweight for these cells to infinity. While you might consider the marked\r\ncells that are not part of the super path, this is inconsequential since\r\nany cage utilizing these cells will invariably pass through the super\r\npath.The overall time complexity of this approach is: .\r\n",
    "name": "F. Penguin Steps",
    "statement": "Mouf and Fouad are standing on an n\r\ntimes n grid. Each cell (i, j) has a value a_{i,j} and a color. The\r\ncolor of a cell is white if c_{i,j} = 0 and black if c_{i,j} = 1.Mouf\r\nstarts at the top-left corner (1, 1), and Fouad starts at the\r\nbottom-left corner (n, 1). Both are trying to reach the exit cell at (r,\r\nn).A path is defined as a sequence of adjacent cells (sharing a\r\nhorizontal or vertical edge). The cost of a path is the maximum value of\r\na_{i, j} among all cells included in the path (including the first and\r\nlast cells).Let:\r\nmathrm{dis}_M denote the minimum possible cost of a valid path from\r\nMouf’s starting position (1, 1) to the exit (r, n);\r\nmathrm{dis}_F denote the minimum possible cost of a valid path from\r\nFouad’s starting position (n, 1) to the exit (r, n). Before moving, Mouf\r\ncan perform up to k operations. In each operation, he may select any\r\nblack cell and increment its value by 1 (possibly choosing the same cell\r\nmultiple times).Mouf wants to maximize\r\nmathrm{dis}_F while ensuring that his own cost\r\nmathrm{dis}_M remains (as if he performed no operations). If Mouf acts\r\noptimally, what are the values of\r\nmathrm{dis}_M and\r\nmathrm{dis}_F?\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "flows",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Penguin Steps.json",
    "hint": [
        "Hint 1 Suppose you need . To achieve this, construct a \"cage\" — a contiguous path of cells all with values at least — that separates Fouad from the exit, while ensuring that remains unchanged.",
        "Hint 2 Try to find a path for Mouf that impacts the building of the \"cage\" as little as possible."
    ]
}