{"link": "https://codeforces.com//contest/844/problem/E", "problemId": "119860", "problem_idx": "E", "shortId": "844E", "contest_number": "844", "problem_submissions": {"E": [29756968, 29759454], "D": [29751901, 29749751, 29752230, 29744882, 29754410, 29749697, 29747401, 29753891, 29758770, 29748328, 29748181, 29749142, 29750857, 29750829, 29761893, 29754092, 29743329, 29750981, 29749760], "C": [29741295, 29740844, 29742968, 29741006, 29747704, 29741133, 29741950, 29743007, 29740184, 29743433, 29743333, 29743161, 29739699, 29742503, 29743461, 29743085, 29739885, 29746382, 29743128], "B": [29738891, 29738862, 29738821, 29739393, 29740604, 29739250, 29739828, 29740063, 29740342, 29741491, 29739840, 29740823, 29739918, 29740419, 29741146, 29738493], "A": [29736508, 31176684, 29736048, 29736305, 29736555, 29736534, 29736883, 29737174, 29736466, 29737056, 29736249, 29736083, 29736171, 29736915, 29737290, 29736045]}, "name": "E. Upgrading Tree", "statement": "You are given a tree with vertices and you are allowed to perform\r\ntransformations on it. Transformation is defined by three vertices and\r\nconsists of deleting edge and adding edge . Transformation could be\r\nperformed if all the following conditions are satisfied: There is an\r\nedge in the current tree. After the transformation the graph remains a\r\ntree. After the deletion of edge the tree would consist of two connected\r\ncomponents. Let\u2019s denote the set of nodes in the component containing\r\nvertex by , and the set of nodes in the component containing vertex by .\r\nThen condition should be satisfied, i.e. the size of the component with\r\nshould be strictly larger than the size of the component with . You\r\nshould the sum of squared distances between all pairs of vertices in a\r\ntree, which you could get after no more than transformations and output\r\nany sequence of transformations leading initial tree to such state.Note\r\nthat you don\u2019t need to minimize the number of operations. It is\r\nnecessary to minimize only the sum of the squared distances.\r\n", "solutions": ["#include<cstdio>\n#include<vector>\nusing namespace std;\nint cnt[200001], n, par;\nvector<int> adj[200001];\nvector<pair<int, int> > v;\nvoid count(int h, int p) {\n    cnt[h]++;\n    for (auto it : adj[h]) if (it^p) {\n        count(it, h);\n        cnt[h] += cnt[it];\n    }\n}\nint ct(int h, int p) {\n    for (auto it : adj[h]) if (it^p) {\n        if (cnt[it] > n / 2) return ct(it, h);\n    }\n    par = p;\n    return h;\n}\nvector<pair<int, pair<int, int> > > res;\nvoid dfs(int h, int p) {\n    for (auto it : adj[h]) if (it^p) {\n        dfs(it, h);\n    }\n    v.push_back({ h,p });\n}\nvoid f(int h, int p) {\n    v.clear();\n    dfs(h, p);\n    v.pop_back();\n    int t = h;\n    for (auto it : v) {\n        res.push_back({ p,{t,it.first} });\n        res.push_back({ it.first,{it.second,h} });\n        t = it.first;\n    }\n    res.push_back({ p,{t,h} });\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    count(1, 0);\n    int cen = ct(1, 0), cen2 = 0;\n    for (auto it : adj[cen]) if (par^it && 2*cnt[it] == n) cen2 = it;\n    for (auto it : adj[cen]) if (it^cen2) f(it, cen);\n    for (auto it : adj[cen2]) if (it^cen) f(it, cen2);\n    printf(\"%d\\n\", res.size());\n    for (auto it : res) printf(\"%d %d %d\\n\", it.first, it.second.first, it.second.second);\n    return 0;\n}"], "input": "", "output": "", "tags": [], "dificulty": "2600", "interactive": false}