{
    "link": "https://codeforces.com//contest/1937/problem/E",
    "problemId": "2503243",
    "problem_idx": "E",
    "shortId": "1937E",
    "contest_number": "1937",
    "problem_submissions": {
        "E": [
            250576191,
            250576177,
            248956893,
            248968788,
            248957297,
            248966672,
            249441680,
            249396118,
            248946403,
            248968676,
            250133778
        ],
        "D": [
            248945664,
            248934669,
            248940205,
            248942769,
            248942389,
            248945370,
            250100307,
            248949877,
            248955428,
            248958358,
            248955920,
            248959000,
            248953793,
            248954441,
            248955304,
            248954744,
            248950479,
            248956622
        ],
        "C": [
            248925723,
            248918003,
            248945269,
            248925093,
            248927475,
            248916202,
            248925097,
            248924482,
            248928585,
            248926397,
            248923906,
            248930862,
            248927119,
            248930899,
            248930534,
            249020336,
            248929752,
            248931403,
            248935918,
            248933256
        ],
        "B": [
            248910702,
            248909576,
            248913624,
            248915352,
            248915231,
            248904510,
            248914972,
            248915980,
            248915024,
            248914144,
            248910066,
            248915252,
            248914074,
            248914693,
            248914679,
            249015802,
            248915248,
            248914394,
            248908476,
            248910261
        ],
        "A": [
            248903051,
            248903069,
            248903106,
            248903549,
            248904708,
            248903046,
            248903582,
            248903569,
            248903261,
            248903372,
            248905387,
            248903521,
            248905435,
            248904180,
            248904557,
            248904753,
            248904311,
            248904712,
            248903327
        ],
        "F": [
            250203263
        ]
    },
    "name": "E. Pok\u00e9mon Arena",
    "statement": "You are at a dueling arena. You also possess n Pok mons. Initially, only\r\nthe 1-st Pok mon is standing in the arena.Each Pok mon has m attributes.\r\nThe j-th attribute of the i-th Pok mon is a_{i,j}. Each Pok mon also has\r\na cost to be hired: the i-th Pok mon\u2019s cost is c_i.You want to have the\r\nn-th Pok mon stand in the arena. To do that, you can perform the\r\nfollowing two types of operations any number of times in any order:\r\nChoose three integers i, j, k (1\r\nle i\r\nle n, 1\r\nle j\r\nle m, k > 0), increase a_{i,j} by k permanently. The cost of this\r\noperation is k. Choose two integers i, j (1\r\nle i\r\nle n, 1\r\nle j\r\nle m) and hire the i-th Pok mon to duel with the current Pok mon in the\r\narena based on the j-th attribute. The i-th Pok mon will win if a_{i,j}\r\nis the j-th attribute of the current Pok mon in the arena (otherwise, it\r\nwill lose). After the duel, only the winner will stand in the arena. The\r\ncost of this operation is c_i. Find the minimum cost you need to pay to\r\nhave the n-th Pok mon stand in the arena.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x first\n#define y second\n#define int long long\n#define mp(x, y) make_pair(x, y)\n#define eb(...) emplace_back(__VA_ARGS__)\n#define fro(i, x, y) for(int i = (x); i <= (y); i++)\n#define pre(i, x, y) for(int i = (x); i >= (y); i--)\ninline void JYFILE19();\n\ntypedef int64_t i64;\ntypedef pair<int, int> PII;\n\nbool ST;\nconst int N = 1e6 + 10;\n\nint n, m, ct, tt, c[N], id[N], dis[N], vis[N], head[N];\nvector<int> a[N], d1[N], d2[N];\nstruct edge {\n  int to, nxt, val;\n} e[N * 4];\n\ninline void cl(vector<int> &a) {\n  vector<int> s; swap(a, s);\n}\ninline void add(int x, int y, int z) {\n  e[++ct] = {y, head[x], z}, head[x] = ct;\n}\n\ninline void solve() {\n  cin >> n >> m;\n  fro(i, 1, n) {\n    a[i].resize(m + 1);\n    d1[i].resize(m + 1);\n    d2[i].resize(m + 1);\n    fro(j, 1, m) d1[i][j] = ++tt;\n    fro(j, 1, m) d2[i][j] = ++tt;\n  }\n  fro(i, 1, n) {\n    cin >> c[i];\n    fro(j, 1, m) {\n      add(d1[i][j], d2[i][j], c[i]);\n      add(d2[i][j], d1[i][j], 0);\n    }\n  }\n  fro(i, 1, n) {\n    fro(j, 1, m) {\n      cin >> a[i][j];\n      if(j != m) {\n        add(d2[i][j], d2[i][j + 1], 0);\n        add(d2[i][j + 1], d2[i][j], 0);\n      }\n    }\n  }\n  iota(id + 1, id + n + 1, 1);\n  fro(j, 1, m) {\n    sort(id + 1, id + n + 1, [&](int x, int y) {\n      return a[x][j] < a[y][j];\n    });\n    fro(i, 1, n) {\n      if(i != n) {\n        add(d1[id[i]][j], d1[id[i + 1]][j], 0);\n        add(d1[id[i + 1]][j], d1[id[i]][j], a[id[i + 1]][j] - a[id[i]][j]);\n      }\n    }\n  }\n  priority_queue<PII, vector<PII>, greater<PII>> q;\n  fill(vis + 1, vis + tt + 1, 0);\n  fill(dis + 1, dis + tt + 1, 1e17);\n  fro(j, 1, m) q.emplace(dis[d2[1][j]] = 0, d2[1][j]);\n  while(q.empty() == 0) {\n    int x = q.top().y; q.pop();\n    if (vis[x]) continue; vis[x] = 1;\n    for (int i = head[x]; i; i = e[i].nxt) {\n      if (dis[e[i].to] > dis[x] + e[i].val) {\n        dis[e[i].to] = dis[x] + e[i].val;\n        q.emplace(dis[e[i].to], e[i].to);\n      }\n    }\n  }\n  int ans = 1e17;\n  fro(j, 1, m) ans = min(ans, dis[d2[n][j]]);\n  cout << ans << \"\\n\";\n  fill(head + 1, head + tt + 1, 0), tt = ct = 0;\n  fro(i, 1, n) cl(a[i]), cl(d1[i]), cl(d2[i]);\n}\n\nsigned main() {\n  JYFILE19();\n  int t; cin >> t;\n  while(t--) {\n    solve();\n  }\n  return 0;\n}\nbool ED;\ninline void JYFILE19() {\n  // freopen(\"\", \"r\", stdin);\n  // freopen(\"\", \"w\", stdout);\n  ios::sync_with_stdio(0), cin.tie(0);\n  double MIB = fabs((&ED-&ST)/1048576.), LIM = 512;\n  cerr << \"MEMORY: \" << MIB << endl, assert(MIB<=LIM);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "graphs",
        "shortest paths",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Pok\u00e9mon Arena.json",
    "editorial_link": "https://codeforces.com//blog/entry/126513",
    "editorial": "Let's consider n\n Pok\u00e9mon as nodes, and defeating Pok\u00e9mon u\n by Pok\u00e9mon v\n as the edge u?v\n. Then the problem is essentially finding the shortest path from n\n to 1\n.\n\nIf we brute force to construct the graph, the time complexity will be O(n2m)\n, which is unacceptable. How can we find a better way to build the graph?\n\nRecalling, we need to represent all processes like \"Pok\u00e9mon u\n increased attribute x\n by some value and defeated Pok\u00e9mon v\n\" using paths in the graph.\n\nWe will use the following graph building to achieve this. Overall, we consider each attribute separately. For the x\n-th attribute, we construct 2n\n virtual nodes X1,...,Xn\n and Y1,...,Yn\n, and connect each Pok\u00e9mon based on the x\n-th attribute.\n\nFor example, n=3\n and a1,1=9,a2,1=6,a3,1=1\n, we have the following graph building for attribute 1\n:\n\n aaa\n\nIn this graph,for example,\"Pok\u00e9mon 3\n increased attribute 1\n by 8\n and defeated Pok\u00e9mon 1\n\" can be represented as path 3?X1?X2?X3?Y3?1\n.\n\nMore generally, our graph building method is :\n\nConsider each attribute separately. Assuming we are processing the i\n-th attribute, insert all a1,i,\u0085,an,i\n into val\n and sort it (for convenience, we assume that they are pairwise different).\n\nConstruct 2n\n virtual nodes X1,...,Xn\n and Y1,...,Yn\n;\n\nAdd edge Xi?Xi+1\n with a value of (vali+1?vali)\n for 1?i<n\n;\n\nAdd edge Yi+1?Yi\n with a value of 0\n for 1?i<n\n;\n\nAdd edge Xi?Yi\n with a value of 0\n for 1?i?n\n;\n\nAdd edge i?Xranki\n with a value of ci\n for 1?i?n\n;\n\nAdd edge Yranki?i\n with a value of 0\n for 1?i?n\n.\n\nThen we just run Dijkstra algorithm in this graph. The time complexity is O(nmlog(nm))\n."
}