{
    "link": "https://codeforces.com//contest/577/problem/B",
    "problemId": "34889",
    "problem_idx": "B",
    "shortId": "577B",
    "contest_number": "577",
    "problem_submissions": {
        "E": [
            12934021,
            12937802,
            12946890,
            12941991,
            12957515,
            12944448,
            13175505,
            12944648,
            12944393,
            12937611,
            12947231,
            12946467,
            12943052,
            12942794
        ],
        "D": [
            12944318,
            12940763,
            12944692,
            12944241,
            12944185,
            12943472
        ],
        "C": [
            12939458,
            12935330,
            12931965,
            12930011,
            12933070,
            12931435,
            12931425,
            12936025,
            12933543,
            12937247,
            12928317,
            12934645,
            12932764,
            12930639,
            12932440,
            12935065,
            12934571
        ],
        "B": [
            12935134,
            12931058,
            12929931,
            12931038,
            12930166,
            12928876,
            12933443,
            12931395,
            12932755,
            12937356,
            12947929,
            13099221,
            12935418,
            12931420
        ],
        "A": [
            12926434,
            12926190,
            12926725,
            12926012,
            12926179,
            12925982,
            12927025,
            12927554,
            12927030,
            12926024,
            12926655,
            12926029,
            12927638,
            12927453,
            12926982,
            12926032
        ]
    },
    "name": "B. Modulo Sum",
    "statement": "You are given a sequence of numbers , and a number .Check if it is\r\npossible to choose a non-empty subsequence such that the sum of numbers\r\nin this subsequence is divisible by .\r\n",
    "solutions": [
        "#include<cstdio>\n\nint S[10000];\nint F[10000];\nint P[10000];\n\nint main()\n{\n    int n1, n2, i, j, l, x, y, z;\n    scanf(\"%d%d\", &n1, &n2);\n    for (i = 1 ; i <= n1 ; ++i)\n    {\n        scanf(\"%d\", &j);\n        j %= n2;\n        F[j]++;\n    }\n    for (i = 0 ; i < n2 ; ++i)\n    {\n        x = 1;\n        while (F[i] > 0)\n        {\n            y = x < F[i] ? x : F[i];\n            F[i]-=y; x*=2;\n            z = (i*y) % n2;\n            for (l = 0 ; l < n2 ; ++l)\n                if (S[l]) P[(l+z)%n2]=1;\n            for (l = 0 ; l < n2 ; ++l)\n                S[l] += P[l], P[l] = 0;\n            S[z] = 1;\n        }\n        if (S[0]) break;\n    }\n    if (S[0]) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Modulo Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/20226",
    "editorial": "Let's consider two cases: n?>?m and n???m.\n\nIf n?>?m, let's look at prefix sums. By pigeonhole principle, there are two equals sums modulo m. Assume Slmodm?=?Srmodm. Then the sum on segment [l?+?1,?r] equals zero modulo m, that means the answer is definitely \"YES\".\n\nIf n???m, we'll solve this task using dynamic programming in O(m2) time. Assume can[i][r] means if we can achieve the sum equal to r modulo m using only first i?-?1 items. The updates in this dynamic programming are obvious: we either take number ai and go to the state can[i?+?1][(r?+?ai) mod m] or not, then we'll get to the state can[i?+?1][r]."
}