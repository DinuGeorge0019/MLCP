{
    "link": "https://codeforces.com//contest/1983/problem/F",
    "problemId": "2739881",
    "problem_idx": "F",
    "shortId": "1983F",
    "contest_number": "1983",
    "problem_submissions": {
        "A": [
            269278635,
            269224195,
            269223849,
            269226514,
            269225288,
            269224120,
            269223887,
            269227486,
            269224712,
            269226231,
            269238169,
            269260779,
            269225102,
            269240926,
            269224023,
            269229049,
            269229008,
            269229437,
            269227958,
            269225179
        ],
        "B": [
            269278056,
            269230788,
            269229550,
            269238075,
            269239775,
            269233840,
            269232426,
            269237259,
            269236179,
            269236169,
            269241163,
            269259016,
            269240024,
            269241196,
            269235107,
            269248703,
            269237529,
            269237369,
            269239496,
            269241230
        ],
        "C": [
            269275559,
            269239407,
            269240124,
            269245784,
            269247404,
            269241159,
            269249194,
            269246484,
            269242664,
            269245963,
            269247870,
            269238276,
            269244413,
            269249774,
            269246281,
            269260121,
            269247344,
            269247358,
            269248698,
            269249698
        ],
        "D": [
            269272884,
            269243672,
            269246000,
            269251406,
            269251795,
            269246010,
            269251878,
            269256401,
            269252027,
            269252217,
            269233789,
            269246546,
            269246776,
            269243749,
            269249916,
            269266016,
            269254304,
            269252415,
            269266726,
            269258898
        ],
        "E": [
            269270622,
            269249510,
            269250892,
            269257523,
            269260300,
            269262071,
            269262617,
            269264482,
            269265164,
            269262684,
            269292411,
            269254378,
            269261706,
            269275920,
            269289749,
            269263092,
            269288046,
            269277163,
            269273777,
            269273251
        ],
        "F": [
            269262701,
            269255388,
            269260448,
            269269019,
            269272052,
            269277444,
            269269564,
            269275950,
            269279316,
            269281347,
            269264892,
            269293501,
            269287451,
            269340337,
            269340202,
            269285676,
            269275010,
            269281603,
            269272906,
            269290579,
            269289233,
            269284840
        ],
        "G": [
            269252950,
            269304269,
            269304164,
            269349906
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131268",
    "editorial": "We can binary search on the the value of the th-smallest and maintain\r\nthe number of subarrays with xor-pair less than the value. This way, we\r\ncan find the th-smallest value easily.In order to maintain the number of\r\nsubarrays, we can use our popular xor data structure called trie. For a\r\ngiven binary searched value, we will traverse from left to right,\r\nputting in the values of the array in our trie with their highest\r\ncorresponding indices.For a fixed index , we would like to find the\r\nhighest index such that the subarray from contains xor-pair less than\r\nthe fixed upper bound. Then all subarrays with their left end between\r\nand right end fixed at will have xor-pair less than the value.Therefore,\r\nthis becomes a sliding window where we want to maximize the value of the\r\nleft end so that the number of subarrays for a fixed right end becomes\r\nas large as possible.To achieve this, we would maintain in our trie the\r\nfollowing two things: - the current bit (on/off) - the maximum index\r\nwhich reached this bit in our trieNow when querying: - if both searched\r\nbit and current array index bit is : take the max for left index from\r\nchild \"on\" bit and go to child \"off\" bit - if both searched bit and\r\ncurrent array index bit is : just go to child \"off\" bit - if searched\r\nbit is and current array index bit is : take the max for left index from\r\nchild \"off\" bit and go to child \"on\" bit - if searched bit is and\r\ncurrent array index bit is : just go to child \"on\" bitThis is done so\r\nthat we can find the maximum left index for the given fixed right index\r\nat . We follow binary searched value as closely as possible while\r\ntraversing the trie to stay under the upper bound as well as maximize\r\nthe left index.Finally, putting the values and corresponding index in\r\nthe trie is trivial. Simply follow the trie and put in the corresponding\r\nbits the maximum index which can reach that bit.This way we can solve\r\nthis problem in\r\n",
    "name": "F. array-value",
    "statement": "You have an array of non-negative integers a_1, a_2,\r\nldots, a_n.The value of a sub-array of length\r\nge 2, a[l, r] = [a_l, a_{l+1},\r\nldots, a_r] is the minimum value of a_i\r\noplus a_j such that l\r\nle i < j\r\nle r, where\r\noplus is the xor (exclusive-or) operator.You have to find the k-th\r\nsmallest value over all sub-arrays of length\r\nge 2.\r\n",
    "solutions": [
        "// Problem: F. array-value// Contest: Codeforces - Codeforces Round #956 (Div. 2) and ByteRace 2024// URL: https://mirror.codeforces.com/contest/1983/problem/F// Memory Limit: 256 MB// Time Limit: 4000 ms// // Powered by CP Editor (https://cpeditor.org)\u00a0// Author: EnucAI#include <bits/stdc++.h>\u00a0#ifdef LOCAL#include \"debug.h\"#else#define D(...) ((void)0)#endif\u00a0using ll = long long;using ull = unsigned long long;using ld = long double;using vi = std::vector<int>;using pii = std::pair<int, int>;\u00a0constexpr int inf = std::numeric_limits<int>::max() / 2;constexpr ll infll = std::numeric_limits<ll>::max() / 2;constexpr ld eps = 1e-8l;\u00a0#define all(x) (x).begin(), (x).end()#define sz(x) ((int)((x).size()))#define rep(i, j, k) for (int i = (j); i <= (k); i++)#define per(i, j, k) for (int i = (j); i >= (k); i--)#define fi first#define se second#define mp std::make_pair#define pb push_back#define ppb pop_back#define eb emplace_back\u00a0template <class X, class Y> void chkmax(X &x, const Y &y) { if (x < y) x = y; }template <class X, class Y> void chkmin(X &x, const Y &y) { if (x > y) x = y; }\u00a0constexpr int maxn = 1e5 + 5, lg = 29;\u00a0int n, a[maxn];ll k;\u00a0struct trie {  int ch[2], mx;} tr[maxn * (lg + 1)];int tot;void clr() {  rep(i, 1, tot) tr[i].ch[0] = tr[i].ch[1] = tr[i].mx = 0;  tot = 1;}void ins(int x, int val) {  int u = 1;  per(i, lg, 0) {    int v = (x >> i) & 1;    if (!tr[u].ch[v]) tr[u].ch[v] = ++tot;    u = tr[u].ch[v];    chkmax(tr[u].mx, val);  }}int que(int u, int d, int x, int y) {  // ? xor x < y  if (d == -1) return 0;  int vx = (x >> d) & 1, vy = (y >> d) & 1;  int res = que(tr[u].ch[vx ^ vy], d - 1, x, y);  if (vy) chkmax(res, tr[tr[u].ch[vx ^ vy ^ 1]].mx);  return res;}\u00a0ll calc(int x) {  int p = 0;  ll res = 0;  clr();  rep(i, 1, n) {    chkmax(p, que(1, lg, a[i], x));    res += p;    ins(a[i], i);  }  return res;}\u00a0void work() {  std::cin >> n >> k;  rep(i, 1, n) std::cin >> a[i];  int l = 0, r = (2 << lg) - 1;  while (l < r) {    int mid = (l + r) >> 1;    if (calc(mid + 1) < k) l = mid + 1;    else r = mid;  }  std::cout << l << '\\n';}\u00a0int main() {  std::cin.tie(nullptr)->sync_with_stdio(false);  int t;  std::cin >> t;  while (t--) work();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. array-value.json"
}