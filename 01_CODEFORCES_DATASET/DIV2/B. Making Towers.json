{
    "link": "https://codeforces.com//contest/1706/problem/B",
    "problemId": "1466352",
    "problem_idx": "B",
    "shortId": "1706B",
    "contest_number": "1706",
    "problem_submissions": {
        "D2": [
            164755947,
            164771403,
            164762268,
            164830322,
            164783821,
            164762155,
            164763660,
            167727726,
            164763512,
            164771385,
            164768987,
            164786591,
            165109549,
            164774482,
            164772244,
            164787948,
            164789501,
            164767866,
            164774049,
            164768972,
            164786019,
            164781366
        ],
        "D1": [
            164755812,
            164767814,
            164760721,
            164830311,
            164764715,
            164761873,
            164763978,
            167106725,
            164760911,
            164771592,
            164764309,
            164755426,
            164758751,
            164758461,
            164759026,
            164768432,
            164762506,
            164771653,
            164768895,
            164754659,
            164780135
        ],
        "E": [
            164750123,
            164754977,
            164771776,
            164830331,
            164760396,
            164775552,
            164750599,
            167106869,
            164780737,
            164776992,
            164776365,
            164769697,
            165109519,
            164782832,
            164784446,
            164777832,
            164745185,
            164783769,
            164782907,
            164785318,
            164774423,
            164765688
        ],
        "C": [
            164743602,
            164744687,
            164740571,
            164830300,
            164745917,
            164752415,
            164768743,
            167106646,
            167106607,
            164749531,
            164746963,
            164750898,
            164748957,
            164751304,
            164751822,
            164752230,
            164762906,
            164749665,
            164747043,
            164749516,
            164747945,
            164752780
        ],
        "B": [
            164740418,
            164739248,
            164748883,
            164830286,
            164740306,
            164748574,
            164773017,
            167106480,
            164740862,
            164740238,
            164743331,
            164741485,
            164741615,
            164739143,
            164740378,
            164753096,
            164741049,
            164740372,
            164742312,
            164741022,
            164745456
        ],
        "A": [
            164734517,
            164734482,
            164750605,
            164830274,
            164734645,
            164734321,
            164774887,
            167106382,
            164735301,
            164734871,
            164734669,
            164735191,
            164734536,
            164734449,
            164734493,
            164748128,
            164735346,
            164734733,
            164735598,
            164734982,
            164735759
        ]
    },
    "name": "B. Making Towers",
    "statement": "You have a sequence of n colored blocks. The color of the i-th block is\r\nc_i, an integer between 1 and n.You will place the blocks down in\r\nsequence on an infinite coordinate grid in the following way. Initially,\r\nyou place block 1 at (0, 0). For 2\r\nle i\r\nle n, if the (i - 1)-th block is placed at position (x, y), then the\r\ni-th block can be placed at one of positions (x + 1, y), (x - 1, y), (x,\r\ny + 1) (), as long no previous block was placed at that position. A is\r\nformed by s blocks such that they are placed at positions (x, y), (x,\r\ny + 1),\r\nldots, (x, y + s - 1) for some position (x, y) and integer s. The of the\r\ntower is s, the number of blocks in it. A is a tower such that all\r\nblocks in it have the color r.For each color r from 1 to n, solve the\r\nfollowing problem : Find the maximum size of a tower of color r that you\r\ncan form by placing down the blocks according to the rules.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1e5 + 5;\n\nint a[N], ans[N], las[N];\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\trep(i, 1, n) ans[i] = las[i] = 0;\n\t\trep(i, 1, n) {\n\t\t\ta[i] = read();\n\t\t\tif (!las[a[i]])\n\t\t\t\tlas[a[i]] = i, ans[a[i]] = 1;\n\t\t\telse {\n\t\t\t\tif (i % 2 != las[a[i]] % 2) {\n\t\t\t\t\tlas[a[i]] = i;\n\t\t\t\t\t++ans[a[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 1, n) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Making Towers.json",
    "editorial_link": "https://codeforces.com//blog/entry/105008",
    "editorial": "When can two blocks of the same color form two consecutive elements of a\r\ntower? Formally, if we have two blocks of the same color at indices and\r\nsuch that , how can we tell if it is possible to place them at and\r\nrespectively?As it turns out, they can be placed like this . First, if\r\nthey have the same parity, it is impossible to place them this way. Note\r\nthat must have a different parity from , since these sums must differ by\r\nexactly . So, if and have the same parity, then must also have the same\r\nparity as . But we want them to be vertically adjacent, which is not\r\npossible if their parities must be the same. So, it is impossible to\r\nmake two blocks with indices of the same parity adjacent to each\r\nother.Next, there is a valid construction if you want to put blocks and\r\ntogether when they have different parities. Say that block will go at\r\nposition and block goes at position . If , then we are done. Now, let\u00e2\u0080\u0099s\r\nsay that . Then, we can place block at and block at position . What if ?\r\nThen we can do the same as the previous case, and then put block at and\r\nblock at . Essentially, we are making the blocks between and into a\r\nhorizontal line extending out for blocks then coming back in.If there\r\nare already blocks to the right of , then we can do the same\r\nconstruction but extending out to the left. Note that since we cannot\r\nmove down, at least one of the right and left side must be open.There\r\nare two ways we can go from here:First, there is a DP solution. Let\u00e2\u0080\u0099s\r\nimagine the naive dp: We say that is the maximum size of a tower with\r\ncolor , such that the last block placed was at index . The transitions\r\nlook like this: . We check all such that and have different parities,\r\nthen see if adding a block to this tower makes a better solution. To\r\noptimize it, we can notice that for the first DP dimension (index), only\r\nthe parity of the index matters for each color, we just need to keep\r\ntrack of the maximum for even and odd .We will iterate through all\r\nblocks , maintaining , which contains the maximum size of a tower with\r\ncolor , where the last block included in the tower had an index with\r\nparity ( indicates an even index, indicates an odd index). If the\r\ncurrent index is even, we set . If it is odd, we set . The solution runs\r\nin linear time.Alternatively, there\u00e2\u0080\u0099s a greedy solution. After selecting\r\na block, the next block selected must always have the opposite parity.\r\nTherefore, it makes sense to greedily select the first block of the same\r\ncolor with opposite parity, since it will never improve the answer if we\r\nselect a later block. For each color, we start from the first block and\r\niterate through, adding each block to the sequence if and only if it has\r\na different parity from the last one.\r\n"
}