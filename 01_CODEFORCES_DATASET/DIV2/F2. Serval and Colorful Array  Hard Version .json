{
    "link": "https://codeforces.com//contest/2085/problem/F2",
    "problemId": "3284102",
    "problem_idx": "F2",
    "shortId": "2085F2",
    "contest_number": "2085",
    "problem_submissions": {
        "F2": [
            311878898,
            311854121,
            312547828,
            313180465,
            312715525
        ],
        "F1": [
            311866129,
            311884163,
            311888744,
            311865797,
            311890721,
            311853454,
            311870055,
            311856458,
            311889685,
            312547788,
            312535060,
            311920736,
            311883283
        ],
        "D": [
            311854269,
            311840149,
            311846898,
            311849836,
            311841369,
            311813594,
            311831715,
            311864844,
            311834411,
            311845527,
            311845487,
            311842115,
            311851940
        ],
        "E": [
            311849828,
            311869915,
            311859328,
            311874708,
            311857458,
            311844963,
            311880401,
            311844941,
            311849085,
            311875928,
            311862172,
            311856416,
            311861319,
            311872692,
            311863088,
            311848201
        ],
        "B": [
            311824052,
            311815589,
            311817146,
            311836083,
            311819326,
            311808366,
            311842734,
            311823405,
            311881846,
            311854059,
            311819894,
            311821673,
            311824308,
            311814219,
            311816794,
            311819160
        ],
        "A": [
            311810733,
            311807971,
            311807466,
            311816690,
            311808218,
            311807487,
            311888447,
            311833731,
            311808956,
            311822473,
            311811561,
            311808040,
            311808284,
            311807791,
            311816294
        ],
        "C": [
            311807884,
            311821315,
            311839190,
            311828017,
            311827320,
            311810326,
            311887204,
            311816120,
            311830323,
            311880309,
            311851607,
            311814111,
            311825484,
            311838153,
            311826627,
            311836598,
            311830943
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140933",
    "editorial": "SolutionOptimizing the solution of F1 using (possibly, heavy) data\r\nstructures results in a solution.Here we introduce a linear approach for\r\nF2 came up by Error_Yuan. In fact, the following proposition\r\nholds.Proposition. The answer obtained is still correct without the\r\nconstraint that exactly elements should be chosen from both sides of the\r\nenumerated position.Without the constraint, when enumerating the\r\nposition , we can directly choose the smaller one between and for each\r\n.Proof. On the one hand, notice that the distance sum will not be\r\nsmaller when is not the middle position among the chosen elements. On\r\nthe other hand, consider the colorful subarray that produces the optimal\r\nanswer, and mark the elements in it first. When enumerates to the middle\r\nposition of the marked elements before swapping, the minimal distance\r\nsum without the constraint is no greater than that under the constraint.\r\nTherefore, all the considered candidates are no less than the real\r\nanswer, and the real answer can be reached, completing the proof. In\r\nimplementation, we consider the contribution to each position for each\r\ninteger . For a certain , it can be shown that the delta of the\r\ncontribution will be one of , , or when moves to an adjacent position.\r\nThe delta of the contribution remains unchanged for most positions, and\r\nonly changes either at the position where placed, or at the midpoint\r\nbetween two adjacent . By pre-calculating the changes of contribution\r\ndeltas over all the and performing the prefix sum on the array twice, we\r\ncan obtain the distance sums, resulting in an solution.\r\n",
    "name": "F2. Serval and Colorful Array  Hard Version ",
    "statement": "Serval has a magic number k (k\r\nge 2). We call an array r if and only if: The length of r is k, and Each\r\ninteger between 1 and k appears in r. You are given an array a\r\nconsisting of n integers between 1 and k. It is guaranteed that each\r\ninteger between 1 and k appears in a at least once. You can perform the\r\nfollowing operation on a: Choose an index i (1\r\nle i < n), then swap a_i and a_{i+1}.Find the minimum number of\r\noperations needed to make at least one subarray^{\r\ntext{ }} of a . It can be shown that this is always possible under the\r\nconstraints of the problem.^{\r\ntext{ }}An array b is a subarray of an array a if b can be obtained from\r\na by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Serval and Colorful Array  Hard Version .json",
    "hint": [
        "Hint 1 Is it possible to simplify the constraints?",
        "Hint 2 Is it possible to remove the constraint that exactly elements should be chosen from both sides of the enumerated position?"
    ]
}