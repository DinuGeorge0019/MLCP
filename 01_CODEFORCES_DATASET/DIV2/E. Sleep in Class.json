{
    "link": "https://codeforces.com//contest/733/problem/E",
    "problemId": "78301",
    "problem_idx": "E",
    "shortId": "733E",
    "contest_number": "733",
    "problem_submissions": {
        "F": [
            21944181,
            21943396,
            21967823,
            21944382,
            21944760,
            21938912,
            21991227,
            22059840,
            21937562,
            21938035,
            21985645,
            21991821,
            21953425,
            22015051,
            21990688
        ],
        "E": [
            21937191,
            21938008,
            21943531,
            21943185,
            21953321,
            21943118,
            21945071,
            21961545
        ],
        "D": [
            21929126,
            21923181,
            21934246,
            21934699,
            21930359,
            21930083,
            21921931,
            21937281,
            21933013,
            21933051,
            21930915,
            21933717,
            21930137,
            21931610,
            21929842,
            21935332,
            21929335,
            21936423,
            21930780,
            21933993
        ],
        "C": [
            21927957,
            21950571,
            21931020,
            21929401,
            21936037,
            21935885,
            21953665,
            21934528,
            21938848,
            21929683,
            21937215,
            21940711,
            21934393,
            21928582,
            21934351,
            21931346,
            21936860,
            21931930
        ],
        "B": [
            21922288,
            21927937,
            21923164,
            21922462,
            21923910,
            21924025,
            21925504,
            21933294,
            21928279,
            21922570,
            21924161,
            21922272,
            21921961,
            21923577,
            21924912,
            21921350,
            21922700,
            21923311,
            21923198,
            21925029
        ],
        "A": [
            21919764,
            21920167,
            21920208,
            21919696,
            21920676,
            21920418,
            21919388,
            21932202,
            21929074,
            21920399,
            21925006,
            21920161,
            21919497,
            21919471,
            21922256,
            21919494,
            21926774,
            21920063,
            21919707,
            21927283
        ]
    },
    "name": "E. Sleep in Class",
    "statement": "The academic year has just begun, but lessons and olympiads have already\r\noccupied all the free time. It is not a surprise that today Olga fell\r\nasleep on the Literature. She had a dream in which she was on a stairs.\r\nThe stairs consists of steps. The steps are numbered from bottom to top,\r\nit means that the lowest step has number , and the highest step has\r\nnumber . Above each of them there is a pointer with the direction (up or\r\ndown) Olga should move from this step. As soon as Olga goes to the next\r\nstep, the direction of the pointer (above the step she leaves) changes.\r\nIt means that the direction \"up\" changes to \"down\", the direction \"down\"\r\nto the direction \"up\".Olga always moves to the next step in the\r\ndirection which is shown on the pointer above the step. If Olga moves\r\nbeyond the stairs, she will fall and wake up. Moving beyond the stairs\r\nis a moving down from the first step or moving up from the last one (it\r\nmeans the -th) step. In one second Olga moves one step up or down\r\naccording to the direction of the pointer which is located above the\r\nstep on which Olga had been at the beginning of the second. For each\r\nstep find the duration of the dream if Olga was at this step at the\r\nbeginning of the dream.Olga\u2019s fall also takes one second, so if she was\r\non the first step and went down, she would wake up in the next second.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define LL long long\nusing namespace std;\n\nchar tmp[1000005];\nLL t1[6000005], t2[6000005];\nLL l1[6000005], l2[6000005];\n\nvoid update1(int i,int L,int R,int x,int y,int val)\n{\n  if(l1[i] != 0)\n  {\n    t1[i]+=l1[i] * 1LL * (R - L + 1);\n    if(L != R)\n    {\n      l1[i*2+1]+=l1[i];\n      l1[i*2+2]+=l1[i];\n    }\n    l1[i] = 0;\n  }\n  if(L >= x && R <= y)\n  {\n    l1[i]+=val;\n    t1[i]+=l1[i] * 1LL * (R - L + 1);\n    if(L != R)\n    {\n      l1[i*2+1]+=l1[i];\n      l1[i*2+2]+=l1[i];\n    }\n    l1[i] = 0;\n    return;\n  }\n  if(L > y || R < x)\n    return;\n  update1(i*2 + 1, L, (L + R) / 2, x, y, val);\n  update1(i*2 + 2, (L + R) / 2 + 1, R, x, y, val);\n  t1[i] = t1[i*2 + 1] + t1[i*2 + 2];\n}\n\nLL query1(int i,int L,int R,int x,int y)\n{\n  if(l1[i] != 0)\n  {\n    t1[i]+=l1[i] * 1LL * (R - L + 1);\n    if(L != R)\n    {\n      l1[i*2+1]+=l1[i];\n      l1[i*2+2]+=l1[i];\n    }\n    l1[i] = 0;\n  }\n  if(L >= x && R <= y)\n    return t1[i];\n  if(L > y || R < x)\n    return 0;\n  return query1(i*2 + 1, L, (L + R) / 2, x, y) + query1(i*2 + 2, (L + R) / 2 + 1, R, x, y);\n}\n\nvoid update2(int i,int L,int R,int x,int y,int val)\n{\n  if(l2[i] != 0)\n  {\n    t2[i]+=l2[i] * 1LL * (R - L + 1);\n    if(L != R)\n    {\n      l2[i*2+1]+=l2[i];\n      l2[i*2+2]+=l2[i];\n    }\n    l2[i] = 0;\n  }\n  if(L >= x && R <= y)\n  {\n    l2[i]+=val;\n    t2[i]+=l2[i] * 1LL * (R - L + 1);\n    if(L != R)\n    {\n      l2[i*2+1]+=l2[i];\n      l2[i*2+2]+=l2[i];\n    }\n    l2[i] = 0;\n    return;\n  }\n  if(L > y || R < x)\n    return;\n  update2(i*2 + 1, L, (L + R) / 2, x, y, val);\n  update2(i*2 + 2, (L + R) / 2 + 1, R, x, y, val);\n  t2[i] = t2[i*2 + 1] + t2[i*2 + 2];\n}\n\nLL query2(int i,int L,int R,int x,int y)\n{\n  if(l2[i] != 0)\n  {\n    t2[i]+=l2[i] * 1LL * (R - L + 1);\n    if(L != R)\n    {\n      l2[i*2+1]+=l2[i];\n      l2[i*2+2]+=l2[i];\n    }\n    l2[i] = 0;\n  }\n  if(L >= x && R <= y)\n    return t2[i];\n  if(L > y || R < x)\n    return 0;\n  return query2(i*2 + 1, L, (L + R) / 2, x, y) + query2(i*2 + 2, (L + R) / 2 + 1, R, x, y);\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  scanf(\"%s\", tmp);\n  string s = tmp;\n  int c1 = 0, c2 = 0;\n  for(int i=n-1;i>=0;i--)\n  {\n    if(s[i] == 'D')\n    {\n      update2(0, 0, n - 1, c2, c2, i);\n      c2++;\n    }\n  }\n  for(int i=0;i<n;i++)\n  {\n    if(i) printf(\" \");\n    LL ans = 0;\n    if(s[i] == 'U')\n    {\n      if(c1 < c2)\n      {\n        if(c2) ans += query2(0, 0, n - 1, c2 - (c1 + 1), c2 - 1) * 2;\n        if(c1) ans += query1(0, 0, n - 1, 0, c1 - 1) * 2;\n        ans += i + 1;\n      }\n      else\n      {\n        if(c2) ans += (query2(0, 0, n - 1, 0, c2 - 1) + query1(0, 0, n - 1, c1 - c2, c1 - 1)) * 2;\n        ans += n - i;\n      }\n      c1++;\n    }\n    else\n    {\n      c2--;\n      if(c2 < c1)\n      {\n        if(c1) ans += query1(0, 0, n - 1, c1 - (c2 + 1), c1 - 1) * 2;\n        if(c2) ans += query2(0, 0, n - 1, 0, c2 - 1) * 2;\n        ans += n - i;\n      }\n      else\n      {\n        if(c1) ans += (query1(0, 0, n - 1, 0, c1 - 1) + query2(0, 0, n - 1, c2 - c1, c2 - 1)) * 2;\n        ans += i + 1;\n      }\n    }\n    if(c1) update1(0, 0, n - 1, 0, c1 - 1, 1);\n    if(c2) update2(0, 0, n - 1, 0, c2 - 1, -1);\n    printf(\"%I64d\", ans);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "math",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sleep in Class.json",
    "editorial_link": "https://codeforces.com//blog/entry/48133",
    "editorial": "Olga is always able to go beyond stairs. To prove that let\u00e2\u0080\u0099s consider\r\nsome segment of stairs. If we enter it from upper step then we move down\r\nuntil reaching \u00e2\u0080\u009d which reverses our moving direction. After that we\r\nleave segment from above. Now this \u00e2\u0080\u009d became \u00e2\u0080\u009d and other symbols remained\r\nthe same as they were either visited twice or not visited at all. So we\r\nenter segment once again from upper step, this time we proceed to next\r\n\u00e2\u0080\u009d. And at the some point we leave segment from below. It will happen in\r\nturn where number of \u00e2\u0080\u009d symbols in segment. Leaving segment from above\r\nwhen it\u00e2\u0080\u0099s entered from below is done in turns, - number of \u00e2\u0080\u009d symbols in\r\nsegment. It can be proven the same way.Then we can divide stairs into\r\nthree parts: Segment below current step Current step Segment above\r\ncurrent step It can be easily seen that we will go beyond stairs either\r\nfrom or from segment. Now let\u00e2\u0080\u0099s calculate values of and for every step.\r\nnumber of \u00e2\u0080\u009d symbols in prefix of stairs (exluding ), number of \u00e2\u0080\u009d symbols\r\nin suffix (exluding ).We will also need values of and , - time in\r\nseconds to leave stairs from below as if is always equal to \u00e2\u0080\u009d and - time\r\nin seconds to leave stairs from above as if is always equal to \u00e2\u0080\u009d.It\u00e2\u0080\u0099s\r\nobvious that by moving iterator by one position to the right we increase\r\ndistance to every calculated symbol \u00e2\u0080\u009d by , so it\u00e2\u0080\u0099s for each symbol to\r\noverall time (we go to this symbol and back to ). If previous symbol was\r\n\u00e2\u0080\u009d then we should add more to overall time. In total this will be equal\r\nto . And as we moved one step away from exit we should increase time by\r\n.And it\u00e2\u0080\u0099s the same for .And finally let\u00e2\u0080\u0099s derive formula to get answer\r\nin for each step.Olga will go beyond stairs from the side which has\r\nleast amount of obstacles. If amounts are equal then it\u00e2\u0080\u0099s the matter of\r\ncurrent letter. Let\u00e2\u0080\u0099s imply that we are exiting from both sides at the\r\nsame time and just subtract from time the part from the side opposite to\r\nexiting one. So we should subtract or (it depends on exiting side),\r\nwhere is position in string of last visited element of side opposite to\r\nexiting one. And also subtract doubled distance between current step and\r\nlast visited obstacle multiplied by number of unvisited onstacles.So if\r\nwe go beyond stairs from below then this is the derived formula:\r\nreversed array of indices (positions in string) of \u00e2\u0080\u009d symbol. number (not\r\nposition) of last visited element from above. is if \u00e2\u0080\u009d, if \u00e2\u0080\u009d. (This will\r\nbe reversed on exiting from above)Answer for last step is calculated the\r\nsame way.For deriving formula for exiting from above you will also need\r\narray of indices (positions in string) of \u00e2\u0080\u009d symbol (not reversed this\r\ntime).\r\n"
}