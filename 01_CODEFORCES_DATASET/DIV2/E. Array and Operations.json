{
    "link": "https://codeforces.com//contest/499/problem/E",
    "problemId": "19908",
    "problem_idx": "E",
    "shortId": "499E",
    "contest_number": "499",
    "problem_submissions": {
        "E": [
            9253382,
            9249937,
            9254400,
            9253914,
            9258427,
            9257640,
            9257147,
            9258089,
            9261739,
            9261692
        ],
        "D": [
            9251144,
            9251936,
            15380925,
            15380903,
            9347944
        ],
        "C": [
            9247911,
            9250694,
            9253182,
            9259776,
            9246632,
            9250112,
            9251006,
            9250760,
            9255795,
            9252835,
            9246700,
            9246228,
            9248570,
            9248780,
            9246821,
            9248766,
            9247714,
            9250833
        ],
        "B": [
            9246389,
            9245483,
            9248025,
            9248145,
            9248497,
            9246640,
            9249042,
            9254662,
            9256938,
            9245721,
            9246128,
            9245971,
            9248045,
            9246498,
            9248899,
            9248096
        ],
        "A": [
            9245543,
            9245348,
            9246338,
            9245638,
            9246309,
            9245625,
            9247454,
            9253414,
            9305487,
            9252605,
            9245370,
            9245544,
            9245374,
            9249324,
            9247099,
            9246649
        ]
    },
    "name": "E. Array and Operations",
    "statement": "You have written on a piece of paper an array of positive integers and\r\npairs of integers . Each pair meets the following conditions: is an odd\r\nnumber and .In one operation you can perform a sequence of actions: take\r\none of the pairs and some integer (), which divides both numbers and ;\r\ndivide both numbers by , i. e. perform the assignments: and . Determine\r\nthe maximum number of operations you can sequentially perform on the\r\ngiven array. Note that one pair may be used several times in the\r\ndescribed operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n#define FN 500010\n#define FM 4200010\n#define INF 1034567890\n#define FOR(it,c) for ( __typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++ )\nusing namespace std;\ntypedef long long LL;\nstruct E {\n    int k,c;\n    E(){}\n    E( int _k, int _c ):k(_k),c(_c){}\n} es[FM];\n\nstruct Flow {\n    int n,m,dis[FN];\n    int qq[FN],qr,ql;\n    vector<int> e[FN];\n    void init( int _n ) {\n        n=_n; m=0;\n        for ( int i=0; i<n; i++ ) e[i]=vector<int>();\n    }\n    void add( int a, int b, int c ) {\n        e[a].push_back(m); es[m]=E(b,c); m++;\n        e[b].push_back(m); es[m]=E(a,0); m++;\n    }\n    bool BFS() {\n        memset(dis,-1,n*sizeof(int));\n        ql=qr=0;\n        qq[qr++]=0;\n        dis[0]=0;\n        while ( ql!=qr && dis[n-1]==-1 ) {\n            int p=qq[ql++];\n            FOR(it,e[p]) {\n                E ee=es[*it];\n                if ( ee.c==0 || dis[ee.k]!=-1 ) continue;\n                dis[ee.k]=dis[p]+1;\n                qq[qr++]=ee.k;\n            }\n        }\n        return dis[n-1]!=-1;\n    }\n    LL go( int p, LL c ) {\n        if ( p==n-1 ) return c;\n        LL ret=0,tmp;\n        FOR(it,e[p]) {\n            E &ee=es[*it];\n            if ( ee.c==0 || dis[p]+1!=dis[ee.k] ) continue;\n            tmp=go(ee.k,min(c-ret,(LL)ee.c));\n            ret+=tmp; ee.c-=tmp; es[(*it)^1].c+=tmp;\n            if ( ret==c ) break;\n        }\n        if ( ret==0 ) dis[p]=-1;\n        return ret;\n    }\n    LL maxflow() {\n        LL ret=0;\n        while ( BFS() ) ret+=go(0,1LL<<60);\n        return ret;\n    }\n} flow;\nint p[SIZE];\nvector<int>pp;\nvoid prime_init(){\n    p[1]=1;\n    for(int i=2;i<SIZE;i++){\n        if(!p[i]){\n            pp.PB(i);\n            for(int j=i;j<SIZE;j+=i){\n                if(!p[j])p[j]=i;\n            }\n        }\n    }\n}\nmap<PII,int>num;\nint No,st[101];\nvector<int>fac[101];\nint main(){\n    prime_init();\n    DRII(n,m);\n    REP(i,n){\n        DRI(x);\n        for(int j=0;pp[j]*pp[j]<=x;j++){\n            if(x%pp[j]==0){\n                fac[i].PB(pp[j]);\n                int cnt=0;\n                while(x%pp[j]==0){\n                    cnt++;\n                    x/=pp[j];\n                }\n                num[MP(i,pp[j])]=cnt;\n            }\n        }\n        if(x!=1){\n            fac[i].PB(x);\n            num[MP(i,x)]=1;\n        }\n        if(i)st[i]=st[i-1]+SZ(fac[i-1]);\n    }\n    flow.init(st[n-1]+SZ(fac[n-1])+2);\n    REP(i,n){\n        if(i&1){\n            REP(j,SZ(fac[i])){\n                flow.add(0,st[i]+j+1,num[MP(i,fac[i][j])]);\n            }\n        }\n        else{\n            REP(j,SZ(fac[i])){\n                flow.add(st[i]+j+1,flow.n-1,num[MP(i,fac[i][j])]);\n            }\n        }\n    }\n    while(m--){\n        DRII(x,y);\n        x--;y--;\n        if(y&1)swap(x,y);\n        int rr=0;\n        REP(i,SZ(fac[x])){\n            while(rr<SZ(fac[y])&&fac[y][rr]<fac[x][i])rr++;\n            if(rr<SZ(fac[y])&&fac[x][i]==fac[y][rr]){\n                flow.add(st[x]+i+1,st[y]+rr+1,INF);\n            }\n        }\n    }\n    printf(\"%d\\n\",flow.maxflow());\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Array and Operations.json",
    "editorial_link": "https://codeforces.com/blog/entry/15353",
    "editorial": "We will divide only by prime numbers. First, let’s build a graph, where\r\neach of numbers have own vertex group: Find all prime factors of current\r\nnumber. Every factor will have its own vertex in a group, furthermore,\r\nif some factor has power of in current number, it will have exactly\r\nvertexes in group. The number of vertexes in such graph is . Now we will\r\nmake edges in our graph: edge between two vertexes exists if and only if\r\nthere is a good pair (given in statement) of vertexes group numbers and\r\nthe prime values of a vertexes are the same. That means that we can\r\ndivide that group numbers by that prime. The number of edges is . Good\r\npairs are given the way that our graph is bipartite. After finding\r\nmaximum matching in this graph we represent the way of doing operations\r\nas described in the statement. As soon as solution is using Kuhn’s\r\nalgorithm, its complexity is . One could notice that some of the edges\r\nare useless and reduce it to .\r\n",
    "hint": []
}