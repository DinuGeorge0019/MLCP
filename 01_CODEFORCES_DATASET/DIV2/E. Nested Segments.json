{
    "link": "https://codeforces.com//contest/2056/problem/E",
    "problemId": "3150796",
    "problem_idx": "E",
    "shortId": "2056E",
    "contest_number": "2056",
    "problem_submissions": {
        "F2": [
            301545587,
            301509040,
            301738450,
            302033567
        ],
        "F1": [
            301461815,
            301455964,
            301458356,
            301426872,
            301434246,
            302031432,
            302030623,
            301580078,
            301600084
        ],
        "E": [
            301439440,
            301447920,
            301443059,
            301433627,
            301428331,
            301444669,
            301439558,
            301439957,
            301443503,
            301447455,
            301451147,
            301446991,
            301456228,
            301452444,
            301427254,
            301456788,
            301448385
        ],
        "D": [
            301411463,
            301430952,
            301426584,
            301413553,
            301414046,
            301415062,
            301415941,
            301414692,
            301446695,
            301418999,
            301418932,
            301422889,
            301412134,
            301417642,
            301411530,
            301417000,
            301444048,
            301424366,
            301426240
        ],
        "C": [
            301399544,
            301411500,
            301416896,
            301418700,
            301401301,
            301404995,
            301400708,
            301399472,
            301417939,
            301403985,
            301402887,
            301398665,
            301399127,
            301403882,
            301404504,
            301408969,
            301407435,
            301401039,
            301402939
        ],
        "B": [
            301393848,
            301392518,
            301400501,
            301395217,
            301391544,
            301398396,
            301394970,
            301396057,
            301401319,
            301397018,
            301398125,
            301391015,
            301394435,
            301395913,
            301394898,
            301392345,
            301400120,
            301395871,
            301401973
        ],
        "A": [
            301388610,
            301388749,
            301390918,
            301392589,
            301387805,
            301391122,
            301388287,
            301390050,
            301390421,
            301388003,
            301389658,
            301387952,
            301388733,
            301389417,
            301387733,
            301388087,
            301390776,
            301389692,
            301388580
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138487",
    "editorial": "SolutionAny good set has a tree-like structure.Specifically, represent\r\nas a forest the following way: segment has a parent iff and is minimized\r\n(its parent is the shortest interval in which it lies). This segment is\r\nunique (or does not exist), because there can’t be two segments with\r\nminimum length that cover , as they would partially intersect otherwise.\r\nNotice that we can always add and for all if they aren’t in yet. Now the\r\nforest of is a tree with exactly leaves.Suppose has children . If , we\r\ncan always add to , which decreases the number of children of by and\r\nincreases the size of by .Therefore, in the optimal solution each\r\nsegment has at most children. Having exactly one child is impossible, as\r\nwe have added all , so every index of is covered by its children.This\r\nmeans that we have a tree where each vertex has either or children,\r\nwhich is a full binary tree.We have leaves, and every full binary tree\r\nwith leaves has exactly vertices, so this is always the optimal size of\r\nregardless of .To count the number of , notice that when the answer is\r\nthe number of full binary trees with leaves, which is , where denotes\r\nthe Catalan’s sequence.To extend this to a general tree, we can add and\r\nfor all to .Now suppose has children . We need to merge some children.\r\nWe can treat as , as , etc. This is now the same case as , so there are\r\nways to merge children of .Each vertex is independent of each other, so\r\nthe answer is over all non-leaves , where is the number of children of\r\n.We can construct the tree in by definition or in using a stack.\r\n",
    "name": "E. Nested Segments",
    "statement": "A set A consisting of pairwise distinct segments [l, r] with integer\r\nendpoints is called if 1\r\nle l\r\nle r\r\nle n, and for any pair of distinct segments [l_i, r_i], [l_j, r_j] in A,\r\nexactly one of the following conditions holds: r_i < l_j or r_j < l_i\r\n(the segments do not intersect) l_i\r\nle l_j\r\nle r_j\r\nle r_i or l_j\r\nle l_i\r\nle r_i\r\nle r_j (one segment is fully contained within the other) You are given a\r\ngood set S consisting of m pairwise distinct segments [l_i, r_i] with\r\ninteger endpoints. You want to add as many additional segments to the\r\nset S as possible while ensuring that set S remains good. Since this\r\ntask is too easy, you need to determine the number of different ways to\r\nadd the maximum number of additional segments to S, ensuring that the\r\nset remains good. Two ways are considered different if there exists a\r\nsegment that is being added in one of the ways, but not in the\r\nother.Formally, you need to find the number of good sets T of distinct\r\nsegments, such that S is a subset of T and T has the maximum possible\r\nsize. Since the result might be very large, compute the answer modulo\r\n998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define N 400005#define M 505#define LL long long#define inf 21474836477777777ll#define LD long double#define eps 1e-6using namespace std;int n,m,rt,a[N],b[N],ifac[N],fac[N],cat[N],rk[N];const int p=998244353;// inline void add(int x,int y){son[++tot]=y,nxt[tot]=fir[x],fir[x]=tot;} inline int P(int x,int y){int z=1;while(y){if(y&1) z=1ll*z*x%p;y>>=1,x=1ll*x*x%p;} return z;}// inline void A(int &x,int y){x+=y,(x>=p)&&(x-=p,0),(x<0)&&(x+=p,0);}// inline void mul(int &x,int y){x=1ll*x*y%p;}inline bool cmp(int x,int y){if(a[x]^a[y]) return a[x]<a[y];return b[x]>b[y];}inline int dfs(int x,int &y){    int res=1,l=a[rk[x]],r=b[rk[x]],tot=r-l;y++;    while(y<=m&&b[rk[y]]<=r) tot-=b[rk[y]]-a[rk[y]],res=1ll*res*dfs(y,y)%p;return 1ll*res*cat[tot]%p;}inline void solve(int tc){    cin>>n>>m;a[0]=1,b[0]=n;for(int i=1;i<=m;i++) cin>>a[i]>>b[i],rk[i]=i;    fac[0]=1;for(int i=1;i<=n*2;i++) fac[i]=1ll*fac[i-1]*i%p;    ifac[n*2]=P(fac[n*2],p-2);for(int i=2*n-1;~i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%p;    for(int i=0;i<=n;i++) cat[i]=1ll*fac[2*i]*ifac[i]%p*ifac[i+1]%p;//cout<<cat[0]<<'\\n';    sort(rk+1,rk+m+1,cmp),rt=0,cout<<dfs(0,rt)<<'\\n';}int main(){    // freopen(\"data.in\",\"r\",stdin);    ios::sync_with_stdio(false);    cin.tie(0); cout.tie(0);    int tc=1;    cin>>tc;    while(tc--) solve(tc);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "dsu",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Nested Segments.json",
    "hint": [
        "Hint 1 Forget about counting. What is the maximum size of if ?",
        "Hint 2 It is . What if isn't ?",
        "Hint 3 It is still . To prove this represent a good set as a forest.",
        "Hint 4 We can always add and for all to . Now the tree of has exactly leaves. What if a vertex has more than children?",
        "Hint 5 What is the number of solutions when ?",
        "Hint 6 It is the number of full binary trees with leaves, which is , where denotes the Catalan's sequence. Extend this idea to count the number of solutions for a general tree of ."
    ]
}