{
    "link": "https://codeforces.com//contest/1768/problem/C",
    "problemId": "1720620",
    "problem_idx": "C",
    "shortId": "1768C",
    "contest_number": "1768",
    "problem_submissions": {
        "D": [
            204982953,
            188071247,
            188067925,
            188068130,
            188070945,
            188072940,
            188074516,
            188075810,
            188085152,
            188074579,
            188073456,
            188074101,
            188082385,
            188164225,
            188089006,
            188069736,
            188081987,
            188082522,
            188078305,
            188078232,
            188080797
        ],
        "F": [
            188116348,
            188135822,
            188160798,
            188176131,
            188168385
        ],
        "E": [
            188083790,
            188076616,
            188084542,
            188083977,
            188085068,
            188090588,
            188090979,
            188080120,
            188090253,
            188095827,
            188095081,
            188082638,
            188089969,
            188164249,
            188075544,
            188101242,
            188092147,
            188102271,
            188100942,
            188097984
        ],
        "C": [
            188076017,
            188062341,
            188060907,
            188066248,
            188067691,
            188065722,
            188067475,
            188070114,
            188066780,
            188064718,
            188068797,
            188076939,
            188164202,
            188081893,
            188163969,
            188059068,
            188075112,
            188075686,
            188069461,
            188068577,
            188075836
        ],
        "B": [
            188057634,
            188051968,
            188049872,
            188053488,
            188055902,
            188055318,
            188053420,
            188056521,
            188052830,
            188053386,
            188052891,
            188065110,
            188164191,
            188059182,
            188051170,
            188056859,
            188053279,
            188061154,
            188058286
        ],
        "A": [
            188047123,
            188046830,
            188047332,
            188048108,
            188047085,
            188046543,
            188047234,
            188050361,
            188047575,
            188046807,
            188046596,
            188059906,
            188164162,
            188047560,
            188046948,
            188050516,
            188048920,
            188047550,
            188060898,
            188051639
        ]
    },
    "name": "C. Elemental Decompress",
    "statement": "You are given an array a of n integers.Find two permutations^\r\ndagger p and q of length n such that\r\nmax(p_i,q_i)=a_i for all 1\r\nleq i\r\nleq n or report that such p and q do not exist.^\r\ndagger A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=2e5+10;\nint a[maxn],b[maxn],c[maxn],m,n,t_case;\nvector<int>v[maxn];\nint main(){\n\tscanf(\"%d\",&t_case);\n\twhile(t_case--){\n\t\tscanf(\"%d\",&n);\n\t\tfor(ri i=1;i<=n;++i)vector<int>().swap(v[i]);\n\t\tfor(ri i=1;i<=n;++i)scanf(\"%d\",a+i),v[a[i]].push_back(i);\n\t\tqueue<int>x,y;\n\t\tfor(ri i=1;i<=n;++i)\n\t\t\tif(v[i].size()>2){\n\t\t\t\tputs(\"NO\");\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\tfor(ri i=n;i;--i){\n\t\t\tif(v[i].empty()){\n\t\t\t\tif(x.empty()&&y.empty()){\n\t\t\t\t\tputs(\"NO\");\n\t\t\t\t\tgoto skip;\n\t\t\t\t}\n\t\t\t\tb[y.front()]=c[x.front()]=i;\n\t\t\t\tx.pop(),y.pop();\n\t\t\t}\n\t\t\telse if(v[i].size()==1){\n\t\t\t\tri z=v[i][0];\n\t\t\t\tif(x.empty()&&y.empty())b[z]=c[z]=i;\n\t\t\t\telse if(x.size())b[z]=c[x.front()]=i,x.pop(),x.push(z);\n\t\t\t\telse c[z]=b[y.front()]=i,y.pop(),y.push(z);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tri z=v[i][0],zz=v[i][1];\n\t\t\t\tb[z]=c[zz]=i;\n\t\t\t\tx.push(z),y.push(zz);\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(ri i=1;i<=n;++i)printf(\"%d%c\",b[i],\" \\n\"[i==n]);\n\t\tfor(ri i=1;i<=n;++i)printf(\"%d%c\",c[i],\" \\n\"[i==n]);\n\t\tskip:;\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Elemental Decompress.json",
    "editorial_link": "https://codeforces.com//blog/entry/110901",
    "editorial": "For some fixed , there are permutations that have exactly inversion in\r\nthem (the inversion is colored): ... Let\u00e2\u0080\u0099s build a directed graph with\r\nvertices where the -th vertex has an outgoing edge . It is easy to see\r\nthat the graph is divided up into cycles of the form .Let be the number\r\nof cycles in this graph. It is a well know fact that is the minimum\r\nnumber of swaps needed to get the permutation from our initial one (in\r\nother words, to sort it). Suppose we now want to get the -th permutation\r\nfrom the list above. Let and be such that and . Let us remove the edges\r\nand from the graph and instead add the edges and . Let be the number of\r\ncycles in this new graph. The minimum number of swaps needed to get the\r\n-th permutation in the list is equal to . Turns out that we can easily\r\ncalculate if we know : if the vertices and were in the same cycle in the\r\ninitial graph, otherwise. To quickly check if two vertices and are in\r\nthe same cycle, assign some id to each cycle (with a simple dfs or with\r\na DSU) and the compare -s cycle id with -s cycle id.The answer is just\r\nthe minimum possible value of over all .Time complexity: .PS: you can\r\nalso find with data structures (for example, by maintaining a treap for\r\neach cycle).\r\n"
}