{
    "link": "https://codeforces.com//contest/752/problem/F",
    "problemId": "86741",
    "problem_idx": "F",
    "shortId": "752F",
    "contest_number": "752",
    "problem_submissions": {
        "E": [
            23307622,
            23298919,
            23293210,
            23296558,
            23289533,
            23300446,
            23289683,
            23303428,
            23297443,
            23304427,
            23304013,
            23301941,
            23302122,
            23296625,
            23299319,
            23308344,
            23296295,
            23301867,
            23298965
        ],
        "F": [
            23299614,
            23303097,
            23296260,
            23300075,
            23297820,
            23312296,
            23333337,
            23302007,
            23335434,
            23945130
        ],
        "D": [
            23293425,
            23296203,
            23296737,
            23303994,
            23297487,
            23296079,
            23297542,
            23304572,
            23298416,
            23301016,
            23298334,
            23301490,
            23342391,
            23303337,
            23298346,
            23305352,
            23295756,
            23302406
        ],
        "B": [
            23289571,
            23288739,
            23297269,
            23301250,
            23289332,
            23290328,
            23290841,
            23289310,
            23291467,
            23292074,
            23312032,
            23305914,
            23302012,
            23289784,
            23305350
        ],
        "C": [
            23288680,
            23289735,
            23290504,
            23291795,
            23293248,
            23292966,
            23293101,
            23290858,
            23293431,
            23292145,
            23290141,
            23293830,
            23292041,
            23293667,
            23293134,
            23292174,
            23291253,
            23291455,
            23296543,
            23939849,
            23294485
        ],
        "A": [
            23288066,
            23288054,
            23288222,
            23289194,
            23290949,
            23288138,
            23294677,
            23288200,
            23288517,
            23288677,
            23288100,
            23288709,
            23288239,
            23288139,
            23288488,
            23288364,
            23288063,
            23288232,
            23288317,
            23288593
        ]
    },
    "name": "F. Santa Clauses and a Soccer Championship",
    "statement": "The country Treeland consists of cities connected with bidirectional\r\nroads in such a way that it’s possible to reach every city starting from\r\nany other city using these roads. There will be a soccer championship\r\nnext year, and all participants are Santa Clauses. There are exactly\r\nteams from different cities.During the first stage all teams are divided\r\ninto pairs. Teams of each pair play two games against each other: one in\r\nthe hometown of the first team, and the other in the hometown of the\r\nother team. Thus, each of the cities holds exactly one soccer game.\r\nHowever, it’s not decided yet how to divide teams into pairs.It’s also\r\nnecessary to choose several cities to settle players in. Organizers tend\r\nto use to settle the teams.Nobody wants to travel too much during the\r\nchampionship, so if a team plays in cities and , it wants to live in one\r\nof the cities on the shortest path between and (maybe, in or in ). There\r\nis another constraint also: the teams from one pair must live in the\r\nsame city.Summarizing, the organizers want to divide teams into pairs\r\nand settle them in the minimum possible number of cities in such a way\r\nthat teams from each pair live in the same city which lies between their\r\nhometowns.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N, K, C, n[200200], c[200200], id[200200], mx[200200], st = -1, arr[200200];\nvector<int> adj[200200],  v, nu;\nvector<vector<int>> shit;\nvector<pair<int,int>> res;\n\nvoid go (int i, int p) {\n\tid[i] = C++;\n\n\tbool ok = 1;\n\n\tfor (int j : adj[i]) if (j != p) {\n\t\tgo(j, i);\n\t\tc[i] += c[j];\n\t\tif (c[j] > K) ok = 0;\n\t}\n\n\tif (2*K - c[i] > K) ok = 0;\n\n\tif (ok) {\n\t\tst = i;\n\t}\n\n\tmx[i] = C;\n}\n\nvoid dfs (int i, int p) {\n\tif (n[i]) nu.PB(arr[n[i]]);\n\tfor (int j : adj[i]) if (j != p) dfs(j, i);\n}\n\nbool cmp (vector<int>& a, vector<int>& b) {\n\treturn a.size() > b.size();\n}\npriority_queue<pair<int,int>> q;\n\nint main () {\n\tscanf(\"%d %d\", &N, &K);\n\tfo(z, 0, N-1) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tadj[a].PB(b), adj[b].PB(a);\n\t}\n\tfo(z, 0, 2*K) {\n\t\tint a; scanf(\"%d\", &a);\n\t\tn[a] = z+1, c[a] = 1;\n\t\tarr[z+1] = a;\n\t}\n\tgo(1, -1);\n\n\tassert(st != -1);\n\n\tprintf(\"%d\\n%d\\n\", 1, st);\n\n\tif (n[st]) v.PB(arr[n[st]]), shit.PB(v);\n\tfor (int j : adj[st]) {\n\t\tdfs(j, st);\n\t\tshit.PB(nu);\n\t\tnu.clear();\n\t}\n\tsort(shit.begin(), shit.end());\n\tfo(i, 0, (int) shit.size()) if (shit[i].size()) {\n\t\tq.push(MP((int) shit[i].size(), i));\n\t}\n\twhile (q.size()) {\n\t\tint x = q.top().second; q.pop();\n\t\tint y = q.top().second; q.pop();\n\t\tres.PB(MP(shit[x].back(), shit[y].back()));\n\t\tshit[x].pop_back();\n\t\tshit[y].pop_back();\n\t\tif (shit[x].size()) q.push(MP((int)shit[x].size(), x));\n\t\tif(shit[y].size()) q.push(MP((int)shit[y].size(), y));\n\t}\n\n\tfor (auto i : res) printf(\"%d %d %d\\n\", i.first, i.second, st);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Santa Clauses and a Soccer Championship.json",
    "editorial_link": "https://codeforces.com//blog/entry/49328",
    "editorial": "Firstly, let's prove that there exists a vertex v in the tree such that if we make it a root, all subtrees of its neighbours (which does not contain v) contain no more than k vertices in which some games are played (we call these vertices chosen further). We root the tree in some vertex root and denote f(u) the number of chosen vertices in the subtree of u. Now we need to prove that there exists vertex v such that f(v)???k (then no more than k vertices outside subtree of v are chosen), but for all children to of v f(to)???k holds. Assume there is no such vertex v, then each vertex u such that f(u)?>?k has some child u' such that f(u')?>?k. So we can build a sequence u0,?u1,?... such that u0?=?root,? ui?+?1 is a child of ui and f(ui)?>?k. But obviously, at some point we will go to the leaf, which clearly has f(u)???1. This leads us to a contradiction.\n\nThis argument also gives us an easy way to find the desired vertex v: just calculate f(u) for all subtrees of the rooted tree and then go from the root down, always going to the child with f(ui?+?1)?>?k, at some point we will find that such vertex does not exist  then current vertex is the one we were looking for.\n\nWe claim that the answer to the original problem is always 1, i.e. we can always choose one vertex, where all teams will live. Consider vertex v having f(to)???k for all its children. We create a list of all chosen vertices, firstly we write all chosen vertices of the first child's subtree of v, then all chosen vertices of the second child's subtree, and so on. In the end, if v is chosen too, we add it to the end of the list. Now we have a list of 2k vertices a. Let's create k pairs of the form (ai,?ai?+?k). Since for all children of v f(to)???k holds, the vertices which numbers in the list differ by k can not belong to the same subtrees, and thus the shortest path between ai and ai?+?k passes through the vertex v.",
    "hint": []
}