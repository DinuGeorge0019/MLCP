{
    "link": "https://codeforces.com//contest/1088/problem/F",
    "problemId": "265516",
    "problem_idx": "F",
    "shortId": "1088F",
    "contest_number": "1088",
    "problem_submissions": {
        "E": [
            46613818,
            46607141,
            46622308,
            46615414,
            46615340,
            46613967,
            46615252,
            46616546,
            46614495,
            46614700,
            46614606,
            46614754,
            46614788,
            46616179,
            46615460,
            46618581,
            46617501,
            46617370,
            46614755,
            46616173,
            46613969
        ],
        "D": [
            46606352,
            46614493,
            46605224,
            46604678,
            46601623,
            46606254,
            46607253,
            46607426,
            46610831,
            46610433,
            46609743,
            46607835,
            46609488,
            46611474,
            46605699,
            46607479,
            46607462,
            46610178,
            46612056,
            46614466
        ],
        "C": [
            46599870,
            46601168,
            46596733,
            46596413,
            46608489,
            46598333,
            46599765,
            46596362,
            46601546,
            46599406,
            46601980,
            46598703,
            46596638,
            46598616,
            46598412,
            46594224,
            46598573,
            46596310,
            46600636,
            46598721
        ],
        "B": [
            46592520,
            46594336,
            46592669,
            46592597,
            46593347,
            46594184,
            46593000,
            46591239,
            46592041,
            46594521,
            46593534,
            46592218,
            46591250,
            46592164,
            46592604,
            46591755,
            46592804,
            46591647,
            46593144,
            46598081
        ],
        "A": [
            46589019,
            46591880,
            46588772,
            46590862,
            46589318,
            46592306,
            46588857,
            46588804,
            46589750,
            46594413,
            46591038,
            46589043,
            46589388,
            46588963,
            46589855,
            46588950,
            46589641,
            46588846,
            46589211,
            46597672
        ],
        "F": [
            46647126,
            46717273
        ]
    },
    "name": "F. Ehab and a weird weight formula",
    "statement": "You\u2019re given a tree consisting of n nodes. Every node u has a weight\r\na_u. It is guaranteed that there is only one node with minimum weight in\r\nthe tree. For every node u (except for the node with the minimum\r\nweight), it must have a neighbor v such that a_v<a_u. You should\r\nconstruct a tree to minimize the weight w calculated as follows: For\r\nevery node u, deg_u\r\ncdot a_u is added to w (deg_u is the number of edges containing node u).\r\nFor every edge\r\n{ u,v\r\n},\r\nlceil log_2(dist(u,v))\r\nrceil\r\ncdot min(a_u,a_v) is added to w, where dist(u,v) is the number of edges\r\nin the path from u to v in the given tree.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<vector>\n#define N (1001010)\n#define LL long long\nusing namespace std;\nint n,A[N],rt,f[N][40];\nvector <int> Vec[N];\nLL ans;\nvoid Dfs(int x){\n\tfor (int i=0;i<Vec[x].size();i++){\n\t\tint y=Vec[x][i];\n\t\tif (y==f[x][0]) continue;\n\t\tf[y][0]=x;\n\t\tDfs(y);\n\t}\n}\nLL Lmin(LL a,LL b){\n\tif (a<b) return a;\n\treturn b;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&A[i]);\n\trt=1;\n\tfor (int i=2;i<=n;i++) if (A[i]<A[rt]) rt=i;\n\tfor (int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tVec[x].push_back(y);\n\t\tVec[y].push_back(x);\n\t}\n\tDfs(rt);\n\tf[rt][0]=rt;\n\tfor (int j=1;j<=30;j++) for (int i=1;i<=n;i++)\n\t\tf[i][j]=f[f[i][j-1]][j-1];\n\t\n\tfor (int i=1;i<=n;i++) if (i!=rt){\n\t\tLL Min=(LL)A[f[i][0]]+(LL)A[i];\n\t\tfor (int k=1;k<=30;k++)\n\t\t\tMin=Lmin(Min,(LL)k*(LL)min(A[i],A[f[i][k]])+(LL)(A[i]+A[f[i][k]]));\n\t\tans+=Min;\n\t}\n\tcout<<ans;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Ehab and a weird weight formula.json",
    "editorial_link": "https://codeforces.com//blog/entry/63656",
    "editorial": "First, let\u00e2\u0080\u0099s reduce the problem to ordinary MST. We know that each edge\r\nadds to . In fact, it also adds 1 to and . Thus, the problem is ordinary\r\nMST on a complete graph where each edge has weight ! Let the node with\r\nthe minimum weight be . Let\u00e2\u0080\u0099s root the tree at it. Lemma: for every node\r\nand a child , . In simpler words, the weight increase as we go down the\r\ntree. Proof: the proof is by contradiction. Assume . Then, the condition\r\nin the problem (that every node has an adjacent node with less weight)\r\nisn\u00e2\u0080\u0099t satisfied yet for . Therefore, must have a child such that .\r\nHowever, the condition isn\u00e2\u0080\u0099t satisfied for , so needs another child and\r\nthe child needs another child etc. (the tree will be infinite) which is\r\nclearly a contradiction. From that, we know that the weights decrease as\r\nwe go up the tree and increase as we go down. Back to the MST problem.\r\nFrom Kruskal\u00e2\u0080\u0099s algorithm, we know that the minimal edge incident to\r\nevery node will be added to the MST (because the edges are sorted by\r\nweight). Let\u00e2\u0080\u0099s analyze the minimal edge incident to every node . Let its\r\nother end be . Except for node , will be an ancestor of . Why? Assume we\r\nfix the distance part and just want to minimize . We\u00e2\u0080\u0099ll keep going up\r\nthe tree (it\u00e2\u0080\u0099s never optimal to go down, since the weights will\r\nincrease) until we reach the desired distance. Now, since the minimal\r\nedge incident to every node will be added to the MST (by Kruskal\u00e2\u0080\u0099s\r\nalgorithm), and they\u00e2\u0080\u0099re distinct (because, otherwise, you\u00e2\u0080\u0099re saying that\r\nis an ancestor of and is an ancestor of ), THEY ARE THE MST. Now, the\r\nproblem just reduces to finding the minimal edge incident to every node\r\nand summing them up (except for ). To do that, we\u00e2\u0080\u0099ll fix the (let it be\r\n), and get the ancestor with the well-known sparse-table (binary\r\nlifting). Code link: https://pastebin.com/vzJqh8si Time complexity: .\r\n"
}