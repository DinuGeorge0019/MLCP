{"link": "https://codeforces.com//contest/1088/problem/F", "problemId": "265516", "problem_idx": "F", "shortId": "1088F", "contest_number": "1088", "problem_submissions": {"E": [46613818, 46607141, 46622308, 46615414, 46615340, 46613967, 46615252, 46616546, 46614495, 46614700, 46614606, 46614754, 46614788, 46616179, 46615460, 46618581, 46617501, 46617370, 46614755, 46616173, 46613969], "D": [46606352, 46614493, 46605224, 46604678, 46601623, 46606254, 46607253, 46607426, 46610831, 46610433, 46609743, 46607835, 46609488, 46611474, 46605699, 46607479, 46607462, 46610178, 46612056, 46614466], "C": [46599870, 46601168, 46596733, 46596413, 46608489, 46598333, 46599765, 46596362, 46601546, 46599406, 46601980, 46598703, 46596638, 46598616, 46598412, 46594224, 46598573, 46596310, 46600636, 46598721], "B": [46592520, 46594336, 46592669, 46592597, 46593347, 46594184, 46593000, 46591239, 46592041, 46594521, 46593534, 46592218, 46591250, 46592164, 46592604, 46591755, 46592804, 46591647, 46593144, 46598081], "A": [46589019, 46591880, 46588772, 46590862, 46589318, 46592306, 46588857, 46588804, 46589750, 46594413, 46591038, 46589043, 46589388, 46588963, 46589855, 46588950, 46589641, 46588846, 46589211, 46597672], "F": [46647126, 46717273]}, "name": "F. Ehab and a weird weight formula", "statement": "You\u2019re given a tree consisting of n nodes. Every node u has a weight\r\na_u. It is guaranteed that there is only one node with minimum weight in\r\nthe tree. For every node u (except for the node with the minimum\r\nweight), it must have a neighbor v such that a_v<a_u. You should\r\nconstruct a tree to minimize the weight w calculated as follows: For\r\nevery node u, deg_u\r\ncdot a_u is added to w (deg_u is the number of edges containing node u).\r\nFor every edge\r\n{ u,v\r\n},\r\nlceil log_2(dist(u,v))\r\nrceil\r\ncdot min(a_u,a_v) is added to w, where dist(u,v) is the number of edges\r\nin the path from u to v in the given tree.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<vector>\n#define N (1001010)\n#define LL long long\nusing namespace std;\nint n,A[N],rt,f[N][40];\nvector <int> Vec[N];\nLL ans;\nvoid Dfs(int x){\n\tfor (int i=0;i<Vec[x].size();i++){\n\t\tint y=Vec[x][i];\n\t\tif (y==f[x][0]) continue;\n\t\tf[y][0]=x;\n\t\tDfs(y);\n\t}\n}\nLL Lmin(LL a,LL b){\n\tif (a<b) return a;\n\treturn b;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&A[i]);\n\trt=1;\n\tfor (int i=2;i<=n;i++) if (A[i]<A[rt]) rt=i;\n\tfor (int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d %d\",&x,&y);\n\t\tVec[x].push_back(y);\n\t\tVec[y].push_back(x);\n\t}\n\tDfs(rt);\n\tf[rt][0]=rt;\n\tfor (int j=1;j<=30;j++) for (int i=1;i<=n;i++)\n\t\tf[i][j]=f[f[i][j-1]][j-1];\n\t\n\tfor (int i=1;i<=n;i++) if (i!=rt){\n\t\tLL Min=(LL)A[f[i][0]]+(LL)A[i];\n\t\tfor (int k=1;k<=30;k++)\n\t\t\tMin=Lmin(Min,(LL)k*(LL)min(A[i],A[f[i][k]])+(LL)(A[i]+A[f[i][k]]));\n\t\tans+=Min;\n\t}\n\tcout<<ans;\n}"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "2800", "interactive": false}