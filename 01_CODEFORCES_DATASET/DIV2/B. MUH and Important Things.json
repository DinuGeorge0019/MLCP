{
    "link": "https://codeforces.com//contest/471/problem/B",
    "problemId": "14356",
    "problem_idx": "B",
    "shortId": "471B",
    "contest_number": "471",
    "problem_submissions": {
        "D": [
            7965405,
            7963038,
            7965335,
            7968421,
            7966244,
            7968397,
            7967934,
            7967754,
            7962449,
            7971169,
            7966737,
            7967640,
            7966907,
            7965389,
            7968194,
            7968684,
            7968144,
            7968063,
            7969059,
            7969743
        ],
        "C": [
            7963799,
            7964161,
            7963025,
            7965860,
            7964576,
            7965647,
            7964444,
            7963849,
            7964165,
            7964646,
            7964390,
            7964067,
            7964677,
            7967841,
            7964930,
            7962467,
            7965383,
            7966049,
            7964548,
            7964611
        ],
        "B": [
            7962693,
            7961062,
            7959880,
            7962852,
            7961634,
            7961073,
            7961603,
            7961941,
            7966053,
            7965991,
            7961463,
            7961486,
            7962239,
            7963641,
            7962519,
            7960810,
            7962445,
            7961115,
            7962351,
            7961842
        ],
        "A": [
            7960020,
            7958602,
            7958473,
            7958790,
            7958822,
            7958588,
            7958849,
            7958927,
            7967090,
            7966996,
            7958571,
            7958632,
            7958550,
            7959873,
            7959046,
            7969496,
            7958766,
            7958587,
            7958630,
            7959368
        ]
    },
    "name": "B. MUH and Important Things",
    "statement": "It\u2019s time polar bears Menshykov and Uslada from the zoo of St.\r\nPetersburg and elephant Horace from the zoo of Kiev got down to\r\nbusiness. In total, there are tasks for the day and each animal should\r\ndo each of these tasks. For each task, they have evaluated its\r\ndifficulty. Also animals decided to do the tasks in order of their\r\ndifficulty. Unfortunately, some tasks can have the same difficulty, so\r\nthe order in which one can perform the tasks may vary.Menshykov, Uslada\r\nand Horace ask you to deal with this nuisance and come up with\r\nindividual plans for each of them. The plan is a sequence describing the\r\norder in which an animal should do all the tasks. Besides, each of them\r\nwants to have its own unique plan. Therefore three plans must form three\r\ndifferent sequences. You are to find the required plans, or otherwise\r\ndeliver the sad news to them by stating that it is impossible to come up\r\nwith three distinct plans for the given tasks.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int maxn=2005;\n\nint n,f[maxn];\nvector<int> s[maxn];\n\nbool check(){\n    bool flag=false;\n    for(int i=0;i<maxn;i++)\n        if((int)s[i].size()>2)return true;\n        else if((int)s[i].size()==2){\n            if(flag)return true;\n            else flag=true;\n        }\n    return false;\n}\n\nvoid shuchu(){\n    bool flag=false;\n    for(int i=0;i<maxn;i++)\n        for(int j=0;j<(int)s[i].size();j++){\n            if(flag)cout<<' ';\n            else flag=true;\n            cout<<s[i][j];\n        }\n    cout<<endl;\n}\n\nvoid solve(){\n    int x=-1;\n    for(int i=0;i<maxn;i++)\n        if((int)s[i].size()>2)x=i;\n    if(~x){\n        for(int ii=0;ii<3;ii++){\n            shuchu();\n            next_permutation(s[x].begin(),s[x].end());\n        }\n        return;\n    }\n    int y=-1;\n    for(int i=0;i<maxn;i++)\n        if((int)s[i].size()==2){\n            if(x==-1)x=i;\n            else y=i;\n        }\n    shuchu();\n    next_permutation(s[x].begin(),s[x].end());\n    shuchu();\n    next_permutation(s[y].begin(),s[y].end());\n    shuchu();\n}\n\nint main(){\n    cin>>n;\n    for(int i=0;i<maxn;i++)\n        s[i].clear();\n    for(int i=1;i<=n;i++){\n        cin>>f[i];\n        s[f[i]].push_back(i);\n    }\n    if(!check()){\n        puts(\"NO\");\n        return 0;\n    }\n    puts(\"YES\");\n    solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. MUH and Important Things.json",
    "editorial_link": "https://codeforces.com//blog/entry/13986",
    "editorial": "You need to check whether exist three pairwise different permutations of\r\nthe indices of the input which result in array being sorted. Generally\r\nyou can count the number of total permutation which give non-decreasing\r\narray. This number might be very large and it might easily overflow even\r\nlong integer type. And what is more important is that you don\u00e2\u0080\u0099t actually\r\nneed to count the exact number of such permutations. Let\u00e2\u0080\u0099s tackle this\r\nproblem from another angle. Assume you already sorted the input array\r\nand you have the corresponding permutation of indices. This already\r\ngives you one array for the result, you only need to find two more.\r\nLet\u00e2\u0080\u0099s look for any pair of equal numbers in the input array, if we swap\r\nthem then we will get another valid permutation. And if we find one more\r\npair of equal numbers then swapping them you can get third permutation\r\nand that will be the answer. You need to keep in mind here that one of\r\nthe indices when swapping the second time might be the same as one of\r\nthe numbers in the first swap, that\u00e2\u0080\u0099s ok as soon as second index is\r\ndifferent. So all you need to do is to find two pairs of indices which\r\npoint to the equal elements. The entire algorithm is as follows:\r\nTransform the input array into array of pairs (tuples), first element of\r\nthe pair will be the number given in the input array, the second element\r\nwill be the index of that number. Sort that array of pairs by the first\r\nelement of the pairs. Then the second elements will give you one correct\r\npermutation. Scan this array in order to find possible swaps. You just\r\niterate over this array and check if the first element in the current\r\npair equals to the first element of the previous pair. If it equals you\r\nremember the indices of these two pairs. You stop scanning the array as\r\nsoon as you have two swaps. Then you check how many swaps you have, if\r\nyou have less than two swaps then there are no three distinct\r\npermutations. Otherwise you have two swaps which means that you have an\r\nanswer. So you print the current permutation, then you execute the first\r\nswap (you just swap those two elements you remembered in the first\r\nswap), then you print the permutation array received after executing\r\nthat swap. And you execute the second swap and print the permutation\r\narray third time. Author\u00e2\u0080\u0099s solution: 7977528\r\n"
}