{
    "link": "https://codeforces.com//contest/727/problem/E",
    "problemId": "75803",
    "problem_idx": "E",
    "shortId": "727E",
    "contest_number": "727",
    "problem_submissions": {
        "F": [
            21454299,
            21463560,
            21456437,
            21465295,
            21454474,
            21458264,
            21456589
        ],
        "E": [
            21449841,
            21449822,
            21450904,
            21453568,
            21453967,
            21760601,
            21511825,
            21511807,
            21511800,
            21454554,
            21549212,
            21460363,
            21455919,
            21459919
        ],
        "D": [
            21446491,
            21446004,
            21446992,
            21445398,
            21448520,
            21448519,
            21447217,
            21446535,
            21447223,
            21446711,
            21448124,
            21446242,
            21447928,
            21448652,
            21448435,
            21449709,
            21448635,
            21445975,
            21450092
        ],
        "C": [
            21445102,
            21444938,
            21445707,
            21444476,
            21446045,
            21446680,
            21446166,
            21445050,
            21443956,
            21445410,
            21446522,
            21445734,
            21446213,
            21445295,
            21445829,
            21445999,
            21444171,
            21447101
        ],
        "B": [
            21444430,
            21444284,
            21444596,
            21443833,
            21445575,
            21445150,
            21455506,
            21444391,
            21445186,
            21444885,
            21444164,
            21445217,
            21445115,
            21446297,
            21444840,
            21445324,
            21453096,
            21445206
        ],
        "A": [
            21442889,
            21442869,
            21443136,
            21442911,
            21443243,
            21443224,
            21443033,
            21442981,
            21442858,
            21442965,
            21442983,
            21442922,
            21442918,
            21442957,
            21443069,
            21443067,
            21443028,
            21443089,
            21442924,
            21443118
        ]
    },
    "name": "E. Games on a CD",
    "statement": "Several years ago Tolya had computer games and at some point of time he\r\ndecided to burn them to CD. After that he wrote down the names of the\r\ngames one after another in a circle on the CD . The names were distinct,\r\nthe length of each name was equal to . The names didn’t overlap.Thus,\r\nthere is a cyclic string of length written on the CD.Several years have\r\npassed and now Tolya can’t remember which games he burned to his CD. He\r\nknows that there were popular games that days. All of the games he\r\nburned were among these games, and .You have to restore any valid list\r\nof games Tolya could burn to the CD several years ago.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld EPS = 1e-7;\n\nconst int N = 3e6 + 123;\nconst int M = 2e5 + 123;\nconst int A = 'z' - 'a' + 2;\n\nstruct Node {\n    int term;\n    int nxt[A];\n    int link;\n    int p, ps;\n    \n    Node() {\n        ps = -1;\n        p = -1;\n        term = -1;\n        fill(nxt, nxt + A, -1);\n        link = -1;\n    }\n};\n\nint ptr = 1;\nNode trie[N];\n\nint get_id(const string &s) {\n    int cur_v = 0;\n    for (char cc : s) {\n        int c = cc - 'a';\n        if (trie[cur_v].nxt[c] == -1) {\n            assert(false);\n        }\n        cur_v = trie[cur_v].nxt[c];\n    }\n    \n    return trie[cur_v].term;\n}\n\nvoid add(const string &s, int id) {\n    int cur_v = 0;\n    for (char cc : s) {\n        int c = cc - 'a';\n        if (trie[cur_v].nxt[c] == -1) {\n            trie[cur_v].nxt[c] = ptr++;\n            trie[ptr - 1].p = cur_v;\n            trie[ptr - 1].ps = c;\n        }\n        cur_v = trie[cur_v].nxt[c];\n    }\n    \n    trie[cur_v].term = id;\n}\n\nint link(int v);\n\nint go(int v, int c) {\n    if (trie[v].nxt[c] != -1) {\n        return trie[v].nxt[c];\n    }\n    if (v == 0) {\n        return 0;\n    }\n    \n    return trie[v].nxt[c] = go(link(v), c);\n}\n\nint link(int v) {\n    if (trie[v].link != -1) {\n        return trie[v].link;\n    }\n    \n    if (v == 0 || trie[v].p == 0) {\n        return 0;\n    }\n    \n    return trie[v].link = go(link(trie[v].p), trie[v].ps);\n}\n\nint n, k;\nset<int> q[M];\n\nint run() {\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int l = (int) s.size();\n    s = s + s;\n    \n    int g;\n    cin >> g;\n    for (int i = 0; i < g; i++) {\n        string t;\n        cin >> t;\n        add(t, i + 1);\n    }\n    \n    int cur_v = 0;\n    \n    for (int i = 0; i < 2 * l; i++) {\n        cur_v = go(cur_v, s[i] - 'a');\n        \n        if (trie[cur_v].term != -1) {\n            int beg = i - k + 1;\n            if (beg < l) {\n                q[beg % k].insert(cur_v);\n            }\n        }\n    }\n    \n    for (int i = 0; i < k; i++) {\n        if ((int) q[i].size() == n) {\n            cout << \"YES\\n\";\n            for (int j = 0; j < n; j++) {\n                cout << get_id(s.substr(i + j * k, k)) << \" \";\n            }\n            cout << \"\\n\";\n            return 0;\n        }\n    }\n    \n    cout << \"NO\\n\";\n    \n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    return run();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Games on a CD.json",
    "editorial_link": "https://codeforces.com//blog/entry/47773",
    "editorial": "With help of Aho Corasick algorithm we need to build the suffix tree on\r\nthe set of game names ans in the vertex of the tree (which correspond to\r\nthe name of some game, this vertex will be on the depth ) we will store\r\nthe number of this game.Builded tree allows to add symbols to some\r\nstring one by one and find the vertex which corresponds to the longest\r\nprefix from all prefixes of game names which equals to the suffix of our\r\nstring. If the length of this prefix equals to the suffix equals to some\r\ngame name.Letâs write the string which wrote on disk twice and calculate\r\nthe index of the game which name equals to substring of doubled string\r\nfrom index to index inclusively (if such index does not exist itâs\r\nequals to ). Now we need to iterate through the indexes of symbols which\r\nis last in the name of some game. We can iterate from to . With fixed we\r\nneed to check that all game names with last symbols in indexes for are\r\ndifferent (for it we need to check that among there is no and all of\r\nthem are different). If it is performed print and now it is easy to\r\nrestore the answer. If the condition failed for all print .Asymptotic\r\nbehavior of this solution\r\n",
    "hint": []
}