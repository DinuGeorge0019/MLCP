{"link": "https://codeforces.com//contest/1401/problem/D", "problemId": "704916", "problem_idx": "D", "shortId": "1401D", "contest_number": "1401", "problem_submissions": {"E": [90589999, 90578154, 90605920, 90584030, 90594969, 90593911, 90572580, 90599304, 90615088, 90675249, 90605781, 90590132, 90599391, 90594214, 90758857, 90645951, 90601216], "F": [90580393, 90597215, 90579684, 90610107, 90603479, 90603116, 90603512, 90617786, 90601646, 90675259, 90613571, 90583132, 90589402, 90594866, 90604055, 90620941, 90598510, 90646625], "D": [90560258, 90565538, 90550432, 90567225, 90569423, 90571869, 90587693, 90567049, 90578884, 90577112, 90563897, 90566957, 90557267, 90573179, 90565326, 90564972, 90565503, 90568268, 90571582], "C": [90551509, 90552981, 90554787, 90547352, 90555070, 90559549, 90607672, 90556632, 90562455, 90568524, 90549734, 90553714, 90548534, 90548686, 90550222, 90543917, 90550988, 90557805, 90555836], "B": [90546499, 90547295, 90558760, 90542536, 90550631, 90551851, 90549294, 90545681, 90553940, 90549432, 90563346, 90548659, 90544907, 90558972, 90545692, 90550414, 90545438, 90550179, 90547970], "A": [90541721, 90542770, 90541219, 90541087, 90544810, 90561361, 90543645, 90541402, 90544925, 90541955, 90542350, 90543732, 90541094, 90542063, 90541725, 90541822, 90542174, 90542376, 90542708]}, "name": "D. Maximum Distributed Tree", "statement": "You are given a tree that consists of n nodes. You should label each of\r\nits n-1 edges with an integer in such way that satisfies the following\r\nconditions: each integer must be greater than 0; the product of all n-1\r\nnumbers should be equal to k; the number of 1-s among all n-1 integers\r\nmust be minimum possible. Let\u2019s define f(u,v) as the sum of the numbers\r\non the simple path from node u to node v. Also, let\r\nsum\r\nlimits_{i=1}^{n-1}\r\nsum\r\nlimits_{j=i+1}^n f(i,j) be a of the tree.Find the maximum possible\r\ndistribution index you can get. Since answer can be too large, print it\r\nmodulo 10^9 + 7.In this problem, since the number k can be large, the\r\nresult of the prime factorization of k is given instead.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MAX = 1e5, MOD = 1e9+7;\nint n, m;\nvi adj[MAX];\nll p[MAX], s[MAX], contrib[MAX];\n\nvoid dfs(int u=0, int p=-1) {\n\ts[u]=1;\n\tfor(int v : adj[u]) {\n\t\tif(v==p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v, u);\n\t\ts[u]+=s[v];\n\t}\n\tcontrib[u]=s[u]*(n-s[u]);\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tadj[i].clear();\n\t\t}\n\t\tfor(int i=0; i<n-1; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v, --u, --v;\n\t\t\tadj[u].pb(v);\n\t\t\tadj[v].pb(u);\n\t\t}\n\t\tcin >> m;\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tcin >> p[i];\n\t\t}\n\t\tsort(p, p+m);\n\t\tdfs();\n\t\tsort(contrib+1, contrib+n);\n\t\tll ans=0;\n\t\tfor(int i=n-1; i>0; i--) {\n\t\t\tll pp=1;\n\t\t\tif(i>n-1-m) {\n\t\t\t\tpp=p[i-1-max(n-1-m, 0)];\n\t\t\t}\n\t\t\tif(i==n-1) {\n\t\t\t\tfor(int j=n-1; j<m; j++) {\n\t\t\t\t\tpp=pp*p[j]%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += pp*contrib[i]%MOD;\n\t\t}\n\t\tcout << ans%MOD << \"\\n\";\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "implementation", "math", "number theory", "sortings", "trees"], "dificulty": "1800", "interactive": false}