{
    "link": "https://codeforces.com//contest/1247/problem/D",
    "problemId": "451064",
    "problem_idx": "D",
    "shortId": "1247D",
    "contest_number": "1247",
    "problem_submissions": {
        "F": [
            63516585,
            63498066,
            63531653,
            63484717
        ],
        "E": [
            63466015,
            63473982,
            63472756,
            63472587,
            63477513,
            63473125,
            63474516,
            63476526,
            63478680,
            63473858,
            63480958,
            63481550,
            63481519,
            63482376,
            63483256,
            63481801,
            63480736,
            63482911,
            63484993
        ],
        "D": [
            63458462,
            63452186,
            63464452,
            63462467,
            63461642,
            63462284,
            63469112,
            63466038,
            63465533,
            63467098,
            63466913,
            63532659,
            63458800,
            63469138,
            63466028,
            63518059,
            63471109,
            63471871,
            63471893,
            63472863,
            63468681
        ],
        "C": [
            63451842,
            63448915,
            63446524,
            63452894,
            63453210,
            63465192,
            63456520,
            63458388,
            63455590,
            63458932,
            63454282,
            63457733,
            63453216,
            63464210,
            63454777,
            63455424,
            63462076,
            63462168,
            63461001
        ],
        "B1": [
            63441028,
            63445773,
            63455031,
            63446312,
            63447577,
            63448362,
            63448931,
            63448486,
            63445824,
            63453830,
            63446861,
            63447193,
            63445847,
            63460715,
            63448295,
            63449973,
            63454578,
            63450726,
            63449807
        ],
        "B2": [
            63440055,
            63445491,
            63454826,
            63446019,
            63446936,
            63447440,
            63449345,
            63447899,
            63445385,
            63454155,
            63447268,
            63446929,
            63448203,
            63460143,
            63447809,
            63449173,
            63454319,
            63450374,
            63450053
        ],
        "A": [
            63437545,
            63439551,
            63452092,
            63445337,
            63447252,
            63440937,
            63439822,
            63438397,
            63438564,
            63453424,
            63437913,
            63439495,
            63438907,
            63456486,
            63442538,
            63445415,
            63444316,
            63440390,
            63439231
        ]
    },
    "name": "D. Power Products",
    "statement": "You are given n positive integers a_1,\r\nldots, a_n, and an integer k\r\ngeq 2. Count the number of pairs i, j such that 1\r\nleq i < j\r\nleq n, and there exists an integer x such that a_i\r\ncdot a_j = x^k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(1e5)+10;\nconst ll INF=(1e10);\nint n,k,tot;\nll a[maxn],cnt[maxn],ans,b,d[maxn];\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(k);\n\tfor (int i=1;i<=n;i++) read(a[i]),cnt[a[i]]++;\n\tfor (int x=1;;x++) {\n\t\tll tmp=1;\n\t\tfor (int i=1;i<=k;i++) {\n\t\t\ttmp*=x;\n\t\t\tif (tmp>=maxn) break;\n\t\t}\n\t\tif (tmp>=maxn) break;\n\t\ttot=x; d[x]=tmp;\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tll z=2,tmp=a[i],y=1;\n\t\twhile (z*z<=tmp) {\n\t\t\tif (tmp%z==0) {\n\t\t\t\tb=0;\n\t\t\t\twhile (tmp%z==0) tmp/=z,b++;\n\t\t\t\tb=(k-b%k)%k;\n\t\t\t\twhile (b--) {\n\t\t\t\t\ty=y*z;\n\t\t\t\t\tif (y>=maxn) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y>=maxn) break;\n\t\t\tif (z==2) z=3; else z+=2;\n\t\t}\n\t\tif (y>=maxn) continue;\n\t\tif (tmp>1) {\n\t\t\tb=k-1;\n\t\t\twhile (b--) {\n\t\t\t\ty=y*tmp;\n\t\t\t\tif (y>=maxn) break;\n\t\t\t}\n\t\t}\n\t\tif (y>=maxn) continue;\n\t\t//printf(\"%lld %lld\\n\",a[i],y);\n\t\tfor (int x=1;x<=tot;x++) {\n\t\t\ttmp=y*d[x];\n\t\t\tif (tmp>=maxn) break;\n\t\t\tif (tmp==a[i]) ans+=cnt[tmp]-1;\n\t\t\telse ans+=cnt[tmp];\n\t\t}\n\t}\t\n\tprintf(\"%lld\\n\",ans/2);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Power Products.json",
    "editorial_link": "https://codeforces.com//blog/entry/70898",
    "editorial": "Suppose that x?y\n is a k\n-th power. The sufficient and necessary condition for that is: for any prime p\n, the total number of times it divides x\n and y\n must be divisible by k\n.\n\nLet us factorize each number ai=pb11\u0085pbmm\n, and associate the list of pairs Li((p1,b1modk),\u0085,(pm,bmmodk))\n, omitting the entries with bimodk=0\n. For example, for 360=232251\n and k=2\n, the corresponding list would be ((2,1),(5,1))\n.\n\nIf ai?aj\n is a k\n-th power the the primes in the respective lists should match, and bimodk\n add up to k\n for corresponding primes. Indeed, if a prime is absent from one of the lists (i.e. the exponent is divisible by k\n), then it should be absent from the other list too. Otherwise, the total exponent for this prime should be divisible by k\n, hence the remainders should add up to k\n.\n\nWe now have that for every ai\n there is a unique possible list L?i\n for the other number that would give a k\n-th power product. We can now maintain the count for each of the occuring lists (e.g. with std::map), and every number we meet we add the number of occurences of L?i\n to the answer, and increase the count for Li\n by one.\n\nThe total complexity comprises of factoring all the input numbers (in O(maxai??????)\n or in O(logmaxai)\n with precomputed sieve), and maintaining a map from vectors to numbers. The total size of all vectors is roughly O(nlogn)\n, so the complexity of maintaining a map is O(nlog2n)\n, or O(nlogn)\n with a hashmap."
}