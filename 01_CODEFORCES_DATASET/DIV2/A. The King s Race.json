{
    "link": "https://codeforces.com//contest/1075/problem/A",
    "problemId": "249092",
    "problem_idx": "A",
    "shortId": "1075A",
    "contest_number": "1075",
    "problem_submissions": {
        "E": [
            45299888,
            45297843,
            45298056,
            45296633,
            45301081,
            45300957,
            45302422,
            45302929,
            45304409,
            45302659,
            45300790,
            45303365,
            45303877,
            45302733
        ],
        "F": [
            45298415,
            45299656,
            45299363,
            45302076,
            45302275,
            45461749,
            45308311
        ],
        "D": [
            45294336,
            45295894,
            45295657,
            45296846,
            45300767,
            45296827,
            45297943,
            45298533,
            45298945,
            45296351,
            45298646,
            45300089,
            45299323,
            45303594,
            45300962,
            45300486,
            45300898
        ],
        "C": [
            45292132,
            45292865,
            45293959,
            45292758,
            45292492,
            45294033,
            45294912,
            45294846,
            45293224,
            45293567,
            45294312,
            45292544,
            45295364,
            45296384,
            45295997,
            45298611,
            45297798
        ],
        "B": [
            45290077,
            45290576,
            45289458,
            45290287,
            45290460,
            106466381,
            45291592,
            45291593,
            45291426,
            45290169,
            45291447,
            45291908,
            45290506,
            45291957,
            45290127,
            45292064,
            45294213,
            45290472
        ],
        "A": [
            45288469,
            45288515,
            45288420,
            45288453,
            45288440,
            45288973,
            45289044,
            45288964,
            45288524,
            45289234,
            45289586,
            45288591,
            45289499,
            45288557,
            45289581,
            45288705,
            45288541
        ]
    },
    "name": "A. The King s Race",
    "statement": "On a chessboard with a width of n and a height of n, rows are numbered\r\nfrom bottom to top from 1 to n, columns are numbered from left to right\r\nfrom 1 to n. Therefore, for each cell of the chessboard, you can assign\r\nthe coordinates (r,c), where r is the number of the row, and c is the\r\nnumber of the column.The white king has been sitting in a cell with\r\n(1,1) coordinates for a thousand years, while the black king has been\r\nsitting in a cell with (n,n) coordinates. They would have sat like that\r\nfurther, but suddenly a beautiful coin fell on the cell with coordinates\r\n(x,y)...Each of the monarchs wanted to get it, so they decided to\r\narrange a race according to slightly changed chess rules:As in chess,\r\nthe white king makes the first move, the black king makes the second\r\none, the white king makes the third one, and so on. However, in this\r\nproblem, .The player who reaches the coin first will win, that is to\r\nsay, the player who reaches the cell with the coordinates (x,y) first\r\nwill win.Let’s recall that the king is such a chess piece that can move\r\none cell in all directions, that is, if the king is in the (a,b) cell,\r\nthen in one move he can move from (a,b) to the cells (a + 1,b), (a -\r\n1,b), (a,b + 1), (a,b - 1), (a + 1,b - 1), (a + 1,b + 1), (a - 1,b - 1),\r\nor (a - 1,b + 1). Going outside of the field is prohibited.Determine the\r\ncolor of the king, who will reach the cell with the coordinates (x,y)\r\nfirst, if the white king moves first.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define szv(V) ((int)(V).size())\n#define allv(V) ((V).begin(), ((V).end()))\n#define sortv(V) sort(allv(V))\n#define uniquev(V) (V).erase(unique(allv(V)), (V).end())\n#define compv(V) sortv(V), uniquev(V)\n#define fs first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mod = 1e9 + 7;\nconst ll inf = 4e18 + 5;\n\nll gcd(ll x, ll y) { while (y) x %= y, swap(x, y); return x; }\npll operator+(pll a, pll b) { return pll(a.fs + b.fs, a.se + b.se); }\npll operator-(pll a, pll b) { return pll(a.fs - b.fs, a.se - b.se); }\nll operator*(pll a, pll b) { return a.fs * b.se - a.se * b.fs; }\ntemplate <class T> int sign(T x) { return x < 0 ? -1 : x > 0 ? 1 : 0; }\nint ccw(pll a, pll b, pll c) { return sign((b - a) * (c - b)); }\ntemplate <class T> void setmin(T &x, T y) { if (x > y) x = y; }\ntemplate <class T> void setmax(T &x, T y) { if (x < y) x = y; }\ntemplate <class T> void addval(T &x, T y) { x += y; x %= mod; }\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    ll n, x, y;\n    cin >> n >> x >> y;\n    ll d1 = max(x - 1, y - 1);\n    ll d2 = max(n - x, n - y);\n    if (d1 <= d2) cout << \"White\";\n    else cout << \"Black\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. The King s Race.json",
    "editorial_link": "https://codeforces.com/blog/entry/62985",
    "editorial": "Letâs find the minimum time needed for the white king to reach the\r\ncoin.It is obvious that it is always optimal to move only towards the\r\ncoin. In case of white king it means that we should move only up, right\r\nor up-right diagonally. During one move we can only add or to any of our\r\ncoordinates (or to both of them), it means that the length of the\r\noptimal path can not be smaller than .Letâs show that we can reach the\r\ncoin with moves.First step. Let be equal to . The king does up-right\r\nmoves, so after that the king will be in the cell . Second step. Letâs\r\nassume that (the case when is proved in a similar way). So . It means\r\nthat the king is in the cell . Now the king can do up moves, after which\r\nhe would be in the cell . It took him moves to reach the coin. If was\r\ngreater than he would need moves (could be proved the same way). So now\r\nwe proved that it takes moves for the white king to reach the coin.In\r\nthe same way we can prove that it takes steps for the black king to\r\nreach the coin.The king, which is closer to the coin, wins. If the\r\ndistances is equal, than the white king wins, because he moves\r\nfirst.Final description of the algorithm:If then the answer is \"\",\r\notherwise the answer is \"\".It is also can be proven that instead of\r\ncomparing minimal distances between the coin and the kings we can\r\ncompare manhattan distances between them. I will leave the proof as\r\nhomework task.\r\n",
    "hint": []
}