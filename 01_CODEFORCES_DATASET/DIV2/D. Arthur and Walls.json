{"link": "https://codeforces.com//contest/525/problem/D", "problemId": "25278", "problem_idx": "D", "shortId": "525D", "contest_number": "525", "problem_submissions": {"E": [10469529, 10465773, 10462320, 10473852, 10470314, 10468913, 10471407, 10472352, 10471463, 10468119, 10482016], "A": [10466492, 10459383, 10459851, 10468884, 10459356, 10464661, 10460865, 10459447, 10463645, 10460601, 10459420, 10459625, 10468470, 10464011, 10460662, 10460403, 10460186, 10460076, 10465668, 10459793], "D": [10466031, 10468890, 10468989, 10474860, 10468593, 10472101, 10470926, 10472770, 10473464, 10480430, 10472569, 10473468, 10468745, 10475146], "C": [10463905, 10462286, 10467821, 10468051, 10468445, 10463570, 10464786, 10471337, 10464431, 10462510, 10465576, 10466372, 10462777, 10467129, 10480410, 10469681, 10469099, 10467204], "B": [10459849, 10460170, 10461961, 10469584, 10459611, 10459522, 10463289, 10460886, 10459674, 10459690, 10460416, 10461920, 10462421, 10467148, 10463544, 10464761, 10465220, 10462234, 10464721, 10464494]}, "name": "D. Arthur and Walls", "statement": "Finally it is a day when Arthur has enough money for buying an\r\napartment. He found a great option close to the center of the city with\r\na nice price.Plan of the apartment found by Arthur looks like a\r\nrectangle consisting of squares of size . Each of those squares contains\r\neither a wall (such square is denoted by a symbol \"\" on the plan) or a\r\nfree space (such square is denoted on the plan by a symbol \"\").Room in\r\nan apartment is a maximal connected area consisting of free squares.\r\nSquares are considered adjacent if they share a common side.The old\r\nArthur dream is to live in an apartment where all rooms are rectangles.\r\nHe asks you to calculate minimum number of walls you need to remove in\r\norder to achieve this goal. After removing a wall from a square it\r\nbecomes a free square. While removing the walls it is possible that some\r\nrooms unite into a single one.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << \" = \" << ccc << endl;\n\n#define\tctrl( xx,yy )\t( xx>=1 and yy>=1 and xx<=m and yy<=n and s[xx][yy]=='.' )\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tm,n;\nchar\ts[3000][3000];\nchar\th[3000][3000];\n\nint\tbozuk( int x,int y ){\n\tif( s[x][y]!='*' )\treturn\t0;\n\tif( ctrl( x-1,y ) and ctrl( x-1,y+1 ) and ctrl( x,y+1 ) )\treturn\t1;\n\tif( ctrl( x,y+1 ) and ctrl( x+1,y+1 ) and ctrl( x+1,y ) )\treturn\t1;\n\tif( ctrl( x+1,y ) and ctrl( x+1,y-1 ) and ctrl( x,y-1 ) )\treturn\t1;\n\tif( ctrl( x,y-1 ) and ctrl( x-1,y-1 ) and ctrl( x-1,y ) )\treturn\t1;\n\treturn\t0;\n}\n\nint main(){\n\tcin >> m >> n;\n\tFP( i,1,m )\n\t\tscanf(\"%s\",s[i]+1);\n\tqueue< pair<int,int> >\tQ;\n\tFP( i,1,m )\n\t\tFP( j,1,n )\n\t\t\tif( bozuk( i,j ) )\tQ.push( mp(i,j) ),h[i][j]=1;\n\tint\tx,y,xx,yy;\n\twhile( Q.size() ){\n\t\tx = Q.front().st;\n\t\ty = Q.front().nd;\n\t\tQ.pop();\n\t\ts[x][y] = '.';\n\t\th[x][y] = 0;\n\t\tFP( i,-1,1 )\n\t\t\tFP( j,-1,1 ){\n\t\t\t\tif( !i and !j )\tcontinue;\n\t\t\t\txx = x+i;\n\t\t\t\tyy = y+j;\n\t\t\t\tif( xx<1 or xx>m or yy<1 or yy>n or h[xx][yy] or !bozuk( xx,yy ) )\tcontinue;\n\t\t\t\tQ.push( mp(xx,yy) ),h[xx][yy] = 1;\n\t\t\t\ts[xx][yy] = '.';\n\t\t\t}\n\t}\n\tFP( i,1,m )\n\t\tprintf(\"%s\\n\",s[i]+1);\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "graphs", "greedy", "shortest paths"], "dificulty": "2400", "interactive": false}