{
    "link": "https://codeforces.com//contest/432/problem/C",
    "problemId": "9480",
    "problem_idx": "C",
    "shortId": "432C",
    "contest_number": "432",
    "problem_submissions": {
        "E": [
            6629542,
            6629685,
            6787172,
            6630011,
            12011414
        ],
        "D": [
            6626923,
            6625069,
            6624242,
            6625615,
            6626784,
            6627500,
            6627213,
            6627749,
            6627433,
            6627095,
            6625919,
            6626790,
            6628329,
            6627888,
            6627861,
            6629346,
            6627908,
            6626789,
            6628335
        ],
        "C": [
            6625922,
            6627708,
            6628444,
            6625084,
            6625495,
            6625430,
            6626041,
            6625379,
            6626502,
            6627502,
            6628640,
            6628030,
            6625935,
            6625367,
            6626856,
            6633716,
            6626069,
            6624111,
            6627225,
            6629433,
            6627012
        ],
        "B": [
            6622630,
            6623369,
            6622464,
            6622520,
            6623124,
            6622829,
            6622983,
            6623645,
            6623780,
            6622660,
            6624201,
            6623167,
            6623125,
            6623134,
            6623267,
            6625795,
            6625412,
            6624139,
            6623117,
            6624747
        ],
        "A": [
            6621909,
            6622385,
            6621900,
            6621957,
            6622065,
            6621901,
            6621989,
            6622108,
            6622047,
            6623481,
            6622838,
            6622310,
            6621964,
            6622183,
            6624704,
            6623532,
            6624976,
            6622988,
            6621991,
            6621961
        ]
    },
    "name": "C. Prime Swaps",
    "statement": "You have an array , containing distinct integers from to . Your task is\r\nto sort this array in increasing order with the following operation (you\r\nmay need to apply it multiple times): choose two indexes, and (; is a\r\nprime number); swap the elements on positions and ; in other words, you\r\nare allowed to apply the following sequence of assignments: ( is a\r\ntemporary variable). You do not need to minimize the number of used\r\noperations. However, you need to make sure that there are at most\r\noperations.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nint a, b, c;\nint m[100001];\nint n[100001];\nint nom[100001];\nbool f[1000000];\nint pos[100001];\nvector<int> v;\nvector<pair<int, int> > ans;\n\nvoid swap_(int a, int b){\n    //cout << pos[a] << \"\\n\";\n    //cout << a << ' ' << b << \"\\n\";\n    if(a == b) return;\n    int l = 0; \n    int r = v.size();\n    while(l < r - 1){\n\tint cen = (l + r) / 2;\n\tif(v[cen] > (b - a + 1)) r = cen;\n\telse l = cen;\n    }\n    ans.push_back(make_pair(b - v[l] + 1, b));\n    //cout << \" << \" << b - v[l] + 1 << ' ' << b << \"\\n\";\n    swap(pos[m[b - v[l] + 1]], pos[a]);\n    swap(m[b - v[l] + 1], m[b]);\n    b -= v[l] - 1;\n    int tmp;\n   //cin >> tmp;\n    swap_(a, b);\n}\n\nint main(){\n    cin >> a;\n    f[0] = 1;\n    f[1] = 1;\n    for(int i = 2; i <= a; ++i){\n      if(f[i] == 0){\n\tv.push_back(i);\n\tfor(int q = i; q <= 100000; q += i)\n\t  f[q] = 1;\n      }\n    }\n    //for(int i = 0; i < v.size(); ++i)\n   //   cout << i << ' ' << v[i] << \"\\n\";\n    for(int i = 1; i <= a; ++i){\n      cin >> m[i];\n      pos[m[i]] = i;\n    }\n    for(int i = 1; i <= a; ++i)\n      swap_(i, pos[i]);\n    cout << ans.size() << \"\\n\";\n    for(int i = 0; i < ans.size(); ++i)\n      cout << ans[i].first << ' ' << ans[i].second << \"\\n\";\n  \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Prime Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/12310",
    "editorial": "The solution can be described by pseudo-code: Consider elements of permutation from  to  While current element  is not sutiated on position  Let the position of element  equals  Find maximum prime integer  which is less or equal than $pos   i + 1 Swap element in positions  and  It could be proved that such algorithm makes less than  swaps (for example, by implementing the algorithm) This algorithm should be implemented optimally. You should maintain positions of elements of permutation. Swap function in author's solution: "
}