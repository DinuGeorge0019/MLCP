{
    "link": "https://codeforces.com//contest/1372/problem/C",
    "problemId": "665584",
    "problem_idx": "C",
    "shortId": "1372C",
    "contest_number": "1372",
    "problem_submissions": {
        "F": [
            86587331,
            86592445
        ],
        "D": [
            86567204,
            86579473,
            86577327,
            86535735,
            86539756,
            86541547,
            86541810,
            86544261,
            86545902,
            86544858,
            86551552,
            86549456,
            86551379,
            86554398,
            86555103,
            86559228,
            86553301
        ],
        "C": [
            86542450,
            86550447,
            86544146,
            86549498,
            86526578,
            86530081,
            86532018,
            86527267,
            86533550,
            86528779,
            86532078,
            86534770,
            86530142,
            86536030,
            86548674,
            86533586,
            86533762,
            86528487,
            86532205
        ],
        "B": [
            86530649,
            86544843,
            86528066,
            86586370,
            86518220,
            86520050,
            86527028,
            86521440,
            86521451,
            86520560,
            86523901,
            86522899,
            86522046,
            86527358,
            86530942,
            86526972,
            86524542,
            86517410,
            86521410
        ],
        "A": [
            86513990,
            86538518,
            86515960,
            86516941,
            86513491,
            86515289,
            86513521,
            86514849,
            86514076,
            86513724,
            86514041,
            86514826,
            86513853,
            86514635,
            86523362,
            86514036,
            86514079,
            86513422,
            86513617
        ],
        "E": [
            86584231,
            86531273,
            86583888,
            86618428,
            86570603
        ]
    },
    "name": "C. Omkar and Baseball",
    "statement": "Patrick likes to play baseball, but sometimes he will spend so many\r\nhours hitting home runs that his mind starts to get foggy! Patrick is\r\nsure that his scores across n sessions follow the identity permutation\r\n(ie. in the first game he scores 1 point, in the second game he scores 2\r\npoints and so on). However, when he checks back to his record, he sees\r\nthat all the numbers are mixed up! Define a special exchange as the\r\nfollowing: choose any subarray of the scores and permute elements such\r\nthat no element of subarray gets to the same position as it was before\r\nthe exchange. For example, performing a special exchange on [1,2,3] can\r\nyield [3,1,2] but it cannot yield [3,2,1] since the 2 is in the same\r\nposition. Given a permutation of n integers, please help Patrick find\r\nthe minimum number of special exchanges needed to make the permutation\r\nsorted! It can be proved that under given constraints this number\r\ndoesn\u2019t exceed 10^{18}.An array a is a subarray of an array b if a can\r\nbe obtained from b by deletion of several (possibly, zero or all)\r\nelements from the beginning and several (possibly, zero or all) elements\r\nfrom the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef pair<int ,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double rl;\n\ntypedef pii int2;\ntypedef tuple<int, int, int>           int3;\ntypedef tuple<int, int, int, int>      int4;\ntypedef tuple<int, int, int, int, int> int5;\n\ntypedef pll ll2;\ntypedef tuple<ll, ll, ll>         ll3;\ntypedef tuple<ll, ll, ll, ll>     ll4;\ntypedef tuple<ll, ll, ll, ll, ll> ll5;\n\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vll_ll;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\ntypedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n\n#define FOR(i,N) for(int i=0; i<N; i++)\n\n#define popc __builtin_popcountll\n// #define popc __builtin_popcount\n\ntemplate<typename A>\nstring to_string(A* ptr)\n{\n    stringstream ss; ss << \"0x\" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr;\n    return ss.str();\n}\n\nstring to_string(char c)\n{\n    return ((string)\"'\"+c)+ \"'\";\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#if !ONLINE_JUDGE && 1\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\nconst int MX=2e5+99;\nint n, a[MX];\n\nll solve()\n{\n    //bool id=true;\n    //bool all_neq=true;\n\n    int cnt_neq=0;\n    int mn_neq=n+1, mx_neq=0;\n\n    for(int i=1; i<=n; i++)\n    {\n        if(a[i]!=i)\n        {\n            cnt_neq++;\n            mn_neq=min(mn_neq, i);\n            mx_neq=max(mx_neq, i);\n        }\n    }\n\n    if(cnt_neq==0) return 0;\n    if(mx_neq-mn_neq+1==cnt_neq)\n    {\n        return 1;\n    }\n    return 2;\n\n    //return -1;\n}\n\nint main()\n{\n#if !ONLINE_JUDGE && 1\n    freopen(\"C.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n#if 0\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n#endif\n\n    int TT;\n#if 1\n    cin >> TT;\n#else\n    TT=1;\n#endif\n    for(int ttt=0; ttt<TT; ttt++)\n    {\n        cin >> n;\n        for(int i=1; i<=n; i++) cin >> a[i];\n        cout << solve() << '\\n';\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Omkar and Baseball.json",
    "editorial_link": "https://codeforces.com//blog/entry/79974",
    "editorial": "You need at most special exchanges to sort the permutation. Obviously,\r\nspecial exchanges are needed if the array is already sorted. Let\u00e2\u0080\u0099s look\r\ninto cases in which you need special exchange to sort the array.Refer to\r\ni as a matching index if . If there are no matching indices, then you\r\ncan just use one special exchange to sort the entire thing. Otherwise,\r\nyou can use the location of matching indices to determine whether you\r\nneed more than special exchange. If all matching indices are located in\r\nsome prefix of the permutation, you can sort the permutation with one\r\nspecial exchange. The same is true for a suffix. In other words, if you\r\ncan choose a subarray in the permutation such that all elements\r\ncontained in the subarray are NOT matching and the elements outside of\r\nthis subarray are matching, then one special exchange is needed to sort\r\nthe array.Otherwise, you need special exchanges to sort the permutation.\r\nLet\u00e2\u0080\u0099s prove why you do not need more than special exchanges. You can\r\nquickly check that you need at most special exchanges for all\r\npermutations of length . For permutations of length , I claim that we\r\ncan perform special exchanges on the whole array; to show this it\r\nsuffices to construct a permutation that has no matching indices with\r\neither the given permutation or the identity permutation . We can do\r\nthis as follows:For simplicity, assume that is even. We will assign the\r\nnumbers to the first positions of our permutation and the numbers to the\r\nlast positions of . This ensures that has no matching indices with the\r\nidentity permutation. Then, for all integers such that their position in\r\n(i. e. the such that ) is in the appropriate half of , assign ; assign\r\nother to arbitrary positions in the appropriate half of . Finally,\r\ncyclically rotate each half of this ensures that has no matching indices\r\nwith .As an example, let\u00e2\u0080\u0099s take . You can quickly check that this cannot\r\nbe done in less than special exchanges. The construction of goes as\r\nfollows:First, we move all numbers to the proper half of , so that\r\n.Observing that and , we set and then replace the remaining elements\r\narbitrarily into the correct half, so we can get, for example, .Finally,\r\nwe cyclically rotate each half of , obtaining , which has no matching\r\nindexes with either or .This can be extended to odd by first choosing\r\nsome element other than and to be (this works for and we must have\r\nanyway in this case), and then running the same algorithm on the rest of\r\n.\r\n"
}