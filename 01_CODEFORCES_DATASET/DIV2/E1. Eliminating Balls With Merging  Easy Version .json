{
    "link": "https://codeforces.com//contest/1998/problem/E1",
    "problemId": "2808663",
    "problem_idx": "E1",
    "shortId": "1998E1",
    "contest_number": "1998",
    "problem_submissions": {
        "E2": [
            275597415,
            275585523,
            275585603,
            275624432,
            275607882,
            275614357,
            275595887,
            275619832,
            275623737,
            275625136,
            275600639,
            275623825,
            275627451,
            275623692,
            275628307,
            275623705,
            275626791,
            275625619,
            275628722,
            275612227
        ],
        "E1": [
            275597010,
            275587241,
            275585991,
            275593723,
            275608426,
            275614274,
            275560961,
            275612542,
            275602427,
            275605651,
            275567685,
            275618625,
            275609795,
            275605031,
            275592538,
            275623999,
            275627361,
            275625758,
            275620522,
            275607421
        ],
        "D": [
            275586064,
            275606706,
            275611517,
            275606418,
            275612571,
            275598942,
            275628023,
            275600312,
            275614869,
            275612903,
            275613506,
            275603714,
            275617537,
            275620550,
            275622209,
            275606375,
            275604352,
            275608175,
            275610636,
            275618730
        ],
        "C": [
            275572305,
            275570533,
            275637129,
            275635205,
            275624349,
            275572002,
            275579268,
            275577783,
            275618992,
            275588428,
            275579740,
            275597585,
            275619380,
            275587772,
            275578283,
            275590393,
            275603888,
            275598655,
            275576819,
            275599430,
            275594072,
            275589195
        ],
        "B": [
            275543162,
            275540617,
            275553706,
            275541326,
            275549095,
            275544297,
            275571979,
            275551098,
            275551147,
            275547296,
            275620850,
            275549937,
            275541075,
            275551747,
            275543184,
            275550406,
            275547364,
            275572048,
            275560766,
            275545023
        ],
        "A": [
            275538909,
            275538891,
            275539594,
            275538822,
            275542591,
            275539447,
            275539471,
            275541785,
            275545969,
            275543154,
            275621852,
            275552627,
            275538828,
            275539052,
            275540124,
            275543325,
            275540250,
            275542995,
            275540086
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132512",
    "editorial": "Notice that at any point all the elements are sum of continous subarray.\n\nHint 2\nDefine a function solve(L,R) which returns true, if we can convert element with weight ?AL+AL+1+....+AR\n into an element with weight ?A\n\nHint 3\nUse greedy, for fixed index L\n and R\n, find a minimum nxtL\n such that ?AnxtL+AnxtL+1+...+AL?1?AL+AL+1+....+AR\n, make a direct jump to nxtL,R\n segment.\n\nHint 4\nDo similar for nxtR\n, and memorise all the answer of solve function.",
    "name": "E1. Eliminating Balls With Merging  Easy Version ",
    "statement": "Sun Tzu, You are given two integers n and x (x=n). There are n balls\r\nlined up in a row, numbered from 1 to n from left to right. Initially,\r\nthere is a value a_i written on the i-th ball.For each integer i from 1\r\nto n, we define a function f(i) as follows: Suppose you have a set S =\r\n{1, 2,\r\nldots, i\r\n}. In each operation, you have to select an integer l (1\r\nleq l < i) from S such that l is not the largest element of S. Suppose r\r\nis the smallest element in S which is greater than l. If a_l > a_r, you\r\nset a_l = a_l + a_r and remove r from S. If a_l < a_r, you set a_r =\r\na_l + a_r and remove l from S. If a_l = a_r, you choose either the\r\ninteger l or r to remove from S: If you choose to remove l from S, you\r\nset a_r = a_l + a_r and remove l from S. If you choose to remove r from\r\nS, you set a_l = a_l + a_r and remove r from S. f(i) denotes the number\r\nof integers j (1\r\nle j\r\nle i) such that it is possible to obtain S =\r\n{j\r\n} after performing the above operations exactly i - 1 times. For each\r\ninteger i from x to n, you need to find f(i).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; #define int long long const int INF=0x3f3f3f3f3f3f3f3f;const int N=2e5+5; int lc[N], rc[N], stk[N], sum[N], a[N], n; struct Segment_Tree1{\tint L[N*4], R[N*4], add[N*4], Min[N*4], cnt[N*4], val[N]; \tSegment_Tree1()\t{\t\tmemset(L,0,sizeof(L));\t\tmemset(R,0,sizeof(R));\t\tmemset(add,0,sizeof(add));\t\tmemset(Min,0,sizeof(Min));\t\tmemset(cnt,0,sizeof(cnt));\t\tmemset(val,0,sizeof(val));\t} \tvoid pushup(int rt)\t{\t\tMin[rt]=min(Min[rt*2],Min[rt*2+1]);\t\tcnt[rt]=0;\t\tif(Min[rt]==Min[rt*2])\t\t\tcnt[rt] += cnt[rt*2];\t\tif(Min[rt]==Min[rt*2+1])\t\t\tcnt[rt] += cnt[rt*2+1];\t} \tvoid Add(int rt,int val)\t{\t\tadd[rt] += val;\t\tMin[rt] += val;\t} \tvoid pushdown(int rt)\t{\t\tif(add[rt])\t\t{\t\t\tAdd(rt*2,add[rt]);\t\t\tAdd(rt*2+1,add[rt]);\t\t\tadd[rt]=0;\t\t}\t} \tvoid update(int rt,int l,int r,int val)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t{\t\t\tAdd(rt,val);\t\t\treturn;\t\t} \t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l<=mid)\t\t\tupdate(rt*2,l,r,val);\t\tif(mid+1<=r)\t\t\tupdate(rt*2+1,l,r,val);\t\tpushup(rt);\t} \tpair<int,int> query(int rt,int l,int r)\t{\t\tif(l<=L[rt] && R[rt]<=r)\t\t\treturn make_pair(Min[rt],cnt[rt]); \t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(l>mid)\t\t\treturn query(rt*2+1,l,r);\t\tif(mid+1>r)\t\t\treturn query(rt*2,l,r); \t\tpair <int,int> L=query(rt*2,l,r);\t\tpair <int,int> R=query(rt*2+1,l,r);\t\tpair <int,int> ans=make_pair(min(L.first,R.first),0);\t\tif(L.first==ans.first)\t\t\tans.second += L.second; \t\tif(R.first==ans.first)\t\t\tans.second += R.second;\t\treturn ans;\t} \tint lstpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn 0; \t\tif(L[rt]==R[rt])\t\t\treturn L[rt]; \t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn lstpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn lstpos(rt*2+1,l,r,val); \t\tint rans=lstpos(rt*2+1,l,r,val);\t\tif(rans==0)\t\t\treturn lstpos(rt*2,l,r,val);\t\treturn rans;\t} \tint firpos(int rt,int l,int r,int val)\t{\t\tif(Min[rt]>=val)\t\t\treturn n+1; \t\tif(L[rt]==R[rt])\t\t\treturn L[rt]; \t\tpushdown(rt);\t\tint mid=(L[rt]+R[rt])/2;\t\tif(mid+1>r)\t\t\treturn firpos(rt*2,l,r,val);\t\tif(l>mid)\t\t\treturn firpos(rt*2+1,l,r,val); \t\tint lans=firpos(rt*2,l,r,val);\t\tif(lans==n+1)\t\t\treturn firpos(rt*2+1,l,r,val);\t\treturn lans;\t} \tvoid build(int rt,int l,int r)\t{\t\tL[rt]=l, R[rt]=r, add[rt]=0;\t\tif(l==r)\t\t{\t\t\tMin[rt]=val[l], cnt[rt]=1;\t\t\treturn;\t\t} \t\tint mid=(l+r)/2;\t\tbuild(rt*2,l,mid);\t\tbuild(rt*2+1,mid+1,r);\t\tpushup(rt);\t}}tr1, tr2, tr3; int L[N*35], R[N*35], indx;bool del[N*35]; struct Segment_Tree2{\tvector <int> vec[N*4]; \tvoid update(int rt,int l,int r,int ql,int qr,int val)\t{\t\tif(ql<=l && r<=qr)\t\t{\t\t\tvec[rt].push_back(val);\t\t\treturn;\t\t} \t\tint mid=(l+r)/2;\t\tif(ql<=mid)\t\t\tupdate(rt*2,l,mid,ql,qr,val);\t\tif(mid+1<=qr)\t\t\tupdate(rt*2+1,mid+1,r,ql,qr,val);\t} \tvoid query(int rt,int l,int r,int pos)\t{\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\tvec[rt].clear(); \t\tif(l==r)\t\t\treturn; \t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tquery(rt*2,l,mid,pos);\t\telse\t\t\tquery(rt*2+1,mid+1,r,pos);\t} \tvoid queryl(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(L[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec); \t\tif(l==r)\t\t\treturn; \t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryl(rt*2,l,mid,pos);\t\telse\t\t\tqueryl(rt*2+1,mid+1,r,pos);\t} \tvoid queryr(int rt,int l,int r,int pos)\t{\t\tvector <int> newvec;\t\tfor(auto x:vec[rt])\t\t\tif(!del[x])\t\t\t{\t\t\t\tif(R[x]==pos)\t\t\t\t\ttr1.update(1,L[x],R[x],-1), del[x]=true;\t\t\t\telse\t\t\t\t\tnewvec.push_back(x);\t\t\t}\t\tswap(vec[rt],newvec); \t\tif(l==r)\t\t\treturn; \t\tint mid=(l+r)/2;\t\tif(pos<=mid)\t\t\tqueryr(rt*2,l,mid,pos);\t\telse\t\t\tqueryr(rt*2+1,mid+1,r,pos);\t}}tr4; void dfs(int l,int r,int root){\tif(l>r)\t\treturn; \tif(sum[r]-sum[l-1]<a[l-1] && sum[r]-sum[l-1]<a[r+1])\t{\t\tindx++, L[indx]=l, R[indx]=r;\t\ttr4.update(1,1,n,l,r,indx);\t\ttr1.update(1,l,r,1);\t} \tdfs(l,root-1,lc[root]);\tdfs(root+1,r,rc[root]);} void build(){\ta[0]=a[n+1]=INF;\tint top=0, root=0;\tfor(int i=1;i<=n;i++)\t{\t\tstk[top+1]=0;\t\twhile(top && a[stk[top]]<=a[i])\t\t\ttop--; \t\tif(top)\t\t\trc[stk[top]]=i;\t\telse\t\t\troot=i; \t\tlc[i]=stk[top+1];\t\tstk[++top]=i;\t} \tdfs(1,n,root);} int c[N]; int query_sum(int x){\tint ans=0;\tfor(int i=x;i;i-=i&-i)\t\tans += c[i];\treturn ans;} void update_sum(int x,int y){\tfor(int i=x;i<=n;i+=i&-i)\t\tc[i] += y;} void work(){\tint x;\tcin >> n >> x;\tfor(int i=1;i<=indx;i++)\t\tL[i]=R[i]=del[i]=0;\tindx=0; \tfor(int i=0;i<=n;i++)\t\tc[i]=lc[i]=rc[i]=sum[i]=a[i]=stk[i]=0; \tfor(int i=0;i<=n*4;i++)\t\ttr4.vec[i].clear(); \tfor(int i=1;i<=n;i++)\t{\t\tscanf(\"%lld\",&a[i]);\t\tupdate_sum(i,a[i]);\t\tsum[i]=sum[i-1]+a[i];\t} \tfor(int i=1;i<=n;i++)\t{\t\ttr2.val[i]=sum[i-1]-a[i];\t\ttr3.val[i]=-a[i]-sum[i];\t} \ttr1.build(1,1,n), tr2.build(1,1,n), tr3.build(1,1,n);\tbuild(); \tfor(int i=x;i<=n;i++)\t{\t\tint l=1, r=i;\t\tif(l==r)\t\t{\t\t\tprintf(\"1\\n\");\t\t\tcontinue;\t\t} \t\tint pos1=tr2.lstpos(1,l+1,r,query_sum(l-1))-1;\t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,1); \t\tint pos2=tr3.firpos(1,l,r-1,-query_sum(r))+1;\t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,1); \t\tprintf(\"%lld\\n\",tr1.query(1,l,r).second); \t\tif(l<=pos1)\t\t\ttr1.update(1,l,pos1,-1); \t\tif(pos2<=r)\t\t\ttr1.update(1,pos2,r,-1);\t}} signed main(){\tint T;\tcin >> T;\twhile(T--)\t\twork();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Eliminating Balls With Merging  Easy Version .json",
    "hint": [
        "Hint 1 Notice that at any point all the elements are sum of continous subarray.",
        "Hint 2 Define a function solve(L,R) which returns true, if we can convert element with weight into an element with weight",
        "Hint 3 Use greedy, for fixed index and , find a minimum such that , make a direct jump to segment.",
        "Hint 4 Do similar for , and memorise all the answer of solve function."
    ]
}