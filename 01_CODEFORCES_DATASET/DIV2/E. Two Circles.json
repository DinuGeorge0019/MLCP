{"link": "https://codeforces.com//contest/363/problem/E", "problemId": "3956", "problem_idx": "E", "shortId": "363E", "contest_number": "363", "problem_submissions": {"A": [5091717, 5059128, 5058405, 5060702, 5058501, 5058437, 5058523, 5058870, 5058824, 5058569, 5058849, 5058835, 5058475, 5058869, 5058397, 5059373, 5059116, 5059730, 5058538], "D": [5062003, 5062111, 5062048, 5062488, 5062551, 5062600, 5061744, 5062900, 5063480, 5063361, 5063540, 5061475, 5063510, 5063001, 5063238, 5064967, 5063752, 5063544], "C": [5060575, 5060628, 5059863, 5060397, 5060617, 5061312, 5059999, 5062594, 5061103, 5061402, 5061178, 5064048, 5061146, 5061399, 5061242, 5061422, 5061398, 5061876], "B": [5059750, 5059183, 5058598, 5059033, 5058933, 5059248, 5059323, 5059565, 5059297, 5059605, 5059146, 5058928, 5059719, 5058972, 5059858, 5058459, 5059102, 5059528], "E": [5072598]}, "name": "E. Two Circles", "statement": "Let\u2019s assume that we are given an table filled by integers. We\u2019ll mark a\r\ncell in the -th row and -th column as . Thus, is the upper left cell of\r\nthe table and is the lower right cell. We\u2019ll assume that a circle of\r\nradius with the center in cell is a set of such cells that . We\u2019ll\r\nconsider only the circles that do not go beyond the limits of the table,\r\nthat is, for which and . A circle of radius 3 with the center at . Find\r\ntwo such non-intersecting circles of the given radius that the sum of\r\nnumbers in the cells that belong to these circles is maximum. Two\r\ncircles intersect if there is a cell that belongs to both circles. As\r\nthere can be more than one way to choose a pair of circles with the\r\nmaximum sum, we will also be interested in the number of such pairs.\r\nCalculate the number of unordered pairs of circles, for instance, a pair\r\nof circles of radius 2 with centers at and is the same pair as the pair\r\nof circles of radius 2 with centers at and .\r\n", "solutions": ["/*\n    Problem:\n    Algorithm:\n    Note:\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<string>\n#include<iomanip>\n#include<iostream>\n#include<cmath>\n#include<queue>\nusing namespace std;\n\n#define rep(i,x,y) for(i=x;i<=y;i++)\n#define _rep(i,x,y) for(i=x;i>=y;i--)\n#define CL(S,x) memset(S,x,sizeof(S))\n#define CP(S1,S2) memcpy(S1,S2,sizeof(S2))\n#define ALL(x,S) for(x=S.begin();x!=S.end();x++)\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define fi first\n#define se second\n#define upmin(x,y) x=min(x,y)\n#define upmax(x,y) x=max(x,y)\n\ntypedef long long ll;\ntypedef long double real;\nconst real eps=1e-5;\nvoid read(int&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x=-x;};\nchar getc(){char c;for(c=getchar();c<=32;c=getchar());return c;}\n\nconst int inf=1000000000;\nint n,m,r,i,j,k,l,d,p,g,h,xx,yy,ans;ll tot,ff;\nint a[510][510],s[510][510],sum[510][510],G[510][510];ll gg[510][510];\nint sx[510],sy[510],st[510];\n\nint gets(int i1,int i2,int j)\n{\n\tif(j>m)return 0;\n\t\n\tif(i1<1)i1=1;\n\tif(i2>n)i2=n;\n\treturn sum[i2][j]-sum[i1-1][j];\n}\n\nvoid pre(int x,int y)\n{\n\tint i1,j1,i2,h;\n\t\n\trep(i1,1,n)st[i1]=m;\n\t\n\trep(i1,1,n)\n\t{\n\t\trep(j1,1,m)if(sqr(i1-x)+sqr(j1-y)<=sqr(r))break;\n\t\t\n\t\t//if(j1<=m)\n\t\trep(i2,1,n)\n\t\tif(sqr(i1-i2)<=sqr(r))\n\t\t{\n\t\t\th=int(sqrt(sqr(r)-sqr(i1-i2)+eps));\n\t\t\tupmin(st[i2],j1-h-1);\n\t\t}\n\t}\n}\n\nint main()\n{\n    read(n);read(m);read(r);\n    rep(i,1,n)rep(j,1,m)read(a[i][j]);\n    \n    rep(i,1,n)rep(j,1,m)sum[i][j]=sum[i-1][j]+a[i][j];\n    \n    \n    CL(s,200);\n    rep(i,r+1,n-r)rep(j,r+1,m-r)\n    {\n\t\ts[i][j]=0;\n\t\trep(d,-r,r)if(j+d>=1&&j+d<=m)\n\t\t{\n\t\t\th=int(sqrt(sqr(r)-sqr(d)+eps));\n\t\t\ts[i][j]+=gets(i-h,i+h,j+d);\n\t\t}\n\t}\n\tCL(G,200);\n    rep(i,1,n)rep(j,1,m)\n    {\n\t\tG[i][j]=G[i][j-1];gg[i][j]=gg[i][j-1];\n\t\tif(s[i][j]>G[i][j])G[i][j]=s[i][j],gg[i][j]=1;\n\t\telse if(s[i][j]==G[i][j])gg[i][j]++;\n\t}\n    \n    \n    ans=-inf;\n    int best;\n    \nrep(i,r+1,n-r)\n{\n\tpre(i,r+1);\n\t\n    rep(j,r+1,m-r)\n    {\n\t\tbest=-inf;ff=0;bool mark;\n\t\trep(d,r+1,n-r)\n\t\t{\n\t\t\tint tmp;\n\t\t\tif(st[d]>=j)\n\t\t\t{\n\t\t\t\tif(d<i)tmp=j;else tmp=j-1;\n\t\t\t\t\n\t\t\t\tupmin(tmp,m-r);\n\t\t\t\tswap(st[d],tmp);mark=1;\n\t\t\t}\n\t\t\telse mark=0;\n\t\t\t\n\t\t\t\n\t\t\tif(st[d]>0)\n\t\t\tif(G[d][st[d]]>best)best=G[d][st[d]],ff=gg[d][st[d]];\n\t\t\telse if(G[d][st[d]]==best)ff+=gg[d][st[d]];\n\t\t\t\n\t\t\tif(mark)swap(st[d],tmp);\n\t\t\t\n\t\t}\n\t\trep(d,1,n)st[d]=min(m,st[d]+1);\n\t\t\n\t//\tprintf(\"%d %d:%d\\n\",i,j,ff);\n\t\tif(s[i][j]+best>ans)ans=s[i][j]+best,tot=ff;\n\t\telse if(s[i][j]+best==ans)tot+=ff;\n\t}\n}\n\t\n\tif(ans<0){printf(\"0 0\\n\");return 0;}\n    \n\tprintf(\"%d %I64d\\n\",ans,tot);\n\t\n    \n    scanf(\"\\n\");\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "implementation"], "dificulty": "2500", "interactive": false}