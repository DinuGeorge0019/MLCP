{
    "link": "https://codeforces.com//contest/137/problem/D",
    "problemId": "724",
    "problem_idx": "D",
    "shortId": "137D",
    "contest_number": "137",
    "problem_submissions": {
        "D": [
            960005,
            960083,
            960407,
            960822,
            960978,
            959728,
            959647,
            960244,
            961785,
            961204,
            960009,
            960173,
            960331,
            960318,
            961322,
            961503,
            960958,
            959450,
            961108
        ],
        "E": [
            959375,
            960769,
            959788,
            959842,
            960438,
            960606,
            961308,
            961259,
            960542,
            960298,
            961524,
            961740,
            961358,
            961405,
            960518,
            960604,
            961543,
            962797,
            961827
        ],
        "A": [
            958154,
            958315,
            957467,
            957359,
            957636,
            957482,
            957504,
            957682,
            957763,
            958206,
            957614,
            957505,
            957814,
            957699,
            957800,
            958834,
            957616,
            957354,
            958655
        ],
        "B": [
            957805,
            957908,
            957895,
            957576,
            958020,
            957753,
            957706,
            958045,
            958039,
            958890,
            957997,
            957845,
            958326,
            958171,
            958572,
            959109,
            958403,
            957499,
            958442
        ],
        "C": [
            957396,
            957611,
            958395,
            958193,
            958567,
            958319,
            958191,
            958994,
            962691,
            962687,
            958717,
            959395,
            958900,
            958213,
            959117,
            959359,
            959315,
            960063,
            959720,
            957783,
            958064
        ]
    },
    "name": "D. Palindromes",
    "statement": "Friday is Polycarpus’ favourite day of the week. Not because it is\r\nfollowed by the weekend, but because the lessons on Friday are 2 IT\r\nlessons, 2 math lessons and 2 literature lessons. Of course, Polycarpus\r\nhas prepared to all of them, unlike his buddy Innocentius. Innocentius\r\nspent all evening playing his favourite game Fur2 and didn’t have enough\r\ntime to do the literature task. As Innocentius didn’t want to get an F,\r\nhe decided to do the task and read the book called \"Storm and Calm\"\r\nduring the IT and Math lessons (he never used to have problems with\r\nthese subjects). When the IT teacher Mr. Watkins saw this, he decided to\r\ngive Innocentius another task so that the boy concentrated more on the\r\nlesson and less on the staff that has nothing to do with IT. Mr. Watkins\r\nsaid that a palindrome is a string that can be read the same way in\r\neither direction, from the left to the right and from the right to the\r\nleft. A concatenation of strings , is a string that results from\r\nconsecutive adding of string to string . Of course, Innocentius knew it\r\nall but the task was much harder than he could have imagined. Mr.\r\nWatkins asked change in the \"Storm and Calm\" the minimum number of\r\ncharacters so that the text of the book would also be a concatenation of\r\nno more than palindromes. Innocentius can’t complete the task and\r\ntherefore asks you to help him.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nchar s[505];\nint dp[505][505];\nint pt[505][505];\nint xy[505][505];\n\nvoid output(int n, int m){\n    if(!m) return;\n    output(pt[n][m],m-1);\n    if(pt[n][m]) putchar('+');\n    int x=pt[n][m]+1,y=n;\n    for(int i=x;i<=y;i++) putchar(i<=y-i+x?s[i]:s[y-i+x]);\n}\n\nint main(){\n    int n=strlen(gets(s+1)),m;\n    scanf(\"%d\",&m);\n    memset(dp,63,sizeof(dp));\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++) for(int j=i;j<=n;j++){\n        for(int k=i;k<=j;k++) if(s[k]!=s[j-k+i]) xy[i][j]++;\n        xy[i][j]/=2;\n    }\n    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\n        for(int k=0;k<i;k++){\n            int tmp=dp[k][j-1]+xy[k+1][i];\n            if(tmp<dp[i][j]){\n                dp[i][j]=tmp;\n                pt[i][j]=k;\n            }\n        }\n    }\n    m=min_element(dp[n],dp[n]+m+1)-dp[n];\n    printf(\"%d\\n\",dp[n][m]);\n    output(n,m);puts(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Palindromes.json",
    "editorial_link": "https://codeforces.com//blog/entry/3318",
    "editorial": "Letâs preprocess array cnt[i][j] - the minimal number of changes tha we\r\nmust do to make substring from position i to j palindrom. We can easy\r\ncalc cnt[i][j] with complexity O(n^3). Now we can calculate dynamic\r\nprogramming z[i][j] - minimal number of changes that we can do to split\r\nprefix of length i into j palindromes. In begining we must assign\r\nz[i][j] = infinity for all (i, j) and assign z[0][0] = 0. If we want to\r\nmake updates from state (i, j) we must fix the length of j-th\r\npalindrom - len. We can update z[i + len][j + 1] by value z[i][j] +\r\ncnt[i][i + len - 1]. Answer to the problem is the min(z[n][i]), where n\r\nis the length of string and i from range [1, k]. The complexity is\r\nO(n^3).\r\n",
    "hint": []
}