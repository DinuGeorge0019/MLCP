{
    "link": "https://codeforces.com//contest/2024/problem/C",
    "problemId": "2964358",
    "problem_idx": "C",
    "shortId": "2024C",
    "contest_number": "2024",
    "problem_submissions": {
        "F": [
            287015023,
            287169223,
            287373673,
            287215917,
            287215736,
            287211292,
            287210539
        ],
        "D": [
            286987175,
            286931903,
            286960958,
            286961825,
            286971656,
            286929566,
            286931351,
            286932695,
            286932954,
            286934298,
            286931628,
            286927969,
            286932481,
            286936758,
            286930518,
            286960977,
            286959072,
            286943034,
            286936933
        ],
        "B": [
            286981623,
            286914966,
            286919282,
            286915114,
            286921371,
            286905134,
            286915552,
            286914323,
            286916482,
            286915957,
            286912577,
            286914600,
            286917409,
            286917069,
            286960523,
            286915841,
            286912540,
            286913505,
            286928405,
            286917057
        ],
        "E": [
            286971252,
            287005601,
            287014904,
            287015860,
            287015861,
            287172897,
            287179171,
            286984012
        ],
        "A": [
            286921784,
            286907603,
            286905627,
            286906243,
            286909098,
            286912198,
            286906985,
            286905683,
            286907292,
            286909521,
            286906250,
            286906979,
            286905397,
            286905452,
            286905213,
            286906731,
            286905626,
            286906240,
            286907336,
            286905986
        ],
        "C": [
            286916369,
            286924618,
            286933885,
            286931704,
            286933058,
            286906288,
            286921833,
            286923843,
            286925202,
            286923774,
            286923641,
            286921029,
            286922676,
            286924091,
            286919391,
            286920408,
            286922209,
            286923637,
            286916167,
            286927200
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Let's sort the arrays in order of non-decreasing sum of elements. It turns out that it is always optimal to concatenate the arrays in this order.\n\nTo prove this, let's consider some optimal answer. Note that if in the final order there are two adjacent arrays, such that the sum of the elements of the left array is greater than the sum of the elements of the right array, then we can swap them, and the number of inversions will not increase. Thus, we can bring any optimal answer to ours by swapping adjacent arrays so that the number of inversions does not increase each time. Thus, such an order is truly optimal.",
    "name": "C. Concatenation of Arrays",
    "statement": "You are given n arrays a_1,\r\nldots, a_n. The length of each array is two. Thus, a_i = [a_{i, 1},\r\na_{i, 2}]. You need to concatenate the arrays into a single array of\r\nlength 2n such that the number of inversions^{\r\ndagger} in the resulting array is minimized. Note that you to count the\r\nactual number of inversions.More formally, you need to choose a\r\npermutation^{\r\nddagger} p of length n, so that the array b = [a_{p_1,1}, a_{p_1,2},\r\na_{p_2, 1}, a_{p_2, 2},\r\nldots, a_{p_n,1}, a_{p_n,2}] contains as few inversions as possible.^{\r\ndagger}The number of inversions in an array c is the number of pairs of\r\nindices i and j such that i < j and c_i > c_j.^{\r\nddagger}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0typedef long long int ll;const ll FOD = 998244353;typedef pair<ll, ll> P;using ull = unsigned long long;template <class T> using V = vector<T>;template <class T> using VV = V<V<T>>;\u00a0\u00a0template <ll MD> struct ModInt {    using M = ModInt;    const static M G;    ll v;    ModInt(ll _v = 0) { set_v(_v % MD + MD); }    M& set_v(ll _v) {        v = (_v < MD) ? _v : _v - MD;        return *this;    }    explicit operator bool() const { return v != 0; }    M operator-() const { return M() - *this; }    M operator+(const M& r) const { return M().set_v(v + r.v); }    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }    M operator*(const M& r) const { return M().set_v(ll(v) * r.v % MD); }    M operator/(const M& r) const { return *this * r.inv(); }    M& operator+=(const M& r) { return *this = *this + r; }    M& operator-=(const M& r) { return *this = *this - r; }    M& operator*=(const M& r) { return *this = *this * r; }    M& operator/=(const M& r) { return *this = *this / r; }    bool operator==(const M& r) const { return v == r.v; }    M pow(ll n) const {        M x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    M inv() const { return pow(MD - 2); }    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }};using Mint = ModInt<998244353>;template<> const Mint Mint::G = Mint(3);\u00a0template <class Mint> void nft(bool type, V<Mint>& a) {    int n = int(a.size()), s = 0;    while ((1 << s) < n) s++;    assert(1 << s == n);\u00a0    static V<Mint> ep, iep;    while (int(ep.size()) <= s) {        ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));        iep.push_back(ep.back().inv());    }    V<Mint> b(n);    for (int i = 1; i <= s; i++) {        int w = 1 << (s - i);        Mint base = type ? iep[i] : ep[i], now = 1;        for (int y = 0; y < n / 2; y += w) {            for (int x = 0; x < w; x++) {                auto l = a[y << 1 | x];                auto r = now * a[y << 1 | x | w];                b[y | x] = l + r;                b[y | x | n >> 1] = l - r;            }            now *= base;        }        swap(a, b);    }}\u00a0template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {    int n = int(a.size()), m = int(b.size());    if (!n || !m) return {};    int lg = 0;    while ((1 << lg) < n + m - 1) lg++;    int z = 1 << lg;    auto a2 = a, b2 = b;    a2.resize(z);    b2.resize(z);    nft(false, a2);    nft(false, b2);    for (int i = 0; i < z; i++) a2[i] *= b2[i];    nft(true, a2);    a2.resize(n + m - 1);    Mint iz = Mint(z).inv();    for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;    return a2;}\u00a0ll n, m, k, q, h, w;\u00a0vector<ll> a, b;\u00a0vector<ll> qs[200'009];ll qi = 0;ll sz = 0;\u00a0Mint mod_pow (Mint l, ll r) {\tif (r == 0) return 1;\u00a0\treturn mod_pow((l * l), r/2) * ((r%2) ? l : 1);}Mint mod_inv (Mint x) {\treturn mod_pow(x, FOD-2);}\u00a0void solve () {\tvector<P> vec(n);\tfor (ll i = 0; i < n; i++) {\t\tvec[i] = {a[i] + b[i], i};\t}\tsort(vec.begin(), vec.end());\u00a0\tfor (ll i = 0; i < n; i++) {\t\tll v = vec[i].second;\u00a0\t\tif (i) cout << \" \";\t\tcout << a[v] << \" \" << b[v];\t}\tcout << \"\\n\";}\u00a0int main (void) {\tcin >> q;\twhile (q--) {\t\tcin >> n;\u00a0\t\ta.resize(n);\t\tb.resize(n);\t\tfor (ll i = 0; i < n; i++) {\t\t\tcin >> a[i] >> b[i];\t\t}\u00a0\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Concatenation of Arrays.json"
}