{"link": "https://codeforces.com//contest/967/problem/E", "problemId": "179485", "problem_idx": "E", "shortId": "967E", "contest_number": "967", "problem_submissions": {"F": [37724740, 37785350], "D": [37715859, 37718485, 37714997, 37714910, 37721057, 37715196, 37718252, 37721060, 37725740, 37722409, 37721493, 37718542, 37720902, 37723570, 37717977, 37722095, 37718943, 37720444, 37720943, 37717804], "C": [37713201, 37714275, 37715739, 37715714, 37735586, 37715171, 37716355, 37717661, 37717233, 37716160, 37725218, 37716853, 37715198, 37728018, 37717261, 37727878, 37722084, 37716869, 37714314], "B": [37710580, 37710295, 37709555, 37710161, 37717401, 37713108, 37711288, 37712382, 37711143, 37713098, 37711452, 37711212, 37711591, 37710867, 37709639, 37712905, 37712898, 37710688, 37712013, 37710071], "A": [37709201, 37709088, 37708901, 37710764, 37709412, 37710987, 37735764, 37709724, 37709576, 37710227, 37709634, 37709699, 37709830, 37709320, 37917335, 37710605, 37727121, 37709146, 37708986], "E": [37722960, 37719908, 37746295, 37728001, 37723621, 37714048, 37723133, 37726145, 37721957, 37725590, 37727533, 37724467, 37727640, 37727967, 37722685, 37746402, 37724717, 37727899, 37780807]}, "name": "E. Big Secret", "statement": "Vitya has learned that the answer for The Ultimate Question of Life, the\r\nUniverse, and Everything is not the integer 42, but an increasing\r\ninteger sequence a_1,\r\nldots, a_n. In order to not reveal the secret earlier than needed, Vitya\r\nencrypted the answer and obtained the sequence b_1,\r\nldots, b_n using the following rules: b_1 = a_1; b_i = a_i\r\noplus a_{i - 1} for all i from 2 to n, where x\r\noplus y is the bitwise XOR of x and y. It is easy to see that the\r\noriginal sequence can be obtained using the rule a_i = b_1\r\noplus\r\nldots\r\noplus b_i.However, some time later Vitya discovered that the integers\r\nb_i in the cypher got shuffled, and it can happen that when decrypted\r\nusing the rule mentioned above, it can produce a sequence that is not\r\nincreasing. In order to save his reputation in the scientific community,\r\nVasya decided to find some permutation of integers b_i so that the\r\nsequence a_i = b_1\r\noplus\r\nldots\r\noplus b_i is strictly increasing. Help him find such a permutation or\r\ndetermine that it is impossible.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define PB push_back\n#define LL long long\n#define REP(i, x) for( int i = 0; i < x; i++ )\n#define FOR(i, x) for( int i = 1; i <=x; i++ )\n#define FORALL(it, x) for(__typeof(x.begin()) it = x.begin(); it != x.end(); it++ )\n#define BACK(i, x) for( int i = x-1; i >= 0; i-- )\n\nint n;\n\ntypedef vector<long long> VI;\n\nVI worki[61];\nVI wszystkie;\n\nVI perm;\nVI nowy;\n\nvoid wczytaj(){\n    cin >> n;\n    REP(i, n){\n        LL a;\n        cin >> a;\n        wszystkie.PB(a);\n    }\n}\n\ninline LL pow(int k){\n    LL a = 1;\n    a <<= k;\n    return a;\n}\n\nvoid posegreguj(){\n    BACK(i, 60) FORALL(it, wszystkie)\n        if( *it >= pow(i) ){\n            worki[i].PB(*it);\n            *it = -1;\n        }\n}\n\nbool znajdz_perma(){\n    BACK(i, 60){\n        //cout << i << endl;\n        bool akt = 0;\n        nowy.clear();\n        int j = 0;\n        int s = perm.size();\n        FORALL(it, worki[i]){\n            while( akt && j < s ){\n                nowy.PB(perm[j]);\n                if( perm[j] & pow(i) ) akt = 0;\n                j++;\n            }\n            if( akt == 0 ){\n                nowy.PB(*it);\n                akt = 1;\n            }\n            else return 0;\n        }\n        while( j < s ) nowy.PB(perm[j++]);\n        perm.clear();\n        FORALL(it, nowy) perm.PB(*it);\n        //FORALL(it, perm) cout << *it << \" \"; cout << endl;\n    }\n    return 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    wczytaj();\n    posegreguj();\n    if( znajdz_perma() ){\n        cout << \"Yes\\n\";\n        FORALL(it, perm) cout << *it << \" \";\n        cout << endl;\n    }\n    else cout << \"No\\n\";\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "2200", "interactive": false}