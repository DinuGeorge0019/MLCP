{
    "link": "https://codeforces.com//contest/967/problem/E",
    "problemId": "179485",
    "problem_idx": "E",
    "shortId": "967E",
    "contest_number": "967",
    "problem_submissions": {
        "F": [
            37724740,
            37785350
        ],
        "D": [
            37715859,
            37718485,
            37714997,
            37714910,
            37721057,
            37715196,
            37718252,
            37721060,
            37725740,
            37722409,
            37721493,
            37718542,
            37720902,
            37723570,
            37717977,
            37722095,
            37718943,
            37720444,
            37720943,
            37717804
        ],
        "C": [
            37713201,
            37714275,
            37715739,
            37715714,
            37735586,
            37715171,
            37716355,
            37717661,
            37717233,
            37716160,
            37725218,
            37716853,
            37715198,
            37728018,
            37717261,
            37727878,
            37722084,
            37716869,
            37714314
        ],
        "B": [
            37710580,
            37710295,
            37709555,
            37710161,
            37717401,
            37713108,
            37711288,
            37712382,
            37711143,
            37713098,
            37711452,
            37711212,
            37711591,
            37710867,
            37709639,
            37712905,
            37712898,
            37710688,
            37712013,
            37710071
        ],
        "A": [
            37709201,
            37709088,
            37708901,
            37710764,
            37709412,
            37710987,
            37735764,
            37709724,
            37709576,
            37710227,
            37709634,
            37709699,
            37709830,
            37709320,
            37917335,
            37710605,
            37727121,
            37709146,
            37708986
        ],
        "E": [
            37722960,
            37719908,
            37746295,
            37728001,
            37723621,
            37714048,
            37723133,
            37726145,
            37721957,
            37725590,
            37727533,
            37724467,
            37727640,
            37727967,
            37722685,
            37746402,
            37724717,
            37727899,
            37780807
        ]
    },
    "name": "E. Big Secret",
    "statement": "Vitya has learned that the answer for The Ultimate Question of Life, the\r\nUniverse, and Everything is not the integer 42, but an increasing\r\ninteger sequence a_1,\r\nldots, a_n. In order to not reveal the secret earlier than needed, Vitya\r\nencrypted the answer and obtained the sequence b_1,\r\nldots, b_n using the following rules: b_1 = a_1; b_i = a_i\r\noplus a_{i - 1} for all i from 2 to n, where x\r\noplus y is the bitwise XOR of x and y. It is easy to see that the\r\noriginal sequence can be obtained using the rule a_i = b_1\r\noplus\r\nldots\r\noplus b_i.However, some time later Vitya discovered that the integers\r\nb_i in the cypher got shuffled, and it can happen that when decrypted\r\nusing the rule mentioned above, it can produce a sequence that is not\r\nincreasing. In order to save his reputation in the scientific community,\r\nVasya decided to find some permutation of integers b_i so that the\r\nsequence a_i = b_1\r\noplus\r\nldots\r\noplus b_i is strictly increasing. Help him find such a permutation or\r\ndetermine that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define PB push_back\n#define LL long long\n#define REP(i, x) for( int i = 0; i < x; i++ )\n#define FOR(i, x) for( int i = 1; i <=x; i++ )\n#define FORALL(it, x) for(__typeof(x.begin()) it = x.begin(); it != x.end(); it++ )\n#define BACK(i, x) for( int i = x-1; i >= 0; i-- )\n\nint n;\n\ntypedef vector<long long> VI;\n\nVI worki[61];\nVI wszystkie;\n\nVI perm;\nVI nowy;\n\nvoid wczytaj(){\n    cin >> n;\n    REP(i, n){\n        LL a;\n        cin >> a;\n        wszystkie.PB(a);\n    }\n}\n\ninline LL pow(int k){\n    LL a = 1;\n    a <<= k;\n    return a;\n}\n\nvoid posegreguj(){\n    BACK(i, 60) FORALL(it, wszystkie)\n        if( *it >= pow(i) ){\n            worki[i].PB(*it);\n            *it = -1;\n        }\n}\n\nbool znajdz_perma(){\n    BACK(i, 60){\n        //cout << i << endl;\n        bool akt = 0;\n        nowy.clear();\n        int j = 0;\n        int s = perm.size();\n        FORALL(it, worki[i]){\n            while( akt && j < s ){\n                nowy.PB(perm[j]);\n                if( perm[j] & pow(i) ) akt = 0;\n                j++;\n            }\n            if( akt == 0 ){\n                nowy.PB(*it);\n                akt = 1;\n            }\n            else return 0;\n        }\n        while( j < s ) nowy.PB(perm[j++]);\n        perm.clear();\n        FORALL(it, nowy) perm.PB(*it);\n        //FORALL(it, perm) cout << *it << \" \"; cout << endl;\n    }\n    return 1;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    wczytaj();\n    posegreguj();\n    if( znajdz_perma() ){\n        cout << \"Yes\\n\";\n        FORALL(it, perm) cout << *it << \" \";\n        cout << endl;\n    }\n    else cout << \"No\\n\";\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Big Secret.json",
    "editorial_link": "https://codeforces.com//blog/entry/59173",
    "editorial": "Let's assume that we've found a suitable permutation of all numbers, except all occurences of the number 1\n. When can we insert the 1\n's so that the new arrangement of numbers is again good? We can see that the XOR of all numbers before any occurence of the number 1\n must be even, so there should an even number of odd numbers before it.\n\nSuppose that there are x\n 1\n's in the input, and y\n odd numbers greater than 1\n. If x>y+1\n, then in any arrangement there is going to be a pair of 1\n's such that there are no odd numbers between them, hence the condition above cannot hold for both of them simultaneously. On the other hand, if x?y+1\n, then it is possible to insert the 1\n's into any permutation of greater numbers. Indeed, we can place one instance of 1\n at the start, and then place remaining 1\n's immediately after greater odd numbers.\n\nNote that this argument works just as well if we consider numbers in the range [2k,2k+1)\n as \"1\n's\", and numbers in [2k+1,?)\n as \"numbers greater than 1\n\". Note further that it doesn't matter how exactly we insert the \"1\n's\" since number of available gaps doesn't depend on that. Hence, we can go as follows: group the numbers by their leading bits. Make an empty list for the answer, and process the numbers in groups by decreasing of their leading bits. Suppose there are x\n numbers with leading bit k\n, and y\n greater numbers that have 1\n in the k\n-th bit. If x>y+1\n, then there is no answer. Otherwise, insert the numbers from the current group as described above.\n\nThe complexity of this solution is O(nlogA)\n, where A\n is the largest value among the numbers in the input.",
    "hint": []
}