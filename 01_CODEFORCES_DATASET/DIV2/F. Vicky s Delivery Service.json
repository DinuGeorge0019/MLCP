{
    "link": "https://codeforces.com//contest/1166/problem/F",
    "problemId": "345557",
    "problem_idx": "F",
    "shortId": "1166F",
    "contest_number": "1166",
    "problem_submissions": {
        "F": [
            54316652,
            54307224,
            54305584,
            54310646,
            54378086,
            54313232,
            54308575
        ],
        "E": [
            54298891,
            54300156,
            54304094,
            54294518,
            54300338,
            54303194,
            54301468,
            54302857,
            54297877,
            54295582,
            54302504,
            54299216,
            54297435,
            54297855,
            54304772,
            54304820,
            54295745,
            54296534
        ],
        "D": [
            54296262,
            54291838,
            54301051,
            54302058,
            54297357,
            54294897,
            54294795,
            54298322,
            54305898,
            54305908,
            54298392,
            54300155,
            54304713,
            54305703,
            54307005,
            54301062,
            54300346,
            54307391,
            54309804
        ],
        "C": [
            54289104,
            54297291,
            54291974,
            54290534,
            54287551,
            54289613,
            54287736,
            54292153,
            54290078,
            54292325,
            54290260,
            54291592,
            54291908,
            54293597,
            54292202,
            54290296,
            54292002,
            54299709,
            54289976
        ],
        "B": [
            54286717,
            54295090,
            54286733,
            54287427,
            54290240,
            54285781,
            54285576,
            54288042,
            54287483,
            54286749,
            54287663,
            54286685,
            54286479,
            54286327,
            54288426,
            54286838,
            54288503,
            54286890,
            54287732
        ],
        "A": [
            54284453,
            54292968,
            54284797,
            54284966,
            54291534,
            54284478,
            54284450,
            54284940,
            54284548,
            54284402,
            54284377,
            54284696,
            54284645,
            54284386,
            54285929,
            54284902,
            54285432,
            54284438,
            54284725
        ]
    },
    "name": "F. Vicky s Delivery Service",
    "statement": "In a magical land there are n cities conveniently numbered 1, 2,\r\ndots, n. Some pairs of these cities are connected by magical colored\r\nroads. Magic is unstable, so at any time, new roads may appear between\r\ntwo cities.Vicky the witch has been tasked with performing deliveries\r\nbetween some pairs of cities. However, Vicky is a beginner, so she can\r\nonly complete a delivery if she can move from her starting city to her\r\ndestination city through a . A double rainbow is a sequence of cities\r\nc_1, c_2,\r\ndots, c_k satisfying the following properties: For each i with 1\r\nle i\r\nle k - 1, the cities c_i and c_{i + 1} are connected by a road. For each\r\ni with 1\r\nle i\r\nle\r\nfrac{k - 1}{2}, the roads connecting c_{2i} with c_{2i - 1} and c_{2i +\r\n1} have the same color. For example if k = 5, the road between c_1 and\r\nc_2 must be the same color as the road between c_2 and c_3, and the road\r\nbetween c_3 and c_4 must be the same color as the road between c_4 and\r\nc_5.Vicky has a list of events in chronological order, where each event\r\nis either a delivery she must perform, or appearance of a new road. Help\r\nher determine which of her deliveries she will be able to complete.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n\nint n, m, c, q; vector<int> DSUpar, DSUsize;\nvector<map<int, int>> adj;\nvector<set<int>> neighbors;\n\nint DSUfind(int x) {\n\twhile (DSUpar[x] != -1) x = DSUpar[x];\n\treturn x;\n}\n\nvoid DSUmerge(int x, int y) {\n\tx = DSUfind(x); y = DSUfind(y);\n\tif (x == y) return;\n\tif (DSUsize[x] < DSUsize[y]) swap(x, y);\n\tDSUsize[x] += DSUsize[y]; DSUpar[y] = x;\n\tfor (auto it=neighbors[y].begin(); it!=neighbors[y].end(); it++) {\n\t\tneighbors[x].insert(*it);\n\t}\n}\n\nvoid Input() {\n\tcin >> n >> m >> c >> q; adj.resize(n); neighbors.resize(n);\n\tDSUpar.resize(n, -1); DSUsize.resize(n, +1);\n\twhile (m--) {\n\t\tint x, y, z; cin >> x >> y >> z; x--; y--;\n\t\tneighbors[DSUfind(x)].insert(y); neighbors[DSUfind(y)].insert(x);\n\t\tif (adj[x].find(z) != adj[x].end()) DSUmerge(y, adj[x][z]); else adj[x][z] = y;\n\t\tif (adj[y].find(z) != adj[y].end()) DSUmerge(x, adj[y][z]); else adj[y][z] = x;\n\t}\n}\n\nvoid Solve() {\n\twhile (q--) {\n\t\tchar cmd; int x, y; cin >> cmd >> x >> y; x--; y--;\n\t\tif (cmd == '+') {\n\t\t\tint z; cin >> z;\n\t\t\tneighbors[DSUfind(x)].insert(y); neighbors[DSUfind(y)].insert(x);\n\t\t\tif (adj[x].find(z) != adj[x].end()) DSUmerge(y, adj[x][z]); else adj[x][z] = y;\n\t\t\tif (adj[y].find(z) != adj[y].end()) DSUmerge(x, adj[y][z]); else adj[y][z] = x;\n\t\t}\n\t\telse if (cmd == '?') {\n\t\t\tif (DSUfind(x) == DSUfind(y)) cout << \"Yes\\n\";\n\t\t\telse if (neighbors[DSUfind(x)].find(y) != neighbors[DSUfind(x)].end()) cout << \"Yes\\n\";\n\t\t\telse cout << \"No\\n\";\n\t\t}\n\t}\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs",
        "hashing"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Vicky s Delivery Service.json",
    "editorial_link": "https://codeforces.com//blog/entry/67081",
    "editorial": "Let be the graph with cities as vertices and roads as edges. Note that\r\nthe edges originally in can be regarded as queries of the \"add edge\"\r\ntype, so we will just describe a solution that can handle queries of any\r\ntype.We need a way to capture the idea of going through two roads of the\r\nsame color in a row. To do this, consider a graph with the same vertices\r\nas , in which vertices and are connected by an edge if and are edges of\r\nthe same color for some vertex . Then any path in this graph corresponds\r\nto a double rainbow in the original. However, this doesnât solve the\r\nproblem yet, because of the condition that the final edge of a double\r\nrainbow can be of any color.To help in solving this issue, consider sets\r\nsuch that has all of the -connected components of both and any neighbor\r\nof . Then we can see that we have a double rainbow from to if and only\r\nif the connected component of is in (either we reach directly, or we\r\nreach one of its neighbors and then use our final edge to go to ). So as\r\nlong as we can mantain these sets, we have a time way to answer queries\r\nof the second type.Now we need to deal with adding edges. To do this, we\r\nwill store the connectivity of using a DSU. When we connect two\r\nconnected components in , we do the merges from small to large. If we\r\nmerge component into component then for each vertex in component and\r\nevery neighbor of we remove from and insert instead. By merging from\r\nsmall to large we guarantee that each vertex changes component at most\r\ntimes, and thus we also update through the edge at most times. Each\r\nupdate is just two operations, so over all updates this amortizes to\r\n(because we have edges), plus for actually moving the vertices.Thereâs\r\nan easy to fix, but important note, which is that the number of edges in\r\ncan be quadratically large. However, we can check that for each edge of\r\ncolor that we add, we only need to add two edges to . Namely, if and are\r\nneighbors of and respectively through an edge of color , then it is\r\nenough to add edges and . (If one of or doesnât exist then we just donât\r\nadd the corresponding edge). We can store these -colored neighbors of\r\neach vertex in sets which have total size at most , so we can find in\r\nwhich updates we need to perform, and we perform a constant number of\r\nupdates per added edge.Complexity: , or using hash tables.\r\n",
    "hint": []
}