{
    "link": "https://codeforces.com//contest/1762/problem/C",
    "problemId": "1695272",
    "problem_idx": "C",
    "shortId": "1762C",
    "contest_number": "1762",
    "problem_submissions": {
        "F": [
            185360973,
            185364441,
            185372202,
            185395910,
            185621065,
            185354232,
            185332491,
            185348264,
            185360759,
            197448951,
            197448921
        ],
        "E": [
            185344507,
            185353525,
            185341937,
            185339289,
            185344504,
            185352316,
            185360035,
            185362208,
            185365484,
            185404755,
            185370016,
            185351528,
            185364233,
            185367555,
            191848003,
            185329145
        ],
        "D": [
            185337625,
            185342301,
            185324406,
            185313736,
            185320476,
            185336684,
            185335575,
            185333725,
            185325437,
            185329719,
            185355407,
            185334757,
            185358794,
            185354685,
            185353510,
            203219751,
            203219727,
            185328017,
            185332700,
            185327767
        ],
        "C": [
            185322060,
            185321446,
            185314988,
            185324570,
            185312857,
            185315091,
            185320564,
            185320295,
            185330972,
            185319388,
            185342558,
            185326201,
            185316184,
            185309915,
            185362472,
            185315926,
            185312437,
            185310609,
            185320776
        ],
        "B": [
            185304175,
            185312988,
            185302843,
            185317620,
            185309312,
            185304849,
            185311399,
            185308703,
            185304961,
            185310615,
            185338037,
            185310014,
            185310646,
            185303730,
            185343806,
            185303744,
            185303718,
            185304581,
            185309640
        ],
        "A": [
            185300504,
            185304250,
            185300255,
            185302050,
            185306620,
            185300445,
            185302307,
            185307731,
            185300743,
            185301230,
            185335246,
            185301137,
            185300437,
            185300430,
            185322563,
            185300790,
            185300333,
            185302002,
            185301784
        ],
        "G": [
            185409628,
            185346613
        ]
    },
    "name": "C. Binary Strings are Fun",
    "statement": "A binary string^\r\ndagger b of odd length m is if b_i is the median^\r\nddagger of b[1,i]^\r\nS for all indices i (1\r\nleq i\r\nleq m).For a binary string a of length k, a binary string b of length\r\n2k-1 is an of a if b_{2i-1}=a_i for all i such that 1\r\nleq i\r\nleq k. For example, and are of the string . String x= is not an of\r\nstring y= because x_3\r\nneq y_2. Note that there are 2^{k-1} different of a.You are given a\r\nbinary string s of length n. Find the sum of the number of over all\r\nprefixes of s. In other words, find\r\nsum_{i=1}^{n} f(s[1,i]), where f(x) gives number of of string x. Since\r\nthe answer can be quite large, you only need to find it modulo 998\r\n,244\r\n,353.^\r\ndagger A binary string is a string whose elements are either\r\nmathtt{0} or\r\nmathtt{1}.^\r\nddagger For a binary string a of length 2m-1, the median of a is the\r\n(unique) element that occurs at least m times in a.^\r\nS a[l,r] denotes the string of length r-l+1 which is formed by the\r\nconcatenation of a_l,a_{l+1},\r\nldots,a_r in that order.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint fpow(int a,int b)\n{\n    int ans=1;\n    while(b){\n        if(b & 1) ans =1LL*ans*a%mod;\n        a = 1LL*a*a%mod ; b >>= 1;\n    }\n    return ans;\n}\nint t[400005] , rt[400005];\nint C(int a,int b)\n{\n    return 1LL*t[a]*rt[a - b] % mod * rt[b] %mod;\n}\nint c[200005];\nchar s[200005];\nint n;\nvoid solve()\n{\n    scanf(\"%d\",&n);t[0] = rt[0] = 1;\n   // for(int i = 1;i <= n*2;i++) t[i] = 1LL*t[i - 1]*i % mod , rt[i] = fpow(t[i],mod-2);\n  //  for(int i = 0;i <= n;i++) c[i] = 1LL*C(i*2 , i) * fpow(i  + 1 , mod - 2) % mod ;\n    scanf(\"%s\",s+1);\n    int lst = 1 ,d = 1;\n    int ans = 0;\n    for(int i = 2;i <= n +1;i++) {\n        if(i == n + 1 || s[i] != s[i - 1]){\n            int L = i - lst;\n            ans = (ans + 1LL*(fpow(2 , L) - 1) * d) % mod;\n          //  d = 1LL*d*c[L] % mod;\n         //   printf(\"After %d , %d\\n\",i - 1 , ans);\n            lst = i;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return;\n}\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    int t;scanf(\"%d\",&t);\n    while(t--) solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Binary Strings are Fun.json",
    "editorial_link": "https://codeforces.com//blog/entry/110169",
    "editorial": "SolutionNow we know how to solve for whole string .We can similarly\r\nsolve for all prefixes.To find , we need to find the longest suffix of\r\ncontaining same character. We can easily calculate this all prefixes\r\nwhile moving from to .Time complexity is .\r\n",
    "hint": [
        "Hint 1 Let us first find .",
        "Hint 2 where is the length of longest suffix of in which all characters are same.",
        "Hint 3 How to prove the result in hint ? First of all it is easy to see if all characters of are same, as median is always . Now we assume that contains distinct characters. Suppose is one good extension of . Assume we are index . If there exists an index such that , we should have . Why? Assume is the smallest index greater than such that . Now if we have , can never be median of subarray . So if longest suffix of having same characters of starts at index , for all and can be anything(either or ) for all ."
    ]
}