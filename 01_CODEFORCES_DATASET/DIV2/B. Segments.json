{
    "link": "https://codeforces.com//contest/909/problem/B",
    "problemId": "142268",
    "problem_idx": "B",
    "shortId": "909B",
    "contest_number": "909",
    "problem_submissions": {
        "D": [
            33703562,
            33684475,
            33687934,
            33679960,
            33681845,
            33678239,
            33681778,
            33682813,
            33684628,
            33683979,
            33684264,
            33683734,
            33682267,
            33684172,
            33684972,
            33684951,
            37837707,
            33689232,
            33685173
        ],
        "C": [
            33702243,
            33685781,
            33688791,
            33678737,
            33677527,
            33680778,
            33679730,
            33677867,
            33678218,
            33679090,
            33681226,
            33679711,
            33679799,
            33678914,
            33682105,
            33681294,
            33679526,
            33680909
        ],
        "F": [
            33682616,
            33683222,
            33692268,
            33694692,
            33695944
        ],
        "E": [
            33680057,
            33686075,
            33684461,
            33682298,
            33685101,
            33681929,
            33683773,
            33684555,
            33682566,
            33680995,
            33686514,
            33687842,
            33689439,
            33687234,
            33687184,
            33690952,
            33683720,
            33689497
        ],
        "B": [
            33678984,
            33689620,
            33681003,
            33675642,
            33677938,
            33674594,
            33675218,
            33675981,
            33675928,
            33676067,
            33676981,
            33677469,
            33675490,
            33680062,
            33675898,
            33676219,
            33677187
        ],
        "A": [
            33675962,
            33690137,
            33674036,
            33674451,
            33674005,
            33674337,
            33674208,
            33673945,
            33674163,
            33674088,
            33674166,
            33675518,
            33673927,
            33674572,
            33673981,
            33673915,
            33676471
        ]
    },
    "name": "B. Segments",
    "statement": "You are given an integer . Consider all possible segments on the\r\ncoordinate axis with endpoints at integer points with coordinates\r\nbetween 0 and , inclusive; there will be of them.You want to draw these\r\nsegments in several layers so that in each layer the segments don’t\r\noverlap (they might touch at the endpoints though). You move the\r\nsegments to a different location on the coordinate axis. Find the\r\nminimal number of layers you have to use for the given .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nnamespace FastIO\n{\n\tstatic char c;\n\tstatic int top,buf[22];\n\ttemplate<typename T>inline void read(T& x)\n\t{\n\t\tx=0,c=getchar();\n\t\twhile(!isdigit(c))c=getchar();\n\t\twhile(isdigit(c))x=x*10+c-'0',c=getchar();\n\t}\n\ttemplate<typename T>inline void write(T x)\n\t{\n\t\ttop=0;\n\t\tdo buf[++top]=x%10,x/=10;while(x);\n\t\twhile(top)putchar(buf[top--]+48);\n\t\tputchar('\\n');\n\t}\n}\nusing FastIO::read;\nusing FastIO::write;\ntypedef long long LL;\n\nint n,dp[105];\n\nint main()\n{\n\tread(n);\n\tdp[1]=1,dp[2]=2;\n\tfor(int i=3;i<=n;i++)dp[i]=i+dp[i-2];\n\twrite(dp[n]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/56666",
    "editorial": "Consider a segment of length 1. Clearly, all segments that cover this\r\nsegment must belong to different layers. To cover it, the left end of\r\nthe segment must be at one of the points ( options), and the right end\r\nat one of the points ( options). So the number of segments covering is\r\nequal to . The maximum of over all gives us a lower bound on the number\r\nof layers. Because the problem doesnât require explicit construction, we\r\ncan make a guess that this bound is exact. can be found in ;\r\nalternatively, it can be seen that the maximum is reached for (for a\r\ncentral segment for odd or for one of two central segments for even ).\r\nThe answer is . We can also prove this by an explicit construction. Sort\r\nall segments in non-decreasing order of their left ends and then in\r\nincreasing order of their right ends. Try to find a place for each next\r\nsegment greedily: if is the left end of current segment, and segment is\r\nfree in some layer, add the current segment to that layer; otherwise,\r\nstart a new layer with the current segment. and yes, this is our\r\nproblem! :-)\r\n",
    "hint": []
}