{
    "link": "https://codeforces.com//contest/92/problem/D",
    "problemId": "485",
    "problem_idx": "D",
    "shortId": "92D",
    "contest_number": "92",
    "problem_submissions": {
        "E": [
            502340,
            502235,
            503231,
            503523,
            502875,
            1934622,
            504390,
            504399
        ],
        "D": [
            501536,
            501225,
            500880,
            502434,
            501591,
            501746,
            502190,
            500876,
            502107,
            1934547,
            501066,
            502802,
            501866,
            502445,
            503569,
            502507,
            502093,
            502285,
            502239
        ],
        "C": [
            500714,
            501838,
            501748,
            501346,
            502515,
            500790,
            501606,
            500378,
            501102,
            1934749,
            500620,
            501744,
            501022,
            501650,
            501493,
            501780,
            501873,
            501256,
            501229
        ],
        "B": [
            500032,
            502068,
            499811,
            499879,
            500650,
            499787,
            500445,
            499339,
            500204,
            1934408,
            499909,
            500192,
            500246,
            500348,
            500291,
            502825,
            500705,
            500227,
            499923
        ],
        "A": [
            499184,
            499077,
            498989,
            499217,
            499137,
            499006,
            499104,
            498985,
            498993,
            1934380,
            499022,
            499009,
            499187,
            499279,
            499007,
            503011,
            499075,
            499110,
            498994
        ]
    },
    "name": "D. Queue",
    "statement": "There are walruses standing in a queue in an airport. They are numbered\r\nstarting from the queue’s tail: the -st walrus stands at the end of the\r\nqueue and the -th walrus stands at the beginning of the queue. The -th\r\nwalrus has the age equal to .The -th walrus becomes displeased if\r\nthere’s a younger walrus standing in front of him, that is, if exists\r\nsuch (), that . The of the -th walrus is equal to the number of walruses\r\nbetween him and the furthest walrus ahead of him, which is younger than\r\nthe -th one. That is, the further that young walrus stands from him, the\r\nstronger the displeasure is.The airport manager asked you to count for\r\neach of walruses in the queue his displeasure.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n//\ntypedef long long LL;\ntypedef pair<int,int> PII;\n#define MP make_pair\n#define VI vector<int>\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n//\n#define rep(i,b) for(int i=(0);i<(b);++i)\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define fore(a,b) for(__typeof((b).begin()) a = (b).begin();a!=(b).end();++a)\n#define vv vector\n#define pb push_back\n#define ll long long\n#define ld long double\n#define ss(a) (int)(a).size()\n#define all(x) (x).begin(),(x).end()\n#define clr(x,a) memset(x,a,sizeof(x))\n#define vi vv<int>\n#define vs vv<string>\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\n\nint cond = (ll)1;\n#define db(x) { if (cond > 0) { cond--; rep (xxx, 1) cerr << __LINE__ << \" \" << #x << \" \" << x << endl; cerr.flush(); } }\n\nconst int sz = (int)1e5 + 11;\n\nint val[sz];\n\nint qage[sz];\nint qwhen[sz];\nint qq = 1;\n\nint ret[sz];\n\nvoid _main() {\n    rep (i, sz) qage[i] = (int)1e9 + 11;\n    int n;\n    scanf(\"%d\", &n);\n    rep (i, n) scanf(\"%d\", &val[i]);\n    ret[n-1] = -1;\n    qage[0] = -val[n-1];\n    qwhen[0] = n-1;\n\n    ford (i, n-2,0) {\n        int cur = val[i];\n        if (-qage[qq-1] > cur) {\n            qage[qq] = -cur;\n            qwhen[qq] = i;\n            qq++;\n        }\n        int p = upper_bound(qage, qage + qq, -cur) - qage;\n        if (p == qq) ret[i] = -1;\n        else ret[i] = qwhen[p] - i - 1;\n    }\n    rep (i, n) {\n        if (i) printf(\" \");\n        printf(\"%d\", ret[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char ** argv) {\n    string p = \"../gcj/source/\" + string(\"\") + argv[0][strlen(argv[0])-1];\n//    if (argc >= 2 && strcmp(argv[1], \"q\") != 0) { freopen(argv[1],\"r\",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], \"1n\") == 0) { freopen(\"1.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"2n\") == 0) { freopen(\"2.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"3n\") == 0) { freopen(\"3.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"4n\") == 0) { freopen(\"4.in\",\"r\",stdin);}\n    rep (i, argc) if (strcmp(argv[i], \"5n\") == 0) { freopen(\"5.in\",\"r\",stdin);}\n\n    rep (i, argc) if (strcmp(argv[i], \"s0\") == 0) { freopen((p + \"-small-0.in\").c_str(),\"r\",stdin);freopen((p + \"-small-0.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"s1\") == 0) { freopen((p + \"-small-1.in\").c_str(),\"r\",stdin);freopen((p + \"-small-1.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"s2\") == 0) { freopen((p + \"-small-2.in\").c_str(),\"r\",stdin);freopen((p + \"-small-2.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"l0\") == 0) { freopen((p + \"-large-0.in\").c_str(),\"r\",stdin);freopen((p + \"-large-0.out\").c_str(),\"w\",stdout); }\n    rep (i, argc) if (strcmp(argv[i], \"q\") == 0) cond = 1 << 30;\n    _main();\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Queue32387.json",
    "editorial_link": "https://codeforces.com//blog/entry/2182",
    "editorial": "We will count the number of ski bases including the base consisted of empty subset of edges (before printing just subtract one). In the beginning the number of bases is equal to 1. If we connect vertexes in the same connected components then the result should be multiplied by 2 else do nothing. You should use DJS data structure to know information about connected components where vertexes are and to unite them.\n\nWhy is it correct?\nTo prove it we will use the matrix of incidence I, rows in it will be edges and columns will be vertexes. Let's define xor of two rows. Xor of two rows a ? b will be row c such that ci?=?ai xor bi. Notice if  xor of some subset of rows is equal to a zero row then this subset form the ski base. It's correct because, the degree of contiguity of every vertex is even, so we can form an Euler cycle in every connected component. The answer is  2(m?-?rank(I)). \n\nWhy it is correct? Let's write the number of edge from the right of each row which suit this row. While finding the matrix rank using gauss method with xor operation, we will xor the subsets from the right of the strings. In the end the subsets of edges written from the right of the zero rows will form the basis of the linear space. Thats why we can take any subset of vectors from basis and make up a new ski base. The number of these subsets is equal to 2k = 2(m?-?rank(I)), where k is the number of zero rows.\n\n\nThe last thing we should notice that the adding row is liner depended if and only if there is exist a way between the vertexes a and b (a and b are the ends of the adding edge).",
    "hint": []
}