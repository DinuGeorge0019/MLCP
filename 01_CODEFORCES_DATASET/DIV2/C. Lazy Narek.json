{
    "link": "https://codeforces.com//contest/2005/problem/C",
    "problemId": "2874763",
    "problem_idx": "C",
    "shortId": "2005C",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "Full SolutionLetâs loop through the strings and define as the maximal\r\nanswer if we are currently looking for the -th letter in the word\r\n\"Narek\". Initially, , and . For the current string, we brute force on\r\nall five letters we could have previously ended on. Let s say the\r\ncurrent letter is the -th, where . If is not , we can replicate the\r\nprocess of choosing this string for our subset and count the score\r\ndifference (the answer). Eventually, we will reach to some -th letter in\r\nthe word \"Narek\". If reaching from is bigger than the previous value of\r\n, we update by .Finally, the answer is . This is because if is not ,\r\nthen we didn t fully complete the entire word (the problem states that\r\nin this case, these letters are counted in the GPT s score, so we\r\nsubtract this from our score and add it to the GPT s).Note: Updating the\r\narray is incorrect, because we may update some for some string, and then\r\nuse that updated for that same string. To avoid this, we can use two\r\narrays and overwrite one to the other for each string. Time complexity:\r\nor , depending on the implementation.\r\n",
    "name": "C. Lazy Narek",
    "statement": "Narek is too lazy to create the third problem of this contest. His\r\nfriend Artur suggests that he should use ChatGPT. ChatGPT creates n\r\nproblems, each consisting of m letters, so Narek has n strings. To make\r\nthe problem harder, he combines the problems by selecting some of the n\r\nstrings and concatenating them . His chance of solving the problem is\r\ndefined as score_n - score_c, where score_n is Narek’s score and score_c\r\nis ChatGPT’s score.Narek calculates score_n by examining the selected\r\nstring (he moves from left to right). He initially searches for the\r\nletter\r\ntexttt{\"n\"}, followed by\r\ntexttt{\"a\"},\r\ntexttt{\"r\"},\r\ntexttt{\"e\"}, and\r\ntexttt{\"k\"}. Upon finding all occurrences of these letters, he\r\nincrements score_n by 5 and resumes searching for\r\ntexttt{\"n\"} again (he doesn’t go back, and he just continues from where\r\nhe left off). After Narek finishes, ChatGPT scans through the array and\r\nincrements score_c by 1 for each letter\r\ntexttt{\"n\"},\r\ntexttt{\"a\"},\r\ntexttt{\"r\"},\r\ntexttt{\"e\"}, or\r\ntexttt{\"k\"} that Narek fails to utilize (note that if Narek fails to\r\ncomplete the last occurrence by finding all of the 5 letters, then all\r\nof the letters he used are counted in ChatGPT’s score score_c, and Narek\r\ndoesn’t get any points if he doesn’t finish finding all the 5\r\nletters).Narek aims to maximize the value of score_n - score_c by\r\nselecting the most optimal subset of the initial strings.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; inline void Solve (){    int linii , coloane;    cin >> linii >> coloane;     const char dorit[] = \"narek\";    int maxim[5] = {0 , -1000000000 , -1000000000 , -1000000000 , -1000000000};    while (linii--)    {        char sir[1001];        cin >> sir;         int temporar[5] = {-1000000000 , -1000000000 , -1000000000 , -1000000000 , -1000000000};        for (int indice = 0 ; indice < 5 ; indice++)        {            int __indice = indice , termen = 0;            for (int actual = 0 ; actual < coloane ; actual++)            {                if (sir[actual] == dorit[__indice])                    { if (++__indice == 5) { __indice = 0; termen += 5; } }                else                    if (strchr(dorit , sir[actual]))                        { termen--; }            }             temporar[__indice] = max(temporar[__indice] , maxim[indice] + termen);        }         for (int indice = 0 ; indice < 5 ; indice++)            { maxim[indice] = max(maxim[indice] , temporar[indice]); }    }     int rezultat = 0;    for (int indice = 0 ; indice < 5 ; indice++)        { rezultat = max(rezultat , maxim[indice] - indice); }     cout << rezultat << '\\n';} int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);     int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Lazy Narek.json",
    "hint": []
}