{"link": "https://codeforces.com//contest/1884/problem/B", "problemId": "2278160", "problem_idx": "B", "shortId": "1884B", "contest_number": "1884", "problem_submissions": {"E": [229182998, 232047287, 229184537, 229188100, 229407530, 229406745, 229186340, 229191046, 229193161], "D": [229158633, 232074380, 229168220, 229164508, 229173176, 229157255, 229153443, 229155494, 229159386, 229160353, 229156733, 229156643, 229161617, 229157357, 229162436, 229158936, 229165915, 229162999, 229162965, 229163918, 229164809], "C": [229155589, 229160960, 229166024, 229166680, 229154105, 229157494, 229160291, 229153826, 229157399, 229163211, 229163270, 229157632, 229164398, 229157764, 229156973, 229156300, 229158818, 229157218, 229159145, 229159718], "B": [229151946, 229151614, 229152037, 229164652, 229149397, 229159327, 229149698, 229150790, 229150442, 229150480, 229151756, 229152335, 229149090, 229150117, 229151229, 229150183, 229155852, 229153843, 229154670, 229153764], "A": [229147132, 229147400, 229147746, 229153787, 229147017, 229146825, 229146890, 229146981, 229146866, 229148682, 229147191, 229148012, 229146920, 229147887, 229146935, 229147042, 229146861, 229146944, 229147243, 229148319]}, "name": "B. Haunted House", "statement": "You are given a number in binary representation consisting of exactly n\r\nbits, possibly, with leading zeroes. For example, for n = 5 the number 6\r\nwill be given as 00110, and for n = 4 the number 9 will be given as\r\n1001.Let\u2019s fix some integer i such that 1\r\nle i\r\nle n. In one operation you can swap any two adjacent bits in the binary\r\nrepresentation. Your goal is to find the smallest number of operations\r\nyou are required to perform to make the number divisible by 2^i, or say\r\nthat it is impossible.Please note that for each 1\r\nle i\r\nle n you are solving the problem independently.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint N;char s[200005];\nint pcnt[200005],pos[200005],tot;ll res[200005];\nvoid solve(){\n\tscanf(\"%d\",&N);scanf(\"%s\",s+1);tot=0;reverse(s+1,s+N+1);\n\tfor(int i=1;i<=N;++i)if(s[i]=='0')pos[++tot]=i;\n\tfor(int i=1;i<=tot;++i)res[i]=res[i-1]+(ll)(pos[i]-i);\n\tpcnt[N+1]=0;for(int i=N;i>=1;--i)pcnt[i]=pcnt[i+1]+(s[i]=='0');\n\tfor(int i=1;i<=N;++i){\n\t\tif(i-(pcnt[1]-pcnt[i+1])>pcnt[i+1]){printf(\"-1 \");continue;}\n\t\tprintf(\"%lld \",res[i]);\n\t} puts(\"\");\n}\nint main(){\n\tint t;cin>>t;\n\twhile(t--)solve(); \n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "greedy", "math", "two pointers"], "dificulty": "1100", "interactive": false}