{
    "link": "https://codeforces.com//contest/1884/problem/B",
    "problemId": "2278160",
    "problem_idx": "B",
    "shortId": "1884B",
    "contest_number": "1884",
    "problem_submissions": {
        "E": [
            229182998,
            232047287,
            229184537,
            229188100,
            229407530,
            229406745,
            229186340,
            229191046,
            229193161
        ],
        "D": [
            229158633,
            232074380,
            229168220,
            229164508,
            229173176,
            229157255,
            229153443,
            229155494,
            229159386,
            229160353,
            229156733,
            229156643,
            229161617,
            229157357,
            229162436,
            229158936,
            229165915,
            229162999,
            229162965,
            229163918,
            229164809
        ],
        "C": [
            229155589,
            229160960,
            229166024,
            229166680,
            229154105,
            229157494,
            229160291,
            229153826,
            229157399,
            229163211,
            229163270,
            229157632,
            229164398,
            229157764,
            229156973,
            229156300,
            229158818,
            229157218,
            229159145,
            229159718
        ],
        "B": [
            229151946,
            229151614,
            229152037,
            229164652,
            229149397,
            229159327,
            229149698,
            229150790,
            229150442,
            229150480,
            229151756,
            229152335,
            229149090,
            229150117,
            229151229,
            229150183,
            229155852,
            229153843,
            229154670,
            229153764
        ],
        "A": [
            229147132,
            229147400,
            229147746,
            229153787,
            229147017,
            229146825,
            229146890,
            229146981,
            229146866,
            229148682,
            229147191,
            229148012,
            229146920,
            229147887,
            229146935,
            229147042,
            229146861,
            229146944,
            229147243,
            229148319
        ]
    },
    "name": "B. Haunted House",
    "statement": "You are given a number in binary representation consisting of exactly n\r\nbits, possibly, with leading zeroes. For example, for n = 5 the number 6\r\nwill be given as 00110, and for n = 4 the number 9 will be given as\r\n1001.Let’s fix some integer i such that 1\r\nle i\r\nle n. In one operation you can swap any two adjacent bits in the binary\r\nrepresentation. Your goal is to find the smallest number of operations\r\nyou are required to perform to make the number divisible by 2^i, or say\r\nthat it is impossible.Please note that for each 1\r\nle i\r\nle n you are solving the problem independently.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint N;char s[200005];\nint pcnt[200005],pos[200005],tot;ll res[200005];\nvoid solve(){\n\tscanf(\"%d\",&N);scanf(\"%s\",s+1);tot=0;reverse(s+1,s+N+1);\n\tfor(int i=1;i<=N;++i)if(s[i]=='0')pos[++tot]=i;\n\tfor(int i=1;i<=tot;++i)res[i]=res[i-1]+(ll)(pos[i]-i);\n\tpcnt[N+1]=0;for(int i=N;i>=1;--i)pcnt[i]=pcnt[i+1]+(s[i]=='0');\n\tfor(int i=1;i<=N;++i){\n\t\tif(i-(pcnt[1]-pcnt[i+1])>pcnt[i+1]){printf(\"-1 \");continue;}\n\t\tprintf(\"%lld \",res[i]);\n\t} puts(\"\");\n}\nint main(){\n\tint t;cin>>t;\n\twhile(t--)solve(); \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "two pointers"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Haunted House.json",
    "editorial_link": "https://codeforces.com//blog/entry/121618",
    "editorial": "In order for a number to be divisible by , the last bits of its binary\r\nrepresentation must be equal to . For convenience, letâs reverse the\r\nbinary representation of the number so that our operations aim to zero\r\nout the first bits. Let be the number of bits equal to in the original\r\nstring.If , it is obvious that the answer is since our operations do not\r\nchange the number of zeros and ones in the number. Otherwise, the answer\r\nexists, and we will learn how to calculate the minimum number of\r\noperations. Consider all , where . We need to remove these ones from our\r\nprefix by replacing them with the nearest zeros after position . We will\r\ntraverse the string from left to right, keeping track of the number of\r\nones in our prefix (denoted as ) and the sum of their positions (denoted\r\nas ). We also need to maintain the sum of the nearest positions of zeros\r\nafter our element (denoted as ). This can be done using a pointer. The\r\nanswer is . This is both a lower bound estimate and can be greedily\r\nshown how to obtain this answer in such a number of operations.First,\r\nletâs place all the ones at the end of our prefix. We will place the\r\nrightmost one at position and so on. This can be done in operations,\r\nwhere is the position of the corresponding one, which in general is\r\nactually . Now we want to place zeros at these positions, and we will do\r\nthis greedily times, performing operations, where is the position of .\r\nAgain, the total is . Our answer is the sum of these two, which is .\r\n",
    "hint": []
}