{
    "link": "https://codeforces.com//contest/1287/problem/D",
    "problemId": "509649",
    "problem_idx": "D",
    "shortId": "1287D",
    "contest_number": "1287",
    "problem_submissions": {
        "E2": [
            68292966
        ],
        "E1": [
            68275567,
            69857829,
            68268888,
            68267730,
            68276517,
            68275345,
            68277506
        ],
        "D": [
            68254686,
            69267989,
            68263399,
            68273154,
            68268233,
            68260202,
            68261652,
            68267427,
            68261050,
            68269506,
            68253370,
            68261828,
            68262781,
            68259993,
            68263653,
            68262032,
            68264765,
            68263857,
            68263835,
            68268683
        ],
        "C": [
            68251057,
            69267378,
            68258032,
            68258705,
            68258307,
            68255841,
            68251184,
            68254777,
            68254064,
            68259914,
            68257391,
            68256601,
            68256839,
            68253229,
            68254316,
            68258260,
            68255773,
            68259159,
            68259073,
            68255080
        ],
        "B": [
            68248587,
            69266960,
            68254034,
            68252413,
            68256461,
            68250437,
            68247733,
            68281202,
            68281106,
            68280696,
            68280618,
            68264095,
            68250685,
            68253499,
            68259982,
            68248645,
            68435109,
            68253464,
            68263831,
            68250832,
            68248995,
            68250500,
            68255530,
            68255702,
            68249590
        ],
        "A": [
            68244872,
            69266641,
            68245653,
            68244897,
            68247583,
            68245583,
            68244694,
            68245113,
            68244700,
            68244809,
            68261293,
            68244924,
            68435072,
            68246461,
            68245783,
            68245033,
            68244706,
            68244729,
            68245472,
            68245512,
            68245361
        ],
        "F": [
            68641340
        ]
    },
    "name": "D. Numbers on Tree",
    "statement": "Evlampiy was gifted a rooted tree. The vertices of the tree are numbered\r\nfrom 1 to n. Each of its vertices also has an integer a_i written on it.\r\nFor each vertex i, Evlampiy calculated c_i the number of vertices j in\r\nthe subtree of vertex i, such that a_j < a_i. Illustration for the\r\nsecond example, the first integer is a_i and the integer in parentheses\r\nis c_iAfter the new year, Evlampiy could not remember what his gift was!\r\nHe remembers the tree and the values of c_i, but he completely forgot\r\nwhich integers a_i were written on the vertices.Help him to restore\r\ninitial integers!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\nvector<int> chld[N];\nint root;\n\nint n;\nint c[N];\nint ans[N];\n\nvoid read() {\n  scanf(\"%d\", &n);\n  for (int i = 1 ; i <= n ; i++) {\n    int p;\n    scanf(\"%d %d\", &p, &c[i]);\n\n    if (p == 0) {\n      root = i;\n    } else {\n      chld[p].push_back(i);\n    }\n  }\n}\n\nvector<int> dfs(int now) {\n  vector<int> ret;\n  for (int x : chld[now]) {\n    vector<int> fromX = dfs(x);\n    for (int y : fromX) {\n      ret.push_back(y);\n    }\n  }\n\n  if (c[now] > ret.size()) {\n    puts(\"NO\");\n    exit(0);\n  }\n\n  ret.insert(ret.begin() + c[now], now);\n  return ret;\n}\n\nvoid work() {\n  vector<int> order = dfs(root);\n  for (int i = 0 ; i < order.size() ; i++) {\n    ans[order[i]] = i+1;\n  }\n\n  puts(\"YES\");\n  for (int i = 1 ; i <= n ; i++) {\n    printf(\"%d\\n\", ans[i]);\n  }\n}\n\nint main() {\n  read();\n  work();\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Numbers on Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "There are several approaches to this problem. We will tell one of them. Note that if ci\n for some vertex is greater than the number of vertices in its subtree, then there is no answer.\n\nNow we prove that we can always build the answer, so that all ai\n will be numbers from 1\n to n\n. On those numbers, let's build some structure that supports deleting elements and searching for k-th element. Let's denote by dv\n the number of vertices in the subtree of vertex v\n. Now iterate over the subtree of v\n in the order of the depth first search. Then let's set av\n = cv\n-th element in our structure (and after that delete this element). Firstly, such an element will always exist. This is true because when we examine the vertex v\n, all vertices in the subtree of this vertex are not yet considered  Rightarrow\n since cv leqdv\n  Rightarrow\n in our structure there are at least cv\n elements. Secondly, the set of all values in the subtree will be a prefix of our structure. If this is true, then the condition that the subtree contains exactly cv\n elements smaller than ours is guaranteed to be satisfied (because all elements from our structure that are smaller than ours are there, and we specifically took the cv\n-th element). Let us prove this fact by induction on the size of the tree. For a tree of size 1\n this is obvious (we always take the first element). Now for size k\n, we have the root on which the number cx leqk?1\n is written. Then when we throw out cx\n, and then throw out all the vertices in the subtree, we will remove the prefix of at least k?1\n vertices, which means that we will drop all the vertices up to cx\n, as well as some prefix of vertices after it, thus in total we'll throw out some prefix of vertices.\n\nNow, we have reduced the problem to dfs and searching for k-order statistics. This can be done in a variety of ways - segment tree, Fenwick tree, sqrt decomposition, Cartesian tree, or a built-in c++ tree."
}