{"link": "https://codeforces.com//contest/1287/problem/D", "problemId": "509649", "problem_idx": "D", "shortId": "1287D", "contest_number": "1287", "problem_submissions": {"E2": [68292966], "E1": [68275567, 69857829, 68268888, 68267730, 68276517, 68275345, 68277506], "D": [68254686, 69267989, 68263399, 68273154, 68268233, 68260202, 68261652, 68267427, 68261050, 68269506, 68253370, 68261828, 68262781, 68259993, 68263653, 68262032, 68264765, 68263857, 68263835, 68268683], "C": [68251057, 69267378, 68258032, 68258705, 68258307, 68255841, 68251184, 68254777, 68254064, 68259914, 68257391, 68256601, 68256839, 68253229, 68254316, 68258260, 68255773, 68259159, 68259073, 68255080], "B": [68248587, 69266960, 68254034, 68252413, 68256461, 68250437, 68247733, 68281202, 68281106, 68280696, 68280618, 68264095, 68250685, 68253499, 68259982, 68248645, 68435109, 68253464, 68263831, 68250832, 68248995, 68250500, 68255530, 68255702, 68249590], "A": [68244872, 69266641, 68245653, 68244897, 68247583, 68245583, 68244694, 68245113, 68244700, 68244809, 68261293, 68244924, 68435072, 68246461, 68245783, 68245033, 68244706, 68244729, 68245472, 68245512, 68245361], "F": [68641340]}, "name": "D. Numbers on Tree", "statement": "Evlampiy was gifted a rooted tree. The vertices of the tree are numbered\r\nfrom 1 to n. Each of its vertices also has an integer a_i written on it.\r\nFor each vertex i, Evlampiy calculated c_i the number of vertices j in\r\nthe subtree of vertex i, such that a_j < a_i. Illustration for the\r\nsecond example, the first integer is a_i and the integer in parentheses\r\nis c_iAfter the new year, Evlampiy could not remember what his gift was!\r\nHe remembers the tree and the values of c_i, but he completely forgot\r\nwhich integers a_i were written on the vertices.Help him to restore\r\ninitial integers!\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\nvector<int> chld[N];\nint root;\n\nint n;\nint c[N];\nint ans[N];\n\nvoid read() {\n  scanf(\"%d\", &n);\n  for (int i = 1 ; i <= n ; i++) {\n    int p;\n    scanf(\"%d %d\", &p, &c[i]);\n\n    if (p == 0) {\n      root = i;\n    } else {\n      chld[p].push_back(i);\n    }\n  }\n}\n\nvector<int> dfs(int now) {\n  vector<int> ret;\n  for (int x : chld[now]) {\n    vector<int> fromX = dfs(x);\n    for (int y : fromX) {\n      ret.push_back(y);\n    }\n  }\n\n  if (c[now] > ret.size()) {\n    puts(\"NO\");\n    exit(0);\n  }\n\n  ret.insert(ret.begin() + c[now], now);\n  return ret;\n}\n\nvoid work() {\n  vector<int> order = dfs(root);\n  for (int i = 0 ; i < order.size() ; i++) {\n    ans[order[i]] = i+1;\n  }\n\n  puts(\"YES\");\n  for (int i = 1 ; i <= n ; i++) {\n    printf(\"%d\\n\", ans[i]);\n  }\n}\n\nint main() {\n  read();\n  work();\n  return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dfs and similar", "graphs", "trees"], "dificulty": "1800", "interactive": false}