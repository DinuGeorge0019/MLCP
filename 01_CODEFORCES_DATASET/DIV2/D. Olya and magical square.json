{
    "link": "https://codeforces.com//contest/1080/problem/D",
    "problemId": "259656",
    "problem_idx": "D",
    "shortId": "1080D",
    "contest_number": "1080",
    "problem_submissions": {
        "F": [
            46161976,
            46162778,
            46160192,
            46159146,
            46160650,
            46161330,
            46177225,
            46181279,
            46177040,
            46159242,
            46165879,
            46244094
        ],
        "E": [
            46159833,
            46158289,
            46156414,
            46159947,
            46162060,
            46170130,
            46156194,
            46160134,
            46157810,
            46160983,
            46162313,
            46162730,
            46268200,
            46162883,
            46161436,
            46165893,
            46162523,
            46157004,
            46162154
        ],
        "D": [
            46156149,
            46155986,
            46154022,
            46155513,
            46158228,
            46156068,
            46156726,
            46159618,
            46156456,
            46155088,
            46157318,
            46173998,
            46159164,
            46155242,
            46156719,
            46155734,
            46161044,
            46159764
        ],
        "C": [
            46152444,
            46149941,
            46152568,
            46150576,
            46153451,
            46151555,
            46151650,
            46150697,
            46153316,
            46152202,
            46153935,
            46150267,
            46152022,
            46151720,
            46151339,
            46154831,
            46152462,
            46152573,
            46153346,
            46152817
        ],
        "B": [
            46149045,
            46145345,
            46149235,
            46146926,
            46149668,
            46147319,
            46152091,
            46147240,
            46146639,
            46147840,
            46147532,
            46146841,
            46147485,
            46146840,
            46146905,
            46150391,
            46147300,
            46147235,
            46147802,
            46148682
        ],
        "A": [
            46146332,
            46144961,
            46147960,
            46145347,
            46146629,
            46145256,
            46151812,
            46146189,
            46145164,
            46147556,
            46144974,
            46145039,
            46145991,
            46145058,
            46145185,
            46149238,
            46145401,
            46145176,
            46145572,
            46145659
        ]
    },
    "name": "D. Olya and magical square",
    "statement": "Recently, Olya received a magical square with the size of 2^n\r\ntimes 2^n.It seems to her sister that one square is boring. Therefore,\r\nshe asked Olya to perform k .A is an operation during which Olya takes a\r\nsquare with side a and cuts it into 4 equal squares with side\r\ndfrac{a}{2}. If the side of the square is equal to 1, then it is\r\nimpossible to apply a splitting operation to it (see examples for better\r\nunderstanding).Olya is happy to fulfill her sister’s request, but she\r\nalso wants to be satisfied after all operations. will be satisfied if\r\nthe following statement is fulfilled:Let the length of the side of the\r\nlower left square be equal to a, then the length of the side of the\r\nright upper square should also be equal to a. There should also be a\r\npath between them that consists only of squares with the side of length\r\na. All consecutive squares on a path should have a common\r\nside.Obviously, as long as we have one square, these conditions are met.\r\nSo Olya is ready to fulfill her sister’s request only under the\r\ncondition that she is satisfied too. Tell her: is it possible to perform\r\nexactly k splitting operations in a certain order so that the condition\r\nof Olya’s happiness is satisfied? If it is possible, tell also the size\r\nof the side of squares of which the path from the lower left square to\r\nthe upper right one will consist.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nLL f[100];\nint t;\n\nvoid Work() {\n  int n;\n  LL k;\n  scanf(\"%d%I64d\", &n, &k);\n  if (k == 0) {\n    printf(\"YES %d\\n\", n);\n    return;\n  }\n  if (n > t) {\n    printf(\"YES %d\\n\", n - 1);\n    return;\n  }\n  LL l = 0, r = 0;\n  for (int i = 0; i <= n && l <= k; ++i) {\n    if (r >= k) {\n      printf(\"YES %d\\n\", n - i);\n      return;\n    }\n    if (i < n) {\n      r += (1LL << (i + 1)) - 1;\n      if (r > k) r = k;\n      // r += 2^(i+1)-1+(2^(i+1)-3)*f[n-i-1]\n      // l += 2^(i+1)-1\n      LL a = (1LL << (i + 2)) - 3, b = f[n - i - 1];\n      if ((k - r) / a < b) r = k;\n      else r += a * b;\n      l += (1LL << (i + 1)) - 1;\n    }\n  }\n  puts(\"NO\");\n}\n\nint main(){\n  f[0] = 0;\n  for (t = 0; f[t] <= 1000000000000000000LL; ++t)\n    f[t + 1] = f[t] * 4 + 1;\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) Work();\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Olya and magical square.json",
    "editorial_link": "https://codeforces.com//blog/entry/63436",
    "editorial": "At first letâs check if the value of is not too large. This can be done\r\ngreedily in the folllowing way:First splitting operation would be\r\napplied on the only existing inital square. After that we have squares\r\nwith sides . Now we will do spliiting operations each on one of them.\r\nThen we will have squares with sides . If we repeat the action times we\r\nwould end up having squares with size . After that we canât do any more\r\noperations. Of course we donât do this manually we just substract the\r\nnumber of splitting operations we did on each step from the number\r\n(thatâs the variable that is a copy of variable we will need the value\r\nof later).If at some point of the algorithm we have to do more splitting\r\noperations than there remains to, then the value of is smaller than the\r\nmaximum number of operations we can apply, thus is not too large, so we\r\ncan just stop checking. If the algorithm successfuly did iterations and\r\nis still greater than , it means that is greater than the maximum number\r\nof operations we can apply, so the answer is \"\". It can easily proven\r\nthat for any there are no too large numbers for them within the\r\nconstraints of the task. Now we know that we can do operations, but can\r\nwe do them in such a way the is fuldilled?Letâs imagine that the\r\nconstraints are not so big and we can emulate the process. We can do it\r\nin the following way:Step 0. We split the only existing square.Step 1.\r\nIf we can apply splitting opertation to all of the squares on the path\r\nfrom leftmost bottom point to rigthmost top point with the reamining\r\noperations, we should do it and after that we return to Step 1.\r\nOtherwise, the size of the squares of which the path consists is equal\r\nto the size of the squares the path consits now. Go to Step 2.Step 2.\r\nWhen we first did Step 1, we left one square of size untouched. All the\r\nremaining spliiting operations will be used in arbitrary way on it or\r\nthe squares that appear from it.Letâs prove that with relatively big we\r\ncan always solve the problem with the following algorithm.If we can\r\nbuild the path from leftmost bottom point to rightmost top point with\r\nsquares of size than everything is ok, since the remaining splitting\r\noperations can be done (we already checked that the value of is not too\r\nlarge).Otherwise, we can easily see that the number of squares to which\r\nyou need to apply the splitting operation on each step changes like\r\nthis: . It can be proven that the number of splitting operations on the\r\n-th step is equal to:Letâs assume that we stopped on -th iteration of\r\nStep 1. It means that the number of splitting operations remaining is\r\nless than . It also means that we can do at least operations on the\r\nsquare that was left untouched after the first iteration of the\r\nalgorithm. Letâs find the set of such numbers that is greater or equal\r\nto : Since, in numerical system with base can be represented as number\r\nwith length that consists only of ones, it follows that:Now, back to our\r\ninequality: Itâs obvious that function grows faster than , so once the\r\nvalue of becomes greater than the value of it will never beome smaller.\r\nFor :, For :, Now we know that the following algorithm always finds\r\nsolution for all . The rest tests cases can be solved with ifâs, but\r\nstill the algorithms works for them. The only exception is test \"\" there\r\nis no solution for this test, though is smaller than the maximum number\r\nof splitting operations you can apply. Like the first part of the\r\nsolution we shouldnât do the algorthm manually we can just on each step\r\nsubstract the length of the path from the variable . (For -th step itâs\r\n).Overall complexity .\r\n",
    "hint": []
}