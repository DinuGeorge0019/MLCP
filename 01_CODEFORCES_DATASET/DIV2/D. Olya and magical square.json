{"link": "https://codeforces.com//contest/1080/problem/D", "problemId": "259656", "problem_idx": "D", "shortId": "1080D", "contest_number": "1080", "problem_submissions": {"F": [46161976, 46162778, 46160192, 46159146, 46160650, 46161330, 46177225, 46181279, 46177040, 46159242, 46165879, 46244094], "E": [46159833, 46158289, 46156414, 46159947, 46162060, 46170130, 46156194, 46160134, 46157810, 46160983, 46162313, 46162730, 46268200, 46162883, 46161436, 46165893, 46162523, 46157004, 46162154], "D": [46156149, 46155986, 46154022, 46155513, 46158228, 46156068, 46156726, 46159618, 46156456, 46155088, 46157318, 46173998, 46159164, 46155242, 46156719, 46155734, 46161044, 46159764], "C": [46152444, 46149941, 46152568, 46150576, 46153451, 46151555, 46151650, 46150697, 46153316, 46152202, 46153935, 46150267, 46152022, 46151720, 46151339, 46154831, 46152462, 46152573, 46153346, 46152817], "B": [46149045, 46145345, 46149235, 46146926, 46149668, 46147319, 46152091, 46147240, 46146639, 46147840, 46147532, 46146841, 46147485, 46146840, 46146905, 46150391, 46147300, 46147235, 46147802, 46148682], "A": [46146332, 46144961, 46147960, 46145347, 46146629, 46145256, 46151812, 46146189, 46145164, 46147556, 46144974, 46145039, 46145991, 46145058, 46145185, 46149238, 46145401, 46145176, 46145572, 46145659]}, "name": "D. Olya and magical square", "statement": "Recently, Olya received a magical square with the size of 2^n\r\ntimes 2^n.It seems to her sister that one square is boring. Therefore,\r\nshe asked Olya to perform k .A is an operation during which Olya takes a\r\nsquare with side a and cuts it into 4 equal squares with side\r\ndfrac{a}{2}. If the side of the square is equal to 1, then it is\r\nimpossible to apply a splitting operation to it (see examples for better\r\nunderstanding).Olya is happy to fulfill her sister\u2019s request, but she\r\nalso wants to be satisfied after all operations. will be satisfied if\r\nthe following statement is fulfilled:Let the length of the side of the\r\nlower left square be equal to a, then the length of the side of the\r\nright upper square should also be equal to a. There should also be a\r\npath between them that consists only of squares with the side of length\r\na. All consecutive squares on a path should have a common\r\nside.Obviously, as long as we have one square, these conditions are met.\r\nSo Olya is ready to fulfill her sister\u2019s request only under the\r\ncondition that she is satisfied too. Tell her: is it possible to perform\r\nexactly k splitting operations in a certain order so that the condition\r\nof Olya\u2019s happiness is satisfied? If it is possible, tell also the size\r\nof the side of squares of which the path from the lower left square to\r\nthe upper right one will consist.\r\n", "solutions": ["#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nLL f[100];\nint t;\n\nvoid Work() {\n  int n;\n  LL k;\n  scanf(\"%d%I64d\", &n, &k);\n  if (k == 0) {\n    printf(\"YES %d\\n\", n);\n    return;\n  }\n  if (n > t) {\n    printf(\"YES %d\\n\", n - 1);\n    return;\n  }\n  LL l = 0, r = 0;\n  for (int i = 0; i <= n && l <= k; ++i) {\n    if (r >= k) {\n      printf(\"YES %d\\n\", n - i);\n      return;\n    }\n    if (i < n) {\n      r += (1LL << (i + 1)) - 1;\n      if (r > k) r = k;\n      // r += 2^(i+1)-1+(2^(i+1)-3)*f[n-i-1]\n      // l += 2^(i+1)-1\n      LL a = (1LL << (i + 2)) - 3, b = f[n - i - 1];\n      if ((k - r) / a < b) r = k;\n      else r += a * b;\n      l += (1LL << (i + 1)) - 1;\n    }\n  }\n  puts(\"NO\");\n}\n\nint main(){\n  f[0] = 0;\n  for (t = 0; f[t] <= 1000000000000000000LL; ++t)\n    f[t + 1] = f[t] * 4 + 1;\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) Work();\n  return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation", "math"], "dificulty": "2000", "interactive": false}