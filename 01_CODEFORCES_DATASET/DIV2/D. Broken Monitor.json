{
    "link": "https://codeforces.com//contest/370/problem/D",
    "problemId": "4146",
    "problem_idx": "D",
    "shortId": "370D",
    "contest_number": "370",
    "problem_submissions": {
        "C": [
            5370412,
            5368730,
            5371522,
            5371990,
            5370195,
            5370131,
            5371258,
            5371358,
            5372807,
            5379034,
            5368672
        ],
        "D": [
            5369264,
            5370401,
            5370565,
            5371357,
            5372982,
            5372779,
            5373131,
            5372520,
            5372523,
            5370570,
            5370366,
            5371915,
            5371128,
            5372843,
            5372383,
            5373802
        ],
        "B": [
            5367928,
            5367560,
            5367818,
            5367866,
            5367916,
            5368321,
            5372838,
            5370234,
            5369841,
            5368420,
            5367832,
            5368440,
            5368950,
            5372070,
            5368698,
            5369739,
            5367644
        ],
        "A": [
            5367394,
            5369807,
            5367525,
            5367450,
            5367389,
            5367654,
            5369021,
            5369042,
            5374280,
            5368909,
            5367810,
            5367376,
            5367612,
            5368269,
            5373074,
            5367757,
            5368835,
            5367393
        ],
        "E": [
            5372646,
            5370095
        ]
    },
    "name": "D. Broken Monitor",
    "statement": "Innocentius has a problem his computer monitor has broken. Now some of\r\nthe pixels are \"dead\", that is, they are always black. As consequence,\r\nInnocentius can’t play the usual computer games. He is recently playing\r\nthe following game with his younger brother Polycarpus.Innocentius is\r\ntouch-typing a program that paints a white square one-pixel wide frame\r\non the black screen. As the monitor is broken, some pixels that should\r\nbe white remain black. Polycarpus should look at what the program\r\ndisplayed on the screen and guess the position and size of the frame\r\nInnocentius has painted. Polycarpus doesn’t like the game but\r\nInnocentius persuaded brother to play as \"the game is good for the\r\nimagination and attention\".Help Polycarpus, automatize his part in the\r\ngaming process. Write the code that finds such possible frame that: the\r\nframe’s width is 1 pixel, the frame doesn’t go beyond the borders of the\r\nscreen, all white pixels of the monitor are located on the frame, of all\r\nframes that satisfy the previous three conditions, the required frame\r\nmust have the smallest size. Formally, a square frame is represented by\r\nsuch pixels of the solid square, that are on the square’s border, that\r\nis, are not fully surrounded by the other pixels of the square. For\r\nexample, if the frame’s size is , then it consists of 8 pixels, if its\r\nsize is , then it contains 4 pixels and if , then the frame is reduced\r\nto a single pixel.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file \"\"\n#define N 100500\n\nchar a[2300][2300];\n       \nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        scanf(\"%s\", a[i]);\n    int l = inf, r = -inf, u = inf, d = -inf;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            if (a[i][j] == 'w')\n            {\n                l = min(l, j);\n                r = max(r, j);\n                u = min(u, i);\n                d = max(d, i);\n            }\n    if (l == inf)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    bool L = 0, R = 0, U = 0, D = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (i == u && j > l && j < r && a[i][j] == 'w') U = 1;\n            if (i == d && j > l && j < r && a[i][j] == 'w') D = 1;\n            if (j == l && i > u && i < d && a[i][j] == 'w') L = 1;\n            if (j == r && i > u && i < d && a[i][j] == 'w') R = 1;\n        }\n    int s = max(r - l, d - u);\n    if (l == r || u == d)\n    {\n        if (l == r)\n        {\n            if (r - s >= 0) l = r - s;\n            else if (l + s < m) r = l + s;\n            else if (L || R)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                l = max(0, r - s);\n                r = min(m - 1, l + s);\n                if (r - l != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n        else\n        {\n            if (d - s >= 0) u = d - s;\n            else if (u + s < n) d = u + s;  \n            else if (U || D)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                u = max(0, d - s);\n                d = min(n - 1, u + s);\n                if (d - u != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    else\n    {                         \n    if (U && D && d - u != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (L && R && r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (U && d - u != s) d = s + u;\n    if (D && d - u != s) u = d - s;\n    if (L && r - l != s) r = l + s;\n    if (R && r - l != s) l = r - s;\n    if (!U && !D && d - u != s)\n    {\n        u = max(0, d - s);\n        d = min(n - 1, u + s);\n    }\n    if (!L && !R && r - l != s)\n    {\n        l = max(0, r - s);\n        r = min(m - 1, l + s);\n    }\n    if (u < 0 || l < 0 || d >= n || r >= m)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (d - u != s || r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if ((i == u || i == d) && j >= l && j <= r)\n            {\n                if (a[i][j] != 'w') a[i][j] = '+';\n            }\n            else if (i >= u && i <= d && (j == l || j == r))\n            {\n                if (a[i][j] != 'w') a[i][j] = '+';\n            }\n            else if (a[i][j] == 'w')\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    for (int i = 0; i < n; i++)\n        printf(\"%s\\n\", a[i]);\n\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Broken Monitor.json",
    "editorial_link": "https://codeforces.com//blog/entry/9866",
    "editorial": "There are a lot of correct approaches to solve the problem. But there\r\nare much more incorrect :) One way to solve the problem is following. It\r\nis easy to see that in possible answer there are two opposite sides each\r\ncontaining w. In opposite case frame can be shrinked. So the size of\r\nframe is or , where and ( are coordinates of left/right/top/bottom ws).\r\nObviously, you should choose as a size. Now we know the size of the\r\nrequired frame. How to find it s leftmost-topmost corner? The set of\r\npossible s is: and 0. Indeed, you may move frame to the left until it\r\nwill abuts to w by left size/right size of abuts to the left side of\r\nmonitor. Similarly, the set of possible s as y-coordinate of\r\nleftmost-topmost corner: . Now the solution looks like: All you need is\r\nto write frame_correct. You may iterate through frame and check that all\r\ncells inside monitor and calculate the number of ws on it. If all the\r\ncells are inside and calculated number equals to total number of w, then\r\nreturn true. This solution works in .\r\n",
    "hint": []
}