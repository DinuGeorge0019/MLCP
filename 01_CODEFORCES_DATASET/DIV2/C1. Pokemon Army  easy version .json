{
    "link": "https://codeforces.com//contest/1420/problem/C1",
    "problemId": "735851",
    "problem_idx": "C1",
    "shortId": "1420C1",
    "contest_number": "1420",
    "problem_submissions": {
        "E": [
            93699813,
            93707260,
            93695968,
            93707648,
            93705681,
            93709151,
            93715432,
            93730964,
            93708580,
            93714548,
            93716147,
            93715550,
            93736542,
            93717442,
            93710855,
            93715981,
            93697763,
            93711132,
            93762507
        ],
        "D": [
            93676952,
            93680084,
            93692950,
            93670877,
            93690670,
            93693136,
            93730971,
            93710781,
            93702357,
            93681953,
            93695104,
            93691378,
            93699248,
            93698024,
            93665582,
            93680861,
            93671056,
            93667892,
            93675623
        ],
        "C2": [
            93674880,
            93671167,
            93692067,
            93741708,
            93681627,
            93659881,
            93679255,
            93686831,
            93676610,
            93670869,
            93669089,
            93684016,
            93707465,
            93690589,
            93710188,
            93716769,
            93662876,
            93683514,
            93665601
        ],
        "C1": [
            93658399,
            93663408,
            93681461,
            93660059,
            93679792,
            93666232,
            93663489,
            93671318,
            93669597,
            93684191,
            93665522,
            93690460,
            93659663,
            93716842,
            93670252,
            93662639,
            93658224,
            93665421
        ],
        "B": [
            93652358,
            93659482,
            93658665,
            93669626,
            93664158,
            93660524,
            93657692,
            93655021,
            93655235,
            93677044,
            93656189,
            93674995,
            93653603,
            93704106,
            93656350,
            93653174,
            93653888,
            93653561
        ],
        "A": [
            93651966,
            93651886,
            93654562,
            93660205,
            93652727,
            93651674,
            93651632,
            93674907,
            93652710,
            93659767,
            93651617,
            93706046,
            93651985,
            93651435,
            93651489,
            93651367
        ]
    },
    "name": "C1. Pok\u00e9mon Army  easy version ",
    "statement": "Pikachu is a cute and friendly pok mon living in the wild pikachu\r\nherd.But it has become known recently that infamous team R wanted to\r\nsteal all these pok mon! Pok mon trainer Andrew decided to help Pikachu\r\nto build a pok mon army to resist.First, Andrew counted all the pok mon\r\nthere were exactly n pikachu. The strength of the i-th pok mon is equal\r\nto a_i, and all these numbers are distinct.As an army, Andrew can choose\r\nany non-empty subsequence of pokemons. In other words, Andrew chooses\r\nsome array b from k indices such that 1\r\nle b_1 < b_2 <\r\ndots < b_k\r\nle n, and his army will consist of pok mons with forces a_{b_1},\r\na_{b_2},\r\ndots, a_{b_k}.The strength of the army is equal to the alternating sum\r\nof elements of the subsequence; that is, a_{b_1} - a_{b_2} + a_{b_3} -\r\na_{b_4} +\r\ndots.Andrew is experimenting with pok mon order. He performs q\r\noperations. In i-th operation Andrew swaps l_i-th and r_i-th pok\r\nmon.Andrew wants to know the maximal stregth of the army he can achieve\r\nwith the initial pok mon placement. He also needs to know the maximal\r\nstrength after each operation.Help Andrew and the pok mon, or team R\r\nwill realize their tricky plan!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 3e5;\nint a[mxN+3]; llong f[mxN+3][2];\nint n,q;\n\nint main()\n{\n\tint T = read(); while(T--)\n\t{\n\t\tn = read(),q = read(); for(int i=1; i<=n; i++) a[i] = read();\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tf[i][0] = max(f[i-1][0],f[i-1][1]+a[i]);\n\t\t\tf[i][1] = max(f[i-1][1],f[i-1][0]-a[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",max(f[n][0],f[n][1]));\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C1. Pok\u00e9mon Army  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/82978",
    "editorial": "The easy version of the task can be solved in different ways. For\r\nexample, you can use the dynamic programming method.Let be the maximum\r\npossible sum of a subsequence on a prefix from the first elements,\r\nprovided that the length of the subsequence is odd. Similarly enter ,\r\nonly for subsequences of even length. Then and are easy to recalculate:\r\n. . The initial values are . The answer will be stored in .This solution\r\nworks for in time. Its main drawback is that it cannot be used to solve\r\na complex version of a task where a different approach is needed.\r\n"
}