{
    "link": "https://codeforces.com//contest/1061/problem/B",
    "problemId": "259558",
    "problem_idx": "B",
    "shortId": "1061B",
    "contest_number": "1061",
    "problem_submissions": {
        "F": [
            46080533,
            46078741,
            46083363,
            46090966,
            46090449,
            46083565,
            46085799,
            46083880,
            46078551,
            46109412,
            46086044,
            46084393,
            46085497,
            46085674,
            46086595,
            46085522,
            46079186,
            46086667,
            46084268,
            46086192,
            46099697,
            46099461,
            46088106
        ],
        "D": [
            46072013,
            46076677,
            46075957,
            46074341,
            46074354,
            46074232,
            46074411,
            46085044,
            46076314,
            46078869,
            46075590,
            46078204,
            46076173,
            46079731,
            46078000,
            46081859,
            46079963,
            46085405,
            46080982,
            46080058
        ],
        "C": [
            46069182,
            46071750,
            46070967,
            46071622,
            46071185,
            46071619,
            46071683,
            46072269,
            46072643,
            46074534,
            46072699,
            46073691,
            46071278,
            46072896,
            46072959,
            46081505,
            46074501,
            46073620,
            46077745,
            46075063
        ],
        "B": [
            46068385,
            46070705,
            46068805,
            46070395,
            46069936,
            46070540,
            46069425,
            46071160,
            46070196,
            46071645,
            46073407,
            46071478,
            46069267,
            46070628,
            46070940,
            46073987,
            46071263,
            46069667,
            46073266,
            46069912
        ],
        "A": [
            46065105,
            46064815,
            46065437,
            46065157,
            46065204,
            46064909,
            46064831,
            46065487,
            46067926,
            46065498,
            46065297,
            46066800,
            46065131,
            46066394,
            46065152,
            46064816,
            46065082,
            46065378,
            46071171,
            46064958
        ],
        "E": [
            46080824,
            46089783,
            46087601,
            142313241,
            46115374
        ]
    },
    "name": "B. Views Matter",
    "statement": "You came to the exhibition and one exhibit has drawn your attention. It\r\nconsists of n stacks of blocks, where the i-th stack consists of a_i\r\nblocks resting on the surface.The height of the exhibit is equal to m.\r\nConsequently, the number of blocks in each stack is less than or equal\r\nto m.There is a camera on the ceiling that sees the top view of the\r\nblocks and a camera on the right wall that sees the side view of the\r\nblocks. Find the maximum number of blocks you can remove such that the\r\nviews for both the cameras would not change.Note, that while originally\r\nall blocks are stacked on the floor, it is not required for them to stay\r\nconnected to the floor after some blocks are removed. There is in the\r\nwhole exhibition, so no block would fall down, even if the block\r\nunderneath is removed. It is not allowed to move blocks by hand either.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll A[100005];\n\nint main() {\n   int N, M; scanf(\"%d%d\", &N, &M);\n   for(int i = 1; i <= N; i++) scanf(\"%lld\", &A[i]);\n   sort(A + 1, A + N + 1);\n   ll s = 0; for(int i = 1; i <= N; i++) s += A[i];\n\n   int h = 0;\n   ll ans = 0;\n   for(int i = 1; i <= N; i++) {\n      ans++;\n      if(h < A[i]) h++;\n   }\n   for(; h <= A[N] - 1; h++) {\n      ans++;\n   }\n   printf(\"%lld\\n\", s - ans);\n\n   return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Views Matter.json",
    "editorial_link": "https://codeforces.com//blog/entry/63384",
    "editorial": "Letâs sort the array in increasing order and find the minimum number of\r\nblocks required to retain the same top and right views. Then, the answer\r\nwould be .For every from to , we need to keep at least block for this\r\nstack to retain the top view. Thus, for every . However, we also need to\r\nmaintain the maximum height we can cover till now, by keeping block in\r\nthis stack. Let the previous best height we had be .Then, if , then we\r\nmanaged to increase the height by , by keeping the block at . However,\r\nif , then we cannot increase the number of blocks in the right view,\r\nsince we are only allowed to keep the current block in range . In the\r\nend, when we finish processing all the stacks, we also need to keep\r\nblocks in the longest stack, to retain the right view as it was\r\noriginally.Overall complexity: Refer to solution code for clarity.\r\n",
    "hint": []
}