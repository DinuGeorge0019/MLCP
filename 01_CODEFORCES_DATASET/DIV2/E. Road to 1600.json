{"link": "https://codeforces.com//contest/1333/problem/E", "problemId": "586757", "problem_idx": "E", "shortId": "1333E", "contest_number": "1333", "problem_submissions": {"E": [75896339, 75896565, 75977605, 75896691, 75897517, 75909706, 75903789, 75909595, 75887158, 75892751, 75911705, 75893605, 75903871, 75907577, 75907287, 75905980, 75911364, 102357635], "F": [75886038, 75883944, 75977662, 75881660, 75879950, 75880078, 75883983, 75889261, 75893323, 75897108, 75891281, 75909072, 75894697, 75898619, 75885706, 75889606, 75886207, 75876954, 75881193], "D": [75864744, 75869369, 75977526, 75869421, 75870061, 75872281, 75875027, 75874985, 75876429, 75882167, 75873219, 75876350, 75881516, 75880068, 75879600, 75883836, 75901469, 75865548, 75870511], "C": [75852521, 75859230, 75977465, 75850790, 75858133, 75853774, 75862591, 75860649, 75860611, 75873215, 75852933, 75864634, 75853173, 75865167, 75868921, 75862158, 75875332, 75854728, 75853080], "B": [75848076, 75848553, 75977412, 75847691, 75848476, 75846675, 75848813, 75851794, 75895723, 75859034, 75846157, 75848508, 75884037, 75854691, 75852331, 75853099, 75848989, 75850255, 75846775], "A": [75845195, 75845040, 75977221, 75844826, 75845093, 75844889, 75845001, 75846626, 75847661, 75851327, 75844724, 75845218, 75845746, 75850998, 75847105, 75848789, 75855160, 75846223, 75844893]}, "name": "E. Road to 1600", "statement": "Egor wants to achieve a rating of 1600 points on the well-known chess\r\nportal ChessForces and he needs your help!Before you start solving the\r\nproblem, Egor wants to remind you how the chess pieces move. Chess moves\r\nalong straight lines up and down, left and right, as many squares as it\r\nwants. And when it wants, it can stop. The walks in all directions\r\nvertically and diagonally at any distance. You can see the examples\r\nbelow. To reach the goal, Egor should research the next topic:There is\r\nan N\r\ntimes N board. Each cell of the board has a number from 1 to N ^ 2 in it\r\nand numbers in all cells are distinct.In the beginning, some chess\r\nfigure stands in the cell with the number 1. Note that this cell is\r\nalready considered as visited. After that every move is determined by\r\nthe following rules: Among all yet cells to which the figure can get in\r\none move, it goes to the cell that has number. If all accessible cells\r\nwere already visited and some cells are not yet visited, then the figure\r\nis teleported to the not visited cell that has minimal number. If this\r\nstep happens, the piece pays a fee of 1 . If all cells are already\r\nvisited, the process is stopped. Egor should find an N\r\ntimes N board on which the rook pays than the queen during the round\r\nwith this numbering. Help him to find such N\r\ntimes N numbered board, or tell that it doesn\u2019t exist.\r\n", "solutions": ["#include <iostream>\n\nusing namespace std;\n\nint const nmax = 500;\nint v[1 + nmax][1 + nmax];\nint sol[16] = {4, 3, 6, 12,7, 5, 9, 15,14, 1, 11, 10, 13, 8, 16, 2};\n\n/*\n124\n538\n967\n*/\n\nint main()\n{\n  int n;\n  cin >> n;\n  if(n <= 2)\n    cout << -1;\n  else if(n == 3){\n    cout << 1 << \" \" << 2 << \" \" << 4 << '\\n';\n    cout << 5 << \" \" << 3 << \" \" << 8 << '\\n';\n    cout << 9 << \" \" << 6 << \" \" << 7 << '\\n';\n  } else {\n    int ptr = 0;\n    int ptr2 = 0;\n    if(n % 2 == 0)\n      for(int i = n - 3; i <= n; i++)\n        for(int j = 1; j <= 4; j++)\n          v[i][j] = 1 * (n * n - 16) + sol[ptr++];\n    else\n      for(int i = n; n - 3 <= i; i--)\n        for(int j = 4; 1 <= j; j--)\n          v[i][j] = 1 * (n * n - 16) + sol[ptr++];\n\n    for(int i = n; 4 <= i; i--){\n      if((n - i) % 2 == 0){\n        for(int j = 1;j <= n; j++)\n          if(v[n - i + 1][j] == 0)\n            v[n - i + 1][j] = ++ ptr2;\n        for(int i2 = 1; i2 <= n; i2++)\n          if(v[i2][i] == 0)\n            v[i2][i] = ++ptr2;\n      } else {\n        for(int i2 = n; 1 <= i2; i2--)\n          if(v[i2][i] == 0)\n            v[i2][i] = ++ptr2;\n        for(int j = n; 1 <= j; j--)\n          if(v[n - i + 1][j] == 0)\n            v[n - i + 1][j] = ++ ptr2;\n      }\n    }\n\n    if(n % 2 == 0)\n      swap(v[n - 4][1], v[n - 4][2]);\n    else if(n % 2 == 1)\n      swap(v[n][5], v[n - 2][5]);\n\n    for(int i = 1;i <= n; i++) {\n      for(int j = 1;j <= n; j++)\n        cout << v[i][j] << \" \";\n      cout << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms"], "dificulty": "2400", "interactive": false}