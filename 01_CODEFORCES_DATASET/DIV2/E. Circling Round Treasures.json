{"link": "https://codeforces.com//contest/376/problem/E", "problemId": "4244", "problem_idx": "E", "shortId": "376E", "contest_number": "376", "problem_submissions": {"C": [5507703, 5508378, 5509653, 5505870, 5508901, 5506789, 5506579, 5509150, 5509916, 5509799, 5507345, 5507270, 5509544, 5509634, 5509897, 5507776, 5509511, 5508122, 5507836], "B": [5506652, 5504117, 5503207, 5503382, 5503807, 5504774, 5504043, 5504523, 5504270, 5505254, 5504120, 5504627, 5505556, 5504132, 5504367, 5505335, 5505531, 5506467], "A": [5506294, 5502978, 5502598, 5506281, 5502656, 5503030, 5502618, 5503447, 5502632, 5502661, 5503380, 5502677, 5504082, 5503223, 5503562, 5502845, 5503131, 5502839], "D": [5505050, 5520106, 5520007, 5519986, 5519964, 5506569, 5511181, 5506448, 5507217, 5507459, 5508461, 5507914, 5507225, 5505749, 5506239, 5511657, 5508760, 5509213, 5508509, 5507842, 5508103, 5509597, 5508261, 5509314, 5509273], "E": [5518045]}, "name": "E. Circling Round Treasures", "statement": "You have a map as a rectangle table. Each cell of the table is either an\r\nobstacle, or a treasure with a certain price, or a bomb, or an empty\r\ncell. Your initial position is also given to you.You can go from one\r\ncell of the map to a side-adjacent one. At that, you are not allowed to\r\ngo beyond the borders of the map, enter the cells with treasures,\r\nobstacles and bombs. To pick the treasures, you need to build a closed\r\npath (starting and ending in the starting cell). The closed path mustn\u2019t\r\ncontain any cells with bombs inside. Let\u2019s assume that the sum of the\r\ntreasures\u2019 values that are located inside the closed path equals , and\r\nbesides, you\u2019ve made single moves (from one cell to another) while you\r\nwere going through the path, then such path brings you the profit of\r\nrubles.Your task is to build a closed path that doesn\u2019t contain any\r\nbombs and brings maximum profit.Note that the path can have\r\nself-intersections. In order to determine if a cell lies inside a path\r\nor not, use the following algorithm: Assume that the table cells are\r\npoints on the plane (the table cell on the intersection of the -th\r\ncolumn and the -th row is point ). And the given path is a closed\r\npolyline that goes through these points. You need to find out if the\r\npoint of the table that is not crossed by the polyline lies inside the\r\npolyline. Let\u2019s draw a ray that starts from point and does not intersect\r\nother points of the table (such ray must exist). Let\u2019s count the number\r\nof segments of the polyline that intersect the painted ray. If this\r\nnumber is odd, we assume that point (and consequently, the table cell)\r\nlie inside the polyline (path). Otherwise, we assume that it lies\r\noutside.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define print(x) cout << x << endl\n#define input(x) cin >> x\n\nconst int mx[] = {1, 0, -1, 0};\nconst int my[] = {0, 1, 0, -1};\n\nconst int SIZE = 30;\nconst int GOLD = 8;\n\nstruct point {\n    int x, y;\n    point(){}\n    point(int ix, int iy): x(ix), y(iy){}\n};\n\nstruct node {\n    point p;\n    int status;\n    \n    node(){}\n    node(int ix, int iy, int istatus): p(ix, iy), status(istatus) {};\n};\n\nint n,m;\nint gold, bomb;\nchar maze[SIZE][SIZE];\nint status[SIZE][SIZE];\nchar visit[SIZE][SIZE][1 << GOLD];\nint step[SIZE][SIZE][1 << GOLD];\nint sum[1 << GOLD];\nint v[SIZE];\n\npoint st;\n\nvoid bfs()\n{\n    queue<node> q;\n    visit[st.y][st.x][0] = 1;\n    q.push(node(st.x, st.y, 0));\n    \n    while (!q.empty()) {\n        node now = q.front();\n        q.pop();\n        int x = now.p.x, y = now.p.y, nowst = now.status;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + mx[i], ny = y + my[i];\n            \n            if (nx < 0 || nx == m || \n                    ny < 0 || ny == n || \n                    maze[ny][nx] != '.') continue;\n            \n            int nst = nowst;\n            \n            if (my[i] == 1) nst ^= status[ny][nx];\n            else if (my[i] == -1) nst ^= status[y][x];\n            \n            if (visit[ny][nx][nst]) {\n                continue;\n            }\n            \n            visit[ny][nx][nst] = 1;\n            q.push(node(nx, ny, nst));\n            \n            step[ny][nx][nst] = step[y][x][nowst] + 1;\n        }\n    }\n}\n\nint main()\n{\n    input(n >> m);\n    gold = bomb = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", maze[i]);\n        for (int j = 0; j < m; j++) {\n            if (maze[i][j] == 'S') {\n                st = point(j, i);\n                maze[i][j] = '.';\n            } else if (isdigit(maze[i][j])) {\n                gold++;\n                int nr = maze[i][j] - '1';\n                for (int k = j + 1; k < m; k++)\n                    status[i][k] |= 1 << nr;\n            }\n        }\n    }\n    for (int i = 0; i < gold; i++) {\n        input(v[i]);\n    }\n    for (int i = 0; i < (1 << gold); i++) {\n        for (int j = 0; j < gold; j++) {\n            if (i & (1 << j)) sum[i] += v[j];\n        }\n    }\n    \n    bomb = gold;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (maze[i][j] == 'B') {\n                for (int k = j + 1; k < m; k++) {\n                    status[i][k] |= 1 << bomb;\n                }\n                bomb++;\n            }\n        }\n    }\n    bfs();\n    int ans = 0;\n    for (int i = 0; i < (1 << gold); i++) {\n        if (visit[st.y][st.x][i]) {\n            ans = max(ans, sum[i] - step[st.y][st.x][i]);\n        }\n    }\n    print(ans);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "shortest paths"], "dificulty": "2600", "interactive": false}