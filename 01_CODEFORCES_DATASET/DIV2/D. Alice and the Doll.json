{"link": "https://codeforces.com//contest/1236/problem/D", "problemId": "442396", "problem_idx": "D", "shortId": "1236D", "contest_number": "1236", "problem_submissions": {"F": [62811108], "E": [62897948, 62812842, 62804306, 62804069, 62813891, 62807146, 62814095, 62805221, 62811322, 62812238, 62805891, 62807935, 62864987, 62832474], "D": [62802950, 62812650, 62812836, 62802625, 62815190, 62803700, 62813698, 62812781, 62814654, 62821887, 62803442, 62805006, 62803249, 62804002, 62802909, 62805902, 62806423], "C": [62792622, 62791071, 62789610, 62791879, 62789897, 62794126, 62795764, 62792967, 62790282, 62793895, 62789462, 62790719, 62789824, 62786960, 62793187, 62790332, 62791408, 62792941], "B": [62786209, 62787426, 62787186, 62788924, 62792966, 62790776, 62793499, 62788719, 62790312, 62785414, 62786772, 62787247, 62786648, 62784848, 62788974, 62787295, 62787730, 62787714], "A": [62784582, 62784627, 62784321, 62785968, 62783805, 62784292, 62799939, 62784596, 62785095, 62790291, 62784662, 62784215, 62784012, 62783846, 62784720, 62784658, 62784976, 62784753]}, "name": "D. Alice and the Doll", "statement": "Alice got a new doll these days. It can even walk!Alice has built a maze\r\nfor the doll and wants to test it. The maze is a grid with n rows and m\r\ncolumns. There are k obstacles, the i-th of them is on the cell (x_i,\r\ny_i), which means the cell in the intersection of the x_i-th row and the\r\ny_i-th column.However, the doll is clumsy in some ways. It can only walk\r\nstraight or turn right at most once in the same cell (including the\r\nstart cell). It cannot get into a cell with an obstacle or get out of\r\nthe maze.More formally, there exist 4 directions, in which the doll can\r\nlook: The doll looks in the direction along the row from the first cell\r\nto the last. While moving looking in this direction the doll will move\r\nfrom the cell (x, y) into the cell (x, y + 1); The doll looks in the\r\ndirection along the column from the first cell to the last. While moving\r\nlooking in this direction the doll will move from the cell (x, y) into\r\nthe cell (x + 1, y); The doll looks in the direction along the row from\r\nthe last cell to first. While moving looking in this direction the doll\r\nwill move from the cell (x, y) into the cell (x, y - 1); The doll looks\r\nin the direction along the column from the last cell to the first. While\r\nmoving looking in this direction the doll will move from the cell (x, y)\r\ninto the cell (x - 1, y). .Standing in some cell the doll can move into\r\nthe cell in the direction it looks or it can turn right once. Turning\r\nright once, the doll switches it\u2019s direction by the following rules: 1\r\nto 2, 2\r\nto 3, 3\r\nto 4, 4\r\nto 1. Standing in one cell, the doll can make at most one turn right.Now\r\nAlice is controlling the doll\u2019s moves. She puts the doll in of the cell\r\n(1, 1) (the upper-left cell of the maze). Initially, the doll looks to\r\nthe direction 1, so along the row from the first cell to the last. She\r\nwants to let the doll walk across all the cells without obstacles\r\nexactly once and end in any place. Can it be achieved?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\ntypedef long long ll;\n\nconst int N = 1e5+5;\nset<int> iToj[N];\nset<int> jToi[N];\n\nsigned main() {\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    for(int i=0;i<k;++i){\n        int I,J;\n        cin>>I>>J;\n        iToj[I].insert(J);\n        jToi[J].insert(I);\n    }\n    int mni = 0, mxi = n+1, mnj = 0, mxj = m+1;\n    pair<int, int> pos = {1,1};\n    int dir = 0;\n    int cnt = 1;\n    bool First = true;\n    while(true) {\n        assert(!iToj[pos.first].count(pos.second));//remove\n        //cout << \"here, cnt: \" << cnt << endl;\n        //cout << \"here, pos: \" << pos.first << ' '<< pos.second << endl;\n        //cout << \"bounds: \"<< mni << ' ' << mnj << ' ' << mxi << ' ' << mxj << endl;\n            //cout << \"\\n\\n\";\n        if(dir == 0) {\n            pair<int,int> next = pos;\n            next.second = mxj-1;\n            auto it = iToj[pos.first].upper_bound(pos.second);\n            if(it != iToj[pos.first].end()) {\n                next.second = min(next.second, *it-1);\n            }\n            if(next.second <= pos.second) {\n                if(First) {\n                    dir = (dir+1)%4;\n                    First = false;\n                    continue;\n                }\n                break;\n            }\n            cnt += next.second - pos.second;\n            mxj = next.second;\n            mni = next.first;\n            pos = next;\n        } else if(dir == 1) {\n\n\n            pair<int,int> next = pos;\n            next.first = mxi-1;\n            auto it = jToi[pos.second].upper_bound(pos.first);\n            if(it != jToi[pos.second].end()) {\n                next.first = min(next.first, *it-1);\n            }\n            if(next.first <= pos.first) {\n                //cout << \"deuaslfj\\n\";\n                break;\n            }\n\n            cnt += next.first - pos.first;\n            mxi = next.first;\n            mxj = next.second;\n            pos = next;\n\n\n\n        } else if(dir == 2) {\n            pair<int,int> next = pos;\n            next.second = mnj+1;\n            auto it = iToj[pos.first].lower_bound(pos.second);\n            if(it != iToj[pos.first].begin()) {\n                --it;\n                next.second = max(next.second, *it+1);\n            }\n            if(next.second >= pos.second) {\n\n                break;\n            }\n            cnt += pos.second - next.second;\n            mnj = next.second;\n            mxi = next.first;\n            pos = next;\n\n        } else {\n            pair<int,int> next = pos;\n            next.first = mni+1;\n            auto it = jToi[pos.second].lower_bound(pos.first);\n            if(it != jToi[pos.second].begin()) {\n                --it;\n                next.first = max(next.first, *it+1);\n            }\n            if(next.first >= pos.first) {\n\n                break;\n            }\n            cnt += pos.first - next.first;\n            mni = next.first;\n            mnj = next.second;\n            pos = next;\n\n        }\n        dir = (dir+1)%4;\n        First = false;\n    }\n    //cout << \"cnt: \" << cnt << endl;\n    cout << (cnt + k == n*m ? \"Yes\":\"No\");\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "greedy", "implementation"], "dificulty": "2300", "interactive": false}