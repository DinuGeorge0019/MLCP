{
    "link": "https://codeforces.com//contest/1802/problem/E",
    "problemId": "1817558",
    "problem_idx": "E",
    "shortId": "1802E",
    "contest_number": "1802",
    "problem_submissions": {
        "F": [
            196663888,
            196625008,
            196625749,
            196635602,
            196634743,
            196643091,
            196651329,
            196656599,
            196633915,
            196648089,
            196652202,
            196632881,
            196638320,
            196651695,
            196637871,
            196638608,
            196644590,
            196711680
        ],
        "G": [
            196633429,
            196750849
        ],
        "A": [
            196608625,
            196601765,
            196601430,
            196604403,
            196601551,
            196601415,
            196601637,
            196621554,
            197609656,
            196604338,
            196602290,
            196601755,
            196624562,
            196602593,
            196601829,
            196602885,
            196603556,
            196602800,
            196601750,
            196602859,
            196601468
        ],
        "C": [
            196603858,
            196634826,
            196613689,
            196616450,
            196615629,
            196606590,
            196615213,
            196643285,
            196614451,
            196642605,
            196612216,
            196636938,
            196666118,
            196610483,
            196616792,
            196626477,
            196610562,
            196619309,
            196615002,
            196608792
        ],
        "D": [
            196603459,
            196611669,
            196611547,
            196620657,
            196623482,
            196612856,
            196623750,
            196629627,
            197067794,
            196623474,
            196620294,
            196724558,
            196619887,
            196617809,
            196618077,
            196620127,
            196622956,
            196623094,
            196616226
        ],
        "B": [
            196601817,
            196604589,
            196605912,
            196607950,
            196604989,
            196602908,
            196605368,
            196624195,
            197609716,
            196611451,
            196608455,
            196605092,
            196630916,
            196608589,
            196607012,
            196607509,
            196609282,
            196615569,
            196605751,
            196607659,
            196606374
        ],
        "E": [
            196616155,
            196623146,
            196626388,
            196631009,
            196622442,
            196634549,
            196631368,
            196632011,
            196635287,
            196622016,
            196653867,
            196631106,
            196668550,
            196632178,
            196624422,
            196629837,
            196626927,
            196632190,
            196635404
        ]
    },
    "name": "E. Music Festival",
    "statement": "The boy Vitya loves to listen to music very much. He knows that n albums\r\nare due to be released this Friday, i-th of which contains k_i tracks.\r\nOf course, Vitya has already listened to all the tracks, and knows that\r\nin the i-th album, the coolness of the j-th track is equal to\r\na_{i,j}.Vitya has a friend Masha, whom he really wants to invite to the\r\nfestival, where his favorite bands perform. However, in order for a\r\nfriend to agree, she must first evaluate the released novelties. Vitya\r\nknows that if Masha listens to a track that was cooler than all the\r\nprevious ones, she will get 1 unit of impression. Unfortunately, albums\r\ncan only be listened to in their entirety, without changing the songs in\r\nthem in places.Help Vitya find such an order of albums so that Masha’s\r\nimpression turns out to be as much as possible, and she definitely went\r\nto the festival with him.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<n;++i)\n#define repn(i,n) for(int i=1;i<=n;++i)\n#define LL long long\n#define fi first\n#define se second\n#define pb push_back\n#define mpr make_pair\n\nvoid fileio()\n{\n  #ifdef LGS\n  freopen(\"in.txt\",\"r\",stdin);\n  freopen(\"out.txt\",\"w\",stdout);\n  #endif\n}\nvoid termin()\n{\n  #ifdef LGS\n  std::cout<<\"\\n\\nEXECUTION TERMINATED\";\n  #endif\n  exit(0);\n}\n\nusing namespace std;\n\nint t,n;\nvector <pair <int,vector <int> > > v;\nvector <int> dsc;\n\nint getDSC(int x){return lower_bound(dsc.begin(),dsc.end(),x)-dsc.begin();}\n\nnamespace st\n{\n  int n2,dat[800010];\n  void upd(int k,int val)\n  {\n    dat[k]=max(dat[k],val);\n    while(k>0)\n    {\n      k=(k-1)/2;\n      dat[k]=max(dat[k],val);\n    }\n  }\n  int qry(int k,int lb,int ub,int tlb,int tub)\n  {\n    if(ub<tlb||tub<lb) return 0;\n    if(tlb<=lb&&ub<=tub) return dat[k];\n    return max(qry(k+k+1,lb,(lb+ub)/2,tlb,tub),qry(k+k+2,(lb+ub)/2+1,ub,tlb,tub));\n  }\n}\n\nint main()\n{\n  fileio();\n\n  cin>>t;\n  rep(tn,t)\n  {\n    cin>>n;\n    v.clear();dsc.clear();\n    rep(i,n)\n    {\n      int x,y,mx=-1e9;vector <int> tmp;\n      scanf(\"%d\",&x);\n      rep(j,x)\n      {\n        scanf(\"%d\",&y);\n        mx=max(mx,y);tmp.pb(y);dsc.pb(y);\n      }\n      v.pb(mpr(mx,tmp));\n    }\n    sort(v.begin(),v.end());\n    sort(dsc.begin(),dsc.end());dsc.erase(unique(dsc.begin(),dsc.end()),dsc.end());\n    rep(i,v.size()) rep(j,v[i].se.size()) v[i].se[j]=getDSC(v[i].se[j]);\n    st::n2=1;while(st::n2<dsc.size()) st::n2*=2;\n    rep(i,st::n2*2+3) st::dat[i]=0;\n    rep(i,v.size())\n    {\n      vector <int> premx;\n      int mx=-1;\n      rep(j,v[i].se.size()) if(v[i].se[j]>mx)\n      {\n        mx=v[i].se[j];\n        premx.pb(mx);\n      }\n      int opt=-1;\n      rep(i,premx.size())\n      {\n        int lb=(i==0 ? 0:premx[i-1]),ub=premx[i]-1;\n        int val=st::qry(0,0,st::n2-1,lb,ub)+premx.size()-i;\n        opt=max(opt,val);\n      }\n      st::upd(premx.back()+st::n2-1,opt);\n    }\n    cout<<st::dat[0]<<endl;\n  }\n  \n  termin();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Music Festival.json",
    "editorial_link": "https://codeforces.com//blog/entry/113857",
    "editorial": "Let's introduce the concept of a compressed album for an album, which is obtained from the original one by removing all elements except those that are the first maxima on their corresponding prefixes.\n\nFor example:\n\nFor the album [1,4,4,3,6,5,6]\n the album will be compressed [1,4,6]\n.\n\nNow we note that the solution of the original problem is reduced to solving the same problem, but on compressed albums. Indeed, the answer to them will not be different, because if some element increased the impression on ordinary albums, then it will increase if you compress albums and vice versa. Next, it will be assumed that all albums have been compressed beforehand.\n\nLet's introduce dpc\n  the maximum impression that can be obtained if there were no albums such that they have elements larger than c\n. Then, dpc\n is equal to dpc?1\n, or you can add another element or two if c\n is the maximum element for some album. Then for all compressed albums, it can be recalculated through the value of dp\n at the point before the first element of the album, or through c?1\n. Thus, for recalculation, it is enough to know for each c\n which albums ended in this index, as well as for each album its first element. Solution for O(K)\n\nLet's now solve the complete problem. For each value of c\n, let's remember the indexes of albums that contain an element equal to c\n. We go in order of increasing c\n, we maintain for each album the value of dpi\n  the maximum impression that can be obtained if there were no elements of large c\n and Masha listened to the last i\n album. Suppose for the next c\n there is an album i\n, that there is a song with the coolness of c\n in it. Then dpi\n should be taken as the maximum of dpi+1\n and the values for all dpj+1\n, such that the maximum element in the j\nth album is less than the maximum element of i\nth, since she could listen to this track, either next in this album, or after listening to some other album completely. Note that you can store the value of mx\n  maximum for all albums for which the maximum value in them is less than c\n and recalculate it when moving to c+1\n, storing those albums that have ended, then you will get a solution for O(K+C)\n.",
    "hint": []
}