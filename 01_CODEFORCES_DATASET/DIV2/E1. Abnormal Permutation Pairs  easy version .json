{
    "link": "https://codeforces.com//contest/1542/problem/E1",
    "problemId": "1034813",
    "problem_idx": "E1",
    "shortId": "1542E1",
    "contest_number": "1542",
    "problem_submissions": {
        "E2": [
            121219799,
            121223040,
            121227052,
            121233469,
            121239326,
            121234301,
            121236580,
            121235420,
            121216663,
            121238675,
            121273656,
            121296078,
            121315568
        ],
        "E1": [
            121219525,
            121218312,
            121219863,
            121224427,
            121223323,
            121227183,
            121236464,
            121219719,
            121216224,
            121238504,
            121230738,
            121231671,
            121233917,
            121231813,
            121237944,
            121234549,
            121237990,
            121237975,
            121239554,
            121315761,
            121236416
        ],
        "B": [
            121207778,
            121207035,
            121196176,
            121198996,
            121193641,
            121199916,
            121198331,
            121209692,
            121227899,
            121202669,
            121195965,
            121201409,
            121210300,
            121201851,
            121197314,
            121210832,
            121203725,
            121200105,
            121198365,
            121315719,
            121204232
        ],
        "A": [
            121204300,
            121188597,
            121188711,
            121189593,
            121188837,
            121209408,
            121188670,
            121192287,
            121228704,
            121189765,
            121189512,
            121188741,
            121190699,
            121190274,
            121188622,
            121206448,
            121191911,
            121188947,
            121188840,
            121315670,
            121198667
        ],
        "D": [
            121203495,
            121202907,
            121210273,
            121212521,
            121209354,
            121208537,
            121211787,
            121232171,
            121222572,
            121218612,
            121213056,
            121211998,
            121216674,
            121217696,
            121216064,
            121219789,
            121217032,
            121218049,
            121218313,
            121350905,
            121217984
        ],
        "C": [
            121193499,
            121197254,
            121200250,
            121203739,
            121204080,
            121201004,
            121202808,
            121205437,
            121226710,
            121208971,
            121203678,
            121205267,
            121206135,
            121204211,
            121205127,
            121202814,
            121209801,
            121207441,
            121209898,
            121315741,
            121209076
        ]
    },
    "name": "E1. Abnormal Permutation Pairs  easy version ",
    "statement": "A permutation of 1, 2,\r\nldots, n is a sequence of n integers, where each integer from 1 to n\r\nappears exactly once. For example, [2,3,1,4] is a permutation of 1, 2,\r\n3, 4, but [1,4,2,2] isn\u2019t because 2 appears twice in it.Recall that the\r\nnumber of inversions in a permutation a_1, a_2,\r\nldots, a_n is the number of pairs of indices (i, j) such that i < j and\r\na_i > a_j.Let p and q be two permutations of 1, 2,\r\nldots, n. Find the number of permutation pairs (p,q) that satisfy the\r\nfollowing conditions: p is lexicographically smaller than q. the number\r\nof inversions in p is greater than the number of inversions in q. Print\r\nthe number of such pairs modulo mod. Note that mod may not be a prime.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-'0');\n\tx*=f;\n}\nint MOD;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=505,MAXM=500005;\n\nint n;\nint s[MAXM],f[MAXN],d[MAXM],g[MAXM],h[MAXM];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n),readint(MOD);\n\ts[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=1ll*i*f[i-1]%MOD;\n\t\tg[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)g[j]=(g[j-1]+1ll*s[j]*(j+1))%MOD;\n\t\th[0]=s[0];\n\t\tfor(int j=1;j<=(i-1)*(i-2)/2;j++)h[j]=dmy(h[j-1]+s[j]);\n\t\tfor(int j=0;j<=(i-1)*(i-2)/2;j++)\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tif(j>=2)inc(tmp,g[j-2]),inc(tmp,MOD-1ll*(j-i+MOD)*h[j-2]%MOD);\n\t\t\tif(j-i-1>=0)inc(tmp,MOD-g[j-i-1]),inc(tmp,1ll*(j-i+MOD)*h[j-i-1]%MOD);\n\t\t\tinc(f[i],1ll*d[j]*tmp%MOD);\n\t\t}\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)d[j]=0;\n\t\tfor(int j=0;j<=i*(i-1)/2;j++)\n\t\t{\n\t\t\td[j]=s[j];\n\t\t\tif(j>=i)inc(d[j],MOD-s[j-i]);\n\t\t}\n\t\ts[0]=d[0];\n\t\tfor(int j=1;j<=i*(i+1)/2;j++)s[j]=dmy(s[j-1]+d[j]);\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Abnormal Permutation Pairs  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/92492",
    "editorial": "Let's first calculate the number of permutation pair (p,q)\ns (with length i\n) that p1<q1\n but inv(p)>inv(q)\n (inv(p)\n is the number of inversions in p\n). Call it ti\n.\n\nLet's enumerate p1=j\n and q1=k\n, then inv(p[2...i])?inv(q[2...i])>k?j\n. (inv(p)=inv(p[2...i])+j?1,inv(q)=inv(q[2...i])+k?1\n, with inv(p)>inv(q)\n we get the following.)\n\nPrecalculate f(i,j)\n: the number of permutation p\ns of length i\n such that inv(p)=j\n. Let s(i,j)\n be ?k?jf(i,k)\n, then:\n\nti=?1?j?i?j<k?i?wf(i?1,w)s(i?1,w?(k?j)?1)\nf\n and s\n can be calculated in O(n4)\n or O(n3)\n in the following way: if you insert i\n into a permutation of length i?1\n after the i?1?p\n-th element (0?p?i?1)\n, it will bring p\n inversions into the permutation. So f(i,j)=?j?i+1?k?jf(i?1,k)\n.\n\nAfter calculating t\n, calculating the answer it easy. Let ansi\n be the answer for n=i\n, then\n\nansi=i\u00d7ansi?1+ti\nConsider if p1=q1\n. If so, there are i\n choices of p1\n, and ansi?1\n choices of the following n?1\n numbers. Otherwise, there are ti\n choices.\n\nTotal complexity is O(n5)\n, but it can be optimized to O(n4)\n if you consider the difference between j?k\n only, and can be optimized to O(n3logn)\n using FFT with arbitary mod (which we hope can't pass E2!)."
}