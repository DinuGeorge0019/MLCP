{
    "link": "https://codeforces.com//contest/439/problem/E",
    "problemId": "10098",
    "problem_idx": "E",
    "shortId": "439E",
    "contest_number": "439",
    "problem_submissions": {
        "D": [
            6805901,
            6804419,
            6803200,
            6805988,
            6804881,
            6805810,
            6805384,
            6806017,
            6807497,
            6805650,
            6808014,
            6804059,
            6806158,
            6805574,
            6805399,
            6806326,
            6804741,
            6806396,
            6808041
        ],
        "E": [
            6803795,
            6806475,
            6805122,
            6808945,
            6805874,
            6808804,
            6804029,
            6812447,
            6809672,
            6805934,
            7363028
        ],
        "C": [
            6800932,
            6800886,
            6803463,
            6802772,
            6807376,
            6802931,
            6803473,
            6802763,
            6804861,
            6803810,
            6804665,
            6808359,
            6803941,
            6812392,
            6803612,
            6803230
        ],
        "B": [
            6798509,
            6800129,
            6798401,
            6799435,
            6798872,
            6811724,
            6799339,
            6807876,
            6800630,
            6798132,
            6800776,
            6807661,
            6800880,
            6806303,
            6802646,
            6801021,
            6799365,
            6798816,
            6798888
        ],
        "A": [
            6798027,
            6801375,
            6797956,
            6798638,
            6798087,
            6798192,
            6808386,
            6799422,
            6799363,
            6798034,
            6798516,
            6806347,
            6798287,
            6808882,
            6801124,
            6798895,
            6798307,
            6798019,
            6798088
        ]
    },
    "name": "E. Devu and Birthday Celebration",
    "statement": "Today is Devu\u2019s birthday. For celebrating the occasion, he bought sweets\r\nfrom the nearby market. He has invited his friends. He would like to\r\ndistribute the sweets among them. As he is a nice guy and the occasion\r\nis great, he doesn\u2019t want any friend to be sad, so he would ensure to\r\ngive at least one sweet to each friend. He wants to celebrate it in a\r\nunique style, so he would like to ensure following condition for the\r\ndistribution of sweets. Assume that he has distributed sweets to his\r\nfriends such that friend is given sweets. He wants to make sure that\r\nthere should not be any positive integer , which divides every .Please\r\nfind the number of ways he can distribute sweets to his friends in the\r\nrequired way. Note that the order of distribution is important, for\r\nexample [1, 2] and [2, 1] are distinct distributions. As the answer\r\ncould be very large, output answer modulo .To make the problem more\r\ninteresting, you are given . Each query contains an , pair. For each\r\nquery please output the required number of ways modulo .\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<\"OK\";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 200100\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(\"a.in\");\nofstream g(\"a.out\");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nll S;\nint divu[N],n,di,val,aux,t,q,lim,po,nrb,nf;\nll I[N],F[N],adn;\nll put(ll a,ll p)\n{\n    ll sol=1;\n    while(p)\n    {\n        if(p&1)\n            sol=sol*a%mod;\n        a=a*a%mod;\n        p>>=1;\n    }\n    return sol;\n}\nll C(int a,int b)\n{\n    return F[a]*I[b]%mod*I[a-b]%mod;\n}\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"a.in\",\"r\",stdin);\n    freopen(\"a.out\",\"w\",stdout);\n    #endif\n    \n    F[0]=1;\n    FOR(i,1,200001)\n    F[i]=F[i-1]*i%mod;\n    I[200001]=put(F[200001],mod-2);\n    ROF(i,200000,0)\n    I[i]=I[i+1]*(i+1)%mod;\n    \n    f>>q;\n    \n    while(q--)\n    {\n        f>>n>>nf;\n        aux=n;\n        t=0;\n        for(int i=2;i*i<=aux;++i)\n            if(aux%i==0)\n            {\n                divu[++t]=i;\n                while(aux%i==0)\n                    aux/=i;\n            }\n        if(aux!=1)\n            divu[++t]=aux;\n        lim=(1<<t);\n        lim--;\n        S=0;\n        FOR(i,1,lim)\n        {\n            aux=i;\n            nrb=0;\n            po=0;\n            di=1;\n            while(aux)\n            {\n                ++po;\n                if(aux&1)\n                {\n                    nrb++;\n                    di*=divu[po];\n                }\n                aux>>=1;\n            }\n            if(n/di<nf)\n                continue;\n            val=n/di;\n            val-=nf;\n            adn=C(nf+val-1,nf-1);\n            if(nrb&1)\n                S+=adn;\n            else\n                S-=adn;\n            if(S>=mod)\n                S-=mod;\n            if(S<0)\n                S+=mod;\n        }\n        S=-S;\n        if(S<0)\n            S+=mod;\n        n-=nf;\n        S+=C(nf+n-1,nf-1);\n        if(S>=mod)\n            S-=mod;\n        g<<S<<\"\\n\";\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Devu and Birthday Celebration.json",
    "editorial_link": "https://codeforces.com//blog/entry/12545",
    "editorial": "There are two possible solutions. dp solution Let be total number of\r\nways of partitioning into segments such that each is positive. With some\r\nmanipulations of the generating function, you can find that this is\r\nequal to . So Let denotes partitions of into parts such that gcd of all\r\nthe is . Note that = sum of over all possible gcd . So will be a divisor\r\nof . In other words, As . You can implement this solution by a simple\r\ndp. You can pre-calculate factorials which will help you to calculate .\r\nComplexity of this solution will be over all the test cases. Please note\r\nthat this solution might get time limit exceeded in Java. Please read\r\nthe comment. Mathematical solution Note that sum of over all possible\r\ngcd ( such that is a divisor of . In other words, As = . Now you have to\r\nuse M bius inversion formula. Theorem: If and are two arithmetic\r\nfunctions satisfying then So In our case: is and is . For proving\r\ncomplexity: Use the fact that total number of divisors of a number from\r\nto is Please also see xorfire comment for understanding the relation\r\nbetween mobius function and the solution using inclusion exclusion\r\nprinciple. Solution Codes\r\n"
}