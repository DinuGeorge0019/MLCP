{
    "link": "https://codeforces.com//contest/1929/problem/F",
    "problemId": "2478908",
    "problem_idx": "F",
    "shortId": "1929F",
    "contest_number": "1929",
    "problem_submissions": {
        "F": [
            246533325,
            246531273,
            246535602,
            246537728,
            248473670,
            248472907,
            246536511,
            246538004,
            246539955,
            246545257,
            246545291,
            246547847,
            246517420,
            246543420,
            246541449,
            246549298,
            246540895,
            246550782,
            246552572,
            246538786,
            246556383,
            246551792
        ],
        "E": [
            246526711,
            246525335,
            246529920,
            246532407,
            247710837,
            246542700,
            246542158,
            246542829,
            246536287,
            246540991,
            246540586,
            246556061,
            246534976,
            246548547,
            246541367,
            246546569,
            246545920,
            246542715,
            246562305,
            246543807,
            246546073
        ],
        "D": [
            246514987,
            246516364,
            246523834,
            246521878,
            246527738,
            246529658,
            246525748,
            246524974,
            246530714,
            246530595,
            246536018,
            246517832,
            246533128,
            246527574,
            246529579,
            246532376,
            246528687,
            246524837,
            246531715,
            246527894
        ],
        "C": [
            246504265,
            246506492,
            246509311,
            246511086,
            246512939,
            246522191,
            246515413,
            246514318,
            246521012,
            246518198,
            246522829,
            246597787,
            246545456,
            246513164,
            246517021,
            246521174,
            246507321,
            246517238,
            246512362,
            246508483,
            246515953
        ],
        "B": [
            246496908,
            246510099,
            246501616,
            246503108,
            246502307,
            246506254,
            246501930,
            246507459,
            246501810,
            246507250,
            246508662,
            246503154,
            246500767,
            246506410,
            246511238,
            246501517,
            246502536,
            246501220,
            246501502,
            246503229
        ],
        "A": [
            246490029,
            246489425,
            246489778,
            246493551,
            246491292,
            246506396,
            246489787,
            246490848,
            246490635,
            246492686,
            246490767,
            246500334,
            246491854,
            246491116,
            246490960,
            246489189,
            246491592,
            246489513,
            246489387,
            246490308
        ]
    },
    "name": "F. Sasha and the Wedding Binary Search Tree",
    "statement": "Having overcome all the difficulties and hardships, Sasha finally\r\ndecided to marry his girlfriend. To do this, he needs to give her an\r\nengagement ring. However, his girlfriend does not like such romantic\r\ngestures, but she does like binary search trees^{\r\ndagger}. So Sasha decided to give her such a tree.After spending a lot\r\nof time on wedding websites for programmers, he found the perfect binary\r\nsearch tree with the root at vertex 1. In this tree, the value at vertex\r\nv is equal to val_v.But after some time, he forgot the values in some\r\nvertices. Trying to remember the found tree, Sasha wondered how many\r\nbinary search trees could he have found on the website, if it is known\r\nthat the values in all vertices are integers in the segment [1, C].\r\nSince this number can be very large, output it modulo 998\r\n,244\r\n,353.^{\r\ndagger}A binary search tree is a rooted binary tree in which for any\r\nvertex x, the following property holds: the values of all vertices in\r\nthe left subtree of vertex x (if it exists) are less than or equal to\r\nthe value at vertex x, and the values of all vertices in the right\r\nsubtree of vertex x (if it exists) are greater than or equal to the\r\nvalue at vertex x.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint tl[500005],tr[500005],val[500005];\nint zh[500005],cnt;\nint ny[500005];\nvoid dfs(int x)\n{\n\tif(x==-1)return;\n\tdfs(tl[x]);\n\tzh[++cnt]=val[x];\n\tdfs(tr[x]);\n}\nint main()\n{\n\tny[1]=1;\n\tfor(int i=2;i<=500000;i++)ny[i]=1LL*(mod-mod/i)*ny[mod%i]%mod;\n\tint t,n,c;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tc=read();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\ttl[i]=read();\n\t\t\ttr[i]=read();\n\t\t\tval[i]=read();\n\t\t}\n\t\tcnt=0;\n\t\tdfs(1);\n\t\t//for(int i=1;i<=cnt;i++)printf(\"%d \",zh[i]);\n\t\t//printf(\"\\n\");\n\t\tint pre=1,xb=0,ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(zh[i]!=-1)\n\t\t\t{\n\t\t\t\tint sx=zh[i]-pre+i-xb-1;\n\t\t\t\tfor(int j=1;j<=i-xb-1;j++)\n\t\t\t\t{\n\t\t\t\t\tans=1LL*ans*(sx+mod-j+1)%mod*ny[j]%mod;\n\t\t\t\t}\n\t\t\t\tpre=zh[i];\n\t\t\t\txb=i;\n\t\t\t}\n\t\t}\n\t\tif(xb!=n)\n\t\t{\n\t\t\tint sx=c-pre+n-xb;\n\t\t\tfor(int j=1;j<=n-xb;j++)\n\t\t\t{\n\t\t\t\tans=1LL*ans*(sx+mod-j+1)%mod*ny[j]%mod;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "data structures",
        "dfs and similar",
        "math",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Sasha and the Wedding Binary Search Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/125943",
    "editorial": "Let's list the numbers of vertices in the order of their values. Let it be v1,\u0085,vn\n. Then it must satisfy valuevi?valuevi+1\n.\n\nThen we have some segments in this order for which we do not know the values. For each segment, we know the maximum and minimum value that the values in this segment can take, let's say L\n and R\n. Then we need to choose a value from the interval (L,R)\n for each number in this segment in order to maintain the relative order. This is a known problem, and there are (R?L+lenlen)\n possible ways to do this, where len\n is the length of the segment. Then we need to multiply all these binomial coefficients.\n\nNow, notice that R?L+len\n is large, so for calculation we can simply use the formula (nk)=n?(n?1)?\u0085?(n?k+1)k!\n, since the sum len\n does not exceed n\n."
}