{
    "link": "https://codeforces.com//contest/935/problem/F",
    "problemId": "158426",
    "problem_idx": "F",
    "shortId": "935F",
    "contest_number": "935",
    "problem_submissions": {
        "E": [
            35490294,
            35492393,
            35493358,
            35495709,
            35495541,
            35493647,
            35499422,
            35499276,
            35500262,
            35500719,
            35500162,
            35500658,
            35500728,
            35499258,
            35501222,
            35495668,
            35497342,
            35498886
        ],
        "D": [
            35486074,
            35488065,
            35489775,
            35490762,
            35489358,
            35485225,
            35484887,
            35488795,
            35492000,
            35489470,
            35491505,
            35486948,
            35491669,
            35491916,
            35491520,
            35489051,
            35488153,
            35487210
        ],
        "C": [
            35484257,
            35486190,
            35486639,
            35485548,
            35486272,
            35495170,
            35490125,
            35484897,
            35485714,
            35486561,
            35487356,
            35493330,
            35488504,
            35487181,
            35485279,
            35490239
        ],
        "B": [
            35480395,
            35480198,
            35480227,
            35479698,
            35479918,
            35483145,
            35479197,
            35480428,
            35479972,
            35480181,
            35482318,
            35482750,
            35481424,
            35486459,
            35478821,
            35479749,
            35480541,
            35480932
        ],
        "A": [
            35478116,
            35476883,
            35477273,
            35476648,
            35476835,
            35476757,
            35476798,
            35478023,
            35477705,
            35477042,
            35477472,
            35478918,
            35478074,
            35478028,
            35476637,
            35476753,
            35478890,
            35477831
        ],
        "F": [
            42089787,
            35507058
        ]
    },
    "name": "F. Fafa and Array",
    "statement": "Fafa has an array of positive integers, the function is defined as . He\r\nwants to do queries of two types: find the maximum possible value of ,\r\nif is to be added to one element in the range . You can choose to which\r\nelement to add . increase all the elements in the range by value . Note\r\nthat queries of type don’t affect the array elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> p;\nconst int P=270000,N=100010;\nconst ll INF=1e18;\nlong long a[N],st[P],sum;\nlong long cat(int x){\n\treturn max(a[x-1],0ll)+max(-a[x],0ll);\n}\nint u,n,q;\nvoid build(){\n\tfor (u=1; u<n; u<<=1); --u;\n\tfor (int i=1; i<=n; ++i) st[u+i]=cat(i);\n\tfor (int i=n+1; i<=u+1; ++i) st[u+i]=INF;\n\tfor (int i=u; i; --i) st[i]=min(st[i<<1],st[i<<1|1]);\n}\nvoid update(int x){\n\tlong long v=cat(x);\n\tfor (x+=u,st[x]=v,x>>=1; x; x>>=1) st[x]=min(st[x<<1],st[x<<1|1]);\n}\nlong long ask(int s,int t){\n\tlong long ret=INF;\n\tfor (s+=u-1,t+=u+1; s^t^1; s>>=1,t>>=1){\n\t\tif (~s&1) ret=min(ret,st[s^1]);\n\t\tif (t&1) ret=min(ret,st[t^1]);\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; ++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1; i<n; ++i) a[i]-=a[i+1];\n\tfor (int i=1; i<n; ++i) sum+=abs(a[i]);\n\t--n;\n\tbuild();\n\tscanf(\"%d\",&q);\n\tfor (int i=1; i<=q; ++i){\n\t\tint tp,l,r,v;\n\t\tscanf(\"%d%d%d%d\",&tp,&l,&r,&v);\n\t\tif (tp==1){\n\t\t\tlong long ret=-INF;\n\t\t\tif (l==1){\n\t\t\t\tret=max(ret,v-max(-a[1],0ll));\n\t\t\t\t++l;\n\t\t\t}\n\t\t\tif (r>n){\n\t\t\t\tret=max(ret,v-max(a[n],0ll));\n\t\t\t\t--r;\n\t\t\t}\n\t\t\tif (l<r){\n\t\t\t\tret=max(0ll,max(ret,2*(v-ask(l,r))));\n\t\t\t}\n\t\t\telse if (l==r){\n\t\t\t\tret=max(ret,max(v-2*max(a[l-1],0ll),-(ll)v)+max(v-2*max(-a[l],0ll),-(ll)v));\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",sum+ret);\n\t\t}\n\t\telse{\n\t\t\tif (l>1){\n\t\t\t\tsum-=abs(a[l-1]);\n\t\t\t\ta[l-1]-=v;\n\t\t\t\tupdate(l-1);\n\t\t\t\tsum+=abs(a[l-1]); \n\t\t\t}\n\t\t\tif (r<=n){\n\t\t\t\tsum-=abs(a[r]);\n\t\t\t\ta[r]+=v;\n\t\t\t\tupdate(r);\n\t\t\t\tsum+=abs(a[r]);\n\t\t\t}\n\t\t\tif (l<=n) update(l);\n\t\t\tif (r<n) update(r+1);\n\t\t}\n//\t\tfor (int i=1; i<=n; ++i) printf(\"%lld \",a[i]); putchar('\\n'); cerr<<\"sum\"<<sum<<\" \"<<cat(3)<<\" \"<<cat(4)<<\" \"<<cat(5)<<\" \"<<ask(3,5)<<endl;\n//\t\tfor (int i=1; i<=20; ++i) printf(\"%lld \",st[i]==INF?-1:st[i]); puts(\"\");\n\t}\n}\n/*\n7\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\n10\n2 2 3 1000000000\n2 5 6 1000000000\n2 2 2 1000000000\n2 6 6 1000000000\n2 2 6 1000000000\n1 3 5 1000000000\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Fafa and Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/57889",
    "editorial": "Letâs have a look at the relation of each element with its adjacent\r\nelements. Without loss of generality, assume has two adjacent elements\r\nand where . One of the following cases will hold for , and : and . and .\r\nand . For a query : if there exists an element , where , such that case\r\nholds, then it is the best element on which we can apply the add\r\noperation because it will increment by . if case doesnât exist, then\r\nthere is at most one element for which case holds (you can prove this by\r\ncontradiction). Letâs assume that this case holds for element , where .\r\nThen we will either: increment the element where , and . The value of\r\nwill be incremented by . increment the element . The value of will be\r\nincremented by . if neither case nor case exists, then we can only the\r\nsecond option of the previous case.For a query : the only affected\r\nelements will be .We can use segment trees to answer queries in\r\ntime.Complexity:\r\n",
    "hint": []
}