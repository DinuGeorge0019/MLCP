{
    "link": "https://codeforces.com//contest/148/problem/D",
    "problemId": "882",
    "problem_idx": "D",
    "shortId": "148D",
    "contest_number": "148",
    "problem_submissions": {
        "D": [
            1139191,
            1138652,
            1138343,
            1139931,
            1138050,
            1141845,
            1137541,
            1139093,
            1141226,
            1140900,
            1138905,
            1138670,
            1137683
        ],
        "E": [
            1138985,
            1140513,
            1139519,
            1141488,
            1139717,
            1140284,
            1142221,
            1139946,
            1138873,
            1142635,
            1149309,
            1141182,
            1140316
        ],
        "B": [
            1135154,
            1135748,
            1135053,
            1135639,
            1140648,
            1135735,
            1134985,
            1135240,
            1135774,
            1138444,
            1134958,
            1134820,
            1135228
        ],
        "A": [
            1133841,
            1134314,
            1134164,
            1134213,
            1133731,
            1134661,
            1133747,
            1134454,
            1134132,
            1134262,
            1133778,
            1133823,
            1134119,
            1133907
        ],
        "C": [
            1137373,
            1136906,
            1137643,
            1136607,
            1138188,
            1140983,
            1141293,
            1140962,
            1139122,
            1136427,
            1137116,
            1136279
        ]
    },
    "name": "D. Bag of mice",
    "statement": "The dragon and the princess are arguing about what to do on the New\r\nYear\u2019s Eve. The dragon suggests flying to the mountains to watch fairies\r\ndancing in the moonlight, while the princess thinks they should just go\r\nto bed early. They are desperate to come to an amicable agreement, so\r\nthey decide to leave this up to chance.They take turns drawing a mouse\r\nfrom a bag which initially contains white and black mice. The person who\r\nis the first to draw a white mouse wins. After each mouse drawn by the\r\ndragon the rest of mice in the bag panic, and one of them jumps out of\r\nthe bag itself (the princess draws her mice carefully and doesn\u2019t scare\r\nother mice). What is the probability of the princess winning?If there\r\nare no more mice in the bag and nobody has drawn a white mouse, the\r\ndragon wins. Mice which jump out of the bag themselves are not\r\nconsidered to be drawn (do not define the winner). Once a mouse has left\r\nthe bag, it never returns to it. Every mouse is drawn from the bag with\r\nthe same probability as every other one, and every mouse jumps out of\r\nthe bag with the same probability as every other one.\r\n",
    "solutions": [
        "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\ndouble dp[1111][1111][2];\nbool vis[1111][1111][2];\ndouble getdp(int w,int b,int who)\n{\n    if (vis[w][b][who])return dp[w][b][who];\n    if (w+b==1)\n    {\n        if (w)return 1.0;\n        else return 0.0;\n    }\n    if (!w)return 0.0;\n    if (!b)return 1.0;\n    if (who==0)//princess \n    {\n        double p=w*1.0/(w*1.0+b*1.0);\n        double ans=p;\n        ans+=(1-p)*(1-getdp(w,b-1,!who));\n        vis[w][b][who]=1;\n        return dp[w][b][who]=ans;\n    }\n    else //dragon\n    {\n        double p=w*1.0/(w*1.0+b*1.0);\n        double ans=p;\n        //draw black\n        {\n            //out white\n            double p1=w*1.0/(w*1.0+b*1.0-1.0);\n            ans+=(1-p)*p1*(1-getdp(w-1,b-1,!who));\n            //out black\n            ans+=(1-p)*(1-p1)*(1-getdp(w,max(0,b-2),!who));\n        }\n        vis[w][b][who]=1;\n        return dp[w][b][who]=ans;\n    }\n}\nint main()\n{\n    int i,j,k,w,b;\n    cin>>w>>b;\n    clr(vis);\n    clr(dp);\n    printf(\"%.12lf\\n\",getdp(w,b,0));\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games",
        "math",
        "probabilities"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bag of mice.json",
    "editorial_link": "https://codeforces.com//blog/entry/3819",
    "editorial": "Initially this problem was a boring homework one about drawing balls out\r\nof the bag. But seriously, do you think a dragon would have something so\r\nmundane as a bag of balls in his cave? And he definitely could find some\r\nuse for a bag of mice for example, using them to scare the princess or\r\nas a snack. If mice were balls and never jumped out of the bag, the\r\nproblem would be doable in a single loop. Suppose that at some step we\r\nhave W white and B black mice left in the bag, and the probability to\r\nget into this state is P (initially W and B are input values, and P =\r\n1). The absolute probability to get a white mouse at this step is (the\r\nprobability of getting to this state, multiplied by the conditional\r\nprobability of getting white mouse). If it\u00e2\u0080\u0099s princess\u00e2\u0080\u0099 turn to draw,\r\nthis probability adds to her winning probability, otherwise her winning\r\nprobability doesn\u00e2\u0080\u0099t change. To move to the next iteration, we need the\r\ngame to continue, i.e., a black mouse to be drawn on this iteration.\r\nThis means that the number of black mice decreases by 1, and the\r\nprobability of getting to the next iteration is multiplied by . Once\r\nwe\u00e2\u0080\u0099ve iterated until we\u00e2\u0080\u0099re out of black mice, we have the answer.\r\nUnfortunately, the mice in the bag behave not as calmly as the balls.\r\nThis adds uncertainty we don\u00e2\u0080\u0099t know for sure what state we will get to\r\nafter the dragon\u00e2\u0080\u0099s draw. We\u00e2\u0080\u0099ll need a recursive solution to handle this\r\n(or dynamic programming whichever one prefers). When we solve a case for\r\n(W, B), the princess\u00e2\u0080\u0099 and the dragon\u00e2\u0080\u0099s draws are processed in a same\r\nway, but to process the mouse jumping out of the bag, we\u00e2\u0080\u0099ll need to\r\ncombine the results of solving subproblems (W, B 3) and (W 1, B 2). The\r\nrecursive function of the reference solution is: The time complexity of\r\nrecursion with memoization is O(W*B), i.e., the number of different\r\nvalues the input can take. Note that in this implementation access to\r\nthe map adds log(W*B) complexity, but you can avoid this by storing the\r\nvalues in an 2-dimensional array.\r\n"
}