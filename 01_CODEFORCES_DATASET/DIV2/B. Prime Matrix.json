{"link": "https://codeforces.com//contest/271/problem/B", "problemId": "2618", "problem_idx": "B", "shortId": "271B", "contest_number": "271", "problem_submissions": {"E": [3100960, 3101029, 3101071, 3101158, 3100866, 3102870, 3101166, 3102181, 3104424, 3101146], "D": [3097603, 3098148, 3098618, 3105470, 3097962, 3097553, 3102341, 3095933, 3103085, 3099231, 3098903, 3234423, 3234279, 3097880, 3098244, 3098489, 3098417, 3098350], "C": [3096548, 3096735, 3096791, 3098514, 3096739, 3100014, 3097999, 3096954, 3097536, 3097492, 3096753, 3096325, 3097045, 3096662, 3097008, 3099380, 3096917], "B": [3095583, 3095688, 3095491, 3095629, 3097325, 3094921, 3095378, 3095747, 3095596, 3095729, 3095110, 3095423, 3095894, 3095694, 3096439, 3095824], "A": [3094225, 3094352, 3094125, 3094074, 3095532, 3094090, 3094248, 3094063, 3094079, 3094404, 3093980, 3094108, 3094610, 3094523, 3094534, 3094629]}, "name": "B. Prime Matrix", "statement": "You\u2019ve got an matrix. The matrix consists of integers. In one move, you\r\ncan apply a single transformation to the matrix: choose an arbitrary\r\nelement of the matrix and increase it by . Each element can be increased\r\nan arbitrary number of times.You are really curious about prime numbers.\r\nLet us remind you that a is a positive integer that has exactly two\r\ndistinct positive integer divisors: itself and number one. For example,\r\nnumbers 2, 3, 5 are prime and numbers 1, 4, 6 are not. A matrix is if at\r\nleast one of the two following conditions fulfills: the matrix has a row\r\nwith prime numbers only; the matrix has a column with prime numbers\r\nonly; Your task is to count the minimum number of moves needed to get a\r\nprime matrix from the one you\u2019ve got.\r\n", "solutions": ["#include<cstdio>\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define max(x,y)    ((x)>(y)?(x):(y))\ntypedef long long LL;\nconst   int N=100008;\nLL  ans,l[1000],r[1000];\nint n,m,a,np;\nint mindiv[N],pr[N];\nint get(int x){\n    int l=0,r=np;\n    while(l+1<r){\n        int m=(l+r)>>1;\n        if(pr[m]>=x)r=m;else    l=m;;\n    }\n    return pr[r];\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n\tfor(int i=2;i<=N;i++){\n\t\tif(mindiv[i]==0)mindiv[i]=i,pr[++np]=i;\n\t\tfor(int j=1;j<=np&&pr[j]*i<=N;j++){\n\t\t\tmindiv[pr[j]*i]=pr[j];\n\t\t\tif(mindiv[i]==pr[j])break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t   for(int j=1;j<=m;j++){\n        scanf(\"%d\",&a);\n        int t=get(a)-a;\n        l[i]+=t,r[j]+=t;\n     }\t       \n    ans=2147482647000000LL;\n    for(int i=1;i<=n;i++)ans=min(ans,l[i]);\n    for(int j=1;j<=m;j++)ans=min(ans,r[j]);\n    printf(\"%I64d\\n\",ans);getchar(),getchar();\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "math", "number theory"], "dificulty": "1300", "interactive": false}