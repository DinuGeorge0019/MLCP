{
    "link": "https://codeforces.com//contest/1839/problem/D",
    "problemId": "1950161",
    "problem_idx": "D",
    "shortId": "1839D",
    "contest_number": "1839",
    "problem_submissions": {
        "D": [
            208378999,
            208378969,
            208378832,
            208349629,
            208349595,
            208328924,
            208318842,
            208320348,
            208320009,
            208322670,
            208334872,
            252078530,
            208941980,
            208322481,
            208320363,
            208321362,
            208327211,
            208323287,
            208323939,
            208326005,
            208322044,
            238787448,
            208326918,
            208338715,
            208324800,
            208326544,
            208326069,
            208328427
        ],
        "E": [
            208319512,
            208328631,
            208328272,
            208332229,
            208329987,
            208322483,
            208941985,
            208331621,
            208337019,
            208333546,
            208333532,
            208337451,
            208338255,
            208336016,
            208341143,
            238787342,
            208337777,
            208329186,
            208341540,
            208340328,
            208345193,
            208341230
        ],
        "C": [
            208312529,
            208312433,
            208313019,
            208312784,
            208314192,
            208314831,
            208941969,
            208315364,
            208314601,
            208315655,
            208313303,
            208314023,
            208311295,
            208317114,
            208312761,
            208316692,
            208311943,
            208319701,
            208315483,
            208313786,
            208316277
        ],
        "B": [
            208308892,
            208309149,
            208309789,
            208308399,
            208310012,
            208310211,
            208941953,
            208312078,
            208308633,
            208312628,
            208307832,
            208309526,
            208306915,
            208309002,
            208309419,
            208310463,
            208308132,
            208308049,
            208311860,
            208308608,
            208311306
        ],
        "A": [
            208307199,
            208306621,
            208306837,
            208306359,
            208306401,
            208306556,
            208941945,
            208307764,
            208306608,
            208308716,
            208306828,
            208306416,
            208307882,
            208306972,
            208306698,
            208306776,
            208306761,
            208306697,
            208307597,
            208306680,
            208308663
        ]
    },
    "name": "D. Ball Sorting",
    "statement": "There are n colorful balls arranged in a row. The balls are painted in n\r\ndistinct colors, denoted by numbers from 1 to n. The i-th ball from the\r\nleft is painted in color c_i. You want to reorder the balls so that the\r\ni-th ball from the left has color i. Additionally, you have k\r\nge 1 balls of color 0 that you can use in the reordering process.Due to\r\nthe strange properties of the balls, they can be reordered only by\r\nperforming the following operations: Place a ball of color 0 anywhere in\r\nthe sequence (between any two consecutive balls, before the leftmost\r\nball or after the rightmost ball) while keeping the relative order of\r\nother balls. You can perform this operation no more than k times,\r\nbecause you have only k balls of color 0. Choose any ball of color such\r\nthat at least one of the balls adjacent to him has color 0, and move\r\nthat ball (of non-zero color) anywhere in the sequence (between any two\r\nconsecutive balls, before the leftmost ball or after the rightmost ball)\r\nwhile keeping the relative order of other balls. You can perform this\r\noperation as many times as you want, but for each operation you should\r\npay 1 coin. You can perform these operations in any order. After the\r\nlast operation, all balls of color 0 magically disappear, leaving a\r\nsequence of n balls of non-zero colors.What is the minimum amount of\r\ncoins you should spend on the operations of the second type, so that the\r\ni-th ball from the left has color i for all i from 1 to n ? It can be\r\nshown that under the constraints of the problem, it is always possible\r\nto reorder the balls in the required way. Solve the problem for all k\r\nfrom 1 to n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define pb push_back\nusing namespace std;\n#pragma GCC optimize(\"O2\")\nvoid init() {\n\t\n}\nconst int mxN = 501;\nint a[mxN];\nint dp[2][mxN][mxN][2];\ninline void chmin(int &lhs, int rhs) {\n\tlhs = min(lhs, rhs);\n}\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\t// dp[position][current value][took how many subarrays][taking now]\n\tfor (int j = 0; j <= n; j++) {\n\t\tfor (int k = 0; k <= n; k++) {\n\t\t\tdp[0][j][k][0] = dp[0][j][k][1] = n + 1;\n\t\t\tdp[1][j][k][0] = dp[1][j][k][1] = n + 1;\n\t\t}\n\t}\n\tdp[0][0][0][0] = 0;\n\tfor (int pos = 1; pos <= n; pos++) {\n\t\tfor (int val = 0; val <= n; val++) {\n\t\t\tif (val == a[pos]) continue;\n\t\t\t// must take now\n\t\t\tfor (int took = 1; took <= n; took++) {\n\t\t\t\tchmin(dp[1][val][took][1], dp[0][val][took][1] + 1);\n\t\t\t\tchmin(dp[1][val][took][1], dp[0][val][took - 1][0] + 1);\n\t\t\t}\n\t\t}\n\t\t// must not take now\n\t\tfor (int took = 0; took <= n; took++) {\n\t\t\tfor (int prev = 0; prev < a[pos]; prev++) {\n\t\t\t\tchmin(dp[1][a[pos]][took][0], dp[0][prev][took][0]);\n\t\t\t\tchmin(dp[1][a[pos]][took][0], dp[0][prev][took][1]);\n\t\t\t}\n\t\t}\n\t\t// update\n\t\tfor (int val = 1; val <= n; val++) {\n\t\t\tfor (int took = 0; took <= n; took++) {\n\t\t\t\tchmin(dp[1][val][took][0], dp[1][val - 1][took][0]);\n\t\t\t\tchmin(dp[1][val][took][1], dp[1][val - 1][took][1]);\n\t\t\t}\n\t\t}\n\t\tfor (int val = 0; val <= n; val++) {\n\t\t\tfor (int took = 0; took <= n; took++) {\n\t\t\t\tdp[0][val][took][0] = dp[1][val][took][0];\n\t\t\t\tdp[0][val][took][1] = dp[1][val][took][1];\n\n\t\t\t\tdp[1][val][took][0] = n + 1;\n\t\t\t\tdp[1][val][took][1] = n + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = n + 1;\n\tfor (int val = 1; val <= n; val++) {\n\t\tchmin(ans, dp[0][val][0][0]);\n\t\tchmin(ans, dp[0][val][0][1]);\n\t}\n\tfor (int took = 1; took <= n; took++) {\n\t\tfor (int val = 1; val <= n; val++) {\n\t\t\tchmin(ans, dp[0][val][took][0]);\n\t\t\tchmin(ans, dp[0][val][took][1]);\n\t\t}\n\t\tcout << ans << ' ';\n\t}\n\tcout << endl;\n}\nint32_t main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tinit();\n\tint t = 1;\n\tcin >> t;\n\twhile (t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Ball Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/116963",
    "editorial": "Letâs solve the problem for some fixed .Consider the set of all balls\r\nthat were never moved with operation of type . Letâs call balls from and\r\nballs not from . The relative order of fixed balls never changes, so\r\ntheir colors must form an increasing sequence. Letâs define as the\r\nnumber of segments of mobile balls that the fixed balls divide sequence\r\ninto. For example, if and , then these segments are and is equal to . As\r\nevery mobile ball has to be moved at least once, there must be at least\r\none zero-colored ball in each such segment, whicn means that . Also, it\r\nmeans that we will need at least operations of type . In fact, we can\r\nalways place mobile balls at correct positions with exactly operations.\r\nThe proof is left as exercise for reader.So the answer for is equal to\r\nminimum value of over all sets of balls such that and the colors of\r\nballs in form an increasing sequence. This problem can be solved with\r\ndynamic programming: let be maximum value of if only balls from to\r\nexist, ball belongs to and is equal to . To perform transitions from you\r\nneed to enumerate the next ball from after . Then, if , you transition\r\nto , otherwise you transition to . After each transition increases by ,\r\nso you just update with value . There are states and at most transitions\r\nfrom each state, so the complexity is .Solution can be optimized to with\r\nsegment tree, but this was not required.\r\n",
    "hint": [
        "Hint Consider the set of balls that were never moved by operations of type 2.",
        "Hint The relative order of these balls never changes, so their colors must form an increasing sequence."
    ]
}