{
    "link": "https://codeforces.com//contest/2001/problem/E1",
    "problemId": "2825894",
    "problem_idx": "E1",
    "shortId": "2001E1",
    "contest_number": "2001",
    "problem_submissions": {
        "B": [
            277398710,
            277337688,
            277333922,
            277337722,
            277337555,
            277331647,
            277331395,
            277333468,
            277348528,
            277341588,
            277340363,
            277333951,
            277333359,
            277338651,
            277333253,
            277332470,
            277333025,
            277335874,
            277338084,
            277338047
        ],
        "A": [
            277396358,
            277332606,
            277324069,
            277328881,
            277324101,
            277323710,
            277325572,
            277324708,
            277342273,
            277324601,
            277327125,
            277324363,
            277324076,
            277325983,
            277324668,
            277323640,
            277324308,
            277324085,
            277329437,
            277324734
        ],
        "C": [
            277393929,
            277349647,
            277343837,
            277347819,
            277349047,
            277345424,
            277478575,
            277341657,
            277342745,
            277358874,
            277352973,
            277356317,
            277345054,
            277358657,
            277349482,
            277354577,
            277354478,
            277341600,
            277373032,
            277357702,
            277354144
        ],
        "D": [
            277386516,
            277362274,
            277363417,
            277423990,
            277364589,
            277362182,
            277363264,
            277481384,
            277378655,
            277372682,
            277373441,
            277372083,
            277373799,
            277371029,
            277376602,
            277374746,
            277374825,
            277383133,
            277374017,
            277362123,
            277383713,
            277376041
        ],
        "E2": [
            277373545,
            283086293,
            277423307,
            278251315,
            278253470
        ],
        "E1": [
            277335505,
            277376073,
            277395747,
            277388497,
            277391499,
            277398952,
            277393530,
            277401516,
            277389370,
            277393752,
            277394666,
            277405095,
            277396023,
            277402006,
            277399147,
            277397663,
            277407033,
            278257931,
            277717643,
            277717625,
            277717605,
            277717578,
            277403586,
            277396025,
            277402066
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132942",
    "editorial": "idea & solution: Misuki SolutionConsider properties of the result\nsequence:Since there may be multiple ways to apply operations to make\nthe same heap, letâs consider the decision version of the problem\ninstead of counting the operation sequence directly. That is, \"Given a\nsequence a resulting from k operations, check whether such a is a\ndeterministic max-heap.\", and try to figure out what properties are\nneeded.Rephrase of problem:Let v = 2^{n - 1} be the only leaf such that\nafter popping one element from the top, every element on the path\nbetween 1 and v would be moved upward, then the condition of a\ndeterministic max-heap can be rephrased as follows: a_1 = k a_{v}\nge a_{2v} + a_{2v + 1}, for any v (1\nle v < 2^{n - 1}) a_{2\ncdot 2^k} > a_{2\ncdot 2^k + 1}, for any k (0\nle k\nle n - 2) So we can see that for any k (0\nle k\nle n - 2), the number of operations done in the subtree of 2\ncdot 2^k should be greater than the number of operations done in the\nsubtree of 2\ncdot 2^k + 1, and we donât care much about how these operations\ndistribute in the subtree of 2\ncdot 2^k + 1 as long as 3. holds. Letâs call such subtree\n\"uncritical\".Apply counting:For any uncritical subtree with size sz, if\nwe do x operations under it, there are\nbinom{x + (sz - 1)}{x} ways to do so.Now we can use dp to consider all\nvalid a we can get by enumerating the number of operation done on each\nvertex on the path from 1 to 2^{n - 1} and all uncritical subtree.Let\ndp[i][j] be the number of different a we can get by j operations on the\nsubtree with size 2^i - 1, then we havebase case: dp[1][j] = 1,\nforall j\nin [0, k]transition: dp[i + 1][l]\ntext{ += } dp[i][j]\ntimes\nbinom{x + (2^i - 2)}{x} ,\nforall x\nin [0, j), l\nin [j + x, k]using prefix sum, we can optimize the above dp to O(nk^2),\nand the number of deterministic max-heap where vertex 2^{n - 1} would be\npulled up is dp[n][k].Make use of symmetry:Finally, due to the symmetry\nproperty of a perfect binary tree, the number of deterministic max-heap\nwhere v would be pulled are equal for all possible v, so the final\nanswer we want would be dp[n][k]\ntimes 2^{n - 1}.\n",
    "name": "E1. Deterministic Heap  Easy Version ",
    "statement": "Consider a perfect binary tree with size 2^n - 1, with nodes numbered\r\nfrom 1 to 2^n-1 and rooted at 1. For each vertex v (1\r\nle v\r\nle 2^{n - 1} - 1), vertex 2v is its left child and vertex 2v + 1 is its\r\nright child. Each node v also has a value a_v assigned to it.Define the\r\noperation\r\nmathrm{pop} as follows: initialize variable v as 1; repeat the following\r\nprocess until vertex v is a leaf (i.e. until 2^{n - 1}\r\nle v\r\nle 2^n - 1); among the children of v, choose the one with the larger\r\nvalue on it and denote such vertex as x; if the values on them are equal\r\n(i.e. a_{2v} = a_{2v + 1}), you can choose any of them; assign a_x to\r\na_v (i.e. a_v := a_x); assign x to v (i.e. v := x); assign -1 to a_v\r\n(i.e. a_v := -1). Then we say the\r\nmathrm{pop} operation is deterministic if there is a unique way to do\r\nsuch operation. In other words, a_{2v}\r\nneq a_{2v + 1} would hold whenever choosing between them.A binary tree\r\nis called a max-heap if for every vertex v (1\r\nle v\r\nle 2^{n - 1} - 1), both a_v\r\nge a_{2v} and a_v\r\nge a_{2v + 1} hold.A max-heap is deterministic if the\r\nmathrm{pop} operation is deterministic to the heap when we do it\r\n.Initially, a_v := 0 for every vertex v (1\r\nle v\r\nle 2^n - 1), and your goal is to count the number of different\r\ndeterministic max-heaps produced by applying the following operation\r\nmathrm{add} exactly k times: Choose an integer v (1\r\nle v\r\nle 2^n - 1) and, for every vertex x on the path between 1 and v, add 1\r\nto a_x. Two heaps are considered different if there is a node which has\r\ndifferent values in the heaps. Since the answer might be large, print it\r\nmodulo p.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}const int N=505;int n,k,p;int f[505][505],g[505][505];void run(){\tcin>>n>>k>>p;\trep(i,n+1)rep(j,k+1)f[i][j]=g[i][j]=0;\trep(i,k+1)f[0][i]=g[0][i]=1;\trep(i,n-1){\t\trep(j,k+1)rep(l,k+1)if(j+l<=k){\t\t\tif(j<l)(f[i+1][j+l]+=g[i][j]*f[i][l])%=p;\t\t\tif(j>l)(f[i+1][j+l]+=f[i][j]*g[i][l])%=p;\t\t\t(g[i+1][j+l]+=g[i][j]*g[i][l])%=p;\t\t}\t\trep(j,k)(f[i+1][j+1]+=f[i+1][j])%=p;\t\trep(j,k)(g[i+1][j+1]+=g[i+1][j])%=p;//\t\trep(j,k+1)cout<<\"f \"<<i+2<<\" \"<<j<<\" \"<<f[i+1][j]<<\"\\n\";//\t\trep(j,k+1)cout<<\"g \"<<i+2<<\" \"<<j<<\" \"<<g[i+1][j]<<\"\\n\";\t}\tcout<<f[n-1][k]<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Deterministic Heap  Easy Version .json",
    "hint": [
        "Hint 1 Consider subtask — decision version of the problem (i.e. yes/no problem) as follow: \"Given a sequence resulting from operations, check whether such is a deterministic max-heap.\", what property should have?",
        "Hint 2 Try to fix the position of leaf being popped, what property are needed on the path from root to it?",
        "Hint 3 Does it really matter where the leaf being popped lies important?",
        "Hint 4 Try to count the number of where the first leaf being popped is fixed at one position using DP.",
        "Hint 3 Try to use DP to track the path of elements being popped and count number of possible satisfy the property."
    ]
}