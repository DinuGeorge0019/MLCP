{"link": "https://codeforces.com//contest/1228/problem/F", "problemId": "424247", "problem_idx": "F", "shortId": "1228F", "contest_number": "1228", "problem_submissions": {"F": [61496806, 61502870, 61502190, 61505436, 61526774, 61501386, 61506794, 61506003, 61507242, 61528062, 61506930, 61504933, 61527679, 61758392, 61506804, 61501659], "E": [61487066, 61484839, 61491424, 61489793, 61526757, 61494082, 61491501, 61493504, 61494383, 61528054, 61491524, 61495860, 61488344, 61491222, 61486950, 61487675, 61498567, 61492377, 61492698, 61509475, 61488264], "D": [61485310, 61482745, 61489582, 61486586, 61526744, 61490366, 61487311, 61489384, 61491690, 61528041, 61498727, 61505643, 61485067, 61484265, 61490334, 61491347, 61491538, 61486214, 61487124, 61487752, 61482893], "C": [61480399, 61479345, 61481687, 61481376, 61526733, 61486187, 61481654, 61482779, 61486226, 61528029, 61481914, 61486289, 61481778, 61480281, 61475855, 61480938, 61484833, 61479319, 61482763, 61482555, 61495805], "B": [61476242, 61476828, 61478048, 61477189, 61526720, 61483135, 61479399, 61477633, 61477664, 61528022, 61483663, 61478266, 61477452, 61477008, 61479768, 61476788, 61509875, 61476696, 61478410, 61478919, 61476259], "A": [61473188, 61476420, 61473176, 61473720, 61526708, 61477230, 61473216, 61473745, 61473523, 61528006, 61479593, 61475038, 61472935, 61473261, 61477228, 61473405, 61476821, 61473215, 61474472, 61475483, 61474687]}, "name": "F. One Node is Gone", "statement": "You have an integer n. Let\u2019s define following tree generation as : Make\r\na complete and full binary tree of 2^{n} - 1 vertices. Complete and full\r\nbinary tree means a tree that exactly one vertex is a root, all leaves\r\nhave the same depth (distance from the root), and all non-leaf nodes\r\nhave exactly two child nodes. Select a non-root vertex v from that\r\nbinary tree. Remove v from tree and make new edges between v\u2019s parent\r\nand v\u2019s direct children. If v has no children, then no new edges will be\r\nmade. You have a tree. Determine if this tree can be made by McDic\u2019s\r\ngeneration. If yes, then find the parent vertex of removed vertex in\r\ntree.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define GG do{puts(\"0\"); exit(0);}while (false);\n#define ASRT(S) if (!(S)) GG;\n\nconst int N = 17, V = (1 << N) + 5;\n\nint ver;\nvector<int> g[V];\nint cnt[5];\nbool vis[V];\n\nvoid chk(int u, int d) {\n  vis[u] = true;\n  int cnt = 0;\n  for (int v : g[u])\n    if (!vis[v]) {\n      chk(v, d - 1);\n      ++cnt;\n    }\n  if (cnt == 0) {\n    ASRT(d == 1);\n  } else\n    ASRT(cnt == 2);\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  int n;\n  scanf(\"%d\", &n);\n  if (n == 2) {\n    puts(\"2\\n1 2\");\n    return 0;\n  }\n\n  // 2 -- 3 -- 1\n  ver = (1 << n) - 2;\n  for (int rep = 1; rep < ver; ++rep) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  for (int i = 1; i <= ver; ++i) {\n    ASRT(g[i].size() <= 4 && g[i].size() > 0);\n    ++cnt[g[i].size()];\n  }\n\n  if (0 == cnt[2]) { // p = root\n    ASRT(cnt[1] == 1 << (n - 1));\n    ASRT(cnt[4] == 0);\n\n    static int dis[V];\n    queue<int> q;\n    for (int i = 1; i <= ver; ++i)\n      if (g[i].size() == 1) {\n        q.push(i);\n        dis[i] = 1;\n      }\n    vector<int> ans;\n    while (!q.empty()) {\n      int u = q.front(); q.pop();\n      if (dis[u] == n - 1)\n        ans.push_back(u);\n      if (dis[u] > n - 1)\n        GG;\n      for (int v : g[u])\n        if (!dis[v]) {\n          dis[v] = dis[u] + 1;\n          q.push(v);\n        }\n    }\n    ASRT(ans.size() == 2);\n    int rt1 = ans[0], rt2 = ans[1];\n    bool fl = false;\n    for (int v : g[rt1])\n      if (v == rt2) {\n        fl = true;\n        break;\n      }\n    ASRT(fl);\n    vis[rt1] = true;\n    vis[rt2] = true;\n    chk(rt1, n - 1);\n    chk(rt2, n - 1);\n    if (rt1 > rt2)\n      swap(rt1, rt2);\n    printf(\"2\\n%d %d\\n\", rt1, rt2);\n  } else if (cnt[2] == 2) { // v = leaf\n    ASRT(cnt[4] == 0);\n    ASRT(cnt[1] == ((1 << (n - 1)) - 1));\n    int ans = -1, rt = -1;\n    for (int i = 1; i <= ver; ++i) {\n      if (g[i].size() != 2)\n        continue;\n      bool f = false;\n      for (int v : g[i])\n        if (g[v].size() == 1) {\n          f = true;\n        }\n      if (!f) {\n        rt = i;\n      } else {\n        g[i].push_back(ver + 1);\n        ans = i;\n      }\n    }\n    if (ans == -1 || rt == -1)\n      GG;\n    chk(rt, n);\n    printf(\"1\\n%d\\n\", ans);\n  } else {\n    ASRT(cnt[4] == 1);\n    ASRT(cnt[2] == 1);\n    ASRT(cnt[1] == 1 << (n - 1));\n    int rt = -1, ans = -1;\n    for (int i = 1; i <= ver; ++i)\n      if (g[i].size() == 2)\n        rt = i;\n      else if (g[i].size() == 4)\n        ans = i;\n\n    static int dis[V];\n    queue<int> q;\n    for (int i = 1; i <= ver; ++i)\n      if (g[i].size() == 1) {\n        q.push(i);\n        dis[i] = 1;\n      }\n    while (!q.empty()) {\n      int u = q.front(); q.pop();\n      for (int v : g[u])\n        if (!dis[v]) {\n          dis[v] = dis[u] + 1;\n          q.push(v);\n        }\n    }\n    vector<pair<int, int>> vv;\n    for (int v : g[ans])\n      vv.emplace_back(dis[v], v);\n    sort(vv.begin(), vv.end());\n    vector<int> ng;\n    for (int v : g[ans])\n      if (vv[0].second != v && vv[1].second != v)\n        ng.push_back(v);\n    ng.push_back(ver + 1);\n    g[ver + 1].push_back(vv[0].second);\n    g[ver + 1].push_back(vv[1].second);\n    g[ans] = ng;\n    for (int& v : g[vv[0].second])\n      if (v == ans) {\n        v = ver + 1;\n        break;\n      }\n    for (int& v : g[vv[1].second])\n      if (v == ans) {\n        v = ver + 1;\n        break;\n      }\n    chk(rt, n);\n    printf(\"1\\n%d\\n\", ans);\n  }\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation", "trees"], "dificulty": "2500", "interactive": false}