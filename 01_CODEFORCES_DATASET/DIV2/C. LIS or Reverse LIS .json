{
    "link": "https://codeforces.com//contest/1682/problem/C",
    "problemId": "1407921",
    "problem_idx": "C",
    "shortId": "1682C",
    "contest_number": "1682",
    "problem_submissions": {
        "F": [
            158050798,
            158077786,
            158086685,
            158039286,
            158069961,
            158110252,
            158078476,
            158248901
        ],
        "D": [
            158028363,
            158027200,
            158028814,
            158069864,
            158039569,
            158036346,
            158030046,
            158050282,
            158037974,
            158041123,
            158041068,
            158036998,
            158042298,
            158032953,
            158041526,
            158029661,
            158056637,
            158029667
        ],
        "C": [
            158015824,
            158013904,
            158013129,
            158070941,
            158017154,
            158019512,
            158011476,
            158017137,
            158021257,
            158018627,
            158020682,
            158022180,
            158021471,
            158039652,
            158019776,
            158037446,
            158028182
        ],
        "B": [
            158006894,
            158007821,
            158007318,
            158071816,
            158008119,
            158009978,
            158007984,
            158008572,
            158013225,
            158009923,
            158010666,
            158009973,
            158013386,
            158010013,
            158016214,
            158026210,
            158017588,
            158010270
        ],
        "A": [
            158004280,
            158004512,
            158004427,
            158072894,
            158004570,
            158007124,
            158005591,
            158005462,
            158005647,
            158004983,
            158006433,
            158004812,
            158012816,
            158004216,
            158013837,
            158039471,
            158008517,
            158004710
        ],
        "E": [
            158050246,
            158056393,
            158060063,
            158060073,
            158067774,
            158059309,
            158065396,
            158067467,
            158070762,
            158068042,
            158070815,
            158073429,
            158070617,
            158069678,
            158075426,
            158064743
        ]
    },
    "name": "C. LIS or Reverse LIS ",
    "statement": "You are given an array a of n positive integers. Let\r\ntext{LIS}(a) denote the length of longest strictly increasing\r\nsubsequence of a. For example,\r\ntext{LIS}([2,\r\nunderline{1}, 1,\r\nunderline{3}]) = 2.\r\ntext{LIS}([\r\nunderline{3},\r\nunderline{5},\r\nunderline{10},\r\nunderline{20}]) = 4.\r\ntext{LIS}([3,\r\nunderline{1},\r\nunderline{2},\r\nunderline{4}]) = 3. We define array a\u2019 as the array obtained after\r\nreversing the array a i.e. a\u2019 = [a_n, a_{n-1},\r\nldots , a_1].The beauty of array a is defined as min(\r\ntext{LIS}(a),\r\ntext{LIS}(a\u2019)).Your task is to determine the maximum possible beauty of\r\nthe array a if you can rearrange the array a arbitrarily.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint p[200005];\nint main()\n{\n\tint t,n,ans=0,ans1=0,tsl;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)p[i]=read();\n\t\tsort(p+1,p+n+1);\n\t\ttsl=1;\n\t\tans1=0;\n\t\tans=0; \n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tif(p[i]!=p[i-1])\n\t\t\t{\n\t\t\t\tif(tsl==1)ans1++;\n\t\t\t\telse ans++;\n\t\t\t\ttsl=1;\n\t\t\t}\n\t\t\telse tsl++;\n\t\t}\n\t\tif(tsl==1)ans1++;\n\t\telse ans++;\n\t\tif(ans1>=1)ans1--,ans++; \n\t\tprintf(\"%d\\n\",ans+ans1/2);\n\t}\n\treturn 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. LIS or Reverse LIS .json",
    "editorial_link": "https://codeforces.com//blog/entry/103097",
    "editorial": "TutorialLet\u00e2\u0080\u0099s make a small observation: There can be at most one index\r\ncommon to both and . If some element occurs times, then one of its\r\noccurrences can be included in and another one in , and all the\r\nremaining occurrences are of no use because none of them can contain 2\r\nequal elements.If some element is a singleton i.e. the frequency of in\r\nis , then it can have positions In only. In only. The only common\r\nelement of and . It can be seen that it is always optimal to choose some\r\nsingleton as the only common element (if available) because those with\r\nfrequency can easily contribute to both and easily. Let be the number of\r\nelements having frequency and be the number of singletons in . The\r\nsingletons should be divided equally among and with one of them given to\r\nboth, if available.Hence, the answer is . The values and can be found\r\nusing some data structure like in C++ in .\r\n"
}