{"link": "https://codeforces.com//contest/340/problem/D", "problemId": "3420", "problem_idx": "D", "shortId": "340D", "contest_number": "340", "problem_submissions": {"E": [4380220, 4380834, 4380126, 4391968, 4382367, 4376164, 4380005, 4381859, 4379851, 4381825, 4380671, 4377641, 4381576, 4383755], "D": [4377289, 4376595, 4378029, 4372963, 4376785, 4377666, 4373992, 4376684, 4376514, 4377010, 4380983, 4375663, 4376643, 4377274, 4373081, 4406324, 4378181, 4380917, 4377354, 4383338], "C": [4375809, 4375002, 4377603, 4374632, 4375617, 4376250, 4378682, 4380136, 4373891, 4375990, 4378082, 4377910, 4377314, 4378457, 4375078, 4376703, 4378516, 4378506, 4374797], "B": [4372293, 4378644, 4376876, 4375385, 4378732, 4374049, 4386232, 4373253, 4380096, 4376212, 4383111, 4383087, 4379013, 4399484, 4382621, 4372666], "A": [4371264, 4371296, 4372303, 4375873, 4371313, 4371976, 4371443, 4371936, 4378560, 4371824, 4374190, 4371558, 4371435, 4371343, 4371370, 4371365, 4371526, 4371376, 4371280]}, "name": "D. Bubble Sort Graph", "statement": "Iahub recently has learned Bubble Sort, an algorithm that is used to\r\nsort a permutation with elements , , ..., in ascending order. He is\r\nbored of this so simple algorithm, so he invents his own graph. The\r\ngraph (let\u2019s call it ) initially has vertices and 0 edges. During Bubble\r\nSort execution, edges appear as described in the following algorithm\r\n(pseudocode). procedure bubbleSortGraph() build a graph G with n\r\nvertices and 0 edges repeat swapped = false for i = 1 to n - 1 inclusive\r\ndo: if a[i] > a[i + 1] then add an undirected edge in G between a[i] and\r\na[i + 1] swap( a[i], a[i + 1] ) swapped = true end if end for until not\r\nswapped /* repeat the algorithm as long as swapped value is true. */ end\r\nprocedureFor a graph, an independent set is a set of vertices in a\r\ngraph, no two of which are adjacent (so there are no edges between\r\nvertices of an independent set). A maximum independent set is an\r\nindependent set which has maximum cardinality. Given the permutation,\r\nfind the size of the maximum independent set of graph , if we use such\r\npermutation as the premutation in procedure bubbleSortGraph.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define DOWN(i,a,b) for(int i = (a); i>=(b);i--)\n#define FR(i,a) for(int i = 0; i < (a); i++)\nusing namespace std;\nint n;\nint a[100300];\nint Tree[100300],f[100300];\nvoid update(int node, int val) {\n    for(;node<=n;node+=node&(-node))\n        Tree[node] = max(Tree[node],val);\n}\nint visit(int node) {\n    int s = 0;\n    for(;node>0;node-=node&(-node))\n        s = max(s,Tree[node]);\n    return s;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    FOR(i,1,n) cin >> a[i];\n    int res = 0;\n    FOR(i,1,n) {\n        f[i] = visit(a[i]) + 1;\n        update(a[i], f[i]);\n        res = max(res,f[i]);\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dp"], "dificulty": "1500", "interactive": false}