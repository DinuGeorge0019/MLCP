{
    "link": "https://codeforces.com//contest/340/problem/D",
    "problemId": "3420",
    "problem_idx": "D",
    "shortId": "340D",
    "contest_number": "340",
    "problem_submissions": {
        "E": [
            4380220,
            4380834,
            4380126,
            4391968,
            4382367,
            4376164,
            4380005,
            4381859,
            4379851,
            4381825,
            4380671,
            4377641,
            4381576,
            4383755
        ],
        "D": [
            4377289,
            4376595,
            4378029,
            4372963,
            4376785,
            4377666,
            4373992,
            4376684,
            4376514,
            4377010,
            4380983,
            4375663,
            4376643,
            4377274,
            4373081,
            4406324,
            4378181,
            4380917,
            4377354,
            4383338
        ],
        "C": [
            4375809,
            4375002,
            4377603,
            4374632,
            4375617,
            4376250,
            4378682,
            4380136,
            4373891,
            4375990,
            4378082,
            4377910,
            4377314,
            4378457,
            4375078,
            4376703,
            4378516,
            4378506,
            4374797
        ],
        "B": [
            4372293,
            4378644,
            4376876,
            4375385,
            4378732,
            4374049,
            4386232,
            4373253,
            4380096,
            4376212,
            4383111,
            4383087,
            4379013,
            4399484,
            4382621,
            4372666
        ],
        "A": [
            4371264,
            4371296,
            4372303,
            4375873,
            4371313,
            4371976,
            4371443,
            4371936,
            4378560,
            4371824,
            4374190,
            4371558,
            4371435,
            4371343,
            4371370,
            4371365,
            4371526,
            4371376,
            4371280
        ]
    },
    "name": "D. Bubble Sort Graph",
    "statement": "Iahub recently has learned Bubble Sort, an algorithm that is used to\r\nsort a permutation with elements , , ..., in ascending order. He is\r\nbored of this so simple algorithm, so he invents his own graph. The\r\ngraph (let’s call it ) initially has vertices and 0 edges. During Bubble\r\nSort execution, edges appear as described in the following algorithm\r\n(pseudocode). procedure bubbleSortGraph() build a graph G with n\r\nvertices and 0 edges repeat swapped = false for i = 1 to n - 1 inclusive\r\ndo: if a[i] > a[i + 1] then add an undirected edge in G between a[i] and\r\na[i + 1] swap( a[i], a[i + 1] ) swapped = true end if end for until not\r\nswapped /* repeat the algorithm as long as swapped value is true. */ end\r\nprocedureFor a graph, an independent set is a set of vertices in a\r\ngraph, no two of which are adjacent (so there are no edges between\r\nvertices of an independent set). A maximum independent set is an\r\nindependent set which has maximum cardinality. Given the permutation,\r\nfind the size of the maximum independent set of graph , if we use such\r\npermutation as the premutation in procedure bubbleSortGraph.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define DOWN(i,a,b) for(int i = (a); i>=(b);i--)\n#define FR(i,a) for(int i = 0; i < (a); i++)\nusing namespace std;\nint n;\nint a[100300];\nint Tree[100300],f[100300];\nvoid update(int node, int val) {\n    for(;node<=n;node+=node&(-node))\n        Tree[node] = max(Tree[node],val);\n}\nint visit(int node) {\n    int s = 0;\n    for(;node>0;node-=node&(-node))\n        s = max(s,Tree[node]);\n    return s;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    FOR(i,1,n) cin >> a[i];\n    int res = 0;\n    FOR(i,1,n) {\n        f[i] = visit(a[i]) + 1;\n        update(a[i], f[i]);\n        res = max(res,f[i]);\n    }\n    cout << res << endl;\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bubble Sort Graph.json",
    "editorial_link": "https://codeforces.com/blog/entry/8755",
    "editorial": "A good way to approach this problem is to notice that you canât build\r\nthe graph. In worst case, the graph will be built in complexity, which\r\nwill time out. Also, notice that \"maximal independent set\" is a NP-Hard\r\ntask, so even if you can build the graph you canât continue from there.\r\nSo, the correct route to start is to think of graphâs properties instead\r\nof building it. After sketching a little on the paper, you should find\r\nthis property: Lemma 1 Suppose we choose 2 indices i and j, such as i <\r\nj. Weâll have an edge on the graph between vertices and if and only if >\r\n. Weâll call that i and j form an inversion in the permutation. Proof We\r\nassume we know the proof that bubble sort does sort correctly an array.\r\nTo proof lemma 1, we need to show two things. To proof 1, if bubble sort\r\nwouldnât swap an inversion, the sequence wouldnât be sorted. But we know\r\nthat bubble sort always sorts a sequence, so all inversions will be\r\nswapped. Proofing 2 is trivial, just by looking at the code. So far\r\nweâve got how the graph G is constructed. Letâs apply it in maximal\r\nindependent set problem. Lemma 2 A maximal independent set of graph G is\r\na longest increasing sequence for permutation a. Proof: Suppose we have\r\na set of indices < < ... such as , , ..., form an independent set. Then,\r\nanyhow weâd choose and , there wonât exist an edge between and .\r\nAccording to proof 1, this only happens when < . Hence, an independent\r\nset will be equivalent to an increasing sequence of permutation a. The\r\nmaximal independent set is simply the maximal increasing sequence of\r\npermutation a. The task reduces to find longest increasing sequence for\r\npermutation . This is a classical problem which can be solved in . Here\r\nis an interesting discussion about how to do it.\r\n",
    "hint": []
}