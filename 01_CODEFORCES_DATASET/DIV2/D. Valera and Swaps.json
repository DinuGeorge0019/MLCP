{
    "link": "https://codeforces.com//contest/441/problem/D",
    "problemId": "10179",
    "problem_idx": "D",
    "shortId": "441D",
    "contest_number": "441",
    "problem_submissions": {
        "D": [
            6846993,
            6848184,
            6846636,
            6846799,
            6846427,
            6846976,
            6846637,
            6847967,
            6844170,
            6847911,
            6848088,
            6847662,
            6847887,
            6842471,
            6843010
        ],
        "C": [
            6842791,
            6840708,
            6842295,
            6841947,
            6842979,
            6843258,
            6842150,
            6845333,
            6842762,
            6847076,
            6842331,
            6843795,
            6844814,
            6843899,
            6843750,
            6845351,
            6843645,
            6850933,
            6849893
        ],
        "B": [
            6840560,
            6839393,
            6840429,
            6840462,
            6840569,
            6841161,
            6840630,
            6842225,
            6840707,
            6845954,
            6840866,
            6842539,
            6843417,
            6847639,
            6842752,
            6841004,
            6841839
        ],
        "A": [
            6839071,
            6838557,
            6838730,
            6838755,
            6839171,
            6839289,
            6839675,
            6840019,
            6839272,
            6839363,
            6838491,
            6838790,
            6838791,
            6839587,
            6842218,
            6839738,
            6839077,
            6839417
        ],
        "E": [
            6847038,
            6850560
        ]
    },
    "name": "D. Valera and Swaps",
    "statement": "A of length is a sequence of distinct integers . A permutation is an\r\nidentity permutation, if for any the following equation holds . A is the\r\noperation that swaps elements and in the permutation. Let\u2019s assume that\r\nis the minimum number of swaps that you need to make the permutation an\r\nidentity permutation. Valera wonders, how he can transform permutation\r\ninto any permutation , such that , using the minimum number of swaps.\r\nHelp him do that.\r\n",
    "solutions": [
        "/* ***********************************************\nAuthor        :kuangbin\nCreated Time  :2014/6/9 0:36:52\nFile Name     :E:\\2014ACM\\Codeforces\\CF252\\D.cpp\n************************************************ */\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\nint a[3030];\nint tot;\nvector<int>vec[3030];\nbool vis[3030];\nint n;\n\nvoid calc()\n{\n\ttot = 0;\n\tmemset(vis,false,sizeof(vis));\n\tfor(int i = 1;i <= n;i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\ttot++;\n\t\t\tvec[tot].clear();\n\t\t\tvec[tot].push_back(i);\n\t\t\tvis[i] = true;\n\t\t\tint u = i;\n\t\t\twhile(!vis[a[u]])\n\t\t\t{\n\t\t\t\tu = a[u];\n\t\t\t\tvis[u] = true;\n\t\t\t\tvec[tot].push_back(u);\n\t\t\t}\n\t\t}\n}\nvector<pair<int,int> >ans;\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tint m;\n\twhile(scanf(\"%d\",&n) == 1)\n\t{\n\t\tfor(int i = 1;i <= n;i++)scanf(\"%d\",&a[i]);\n\t\ttot = 0;\n\t\tscanf(\"%d\",&m);\n\t\tm = n-m;\n\t\tans.clear();\n\t\twhile(1)\n\t\t{\n\t\t\tcalc();\n\t\t\tif(tot == m)break;\n\t\t\tif(tot < m)\n\t\t\t{\n\t\t\t\tfor(int i = 1;i <= tot;i++)\n\t\t\t\t\tif(vec[i].size() >= 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Min = vec[i][1];\n\t\t\t\t\t\tint sz = vec[i].size();\n\t\t\t\t\t\tfor(int j = 2;j < sz;j++)\n\t\t\t\t\t\t\tif(vec[i][j] < Min)\n\t\t\t\t\t\t\t\tMin = vec[i][j];\n\t\t\t\t\t\tans.push_back(make_pair(vec[i][0],Min));\n\t\t\t\t\t\tswap(a[vec[i][0]],a[Min]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans.push_back(make_pair(vec[1][0],vec[2][0]));\n\t\t\t\tswap(a[vec[1][0]],a[vec[2][0]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans.size());\n\t\tint sz = ans.size();\n\t\tfor(int i = 0;i < sz;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\",ans[i].first,ans[i].second);\n\t\t\tif(i < sz-1)printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dsu",
        "graphs",
        "implementation",
        "math",
        "string suffix structures"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Valera and Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/12615",
    "editorial": "Problem author danilka.pro In this task you should represent permutation\r\nas graph with vertexes, and from every vertex exists exactly one edge to\r\nvertex . It\u00e2\u0080\u0099s easy to understand that such graph consists of simple\r\ncycles only. If we make swap , edges and will become edges and\r\nrespectively. Then if and is in the same cycle, this cycle will break:\r\nbut if they are in different cycles, these cycles will merge into one:\r\nthis means that every swap operation increases number of cycles by one,\r\nor decreases it by one. Assuming all above, to get permutation from\r\npermutation , we need to increase (or decrease) number of cycles in to .\r\nLet number of cycles in . Then always equals . For satisfying\r\nlexicographical minimality we will review three cases: 1) It\u00e2\u0080\u0099s easy to\r\nunderstand, that in this case you must decrease cycles number by merging\r\ncycles one by one with cycle containing vertex 1. This way every swap\r\nhas form , where . Because every cycle vertex is bigger than previous\r\ncycle vertex, this case can be solved with . 2) In this case you should\r\nbreak cycle for every vertex, making swap with smallest possible vertex\r\n(it should be in this cycle too). This could be done if represent cycle\r\nby line . As soon as every cycle is broken with linear asymptotics, this\r\ncase solution works with . Bonus: this way of representing cycle lets us\r\noptimize solution to asymptotics, you may think how. 3) Besause in this\r\ncase , there is nothing need to be swapped. It\u00e2\u0080\u0099s highly recommended to\r\ninspect jury\u00e2\u0080\u0099s solution: 6850515\r\n"
}