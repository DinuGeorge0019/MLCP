{"link": "https://codeforces.com//contest/441/problem/D", "problemId": "10179", "problem_idx": "D", "shortId": "441D", "contest_number": "441", "problem_submissions": {"D": [6846993, 6848184, 6846636, 6846799, 6846427, 6846976, 6846637, 6847967, 6844170, 6847911, 6848088, 6847662, 6847887, 6842471, 6843010], "C": [6842791, 6840708, 6842295, 6841947, 6842979, 6843258, 6842150, 6845333, 6842762, 6847076, 6842331, 6843795, 6844814, 6843899, 6843750, 6845351, 6843645, 6850933, 6849893], "B": [6840560, 6839393, 6840429, 6840462, 6840569, 6841161, 6840630, 6842225, 6840707, 6845954, 6840866, 6842539, 6843417, 6847639, 6842752, 6841004, 6841839], "A": [6839071, 6838557, 6838730, 6838755, 6839171, 6839289, 6839675, 6840019, 6839272, 6839363, 6838491, 6838790, 6838791, 6839587, 6842218, 6839738, 6839077, 6839417], "E": [6847038, 6850560]}, "name": "D. Valera and Swaps", "statement": "A of length is a sequence of distinct integers . A permutation is an\r\nidentity permutation, if for any the following equation holds . A is the\r\noperation that swaps elements and in the permutation. Let\u2019s assume that\r\nis the minimum number of swaps that you need to make the permutation an\r\nidentity permutation. Valera wonders, how he can transform permutation\r\ninto any permutation , such that , using the minimum number of swaps.\r\nHelp him do that.\r\n", "solutions": ["/* ***********************************************\nAuthor        :kuangbin\nCreated Time  :2014/6/9 0:36:52\nFile Name     :E:\\2014ACM\\Codeforces\\CF252\\D.cpp\n************************************************ */\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\nint a[3030];\nint tot;\nvector<int>vec[3030];\nbool vis[3030];\nint n;\n\nvoid calc()\n{\n\ttot = 0;\n\tmemset(vis,false,sizeof(vis));\n\tfor(int i = 1;i <= n;i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\ttot++;\n\t\t\tvec[tot].clear();\n\t\t\tvec[tot].push_back(i);\n\t\t\tvis[i] = true;\n\t\t\tint u = i;\n\t\t\twhile(!vis[a[u]])\n\t\t\t{\n\t\t\t\tu = a[u];\n\t\t\t\tvis[u] = true;\n\t\t\t\tvec[tot].push_back(u);\n\t\t\t}\n\t\t}\n}\nvector<pair<int,int> >ans;\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tint m;\n\twhile(scanf(\"%d\",&n) == 1)\n\t{\n\t\tfor(int i = 1;i <= n;i++)scanf(\"%d\",&a[i]);\n\t\ttot = 0;\n\t\tscanf(\"%d\",&m);\n\t\tm = n-m;\n\t\tans.clear();\n\t\twhile(1)\n\t\t{\n\t\t\tcalc();\n\t\t\tif(tot == m)break;\n\t\t\tif(tot < m)\n\t\t\t{\n\t\t\t\tfor(int i = 1;i <= tot;i++)\n\t\t\t\t\tif(vec[i].size() >= 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Min = vec[i][1];\n\t\t\t\t\t\tint sz = vec[i].size();\n\t\t\t\t\t\tfor(int j = 2;j < sz;j++)\n\t\t\t\t\t\t\tif(vec[i][j] < Min)\n\t\t\t\t\t\t\t\tMin = vec[i][j];\n\t\t\t\t\t\tans.push_back(make_pair(vec[i][0],Min));\n\t\t\t\t\t\tswap(a[vec[i][0]],a[Min]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans.push_back(make_pair(vec[1][0],vec[2][0]));\n\t\t\t\tswap(a[vec[1][0]],a[vec[2][0]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans.size());\n\t\tint sz = ans.size();\n\t\tfor(int i = 0;i < sz;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\",ans[i].first,ans[i].second);\n\t\t\tif(i < sz-1)printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dsu", "graphs", "implementation", "math", "string suffix structures"], "dificulty": "2100", "interactive": false}