{"link": "https://codeforces.com//contest/676/problem/D", "problemId": "60899", "problem_idx": "D", "shortId": "676D", "contest_number": "676", "problem_submissions": {"D": [18086124, 18088139, 18084280, 18085571, 18084868, 18078718, 18082907, 18080588, 18080137, 18081145, 18081985, 18081026, 18081695, 18082035, 18081128, 18082512, 18082190, 18083067, 18081575, 18082166], "E": [18083014, 18097261, 18097237, 18085521, 18088459, 18088804, 18088832, 18103936, 18095906, 18094839, 18090516, 18100676, 18103495, 18227086], "C": [18079114, 18076155, 18074138, 18080914, 18078417, 18075987, 18076242, 18077017, 18077328, 18077130, 18076218, 18077107, 18077040, 18076098, 18076862, 18077489, 18078049, 18076245, 18076673, 18078488], "B": [18076441, 18077200, 18076573, 18077509, 18075916, 18074860, 18074368, 18074928, 18076475, 18075886, 18077173, 18074968, 18075981, 18075167, 18077678, 18075867, 18076662, 18079173, 18077589, 18077066], "A": [18073771, 18073531, 18073371, 18075006, 18073412, 18073493, 18073358, 18073487, 18073563, 18073458, 18073435, 18073444, 18073768, 18073556, 18073505, 18073796, 18074124, 18073590, 18073448, 18074969]}, "name": "D. Theseus and labyrinth", "statement": "Theseus has just arrived to Crete to fight Minotaur. He found a\r\nlabyrinth that has a form of a rectangular field of size and consists of\r\nblocks of size . block of the labyrinth has a button that rotates blocks\r\ndegrees clockwise. Each block rotates around its center and doesn\u2019t\r\nchange its position in the labyrinth. Also, each block has some number\r\nof doors (possibly none). In one minute, Theseus can either push the\r\nbutton in order to rotate all the blocks degrees clockwise or pass to\r\nthe neighbouring block. Theseus can go from block to some neighbouring\r\nblock only if block has a door that leads to block and block has a door\r\nthat leads to block .Theseus found an entrance to labyrinth and is now\r\nlocated in block the block in the row and column . Theseus know that the\r\nMinotaur is hiding in block and wants to know the minimum number of\r\nminutes required to get there.Theseus is a hero, not a programmer, so he\r\nasks you to help him.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n\nchar maze[1010][1010];\n\nconst string chars = \"+-|^><vLRUD*\";\nconst string roted = \"+|->v^<UDRL*\";\n\nint di[] = {0, 1, 0, -1};\nint dj[] = {1, 0, -1, 0};\nint rev[] = {2, 3, 0, 1};\n// RDLU\n\nint n, m;\n\n\nstring access[12];\n\nint normalizeChar(char c) {\n\t\treturn find(chars.begin(), chars.end(), c) - chars.begin();\n}\n\nvoid initAccess() {\n\taccess[0] = \"1111\";\n\taccess[1] = \"1010\";\n\taccess[2] = \"0101\";\n\taccess[3] = \"0001\";\n\taccess[4] = \"1000\";\n\taccess[5] = \"0010\";\n\taccess[6] = \"0100\";\n\taccess[7] = \"1101\";\n\taccess[8] = \"0111\";\n\taccess[9] = \"1110\";\n\taccess[10] = \"1011\";\n\taccess[11] = \"0000\";\n}\n\nint D[1005][1005][4];\nbool viz[1005][1005][4];\n\npair<int, int> nextCoord(int i, int j, int r, int d) {\n\tint newi = i + di[d];\n\tint newj = j + dj[d];\n\n\tif(newi > n || newj > m || newi <= 0 || newj <= 0)\n\t\treturn {-1, -1};\n\n\tint stateij = normalizeChar(maze[i][j]);\n\tint stateninj = normalizeChar(maze[newi][newj]);\n\n\tfor(int i = 0; i < r; ++i) {\n\t\tstateij = normalizeChar(roted[stateij]);\n\t\tstateninj = normalizeChar(roted[stateninj]);\n\t}\n\n\tif(access[stateij][d] == '1' && access[stateninj][rev[d]] == '1')\n\t\treturn {newi, newj};\n\treturn {-1, -1};\n\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"data.in\",\"r\",stdin);\n\t#endif // ONLINE_JUDGE\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\n\tinitAccess();\n\tcin >> n >> m;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> maze[i] + 1;\n\n\tint si, sj, ei, ej;\n\tcin >> si >> sj >> ei >> ej;\n\n\tqueue<vector<int>> Q;\n\tQ.push({si, sj, 0});\n\tviz[si][sj][0] = 1;\n\n\twhile(!Q.empty()) {\n\t\tauto now = Q.front();\n\t\tint i = now[0], j = now[1], r = now[2];\n\t\tQ.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tauto nxt = nextCoord(i, j, r, d);\n\t\t\tif(nxt.first == -1) continue;\n\n\t\t\tif(!viz[nxt.first][nxt.second][r]) {\n\t\t\t\tviz[nxt.first][nxt.second][r] = 1;\n\t\t\t\tD[nxt.first][nxt.second][r] =\n\t\t\t\t\tD[i][j][r] + 1;\n\t\t\t\tQ.push({nxt.first, nxt.second, r});\n\t\t\t}\n\t\t}\n\n\t\tint nr = (r + 1) % 4;\n\t\tif(!viz[i][j][nr]) {\n\t\t\tviz[i][j][nr] = 1;\n\t\t\tD[i][j][nr] = D[i][j][r] + 1;\n\t\t\tQ.push({i, j, nr});\n\t\t}\n\t}\n\n\tconst int INF = 0x7fffffff;\n\n\tint best = INF;\n\tfor(int d = 0; d < 4; ++d) {\n\t\tif(!viz[ei][ej][d]) continue;\n\t\tbest = min(best, D[ei][ej][d]);\n\t}\n/*\n\tfor(int i = 1; i <= n; ++i, cout << endl)\n\tfor(int j = 1; j <= m; ++j) {\n\t\tint best = INF;\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tif(!viz[i][j][d]) continue;\n\t\t\tbest = min(best, D[i][j][d]);\n\t\t}\n\n\t\tif(best == INF) best = -1;\n\t\tcout << best << \" \";\n\t}\n*/\n\tif(best == INF) best = -1;\n\tcout << best << '\\n';\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "implementation", "shortest paths"], "dificulty": "2000", "interactive": false}