{"link": "https://codeforces.com//contest/1501/problem/E", "problemId": "922990", "problem_idx": "E", "shortId": "1501E", "contest_number": "1501", "problem_submissions": {"E": [109941376, 109875512, 109883789, 110105518, 110105287], "F": [109904857], "A": [109878442, 109847988, 109846729, 109846494, 109846135, 109845267, 109845587, 109847199, 109845456, 109847603, 109846645, 109853330, 109847527, 109845680, 109862040, 109861437, 109857820, 109847064, 109879578, 109846519], "B": [109859119, 109845806, 109857469, 109847916, 109848937, 109845741, 109938795, 109847183, 109850677, 109848222, 109850447, 109858630, 109845453, 109850407, 109847950, 109859017, 109850474, 109855074, 109848387, 109851675, 109849198], "D": [109857126, 109874773, 109867593, 109877645, 109872691, 109883837, 109870581, 109889646, 109873833, 109880027, 109879853, 109876481, 109884289, 109877446, 109871324, 109884869, 109884357, 109879548, 109886127, 109876946, 109883128], "C": [109846358, 109849688, 109852611, 109851798, 109861330, 109852150, 109856203, 109859435, 109862259, 109860307, 109858003, 109857809, 109860809, 109860157, 109856014, 109855070, 109852660, 109851031, 109863843, 109867505]}, "name": "E. Matrix Sorting", "statement": "You are given two tables A and B of size n\r\ntimes m. We define a as the following: we choose a column and reorder\r\nthe rows of the table by the value in this column, from the rows with\r\nthe smallest value to the rows with the largest. In case there are two\r\nor more rows with equal value in this column, their relative order does\r\nnot change (such sorting algorithms are called ).You can find this\r\nbehavior of sorting by column in many office software for managing\r\nspreadsheets. Petya works in one, and he has a table A opened right now.\r\nHe wants to perform zero of more sortings by column to transform this\r\ntable to table B.Determine if it is possible to do so, and if yes, find\r\na sequence of columns to sort by. Note that you to minimize the number\r\nof sortings.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nconst long long M=75161927681ll;\nconst int N=1505,E=524288;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nint n,m,i,j,a[N][N],b[N][N],id[N],nx[N][N],vis[N],k,l,nw[N],nid[N];\nlong long ha[N],hb[N];\nvector<int> as;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nstruct str{\n\tint l,r;\n}sg[N],nsg[N];\nvector<str> t[N];\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n#endif\n\tgi(n),gi(m);\n\tlong long bs=rnd()%1000000+100001;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=m;++j)\n\t\t{\n\t\t\tgi(a[i][j]);\n\t\t\tha[i]=(ha[i]*bs+a[i][j])%M;\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=m;++j)\n\t\t{\n\t\t\tgi(b[i][j]);\n\t\t\thb[i]=(hb[i]*bs+b[i][j])%M;\n\t\t}\n\tfor(i=1;i<=m;++i)\n\t\tfor(j=n;j>=1;--j)\n\t\t\tif(b[j][i]>b[j+1][i])\n\t\t\t\tnx[j][i]=j;\n\t\t\telse\n\t\t\t\tnx[j][i]=nx[j+1][i];\n\tfor(i=1;i<=n;++i)\n\t\tid[i]=i;\n\tsg[k=1]={1,n};\n\twhile(1)\n\t{\n\t\tfor(i=1;i<=n;++i)\n\t\t\tif(ha[id[i]]!=hb[i])\n\t\t\t\tbreak;\n\t\tif(i>n)\n\t\t\tbreak;\n\t\tfor(i=1;i<=m;++i)\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tfor(j=1;j<=k;++j)\n\t\t\t\t\tif(nx[sg[j].l][i]<sg[j].r)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif(j>k)\n\t\t\t\t{\n\t\t\t\t\tas.push_back(i);\n\t\t\t\t\tvis[i]=1;\n\t\t\t\t\tfor(j=1;j<=k;++j)\n\t\t\t\t\t\tnw[j]=sg[j].l;\n\t\t\t\t\tfor(j=1;j<=k;++j)\n\t\t\t\t\t\tfor(l=sg[j].l;l<=sg[j].r;++l)\n\t\t\t\t\t\t\tt[a[id[l]][i]].push_back({j,id[l]});\n\t\t\t\t\tfor(j=1;j<=n;++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(auto it:t[j])\n\t\t\t\t\t\t\tnid[nw[it.l]++]=it.r;\n\t\t\t\t\t\tt[j].clear();\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=1;j<=n;++j)\n\t\t\t\t\t\tid[j]=nid[j];\n\t\t\t\t\tint kk=0;\n\t\t\t\t\tfor(j=1;j<=k;++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tint las=sg[j].l;\n\t\t\t\t\t\tfor(l=sg[j].l;l<sg[j].r;++l)\n\t\t\t\t\t\t\tif(a[id[l]][i]!=a[id[l+1]][i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnsg[++kk]={las,l};\n\t\t\t\t\t\t\t\tlas=l+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tnsg[++kk]={las,sg[j].r};\n\t\t\t\t\t}\n\t\t\t\t\tk=kk;\n\t\t\t\t\tfor(j=1;j<=kk;++j)\n\t\t\t\t\t\tsg[j]=nsg[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif(i>m)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treverse(as.begin(),as.end());\n\tprintf(\"%d\\n\",as.size());\n\tfor(auto it:as)\n\t\tprintf(\"%d \",it);\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2600", "interactive": false}