{
    "link": "https://codeforces.com//contest/1732/problem/D1",
    "problemId": "1601558",
    "problem_idx": "D1",
    "shortId": "1732D1",
    "contest_number": "1732",
    "problem_submissions": {
        "A": [
            177780757,
            177610358,
            177608551,
            177606643,
            177607169,
            177610084,
            177606577,
            177608412,
            177606634,
            177606927,
            177606608,
            177607362,
            177606772,
            177606726,
            177606713,
            177607069,
            177607097,
            177611108,
            177606918,
            177704415,
            177608226,
            177608992
        ],
        "E": [
            177657016,
            177656202,
            177633902,
            177640667,
            177803227,
            177634482,
            219606714,
            177713292,
            205728264
        ],
        "D2": [
            177641910,
            177631345,
            177624639,
            177622507,
            177657720,
            177627306,
            177634600,
            177636897,
            177705044,
            177639536,
            177633383,
            177633472,
            177633356,
            177632157,
            177640421,
            177640870,
            177713072,
            177632770,
            177633150,
            177631372,
            177704515,
            177639496,
            177628055
        ],
        "C2": [
            177632291,
            177641962,
            177622438,
            177615256,
            177628405,
            177620951,
            177620108,
            177616118,
            177614696,
            177620919,
            177623972,
            177616635,
            177637052,
            177635166,
            177620867,
            178222629,
            177623840,
            177623959,
            177628626,
            177704465,
            177632045,
            177631184
        ],
        "D1": [
            177621374,
            177621523,
            177609368,
            177617748,
            177635005,
            177615122,
            177622111,
            177619777,
            177625112,
            177625655,
            177620912,
            177619034,
            177613806,
            177616102,
            177629698,
            177628519,
            177632466,
            177625833,
            177704487,
            177616074,
            177626081
        ],
        "C1": [
            177616773,
            177634647,
            177613208,
            177615318,
            177628507,
            177619693,
            177620176,
            177616207,
            177614603,
            177613000,
            177624015,
            177616698,
            177626783,
            177614045,
            177620826,
            177623767,
            177623763,
            177621443,
            177704454,
            177618806,
            177621758
        ],
        "B": [
            177611173,
            177612224,
            177608250,
            177608561,
            177614708,
            177608123,
            177608457,
            177614546,
            177608888,
            177607945,
            177608753,
            177607801,
            177610965,
            177607589,
            177608533,
            177609886,
            177611017,
            177610279,
            177704436,
            177611009,
            177609323
        ]
    },
    "name": "D1. Balance  Easy version ",
    "statement": "Initially you have a set containing one element 0. You need to handle q\r\nqueries of the following types: x add the integer x to the set. It is\r\nguaranteed that this integer is not contained in the set; k find the k\r\ntext{-mex} of the set. In our problem, we define the k\r\ntext{-mex} of a set of integers as the smallest non-negative integer x\r\nthat is divisible by k and which is not contained in the set.\r\n",
    "solutions": [
        "#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,q;\nLL x,k;\nmap<LL,int>H,H2;\nsigned main(){\n\tsrand(time(0));\n\tgi(q);\n\twhile(q--){\n\t\tchar s[3];\n\t\tscanf(\"%s\",s+1);\n\t\tif(s[1]=='+'){\n\t\t\tgi(x);\n\t\t\tH2[x]=1;\n\t\t}else{\n\t\t\tgi(k);\n\t\t\tif(H.find(k)==H.end())H[k]=1;\n\t\t\tint now=H[k];\n\t\t\twhile(H2[1ll*now*k])now++;\n\t\t\tH[k]=now;\n\t\t\tpi(1ll*now*k,'\\n');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n\u9519\u8bef\u7684\uff0c\u504f\u6fc0\u7684\uff0c\u6781\u53f3\u7ffc\u7684\uff0c\u975e\u9a6c\u6069\u4e3b\u4e49\u7684\uff0c\u5973\u6743\u7684\uff0c\u5931\u8d25\u7684\uff0c\u4eba\u6c11\u65e5\u62a5\u7684\uff0c\u4e50\u7684\uff01 \n\u6587\u660e\u4e4b\u7f8e\u770b\u4e1c\u65b9\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Balance  Easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108327",
    "editorial": "Let\u00e2\u0080\u0099s look at a stupid solution and try to improve it.In a stupid\r\nsolution, we can simply add to the set, and when answering a query,\r\niterate over the numbers and so on until we find the answer. This\r\nsolution will take a long time if the answer is , where is large.We will\r\nimprove the solution. If a request comes to us for the first time for a\r\ngiven , then we calculate the answer for it greedily and remember it. In\r\nthe future, we will no longer check with whether there is a number in\r\nthe set, but with the previous answer.Let\u00e2\u0080\u0099s count for each value how\r\nmany times we can check for its presence in the set. First, we do this\r\nfor such that is divisible by . Secondly, the set must already contain\r\nelements , that is, numbers. Note that if is not one of the largest\r\ndivisors of , then becomes greater than . Therefore, this solution will\r\nwork quite quickly.\r\n"
}