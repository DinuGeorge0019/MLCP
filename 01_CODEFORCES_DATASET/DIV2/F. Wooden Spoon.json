{"link": "https://codeforces.com//contest/1786/problem/F", "problemId": "1767296", "problem_idx": "F", "shortId": "1786F", "contest_number": "1786", "problem_submissions": {"E": [192342570, 192306394, 192404273, 192327524, 192339032, 192311189, 192325805, 192320065, 192441626, 192343977, 192328171, 192315469, 192316636, 192338226, 192342670, 192339784, 192342778], "D": [192320379, 192313768, 192307277, 192318549, 192309409, 192292999, 192316314, 192320950, 192332305, 192309612, 192327595, 192325214, 192325223, 192311769, 192310059, 192313834, 192316588, 192327743], "F": [192310858, 192336618, 192349130, 192348404, 192333052, 192339600, 192329659, 192334176, 192328243, 192307751, 192340487, 192363526, 192345318], "C": [192293366, 192290648, 192294881, 192293245, 192293510, 192290179, 192292716, 192294689, 192305954, 192310133, 192289535, 192298071, 192296223, 192302623, 192296901, 192292106, 192294116, 192300798, 192295593, 192301556], "B": [192288687, 192344141, 192291360, 192289646, 192340206, 192287135, 192290672, 192302280, 192292700, 192296847, 192294213, 192293367, 192300808, 192292539, 192288767, 192289750, 192293496, 192292722, 192296815], "A2": [192287082, 192284625, 192286145, 192285724, 192290142, 192283788, 192286284, 192297549, 192284597, 192306985, 192286345, 192288530, 192296607, 192287030, 192284519, 192284365, 192288011, 192288312, 192289376], "A1": [192287049, 192283178, 192286410, 192283361, 192283338, 192284177, 192283764, 192296237, 192283279, 192307201, 192286846, 192283729, 192297100, 192283762, 192283137, 192282950, 192288217, 192285269, 192287405]}, "name": "F. Wooden Spoon", "statement": "2^n people, numbered with distinct integers from 1 to 2^n, are playing\r\nin a single elimination tournament. The bracket of the tournament is a\r\nfull binary tree of height n with 2^n leaves.When two players meet each\r\nother in a match, a player with the number always wins. The winner of\r\nthe tournament is the player who wins all n their matches.A virtual\r\nconsolation prize \"Wooden Spoon\" is awarded to a player who satisfies\r\nthe following n conditions: they lost their first match; the player who\r\nbeat them lost their second match; the player who beat that player lost\r\ntheir third match;\r\nldots; the player who beat the player from the previous condition lost\r\nthe final match of the tournament. It can be shown that there is always\r\nexactly one player who satisfies these conditions.Consider all possible\r\n(2^n)! arrangements of players into the tournament bracket. For each\r\nplayer, find the number of these arrangements in which they will be\r\nawarded the \"Wooden Spoon\", and print these numbers modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 2e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, (1 << 20) + 5)\ndef(p, int, 998244353)\n\nint n, m;\nint a[N];\nll f[N][21], pre[N][21];\n\nvoid solve() {\n\tcin >> n;\n\tComb::init(1 << n, p);\n\tf[1][1] = 1;\n\trep(i, 1, (1 << n)) pre[i][1] = 1;\n\tint al = 1 << n;\n\trep(i, 2, n) rep(j, 1, al) {\n\t\tf[j][i] = pre[j - 1][i - 1] * C(al - j - (1 << n - i), (1 << n - i) - 1) % p;\n\t\tpre[j][i] = (pre[j - 1][i] + f[j][i]) % p;\n\t}\n\tll t = qpow(n, 2, p);\n\trep(i, 1, n - 1) t = t * Comb::fac[1 << i] % p;\n\trep(i, 1, (1 << n)) cout << pre[i - 1][n] * t % p << '\\n';\n}\n\nint main() {\n\tint T = 1;\n\t// cin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "fft", "games", "math"], "dificulty": "2400", "interactive": false}