{
    "link": "https://codeforces.com//contest/1786/problem/F",
    "problemId": "1767296",
    "problem_idx": "F",
    "shortId": "1786F",
    "contest_number": "1786",
    "problem_submissions": {
        "E": [
            192342570,
            192306394,
            192404273,
            192327524,
            192339032,
            192311189,
            192325805,
            192320065,
            192441626,
            192343977,
            192328171,
            192315469,
            192316636,
            192338226,
            192342670,
            192339784,
            192342778
        ],
        "D": [
            192320379,
            192313768,
            192307277,
            192318549,
            192309409,
            192292999,
            192316314,
            192320950,
            192332305,
            192309612,
            192327595,
            192325214,
            192325223,
            192311769,
            192310059,
            192313834,
            192316588,
            192327743
        ],
        "F": [
            192310858,
            192336618,
            192349130,
            192348404,
            192333052,
            192339600,
            192329659,
            192334176,
            192328243,
            192307751,
            192340487,
            192363526,
            192345318
        ],
        "C": [
            192293366,
            192290648,
            192294881,
            192293245,
            192293510,
            192290179,
            192292716,
            192294689,
            192305954,
            192310133,
            192289535,
            192298071,
            192296223,
            192302623,
            192296901,
            192292106,
            192294116,
            192300798,
            192295593,
            192301556
        ],
        "B": [
            192288687,
            192344141,
            192291360,
            192289646,
            192340206,
            192287135,
            192290672,
            192302280,
            192292700,
            192296847,
            192294213,
            192293367,
            192300808,
            192292539,
            192288767,
            192289750,
            192293496,
            192292722,
            192296815
        ],
        "A2": [
            192287082,
            192284625,
            192286145,
            192285724,
            192290142,
            192283788,
            192286284,
            192297549,
            192284597,
            192306985,
            192286345,
            192288530,
            192296607,
            192287030,
            192284519,
            192284365,
            192288011,
            192288312,
            192289376
        ],
        "A1": [
            192287049,
            192283178,
            192286410,
            192283361,
            192283338,
            192284177,
            192283764,
            192296237,
            192283279,
            192307201,
            192286846,
            192283729,
            192297100,
            192283762,
            192283137,
            192282950,
            192288217,
            192285269,
            192287405
        ]
    },
    "name": "F. Wooden Spoon",
    "statement": "2^n people, numbered with distinct integers from 1 to 2^n, are playing\r\nin a single elimination tournament. The bracket of the tournament is a\r\nfull binary tree of height n with 2^n leaves.When two players meet each\r\nother in a match, a player with the number always wins. The winner of\r\nthe tournament is the player who wins all n their matches.A virtual\r\nconsolation prize \"Wooden Spoon\" is awarded to a player who satisfies\r\nthe following n conditions: they lost their first match; the player who\r\nbeat them lost their second match; the player who beat that player lost\r\ntheir third match;\r\nldots; the player who beat the player from the previous condition lost\r\nthe final match of the tournament. It can be shown that there is always\r\nexactly one player who satisfies these conditions.Consider all possible\r\n(2^n)! arrangements of players into the tournament bracket. For each\r\nplayer, find the number of these arrangements in which they will be\r\nawarded the \"Wooden Spoon\", and print these numbers modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 2e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, (1 << 20) + 5)\ndef(p, int, 998244353)\n\nint n, m;\nint a[N];\nll f[N][21], pre[N][21];\n\nvoid solve() {\n\tcin >> n;\n\tComb::init(1 << n, p);\n\tf[1][1] = 1;\n\trep(i, 1, (1 << n)) pre[i][1] = 1;\n\tint al = 1 << n;\n\trep(i, 2, n) rep(j, 1, al) {\n\t\tf[j][i] = pre[j - 1][i - 1] * C(al - j - (1 << n - i), (1 << n - i) - 1) % p;\n\t\tpre[j][i] = (pre[j - 1][i] + f[j][i]) % p;\n\t}\n\tll t = qpow(n, 2, p);\n\trep(i, 1, n - 1) t = t * Comb::fac[1 << i] % p;\n\trep(i, 1, (1 << n)) cout << pre[i - 1][n] * t % p << '\\n';\n}\n\nint main() {\n\tint T = 1;\n\t// cin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "games",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Wooden Spoon.json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "Let's focus on the sequence of players beating each other 1=a0<a1<\u0085<an\n: a0\n is the tournament champion, a0\n beats a1\n in the last match, a1\n beats a2\n in the second-to-last match, \u0085\n, an?1\n beats an\n in the first match.\n\nFor a fixed such sequence, how many ways are there to fill the tournament bracket?\n\nLet's look at the sequence in reverse.\n\nThere are 2n\n ways to put player an\n somewhere.\n\nPlayer an?1\n has to be the opponent of player an\n in the first match.\n\nPlayer an?2\n has to beat some player b>an?2\n in the first match, and then beat an?1\n in the second match. There are 2n?an?2?2\n ways to choose player b\n (since it can not be equal to an?1\n and an\n), and there are also 2\n ways to order an?2\n and b\n.\n\nPlayer an?3\n has to be the winner of a subbracket containing 3\n other players c1,c2,c3>an?3\n, and then beat an?2\n in the third match. There are 2n?an?3?4\n players to choose ci\n from (since they can not be equal to an?2\n, an?1\n, an\n, and b\n), and there are (2n?an?3?43)\n ways to do so, and there are also 4!\n ways to order an?3\n, c1\n, c2\n, and c3\n.\n\nIn general, player an?i\n has to be the winner of a subbracket containing 2i?1?1\n other players, and there are 2n?an?i?2i?1\n players to choose from, and there are (2n?an?i?2i?12i?1?1)\n ways to choose, and also (2i?1)!\n ways to order this subbracket.\n\nYou can see that the total number of brackets for a fixed sequence 1=a0<a1<\u0085<an\n can be represented as f(a0,0)?f(a1,1)?\u0085?f(an?1,n?1)?f(an,n)\n, where f(ai,i)\n is some function of a player number and a round number.\n\nNow let's use dynamic programming: let d(ai,i)\n be the sum of products of f(a0,0)?f(a1,1)?\u0085?f(ai,i)\n over all sequences 1=a0<a1<\u0085<ai\n. Then:\n\nd(1,0)=f(1,0)\n;\nd(a0,0)=0\n for a0>1\n;\nd(ai,i)=f(ai,i)??ai?1=1ai?1d(ai?1,i?1)\n for i>0\n.\nThe answer for player x\n is d(x,n)\n.\n\nThis DP has O(n?2n)\n states, and note that the inner sums in the formulas for d(ai,i)\n and d(ai+1,i)\n only differ by one summand. Thus, by using cumulative sums for transitions, we can achieve an O(n?2n)\n time complexity."
}