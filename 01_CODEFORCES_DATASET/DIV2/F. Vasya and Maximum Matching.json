{
    "link": "https://codeforces.com//contest/1079/problem/F",
    "problemId": "257676",
    "problem_idx": "F",
    "shortId": "1079F",
    "contest_number": "1079",
    "problem_submissions": {
        "E": [
            45934267,
            45936636,
            45941806,
            45937565,
            45939333,
            45937199,
            45940743,
            45942158,
            45941402,
            46104036,
            45963146,
            45940904,
            45946313
        ],
        "D": [
            45931502,
            45929943,
            45928202,
            45933972,
            45932585,
            45928454,
            45926585,
            45928651,
            45928898,
            45928856,
            45930400,
            45930743,
            45929548,
            45929551,
            45931333,
            45929717,
            45931175,
            45930151,
            45933096
        ],
        "C": [
            45927571,
            45925544,
            45925366,
            45932689,
            45926037,
            45924078,
            45924314,
            45925482,
            45926594,
            45925976,
            45921399,
            45924312,
            45926518,
            45925797,
            45924767,
            45926026,
            45925780,
            45927583,
            45925054
        ],
        "B": [
            45922164,
            45922160,
            45923256,
            45930687,
            45951085,
            45921961,
            45921919,
            45922366,
            45922028,
            45923115,
            45924050,
            45922108,
            45922170,
            45923305,
            45921946,
            45922922,
            45922642,
            45922803,
            45922288
        ],
        "A": [
            45920252,
            45920257,
            45923913,
            45925594,
            45920970,
            45920420,
            45920504,
            45920483,
            45920269,
            45921357,
            45926632,
            45920349,
            45920289,
            45920409,
            45920196,
            45920480,
            45920373,
            45920574,
            45920303
        ],
        "F": [
            46007936,
            46007802,
            46007752,
            45995791,
            45995576,
            45995489,
            45995039,
            45994859,
            45992076
        ],
        "G": [
            45942230
        ]
    },
    "name": "F. Vasya and Maximum Matching",
    "statement": "Vasya has got a tree consisting of n vertices. He wants to delete some\r\n(possibly zero) edges in this tree such that the maximum matching in the\r\nresulting graph is unique. He asks you to calculate the number of ways\r\nto choose a set of edges to remove.A matching in the graph is a subset\r\nof its edges such that there is no vertex incident to two (or more)\r\nedges from the subset. A maximum matching is a matching such that the\r\nnumber of edges in the subset is maximum possible among all matchings in\r\nthis graph.Since the answer may be large, output it modulo 998244353.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#ifdef ONLINE_JUDGE\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#endif\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment(linker, \"/stack:200000000\")\n#include <bits/stdc++.h>\n#include <deque>\n#include <type_traits>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\ntemplate<typename Key=int,typename Mapped=__gnu_pbds::null_type,typename Cmp_Fn=std::less<Key>,typename Tag=__gnu_pbds::rb_tree_tag,template<typename Const_Node_Iterator,typename Node_Iterator,typename Cmp_Fn_,typename Allocator_>class Node_Update=__gnu_pbds::tree_order_statistics_node_update,typename Allocator=std::allocator<char>>class ordered_set_t:__gnu_pbds::tree<Key,Mapped,Cmp_Fn,Tag,Node_Update,Allocator>{};const int GRANDOM=std::chrono::high_resolution_clock::now().time_since_epoch().count();struct ghash{int operator()(int x){return std::hash<int>{}(x^GRANDOM);}};template<typename KeyType>class hash_table_t:__gnu_pbds::gp_hash_table<KeyType,int,ghash>{};namespace vh{template<class T>void _R(T&x){std::cin>>x;}inline void _R(int&x){scanf(\"%d\",&x);}inline void _R(int64_t&x){scanf(\"%\" SCNd64,&x);}inline void _R(double&x){scanf(\"%lf\",&x);}inline void _R(char&x){scanf(\" %c\",&x);}inline void _R(char*x){scanf(\"%s\",x);}inline void R(){}template<class T,class... U>inline void R(T&head,U&... tail){_R(head);R(tail...);}template<class T>void _W(const T&x){cout<<x;}inline void _W(const int&x){printf(\"%d\",x);}inline void _W(const int64_t&x){printf(\"%\" PRId64,x);}inline void _W(const double&x){printf(\"%.16f\",x);}inline void _W(const char&x){putchar(x);}inline void _W(const char*x){printf(\"%s\",x);}template<class T>inline void _W(const vector<T>&x){for(auto i=x.begin();i!=x.end();_W(*i++))if(i!=x.cbegin())putchar(' ');}inline void W(){}template<class T,class... U>inline void W(const T&head,const U&... tail){_W(head);if(sizeof...(tail))putchar(' '),W(tail...);}template<class T,class... U>inline void WL(const T&head,const U&... tail){_W(head);putchar(sizeof...(tail)? ' ':'\\n');W(tail...);}};\n#define prec setprecision\nnamespace vh{typedef long long ll;typedef unsigned long long llu;template<typename T>T gcd(T m,T n){while(n){T t=m%n;m=n;n=t;};return m;}template<typename T>T exgcd(T a,T b,T&sa,T&ta){T q,r,sb=0,tb=1,sc,tc;sa=1,ta=0;if(b)do q=a/b,r=a-q*b,a=b,b=r,sc=sa-q*sb,sa=sb,sb=sc,tc=ta-q*tb,ta=tb,tb=tc;while(b);return a;}template<typename T>T mul_inv(T a,T b){T t1=a,t2=b,t3;T v1=1,v2=0,v3;T x;while(t2!=1)x=t1/t2,t3=t1-x*t2,v3=v1-x*v2,t1=t2,t2=t3,v1=v2,v2=v3;return(v2+b)%b;}template<typename T>T powmod(T a,T b,T MOD){if(b<0)return 0;T rv=1;while(b)(b%2)&&(rv=(rv*a)%MOD),a=a*a%MOD,b/=2;return rv;}template<typename T>inline T isqrt(T k){T r=sqrt((double)k)+1;while(r*r>k)r--;return r;}template<typename T>inline T icbrt(T k){T r=cbrt((double)k)+1;while(r*r*r>k)r--;return r;}template<typename T>bool mul_overflow(T&r,T a,T b){return __builtin_mul_overflow(a,b,&r);}template<ll n>struct BitSize{enum{Size=BitSize<n/2>::Size+1};};template<>struct BitSize<0>{enum{Size=1};};template<>struct BitSize<1>{enum{Size=1};};\n#define BITSIZE(n) (BitSize<n>::Size)\n#define BITMAX(n) (BitSize<n>::Size - 1)\n#define DEBUG !defined(ONLINE_JUDGE)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define RALL(x) (x).rbegin(),(x).rend()\ntemplate<typename TH>void _dbg(const char*sdbg,TH h){cerr<<sdbg<<\"=\"<<h<<\"\\n\";}template<typename TH,typename... TA>void _dbg(const char*sdbg,TH h,TA... t){while(*sdbg!=',')cerr<<*sdbg++;cerr<<\"=\"<<h<<\",\";_dbg(sdbg+1,t...);}\n#ifdef DEBUG\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; for(auto itt: x) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n}namespace vh{template<typename T>int min_rotation(vector<T>s){int a=0,N=s.size();for(int b=0;b<N;b++)for(int i=0;i<N;i++){if(a+i==b||s[(a+i)%N]<s[(b+i)%N]){b+=max(0,i-1);break;}if(s[(a+i)%N]>s[(b+i)%N]){a=b;break;}}return a;}}namespace vh{template<ll MOD,typename T=ll>class FiniteField{typedef FiniteField<MOD,T>self;public:ll val;FiniteField(ll x=0):val(normalize(x)){}inline T normalize(T x){x%=MOD;return normalize2(x);}inline T normalize2(T x){if(x<0)x+=MOD;if(x>=MOD)x-=MOD;return x;}self&operator=(const self&o){val=o.val;return*this;}template<typename NT>self&operator=(const NT o){val=normalize(o);return*this;}self&operator+=(const self&o){val=normalize2(val+o.val);return*this;}template<typename NT>self&operator+=(const NT o){val=normalize(val+(o));return*this;}self&operator-=(const self&o){val=normalize2(val-o.val);return*this;}template<typename NT>self&operator-=(const NT o){val=normalize(val-(o));return*this;}self&operator*=(const self&o){return*this*=o.val;}template<typename NT>self&operator*=(const NT o){val=normalize(val*o);return*this;}self operator+(const self&o){return self(normalize2(val+o.val));}template<typename NT>self operator+(const NT o){return self(normalize2(val+(o)));}self operator-(const self&o){return self(normalize2(val-o.val));}template<typename NT>self operator-(const NT o){return self(normalize2(val-(o)));}self operator-(){return self(normalize(-val));}self operator*(const self&o){return self(normalize(val*o.val));}template<typename NT>self operator*(const NT o){return self(normalize(val*(o)));}operator T()const{return val;}};};namespace vh{};\nnamespace vh{\n  const int maxn=3e5+7;\n  const ll MOD=998244353;\n  int n;\n  vector<int>adj[maxn];\n  typedef FiniteField<MOD>number_t;\n  struct DPE{\n    number_t matched;\n    number_t need_match;\n    number_t valid;\n  };\n  DPE solve(int u,int p){\n    DPE r;\n    number_t valid_any=1;\n    number_t valid_matched=0;\n    number_t valid_unmatched=1;\n    vector<number_t>need_match;\n    vector<number_t>valid_child;\n    for(int v:adj[u])if(v!=p){\n      auto s=solve(v,u);\n      valid_unmatched*=s.valid;\n      valid_any*=s.valid+s.matched;\n      need_match.push_back(s.need_match);\n      valid_child.push_back(s.valid+s.matched);\n    }\n    if(auto sz=valid_child.size()){\n      vector<number_t>valid_left(sz,0);\n      valid_left[0]=1;\n      for(int i=1;i<sz;i++)valid_left[i]=valid_left[i-1]*valid_child[i-1];\n      vector<number_t>valid_right(sz,0);\n      valid_right[sz-1]=1;\n      for(int i=sz-2;i>=0;i--)valid_right[i]=valid_right[i+1]*valid_child[i+1];\n      for(int i=0;i<sz;i++)valid_matched+=valid_left[i]*need_match[i]*valid_right[i];\n    }\n    r.need_match=valid_any;\n    r.matched=valid_matched;\n    r.valid=valid_matched+valid_unmatched;\n    return r;\n  }\n  DPE solve_optimized(int u,int p){\n    DPE r={0,1,1};\n    for(int v:adj[u])if(v!=p){\n      auto s=solve_optimized(v,u);\n      r.valid*=s.valid;\n      r.matched=r.matched*(s.valid+s.matched)+r.need_match*s.need_match;\n      r.need_match*=s.valid+s.matched;\n    }\n    r.valid+=r.matched;\n    return r;\n  }\n  int main(){\n    srand(GRANDOM);\n    cin>>n;\n    for(int i=2;i<=n;i++){\n      int u,v;cin>>u>>v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n    cout<<(solve_optimized(1,0).valid).val<<endl;\n    return 0;\n  }\n};\nint main(int argc,char*argv[]){\n  std::cin.sync_with_stdio(false);std::cin.tie(nullptr);\n  return vh::main();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Vasya and Maximum Matching.json",
    "editorial_link": "https://codeforces.com//blog/entry/63324",
    "editorial": "Firstly let's understand when the maximum matching in the tree is unique  and it is unique if and only if it's perfect (i.?e. every vertex having at least one incident edge is saturated). So the problem is reduced to counting the number of ways to split the tree so that each component having size 2\n or more has a perfect matching.\n\nLet's use dynamic programming to do this. Let dpv,02\n be the number of ways to delete edges in the subtree of v\n so that in this subtree every component is valid (if its size is more than 1\n, then it has a perfect matching). The second parameter can take one of three values:\n\ndpv,0\n  v\n can be used for the matching (but it's not necessary to do it).\n\ndpv,1\n  v\n is already used in the matching.\n\ndpv,2\n  v\n is not used in the matching yet, but we have to match it to some vertex.\n\nThen\n\ndpv,0=?todpto,0+?to(dpto,1??to?,to??to(dpto?,0+dpto?,2))\n,\n\ndpv,1=?to(dpto,0+dpto,2)\n,\n\ndpv,2=?to(dpto,1??to?,to??to(dpto?,0+dpto?,2))\n,\n\nwhere to\n and to?\n are children of v\n.",
    "hint": []
}