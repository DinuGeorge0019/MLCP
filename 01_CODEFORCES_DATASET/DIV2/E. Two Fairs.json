{
    "link": "https://codeforces.com//contest/1277/problem/E",
    "problemId": "495585",
    "problem_idx": "E",
    "shortId": "1277E",
    "contest_number": "1277",
    "problem_submissions": {
        "F": [
            66866628,
            66860664,
            66862829,
            66860439,
            66977841,
            66899469,
            66863808,
            92979782,
            92978994,
            92978960,
            92978865,
            66891528,
            66889235,
            66866269,
            67019482
        ],
        "D": [
            66856749,
            66864218,
            66854207,
            66847715,
            66844420,
            66847306,
            66854098,
            66848610,
            66848065,
            66848280,
            66844474,
            66849217,
            66848886,
            66864076,
            66847735
        ],
        "E": [
            66850123,
            66849554,
            66847076,
            66854313,
            66848191,
            66853241,
            66855295,
            66853466,
            66848425,
            66855580,
            66855848,
            66853292,
            66856132,
            92977693,
            66856983,
            66854785,
            125051093,
            66850783,
            66861075
        ],
        "C": [
            66841382,
            66842457,
            66841119,
            66845741,
            66837706,
            66839907,
            66838468,
            66840457,
            66839782,
            66840815,
            66841610,
            66843424,
            66846378,
            66837428,
            66844848,
            66841436,
            66840246,
            66839763
        ],
        "B": [
            66837718,
            66838330,
            66834438,
            66842100,
            66834455,
            66836147,
            66833752,
            66836537,
            66835874,
            66836673,
            66837137,
            66837196,
            66974853,
            66841617,
            66834535,
            66838161,
            66835795,
            66834507,
            66836405
        ],
        "A": [
            66834598,
            66836237,
            66833655,
            66838372,
            66833757,
            66834211,
            66833507,
            66833800,
            66834296,
            66834715,
            66834270,
            66834723,
            66974834,
            66839401,
            66833706,
            66836909,
            66833653,
            66833594,
            66833715
        ]
    },
    "name": "E. Two Fairs",
    "statement": "There are n cities in Berland and some pairs of them are connected by\r\ntwo-way roads. It is guaranteed that you can pass from any city to any\r\nother, moving along the roads. Cities are numerated from 1 to n.Two\r\nfairs are currently taking place in Berland they are held in two\r\ndifferent cities a and b (1\r\nle a, b\r\nle n; a\r\nne b).Find the number of pairs of cities x and y (x\r\nne a, x\r\nne b, y\r\nne a, y\r\nne b) such that if you go from x to y you will have to go through both\r\nfairs (the order of visits doesn’t matter). Formally, you need to find\r\nthe number of pairs of cities x,y such that any path from x to y goes\r\nthrough a and b (in any order).Print the required number of pairs. The\r\norder of two cities in a pair does not matter, that is, the pairs (x,y)\r\nand (y,x) must be taken into account only once.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\nvector<int> G[(int)1e6];\nbool checkedA[(int)1e6], checkedB[(int)1e6];\n\nvoid saikiA(int now, int b){\n  if(checkedA[now]) return;\n  checkedA[now] = true;\n  if(now==b) return;\n  rep(j,G[now].size()){\n    int next = G[now][j];\n    saikiA(next, b);\n  }\n}\n\nvoid saikiB(int now, int a){\n  if(checkedB[now]) return;\n  checkedB[now] = true;\n  if(now==a) return;\n  rep(j,G[now].size()){\n    int next = G[now][j];\n    saikiB(next, a);\n  }\n}\n\nint main(void){\n  int t;\n  cin>>t;\n  rep(t_, t){\n    int n,m,a,b;\n    cin>>n>>m>>a>>b;\n    a--;b--;\n    rep(i,n){\n      G[i].clear();\n      checkedA[i] = false;\n      checkedB[i] = false;\n    }\n    rep(i,m){\n      int u,v;\n      cin>>u>>v;\n      u--;\n      v--;\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    saikiA(a,b);\n    saikiB(b,a);\n\n    ll countA=0, countB=0;\n    rep(i,n){\n      if(checkedA[i] && !checkedB[i]){\n        countA++;\n      }else if(checkedB[i] && !checkedA[i]){\n        countB++;\n      }\n    }\n    cout<<countA*countB<<endl;\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Two Fairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "This problem has a simple linear solution (just two depth-first searches) without involving cut points, biconnected components, and other advanced techniques.\n\nLet's reformulate this problem in the language of graph theory: you are given an undirected graph and two vertices a\n and b\n, you need to find the number of pairs of vertices (x,y\n) such that any path from x\n to y\n contains both vertices a\n and b\n.\n\nIn other words, we are interested in pairs of vertices (x,y\n) such that deleting the vertex a\n (while going from b\n) breaks the connection from x\n to y\n and deleting the vertex b\n (while going from a\n) breaks the connection from x\n to y\n.\n\nLet's remove the vertex a\n and select the connected components in the resulting graph. Similarly, we remove the vertex b\n and select the connected components in the resulting graph. Then the pair (x,y\n) interests us if x\n and y\n belong to different components both when removing a\n and when removing b\n.\n\nThus, let's find a pair of (?u,?u)\n for each vertex u\n. It will be numbers of the connected components when a\n and b\n are removed, respectively. The pair (x,y\n) interests us if (?x,?x)?(?y,?y)\n.\n\nThe total number of vertex pairs is n?(n?1)/2\n. Let's subtract the number of uninteresting pairs from it.\n\nFirstly, these are pairs such that (?x,?x)\n and (?y,?y)\n partially equals (in exactly one component). For example, let the equality be on the first component in the common value of ?\n. Let the total number of pairs (?u,?u)\n such that ?u=?\n be equal to c\n, then subtract c?(c?1)/2\n from the current answer. We will do this with all ?\n and ?\n.\n\nNote that some uninteresting pairs were counted twice. These are pairs of vertices such that (?x,?x)\n and (?y,?y)\n equals in both components. We can count the number of corresponding vertices c\n and add c?(c?1)/2\n to the current answer for each pair.\n\nIn the following code, let p\n be an array of pairs of component numbers for all vertices except a\n and b\n. Each pair is the number of the connected component of this vertex if a\n is removed, and the number of the connected component of this vertex if b\n is removed. Then the main part of the solution can be like this:",
    "hint": []
}