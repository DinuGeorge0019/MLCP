{
    "link": "https://codeforces.com//contest/752/problem/E",
    "problemId": "86740",
    "problem_idx": "E",
    "shortId": "752E",
    "contest_number": "752",
    "problem_submissions": {
        "E": [
            23307622,
            23298919,
            23293210,
            23296558,
            23289533,
            23300446,
            23289683,
            23303428,
            23297443,
            23304427,
            23304013,
            23301941,
            23302122,
            23296625,
            23299319,
            23308344,
            23296295,
            23301867,
            23298965
        ],
        "F": [
            23299614,
            23303097,
            23296260,
            23300075,
            23297820,
            23312296,
            23333337,
            23302007,
            23335434,
            23945130
        ],
        "D": [
            23293425,
            23296203,
            23296737,
            23303994,
            23297487,
            23296079,
            23297542,
            23304572,
            23298416,
            23301016,
            23298334,
            23301490,
            23342391,
            23303337,
            23298346,
            23305352,
            23295756,
            23302406
        ],
        "B": [
            23289571,
            23288739,
            23297269,
            23301250,
            23289332,
            23290328,
            23290841,
            23289310,
            23291467,
            23292074,
            23312032,
            23305914,
            23302012,
            23289784,
            23305350
        ],
        "C": [
            23288680,
            23289735,
            23290504,
            23291795,
            23293248,
            23292966,
            23293101,
            23290858,
            23293431,
            23292145,
            23290141,
            23293830,
            23292041,
            23293667,
            23293134,
            23292174,
            23291253,
            23291455,
            23296543,
            23939849,
            23294485
        ],
        "A": [
            23288066,
            23288054,
            23288222,
            23289194,
            23290949,
            23288138,
            23294677,
            23288200,
            23288517,
            23288677,
            23288100,
            23288709,
            23288239,
            23288139,
            23288488,
            23288364,
            23288063,
            23288232,
            23288317,
            23288593
        ]
    },
    "name": "E. Santa Claus and Tangerines",
    "statement": "Santa Claus has tangerines, and the -th of them consists of exactly\r\nslices. Santa Claus came to a school which has pupils. Santa decided to\r\ntreat them with tangerines.However, there can be too few tangerines to\r\npresent at least one tangerine to each pupil. So Santa decided to divide\r\ntangerines into parts so that no one will be offended. In order to do\r\nthis, he can divide a tangerine or any existing part into two smaller\r\nequal parts. If the number of slices in the part he wants to split is\r\nodd, then one of the resulting parts will have one slice more than the\r\nother. It\u2019s forbidden to divide a part consisting of only one slice.\r\n(that also means that everyone must get a positive number of slices).\r\nOne or several tangerines or their parts may stay with Santa.Let be the\r\nnumber of slices the -th pupil has in the end. Let Santa\u2019s be the\r\nminimum among all \u2019s.Your task is to find the maximum possible Santa can\r\nhave after he treats everyone with tangerines (or their parts).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N;\nll dp[10100100];\nll K, a[1100100], lo, hi, mid, ans=-1;\n\nbool check (ll v) {\n\tfo(i, 0, 10100100) dp[i] = 0;\n\tfo(i, 0, N) dp[a[i]]++;\n\tll sum = 0;\n\tfor (int i = 10100100; i--; ) {\n\t\tif (i/2 < v) {\n\t\t\tif (i >= v) {\n\t\t\t\tsum = min(K, sum + dp[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tdp[i/2] = min(K, dp[i/2] + dp[i]);\n\t\t\tdp[(i+1)/2] = min(K, dp[(i+1)/2] + dp[i]);\n\t\t\tdp[i] = 0;\n\t\t}\n\t}\n\treturn sum >= K;\n}\n\nint main () {\n\tscanf(\"%d %lld\", &N, &K);\n\tfo(i, 0, N) scanf(\"%lld\", &a[i]);\n\tsort(a, a+N);\n\n\tlo = 1, hi = a[N-1];\n\twhile (lo <= hi) {\n\t\tmid = (lo + hi) / 2;\n\t\tif (check(mid)) ans = mid, lo = mid+1;\n\t\telse hi = mid-1;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Santa Claus and Tangerines.json",
    "editorial_link": "https://codeforces.com//blog/entry/49328",
    "editorial": "It is obvious that if the total number of slices is less than k, then the answer is ?-?1. Otherwise it's at least 1. Let's find the answer in this case.\n\nLet's divide tangerines and parts in halves one by one in order to find the best answer. It's easy to see that it makes no sense to divide a part of size x if there is an undivided part of size y?>?x. So we are going to proceed dividing the largest part on each step. Let's also maintain current answer, i. e. the size of the k-th biggest current part, and a set of parts which we are going to present to the pupils. When we divide the largest part, there are two possible cases:\n\nIf the size of any part is less then the current answer, then it's obvious that the answer will never be greater if we proceed further, so we can stop the process.\nIf the sizes of both parts are greater than or equal to the current answer, then we should delete the initial part and add the resulting parts to those we present to the pupils in the current answer, and then delete the smallest part from the set making it of size k again.\nWe can see that in the second case the answer never decreases so we can just proceed until the first case happens.\n\nTo emulate this process in a fast way, we can keep an array from 1 to A, where A?=?107 is the maximum possible number of slices in a part, where each cell contain the current number of parts of that size. Thus, we can maintain two pointers: one to the current answer and one to the current maximum size, so the whole process can be done in O(n). The overall complexity is O(n?+?A)."
}