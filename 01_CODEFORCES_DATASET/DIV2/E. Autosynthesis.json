{
    "link": "https://codeforces.com//contest/1877/problem/E",
    "problemId": "2251956",
    "problem_idx": "E",
    "shortId": "1877E",
    "contest_number": "1877",
    "problem_submissions": {
        "F": [
            227174558,
            227466890,
            227293603,
            227329252
        ],
        "E": [
            227163070,
            227145733,
            227144090,
            227153972,
            227157518,
            227156560,
            227163724,
            227161365,
            227162255,
            227162229,
            227160325,
            227160791,
            227163873,
            227162598,
            227166392,
            227166841,
            227158401,
            227162185,
            227162372
        ],
        "D": [
            227138699,
            227131389,
            227129888,
            227134099,
            227129112,
            227133071,
            227133077,
            227144267,
            227136086,
            227139472,
            227138655,
            227139596,
            227138226,
            227141861,
            227140431,
            227137088,
            227140648,
            227146399,
            227136902
        ],
        "C": [
            227133414,
            227127308,
            227127530,
            227125282,
            227126156,
            227610507,
            227128623,
            227127297,
            227125856,
            227127429,
            227131821,
            227132500,
            227131322,
            227128501,
            227133505,
            227132343,
            227131403,
            227133386,
            227133010,
            227130729
        ],
        "B": [
            227128215,
            227121053,
            227122944,
            227120105,
            227119973,
            227121777,
            227121712,
            227120149,
            227123349,
            227121082,
            227122657,
            227123511,
            227122887,
            227123130,
            227122430,
            227122300,
            227131461,
            227125290,
            227124467
        ],
        "A": [
            227124912,
            227116905,
            227115298,
            227115060,
            227115015,
            227610458,
            227116248,
            227116367,
            227115306,
            227116532,
            227115007,
            227115508,
            227115261,
            227115583,
            227117792,
            227115925,
            227115499,
            227117913,
            227116538,
            227116495
        ]
    },
    "name": "E. Autosynthesis",
    "statement": "Chaneka writes down an array a of n positive integer elements.\r\nInitially, all elements are not circled. In one operation, Chaneka can\r\ncircle an element. It is possible to circle the same element more than\r\nonce.After doing all operations, Chaneka makes a sequence r consisting\r\nof all elements of a following the order of their indices.Chaneka also\r\nmakes another sequence p such that its length is equal to the number of\r\noperations performed and p_i is the of the element that is circled in\r\nthe i-th operation.Chaneka wants to do several operations such that\r\nsequence r is equal to sequence p. Help her achieve this, or report if\r\nit is impossible! Note that if there are multiple solutions, you can\r\nprint any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long \n#define pb push_back\nusing namespace std;\nconst int INF=1e6+5;\nconst int Mod=998244353;\nint n,in[INF],co[INF],nxt[INF],p[INF],fl,vis[INF],aa[INF],vis2[INF];\nvector <int> ans;\nvoid DFS(int x,int y) {\n\tif (y) ans.pb(x);\n\tvis[x]=1;\n\tif (co[nxt[x]]==-1) {\n\t\tco[nxt[x]]=y^1;\n\t\tDFS(nxt[x],y^1);\n\t}\n\telse if (co[nxt[x]]!=(y^1)) fl=1;\n}\nqueue <int> q;\nvoid solve(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++) co[i]=-1;\n\tfor (int i=1;i<=n;i++) {\n\t\tint x=0;cin>>x;\n\t\tnxt[i]=x;p[x]=i;\n\t\taa[i]=x;in[x]++;\n\t}\n\tfor (int i=1;i<=n;i++) if (!in[i]) q.push(i);\n\twhile (q.size()) {\n\t\tint x=q.front();q.pop();\n\t\tvis[x]=1;ans.pb(nxt[x]);\n\t\tif (!vis[nxt[x]] && !--in[nxt[nxt[x]]]) q.push(nxt[nxt[x]]);\n\t\tvis[nxt[x]]=1;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]) {\n\t\t\tco[i]=0;\n\t\t\tDFS(i,0);\n\t\t}\n\tif (fl) cout<<\"-1\\n\";\n\telse {\n\t\tvector <int> res;\n\t\tfor (int i:ans) vis2[i]=1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (!vis2[i]) res.pb(aa[i]);\n\t\tcout<<res.size()<<\"\\n\";\n\t\tfor (int i:res) cout<<i<<\" \";\n\t\tcout<<\"\\n\";\n\t}\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tint t=1;\n\twhile (t--) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Autosynthesis.json",
    "editorial_link": "https://codeforces.com//blog/entry/121200",
    "editorial": "Let\u00e2\u0080\u0099s say we have coloured each element of into black or white and we\r\nwant to find a sequence of operations that results in all black elements\r\nbeing circles and all white elements being uncircled. Notice that such a\r\nsequence exists if and only if the following holds: For each black\r\nelement, there must exist at least one white element with a equal to the\r\nof that black element. (There must be a value in that circles that black\r\nelement) For each white element, there cannot be any white element with\r\na equal to the of that black element. (There cannot be a value in that\r\ncircles that white element) Construct a directed graph of vertices and\r\ndirected edges. Each edge is from vertex to vertex . For an edge from to\r\n, define as a child of and define as a parent of . Notice that each\r\nvertex only has exactly one parent. This means that each connected\r\ncomponent in the graph looks like a directed rooted tree with a cycle of\r\narbitrary size at the root.Let each vertex represent whether element is\r\nwhite or black. From the knowledge above, we can get the following for\r\ndetermining the colour of a certain vertex: If it has at least one white\r\nchild, then it must be black. If it has no white children, then it must\r\nbe white. This means we can determine the colour of a vertex once we\r\nhave determined the colours of its children. Additionally, once there is\r\nat least one white child, we can guarantee the vertex to be black.We can\r\nsolve this by maintaining a queue. First, fill the queue with each\r\nvertex with no children ( indegree). When we process a vertex in the\r\nqueue, determine the colour using the rules above, and then decrease the\r\nindegree of its parent (as if the current processed vertex is deleted\r\nfrom the graph). If the indegree of the parent reaches , add the parent\r\nto the queue. In particular, if the current vertex is white, we can\r\nimmediately determine the colour of the parent to be black and add it to\r\nthe queue as well.The process stops once there are no vertices left with\r\nindegrees and none of the remaining vertices has a white child. Because\r\nof the special structure of the graph, once this happens, the remaining\r\ngraph only contains zero or more disjoint cycles.Let\u00e2\u0080\u0099s solve each cycle\r\nindependently. Notice that if a cycle is of even length, we can colour\r\nits vertices black and white alternatingly. However, if a cycle is of\r\nodd length, it is impossible to colour it.Time complexity:\r\n"
}