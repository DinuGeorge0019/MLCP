{"link": "https://codeforces.com//contest/1451/problem/C", "problemId": "804299", "problem_idx": "C", "shortId": "1451C", "contest_number": "1451", "problem_submissions": {"E2": [99164666, 99162733, 99165925, 99161646, 99162275, 99166708, 99177844, 99187045, 99171193, 99180740, 99166779, 99593065, 99167139, 99212094, 99180750, 99167382, 99164289, 99170306, 99166489, 99174952, 99170046], "F": [99157323, 99174334, 99172211, 99171897, 99169968, 99159796, 99185696, 99185913, 99161260, 99186126, 101852088, 99331616, 99277099, 99194656], "E1": [99152747, 99148819, 99166585, 99161270, 99161762, 99166831, 99177296, 99186671, 99171561, 99180543, 99167295, 99166954, 99212099, 99162460, 99166940, 99164739, 99169616, 99166777, 99174556, 99160048], "B": [99139927, 99129712, 99127148, 99131588, 99133196, 99173277, 99136243, 99144900, 99179324, 99132526, 99124656, 99134309, 99211443, 99138683, 99129420, 99135350, 99127140, 99142430, 99125493, 99136003], "C": [99137455, 99134588, 99132257, 99139076, 99140138, 99171814, 99145789, 99142052, 99183664, 99140696, 99133474, 99140223, 99211399, 99130542, 99135361, 99140699, 99137433, 99148880, 99132285, 99139620], "D": [99133620, 99140832, 99142901, 99155332, 99185292, 99169795, 99166634, 99139104, 99176250, 99168173, 99147779, 99144152, 99212069, 99141953, 99149299, 99150791, 99154805, 99153259, 99147140, 99162814], "A": [99120654, 99120423, 99121791, 99121810, 99124507, 99174166, 99122054, 99147895, 99180245, 99124534, 99120454, 99123326, 99211324, 99120847, 99120693, 99131959, 99121501, 99120866, 99121109, 99120621]}, "name": "C. String Equality", "statement": "Ashish has two strings a and b, each of length n, and an integer k. The\r\nstrings only contain lowercase English letters.He wants to convert\r\nstring a into string b by performing some (possibly zero) operations on\r\na.In one move, he can either choose an index i (1\r\nleq i\r\nleq n-1) and swap a_i and a_{i+1}, or choose an index i (1\r\nleq i\r\nleq n-k+1) and if a_i, a_{i+1},\r\nldots, a_{i+k-1} are to some character c (c\r\nneq \u201d), replace each one with the next character (c+1), that is, \u201d is\r\nreplaced by \u201d, \u201d is replaced by \u201d and so on. Note that he can perform\r\nany number of operations, and the operations can only be performed on\r\nstring a. Help Ashish determine if it is possible to convert string a\r\ninto b after performing some (possibly zero) operations on it.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nint ca[30];\nint cb[30];\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tint n,k; cin>>n>>k;\n\t\tmemset(ca,0,sizeof(ca));\n\t\tmemset(cb,0,sizeof(cb));\n\t\tstring a,b; cin>>a>>b;\n\t\tfor(char c:a)\n\t\t{\n\t\t\tca[c-'a']++;\n\t\t}\n\t\tfor(char c:b)\n\t\t{\n\t\t\tca[c-'a']--;\n\t\t}\n\t\tbool pos=1;\n\t\tfor(int i=0;i<25;i++)\n\t\t{\n\t\t\twhile(ca[i]>=k)\n\t\t\t{\n\t\t\t\tca[i]-=k; ca[i+1]+=k;\n\t\t\t}\n\t\t\tif(ca[i]<0){pos=0; break;}\n\t\t}\n\t\tif(ca[25]<0) pos=0;\n\t\tif(pos) cout<<\"Yes\\n\";\n\t\telse cout<<\"No\\n\";\n\t}\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy", "hashing", "implementation", "strings"], "dificulty": "1400", "interactive": false}