{
    "link": "https://codeforces.com//contest/982/problem/C",
    "problemId": "183673",
    "problem_idx": "C",
    "shortId": "982C",
    "contest_number": "982",
    "problem_submissions": {
        "D": [
            38375535,
            38368851,
            38373726,
            38377162,
            38371395,
            38370646,
            38371994,
            38375134,
            38373026,
            38372327,
            38378250,
            38374514,
            38364939,
            38373007,
            38369726,
            38368852,
            38367484,
            38371092,
            38368305
        ],
        "C": [
            38369557,
            38365950,
            38368727,
            38373748,
            38365636,
            38362990,
            38360353,
            38357935,
            38366403,
            38365707,
            38366242,
            38368203,
            38360426,
            38360914,
            38358247,
            38360443,
            38360473,
            38363231,
            38362845
        ],
        "B": [
            38368596,
            38365056,
            38363500,
            38360346,
            38360284,
            38359729,
            38364781,
            38362446,
            38362143,
            38359325,
            38360710,
            38365274,
            38357153,
            38595002,
            38358897,
            38360993,
            38362869,
            38358240,
            38360536,
            38357974
        ],
        "A": [
            38367216,
            38364962,
            38356449,
            38356432,
            38356314,
            38356331,
            38367453,
            38355628,
            38357632,
            38356537,
            38357572,
            38363973,
            38355536,
            38355838,
            38356345,
            38364483,
            38355616,
            38357300,
            38355573
        ],
        "F": [
            38365213,
            38386318,
            38386309,
            38375562,
            38372484,
            38551586
        ],
        "E": [
            38373371,
            38376699,
            38377910,
            38376666,
            38377583,
            38377503,
            38378506,
            38374036,
            38378687,
            40182999
        ]
    },
    "name": "C. Cut  em all ",
    "statement": "You\u2019re given a tree with n vertices.Your task is to determine the\r\nmaximum possible number of edges that can be removed in such a way that\r\nall the remaining connected components will have even size.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#define rep(i,n) for(int i=1;i<=n;++i)\n#define pb push_back\nusing namespace std;\n\nvector<int> g[210000];\nint son[210000];\nint n,ans;\n\nvoid dfs(int x,int pre)\n{\n\tson[x]=1;\n\tfor(auto i:g[x])\n\tif (i!=pre)\n\t{\n\t\tdfs(i,x);\n\t\tson[x]=son[x]+son[i];\n\t\tif (son[i]%2==0) ans++;\n\t}\n}\n\nint main()\n{\n\tcin>>n;\n\tans=0;\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\n\tdfs(1,0);\n\n\tif (son[1]%2!=0){ puts(\"-1\"); return 0; }\n\tcout<<ans<<endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Cut  em all .json",
    "editorial_link": "https://codeforces.com//blog/entry/59551",
    "editorial": "Note that if there is an edge that can be removed, we can do it without\r\nany problem. Let\u00e2\u0080\u0099s consider such edge that in one of the obtained\r\nsubtrees it is impossible to delete more anything else, and its removal\r\nis possible. What happens if we delete it in the tree? Relative to the\r\nother end of the edge, the odd-even balance of the subtree has not\r\nchanged, which means that the edge has not been affected by further\r\ndeletions. Which means if we remove it, the answer will be better. This\r\nis followed by a greedy solution: in dfs we count the size of the\r\nsubtree for each vertex, including the current vertex, and if it is\r\neven, then the edge from the parent (if it exists) can be removed.\r\n"
}