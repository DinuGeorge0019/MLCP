{
    "link": "https://codeforces.com//contest/937/problem/D",
    "problemId": "159984",
    "problem_idx": "D",
    "shortId": "937D",
    "contest_number": "937",
    "problem_submissions": {
        "B": [
            35696794,
            35702864,
            35692823,
            35690729,
            35694513,
            35690544,
            35690257,
            35698410,
            35691221,
            35690892,
            35691375,
            35702558,
            35696021,
            35691603,
            35692248,
            35693511,
            35689627,
            35691074
        ],
        "D": [
            35692697,
            35713147,
            35697020,
            35698388,
            35700044,
            35703123,
            35701138,
            35701740,
            35699988,
            35703153,
            35699440,
            35715758,
            35702654,
            35703145,
            35702583,
            35705096,
            35704134,
            35704747
        ],
        "C": [
            35687317,
            35691596,
            35689373,
            35694359,
            35690896,
            35693744,
            35693408,
            35694406,
            35694106,
            35697537,
            35696111,
            35691520,
            35694573,
            35696303,
            35696728,
            35696658,
            35694289,
            35696468,
            35696813
        ],
        "A": [
            35686618,
            35687353,
            35687073,
            35686895,
            35689698,
            35687175,
            35687230,
            35687897,
            35688429,
            35688503,
            35687868,
            35688027,
            35686930,
            35689664,
            35687167,
            35686480,
            35686539
        ],
        "E": [
            35699925,
            35705854,
            35766833,
            35707300,
            35705001,
            35707037,
            35726109,
            35750977,
            35707021
        ]
    },
    "name": "D. Sleepy Game",
    "statement": "Petya and Vasya arranged a game. The game runs by the following rules.\r\nPlayers have a directed graph consisting of vertices and edges. One of\r\nthe vertices contains a chip. Initially the chip is located at vertex .\r\nPlayers take turns moving the chip along some edge of the graph. Petya\r\ngoes first. Player who can’t move the chip loses. If the game lasts for\r\nturns the draw is announced.Vasya was performing big laboratory work in\r\n\"Spelling and parts of speech\" at night before the game, so he fell\r\nasleep at the very beginning of the game. Petya decided to take the\r\nadvantage of this situation and make both Petya’s and Vasya’s moves.Your\r\ntask is to help Petya find out if he can win the game or at least draw a\r\ntie.\r\n",
    "solutions": [
        "//\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl \"\\n\"\n#define mp make_pair\n\nconst int mod = 1000000007;\nconst int INF = 1000000000;\nconst int MAXN = 200007;\n\nstruct Item {\n    int v, cost;\n\n    Item() { }\n    Item(int i, int c) {\n        v = i;\n        cost = c;\n    }\n};\n\nint n, m, used[MAXN][5], pr[MAXN][5], start, usedCycle[MAXN], drawMark = 0;\nvector <ll> edges[MAXN];\nqueue <Item> bfs;\nvector <int> answerWay;\n\nvoid findCycles(int cur);\n\nint main() {\n    int u, v, cost;\n\n    cin >> n >> m;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> u;\n\n        for (int j = 0; j < u; j++) cin >> v, edges[i].push_back(v);\n    }\n\n    cin >> start;\n\n    used[start][0] = 1;\n    pr[start][0] = pr[start][1] = -1;\n\n    bfs.push(Item(start, 0));\n\n    while (!bfs.empty()) {\n        Item cur = bfs.front();\n        bfs.pop();\n\n        for (int i = 0; i < edges[cur.v].size(); i++) {\n            int to = edges[cur.v][i];\n\n            if (!used[to][1 - cur.cost]) {\n                used[to][1 - cur.cost] = 1;\n                pr[to][1 - cur.cost] = cur.v;\n\n                bfs.push(Item(to, 1 - cur.cost));\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (used[i][1] && edges[i].empty()) {\n            drawMark = INF;\n\n            for (v = i, cost = 1; v != -1;) {\n                answerWay.push_back(v);\n                v = pr[v][cost];\n                cost ^= 1;\n            }\n\n            reverse(answerWay.begin(), answerWay.end());\n\n            break;\n        }\n    }\n\n    if (!drawMark) {\n        findCycles(start);\n\n        if (!drawMark) {\n            cout << \"Lose\";\n\n            return 0;\n        }\n\n        cout << \"Draw\";\n\n        return 0;\n    }\n\n    cout << \"Win\" << endl;\n\n    for (int i = 0; i < answerWay.size(); i++)\n        cout << answerWay[i] << \" \";\n\n    return 0;\n}\n\nvoid findCycles(int cur) {\n    usedCycle[cur] = 1;\n\n    for (int i = 0; i < edges[cur].size(); i++) {\n        int to = edges[cur][i];\n\n        if (!usedCycle[to])\n            findCycles(to);\n        else if (usedCycle[to] == 1) {\n            drawMark = 1;\n\n            return;\n        }\n    }\n    usedCycle[cur] = 2;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "games",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Sleepy Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/58056",
    "editorial": "Note that the answer is sequence of adjacent vertices of even length such that the last vertex of this sequence has no outgoing edges.\n\nBuild state graph as follows:\n\nState is pair (v,?parity), where v is vertex of initial graph and parity is parity of count of vertices on path from s to v. For every edge uv of initial graph add edges  and  in state graph. So there exists path from (s,?1) to (v,?parity) if and only if there exists path from s to v in initial graph of parity parity.\n\nLets find all reachable from (s,?1) states using BFS or DFS. If there is state (v,?0) among them such that v has no outgoing edges in initial graph, then Petya can win. He can move along vertices in path from (s,?1) to (v,?0) in state graph.\n\nOtherwise we need to check if Petya can make 106 moves for drawing a tie. If there is a tie then the chip visited some vertex twice, because n?<?106. Therefore it is sufficient to check if there is a cycle in initial graph reachable from s. In this case Petya can play as follows: move to any vertex of cycle and then move along the cycle as long as it requires to draw a tie.",
    "hint": []
}