{"link": "https://codeforces.com//contest/1514/problem/D", "problemId": "962261", "problem_idx": "D", "shortId": "1514D", "contest_number": "1514", "problem_submissions": {"E": [113528522, 113530195, 113565998, 113829004, 113597935, 113646044, 113584968, 113566286, 113569074], "D": [113508768, 113510778, 113502539, 113509039, 113502444, 116142094, 113508651, 113514400, 113508947, 113510664, 113510706, 113513958, 113537785, 113515183, 113514322, 113510627, 113510608, 113515221, 113512482, 113511797, 113512424, 113510335], "C": [113497839, 113503895, 113492438, 113500977, 113496051, 125221398, 113496633, 113501835, 113497325, 113497426, 113503146, 113504263, 113499255, 113504094, 113504124, 113506035, 113503284, 113501631, 113505697, 113499549, 113501744], "B": [113492786, 113495281, 113492225, 113493324, 113492091, 125221427, 113503162, 113493531, 113492227, 113493586, 113492727, 113494979, 113494843, 113496894, 113495291, 113492924, 113490836, 113494606, 113493594, 113494186, 113493708], "A": [113490269, 113491100, 113495047, 113490072, 113489948, 125221450, 113504457, 113489912, 113489857, 113490379, 113490423, 113490999, 113495292, 113490189, 113492252, 113490413, 113493815, 113492689, 113490314, 113489923, 113490126]}, "name": "D. Cut and Stick", "statement": "Baby Ehab has a piece of Cut and Stick with an array a of length n\r\nwritten on it. He plans to grab a pair of scissors and do the following\r\nto it: pick a range (l, r) and cut out every element a_l, a_{l + 1},\r\n..., a_r in this range; stick some of the elements together in the same\r\norder they were in the array; end up with multiple pieces, where every\r\npiece contains some of the elements and every element belongs to some\r\npiece. More formally, he partitions the sequence a_l, a_{l + 1}, ...,\r\na_r into subsequences. He thinks a partitioning is beautiful if for\r\nevery piece (subsequence) it holds that, if it has length x, then no\r\nvalue occurs strictly more than\r\nlceil\r\nfrac{x}{2}\r\nrceil times in it.He didn\u2019t pick a range yet, so he\u2019s wondering: for q\r\nranges (l, r), what is the minimum number of pieces he needs to\r\npartition the elements a_l, a_{l + 1}, ..., a_r into so that the\r\npartitioning is beautiful.A sequence b is a subsequence of an array a if\r\nb can be obtained from a by deleting some (possibly zero) elements. Note\r\nthat it does have to be contiguous.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, zap;\n    cin >> n >> zap;\n    vector<int> a(n);\n    vector<vector<int>> q(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        a[i]--;\n        q[a[i]].push_back(i);\n    }\n    auto get = [&](int i, int l, int r) -> int {\n        return lower_bound(q[i].begin(), q[i].end(), r + 1) - lower_bound(q[i].begin(), q[i].end(), l);\n    };\n    vector<int> cnt(n);\n    while (zap--) {\n        int l, r;\n        cin >> l >> r;\n        l--;\n        r--;\n        int ans = 1;\n        vector<int> b;\n        for (int it = 0; it < 100; it++) {\n            b.push_back(a[rnd() % (r - l + 1) + l]);\n        }\n        vector<int> q = {-1, -1, -1, -1};\n        vector<int> z;\n        for (int i : b) {\n            if (cnt[i] == 0)\n                z.push_back(i);\n            cnt[i]++;\n        }\n        for (int i : z) {\n            for (int j = 0; j < q.size(); j++) {\n                if (q[j] == -1 || cnt[q[j]] < cnt[i]) {\n                    for (int k = q.size() - 1; k > j; k--)\n                        q[k] = q[k - 1];\n                    q[j] = i;\n                    break;\n                }\n            }\n        }\n        for (int i : b)\n            cnt[i]--;\n        for (int id : q)\n        if (id != -1) {\n            int x = get(id, l, r);\n            int y = r - l + 1 - x;\n            ans = max(ans, x - y);\n        }\n        cout << ans << '\\n';\n    }\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "greedy", "implementation", "sortings"], "dificulty": "2000", "interactive": false}