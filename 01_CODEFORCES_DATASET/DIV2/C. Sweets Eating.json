{
    "link": "https://codeforces.com//contest/1253/problem/C",
    "problemId": "472860",
    "problem_idx": "C",
    "shortId": "1253C",
    "contest_number": "1253",
    "problem_submissions": {
        "F": [
            65199103,
            65190951,
            65202217,
            65200176,
            65205791,
            65198288,
            65206369,
            65202224,
            65204185,
            65198880,
            71343526,
            65209779,
            69242445
        ],
        "E": [
            65190374,
            65200198,
            65189404,
            65179572,
            65189474,
            65203687,
            65210511,
            65176917,
            65203722,
            65186844,
            65188534,
            65195069,
            65199233,
            65190702,
            65194167,
            65189184,
            65189079,
            65566785,
            65194999,
            65197237
        ],
        "D": [
            65185415,
            65178485,
            65180601,
            65183049,
            65178022,
            65187686,
            65195445,
            65178632,
            65179619,
            65180170,
            65183967,
            65181658,
            65188561,
            65181701,
            65182069,
            65187758,
            65183529,
            65182372,
            65181324
        ],
        "C": [
            65180957,
            65172664,
            65176866,
            65185425,
            65173509,
            65180180,
            65194567,
            65173458,
            65200178,
            65176131,
            65179441,
            65175878,
            65184305,
            65178007,
            65179468,
            65178975,
            65179727,
            65177898,
            65176250
        ],
        "B": [
            65175476,
            65202574,
            65174599,
            65188764,
            65185456,
            65176094,
            65186553,
            65183630,
            65196117,
            65172495,
            65173857,
            65173178,
            65174792,
            65174898,
            65174679,
            65176409,
            65176161,
            65176165,
            65172853
        ],
        "A": [
            65171088,
            65170116,
            65170656,
            65190482,
            65180567,
            65170231,
            65180099,
            65170284,
            65170843,
            65169770,
            65169894,
            65169914,
            65170943,
            65169881,
            65172675,
            65172008,
            65171211,
            65169945,
            65169720
        ]
    },
    "name": "C. Sweets Eating",
    "statement": "Tsumugi brought n delicious sweets to the Light Music Club. They are\r\nnumbered from 1 to n, where the i-th sweet has a sugar concentration\r\ndescribed by an integer a_i.Yui loves sweets, but she can eat at most m\r\nsweets each day for health reasons.Days are 1-indexed (numbered 1, 2, 3,\r\nldots). Eating the sweet i at the d-th day will cause a sugar penalty of\r\n(d\r\ncdot a_i), as sweets become more sugary with time. A sweet can be eaten\r\nat most once.The total sugar penalty will be the of the individual\r\npenalties of each sweet eaten.Suppose that Yui chooses exactly k sweets,\r\nand eats them in any order she wants. What is the total sugar penalty\r\nshe can get?Since Yui is an undecided girl, she wants you to answer this\r\nquestion for every value of k between 1 and n.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n\nint n,m;\nint A[200005];\nvector < int > B[200005],id;\nLL row[200005];\nint cnt = 0;\n\nint main(){\n\n\n\tscanf(\"%d%d\",&n,&m);\n\tfor ( int i = 0; i < n; i++ ){\n\t\tscanf(\"%d\",&A[i]);\n\t}\n\tsort(A,A+n);\n\n\tcnt = 0;\n\tfor ( int i = 0; i < n; i++ ){\n\t\tif ( B[cnt].size() == m ) cnt++;\n\t\tB[cnt].push_back(A[i]);\n\t}\n\t\n\tcnt = 0;\n\tint pos = 0;\n\tLL ans = 0;\n\tfor ( int i = 1; i <= n; i++ ){\n\t\trow[pos] += B[cnt][pos];\n\t\tans += row[pos];\n\t\tpos++;\n\t\tif ( pos == m ){\n\t\t\tcnt++;\n\t\t\tpos = 0;\n\t\t}\n\t\tprintf(\"%lld\",ans);\n\t\tif ( i < n ) printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Sweets Eating.json",
    "editorial_link": "https://codeforces.com//blog/entry/71489?locale=en",
    "editorial": "Let\u00e2\u0080\u0099s sort array . Now we can easily that if Yui wants to eat sweets,\r\nshe has to eat sweets in this order, because of rearrangement inequality\r\n(put lower coefficients (day) on higher values (sugar concentration)).A\r\nnaive simulation of this strategy would have complexity , which is too\r\nslow.Let\u00e2\u0080\u0099s look what happens when we replace by . During the first day,\r\nYui will eat sweets . Then, we reproduce the strategy used for , but one\r\nday late : all coefficients are increased by . Formally, where because\r\nof new sweets eaten and because the coefficient of these sweets are all\r\nincreased by (we eat them one day later).We can derive the following\r\nformula : .If we maintain the current prefix sum, and all previous\r\nanswers computed in an array, we can compute all answers in .Final\r\ncomplexity is , because sorting is the slowest part of the\r\nsolution.Implementation\r\n"
}