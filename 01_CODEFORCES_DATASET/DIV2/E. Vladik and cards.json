{
    "link": "https://codeforces.com//contest/743/problem/E",
    "problemId": "84655",
    "problem_idx": "E",
    "shortId": "743E",
    "contest_number": "743",
    "problem_submissions": {
        "C": [
            22970568,
            22954819,
            22955931,
            22959540,
            22960803,
            22954630,
            22967024,
            22964712,
            22959281,
            22956710,
            22956672,
            22954587,
            22959020,
            22956501,
            22953944,
            22955848,
            22960168,
            22960967
        ],
        "E": [
            22965880,
            22967434,
            22967306,
            22968969,
            22967268,
            22973387,
            22967640,
            22968707,
            22974150,
            22967996,
            22970034,
            22971822,
            22987515,
            22975131,
            41741833,
            22975215,
            22975586,
            22974342
        ],
        "B": [
            22955029,
            22952524,
            22952071,
            22953395,
            22954814,
            22952559,
            22951675,
            22954634,
            22953589,
            22953782,
            22953874,
            22953034,
            22954309,
            22952189,
            22955346,
            22951377,
            22952875,
            22956475,
            22953744
        ],
        "D": [
            22953950,
            22961837,
            22961932,
            22962256,
            22961186,
            22961360,
            22956645,
            22961156,
            22963404,
            22962979,
            22963931,
            22963003,
            22964853,
            22959856,
            22961283,
            22968732,
            22964847,
            22966379,
            22964407
        ],
        "A": [
            22950683,
            22950781,
            22950661,
            22966387,
            22969695,
            22950835,
            22950658,
            22952400,
            22951347,
            22956844,
            22951276,
            22950972,
            22951766,
            22950741,
            22951008,
            22953378,
            22951284
        ]
    },
    "name": "E. Vladik and cards",
    "statement": "Vladik was bored on his way home and decided to play the following game.\r\nHe took cards and put them in a row in front of himself. Every card has\r\na positive integer number not exceeding written on it. He decided to\r\nfind the longest subsequence of cards which satisfies the following\r\nconditions: the number of occurrences of each number from to in the\r\nsubsequence doesn\u2019t differ by more then from the number of occurrences\r\nof any other number. Formally, if there are cards with number on them in\r\nthe subsequence, than for all pairs of integers the condition must hold.\r\nif there is at least one card with number on it in the subsequence, then\r\nall cards with number in this subsequence must form a continuous segment\r\nin it (). For example, the subsequence satisfies this condition while\r\nthe subsequence doesn\u2019t. Note that doesn\u2019t satisfy the first condition.\r\nPlease help Vladik to find the length of the longest subsequence that\r\nsatisfies both conditions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1024;\nconst int CNT = 10;\nconst int MASK = 1<<9;\nconst int INF = (1e9) + 7;\n\nint n,a[N];\nint cnt;\nint nxt[CNT][N][N];\nint occ;\nbool used[N][MASK];\nint state[N][MASK];\nint ans;\n\nint recurse(int pos, int mask) {\n    if(mask==(1<<8)-1) return 0;\n    if(pos>n) return -INF;\n    if(used[pos][mask]) return state[pos][mask];\n    int ans=-INF;\n    if(mask&(1<<(a[pos]-1))) ans=recurse(pos+1,mask);\n    else {\n        ans=max(ans,recurse(pos+1,mask));\n        if(nxt[a[pos]][pos][occ]) ans=max(ans,occ+recurse(nxt[a[pos]][pos][occ]+1,mask|(1<<(a[pos]-1))));\n        if(nxt[a[pos]][pos][occ+1]) ans=max(ans,occ+1+recurse(nxt[a[pos]][pos][occ+1]+1,mask|(1<<(a[pos]-1))));\n    }\n    used[pos][mask]=true;\n    state[pos][mask]=ans;\n    return ans;\n}\n\nint main() {\n    int i,j,z,cnt;\n    set < int > s;\n\n    scanf(\"%d\", &n);\n    for(i=1;i<=n;i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    for(z=1;z<=8;z++) {\n        for(i=1;i<=n;i++) {\n            cnt=0;\n            for(j=i;j<=n;j++) {\n                if(a[j]==z) ++cnt,nxt[z][i][cnt]=j;\n            }\n        }\n    }\n    for(i=1;i<=n;i++) s.insert(a[i]);\n    ans=(int)(s.size());\n    for(occ=1;(occ-2)*8<=n;++occ) {\n        memset(used,0,sizeof(used));\n        ans=max(ans,recurse(1,0));\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Vladik and cards.json",
    "editorial_link": "https://codeforces.com//blog/entry/49049",
    "editorial": "Suppose we have taken at least cards of each color and colors of them\r\nhave cards.Then the answer will look like: . Obviously, if our sequence\r\nof cards allows us to take cards of each color, then it allows to take ,\r\nand , so on.Lets binary search for value, and check allowability this\r\nway:Define bitmask dynamic programming () as the number of colors, for\r\nwhich we have taken element, if we passed cards in the sequence and the\r\ncolors, which has bit equal to one in bitmask mask.We will have two\r\ndifferent transitions. Iterate the new color, which has zero bit in the\r\nmask, to make the first transition, and find its occurrence number in\r\nsubarray . The second transition is completely the same, but we have to\r\nfind occurrence number . To find the occurrence number of some color in\r\nsubarray we should maintain an array of the remaining cards for each\r\ncolor.Finally, find the maximal allowable , and in dp calculated for\r\nfind the maximal additional cards in .This solution for colors of cards\r\n(8 in our case) has complexity .\r\n"
}