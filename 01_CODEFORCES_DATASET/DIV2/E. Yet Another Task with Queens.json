{
    "link": "https://codeforces.com//contest/131/problem/E",
    "problemId": "696",
    "problem_idx": "E",
    "shortId": "131E",
    "contest_number": "131",
    "problem_submissions": {
        "F": [
            904424,
            898451,
            898852,
            898665,
            899656,
            42410750,
            900665,
            900877,
            900384,
            899648,
            900915,
            901359,
            897034,
            901848,
            900975,
            901375,
            897608,
            902336,
            895558,
            901701
        ],
        "E": [
            904422,
            896838,
            895727,
            896630,
            897281,
            42410343,
            898660,
            899049,
            899074,
            898552,
            899102,
            899404,
            899253,
            899170,
            899607,
            899696,
            899911,
            897321,
            900186,
            897365
        ],
        "D": [
            904420,
            894775,
            894348,
            894881,
            894791,
            896588,
            897021,
            897370,
            896846,
            897407,
            896897,
            908176,
            904628,
            901525,
            897622,
            897737,
            898418,
            894267,
            898476,
            898021,
            898664,
            894931
        ],
        "C": [
            904417,
            892960,
            891836,
            893412,
            892695,
            893493,
            894746,
            897077,
            895187,
            893806,
            894995,
            895988,
            896203,
            894856,
            902951,
            896937,
            892903
        ],
        "B": [
            904413,
            892343,
            898130,
            892434,
            891977,
            893039,
            892628,
            893632,
            891827,
            892784,
            894062,
            892290,
            894254,
            895376,
            891900,
            893592,
            894329,
            896307,
            891485
        ],
        "A": [
            904410,
            891551,
            891494,
            891758,
            891408,
            891725,
            892258,
            891411,
            891856,
            891608,
            892187,
            891595,
            893365,
            893186,
            891415,
            891922,
            891657,
            895179,
            892042
        ]
    },
    "name": "E. Yet Another Task with Queens",
    "statement": "A queen is the strongest chess piece. In modern chess the queen can move\r\nany number of squares in any horizontal, vertical or diagonal direction\r\n(considering that there’re no other pieces on its way). The queen\r\ncombines the options given to the rook and the bishop.There are queens\r\non a square chessboard. You know each queen’s positions, the -th queen\r\nis positioned in the square , where is the board row number (numbered\r\nfrom the top to the bottom from 1 to ), and is the board’s column number\r\n(numbered from the left to the right from 1 to ). No two queens share\r\nthe same position.For each queen one can count the number of other\r\nqueens that the given queen threatens (attacks). For a fixed attack\r\ndirection only the first queen in this direction is under attack if\r\nthere are many queens are on the ray of the attack. Obviously, for any\r\nqueen is between 0 and 8, inclusive.Print the sequence , where is the\r\nnumber of queens that threaten exactly other queens, i.e. the number of\r\nqueens that their equals .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <set>\nusing namespace std;\nset <pair <int,int> > a[100010],b[100010],c[200010],d[200010];\npair <int,int> p[100010];\nint ans[10];\nint calc(const pair <int,int> p,const set <pair <int,int> > &a)\n{\n    int x=p.first,y=p.second,ret=0;\n    if (*a.begin()!=p)\n        ret++;\n    if (a.upper_bound(p)!=a.end())\n        ret++;\n    return(ret);\n}\nint main()\n{\n    int n;\n    scanf(\"%*d%d\",&n);\n    for (int i=1;i<=n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        p[i]=make_pair(x,y);\n        a[x].insert(p[i]);\n        b[y].insert(p[i]);\n        c[x+y].insert(p[i]);\n        d[x-y+100000].insert(p[i]);\n    }\n    for (int i=1;i<=n;i++)\n    {\n        int sum=0,x=p[i].first,y=p[i].second;\n        sum=calc(p[i],a[x])+calc(p[i],b[y])+calc(p[i],c[x+y])+calc(p[i],d[x-y+100000]);\n        ans[sum]++;\n    }\n    for (int i=0;i<=8;i++)\n        printf(\"%d%c\",ans[i],i==8?'\\n':' ');\n    return(0);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Yet Another Task with Queens.json",
    "editorial_link": "https://codeforces.com//blog/entry/3256",
    "editorial": "Let's first consider that the queens can only attack the other pieces standing in the same line - the case with the columns and both diagonals will be analogous.\n\nLet line[i] be an array that will store all the queens that are in the i-th line on the chessboard. Since it's indexed by the line number, it's only necessary to store the column number of the pieces. So, for example, if we have queens at positions (4,6), (4,8) and (6,5), we will have line[4] = {6,8} and line[6] = {5}.\n\nTo check if the queen at position (i,j) is attacking someone in its line, you must check if there is some number greater than j and/or less than j in line[i]. To do that, presort line[i] and binary search j in it. Notice that j will always be successful found by the search. Notice also that there will be some number greater than j iff the found element is not the last one of line[i]. The same applies for the other case: check if j is not the first element of line[i]. If j is not the first nor the last element, the queen is attacking 2 pieces in its line. If j is the only element, the queen is attacking no one, and it's attacking 1 piece otherwise.\n\nDo the same thing (compute all column[i], sort them and, for each queen, binary search) to the column, to the \"/\" diagonal, and to the \"\\\" diagonal. Remember that a piece at position (i,j) is at the diagonals i+j and i-j. Like in problem B, use an offset to handle the negative numbers in the last case. Store the line number in the column[i] array. There's no different in witch index (line or column) to use in the diagonals arrays (but, of course, use the same chosen index for everyone).\n\nIt seems that the sorting part of the algorithm will run in O(n*n*logn) time, since we have O(n) lines, columns and diagonals. However, the sum of the sizes of all these arrays will be m, the numbers of queens. So the running time will be actually near O(m*logm). Binary searching for every queen will take less than O(m*logm), too.",
    "hint": []
}