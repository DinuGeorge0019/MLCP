{
    "link": "https://codeforces.com//contest/1215/problem/B",
    "problemId": "412392",
    "problem_idx": "B",
    "shortId": "1215B",
    "contest_number": "1215",
    "problem_submissions": {
        "F": [
            60620224,
            60633144,
            60628796,
            62102987,
            60657759
        ],
        "E": [
            60614830,
            60620100,
            60624259,
            60618193,
            60620939,
            60619722,
            60618555,
            60619211,
            60623129,
            60624049,
            60623962,
            60621062,
            60625235,
            60625015,
            60623138,
            60622255,
            60623519,
            60627768,
            60628419,
            60622708
        ],
        "D": [
            60613485,
            60617335,
            60619535,
            60616864,
            60615351,
            60616017,
            60622796,
            60619079,
            60617400,
            60616935,
            60621165,
            60617806,
            60616391,
            60616135,
            60618699,
            60620021,
            60619257,
            60623666,
            60614165,
            60618490
        ],
        "C": [
            60611883,
            60614880,
            60616986,
            60613872,
            60612356,
            60613808,
            60613237,
            60615096,
            60615058,
            60613116,
            60615948,
            60615995,
            60614183,
            60613610,
            60614082,
            60612548,
            60614439,
            60618385,
            60611650,
            60615653
        ],
        "B": [
            60609609,
            60611892,
            60614411,
            60610320,
            60609887,
            60611712,
            60610288,
            60610941,
            60611470,
            60610159,
            60611942,
            60611586,
            60611453,
            60611164,
            60611443,
            60609621,
            60611512,
            60611710,
            60609773,
            60612774
        ],
        "A": [
            60609389,
            60610541,
            60610424,
            60609620,
            60609428,
            60610648,
            60609442,
            60611977,
            60609576,
            60609429,
            60610464,
            60609932,
            60609744,
            60609643,
            60609965,
            60616895,
            60610358,
            60609768,
            60609404,
            60611551
        ]
    },
    "name": "B. The Number of Products",
    "statement": "You are given a sequence a_1, a_2,\r\ndots, a_n consisting of n non-zero integers (i.e. a_i\r\nne 0). You have to calculate two following values: the number of pairs\r\nof indices (l, r) (l\r\nle r) such that a_l\r\ncdot a_{l + 1}\r\ndots a_{r - 1}\r\ncdot a_r is negative; the number of pairs of indices (l, r) (l\r\nle r) such that a_l\r\ncdot a_{l + 1}\r\ndots a_{r - 1}\r\ncdot a_r is positive;\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,S[1000005];\nint main(){\n\t/*scanf(\"%d%d%d%d%d\",&a1,&a2,&k1,&k2,&n);\n\tint low=a1*(k1-1)+a2*(k2-1);\n\tprintf(\"%d \",max(n-low,0));\n\tif (k1>k2) swap(k1,k2),swap(a1,a2);\n\tint T1=min(n/k1,a1); a1-=k1; n-=T1*k1;\n\tprintf(\"%d\",T1+n/k2);*/\n\tscanf(\"%d\",&n);\n\tS[0]=1;\n\tFor(i,1,n){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tif (x<0) S[i]=S[i-1]^1;\n\t\telse S[i]=S[i-1];\n\t}\n\tint s0=0,s1=0;\n\tFor(i,0,n)\n\t\tif (S[i]==0) ++s0;\n\t\telse ++s1;\n\tprintf(\"%lld %lld\\n\",1ll*s0*s1,1ll*n*(n+1)/2-1ll*s0*s1);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The Number of Products.json",
    "editorial_link": "https://codeforces.com//blog/entry/69815",
    "editorial": "At first, letâs calculate the value of the number of subsegments with\r\npositive product. We should iterate through the array and store the\r\nnumber of negative elements. Also we should store and the number of\r\nelements such that there is an even number of negative elements before\r\nthem () or an odd number of negative elements before them (). If for the\r\ncurrent element is even, we should increase by one, else we should\r\nincrease by one. Then if the current element is negative, we should\r\nincrease by one. Then we should add the number of subsegments ending in\r\nthe current element and having positive product to . If is even, then\r\nany subsegment ending in the current element and containing even number\r\nof negative elements should begin in a position where was even too, so\r\nwe should add to . If is odd, we should add to (we use similar\r\nreasoning).The number of segments having negative product can be\r\ncalculated, for example, by subtracting from the total number of\r\nsubsegments, which is .\r\n",
    "hint": []
}