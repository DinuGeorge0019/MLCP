{
    "link": "https://codeforces.com//contest/909/problem/D",
    "problemId": "142270",
    "problem_idx": "D",
    "shortId": "909D",
    "contest_number": "909",
    "problem_submissions": {
        "D": [
            33703562,
            33684475,
            33687934,
            33679960,
            33681845,
            33678239,
            33681778,
            33682813,
            33684628,
            33683979,
            33684264,
            33683734,
            33682267,
            33684172,
            33684972,
            33684951,
            37837707,
            33689232,
            33685173
        ],
        "C": [
            33702243,
            33685781,
            33688791,
            33678737,
            33677527,
            33680778,
            33679730,
            33677867,
            33678218,
            33679090,
            33681226,
            33679711,
            33679799,
            33678914,
            33682105,
            33681294,
            33679526,
            33680909
        ],
        "F": [
            33682616,
            33683222,
            33692268,
            33694692,
            33695944
        ],
        "E": [
            33680057,
            33686075,
            33684461,
            33682298,
            33685101,
            33681929,
            33683773,
            33684555,
            33682566,
            33680995,
            33686514,
            33687842,
            33689439,
            33687234,
            33687184,
            33690952,
            33683720,
            33689497
        ],
        "B": [
            33678984,
            33689620,
            33681003,
            33675642,
            33677938,
            33674594,
            33675218,
            33675981,
            33675928,
            33676067,
            33676981,
            33677469,
            33675490,
            33680062,
            33675898,
            33676219,
            33677187
        ],
        "A": [
            33675962,
            33690137,
            33674036,
            33674451,
            33674005,
            33674337,
            33674208,
            33673945,
            33674163,
            33674088,
            33674166,
            33675518,
            33673927,
            33674572,
            33673981,
            33673915,
            33676471
        ]
    },
    "name": "D. Colorful Points",
    "statement": "You are given a set of points on a straight line. Each point has a color\r\nassigned to it. For point , its neighbors are the points which don\u2019t\r\nhave any other points between them and . Each point has at most two\r\nneighbors - one from the left and one from the right.You perform a\r\nsequence of operations on this set of points. In one operation, you\r\ndelete all points which have a neighbor point of a different color than\r\nthe point itself. Points are deleted simultaneously, i.e. first you\r\ndecide which points have to be deleted and then delete them. After that\r\nyou can perform the next operation etc. If an operation would not delete\r\nany points, you can\u2019t perform it.How many operations will you need to\r\nperform until the next operation does not have any points to delete?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+5;\n\nint l[maxn],r[maxn],n,ans;\nchar s[maxn];\nvector<int> q,q2;\nbool vis[maxn];\n\ninline bool chk(int i){return (l[i]&&s[l[i]]!=s[i])||(r[i]<=n&&s[r[i]]!=s[i]);}\ninline void clr(int i){r[l[i]]=r[i],l[r[i]]=l[i];}\n\nint main()\n{\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tr[0]=1,l[n+1]=n,vis[0]=vis[n+1]=1;\n\tfor(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;\n\tfor(int i=1;i<=n;i++)if(chk(i))\n\t\tq.push_back(i),vis[i]=1;\n\twhile(!q.empty())\n\t{\n\t\t++ans;\n\t\tfor(auto i:q)q2.push_back(l[i]),q2.push_back(r[i]),clr(i);\n\t\tq.clear();\n\t\tfor(auto i:q2)if(i&&i<=n&&!vis[i]&&chk(i))\n\t\t\tvis[i]=1,q.push_back(i);\n\t\tq2.clear();\n\t}\n\treturn printf(\"%d\",ans),0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Colorful Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/56666",
    "editorial": "We can simulate the process described in the problem step by step, but\r\nthis is too slow a straightforward simulation (iterate over all points\r\nwhen deciding which ones to delete) has an complexity and takes too\r\nlong. A solution with better complexity is required. Let\u00e2\u0080\u0099s consider\r\ncontinuous groups of points of same color. Any points inside a group are\r\nsafe during the operation; only points at the border of a group are\r\ndeleted (except for the leftmost point of the leftmost group and the\r\nrightmost point of the rightmost group, if these groups have more than\r\none point). So, if current group sizes are, from left to right, , group\r\nsizes after performing the first operation are , after the second\r\noperation and so on. This process continues until at least one of the\r\ngroups disappears completely, at which point its adjacent groups may get\r\nmerged if they are of the same color. This way, multiple operations can\r\nbe simulated at once: Find the number of operations that are required\r\nfor at least one group to disappear. Update group sizes after this\r\nnumber of operations. Remove empty groups. Merge adjacent groups of the\r\nsame color. One update done this way requires time. During such an\r\nupdate at least one point from each group is deleted, so at least points\r\nare removed. If is the initial number of points, we can remove at most\r\npoints in total. Therefore, running time of the algorithm is .\r\n"
}