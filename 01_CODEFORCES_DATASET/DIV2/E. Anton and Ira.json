{
    "link": "https://codeforces.com//contest/584/problem/E",
    "problemId": "37440",
    "problem_idx": "E",
    "shortId": "584E",
    "contest_number": "584",
    "problem_submissions": {
        "E": [
            13448030,
            13450163,
            88104477,
            88104151,
            13449935,
            13451571,
            13453816,
            13453484,
            13454516,
            13452930,
            13453585,
            13458236,
            13456357,
            13455755,
            13455102,
            13451472,
            13456813,
            13457020
        ],
        "D": [
            13443353,
            13443270,
            13445578,
            13446859,
            13447606,
            13447543,
            13447741,
            13446415,
            13448718,
            13445763,
            13446604,
            13445778,
            13448530,
            13449671,
            13448690,
            13448138
        ],
        "C": [
            13441835,
            13441802,
            13442513,
            13443476,
            13443861,
            13443254,
            13444395,
            13444004,
            13444710,
            13440670,
            13444125,
            13442160,
            13444719,
            13448622,
            13442919,
            13445377
        ],
        "B": [
            13438000,
            13437696,
            13438159,
            13439238,
            13437543,
            13437817,
            13438697,
            13448122,
            13439114,
            13441730,
            13440843,
            13438018,
            13442212,
            13445708,
            13438788,
            13438618
        ],
        "A": [
            13435549,
            13436265,
            13435303,
            13436790,
            13435284,
            13435093,
            13435788,
            13441140,
            13435389,
            13435044,
            13435995,
            13435611,
            13438071,
            13435350,
            13435872,
            13435359
        ]
    },
    "name": "E. Anton and Ira",
    "statement": "Anton loves transforming one permutation into another one by swapping\r\nelements for money, and Ira doesn’t like paying for stupid games. Help\r\nthem obtain the required permutation by paying as little money as\r\npossible.More formally, we have two permutations, and of numbers from to\r\n. We can swap and , by paying coins for it. Find and print the smallest\r\nnumber of coins required to obtain permutation from permutation . Also\r\nprint the sequence of swap operations at which we obtain a solution.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2E3 + 10;\n\nint a[MAXN], b[MAXN];\nint loc[MAXN];\n\nint cnt;\nint out[MAXN * MAXN][2];\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", &a[i]);\n\t\tloc[a[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", &b[i]);\n\t\ta[loc[b[i]]] = i;\n\t}\n\t/*\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%d \", a[i]);\n\tputs(\"\");\n\t*/\n\n\tint cost = 0;\n\tcnt = 0;\n\tfor (int i = 1; i <= n; ++i){\n\t\tint u = 0;\n\t\tfor (u = i; u <= n && a[u] != i; ++u);\n\t\tfor (int j = u - 1; j >= i; --j)\n\t\t\tif (a[j] >= u){\n\t\t\t\tcost += u - j;\n\t\t\t\tout[cnt][0] = u;\n\t\t\t\tout[cnt][1] = j;\n\t\t\t\t++cnt;\n\t\t\t\tswap(a[u], a[j]);\n\t\t\t\tu = j;\n\t\t\t\tj = u;\n\t\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", cost, cnt);\n\tfor (int i = 0; i < cnt; ++i)\n\t\tprintf(\"%d %d\\n\", out[i][0], out[i][1]);\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Anton and Ira.json",
    "editorial_link": "https://codeforces.com//blog/entry/20766",
    "editorial": "We can consider that we pay coins for swap (we can divide answer in the\r\nend). Then we can consider that we pay coins for moving and for moving .\r\nSo, if was on position and then came to position , then we will pay at\r\nleast coins. Then the answer is at least ( position in permutation , and\r\nposition in permutation ). Letâs prove that this is the answer by\r\nshowing the algorithm of making swaps. Letâs consider that permutation\r\nis sorted (our task is equal to it). Then we will put numbers from to on\r\ntheir positions. How we can put on its position? Denote . Letâs prove\r\nthat there exists a position such that and (then we will swap with (and\r\nboth numbers will move to their final positions and will move to the\r\nright, so we can repeat this process until returns to its position)). We\r\ncan note that there are only positions that are bigger than . And how\r\nmany numbers on these positions can be bigger than ? We can say that\r\nanswer is , but itâs incorrect, because is bigger than , but . Now we\r\ncan use Pigeonhole principle and say that position , such that and\r\nexists. But now our algorithm is . How we can put in its position in\r\noperations? Letâs move the pointer to the right while number is bigger\r\nthan . Then swap with found number. After we can move pointer from new\r\nâs position, so pointer always moves to the right and will not do more\r\nthen steps.\r\n",
    "hint": []
}