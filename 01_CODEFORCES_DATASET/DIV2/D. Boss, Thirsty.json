{
    "link": "https://codeforces.com//contest/2021/problem/D",
    "problemId": "2929695",
    "problem_idx": "D",
    "shortId": "2021D",
    "contest_number": "2021",
    "problem_submissions": {
        "D": [
            284590256,
            284590001,
            284586301,
            284623851,
            284569171,
            284578878,
            284712748,
            284578625,
            284581515,
            284581353,
            284637993
        ],
        "E3": [
            284578176,
            284565599,
            284600842,
            284850992,
            284584216,
            284618196,
            284597636,
            284599022,
            284585148,
            286020331,
            284745105
        ],
        "E1": [
            284577293,
            284599054,
            284566976,
            284599574,
            284568532,
            284584477,
            284579805,
            284586608,
            284600476,
            284585423,
            284594051,
            284576473,
            284592731,
            284581221,
            284582830,
            284576965,
            286020463,
            284573682,
            284745154,
            284585073
        ],
        "E2": [
            284576481,
            284599368,
            284566551,
            284571784,
            284584447,
            284580377,
            284586193,
            284585357,
            284576258,
            284585492,
            284583546,
            284582548,
            286020438,
            284593395,
            284766277,
            284587863
        ],
        "C2": [
            284552959,
            284550125,
            284578847,
            284570668,
            284557743,
            284572571,
            284559765,
            284559531,
            284592443,
            284564745,
            284553608,
            284551809,
            284555032,
            284564040,
            284565535,
            284591262,
            284564727,
            284560092
        ],
        "C1": [
            284543395,
            284545189,
            284579118,
            284555011,
            284551439,
            284544381,
            284549845,
            284558858,
            284582609,
            284556392,
            284545368,
            284554154,
            284545358,
            284546156,
            284555833,
            284553560,
            284550666,
            284546712,
            284545533,
            284552561
        ],
        "B": [
            284537997,
            284541648,
            284545572,
            284550280,
            284536827,
            284538339,
            284543136,
            284541306,
            284577835,
            284541582,
            284538597,
            284539525,
            284540971,
            284538476,
            284541915,
            284545007,
            284543924,
            284540121,
            284540098,
            284544260
        ],
        "A": [
            284536034,
            284541336,
            284535964,
            284545882,
            284543072,
            284535980,
            284537720,
            284537149,
            284572305,
            284541440,
            284535781,
            284536205,
            284539247,
            284535865,
            284537520,
            284541705,
            284541775,
            284537231,
            284537773,
            284536991
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134873",
    "editorial": "We can see it as a grid of square tiles, consisting of rows and columns.\r\nConsider a single row. Instead of looking at the tiles, we can look at\r\nthe edges between tiles, including the leftmost edge and the rightmost\r\nedge. We number the edges from to such that tile () is the tile between\r\nedge and edge .For a single row , choosing a segment of tiles is\r\nequivalent to choosing two different edges and () as the endpoints of\r\nthe segment, which denotes choosing the tiles from to . For each edge ,\r\nwe can precompute a prefix sum . That means, choosing edges and yields a\r\nprofit of .Let\u00e2\u0080\u0099s say we\u00e2\u0080\u0099ve chosen edges and for row and we want to\r\nchoose two edges and for row that satisfies the problem requirement. We\r\nwant to choose a continuous segment that includes at least one chosen\r\ntile and at least one unchosen tile from the previous row. A chosen tile\r\nthat is adjacent to an unchosen tile only appears at the endpoints of\r\nthe previous segment. That means, to satisfy the requirement, the new\r\nsegment must strictly contain at least one endpoint of the previous\r\nsegment. More formally, at least one of the following conditions must be\r\nsatisfied: Knowing that, we can see that when going from one row to the\r\nnext, we only need the information for one of the two endpoints, not\r\nboth.We can solve this with dynamic programming from row to row . For\r\neach row, we find the optimal profit for each and the optimal profit for\r\neach . We do those two things separately. For each row , define the\r\nfollowing things: : the optimal profit for the first rows if the left\r\nendpoint of the last segment is . : the optimal profit for the first\r\nrows if the right endpoint of the last segment is . Let\u00e2\u0080\u0099s say we\u00e2\u0080\u0099ve\r\ncalculated all values of and for row and we want to calculate for row .\r\nLet and be the left and right endpoints of the new segment respectively.\r\nLet be one of the endpoints of the previous segment. Then it must hold\r\nthat , which yields a maximum profit of .Let\u00e2\u0080\u0099s calculate all values of\r\nfirst for row . For each , we want to consider all corresponding triples\r\nand find the maximum profit among them. In order to do that, we do three\r\nsteps: Make a prefix maximum of . Then, for each , we add with the\r\nmaximum value of for all . And then we make a prefix maximum of those\r\nvalues. Then, for each , the value of is added by the maximum value for\r\nthe previous calculation for each from to . We do the same thing for but\r\nwe use suffix maxmiums instead.After doing all that for every row from\r\nto , we find the maximum value of and in the last row to get the\r\nanswer.Time complexity of each test case:\r\n",
    "name": "D. Boss, Thirsty",
    "statement": "Pak Chanek has a friend who runs a drink stall in a canteen. His friend\r\nwill sell drinks for n days, numbered from day 1 to day n. There are\r\nalso m types of drinks, numbered from 1 to m.The profit gained from\r\nselling a drink on a particular day can vary. On day i, the projected\r\nprofit from selling drink of type j is A_{i, j}. Note that A_{i, j} can\r\nbe negative, meaning that selling the drink would actually incur a\r\nloss.Pak Chanek wants to help his friend plan the sales over the n days.\r\nOn day i, Pak Chanek must choose to sell one type of drink. Furthermore,\r\nthe types of drinks sold on a single day must form a subarray. In other\r\nwords, in each day, Pak Chanek will select i and j such that 1\r\nleq i\r\nleq j\r\nleq m. Then all types of drinks between i and j (inclusive) will be\r\nsold.However, to ensure that customers from the previous day keep\r\nreturning, the selection of drink types sold on day i (i>1) must meet\r\nthe following conditions: At least one drink type sold on day i must\r\nalso have been sold on day i-1. At least one drink type sold on day i\r\nmust have been sold on day i-1. The daily profit is the sum of the\r\nprofits from all drink types sold on that day. The total profit from the\r\nsales plan is the sum of the profits over n days. What is the maximum\r\ntotal profit that can be achieved if Pak Chanek plans the sales\r\noptimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define inf 0x3f3f3f3f3f3f3f3fusing namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}inline void get_max(long long &a,long long b){if(a<b) a=b;}int n,m;vector<int> a[200010];vector<long long> S[200010],f[200010],g[200010];long long tmp,dp;void solve(){\tfor(int i=1;i<=n;i++)\t\tvector<int>().swap(a[i]),\t\tvector<long long>().swap(S[i]),\t\tvector<long long>().swap(f[i]),\t\tvector<long long>().swap(g[i]);\u00a0\tn=Qread(),m=Qread();\tfor(int i=1;i<=n;i++)\t\ta[i].resize(m+1),S[i].resize(m+1),\t\tf[i].resize(m+1,-inf),\t\tg[i].resize(m+1,-inf);\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++)\t\ta[i][j]=Qread(),S[i][j]=S[i][j-1]+a[i][j];\u00a0\t//init\ttmp=0;\tfor(int i=1;i<=m;i++)\t{\t\tg[1][i]=S[1][i]-tmp;\t\ttmp=min(tmp,S[1][i]);\t}\ttmp=S[1][m];\tfor(int i=m;i;i--)\t{\t\tf[1][i]=tmp-S[1][i-1];\t\ttmp=max(tmp,S[1][i-1]);\t}\u00a0\t//zhuan yi\tfor(int i=2;i<=n;i++)\t{\t\t//f to f\t\ttmp=S[i][m],dp=-inf;\t\tfor(int j=m;j;j--)\t\t{\t\t\tget_max(f[i][j],dp-S[i][j-1]);\t\t\tdp=max(dp,tmp+f[i-1][j]);\t\t\ttmp=max(tmp,S[i][j-1]);\t\t}\t\t//f to g\t\ttmp=inf,dp=-inf;\t\tfor(int j=1;j<=m;j++)\t\t{\t\t\tdp=max(dp,f[i-1][j]-tmp);\t\t\tget_max(g[i][j],dp+S[i][j]);\t\t\ttmp=min(tmp,S[i][j-1]);\t\t}\t\t//g to f\t\ttmp=-inf,dp=-inf;\t\tfor(int j=m;j;j--)\t\t{\t\t\tdp=max(dp,g[i-1][j]+tmp);\t\t\tget_max(f[i][j],dp-S[i][j-1]);\t\t\ttmp=max(tmp,S[i][j]);\t\t}\t\t//g to g\t\ttmp=0,dp=-inf;\t\tfor(int j=1;j<=m;j++)\t\t{\t\t\tget_max(g[i][j],dp+S[i][j]);\t\t\tdp=max(dp,g[i-1][j]-tmp);\t\t\ttmp=min(tmp,S[i][j]);\t\t}\t}\tlong long ans=-inf;\tfor(int i=1;i<=m;i++)\t\tget_max(ans,f[n][i]),get_max(ans,g[n][i]);\tprintf(\"%lld\\n\",ans);}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Boss, Thirsty.json"
}