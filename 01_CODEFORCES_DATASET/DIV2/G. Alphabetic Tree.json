{
    "link": "https://codeforces.com//contest/1608/problem/G",
    "problemId": "1223929",
    "problem_idx": "G",
    "shortId": "1608G",
    "contest_number": "1608",
    "problem_submissions": {
        "G": [
            138775127
        ],
        "F": [
            138754387,
            138771178,
            138771063,
            138772062,
            138791656,
            138791262,
            138768315,
            138766868,
            157787859,
            164237887,
            237837030,
            237836998,
            237835750
        ],
        "E": [
            138739786,
            138742154,
            138749882,
            138750135,
            138747933,
            138773994,
            138772884,
            138751851,
            138752060,
            138750338,
            138775532,
            138760313,
            138774000,
            138762726,
            138757936,
            138757827,
            138764476,
            138758978,
            138759090,
            138760707,
            138762156,
            138756888
        ],
        "D": [
            138734567,
            138734532,
            138736194,
            138735000,
            138740009,
            138735872,
            138737965,
            138741407,
            138737384,
            138742340,
            138747991,
            138746601,
            138745994,
            138748332,
            138739363,
            138743644,
            138745225,
            138751720,
            138746081
        ],
        "C": [
            138730911,
            138728412,
            138732051,
            138729895,
            138733167,
            138732651,
            138732813,
            138735111,
            138729971,
            138736027,
            138735972,
            138737416,
            138733290,
            138734144,
            138732973,
            138735675,
            138739036,
            138733532,
            138737913
        ],
        "B": [
            138728496,
            138730558,
            138729168,
            138727806,
            138728454,
            138727786,
            138728495,
            138729879,
            138726790,
            138731838,
            138730784,
            138733303,
            138728802,
            138731138,
            138729760,
            138729468,
            138732919,
            138731528,
            138735209
        ],
        "A": [
            138720875,
            138721636,
            138720831,
            138720708,
            138721065,
            138720677,
            138722900,
            138720671,
            138720647,
            138720885,
            138721095,
            138720890,
            138720651,
            138720737,
            138720886,
            138721221,
            138721571,
            138720878,
            138720786
        ]
    },
    "name": "G. Alphabetic Tree",
    "statement": "You are given m strings and a tree on n nodes. Each edge has some letter\r\nwritten on it.You have to answer q queries. Each query is described by 4\r\nintegers u, v, l and r. The answer to the query is the total number of\r\noccurrences of str(u,v) in strings with indices from l to r. str(u,v) is\r\ndefined as the string that is made by concatenating letters written on\r\nthe edges on the shortest path from u to v (in order that they are\r\ntraversed).\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\n//yosupo\n//TKPPC G\nstruct SA{\n\tint n;\n\tvi sa,as,lcp;\n\tSA(){}\n\ttemplate<class t> SA(t s):n(s.size()),sa(n),as(n),lcp(n-1){\n\t\trep(i,n)sa[i]=n-1-i;\n\t\tstable_sort(all(sa),[&](int a,int b){return s[a]<s[b];});\n\t\tvi c(n);\n\t\trep(i,n)c[i]=s[i];\n\t\tfor(int w=1;w<n;w*=2){\n\t\t\tvi d(c);\n\t\t\trep(i,n){\n\t\t\t\tif(i&&sa[i-1]+w<n&&d[sa[i-1]]==d[sa[i]]&&d[sa[i-1]+w/2]==d[sa[i]+w/2])\n\t\t\t\t\tc[sa[i]]=c[sa[i-1]];\n\t\t\t\telse\n\t\t\t\t\tc[sa[i]]=i;\n\t\t\t}\n\t\t\tvi e(sa),f(n);\n\t\t\tiota(all(f),0);\n\t\t\trep(i,n){\n\t\t\t\tint j=e[i]-w;\n\t\t\t\tif(j>=0)sa[f[c[j]]++]=j;\n\t\t\t}\n\t\t}\n\t\t//as\n\t\trep(i,n)as[sa[i]]=i;\n\t\t//lcp\n\t\tint w=0;\n\t\tfor(auto i:as){\n\t\t\tif(w)w--;\n\t\t\tif(i<n-1){\n\t\t\t\twhile(max(sa[i],sa[i+1])+w<n&&s[sa[i]+w]==s[sa[i+1]+w])w++;\n\t\t\t\tlcp[i]=w;\n\t\t\t}\n\t\t}\n\t}\n};\n\n//CF530F\n//returns the suffix tree\n//the i-th (0<=i<=n-1) element corresponds to the lexicographically i-th suffix\nstruct ste{\n\tint to,l,r;\n\toperator int()const{return to;}\n};\nostream&operator<<(ostream&os,const ste&a){\n\treturn os<<\"ste{\"<<a.to<<\",[\"<<a.l<<\",\"<<a.r<<\"]}\";\n}\npair<vvc<ste>,int> stree(const SA&sa){\n\tint n=sa.n,s=n*2-1;\n\tvi len(s);\n\trep(i,n)len[i]=n-sa.sa[i];\n\trep(i,n-1)len[i+n]=sa.lcp[i];\n\tvi idx(n-1);\n\tiota(all(idx),n);\n\tstable_sort(all(idx),[&](int a,int b){return len[a]>len[b];});\n\tunionfind uf(s);\n\tvi par(s,-1),c(s,-1);\n\trep(i,n)c[i]=sa.sa[i];\n\tfor(auto i:idx){\n\t\tint a=uf.find(i-n),b=uf.find(i-n+1);\n\t\tuf.unite(i,a);\n\t\tuf.unite(i,b);\n\t\tpar[a]=i;\n\t\tpar[b]=i;\n\t\tc[i]=c[a];\n\t}\n\tpar[n==1?0:idx.back()]=s++;\n\tlen.pb(0);\n\tuf=unionfind(s);\n\trep(i,s-1)if(len[i]==len[par[i]])\n\t\tuf.unite(i,par[i]);\n\tvi vs;\n\trep(i,s)if(uf.find(i)==i)vs.pb(i);\n\tauto z=[&](int i){return lower_bound(all(vs),uf.find(i))-vs.bg;};\n\tvvc<ste> res(vs.size());\n\trep(ii,s-1){\n\t\tint i=ii/2+ii%2*n;\n\t\tint a=z(i),b=z(par[i]);\n\t\tif(a==b)continue;\n\t\tres[b].pb(ste{a,c[i]+len[par[i]],c[i]+len[i]});\n\t}\n\treturn make_pair(res,z(s-1));\n}\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.clear();buf.resize(s=n,0);}\n\tvoid init(const vc<t>&a){\n\t\ts=si(a);\n\t\tbuf.resize(s);\n\t\trep(i,s)buf[i]=a[i];\n\t\trep(i,s){\n\t\t\tint j=i+((i+1)&(-i-1));\n\t\t\tif(j<s)buf[j]+=buf[i];\n\t\t}\n\t}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tvoid add_range(int b,int e,t v){\n\t\tadd(b,v);\n\t\tadd(e,-v);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\ntemplate<class t>\nstruct Point1D{\n\tBIT<t> bit;\n\tvi pos;\n\tvoid addp(int p){\n\t\tpos.pb(p);\n\t}\n\tvoid init(){\n\t\tmkuni(pos);\n\t\tbit.init(pos.size());\n\t}\n\tint idx(int p){\n\t\treturn lwb(pos,p);\n\t}\n\tvoid addv(int p,t v){\n\t\tbit.add(idx(p),v);\n\t}\n\tt sum(int b,int e){\n\t\treturn bit.sum(idx(b),idx(e));\n\t}\n\t//[-inf,p)\n\tt getpref(int p){\n\t\treturn bit.get(idx(p)-1);\n\t}\n};\n\ntemplate<class t>\nstruct Point2D{\n\tvc<Point1D<t>> buf;\n\tvi pos,xs,ys;\n\tvoid addp(int x,int y){\n\t\txs.pb(x);\n\t\tys.pb(y);\n\t}\n\tint idx(int p){\n\t\treturn lwb(pos,p);\n\t}\n\tvoid init(){\n\t\tpos=xs;\n\t\tmkuni(pos);\n\t\tbuf.resize(pos.size());\n\t\trep(i,xs.size())\n\t\t\tfor(int j=idx(xs[i]);j<int(buf.size());j+=(j+1)&(-j-1))\n\t\t\t\tbuf[j].addp(ys[i]);\n\t\tfor(auto&b:buf)b.init();\n\t}\n\tvoid addv(int x,int y,t v){\n\t\tfor(int j=idx(x);j<int(buf.size());j+=(j+1)&(-j-1))\n\t\t\tbuf[j].addv(y,v);\n\t}\n\t//[x1,x2)*[y1,y2)\n\tt rect(int x1,int x2,int y1,int y2){\n\t\tt res=0;\n\t\tfor(int j=idx(x1)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres-=buf[j].sum(y1,y2);\n\t\tfor(int j=idx(x2)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres+=buf[j].sum(y1,y2);\n\t\treturn res;\n\t}\n\t//NOT VERIFIED\n\t//[-inf,x)*[-inf,y)\n\tt getpref(int x,int y){\n\t\tt res=0;\n\t\tfor(int j=idx(x)-1;j>=0;j-=(j+1)&(-j-1))\n\t\t\tres+=buf[j].getpref(y);\n\t\treturn res;\n\t}\n};\n\n\n//KUPC 2020 C\n//重心分解してクエリに答える\n//クエリ (a,b) に対しては，LCA から a までのパスと，LCA から b までのパスの情報を使って答える．\n//パスの情報は N に保存される\n//N() が単位元的な役割\n//N.extend(e) で辺 e を使って下に下って新しいノードを作る\n//N 同士のマージをやると計算量が壊れるが extend なら．．．というときに使える\ntemplate<class E,class N>\nstruct cdecomp{\n\tconst vvc<E>&g;\n\tint n;\n\tvi rem;\n\t\n\tint ts(int v,int p){\n\t\tint res=1;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e])\n\t\t\tres+=ts(e,v);\n\t\treturn res;\n\t}\n\tint fc(int v,int p,int s){\n\t\tint ret=1,mx=0;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e]){\n\t\t\tint f=fc(e,v,s);\n\t\t\tif(f<=0)\n\t\t\t\treturn f;\n\t\t\telse{\n\t\t\t\tret+=f;\n\t\t\t\tmx=max(mx,f);\n\t\t\t}\n\t\t}\n\t\tmx=max(mx,s-ret);\n\t\tif(mx*2<=s)\n\t\t\treturn -v;\n\t\telse\n\t\t\treturn ret;\n\t}\n\t\n\tcdecomp(const vvc<E>&gg):g(gg),n(g.size()),rem(n){\n\t}\n\t\n\tvc<N> buf0;\n\tvc<N> buf1;\n\tvi tp;\n\tvvc<tuple<int,int,int>> bucket;\n\t\n\tvoid dfs1(int v,int p,int i,N cur0,N cur1){\n\t\tbuf0[v]=cur0;\n\t\tbuf1[v]=cur1;\n\t\ttp[v]=i;\n\t\tfor(auto e:g[v])if(e!=p&&!rem[e]){\n\t\t\tdfs1(e,v,i==-1?e:i,cur0.extend(e),cur1.extend(e));\n\t\t}\n\t}\n\t\n\ttemplate<class F>\n\tvoid con(int r,const vc<tuple<int,int,int>>&qs,F f){\n\t\tr=-fc(r,-1,ts(r,-1));\n\t\t\n\t\tN ini0,ini1;\n\t\tini0.init(0);\n\t\tini1.init(1);\n\t\tdfs1(r,-1,-1,ini0,ini1);\n\t\tfor(const auto&w:qs){\n\t\t\tint a,b,i;tie(a,b,i)=w;\n\t\t\tif(tp[a]!=tp[b]){\n\t\t\t\tf(i,buf0[a],buf1[b],r);\n\t\t\t}else{\n\t\t\t\tbucket[tp[a]].pb(w);\n\t\t\t}\n\t\t}\n\t\t\n\t\trem[r]=1;\n\t\tfor(auto e:g[r])if(!rem[e]){\n\t\t\tvc<tuple<int,int,int>> tmp;\n\t\t\ttmp.swap(bucket[e]);\n\t\t\tcon(e,tmp,f);\n\t\t}\n\t}\n\t\n\t//f(idx,N lf,N rt,int lca) がよばれる\n\t//[qs[i].a,lca) が lf に，[qs[i].b,lca) が rt に入るらしい\n\ttemplate<class F>\n\tvoid slv(const vc<pi>&qs,F f){\n\t\tfill(all(rem),0);\n\t\tbuf0.resize(n);\n\t\tbuf1.resize(n);\n\t\ttp.resize(n);\n\t\tbucket.resize(n);\n\t\t\n\t\tvc<tuple<int,int,int>> tmp(si(qs));\n\t\trep(i,si(qs))\n\t\t\ttmp[i]=mt(qs[i].a,qs[i].b,i);\n\t\tcon(0,tmp,f);\n\t}\n};\n\nstruct E{\n\tint to;\n\tchar c;\n\toperator int()const{return to;}\n};\n\nSA sa[2];\nvvc<ste> st[2];\nint stroot[2];\nvi in[2],out[2];\nint ord[2];\n\nvoid dfs(int k,int v){\n\tin[k][v]=ord[k]++;\n\tfor(auto e:st[k][v])\n\t\tdfs(k,e.to);\n\tout[k][v]=ord[k];\n}\n\nstring z[2];\n\nstruct N{\n\tint k,v,dig,len;\n\tvoid init(int kk){\n\t\tk=kk;\n\t\tv=stroot[k];\n\t\tdig=-1;\n\t\tlen=-1;\n\t}\n\tN extend(const E&e)const{\n\t\tif(v==-1)return N{-1,-1,-1,-1};\n\t\tN res=*this;\n\t\tif(res.dig==-1){\n\t\t\trep(i,si(st[k][v])){\n\t\t\t\tif(z[k][st[k][v][i].l]==e.c){\n\t\t\t\t\tres.dig=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res.dig==-1){\n\t\t\t\treturn N{-1,-1,-1,-1};\n\t\t\t}\n\t\t\tres.len=0;\n\t\t}\n\t\tconst auto&f=st[k][v][res.dig];\n\t\tif(z[k][f.l+res.len]!=e.c)return N{-1,-1,-1,-1};\n\t\tres.len++;\n\t\tif(f.r-f.l==res.len){\n\t\t\treturn N{k,f.to,-1,-1};\n\t\t}else{\n\t\t\treturn res;\n\t\t}\n\t}\n\tpi getlr(){\n\t\tif(v==-1)return pi(-1,-1);\n\t\tint w=v;\n\t\tif(len>0){\n\t\t\tw=st[k][v][dig].to;\n\t\t}\n\t\treturn pi(in[k][w],out[k][w]);\n\t}\n};\n\n/*\n//example\nauto slv=[&](int dst,N x,N y,int lca){\n\tx.off^=y.off;\n\trep(i,y.s)x.add(y.vs[i]);\n\tif(cv[lca]!=-1)x.add(cv[lca]);\n\tans[dst]=x.getans(ks[dst]);\n};\n*/\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\t\n\tvvc<E> tr(n);\n\trep(i,n-1){\n\t\tint u,v;cin>>u>>v;\n\t\tu--;v--;\n\t\tstring s;cin>>s;\n\t\ttr[u].pb(E{v,s[0]});\n\t\ttr[v].pb(E{u,s[0]});\n\t}\n\t\n\tz[0]=\"$\";\n\tvi off(m),len(m);\n\trep(i,m){\n\t\toff[i]=si(z[0]);\n\t\tstring s;cin>>s;\n\t\tlen[i]=si(s);\n\t\tz[0]+=s;\n\t\tz[0]+='$';\n\t}\n\tz[1]=z[0];\n\treverse(all(z[1]));\n\t\n\trep(k,2){\n\t\ttie(st[k],stroot[k])=stree(sa[k]=SA(z[k]));\n\t\tin[k].resize(si(st[k]));\n\t\tout[k].resize(si(st[k]));\n\t\tdfs(k,stroot[k]);\n\t\tdmp(k);\n\t\tdmp(st[k]);\n\t\tdmp(in[k]);\n\t}\n\t\n\tusing P=pair<pi,pi>;\n\tvc<pi> uv(q);\n\tvvc<int> baka(m+1);\n\tvc<P> ls(q);\n\trep(i,q){\n\t\tint u,v,l,r;cin>>u>>v>>l>>r;\n\t\tu--,v--,l--;\n\t\tuv[i]=pi(v,u);\n\t\tbaka[l].pb(i*2);\n\t\tbaka[r].pb(i*2+1);\n\t}\n\t\n\tauto unko=[&](int idx,N lf,N rt,int){\n\t\tls[idx]=P(lf.getlr(),rt.getlr());\n\t};\n\t\n\tcdecomp<E,N> cd(tr);\n\tcd.slv(uv,unko);\n\t\n\tdmp(ls);\n\t\n\tPoint2D<int> p2d;\n\trep(i,m){\n\t\trng(j,off[i],off[i]+len[i]+1){\n\t\t\tint x=in[0][sa[0].as[j]];\n\t\t\tint y=in[1][sa[1].as[si(z[1])-j]];\n\t\t\tdmp2(x,y);\n\t\t\tp2d.addp(x,y);\n\t\t}\n\t}\n\tp2d.init();\n\t\n\tvi ans(q);\n\t\n\trep(i,m+1){\n\t\tfor(auto w:baka[i]){\n\t\t\tauto [xl,xr]=ls[w/2].a;\n\t\t\tauto [yl,yr]=ls[w/2].b;\n\t\t\tans[w/2]+=p2d.rect(xl,xr,yl,yr)*(w%2==0?-1:1);\n\t\t}\n\t\tif(i<m){\n\t\t\trng(j,off[i],off[i]+len[i]+1){\n\t\t\t\tint x=in[0][sa[0].as[j]];\n\t\t\t\tint y=in[1][sa[1].as[si(z[1])-j]];\n\t\t\t\tp2d.addv(x,y,1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,q)print(ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "hashing",
        "string suffix structures",
        "strings",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Alphabetic Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/97782",
    "editorial": "Letâs concatenate the input strings, separated by some character not in\r\nthe input, into a string , and build the suffix array over it. If we\r\ncould lexicographically compare to some suffix of , we could use binary\r\nsearch to find the left and right boundary of suffixes that start with\r\nin the suffix array. Knowing how to find the longest common prefix of a\r\npath in the tree and a suffix of would help us in comparing them, since\r\nwe would know the first position where these string differ. Letters on\r\nthe tree are still unrelated to the letters in concatenated string, so\r\nletâs append them to in some helpful way. Letâs split the tree into\r\nchains using heavy-light decomposition and append the chains and\r\nreversed chains to the string . This way every path in the tree can be\r\nsplit into parts which are substrings of . Letâs build LCP array of from\r\nitâs suffix array, and then sparse table over the LCP array, to be able\r\nto answer queries for longest common prefix of two suffixes of in . With\r\nsuch queries we can get longest common prefix of a path and a suffix of\r\nin by querying LCP for parts of the path and corresponding suffixes of .\r\nNow we know how to find the range of suffixes which have as a prefix.\r\nOut of these suffixes we have to count only these for which first\r\nposition belongs to a string with index in the set . We can do the\r\ncounting offline, sweeping through strings from the first to the last\r\nand maintaining binary indexed tree over suffix array. In iteration we\r\nstore for suffixes of strings with indices , and for the rest. A query\r\ncan be solved by taking the difference of sums on suffix array range in\r\niteration and in iteration . Building suffix array can be done in , or\r\ndepending on the chosen algorithm, LCP array can be constructed from the\r\nsuffix array in using Kasaiâs algorithm, while the sparse table\r\nconstruction works in and uses memory. Searching for the ranges can be\r\ndone in as described above, and the last offline sweeping part takes\r\ntime. The overall time complexity is , with memory.\r\n",
    "hint": []
}