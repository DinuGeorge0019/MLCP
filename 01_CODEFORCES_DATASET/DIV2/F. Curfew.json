{
    "link": "https://codeforces.com//contest/950/problem/F",
    "problemId": "163627",
    "problem_idx": "F",
    "shortId": "950F",
    "contest_number": "950",
    "problem_submissions": {
        "F": [
            36110799,
            36106874,
            36110418,
            36111996,
            36110842,
            36112881,
            36112066,
            36111037,
            36115685,
            36107783,
            36111061,
            36110969
        ],
        "E": [
            36106600,
            36110576,
            36107020,
            36108185,
            36105421,
            36110602,
            36104100,
            36112036,
            36103180,
            36119591,
            36103520,
            36104391,
            36111839,
            36104803,
            36105285,
            36106153,
            36105692,
            36107917,
            36133513,
            36106022
        ],
        "D": [
            36099255,
            36103207,
            36103975,
            36101168,
            36099422,
            36104316,
            36100451,
            36105727,
            36100010,
            36100957,
            36098808,
            36101447,
            36108972,
            36101180,
            36100807,
            36101948,
            36101824,
            36102198,
            36099705,
            36115114,
            36103338
        ],
        "B": [
            36097037,
            36093570,
            36096763,
            36102283,
            36107341,
            36096070,
            36118539,
            36103628,
            36098191,
            36093324,
            36097654,
            36092909,
            36097186,
            36093092,
            36094178,
            36093761,
            36093826,
            36092324,
            36094422,
            36093177
        ],
        "C": [
            36095719,
            36096428,
            36100419,
            36099281,
            36103315,
            36101716,
            36094357,
            36100382,
            36094934,
            36098794,
            36096378,
            36098545,
            36106922,
            36096674,
            36097941,
            36096847,
            36097394,
            36095627,
            36097024,
            36097344
        ],
        "A": [
            36091256,
            36091581,
            36094574,
            36100244,
            36107668,
            36091536,
            36095298,
            36101664,
            36095785,
            36091314,
            36098215,
            36091291,
            36093398,
            36091393,
            36091803,
            36091568,
            36091610,
            36091266,
            36092123,
            36091364
        ]
    },
    "name": "F. Curfew",
    "statement": "Instructors of Some Informatics School make students go to bed.The house\r\ncontains rooms, in each room exactly students were supposed to sleep.\r\nHowever, at the time of curfew it happened that many students are not\r\nlocated in their assigned rooms. The rooms are arranged in a row and\r\nnumbered from to . Initially, in -th room there are students. All\r\nstudents are currently somewhere in the house, therefore . Also\r\ninstructors live in this house.The process of curfew enforcement is the\r\nfollowing. One instructor starts near room and moves toward room , while\r\nthe second instructor starts near room and moves toward room . After\r\nprocessing current room, each instructor moves on to the next one. Both\r\ninstructors enter rooms and move simultaneously, if is odd, then only\r\nthe first instructor processes the middle room. When all rooms are\r\nprocessed, the process ends.When an instructor processes a room, she\r\ncounts the number of students in the room, then turns off the light, and\r\nlocks the room. Also, if the number of students inside the processed\r\nroom is not equal to , the instructor writes down the number of this\r\nroom into her notebook (and turns off the light, and locks the room).\r\nInstructors are in a hurry (to prepare the study plan for the next day),\r\nso they don’t care about who is in the room, but only about the number\r\nof students.While instructors are inside the rooms, students can run\r\nbetween rooms that are not locked and not being processed. A student can\r\nrun by at most rooms, that is she can move to a room with number that\r\ndiffers my at most . Also, after (or instead of) running each student\r\ncan hide under a bed in a room she is in. In this case the instructor\r\nwill not count her during the processing. In each room any number of\r\nstudents can hide simultaneously.Formally, here is what’s happening: A\r\ncurfew is announced, at this point in room there are students. Each\r\nstudent can run to another room but not further than rooms away from her\r\ninitial room, or stay in place. After that each student can optionally\r\nhide under a bed. Instructors enter room and room , they count students\r\nthere and lock the room (after it no one can enter or leave this room).\r\nEach student from rooms with numbers from to can run to another room but\r\nnot further than rooms away from her room, or stay in place. Each\r\nstudent can optionally hide under a bed. Instructors move from room to\r\nroom and from room to room . This process continues until all rooms are\r\nprocessed. Let denote the number of rooms in which the first instructor\r\ncounted the number of non-hidden students different from , and be the\r\nsame number for the second instructor. Students know that the principal\r\nwill only listen to one complaint, therefore they want to minimize the\r\nmaximum of numbers . Help them find this value if they use the optimal\r\nstrategy.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100100;\nint a[N],n,d,b;\nint gsm(long long l,long long r){\n\tif(l<1)l=1;if(r>n)r=n;\n\treturn a[r]-a[l-1];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&d,&b);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(int i=1;i<=n;i++)a[i]+=a[i-1];\n\tint Lu=0,Ru=0,fcnt1=0,fcnt2=0;\n\tfor(int i=1;i<=n/2;i++){\n\t\tint u=gsm(1,i+(long long)i*d);\n\t\tif(u>=Lu+b){\n\t\t\tLu+=b;\n\t\t}else fcnt1++;\n\t\tu=gsm(n-i+1-(long long)i*d,n);\n\t\tif(u>=Ru+b){\n\t\t\tRu+=b;\n\t\t}else fcnt2++;\n\t}\n\tprintf(\"%d\\n\",max(fcnt1,fcnt2));\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Curfew.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Let's solve the problem in case when there is only one instructor (which moves from left to right and the only goal is to minimize number of bad rooms)\n\nI claim, that the following greedy works:\n\nMove through rooms from left to right\nIf there are too many students inside room, send the excess students to the next room\nIf there are not enough students, but it is possible to fulfill this room from rooms on the right (the sum  is at least b), then do it.\nIf it's not possible, then send all students to the following room.\nIf it is the last room, say that those students are hiding in it.\nThis greedy can be implemented in  time: calculate the prefix sums on the initial ai, this way you can check if it is possible to move students from following rooms here fast.\n\nTo handle the removal students from following rooms you can maintain the current \"debt\" of students. When you first consider room you can repay the debt as much as you can and then check one of the cases above. Since the both left and right borders of segments are moving monotonously the debt will be \"inherited\" correctly.\n\nNotice, that you can only consider \"paths of different students never cross\", that means if first student was initially in room i and moved to a, while the second student was in j and moved to b, then if i???j than a???b. Because otherwise you can swap students and nothing will change.\n\nThe proof of the greedy (you can possibly skip it).\n\nSuppose there is a better answer, which completes the rooms a1, ..., ak, while the greedy solutions completes rooms b1, ..., bl, l?<?k.\n\nWe will assume that in optimal solution paths of students don't intersect, that all \"excessive\" students are hiding in last room and that all rooms in optimal answer are either full (b) or empty (0). Otherwise it's possible to change the \"correct answer in such way, that number of good rooms will not decrease.\n\nLet's i is smallest index when ai???bi. Then ai?>?bi, because greedy solution would always fulfill the room ai if it would be possible (actually, greedy solution builts the lexmin solution).\n\nBut if ai?>?bi we can \"patch\" the supposed optimal solution and move all students which were sent to room bi to ai (we know it is possible by the greedy solution's answer).\n\nThis way we can increase the common prefix with any possible \"best\" answer hence contradiction.\n\nBack to the problem with two instructors. Recall, that \"paths of different students don't cross\", hence there exists a \"border\", the number x from 0 to nb, where the first x students are going to the first instructor and all others to second.\n\nOne could have bruteforced that border and solved the both halfs of the array by the method above, but then the complexity will be n2·b which is too much. We need to search for the border more efficiently.\n\nLet f(m) will be the answer for first instructor, when he is given m first students and g(m) is the answer for second instructor when he is given all students except first m ones.\n\nIt is easy to see, that f(m) in decreasing, while g(m) is increasing (both times it is not strict monotonicity). Indeed, the more students are given to instructor, than more opportunities he has (all excessive students can always hide, so it is not a problem).\n\nWe are searching for m where ans(m)?=?max(f(m),?g(m)) is smallest possible.Let's introduce function z(m)?=?g(m)?-?f(m)  increasing (but still not strict).\n\nLet's call m0 the smallest index, such that z(m0)???0. One can see, that a min(ans(m0?-?1),?ans(m0)) is the final answer. Indeed, if one will try greater m's than m0, than the g(m) will be dominating in max, and hence ans(m0) is more optimal. Otherwise, if m?<?m0?-?1, then ans(m) is better.",
    "hint": []
}