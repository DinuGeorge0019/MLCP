{
    "link": "https://codeforces.com//contest/1762/problem/D",
    "problemId": "1695273",
    "problem_idx": "D",
    "shortId": "1762D",
    "contest_number": "1762",
    "problem_submissions": {
        "F": [
            185360973,
            185364441,
            185372202,
            185395910,
            185621065,
            185354232,
            185332491,
            185348264,
            185360759,
            197448951,
            197448921
        ],
        "E": [
            185344507,
            185353525,
            185341937,
            185339289,
            185344504,
            185352316,
            185360035,
            185362208,
            185365484,
            185404755,
            185370016,
            185351528,
            185364233,
            185367555,
            191848003,
            185329145
        ],
        "D": [
            185337625,
            185342301,
            185324406,
            185313736,
            185320476,
            185336684,
            185335575,
            185333725,
            185325437,
            185329719,
            185355407,
            185334757,
            185358794,
            185354685,
            185353510,
            203219751,
            203219727,
            185328017,
            185332700,
            185327767
        ],
        "C": [
            185322060,
            185321446,
            185314988,
            185324570,
            185312857,
            185315091,
            185320564,
            185320295,
            185330972,
            185319388,
            185342558,
            185326201,
            185316184,
            185309915,
            185362472,
            185315926,
            185312437,
            185310609,
            185320776
        ],
        "B": [
            185304175,
            185312988,
            185302843,
            185317620,
            185309312,
            185304849,
            185311399,
            185308703,
            185304961,
            185310615,
            185338037,
            185310014,
            185310646,
            185303730,
            185343806,
            185303744,
            185303718,
            185304581,
            185309640
        ],
        "A": [
            185300504,
            185304250,
            185300255,
            185302050,
            185306620,
            185300445,
            185302307,
            185307731,
            185300743,
            185301230,
            185335246,
            185301137,
            185300437,
            185300430,
            185322563,
            185300790,
            185300333,
            185302002,
            185301784
        ],
        "G": [
            185409628,
            185346613
        ]
    },
    "name": "D. GCD Queries ",
    "statement": "There is a secret permutation p of [0,1,2,\r\nldots,n-1]. Your task is to find 2 indices x and y (1\r\nleq x, y\r\nleq n, possibly x=y) such that p_x=0 or p_y=0. In order to find it, you\r\nare allowed to ask 2n queries.In one query, you give two integers i and\r\nj (1\r\nleq i, j\r\nleq n, i\r\nneq j) and receive the value of\r\ngcd(p_i,p_j)^\r\ndagger.Note that the permutation p is fixed any queries are made and\r\ndoes not depend on the queries.^\r\ndagger\r\ngcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.\r\nNote that\r\ngcd(x,0)=\r\ngcd(0,x)=x for all positive integers x.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> v , g , v2;\nbool ok[20005];\nint query(int i,int j)\n{\n    printf(\"? %d %d\\n\",i,j);fflush(stdout);\n    int x;scanf(\"%d\",&x);\n    return x;\n}\nmt19937 rnd(time(0));\nvoid shuf()\n{\n    for(int i = 1;i < v.size();i++) {\n        swap(v[i] , v[rnd()%(i + 1)]);\n    }\n    return;\n}\nvoid solve()\n{\n    scanf(\"%d\",&n);v.clear();\n    for(int i = 1;i <= n;i++) v.push_back(i);\n    while(v.size() > 2) {\n        g.clear();\n        for(int i = 0;i < v.size();i++) ok[i] = 1;\n        for(int i = 0;i + 2 < v.size();i += 3) {\n            int a= query(v[i] , v[i + 1]) , b = query(v[i + 1] , v[i + 2]);\n            if(a > b) ok[i + 2] = 0;\n            else if(a < b) ok[i] = 0;\n            else ok[i + 1] = 0;\n        }\n        v2.clear();\n        for(int i = 0;i < v.size();i++) {\n            if(ok[i]) v2.push_back(v[i]);\n        }\n        swap(v , v2);\n    }\n    printf(\"! %d %d\\n\",v[0],v[1]) ; fflush(stdout);int d;scanf(\"%d\",&d);\n    return;\n}\nint main() {\n //   freopen(\"in.txt\",\"r\",stdin);\n    srand(time(NULL));\n    int t;scanf(\"%d\",&t);\n    while(t--) solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. GCD Queries .json",
    "editorial_link": "https://codeforces.com//blog/entry/110169",
    "editorial": "SolutionSo suppose we have three distinct indices , and .Let us assume\r\nand Now we have only three possibilities. In this case, cannot be . Why?\r\nand are distinct, and we have if In this case, cannot be . Why? Note and\r\ncan be atmost for any non negative integer. If , this means cannot be .\r\nThus for sure In this case, cannot be . Why? Refer to the above\r\nargument. This we can eliminate one index on using queries. We will\r\nperform this operation times. Refer to attached code for details.Time\r\ncomplexity is .\r\n"
}