{
    "link": "https://codeforces.com//contest/1136/problem/E",
    "problemId": "311124",
    "problem_idx": "E",
    "shortId": "1136E",
    "contest_number": "1136",
    "problem_submissions": {
        "E": [
            51189467,
            51191046,
            51188149,
            51188855,
            51190741,
            51191408,
            51191033,
            51190850,
            51194968,
            51193904,
            51191352,
            51194243,
            51193372,
            51194410,
            51195041,
            51186939,
            51301458,
            51187400,
            108142946
        ],
        "D": [
            51180882,
            51177336,
            51181079,
            51182192,
            51180429,
            51179730,
            51184359,
            51186400,
            51182377,
            51185059,
            51181346,
            51187131,
            51180821,
            51187135,
            51188443,
            51182185,
            51181190,
            51180808,
            51185600
        ],
        "C": [
            51175111,
            51174280,
            51177685,
            51177311,
            51177103,
            51175422,
            51178344,
            51175375,
            51179187,
            51176703,
            51175880,
            51179438,
            51181887,
            51178846,
            51181563,
            51198833,
            51176953,
            51176740,
            51179104
        ],
        "B": [
            51173283,
            51172239,
            51175677,
            51174542,
            51172486,
            51175496,
            51178841,
            51174659,
            51174225,
            51173330,
            51175893,
            51182729,
            51176296,
            51176824,
            51173811,
            51174832,
            51175088,
            51177269
        ],
        "A": [
            51171549,
            51171474,
            51171656,
            51171563,
            51171471,
            51172689,
            51176507,
            51172194,
            51172348,
            51171636,
            51172774,
            51183297,
            51171952,
            51174150,
            51171613,
            51171562,
            51173429,
            51171702
        ]
    },
    "name": "E. Nastya Hasn t Written a Legend",
    "statement": "In this task, Nastya asked us to write a formal statement.An array a of\r\nlength n and an array k of length n-1 are given. Two types of queries\r\nshould be processed: increase a_i by x. Then if a_{i+1} < a_i + k_i,\r\na_{i+1} becomes exactly a_i + k_i; again, if a_{i+2} < a_{i+1} +\r\nk_{i+1}, a_{i+2} becomes exactly a_{i+1} + k_{i+1}, and so far for\r\na_{i+3}, ..., a_n; print the sum of the contiguous subarray from the\r\nl-th element to the r-th element of the array a. It\u2019s guaranteed that\r\ninitially a_i + k_i\r\nleq a_{i+1} for all 1\r\nleq i\r\nleq n-1.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 131072;\nint N;\nlong long a[MAXN];\nlong long k[MAXN];\nlong long v1[MAXN];\nset<int> v1_nonzero;\n\nlong long segsum[2*MAXN]; // v[a]\nlong long segnsum[2*MAXN]; // a*v[a];\nlong long getv(long long* seg, int a, int b)\n{\n  a += MAXN; b += MAXN;\n  long long ans = 0;\n  while(a<=b)\n  {\n    if(a%2 == 1) ans += seg[a++];\n    if(b%2 == 0) ans += seg[b--];\n    a /= 2; b /= 2;\n  }\n  return ans;\n}\nvoid setv(long long* seg, int a, long long v)\n{\n  a += MAXN;\n  seg[a] += v;\n  while((a=a/2))\n    seg[a] = seg[a*2]+seg[a*2+1];\n}\nlong long SUM(int l, int r)\n{\n  long long ar = getv(segsum, 0, r-1);\n  long long al = getv(segsum, 0, l-1);\n  return r*ar-getv(segnsum, l, r-1)-(l-1)*al;\n}\nvoid SET(int a, long long v)\n{\n  //printf(\"%d %lld\\n\", a, v);\n  setv(segsum, a, v);\n  setv(segnsum, a, a*v);\n  /*for(int i=0; i<2*MAXN; ++i)\n    printf(\"%3d\", i);\n  puts(\"\");\n  for(int i=0; i<2*MAXN; ++i)\n    printf(\"%3lld\", segsum[i]);\n  puts(\"\");\n  for(int i=0; i<2*MAXN; ++i)\n    printf(\"%3lld\", segnsum[i]);\n  puts(\"\");\n  */\n}\nvoid ADD(int id, long long x)\n{\n  // no x = 0;\n  if(x == 0) return;\n  \n  // v1[id-1] inc, v1[id] dec\n  v1[id-1] += x; v1_nonzero.insert(id-1); SET(id-1, x);\n  v1[id] -= x; SET(id, -x);\n  if(v1[id] > 0)\n    return;\n  if(v1[id] == 0)\n  {\n    v1_nonzero.erase(id); return;\n  }\n  long long remain = -v1[id];\n  SET(id, -v1[id]); v1[id] = 0;\n  v1_nonzero.erase(id);\n  auto it = v1_nonzero.lower_bound(id);\n  while(remain > 0 && it != v1_nonzero.end())\n  {\n    long long v = min(remain, v1[*it]);\n    remain -= v; v1[*it] -= v; SET(*it, -v);\n    if(v1[*it] == 0)\n      v1_nonzero.erase(it++);\n  }\n  return;\n}\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i=1; i<=N; ++i)\n    scanf(\"%lld\", a+i);\n  for(int i=1; i<=N-1; ++i)\n    scanf(\"%lld\", k+i);\n  for(int i=0; i<=N-1; ++i)\n  {\n    v1[i] = a[i+1]-a[i]-k[i];\n    SET(i, a[i+1]-a[i]);\n    if(v1[i] != 0)\n      v1_nonzero.insert(i);\n  }\n  int Q; scanf(\"%d\", &Q);\n  while(Q--)\n  {\n    char c; int a, b; scanf(\" %c%d%d\", &c, &a, &b);\n    if(c == 's')\n      printf(\"%lld\\n\", SUM(a, b));\n    else\n      ADD(a, b);\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Nastya Hasn t Written a Legend.json",
    "editorial_link": "https://codeforces.com/blog/entry/65905",
    "editorial": "Let , .We can rewrite the condition , using array : Let\u00e2\u0080\u0099s calculate\r\narrays and .So as , in order to get sum in subarray of , we can sum\r\ncorresponding sums in and .Now let\u00e2\u0080\u0099s find out what happens with after\r\naddition to position . increases exactly on . Then, if , becomes equal\r\nto , and so on for , , ..., . Note that array is always sorted and each\r\naddition sets value in half-interval , where - the lowest index such as\r\nTo handle these modifications, let\u00e2\u0080\u0099s build segment tree on array with\r\noperation \"set value on a segment\", which stores sum and maximum in\r\nevery vertex. The only problem is how to find . This can be done with\r\ndescending along the segment tree. If the maximum in the left son of\r\ncurrent vertex is bigger or equal that , we go to the left son,\r\notherwise we go the right son.BONUS: solve it with modifications of\r\nelements of .\r\n"
}