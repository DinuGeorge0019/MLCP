{
    "link": "https://codeforces.com//contest/1730/problem/B",
    "problemId": "1555170",
    "problem_idx": "B",
    "shortId": "1730B",
    "contest_number": "1730",
    "problem_submissions": {
        "F": [
            173481312,
            173482867,
            173478875,
            173582676
        ],
        "D": [
            173464501,
            173463845,
            173492235,
            173460042,
            173462224,
            173461894,
            173462011,
            173463683,
            173464123,
            173466252,
            173465903,
            173465820,
            173472784,
            173476685,
            173475004,
            173471558,
            173472223
        ],
        "C": [
            173450456,
            173450157,
            173457042,
            173452649,
            173450776,
            173453445,
            173454802,
            173455629,
            173456866,
            173446752,
            173444646,
            173455631,
            173457312,
            173447641,
            173447077,
            173451017,
            173452623,
            173453329
        ],
        "B": [
            173445492,
            173444904,
            173458756,
            173449524,
            173445632,
            173448108,
            173451808,
            173449142,
            173453555,
            173457120,
            173455134,
            173451905,
            173454521,
            173452227,
            173444715,
            173446889,
            173447944,
            173446921
        ],
        "A": [
            173439407,
            173438936,
            173438879,
            173443820,
            173439220,
            173439980,
            173443156,
            173443507,
            173445064,
            173455369,
            173446952,
            173439340,
            173447666,
            173440064,
            173438737,
            173441530,
            173439874,
            173440797
        ],
        "E": [
            173564584,
            173477480,
            173568880
        ]
    },
    "name": "B. Meeting on the Line",
    "statement": "n people live on the coordinate line, the i-th one lives at the point\r\nx_i (1\r\nle i\r\nle n). They want to choose a position x_0 to meet. The i-th person will\r\nspend |x_i - x_0| minutes to get to the meeting place. Also, the i-th\r\nperson needs t_i minutes to get dressed, so in total he or she needs\r\nt_i + |x_i - x_0| minutes. Here |y| denotes the absolute value of\r\ny.These people ask you to find a position x_0 that minimizes the time in\r\nwhich all n people can gather at the meeting place.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1e9+7;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint T,n;\nint x[100005],t[100005];\nbool check(int cur){\n\tint lb=-2e9,rb=2e9;\n\tfor(int i=1;i<=n;i++){\n\t\tlb=max(lb,x[i]-(cur-t[i]));\n\t\trb=min(rb,x[i]+(cur-t[i]));\n\t}\n\treturn lb<=rb;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++)cin>>x[i],x[i]*=2;\n\t\tfor(int i=1;i<=n;i++)cin>>t[i],t[i]*=2;\n\t\tint l=*max_element(t+1,t+n+1)-1,r=1e9;\n\t\twhile(r-l>1){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(check(mid))r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tint cur=r;\n\t\tint lb=-2e9,rb=2e9;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tlb=max(lb,x[i]-(cur-t[i]));\n\t\t\trb=min(rb,x[i]+(cur-t[i]));\n\t\t}\n//\t\tcerr<<lb<<\" \"<<rb<<endl;\n//\t\tif(lb!=rb)assert(0);\n\t\tprintf(\"%lf\\n\",lb/2.0);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry",
        "greedy",
        "implementation",
        "math",
        "ternary search"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Meeting on the Line.json",
    "editorial_link": "https://codeforces.com//blog/entry/107293",
    "editorial": "There are many solutions to this problem, here are 2 of them. Let people\r\nbe able to meet in time , then they could meet in time , where . So we\r\ncan find by binary search. It remains to learn how to check whether\r\npeople can meet for a specific time . To do this, for the -th person,\r\nfind a segment of positions that he can get to in time : if then this\r\nsegment is empty, otherwise it is . Then people will be able to meet\r\nonly if these segments intersect, that is, the minimum of the right\r\nborders is greater than or equal to the maximum of the left borders. In\r\norder to find the answer by the minimum , you need to intersect these\r\nsegments in the same way (should get a point, but due to accuracy, most\r\nlikely, a segment of a very small length will turn out) and take any\r\npoint of this intersection. Asymptotics is . If all were equal to , then\r\nthis would be a classical problem, the solution of which would be to\r\nfind the average of the minimum and maximum coordinates of people. We\r\ncan reduce our problem to this one if we replace the person (, ) with\r\ntwo people: (, ) and (, ). Proof. Let the meeting be at the point . Let\r\n. Then this person will need of time to get to her, and the two we want\r\nto replace him with and . it is easy to see that the first value is\r\nequal to the initial value, and the second is not greater than the\r\ninitial value, then the maximum of these two values is equal to the\r\ninitial value. The proof is similar for the case . Then for any meeting\r\npoint, the time in the original problem and after the replacement does\r\nnot differ, which means that such a replacement will not change the\r\nanswer and it can be done. Asymptotics is .\r\n"
}