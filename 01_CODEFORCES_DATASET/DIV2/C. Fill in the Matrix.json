{
    "link": "https://codeforces.com//contest/1869/problem/C",
    "problemId": "2184993",
    "problem_idx": "C",
    "shortId": "1869C",
    "contest_number": "1869",
    "problem_submissions": {
        "E": [
            222790733,
            222755919,
            223014703,
            222844888,
            222822436,
            222820168
        ],
        "D2": [
            222751076,
            222765748,
            222762229,
            222767685,
            222770713,
            222771349,
            222774390,
            222781618,
            222778821,
            222788639,
            222773236,
            222775336,
            222775900,
            222778257,
            222775220,
            222773627,
            222771492
        ],
        "D1": [
            222743411,
            222768273,
            222754309,
            222754872,
            222757370,
            222757211,
            222762465,
            222761473,
            222755833,
            222757091,
            222752420,
            222764925,
            222765023,
            222761868,
            222761450,
            222761828,
            222765878,
            222760854
        ],
        "C": [
            222734213,
            222799024,
            222739072,
            222743933,
            222748797,
            222742198,
            222748357,
            222740791,
            222743470,
            222743624,
            222737636,
            222744668,
            222749662,
            222742346,
            222741675,
            222752222,
            222753724,
            222751049
        ],
        "B": [
            222728831,
            222759638,
            222728679,
            222733793,
            222732869,
            222730403,
            222734827,
            222731660,
            222733775,
            222732224,
            222728510,
            222735540,
            222734578,
            222733639,
            222729850,
            222736886,
            222733662,
            222738397
        ],
        "A": [
            222725390,
            222757999,
            222725599,
            222726282,
            222727750,
            222725856,
            222726824,
            222727514,
            222730110,
            222726868,
            222725449,
            222728462,
            222727639,
            222725642,
            222725871,
            222727421,
            222725878,
            222731354
        ],
        "F": [
            223418170
        ]
    },
    "name": "C. Fill in the Matrix",
    "statement": "There is an empty matrix M of size n\r\ntimes m.Zhongkao examination is over, and Daniel would like to do some\r\npuzzle games. He is going to fill in the matrix M using permutations of\r\nlength m. That is, each row of M must be a permutation of length m^\r\ndagger.Define the of the i-th column in M as v_i=\r\noperatorname{MEX}(M_{1,i},M_{2,i},\r\nldots,M_{n,i})^\r\nddagger. Since Daniel likes diversity, the of M is s=\r\noperatorname{MEX}(v_1,v_2,\r\ncdots,v_m).You have to help Daniel fill in the matrix M and its beauty.^\r\ndagger A permutation of length m is an array consisting of m distinct\r\nintegers from 0 to m-1 in arbitrary order. For example, [1,2,0,4,3] is a\r\npermutation, but [0,1,1] is not a permutation (1 appears twice in the\r\narray), and [0,1,3] is also not a permutation (m-1=2 but there is 3 in\r\nthe array).^\r\nddagger The\r\noperatorname{MEX} of an array is the smallest non-negative integer that\r\ndoes not belong to the array. For example,\r\noperatorname{MEX}(2,2,1)=0 because 0 does not belong to the array, and\r\noperatorname{MEX}(0,3,1,2)=4 because 0, 1, 2 and 3 appear in the array,\r\nbut 4 does not.\r\n",
    "solutions": [
        "// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n#include <bits/stdc++.h>\n// #define int long long\n#define i64 long long\n#define pii pair <int, int> \nusing namespace std;\ninline int read(void) {\n    int x=0,sgn=1; char ch=getchar();\n    while(ch<48||57<ch) {if(ch==45)sgn=0;ch=getchar();}\n    while(47<ch&&ch<58) {x=x*10+ch-48;   ch=getchar();}\n    return sgn? x:-x;\n}\nvoid write(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\nint n,m;\ninline void work() {\n    n=read(); m=read();\n    if(m==1) cout<<0<<endl;\n    else cout<<min(n+1,m)<<endl;\n    for(int i=1; i<=n; ++i) {\n        int del=max(1-i,2-m);\n        for(int u=m-1; u>=0; --u) cout<<(u-del+m)%m<<' ';\n        cout<<endl;\n    }\n}\nsigned main() {\n    // freopen(\"localoutput\",\"w\",stdout);\n    int T=read();\n    while(T--) work();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Fill in the Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/116642",
    "editorial": "On one hand, the matrix M\n has n\n rows, so the maxmium vi\n does not exceed MEX(0,1,?,n?1)=n\n, and s\n does not exceed n+1\n.\n\nOn the other hand, the matrix M\n has m\n columns, and there are only m\n numbers in the array v\n, so s\n must not exceed m\n.\n\nTherefore, the upper bound of s\n is min(n+1,m)\n.\n\nHow can we reach the upper bound?\n\nIf m=1\n, then the only possible M=??????00?0??????\n, in this case, v1=1\n, so s\n must be 0\n, which unfortunately cannot reach the upper bound. Sadly, many participants failed on pretest 2 because of it. I've added this test to examples:)\n\nIf m>1\n, let's construct the M\n in two cases:\n\nCase 1. m?n+1\n.\nIn this case, we can construct M\n like following:\nM=?????????012?n?1123?n?????m?2m?10?n?3m?101?n?2?????????\n\nMore formally, Mi,j=(i+j?1)modm\n.\n\nNote that in this case n?1<m?1\n, so we have v1=n\n, v2=v3=?=vm?n?1=0\n, vm?n=1,vm?n+1=2,?,vm=n?1\n. Then s=n+1\n, which reaches the upper bound.\n\nCase 2. m<n+1\n.\nIn this case, we can construct M\n like following:\nM=????????????????????012?m?200?0123?m?111?1?????????m?2m?10?m?4m?2m?2?m?2m?101?m?3m?1m?1?m?1????????????????????\n\nMore formally, for 1?j?m?1\n, Mi,j=(i+j?1)modm\n, for m?j?n\n, Mi,j=(j?1)modm\n.\n\nNote that m>1\n, and m?2?0\n. Similarly to case 1 we can get s=m\n, which also reaches the upper bound.\n\nTime Complexity: O(n?m)\n per test case.",
    "hint": []
}