{
    "link": "https://codeforces.com//contest/1771/problem/B",
    "problemId": "1688878",
    "problem_idx": "B",
    "shortId": "1771B",
    "contest_number": "1771",
    "problem_submissions": {
        "E": [
            184786252,
            184768319,
            184791269,
            184791695,
            184799239,
            184789827,
            184804872,
            184797015,
            184779796,
            184780579,
            184774488,
            184784737,
            184789324,
            184905669
        ],
        "F": [
            184767458,
            184789428,
            184776697,
            184780762,
            184768498,
            184799203,
            184750590,
            184788854,
            184819486,
            184733731,
            184782224,
            184765553,
            184837754,
            184787637,
            184786087,
            184781451,
            186375922,
            184885288,
            184793012
        ],
        "D": [
            184754420,
            184746285,
            184751879,
            184767199,
            184796187,
            184770689,
            184788363,
            184741723,
            184762124,
            184781810,
            184734475,
            184771306,
            184784877,
            184767214,
            184757752,
            184754682,
            184762986,
            184732202,
            184885253,
            184786038
        ],
        "C": [
            184742304,
            184730753,
            184731670,
            184750562,
            184746404,
            184744176,
            184732056,
            186784755,
            186783506,
            185248092,
            184831291,
            184725362,
            184737633,
            184749397,
            184807012,
            184806808,
            184806589,
            184806495,
            184750795,
            184733621,
            184739758,
            184731026,
            184753323,
            184736577,
            184746147,
            184753799,
            184885221,
            184836201,
            184744786,
            184740528
        ],
        "B": [
            184723301,
            184725456,
            184722508,
            184735259,
            184724915,
            184727876,
            184722523,
            184720717,
            184727802,
            184728402,
            184761586,
            184727553,
            184722898,
            184733183,
            184726202,
            184743742,
            184729968,
            184744730,
            184885179,
            184732333
        ],
        "A": [
            184718639,
            184717667,
            184718126,
            184729979,
            184719322,
            184720803,
            184717674,
            184717800,
            184721090,
            184719864,
            184753140,
            184718839,
            184717731,
            184725439,
            184718841,
            184718297,
            184718595,
            184738977,
            184885137,
            184718315
        ]
    },
    "name": "B. Hossam and Friends",
    "statement": "Hossam makes a big party, and he will invite his friends to the party.He\r\nhas n friends numbered from 1 to n. They will be arranged in a queue as\r\nfollows: 1, 2, 3,\r\nldots, n.Hossam has a list of m pairs of his friends that don\u2019t know\r\neach other. Any pair not present in this list are friends.A subsegment\r\nof the queue starting from the friend a and ending at the friend b is\r\n[a, a + 1, a + 2,\r\nldots, b]. A subsegment of the queue is called when all pairs of that\r\nsegment are friends.Hossam wants to know how many pairs (a, b) there are\r\n(1\r\nle a\r\nle b\r\nle n), such that the subsegment starting from the friend a and ending at\r\nthe friend b is good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\n\n// \u0432\u043f\u0440\u0430\u0432\u043e, \u0432\u043d\u0438\u0437, \u0432\u043b\u0435\u0432\u043e, \u0432\u0432\u0435\u0440\u0445\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\n// \u0445\u043e\u0434 \u043a\u043e\u043d\u0435\u043c\n//int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n//int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::system_clock::now().time_since_epoch().count());\nint rndInteger (int l, int r) {\n    return uniform_int_distribution<int> (l, r)(rnd);\n}\n\nconst int MOD = (int) 998244353;\nconst int N = (int) 1e6 + 7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T;\n    cin >> T;\n    while(T--) {\n        int n, m;\n        cin >> n >> m;\n        vector<int> L(n + 1, 0);\n        for (int i = 0; i < m; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(x > y) swap(x, y);\n            L[y] = max(L[y], x);\n        }\n\n        int cur = 0;\n        ll ans = 0;\n        for (int i = 1; i <= n; ++i) {\n            cur = max(cur, L[i]);\n            ans += i - cur;\n        }\n        cout << ans << '\\n';\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dp",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Hossam and Friends.json",
    "editorial_link": "https://codeforces.com//blog/entry/110092",
    "editorial": "Just in non-friends pairs. Let\u00e2\u0080\u0099s calculate minimum non-friend for all\r\npeople. So, we can\u00e2\u0080\u0099t start subsegment in and finish it righter .Let\u00e2\u0080\u0099s\r\nprocess people from right to left and calculate the rightmost positions\r\nthere subsegment can end. Initially, . Then we go to just do and add to\r\nanswer.\r\n"
}