{"link": "https://codeforces.com//contest/760/problem/E", "problemId": "89820", "problem_idx": "E", "shortId": "760E", "contest_number": "760", "problem_submissions": {"F": [24048996, 24334592, 24109967], "D": [24042480, 24043732, 24050024, 24046176, 24044696, 24045116, 24042014, 24043570, 24047853, 24043885, 24739234, 24045094, 24044167, 24044943, 24049808, 24041812, 24045235], "C": [24040885, 24041111, 24041193, 24043138, 24047007, 24043013, 24038951, 24041237, 24046096, 24041744, 24041798, 24042387, 24042705, 24049213, 24042229, 24044994, 24042730], "B": [24039488, 24039342, 24037031, 24040294, 24041983, 24041211, 24039467, 24039465, 24039319, 24038489, 24040344, 24039097, 24039942, 24040090, 24041062], "A": [24036025, 24035890, 24035872, 24036889, 24036131, 24037811, 24035954, 24036348, 24036507, 24036069, 24036108, 24036146, 24036211, 24041066, 24035881, 24035886, 24036867], "E": [24050782, 24048436, 24049579, 24049178, 24050210, 24052439, 24072140, 24052585, 24324528, 24324402, 24048812, 24049062, 24108774]}, "name": "E. Nikita and stack", "statement": "Nikita has a stack. A stack in this problem is a data structure that\r\nsupports two operations. Operation puts an integer on the top of the\r\nstack, and operation deletes the top integer from the stack, i. e. the\r\nlast added. If the stack is empty, then the operation does\r\nnothing.Nikita made operations with the stack but forgot them. Now\r\nNikita wants to remember them. He remembers them one by one, on the -th\r\nstep he remembers an operation he made -th. In other words, he remembers\r\nthe operations in order of some permutation . After each step Nikita\r\nwants to know what is the integer on the top of the stack after\r\nperforming the operations he have already remembered, in the\r\ncorresponding order. Help him!\r\n", "solutions": ["/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author wcx5tq957i\n */\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n\n#include <iostream>\n#include <cassert>\n#include <set>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nconstexpr int kInf = 1e9;\n\nstruct SegmentTreeBalance {\n\tint size;\n\tvector<int> values, push;\n\n\tSegmentTreeBalance(int initial_size) {\n\t\tsize = initial_size;\n\t\tvalues.assign(4 * size, 0);\n\t\tpush.assign(4 * size, 0);\n\t}\n\n\tvoid do_push(int v) {\n\t\tif (push[v] != 0) {\n\t\t\tpush[v + v] += push[v];\n\t\t\tpush[v + v + 1] += push[v];\n\t\t\tvalues[v + v] += push[v];\n\t\t\tvalues[v + v + 1] += push[v];\n\t\t\tpush[v] = 0;\n\t\t}\n\t}\n\n\tint get(int v, int l, int r, int tl, int tr) {\n\t\tif (l == tl && r == tr) {\n\t\t\treturn values[v];\n\t\t} else {\n\t\t\tdo_push(v);\n\t\t\tint m = (l + r) / 2;\n\t\t\tint result = kInf;\n\t\t\tif (tl <= m)\n\t\t\t\tresult = get(v + v, l, m, tl, min(tr, m));\n\t\t\tif (tr > m)\n\t\t\t\tresult = min(result, get(v + v + 1, m + 1, r, max(m + 1, tl), tr));\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint get(int tl, int tr) {\n\t\treturn get(1, 0, size - 1, tl, tr);\n\t}\n\n\tvoid change(int tl, int tr, int diff) {\n\t\tchange(1, 0, size - 1, tl, tr, diff);\n\t}\n\n\tvoid change(int v, int l, int r, int tl, int tr, int diff) {\n\t\tif (l == tl && r == tr) {\n\t\t\tvalues[v] += diff;\n\t\t\tpush[v] += diff;\n\t\t} else {\n\t\t\tdo_push(v);\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (tl <= m)\n\t\t\t\tchange(v + v, l, m, tl, min(tr, m), diff);\n\t\t\tif (tr > m)\n\t\t\t\tchange(v + v + 1, m + 1, r, max(m + 1, tl), tr, diff);\n\t\t\tvalues[v] = min(values[v + v], values[v + v + 1]);\n\t\t}\n\t}\n};\n\nclass TaskE {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\t\tint operations_count;\n\t\t\tin >> operations_count;\n\t\t\tint numbers_in_stack = 0;\n\n\t\t\tSegmentTreeBalance balances_storage(operations_count);\n\t\t\tvector<int> numbers_storage(operations_count);\n\n\t\t\tset<int> delayed_pops;\n\n\t\t\tauto add_pop = [&](int position) {\n\t\t\t\tif (balances_storage.get(position, operations_count - 1) > 0) {\n\t\t\t\t\tbalances_storage.change(position, operations_count - 1, -1);\n\t\t\t\t\t--numbers_in_stack;\n\t\t\t\t} else {\n\t\t\t\t\tdelayed_pops.insert(position);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tauto first_larger = [&](int k) {\n\t\t\t\tint l = -1, r = operations_count;\n\t\t\t\twhile (r - l > 1) {\n\t\t\t\t\tint m = (l + r) / 2;\n\t\t\t\t\tif (balances_storage.get(m, operations_count - 1) >= k) {\n\t\t\t\t\t\tr = m;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl = m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t};\n\n\t\t\tauto add_push = [&](int position, int value) {\n\t\t\t\tbalances_storage.change(position, operations_count - 1, 1);\n\t\t\t\tnumbers_storage[position] = value;\n\t\t\t\t++numbers_in_stack;\n\n\t\t\t\tposition = first_larger(1);\n\t\t\t\tif (position != operations_count) {\n\t\t\t\t\tauto it = delayed_pops.lower_bound(position);\n\t\t\t\t\tif (it != delayed_pops.end()) {\n\t\t\t\t\t\tposition = *it;\n\t\t\t\t\t\tbalances_storage.change(position, operations_count - 1, -1);\n\t\t\t\t\t\tdelayed_pops.erase(it);\n\t\t\t\t\t\t--numbers_in_stack;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tauto get_last = [&]() {\n\t\t\t\tint r = first_larger(numbers_in_stack);\n\t\t\t\tassert(balances_storage.get(r, operations_count - 1) >= numbers_in_stack);\n\t\t\t\treturn numbers_storage[r];\n\t\t\t};\n\n\t\t\tauto get_answer = [&]() {\n\t\t\t\tif (numbers_in_stack == 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn get_last();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (int i = 0; i < operations_count; i++) {\n\t\t\t\tint position;\n\t\t\t\tin >> position;\n\t\t\t\t--position;\n\t\t\t\tint type;\n\t\t\t\tin >> type;\n\t\t\t\tif (type == 0) {\n\t\t\t\t\t// pop\n\t\t\t\t\tadd_pop(position);\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tassert(type == 1);\n\t\t\t\t\tint value;\n\t\t\t\t\tin >> value;\n\t\t\t\t\tadd_push(position, value);\n\t\t\t\t}\n\t\t\t\tout << get_answer() << \"\\n\";\n\t\t\t}\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2200", "interactive": false}