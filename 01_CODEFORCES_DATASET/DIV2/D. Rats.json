{
    "link": "https://codeforces.com//contest/254/problem/D",
    "problemId": "2367",
    "problem_idx": "D",
    "shortId": "254D",
    "contest_number": "254",
    "problem_submissions": {
        "E": [
            2740484,
            2741271,
            2740417,
            2740877,
            2741373,
            2743269,
            2742126,
            2743266,
            2745430,
            2771923
        ],
        "C": [
            2738508,
            2738068,
            2738593,
            2735008,
            2736528,
            2736699,
            2737568,
            2737352,
            2745595,
            2738018,
            2737726,
            2737295,
            2738342,
            2738512,
            2737959,
            2737102,
            2738365,
            2738534,
            2738009
        ],
        "B": [
            2737079,
            2736879,
            2739133,
            2735037,
            2735572,
            2735546,
            2736025,
            2736861,
            2735717,
            2735630,
            2736253,
            2735557,
            2735277,
            2736333,
            2737859,
            2735812,
            2735603,
            2735733
        ],
        "A": [
            2736146,
            2734462,
            2734865,
            2741112,
            2734113,
            2735132,
            2734336,
            2735192,
            2735720,
            2734351,
            2734166,
            2734512,
            2734291,
            2734207,
            2734482,
            2734395,
            2734573,
            2734246,
            2734420
        ],
        "D": [
            2743106,
            2742423,
            2742158,
            2746535,
            2743203
        ]
    },
    "name": "D. Rats",
    "statement": "Rats have bred to hundreds and hundreds in the basement of the store,\r\nowned by Vasily Petrovich. Vasily Petrovich may have not noticed their\r\npresence, but they got into the habit of sneaking into the warehouse and\r\nstealing food from there. Vasily Petrovich cannot put up with it\r\nanymore, he has to destroy the rats in the basement. Since mousetraps\r\nare outdated and do not help, and rat poison can poison inattentive\r\npeople as well as rats, he chose a radical way: to blow up two grenades\r\nin the basement (he does not have more).In this problem, we will present\r\nthe shop basement as a rectangular table of cells. Some of the cells are\r\noccupied by walls, and the rest of them are empty. Vasily has been\r\nwatching the rats and he found out that at a certain time they go to\r\nsleep, and all the time they sleep in the same places. He wants to blow\r\nup a grenade when this convenient time comes. On the plan of his\r\nbasement, he marked cells with sleeping rats in them. Naturally, these\r\ncells are not occupied by walls.Grenades can only blow up in a cell that\r\nis not occupied by a wall. The blast wave from a grenade distributes as\r\nfollows. We assume that the grenade blast occurs at time 0. During this\r\ninitial time only the cell where the grenade blew up gets \u2019clear\u2019. If at\r\ntime some cell is clear, then at time those side-neighbouring cells\r\nwhich are not occupied by the walls get clear too (some of them could\r\nhave been cleared before). The blast wave distributes for exactly\r\nseconds, then it dies immediately. Vasily Petrovich wonders, whether he\r\ncan choose two cells to blast the grenades so as to clear all cells with\r\nsleeping rats. Write the program that finds it out.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nconst int N = 1005;\ntypedef pair<int,int> per;\n#define mp(x,y) make_pair(x,y)\nvector<per>E;\nchar g[N][N];\nint dep[N][N],dd[N][N];\nint cr[N][N],flag,cnt,n,m;\nint c[4][2]={1,0,0,1,-1,0,0,-1};\nper q[N*N];\nvoid bfs(int sx,int sy,int d,int z)\n{\n    int t=0,w=1;\n    q[0]=mp(sx,sy);\n    dep[sx][sy]=0;\n    cr[sx][sy]++;\n    while(t<w)\n    {\n        int x=q[t].first,y=q[t].second;\n        if(dep[x][y]==d)break;\n        t++;\n        for(int i=0;i<4;i++)\n        {\n            int x1=c[i][0]+x;\n            int y1=c[i][1]+y;\n            if(x1>=0&&y1>=0&&x1<m&&y1<n&&g[x1][y1]!='X'&&dep[x1][y1]==-1)\n            {\n                dep[x1][y1]=dep[x][y]+1;\n                cr[x1][y1]++;\n                q[w++]=mp(x1,y1);\n            }\n        }\n    }\n    if(!z)\n    {\n        for(int i=0;i<w;i++)\n        {\n            //printf(\"i:%d x:%d y:%d \\n\",i,q[i].first,q[i].second);\n            dep[q[i].first][q[i].second]=-1;\n        }\n    }\n}\nvoid bbfs(int sx1,int sy1,int sx2,int sy2,int d)\n{\n    int t=0,w=2,tmp=0;\n    q[0]=mp(sx1,sy1);\n    q[1]=mp(sx2,sy2);\n    dep[sx1][sy1]=dep[sx2][sy2]=0;\n    while(t<w)\n    {\n        int x=q[t].first,y=q[t].second;\n        if(dep[x][y]==d)break;\n        t++;\n        for(int i=0;i<4;i++)\n        {\n            int x1=c[i][0]+x;\n            int y1=c[i][1]+y;\n            if(x1>=0&&y1>=0&&x1<m&&y1<n&&g[x1][y1]!='X'&&dep[x1][y1]==-1)\n            {\n                dep[x1][y1]=dep[x][y]+1;\n                cr[x1][y1]++;\n                q[w++]=mp(x1,y1);\n            }\n        }\n    }\n    for(int i=0;i<w;i++)\n        {\n            if(g[q[i].first][q[i].second]=='R')tmp++;\n            //printf(\"i:%d x:%d y:%d \\n\",i,q[i].first,q[i].second);\n            dep[q[i].first][q[i].second]=-1;\n        }\n    //printf(\"sx1:%d sy1:%d sx2:%d sy2:%d tmp:%d cnt:%d \\n\",sx1,sy1,sx2,sy2,tmp,cnt);\n    if(tmp==cnt)flag=1;\n}\nvoid check(int d)\n{\n    int i,j,sx,sy;\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            if(g[i][j]=='R')\n            {\n                sx=i;\n                sy=j;\n                i=m;\n                break;\n            }\n        }\n    }\n    bfs(sx,sy,d+d,1);   \n    for(i=0;i<m;i++)for(j=0;j<n;j++)dd[i][j]=dep[i][j];\n    memset(dep,-1,sizeof(dep));\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            if(g[i][j]=='R'&&dd[i][j]==-1)\n            {\n                sx=i;\n                sy=j;\n                i=m;\n                break;\n            }\n        }\n    }\n    bfs(sx,sy,d+d,1);\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            if(g[i][j]=='R'&&dd[i][j]==-1&&dep[i][j]==-1)flag=1;\n        }\n    }\n}\nint main()\n{\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    memset(dep,-1,sizeof(dep));\n    int d,i,j;\n    scanf(\"%d%d%d\",&m,&n,&d);\n    for(i=0;i<m;i++)scanf(\"%s\",g[i]);\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)if(g[i][j]=='R')cnt++;\n    }\n    flag=0;\n    check(d);\n    if(flag)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    //printf(\"flag:%d \\n\",flag);\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            if((dd[i][j]!=-1||dep[i][j]!=-1)&&g[i][j]!='X')\n            {\n            //  printf(\"i:%d j:%d \\n\",i,j);\n                E.push_back(mp(i,j));\n            }\n        }\n    }\n        int k=E.size();\n    if(k==1)\n    {\n        for(i=0;i<m;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n                if(g[i][j]=='.')\n                {\n                    printf(\"%d %d \",i+1,j+1);\n                    i=m;j=n;\n                }\n            }\n        }\n        printf(\"%d %d\\n\",E[0].first+1,E[0].second+1);\n        return 0;\n    }\n    memset(dep,-1,sizeof(dep));\n    flag=0;\n    for(i=0;i<k&&!flag;i++)\n    {\n        for(j=i+1;j<k&&!flag;j++)\n        {\n            bbfs(E[i].first,E[i].second,E[j].first,E[j].second,d);\n            if(flag)\n            {\n                printf(\"%d %d %d %d\\n\",E[i].first+1,E[i].second+1,E[j].first+1,E[j].second+1);\n            }\n        }\n    }\n    if(!flag)puts(\"-1\");\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Rats.json",
    "editorial_link": "https://codeforces.com//blog/entry/6085",
    "editorial": "Choose arbitrary rat (for say, the leftmost of the upmost). It\u00e2\u0080\u0099s cell\r\nshould be cleared. Make a BFS that never goes further than from this\r\ncell (we will call such a BFS by d-BFS). It will visit approximately\r\ncells in the worst case. So, we have to blow the first grenade in one of\r\nthe visited cells. Lets check every visited cell as a candidate. Make a\r\nd-BFS from the candidate cell. Some cells with the rats will not be\r\nvisited. That means that they should be cleared by the second grenade.\r\nChoose arbitrary cell with a rat that was not cleared by the first\r\ngrenade. Make a d-BFS from it. All cells visited by this BFS are\r\ncandidates to blow the second grenade. Lets check every such cell.\r\nChecking a cell again means making a d-BFS from it. If this BFS visits\r\nall cells that were not cleared by the first grenade, that we have found\r\na solution. As every d-BFS visits at most , the overall number of steps\r\nis approximately .\r\n"
}