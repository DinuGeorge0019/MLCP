{
    "link": "https://codeforces.com//contest/1325/problem/E",
    "problemId": "561457",
    "problem_idx": "E",
    "shortId": "1325E",
    "contest_number": "1325",
    "problem_submissions": {
        "E": [
            73269401,
            73332152,
            73299753,
            73395378,
            73360091,
            73360008
        ],
        "F": [
            73248978,
            73251409,
            73254927,
            73256076,
            73255610,
            73257423,
            73262364,
            73259512,
            73356282,
            73356144,
            73263300,
            73263158,
            73261258,
            73265350,
            73262400,
            73265312,
            73263991,
            73268889,
            73270937
        ],
        "D": [
            73244100,
            73243574,
            73240330,
            73242761,
            73241884,
            73241409,
            73246071,
            73252259,
            73251009,
            73248948,
            73245139,
            73243278,
            73250903,
            73243449,
            73248645,
            73246841,
            73242067
        ],
        "C": [
            73236055,
            73236410,
            73233326,
            73229143,
            73233805,
            73246561,
            73234913,
            73236946,
            73236155,
            73241716,
            73237967,
            73239330,
            73240506,
            73236929,
            73231917,
            73233819,
            73237479
        ],
        "B": [
            73227966,
            73225855,
            73227806,
            73223000,
            73224291,
            73227411,
            73226586,
            73225151,
            73229505,
            73230477,
            73228144,
            73229165,
            73230081,
            73251563,
            73223597,
            73227071,
            73225379
        ],
        "A": [
            73222798,
            73222976,
            73224188,
            73222275,
            73222466,
            73223833,
            73222584,
            73222533,
            73226908,
            73225662,
            73224126,
            73224793,
            73228118,
            73227876,
            73225812,
            73222400,
            73222615
        ]
    },
    "name": "E. Ehab s REAL Number Theory Problem",
    "statement": "You are given an array a of length n that has a special condition: every\r\nelement in this array has at most 7 divisors. Find the length of the\r\nshortest non-empty subsequence of this array product of whose elements\r\nis a perfect square.A sequence a is a subsequence of an array b if a can\r\nbe obtained from b by deletion of several (possibly, zero or all)\r\nelements.\r\n",
    "solutions": [
        "///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 1e6+10;\nconst int mod = 1e9+7;\nconst int inf = 1e9+10;\nconst int N = 80010;\n\nint n, m;\nvector<int> g[N];\n\nint bfs(int s)\n{\n    int dis[N], mark[N], par[N];\n    memset(mark, 0, sizeof mark);\n    queue<int> q;\n\n    dis[s] = 0;\n    mark[s] = 1;\n    q.push(s);\n    bool X = 0;\n    int ans = inf;\n    while(q.size())\n    {\n        int v = q.front();\n        q.pop();\n        for(auto u : g[v])\n            if(!mark[u])\n            {\n                mark[u] = 1;\n                dis[u] = dis[v] + 1;\n                par[u] = v;\n                q.push(u);\n            }\n            else\n                if(u != par[v] && !X)\n                {\n                    ans = min(ans, dis[v]+dis[u]+1);\n                    X = 1;\n                }\n    }\n    return ans;\n}\n\nbool av[maxn];\nvector<int> pr[maxn];\nint mp[maxn], a[maxn];\n\nint num(int x, int p)\n{\n    int cnt = 0;\n    int X = x;\n    while(x % p == 0)\n    {\n        cnt++;\n        x /= p;\n    }\n    if(!(cnt&1)) return x;\n    return X;\n}\n\nset<pair<int,int>> edge;\n\nsigned main()\n{\n    //ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n\n    int last = 0;\n    for(int i = 2; i < maxn; i++)\n        if(!av[i])\n        {\n            last++; mp[i] = last;\n            for(int j = 2*i; j < maxn; j += i)\n            {\n                pr[j].push_back(i);\n                av[j] = 1;\n            }\n            pr[i].push_back(i);\n        }\n    last++;\n\n    bool T = 0;\n    for(int i = 1, x; i <= n; i++)\n    {\n        cin>> x;\n        for(auto p : pr[x])\n            x = num(x,p);\n\n        if(pr[x].size() == 2)\n        {\n            if(edge.count({mp[pr[x][1]], mp[pr[x][0]]}))\n                T = 1;\n\n            g[mp[pr[x][0]]].push_back(mp[pr[x][1]]);\n            g[mp[pr[x][1]]].push_back(mp[pr[x][0]]);\n\n            edge.insert({mp[pr[x][1]], mp[pr[x][0]]});\n            edge.insert({mp[pr[x][0]], mp[pr[x][1]]});\n        }\n\n        if(pr[x].size() == 1)\n        {\n            if(edge.count({last,mp[pr[x][0]]}))\n                T = 1;\n\n            g[last].push_back(mp[pr[x][0]]);\n            g[mp[pr[x][0]]].push_back(last);\n\n            edge.insert({last,mp[pr[x][0]]});\n        }\n\n        if(x == 1)\n            return cout<< 1, 0;\n    }\n\n    if(T) return cout<< 2, 0;\n\n    int cyc = inf;\n    for(int i = 1; i <= 1010; i++)\n        cyc = min(cyc, bfs(mp[i]));\n    cyc = min(cyc,bfs(last));\n\n    if(cyc == inf) cout<< -1;\n    else cout<< cyc;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "number theory",
        "shortest paths"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ehab s REAL Number Theory Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/74235",
    "editorial": "Notice that for each element in the array, if some perfect square\r\ndivides it, you can divide it by that perfect square, and the problem\r\nwon\u00e2\u0080\u0099t change. Let\u00e2\u0080\u0099s define normalizing a number as dividing it by\r\nperfect squares until it doesn\u00e2\u0080\u0099t contain any. Notice than any number\r\nthat has 3 different prime divisors has at least 8 divisors, so after\r\nnormalizing any element in the array, it will be , , or for some primes\r\nand . Let\u00e2\u0080\u0099s create a graph where the vertices are the prime numbers (and\r\n,) and the edges are the elements of the array. For each element, we\u00e2\u0080\u0099ll\r\nconnect and (or and if it\u00e2\u0080\u0099s a prime after normalizing, or with if it\u00e2\u0080\u0099s\r\nafter normalizing.) What\u00e2\u0080\u0099s the significance of this graph? Well, if you\r\ntake any walk from node to node , multiply the elements on the edges you\r\ntook, and normalize, the product you get will be ! That\u00e2\u0080\u0099s because every\r\nnode in the path will be visited an even number of times, except and .\r\nSo the shortest subsequence whose product is a perfect square is just\r\nthe shortest cycle in this graph! The shortest cycle in an arbitrary\r\ngraph takes to compute: you take every node as a source and calculate\r\nthe bfs tree, then you look at the edges the go back to the root to\r\nclose the cycle. That only finds the shortest cycle if the bfs source is\r\ncontained in one. The graph in this problem has a special condition: you\r\ncan\u00e2\u0080\u0099t connect 2 nodes with indices greater than . That\u00e2\u0080\u0099s because their\r\nproduct would be greater than . So that means ANY walk in this graph has\r\na node with index . You can only try these nodes as sources for your\r\nbfs. Code link: https://pastebin.com/4ixLQyvg Bonus task: try to prove\r\nthe answer can\u00e2\u0080\u0099t exceed .\r\n"
}