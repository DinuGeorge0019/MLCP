{
    "link": "https://codeforces.com//contest/1820/problem/D",
    "problemId": "1880612",
    "problem_idx": "D",
    "shortId": "1820D",
    "contest_number": "1820",
    "problem_submissions": {
        "E": [
            202221495,
            202224197,
            202223650,
            202221055,
            202211278,
            202210773,
            202210525,
            202392193,
            202234544,
            202241741
        ],
        "D": [
            202204493,
            202203834,
            202204941,
            202200357,
            202224521,
            202196714,
            202201649,
            202201288,
            202205548,
            202208808,
            202207552,
            202206152,
            202208768,
            202210206,
            202204088,
            202209173,
            202204193,
            202208143
        ],
        "C": [
            202188210,
            202190438,
            202191871,
            202204067,
            202186370,
            202194680,
            202193928,
            202184998,
            202190422,
            202190852,
            202188780,
            202191686,
            202189589,
            202189497,
            202191313,
            202189933,
            202193203,
            202191781,
            202192559,
            202193037
        ],
        "B": [
            202184059,
            202186314,
            202188694,
            202185290,
            202181971,
            202185877,
            202195824,
            202184988,
            202186184,
            202184424,
            202184282,
            202185384,
            202184368,
            202185406,
            202183611,
            202187273,
            202187259,
            202188101,
            202186319
        ],
        "A": [
            202181070,
            202181088,
            202184573,
            202180673,
            202180868,
            202181103,
            202180754,
            202181157,
            202181299,
            202180503,
            202180966,
            202180804,
            202180777,
            202180572,
            202180527,
            202180589,
            202182901,
            202184035,
            202181508
        ],
        "F": [
            202489739,
            202420015
        ]
    },
    "name": "D. The Butcher",
    "statement": "Anton plays his favorite game \"Defense of The Ancients 2\" for his\r\nfavorite hero The Butcher. Now he wants to make his own dinner. To do\r\nthis he will take a rectangle of height h and width w, then make a\r\nvertical or horizontal cut so that both resulting parts have integer\r\nsides. After that, he will put one of the parts in the box and cut the\r\nother again, and so on.More formally, a rectangle of size h\r\ntimes w can be cut into two parts of sizes x\r\ntimes w and (h - x)\r\ntimes w, where x is an integer from 1 to (h - 1), or into two parts of\r\nsizes h\r\ntimes y and h\r\ntimes (w - y), where y is an integer from 1 to (w - 1).He will repeat\r\nthis operation n - 1 times, and then put the remaining rectangle into\r\nthe box too. Thus, the box will contain n rectangles, of which n - 1\r\nrectangles were put in the box as a result of the cuts, and the n-th\r\nrectangle is the one that the Butcher has left after all n - 1\r\ncuts.Unfortunately, Butcher forgot the numbers h and w, but he still has\r\nn rectangles mixed in random order. Note that Butcher , but only\r\nshuffled them. Now he wants to know all possible pairs (h, w) from which\r\nthis set of rectangles can be obtained. And you have to help him do\r\nit!It is guaranteed that there exists at least one pair (h, w) from\r\nwhich this set of rectangles can be obtained.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FORI(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n \nmt19937 rnd(time(0));\n\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define endl '\\n'\n\n#define mp(m, n) make_pair((m), (n))\n \ntemplate<typename T>\nvoid read(vector<T> &t) {FOR(i, t.size()) {cin >> t[i];}}\ntemplate<typename T> string tostring(T a) { istringstream sin; sin >> a; return sin.str(); }\n \n// #define DEBUG\n \n#ifdef DEBUG\ntemplate<typename T>\nvoid _debug(string s, T x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, unordered_map<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \":\" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, map<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \":\" << it->second;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, set<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, vector<pair<T, K> > x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \",\" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, pair<T, K> x) {\n    cerr << s << \": \" << x.first << \",\" << x.second << endl;\n}\n \nvoid _debug(string s, int x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, long long x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, double x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, string x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, char x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, size_t x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, bool x) {\n    cerr << s << \": \" << x << endl;\n}\n \n#define debug(x) _debug(#x, (x))\n#else\n#define debug(x)\n#endif\n \n#define db debug\n\ntemplate <class T>\nvoid print(vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        cout << v[i];\n        if (i == v.size() - 1) {\n            cout << endl;\n        } else {\n            cout << \" \";\n        }\n    }\n}\n\nvoid solve();\n \nvoid pre_init();\n\nint main() {\n    ios_base::sync_with_stdio(false); std::cin.tie(0);\n    pre_init();\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}\n \nvoid pre_init() {}\n\npair<ll, ll> solve(vector<pair<ll, ll> > vp) {\n    ll max_l = 0;\n    ll area = 0;\n    for (int i = 0; i < vp.size(); i++) {\n        max_l = max(max_l, vp[i].first);\n        area += vp[i].first * vp[i].second;\n    }\n    if (area % max_l != 0) {\n        return {-1, -1};\n    }\n    \n    ll l = max_l, r = area / l;\n    ll lll = l, rrr = r;\n    int lx = 1;\n    vector<bool> used(vp.size());\n    map<ll, vector<int> > lmap, rmap;\n    for (int i = 0; i < vp.size(); i++) {\n        lmap[vp[i].first].push_back(i);\n        rmap[vp[i].second].push_back(i);\n    }\n    debug(lll);\n    debug(rrr);\n    \n    while (l > 0 && r > 0) {\n        bool change = false;\n        if (lx) {\n            for (int x = 0; x < lmap[l].size(); x++) {\n                int idx = lmap[l][x];\n                if (!used[idx]) {\n                    used[idx] = 1;\n                    r-= vp[idx].second;\n                    change = true;\n                } else {\n                    \n                }\n            }\n        } else {\n            debug(rmap[r]);\n            for (int x = 0; x < rmap[r].size(); x++) {\n                int idx = rmap[r][x];\n                if (!used[idx]) {\n                    used[idx] = 1;\n                    l -= vp[idx].first;\n                    change = true;\n                } else {\n                    \n                }\n            }\n        }\n        debug(change);\n        if (!change) {\n            return {-1, -1};\n        }\n        lx = 1 - lx;\n    }\n    return {lll, rrr};\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<pair<ll, ll> > vp(n);\n    for (int i = 0; i < n; i++) {\n        cin >> vp[i].first >> vp[i].second;\n    }\n    set<pair<ll, ll> > s;\n    auto x = solve(vp);\n    if (x.first >= 0) s.insert(x);\n\n    for (int i = 0; i < n; i++) {\n        swap(vp[i].first, vp[i].second);\n    }\n    auto y = solve(vp);\n    if (y.first >= 0) s.insert({y.second, y.first});\n    cout << s.size() << endl;\n    for (auto x : s) {\n        cout << x.first << \" \" << x.second << endl;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Butcher.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "Note that we know the area of the original rectangle. This value can be calculated as the sum of the areas of the given rectangles. Now let's consider two similar cases: the first cut was horizontal or the first cut was vertical. We will present the solution for the first case, the second one is considered similarly.\n\nIf the first cut was horizontal, then there exists a rectangle which width is equal to the width of the entire original rectangle. Moreover, it's easy to notice that this is a rectangle with the maximum width. Knowing the width and area, we also know the height of the rectangle we need. The only thing left is to come up with an algorithm that, for given h\n and w\n, tells us whether it is possible to construct a rectangle with such dimensions.\n\nWe will perform the following procedure: let us have a rectangle {h?,w?}\n for which h?=h\n or w?=w\n holds, and cut off our current rectangle with the rectangle {h?,w?}\n. Formally, if w?=w\n, we will make h?=h?\n, if h=h?\n, we will make w?=w?\n. Note that this greedy algorithm is correct, since at each iteration we performed either a horizontal cut or a vertical cut. Thus, at each iteration of our algorithm, we should have only one option: to remove some rectangle corresponding to a vertical cut or to remove a rectangle corresponding to a horizontal cut. We can choose any of these rectangles.\n\nHaving performed this algorithm in the case where the first cut was vertical and in the case where the first cut was horizontal, we will check both potential answers.",
    "hint": []
}