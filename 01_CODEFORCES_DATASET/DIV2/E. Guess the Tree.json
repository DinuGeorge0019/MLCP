{"link": "https://codeforces.com//contest/430/problem/E", "problemId": "9401", "problem_idx": "E", "shortId": "430E", "contest_number": "430", "problem_submissions": {"E": [6596209, 6601239, 6595457, 6596869, 6611998], "C": [6593903, 6589689, 6590185, 6591146, 6594509, 6591043, 6594881, 6592145, 6591439, 6590916, 6592010, 6592041, 6592596, 6592644, 6593233, 6592230, 6592515, 6591488, 6591864], "D": [6592681, 6591086, 6597590, 6592274, 6591820, 6594037, 6592628, 6594400, 6599564, 6594397, 6596203, 6595708, 6594744, 6595014, 6595972, 6596088, 6594380, 6593712, 6595433], "B": [6591917, 6588904, 6589347, 6590112, 6589136, 6589725, 6590062, 6590923, 6589922, 6588990, 6590100, 6590128, 6591019, 6591186, 6590471, 6590715, 6590194, 6589294, 6593720], "A": [6588412, 6588136, 6588222, 6588465, 6590072, 6588672, 6588238, 6589003, 6588856, 6595945, 6588333, 6588427, 6589419, 6589285, 6588864, 6589371, 6595841, 6600698, 6589758]}, "name": "E. Guess the Tree", "statement": "Iahub and Iahubina went to a picnic in a forest full of trees. Less than\r\n5 minutes passed before Iahub remembered of trees from programming.\r\nMoreover, he invented a new problem and Iahubina has to solve it,\r\notherwise Iahub won\u2019t give her the food. Iahub asks Iahubina: can you\r\nbuild a rooted tree, such that each internal node (a node with at least\r\none son) has at least two sons; node has nodes in its subtree? Iahubina\r\nhas to guess the tree. Being a smart girl, she realized that it\u2019s\r\npossible no tree can follow Iahub\u2019s restrictions. In this way, Iahub\r\nwill eat all the food. You need to help Iahubina: determine if there\u2019s\r\nat least one tree following Iahub\u2019s restrictions. .\r\n", "solutions": ["/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem E\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 30;\n\nint n, top;\nint size[MAXN], cnt[MAXN], c[MAXN];\nbool ans;\n\nvoid dfs1(int);\n\nvoid dfs2(int cur, int now, int rest, int tot) {\n    if (rest == 0) {\n        if (tot < 2) return;\n        if (size[top] == c[cur]) cnt[top]++;\n        else ++top, size[top] = c[cur], cnt[top] = 1;\n        dfs1(cur + 1);\n    }\n    else {\n        if (now > top) return;\n        if (size[now] > rest) return;\n        for (int i = now; i <= top; i++) {\n            for (int j = 1; j <= cnt[i] && j * size[i] <= rest; j++) {\n                cnt[i] -= j;\n                dfs2(cur, i + 1, rest - j * size[i], tot + j);\n                if (ans) return;\n                cnt[i] += j;\n            }\n        }\n    }\n}\n\nvoid dfs1(int i) {\n    if (i > n) {\n        ans = 1;\n        return;\n    }\n//    pf(\"dfs %d:\\n\", c[i]);\n//    rep (j, 1, top) pf(\"%d %d\\n\", size[j], cnt[j]);\n    dfs2(i, 1, c[i] - 1, 0);\n}\n\nint main() {\n    R(n);\n    rep (i, 1, n) R(c[i]);\n    sort(c + 1, c + 1 + n);\n    if (c[n] != n) pf(\"NO\\n\");\n    else {\n        int st = 1;\n        top = 1;\n        size[1] = 1;\n        cnt[1] = 0;\n        while (c[st] == 1) st++, cnt[1]++;\n        ans = 0;\n        dfs1(st);\n        if (ans) pf(\"YES\\n\");\n        else pf(\"NO\\n\");\n    }\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dfs and similar"], "dificulty": "2300", "interactive": false}