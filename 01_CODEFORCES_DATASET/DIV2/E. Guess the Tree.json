{
    "link": "https://codeforces.com//contest/430/problem/E",
    "problemId": "9401",
    "problem_idx": "E",
    "shortId": "430E",
    "contest_number": "430",
    "problem_submissions": {
        "E": [
            6596209,
            6601239,
            6595457,
            6596869,
            6611998
        ],
        "C": [
            6593903,
            6589689,
            6590185,
            6591146,
            6594509,
            6591043,
            6594881,
            6592145,
            6591439,
            6590916,
            6592010,
            6592041,
            6592596,
            6592644,
            6593233,
            6592230,
            6592515,
            6591488,
            6591864
        ],
        "D": [
            6592681,
            6591086,
            6597590,
            6592274,
            6591820,
            6594037,
            6592628,
            6594400,
            6599564,
            6594397,
            6596203,
            6595708,
            6594744,
            6595014,
            6595972,
            6596088,
            6594380,
            6593712,
            6595433
        ],
        "B": [
            6591917,
            6588904,
            6589347,
            6590112,
            6589136,
            6589725,
            6590062,
            6590923,
            6589922,
            6588990,
            6590100,
            6590128,
            6591019,
            6591186,
            6590471,
            6590715,
            6590194,
            6589294,
            6593720
        ],
        "A": [
            6588412,
            6588136,
            6588222,
            6588465,
            6590072,
            6588672,
            6588238,
            6589003,
            6588856,
            6595945,
            6588333,
            6588427,
            6589419,
            6589285,
            6588864,
            6589371,
            6595841,
            6600698,
            6589758
        ]
    },
    "name": "E. Guess the Tree",
    "statement": "Iahub and Iahubina went to a picnic in a forest full of trees. Less than\r\n5 minutes passed before Iahub remembered of trees from programming.\r\nMoreover, he invented a new problem and Iahubina has to solve it,\r\notherwise Iahub won’t give her the food. Iahub asks Iahubina: can you\r\nbuild a rooted tree, such that each internal node (a node with at least\r\none son) has at least two sons; node has nodes in its subtree? Iahubina\r\nhas to guess the tree. Being a smart girl, she realized that it’s\r\npossible no tree can follow Iahub’s restrictions. In this way, Iahub\r\nwill eat all the food. You need to help Iahubina: determine if there’s\r\nat least one tree following Iahub’s restrictions. .\r\n",
    "solutions": [
        "/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem E\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 30;\n\nint n, top;\nint size[MAXN], cnt[MAXN], c[MAXN];\nbool ans;\n\nvoid dfs1(int);\n\nvoid dfs2(int cur, int now, int rest, int tot) {\n    if (rest == 0) {\n        if (tot < 2) return;\n        if (size[top] == c[cur]) cnt[top]++;\n        else ++top, size[top] = c[cur], cnt[top] = 1;\n        dfs1(cur + 1);\n    }\n    else {\n        if (now > top) return;\n        if (size[now] > rest) return;\n        for (int i = now; i <= top; i++) {\n            for (int j = 1; j <= cnt[i] && j * size[i] <= rest; j++) {\n                cnt[i] -= j;\n                dfs2(cur, i + 1, rest - j * size[i], tot + j);\n                if (ans) return;\n                cnt[i] += j;\n            }\n        }\n    }\n}\n\nvoid dfs1(int i) {\n    if (i > n) {\n        ans = 1;\n        return;\n    }\n//    pf(\"dfs %d:\\n\", c[i]);\n//    rep (j, 1, top) pf(\"%d %d\\n\", size[j], cnt[j]);\n    dfs2(i, 1, c[i] - 1, 0);\n}\n\nint main() {\n    R(n);\n    rep (i, 1, n) R(c[i]);\n    sort(c + 1, c + 1 + n);\n    if (c[n] != n) pf(\"NO\\n\");\n    else {\n        int st = 1;\n        top = 1;\n        size[1] = 1;\n        cnt[1] = 0;\n        while (c[st] == 1) st++, cnt[1]++;\n        ans = 0;\n        dfs1(st);\n        if (ans) pf(\"YES\\n\");\n        else pf(\"NO\\n\");\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Guess the Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "The constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problems restriction more carefully.\n\nThe problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. Well proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Lets assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n  1. So it has at least (n + k  1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs.\n\nFor n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i  1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they cant be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we wont have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when its processed, it wont have in future either. If it has, the tree is connected so far, so we add children of i.\n\nLets introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes dont have one and internal nodes corresponding to 1 in bitmask mask also dont have one? If you never heart about bitmask word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree cant be built. Otherwise, lets assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node]  S  1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we cant build the tree. Will remain obviously leafs  L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs  L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we cant.\n\nLets analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:\n\n0 if bit does not appear in mask\n\n1 if bit appears in mask but not in submask\n\n2 if bit appears in mask and in submask\n\nObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2).",
    "hint": []
}