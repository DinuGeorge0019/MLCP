{
    "link": "https://codeforces.com//contest/2049/problem/F",
    "problemId": "3095890",
    "problem_idx": "F",
    "shortId": "2049F",
    "contest_number": "2049",
    "problem_submissions": {
        "E": [
            297497545,
            297506248,
            297513363,
            297497215,
            297513754,
            297518565,
            297506722,
            297520708,
            297488887,
            297517677,
            297529325,
            297517116,
            297526566,
            297525983,
            297522466,
            297519909,
            297520752
        ],
        "D": [
            297483631,
            297479906,
            297485869,
            297513484,
            297488988,
            297486425,
            297485532,
            297485220,
            297484984,
            297500489,
            297482945,
            297486674,
            297499534,
            297487140,
            297494415,
            297499648,
            297503839,
            297506419
        ],
        "C": [
            297476672,
            297469506,
            297476237,
            297468134,
            297474308,
            297470523,
            297476380,
            297473582,
            297506923,
            297485541,
            297473126,
            297478801,
            297475763,
            297482532,
            297481819,
            297486746,
            297475914
        ],
        "B": [
            297470859,
            297460761,
            297460293,
            297459118,
            297463641,
            297461216,
            297463086,
            297463837,
            297473641,
            297462725,
            297462885,
            297469778,
            297465587,
            297460737,
            297466206,
            297472797,
            297465768
        ],
        "A": [
            297458727,
            297456975,
            297457057,
            297457132,
            297458401,
            297457465,
            297458903,
            297458352,
            297460231,
            297458345,
            297457970,
            297457220,
            297457772,
            297457523,
            297459233,
            297459057,
            297457136
        ],
        "F": [
            299863982,
            297606792
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137273",
    "editorial": "Letâs figure out when a sequence is good. Let be the maximum element of\r\nthe sequence. Notice that the bitwise OR of the sequence is at least and\r\nas MEX OR , that means MEX has to be at least . Which means all elements\r\nfrom to has to be present in the sequence. As MEX canât be greater than\r\n, the MEX has to be exactly . Now we need to check for which the bitwise\r\nOR of the elements from to is exactly . Itâs not hard to see that this\r\nis true for for some integer . The reason is that all bits from to have\r\nto be set in for the OR to be and itâs only possible if is of the form .\r\nSo, a sequence is good if the maximum element is for some integer and\r\nall elements from to are present in the sequence. Now, letâs see how to\r\nanswer the queries without any updates. To find the longest good\r\nsubarray, we can use a two-pointers approach. But a better way to do\r\nthis is to fix the power and find the longest good subarray with maximum\r\nelement . To do this, ignore the elements greater than and then split\r\nthe array into segments of consecutive numbers where each segment has\r\nelements from to . To check if a segment is good, we can track the\r\nnumber of distinct elements in the segment. If the number of distinct\r\nelements is , then the segment is good. So to sum it up, for each power\r\n, we will track some segments/components and the number of distinct\r\nelements in them and also the lengths of the segments to get the longest\r\none during queries. Now regarding the updates, it is hard to track\r\neverything if we do the updates normally. But itsâs easier if we look at\r\nthem in reverse order! Then each update will be decreasing the value of\r\nby . Then for each power , we will have to add a new element to a\r\ncomponent or merge two components. For tracking distinct elements, we\r\ncan use a map or unordered map and to merge we can use DSU with small to\r\nlarge merging. And thatâs pretty much it. Please check my code for more\r\ndetails. Overall complexity is or depending on if you use an unordered\r\nmap or a map. Solution\r\n",
    "name": "F. MEX OR Mania",
    "statement": "An integer sequence b_1, b_2,\r\nldots, b_n is if\r\noperatorname{mex}(b_1, b_2,\r\nldots, b_n) - (b_1 | b_2 |\r\nldots | b_n) = 1. Here,\r\noperatorname{mex(c)} denotes the MEX^{\r\ntext{ }} of the collection c, and | is the bitwise OR operator.Shohag\r\nhas an integer sequence a_1, a_2,\r\nldots, a_n. He will perform the following q updates on a: i x increase\r\na_i by x. After each update, help him find the length of the longest\r\ngood subarray^{\r\ntext{ }} of a.^{\r\ntext{ }}The minimum excluded (MEX) of a collection of integers c_1, c_2,\r\nldots, c_k is defined as the smallest non-negative integer y which does\r\nnot occur in the collection c. ^{\r\ntext{ }}An array d is a subarray of an array f if d can be obtained from\r\nf by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [
        "#include<bits/stdc++.h> using namespace std; #pragma GCC optimize(\"O3,unroll-loops\")#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\") #define int long long #define F first #define S second #define pb push_backconst int mol=998244353;  const int N = 1e5+5;multiset<int, greater<>>ans;struct Dsu{    int dsu[N], sz[N];    map<int, int>ha[N];    void init(int n){        for(int i=1;i<=n;i++) dsu[i]=i, sz[i]=1, ha[i].clear();    }     int find(int g){        if(g==dsu[g]) return g;        return dsu[g]=find(dsu[g]);    }    void un(int g, int h, int id){        g=find(g), h=find(h);                if(sz[g]>sz[h]) swap(g, h);        if(ha[g].size()==(1ll<<id)){            ans.erase(ans.find(sz[g]));        }        if(ha[h].size()==(1ll<<id)){            ans.erase(ans.find(sz[h]));        }                dsu[g]=h, sz[h]+=sz[g];        for(auto t: ha[g]){            ha[h][t.F]+=t.S;        }        if(ha[h].size()==(1ll<<id)){            ans.insert(sz[h]);        }    }}iu[20];int a[N], id[N];void solve(){    int n, q;    cin>>n>>q;    ans.clear();    ans.insert(0);    for(int i=0;i<20;i++) iu[i].init(n);    for(int i=1;i<=n;i++){        cin>>a[i];        id[i]=20;    }     vector<pair<int, int>>qq;    for(int i=1;i<=q;i++){        int g, h;        cin>>g>>h;        a[g]+=h;        qq.pb({g, h});    }     for(int i=19;i>=0;i--){        for(int j=1;j<=n;j++) if(a[j]<(1ll<<i)){            id[j]=i;            if(i==0) ans.insert(1);            iu[i].ha[j][a[j]]=1;        }        for(int j=1;j<n;j++){            if(a[j]<(1ll<<i)&&a[j+1]<(1ll<<i)){                iu[i].un(j, j+1, i);            }        }    }    vector<int>ansq(q+1);    for(int i=q;i>=1;i--){        ansq[i]=*ans.begin();        auto g=qq.back();qq.pop_back();        a[g.F]-=g.S;        for(int i=id[g.F];i<20;i++){            int t=iu[i].find(g.F);            iu[i].ha[t][a[g.F]+g.S]--;            if(iu[i].ha[t][a[g.F]+g.S]==0){                if(iu[i].ha[t].size()==(1ll<<i)) ans.erase(ans.find(iu[i].sz[t]));                iu[i].ha[t].erase(a[g.F]+g.S);            }            iu[i].ha[t][a[g.F]]++;            if(iu[i].ha[t].size()==(1ll<<i)&&iu[i].ha[t][a[g.F]]==1) ans.insert(iu[i].sz[t]);        }        while(id[g.F]>0){            if((1ll<<(id[g.F]-1))>a[g.F]){                id[g.F]--;                iu[id[g.F]].ha[g.F][a[g.F]]=1;                if(id[g.F]==0) ans.insert(1);                if(g.F>1&&a[g.F-1]<(1ll<<(id[g.F]))){                    iu[id[g.F]].un(g.F, g.F-1, id[g.F]);                }                if(g.F<n&&a[g.F+1]<(1ll<<(id[g.F]))){                    iu[id[g.F]].un(g.F, g.F+1, id[g.F]);                }            }            else break;        }    }     for(int i=1;i<=q;i++) cout<<ansq[i]<<\"\\n\";}signed main(){    ios::sync_with_stdio(0);cin.tie(0);    int t;    cin>>t;    while(t--)    solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "data structures",
        "dsu",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. MEX OR Mania.json",
    "hint": []
}