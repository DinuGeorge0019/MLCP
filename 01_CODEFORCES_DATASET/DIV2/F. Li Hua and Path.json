{
    "link": "https://codeforces.com//contest/1797/problem/F",
    "problemId": "1868418",
    "problem_idx": "F",
    "shortId": "1797F",
    "contest_number": "1797",
    "problem_submissions": {
        "B": [
            205419034,
            201275977,
            201268460,
            202344188,
            201271807,
            201275386,
            201273112,
            201272415,
            201269513,
            201276897,
            201277640,
            201269175,
            201275166,
            202145333,
            201276000,
            201267831,
            201270551,
            201276485,
            201289099,
            201272649,
            201271253,
            201272124,
            201270606
        ],
        "A": [
            205418993,
            201265764,
            201267671,
            202344137,
            201265725,
            201267108,
            201266341,
            201266676,
            201266049,
            201269061,
            201271927,
            201266144,
            201269858,
            202145345,
            201267522,
            201265871,
            201265945,
            201268294,
            201268304,
            201268572,
            201266365,
            201267763,
            201266314
        ],
        "C": [
            201304931,
            201299785,
            202344275,
            201282998,
            201300736,
            201289854,
            201285491,
            201299725,
            201282788,
            201290162,
            201283371,
            201295706,
            202145313,
            201292638,
            201281179,
            201287038,
            201297132,
            201271589,
            201298508,
            201283505,
            201292123,
            201308055
        ],
        "E": [
            201300187,
            201295260,
            201299598,
            201320286,
            202381158,
            201379930,
            201379655,
            201379250,
            201325544,
            201325138,
            201320528,
            201338561,
            201331085,
            201338593,
            201334166,
            202145221,
            201331849,
            201345570,
            201338770,
            201329752,
            201334417,
            201332873,
            201342334,
            201330509,
            201327922
        ],
        "D": [
            201273188,
            201286495,
            202344347,
            201311226,
            201292800,
            201301138,
            201293532,
            201309768,
            201303093,
            201302579,
            201300376,
            201317473,
            202145285,
            201313643,
            201313719,
            201306889,
            201311824,
            201310494,
            201312575,
            201304976,
            201303632,
            201307784
        ],
        "F": [
            201422339,
            201658184,
            201413786
        ]
    },
    "name": "F. Li Hua and Path",
    "statement": "Li Hua has a tree of n vertices and n-1 edges. The vertices are numbered\r\nfrom 1 to n.A pair of vertices (u,v) (u < v) is considered if of the\r\nfollowing two statements is true: u is the vertex with the minimum index\r\namong all vertices on the path (u,v). v is the vertex with the maximum\r\nindex among all vertices on the path (u,v).There will be m operations.\r\nIn each operation, he decides an integer k_j, then inserts a vertex\r\nnumbered n+j to the tree, connecting with the vertex numbered k_j.He\r\nwants to calculate the number of pairs before operations and after each\r\noperation.Suppose you were Li Hua, please solve this problem.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n,m;\nvector<int> Emx[1000005],Emn[1000005],E[1000005];\nint fa[1000005],famx[1000005],famn[1000005];\nint getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}\n\ntemplate<int MAXN>struct BIT{\n\tint c[MAXN+5];\n\tint N;\n\tvoid init(int _N=0){\n\t\tN=_N;\n\t\tfor(int i=0;i<=N;++i)\n\t\t\tc[i]=0;\n\t}\n\tint lowbit(int x){return x&(-x);}\n\tvoid add(int x,int k){\n\t\tfor(;x<=N;x+=lowbit(x))\n\t\t\tc[x]+=k;\n\t}\n\tint query(int x){\n\t\tint ret=0;\n\t\tfor(;x;x-=lowbit(x))\n\t\t\tret+=c[x];\n\t\treturn ret;\n\t}\n};\n\nBIT<1000000> bit;\nint dep1[1000005],dep2[1000005],dfn[1000005],sz[1000005],dcnt;\nll A,B,C,ans;\nvoid dfs1(int x){\n\tdfn[x]=++dcnt;\n\tsz[x]=1;\n\tdep1[x]=dep1[famx[x]]+1;\n\tB+=dep1[x]-1;\n\tfor(int y:Emx[x]){\n\t\tdfs1(y);\n\t\tsz[x]+=sz[y];\n\t}\n}\n\nvoid dfs2(int x){\n\tdep2[x]=dep2[famn[x]]+1;\n\tA+=dep2[x]-1;\n\tC+=bit.query(dfn[x]+sz[x]-1)-bit.query(dfn[x]-1);\n\tbit.add(dfn[x],1);\n\tfor(int y:Emn[x])\n\t\tdfs2(y);\n\tbit.add(dfn[x],-1);\n}\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint ui,vi;\n\t\tscanf(\"%d %d\",&ui,&vi);\n\t\tE[ui].push_back(vi);\n\t\tE[vi].push_back(ui);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tsort(E[i].begin(),E[i].end());\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j:E[i]){\n\t\t\tif(j>i)\n\t\t\t\tcontinue;\n\t\t\tj=getfa(j);\n\t\t\tfa[getfa(j)]=getfa(i);\n\t\t\tfamx[j]=i;\n\t\t\tEmx[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j:E[i]){\n\t\t\tif(j<i)\n\t\t\t\tcontinue;\n\t\t\tj=getfa(j);\n\t\t\tfa[getfa(j)]=getfa(i);\n\t\t\tfamn[j]=i;\n\t\t\tEmn[i].push_back(j);\n\t\t}\n\t}\n\tbit.init(n);\n\tdfs1(n);\n\tdfs2(1);\n\tans=A+B-2*C;\n\tprintf(\"%lld\\n\",ans);\n\tscanf(\"%d\",&m);\n\twhile(m--){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tdep2[++n]=dep2[k]+1;\n\t\tans+=n-dep2[n];\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dsu",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Li Hua and Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/114890",
    "editorial": "There exists an acceptable solution using centroid decomposition, but\r\nthere is a better solution using reconstruction trees.The initial tree\r\nis shown in the following picture: Consider the following reconstruction\r\ntrees. We will define two reconstruction trees called min-RT and max-RT\r\nwhere \"RT\" means reconstruction tree.For the max-RT, we enumerate\r\nvertices in increasing order. We create a new vertex in the max-RT, then\r\nfind each vertex such that and is adjacent to in the original tree, make\r\nbecome the father of the root of on the max-RT. We can use a dsu to\r\nbuild the max-RT.The max-RT is shown in the following picture: The\r\nproperty that on the max-RT is the maximum index on the path between on\r\nthe original tree is satisfied.The min-RT is similar to the max-RT.The\r\nmin-RT is shown in the following picture: After designing the\r\nreconstruction trees, I found out that the reconstruction trees are\r\nrelated to Kruskal reconstruction trees (KRT) to a certain extent. Here\r\nis another way to understand the two reconstruction trees. For the\r\nmax-RT, since we want to calculate the maximum index on the path, we\r\ndefine the weight of an edge as . We build a (minimum spanning) KRT of\r\nthe original tree and merge the vertices with the same weight into one\r\nvertex. For the min-RT, define the weight of an edge as and use the\r\n(maximum spanning) KRT.The max-RT and the (minimum spanning) KRT: (left:\r\nmaximum valued graph; middle: KRT; right: max-RT) The min-RT and the\r\n(maximum spanning) KRT: (left: minimum valued graph; middle: KRT; right:\r\nmin-RT) We will solve the problem using the two reconstruction trees.\r\nLet\u00e2\u0080\u0099s call the two restrictions in the statement and .Denote as the\r\nnumber of pairs satisfying exactly one of and (which is the answer), as\r\nthe number of pairs satisfying , as the number of pairs satisfying and\r\nas the number of pairs satisfying both and . It\u00e2\u0080\u0099s obvious that .We can\r\neasily calculate and using the depth of each vertex on two\r\nreconstruction trees. Due to the property mentioned above, is the number\r\nof pairs satisfying the condition that is an ancestor of on min-RT and\r\nis an ancestor of on max-RT, which can be solved using dfs order and\r\nFenwick tree.Finally, we calculated the original answer. If we add a\r\nvertex with the largest index as a leaf, paths ending with this vertex\r\nwill satisfy , so we can use min-RT to calculate the paths ending with\r\nthis vertex not satisfying and update the answer.Time complexity: .\r\n"
}