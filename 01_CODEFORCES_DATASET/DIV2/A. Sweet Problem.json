{
    "link": "https://codeforces.com//contest/1263/problem/A",
    "problemId": "483577",
    "problem_idx": "A",
    "shortId": "1263A",
    "contest_number": "1263",
    "problem_submissions": {
        "F": [
            65982966,
            65978661,
            65982743,
            66004105,
            65981403,
            65982906,
            65984527,
            65967209,
            65985700,
            65987420,
            65990597,
            65985690,
            65988080,
            66082681,
            66082661,
            65991200,
            65988308,
            65990381,
            65990481,
            66004842,
            66004759,
            66004719,
            66004190,
            65989038,
            65986432,
            65987559
        ],
        "A": [
            65969521,
            65961098,
            65960714,
            65962476,
            65960820,
            65960894,
            65980138,
            65961073,
            65960873,
            65961438,
            65963263,
            65960772,
            65978824,
            65961157,
            65962102,
            65960839,
            65961853,
            65961109,
            65961702
        ],
        "E": [
            65968592,
            65970858,
            65970511,
            66002882,
            65966227,
            65975131,
            65974148,
            65975198,
            65975184,
            65976510,
            65977397,
            65977245,
            65977807,
            65973180,
            65969025,
            65981150,
            65979864,
            65980298,
            65982044,
            65990889,
            65982753
        ],
        "D": [
            65964312,
            65966149,
            65963758,
            65968928,
            65967814,
            65969772,
            65976755,
            65969893,
            65967529,
            65964864,
            65971947,
            65966055,
            65962087,
            65967297,
            65966037,
            65973690,
            65970452,
            65967218,
            65972623
        ],
        "C": [
            65962585,
            65964625,
            65962104,
            65977080,
            65966153,
            65965608,
            65964949,
            65977661,
            65966317,
            65964823,
            65965028,
            65969369,
            65963751,
            65963273,
            65964947,
            65961279,
            65968926,
            65968185,
            65964802,
            65969882
        ],
        "B": [
            65961580,
            65962530,
            65961425,
            65964286,
            65964464,
            65963229,
            65979595,
            65963832,
            65962737,
            65962077,
            65967269,
            65974357,
            65980348,
            65962893,
            65969125,
            65965548,
            65964171,
            65963429,
            65966476
        ]
    },
    "name": "A. Sweet Problem",
    "statement": "You have three piles of candies: red, green and blue candies: the first\r\npile contains only red candies and there are r candies in it, the second\r\npile contains only green candies and there are g candies in it, the\r\nthird pile contains only blue candies and there are b candies in it.\r\nEach day Tanya eats exactly two candies of different colors. She is free\r\nto choose the colors of eaten candies: the only restriction that she\r\ncan\u2019t eat two candies of the same color in a day.Find the maximal number\r\nof days Tanya can eat candies? Each day she needs to eat two candies.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T-- > 0) {\n    int a[3];\n    for (int i = 0; i < 3; i++) scanf(\"%d\", &a[i]);\n    sort(a, a + 3);\n    int sum = a[0] + a[1] + a[2];\n    int ans;\n    if (a[2] > a[0] + a[1]) {\n      ans = a[0] + a[1];\n    } else {\n      ans = sum / 2;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Sweet Problem.json",
    "editorial_link": "https://codeforces.com/blog/entry/71844?locale=en",
    "editorial": "Sort the values of , , such that . Now consider two cases.If , then\r\nTanya can take candies from piles and , and then candies from piles and\r\n. After that there may be a bunch of candies left in the pile that Tanya\r\nwon\u00e2\u0080\u0099t be able to eat, so the answer is .Otherwise, we need to achieve\r\nthe equality of the piles , , . First, we make equal and by eating from\r\nthe piles and (this can always be done since ). Then we make equal the\r\npiles , by eating from the piles and . After that, , and we can get\r\nthree different cases. nothing needs to be done, Tanya has already eaten\r\nall the sweets; you can take candy from any of two piles so in the end\r\nthere will always be one candy left; we reduce all the piles by ,\r\ntaking, for example, a candy from piles and , and , and . With such\r\nactions, Tanya eventually reaches the two previous cases, since the\r\nsizes of the piles are reduced by 2. Since with this strategy we always\r\nhave 0 or 1 candy at the end, Tanya will be able to eat candies for\r\ndays.\r\n"
}