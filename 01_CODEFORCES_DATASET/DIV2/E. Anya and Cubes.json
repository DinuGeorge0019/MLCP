{
    "link": "https://codeforces.com//contest/525/problem/E",
    "problemId": "25279",
    "problem_idx": "E",
    "shortId": "525E",
    "contest_number": "525",
    "problem_submissions": {
        "E": [
            10469529,
            10465773,
            10462320,
            10473852,
            10470314,
            10468913,
            10471407,
            10472352,
            10471463,
            10468119,
            10482016
        ],
        "A": [
            10466492,
            10459383,
            10459851,
            10468884,
            10459356,
            10464661,
            10460865,
            10459447,
            10463645,
            10460601,
            10459420,
            10459625,
            10468470,
            10464011,
            10460662,
            10460403,
            10460186,
            10460076,
            10465668,
            10459793
        ],
        "D": [
            10466031,
            10468890,
            10468989,
            10474860,
            10468593,
            10472101,
            10470926,
            10472770,
            10473464,
            10480430,
            10472569,
            10473468,
            10468745,
            10475146
        ],
        "C": [
            10463905,
            10462286,
            10467821,
            10468051,
            10468445,
            10463570,
            10464786,
            10471337,
            10464431,
            10462510,
            10465576,
            10466372,
            10462777,
            10467129,
            10480410,
            10469681,
            10469099,
            10467204
        ],
        "B": [
            10459849,
            10460170,
            10461961,
            10469584,
            10459611,
            10459522,
            10463289,
            10460886,
            10459674,
            10459690,
            10460416,
            10461920,
            10462421,
            10467148,
            10463544,
            10464761,
            10465220,
            10462234,
            10464721,
            10464494
        ]
    },
    "name": "E. Anya and Cubes",
    "statement": "Anya loves to fold and stick. Today she decided to do just that.Anya has\r\ncubes lying in a line and numbered from to from left to right, with\r\nnatural numbers written on them. She also has stickers with exclamation\r\nmarks. We know that the number of stickers does not exceed the number of\r\ncubes.Anya can stick an exclamation mark on the cube and get the\r\nfactorial of the number written on the cube. For example, if a cube\r\nreads , then after the sticking it reads , which equals .You need to\r\nhelp Anya count how many ways there are to choose some of the cubes and\r\nstick on some of the chosen cubes at most exclamation marks so that the\r\nsum of the numbers written on the chosen cubes after the sticking\r\nbecomes equal to . Anya can stick at most one exclamation mark on each\r\ncube. Can you do it?Two ways are considered the same if they have the\r\nsame set of chosen cubes and the same set of cubes with exclamation\r\nmarks.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << \" = \" << ccc << endl;\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nlli\tfact[30]={1},S;\nint\tn,n1,n2,arr[30];\nint\tk;\n\nmap<lli,int>\tA[30],B[30];\n\nvoid\trec1( int ind,int t,lli s ){\n\tif( s>S or t>k )\treturn;\n\tif( ind==n1+1 ){\n\t\tA[t][s]++;\n\t\treturn;\n\t}\n\trec1( ind+1,t,s );\n\trec1( ind+1,t,s+arr[ind] );\n\tif( arr[ind]<=18 )\trec1( ind+1,t+1,s+fact[arr[ind]] );\n}\nvoid\trec2( int ind,int t,lli s ){\n\tif( s>S or t>k )\treturn;\n\tif( ind==n2+1 ){\n\t\tFP( i,t,k )\n\t\t\tB[i][s]++;\n\t\treturn;\n\t}\n\trec2( ind+1,t,s );\n\trec2( ind+1,t,s+arr[ind] );\n\tif( arr[ind]<=18 )\trec2( ind+1,t+1,s+fact[arr[ind]] );\n}\n\nint main(){\n\tFP( i,1,19 )\tfact[i] = fact[i-1]*i;\n\tcin >> n >> k >> S;\n\tFP( i,1,n )\n\t\tcin >> arr[i];\n\tsort( arr+1,arr+n+1 );\n\tn1 = (n+1)/2;\n\tn2 = n-n1;\n\trec1( 1,0,0 );\n\tFP( i,1,n2 )\n\t\tarr[i] = arr[i+n1];\n\trec2( 1,0,0 );\n\tlli\tres=0;\n\tFP( i,0,k )\n\t\tforeach( A[i],it )\n\t\t\tif( B[k-i].find( S-(it->st) )!=B[k-i].end() )\n\t\t\t\tres += (lli)(it->nd)*B[k-i][S-(it->st)];\n\tcout << res << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "dp",
        "math",
        "meet-in-the-middle"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Anya and Cubes.json",
    "editorial_link": "https://codeforces.com//blog/entry/17119",
    "editorial": "To solve this problem we need to use meet-in-the-middle. At first sort given array in increasing order and divide it in two parts. In first part must be first n?/?2 elements, in second part  other.\n\nIterate all submasks of all masks of elements from first part. That is iterate which cubes from first part we take and on which from them we paste exclamation marks. In this way we iterated all possible sums, which we can get with cubes from first part. Let for current submask we get sum sum_lf and use tlf exclamation marks. To store all such sums we use associative arrays map?<?long long?>?cnt[k + 1], where k  count of exclamation marks which we have in the beginning.\n\nAfter that similary iterate all submasks of all masks of elements from second part. Let for current submask sum is sumrg and number of used exclamation marks is trg. Then from first part we need to get sum (s?-?sumrg) and we can use only (k?-?trg) exclamation marks, where s  sum which we must get by condition of the problem. Then iterate how many exclamation marks we will use in first part (let it be variable cur) and increase answer on cnt[cur][s?-?sumrg]. To accelerate our programm we may increase answer only if cnt[cur].count(s?-?sumrg)?=?true.\n\nFor submasks in iterate we can cut off iteration on current sum for submask (it must be less or equal to given s) and on current count of exclamation marks (it must be less or equal to given k). Also we should not paste exclamation marks on cubecs with numbers larger than 18, because 19! more than 1016  maximal value of s.\n\nAsymptotic behavior of this solution  O(3((n?+?1)?/?2)?*?log(maxcnt)?*?k), where n  count of cubes, maxcnt  maximal size of associative array, k  count of exclamation marks.\n",
    "hint": []
}