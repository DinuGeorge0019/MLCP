{
    "link": "https://codeforces.com//contest/2063/problem/C",
    "problemId": "3154904",
    "problem_idx": "C",
    "shortId": "2063C",
    "contest_number": "2063",
    "problem_submissions": {
        "F2": [
            302425610,
            302451940,
            302442929,
            302441504,
            302438014,
            302448830,
            302447651,
            302449239,
            302451441,
            302441520,
            302449441,
            302462040,
            302527079
        ],
        "C": [
            302417331,
            302388966,
            302380666,
            302386796,
            302391515,
            302388488,
            302384390,
            302383854,
            302392461,
            302390039,
            302389493,
            302385787,
            302379767,
            302392628,
            302382228,
            302388334,
            302383676,
            302394839,
            302388632,
            302391072
        ],
        "D": [
            302412152,
            302402949,
            302396428,
            302402633,
            302409161,
            302404535,
            302411549,
            302409325,
            302409501,
            302412675,
            302403620,
            302420625,
            302411254,
            302422339,
            302414704,
            302406132,
            302417532,
            302411171,
            302418058,
            302418384
        ],
        "E": [
            302404720,
            302395352,
            302418668,
            302414791,
            302422680,
            302426848,
            302421742,
            302427528,
            302428407,
            302458083,
            302451720,
            302434097,
            302422758,
            302403323,
            302431883,
            302433354,
            302432981,
            302436125,
            302427678,
            302431985
        ],
        "F1": [
            302388355,
            302424887,
            302442481,
            302433761,
            302438421,
            302445686,
            302447198,
            302443757,
            302450796,
            302427723,
            302449982,
            302451319,
            302436505,
            302455100,
            302448501,
            302454721,
            302454623,
            302448067,
            302454995,
            302448498
        ],
        "B": [
            302385897,
            302389386,
            302371425,
            302391237,
            302379321,
            302378690,
            302373741,
            302377026,
            302378459,
            302385735,
            302370221,
            302376737,
            302372000,
            302386149,
            302374530,
            302374437,
            302376025,
            302383492,
            302381557,
            302378496
        ],
        "A": [
            302374954,
            302366962,
            302363313,
            302365021,
            302366134,
            302366042,
            302365897,
            302366966,
            302363934,
            302362493,
            302362600,
            302366245,
            302365093,
            302367784,
            302363061,
            302365428,
            302365621,
            302368569,
            302369401,
            302377605
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138593",
    "editorial": "The main observation behind this task is that the number of connected\r\ncomponents increases by , where is the degree of the removed vertex\r\nremoving. Thus, the number of connected components after removing two\r\nvertices and is: if and are adjacent; if and are adjacent, because\r\nremoving will decrease of by . The main approaches in maximizing this\r\nappear this observation. There are multiple approaches to this, where\r\nthe editorial will introduce two of them. : Bruteforcing the Vertex You\r\ncan maintain a sorted version of the degree sequence, using a , a heap,\r\nor possibly even simply a sorted sequence.After you fix the first vertex\r\n, you can find the maximum degree decreasing the degrees of all adjacent\r\nvertices by . can deal with this directly by removing and inserting\r\nvalues, while a heap or a sorted sequence can deal with this by popping\r\nelements from the end while the two maximums have the same value. Then,\r\nthe second vertex is easily the one with maximum degree.Maintaining the\r\ndegrees takes time. As , the total time complexity of this approach is .\r\n: Bruteforcing the Vertex If we greedily select the first vertex by\r\ndegree, we can notice that selecting the first vertex as one with\r\nmaximum degree will find at least one optimal solution. Assume that the\r\nfirst vertex with maximum degree had a maximum value . Then, consider\r\nany solution with both vertices’ initial degrees strictly less than .\r\nThis second solution’s maximum possible value will never exceed ,\r\nbecause and . Thus, at least one optimal answer must have the first\r\nvertex as one with maximum initial degree.But we do not know what to do\r\nwhen there are multiple first vertices with maximum initial degree.\r\nLuckily, trying only two first vertices with maximum initial degrees\r\nwill always find one optimal answer. This can be proven by\r\ncontradiction; If the two first vertices are and , and the second vertex\r\nchosen in the bruteforce is . At least one pair in , , will be , because\r\notherwise it implies the existence of a -cycle, which can only exist if\r\nthe graph is a tree. Thus, if the optimal solution is in the form ,\r\ntrying two first vertices will always find it.Therefore, we can try two\r\nvertices greedily for the first vertex and try all other vertices as the\r\nsecond vertex, finding at least one optimal answer in the process.The\r\ntime complexity of this approach is or depending on how adjacency is\r\nchecked. Adjacency check in is possible by preprocessing parents using\r\nDFS, because \" and are adjacent\" is equivalent to \" or \".\r\n",
    "name": "C. Remove Exactly Two",
    "statement": "You are given a tree^{\r\ntext{ }} of n vertices. You must perform the following operation .\r\nSelect a vertex v; Remove all edges incident to v, and also the vertex\r\nv. Please find the maximum number of connected components after\r\nperforming the operation .Two vertices x and y are in the same connected\r\ncomponent if and only if there exists a path from x to y. For clarity,\r\nnote that the graph with 0 vertices has 0 connected components by\r\ndefinition.^{\r\ntext{ }}^{\r\ntext{ }}A tree is a connected graph without cycles. ^{\r\ntext{ }}But is such a graph connected?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());ll rint(ll l,ll r){return uniform_int_distribution<ll>(l,r)(rnd);}const int maxn=3e5+10;template<class T> void read(T &X){    X=0;    bool fu=0;    char cr=getchar();    while((cr<'0'||cr>'9')&&cr!='-') cr=getchar();    if(cr=='-') cr=getchar(),fu=1;    while(cr>='0'&&cr<='9') X=(X<<3)+(X<<1)+(cr^48),cr=getchar();    X=(fu?-X:X);}int T,n,d[maxn];vector<int> e[maxn];pr a[maxn];set<pr> s;int main(){//    freopen(\".in\",\"r\",stdin);//    freopen(\".out\",\"w\",stdout);    read(T);    while(T--)    {        read(n),s.clear();        for(int i=1;i<=n;i++) d[i]=0,e[i].clear();        for(int i=1,x,y;i<n;i++) read(x),read(y),s.insert(mp(x,y)),s.insert(mp(y,x)),d[x]++,d[y]++;        for(int i=1;i<=n;i++) a[i]=mp(d[i],i);        sort(a+1,a+n+1),reverse(a+1,a+n+1);        int loc=1;        while(loc+1<=n&&a[loc+1].x==a[1].x) loc++;        int ans=a[1].x+a[2].x-2;        if(loc==1)        {            for(int i=2;i<=n&&a[2].x==a[i].x;i++)            {                if(!s.count(mp(a[1].y,a[i].y)))                {                    ans=a[1].x+a[2].x-1;                    break;                }            }        }        else if(loc>=2)        {            if(!s.count(mp(a[1].y,a[2].y))) ans=a[1].x+a[2].x-1;            if(loc>=3&&0==s.count(mp(a[1].y,a[3].y))) ans=a[1].x+a[2].x-1;            if(loc>=3&&0==s.count(mp(a[2].y,a[3].y))) ans=a[1].x+a[2].x-1;        }        printf(\"%d\\n\",ans);    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Remove Exactly Two.json",
    "hint": [
        "Hint The answer after choosing two vertices is decided by the degrees of the two vertices, and whether the two vertices are adjacent . Can you find a clean solution where you don't have to care about the latter?"
    ]
}