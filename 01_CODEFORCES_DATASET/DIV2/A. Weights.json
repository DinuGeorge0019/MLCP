{"link": "https://codeforces.com//contest/1600/problem/A", "problemId": "1136949", "problem_idx": "A", "shortId": "1600A", "contest_number": "1600", "problem_submissions": {"D": [131326791, 131319774, 131349265, 131313616, 131318416, 131323729], "F": [131320345, 131329426, 131350388], "E": [131316574, 131313861, 131305576, 131310151, 131314773], "I": [131312786, 131309903, 131307758, 131305198, 131310781], "A": [131307398], "J": [131302886, 131305362, 131303377, 131303391, 131305512]}, "name": "A. Weights", "statement": "You are given an array A of length N weights of masses A_1, A_2...A_N.\r\nNo two weights have the same mass. You can put every weight on one side\r\nof the balance (left or right). You don\u2019t have to put weights in order\r\nA_1,...,A_N. There is also a string S consisting of characters \"L\" and\r\n\"R\", meaning that after putting the i-th weight (not A_i, but i-th\r\nweight of your choice) left or right side of the balance should be\r\nheavier. Find the order of putting the weights on the balance such that\r\nrules of string S are satisfied.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    REP(i, n) cin >> a[i];\n    string ss;\n    cin >> ss;\n    vector<int> s(n);\n    REP(i, n) s[i] = (ss[i] == 'L' ? -1 : 1);\n\n    auto sign = [&](int x) {\n      return (x+n)%2 ? s[n-1] : -s[n-1];\n    };\n    sort(a.begin(), a.end());\n    vector<int> ans(n);\n\n    int lo = 0;\n    int hi = n - 1;\n    FORD(i, n - 1, 1) {\n      if (sign(hi) == s[i - 1]) {\n        ans[i] = a[lo] * sign(lo), lo++;\n      } else {\n        ans[i] = a[hi] * sign(hi), hi--;\n      }\n    }\n\n    ans[0] = a[lo] * sign(lo);\n\n    FOR(i, 0, n - 1) {\n      cout << abs(ans[i]) << \" \";\n      if (ans[i] < 0) cout << \"L\" << endl; else cout << \"R\" << endl;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2600", "interactive": false}