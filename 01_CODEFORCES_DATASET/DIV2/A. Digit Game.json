{
    "link": "https://codeforces.com//contest/1419/problem/A",
    "problemId": "729807",
    "problem_idx": "A",
    "shortId": "1419A",
    "contest_number": "1419",
    "problem_submissions": {
        "F": [
            93295033,
            93295948,
            93577512,
            141950739,
            141949703,
            93333082
        ],
        "E": [
            93234753,
            93227212,
            93234200,
            93238693,
            93238493,
            93238433,
            93238275,
            93245697,
            93246537,
            93242848,
            93246826,
            93247065,
            93245207,
            93241549,
            93243538,
            93254913,
            93249479,
            93238516
        ],
        "D2": [
            93212522,
            93217506,
            93213686,
            93220590,
            93215812,
            93218918,
            93214966,
            93215328,
            93210409,
            93223664,
            93218002,
            93222549,
            93220767,
            93225667,
            93221756,
            93229039,
            93216049,
            93227118
        ],
        "D1": [
            93210697,
            93214622,
            93213970,
            93213840,
            93206345,
            93211719,
            93208773,
            93212321,
            93204619,
            93213170,
            93216390,
            93214097,
            93210302,
            93207013,
            93214684,
            93211970,
            93215865,
            93206978
        ],
        "C": [
            93207169,
            93210000,
            93209428,
            93210195,
            93217148,
            93208516,
            93207753,
            93214333,
            93218732,
            93213670,
            93211157,
            93218160,
            93211807,
            93211495,
            93209180,
            93205213,
            93217455
        ],
        "B": [
            93202581,
            93203801,
            93204920,
            93203314,
            93203851,
            93201764,
            93202768,
            93202454,
            93208579,
            93203844,
            93205640,
            93206433,
            93220603,
            93204341,
            93204189,
            93202311,
            93214207
        ],
        "A": [
            93200129,
            93200069,
            93200258,
            93200020,
            93200369,
            93204977,
            93200037,
            93200656,
            93201705,
            93200310,
            93200086,
            93201198,
            93200525,
            93199999,
            93201236,
            93200136,
            93200638
        ]
    },
    "name": "A. Digit Game",
    "statement": "Everyone knows that agents in Valorant decide, who will play as\r\nattackers, and who will play as defenders. To do that Raze and Breach\r\ndecided to play t matches of a digit game...In each of t matches of the\r\ndigit game, a positive integer is generated. It consists of n digits.\r\nThe digits of this integer are numerated from 1 to n from the\r\nhighest-order digit to the lowest-order digit. After this integer is\r\nannounced, the match starts.Agents play in turns. Raze starts. In one\r\nturn an agent can choose any unmarked digit and mark it. Raze can choose\r\ndigits on odd positions, but can not choose digits on even positions.\r\nBreach can choose digits on even positions, but can not choose digits on\r\nodd positions. The match ends, when there is only one unmarked digit\r\nleft. If the single last digit is odd, then Raze wins, else Breach\r\nwins.It can be proved, that before the end of the match (for every\r\ninitial integer with n digits) each agent has an ability to make a turn,\r\ni.e. there is at least one unmarked digit, that stands on a position of\r\nrequired parity.For each of t matches find out, which agent wins, if\r\nboth of them want to win and play optimally.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s\".in\", \"r\", stdin); freopen(s\".out\", \"w\", stdout)\n#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, \"%d \", a[i]); fprintf(stderr, \"\\n\");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = '0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint a[MAXN], n;\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(\"pro\");\n    #endif\n    int T; cin >> T;\n    while(T--) {\n    \tcin >> n; string s; cin >> s; s = ' ' + s;\n    \tif(n & 1) {\n    \t\tint res = 0;\n    \t\tfor(int i = 1; i <= n; i += 2) \n    \t\t\tif((s[i] - '0') & 1) res = 1;\n    \t\tprintf(res ? \"1\\n\" : \"2\\n\");\n\t\t} else {\n\t\t\tint res = 0;\n    \t\tfor(int i = 2; i <= n; i += 2) \n    \t\t\tif(!((s[i] - '0') & 1)) res = 1;\n    \t\tprintf(res ? \"2\\n\" : \"1\\n\");\n\t\t}\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy",
        "implementation"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Digit Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/82817",
    "editorial": "Let\u00e2\u0080\u0099s say that digits on odd positions are blue and digits on even\r\npositions are red. If is even the remaining digit will be red. If there\r\nis at least one even red digit then Breach wins (he can mark all digits\r\nexcept the one that will remain in the end). In other case Raze wins,\r\nbecause any digit that may remain is odd.If is odd the remaining digit\r\nwill be blue. If there is at least one odd blue digit then Raze wins\r\n(using the same strategy applied to her). In other case Breach wins.\r\n"
}