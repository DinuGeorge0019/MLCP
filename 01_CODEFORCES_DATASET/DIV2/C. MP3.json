{"link": "https://codeforces.com//contest/1199/problem/C", "problemId": "380943", "problem_idx": "C", "shortId": "1199C", "contest_number": "1199", "problem_submissions": {"E": [58030586, 58021734, 58025826, 58022450, 58018815, 58018132, 58016064, 58035343, 58034869, 58017816, 58024170, 58025918, 58022291, 58023170, 58022937, 58024351, 58028105], "F": [58024830, 58028686, 58018020, 58017115, 58028245, 58019034, 58384931, 58013729, 58065279, 58027365, 58334987, 58059871, 58026310], "D": [58011622, 58006050, 58005239, 58009886, 58003558, 58013213, 58006910, 58023637, 58004292, 58010802, 58010127, 58010591, 58010277, 58011062, 58011952, 58012323, 58015144, 58009223, 58018000], "C": [58003286, 58015626, 58038871, 58045412, 58007604, 58002586, 58019533, 58011071, 58005193, 58006733, 58004437, 58004399, 58006254, 58008729, 58007961, 58005653, 58003369, 58011620], "B": [57997198, 58010291, 57996992, 57996941, 58045445, 57999240, 57998882, 57996286, 57999211, 58000305, 58000178, 58000443, 57996371, 57996748, 57996780, 57999052, 57996536, 57997898, 57997650, 58000545], "A": [57995512, 58007859, 57995725, 57995380, 57995192, 57996027, 57994975, 57996866, 57994742, 57994764, 57995474, 57994875, 57994979, 57995233, 57995511, 57995009, 57994816, 57996166, 57995838]}, "name": "C. MP3", "statement": "One common way of digitalizing sound is to record sound intensity at\r\nparticular time moments. For each time moment intensity is recorded as a\r\nnon-negative integer. Thus we can represent a sound file as an array of\r\nn non-negative integers.If there are exactly K distinct values in the\r\narray, then we need k =\r\nlceil\r\nlog_{2} K\r\nrceil bits to store each value. It then takes nk bits to store the whole\r\nfile.To reduce the memory consumption we need to apply some compression.\r\nOne common way is to reduce the number of possible intensity values. We\r\nchoose two integers l\r\nle r, and after that all intensity values are changed in the following\r\nway: if the intensity value is within the range [l;r], we don\u2019t change\r\nit. If it is less than l, we change it to l; if it is greater than r, we\r\nchange it to r. You can see that we lose some low and some high\r\nintensities.Your task is to apply this compression in such a way that\r\nthe file fits onto a disk of size I bytes, and the number of changed\r\nelements in the array is minimal possible.We remind you that 1 byte\r\ncontains 8 bits.k =\r\nlceil log_{2} K\r\nrceil is the smallest integer such that K\r\nle 2^{k}. In particular, if K = 1, then k = 0.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\n#define isNum(a) (a >= '0' && a <= '9')\n#define SP putchar(' ')\n#define EL putchar('\\n')\n#define File(a) freopen(a \".in\", \"r\", stdin), freopen(a \".out\", \"w\", stdout)\n\ntemplate<class T>\ninline void read(T&);\ntemplate<class T>\ninline void write(const T&);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef const int& ci;\ntypedef std::pair<int, int> pii;\nconst int iinf = 2147483647;\nconst ll llinf = 9223372036854775807ll;\nusing std::min;\nusing std::max;\nusing std::abs;\nusing std::sort;\nconst int N = 400005;\n\nint a[N];\nint num[N];\nint sum[N];\n\nint main () {\n    int n, m;\n    read(n), read(m);\n    int k = m * 8 / n;\n    if (k > 20) {\n        write(0), EL;\n        return 0;\n    }\n    int K = 1 << k;\n    for (int i = 1; i <= n; ++i) {\n        read(a[i]);\n    }\n    sort(a + 1, a + n + 1);\n    int now = 1;\n    num[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        if (a[i] == a[i - 1]) {\n            ++num[now];\n        } else {\n            ++num[++now];\n        }\n    }\n    if (K >= now) {\n        write(0), EL;\n        return 0;\n    }\n    for (int i = 1; i <= now; ++i) {\n        sum[i] = sum[i - 1] + num[i];\n    }\n    int ans = iinf;\n    for (int i = K; i <= now; ++i) {\n        ans = min(ans, n - (sum[i] - sum[i - K]));\n    }\n    write(ans), EL;\n    return 0;\n}\n\ntemplate<class T>\nvoid read(T &Re) {\n    T k = 0;\n    char ch = getchar();\n    int flag = 1;\n    while (!isNum(ch)) {\n        if (ch == '-') {\n            flag = -1;\n        }\n        ch = getchar();\n    }\n    while (isNum(ch)) {\n        k = (k << 1) + (k << 3) + ch - '0';\n        ch = getchar();\n    }\n    Re = flag * k;\n}\ntemplate<class T>\nvoid write(const T &Wr) {\n    if (Wr < 0) {\n        putchar('-');\n        write(-Wr);\n    } else {\n        if (Wr < 10) {\n            putchar(Wr + '0');\n        } else {\n            write(Wr / 10);\n            putchar((Wr % 10) + '0');\n        }\n    }\n}\n"], "input": "", "output": "", "tags": ["two pointers"], "dificulty": "1600", "interactive": false}