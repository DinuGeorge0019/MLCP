{
    "link": "https://codeforces.com//contest/940/problem/C",
    "problemId": "159601",
    "problem_idx": "C",
    "shortId": "940C",
    "contest_number": "940",
    "problem_submissions": {
        "F": [
            35642079,
            35639249,
            35741635,
            36062963,
            36289513
        ],
        "E": [
            35635658,
            35633935,
            35631463,
            35633682,
            35625185,
            35633814,
            35633623,
            35626225,
            35634924,
            35632939,
            35633342,
            35637140,
            35635889,
            35635053,
            35634184,
            35633752,
            35646808,
            35646714,
            35632320,
            35632703
        ],
        "C": [
            35629972,
            35623066,
            35624318,
            35625052,
            35625312,
            35628608,
            35627465,
            35626058,
            35629009,
            35622773,
            35623814,
            35626574,
            35624743,
            35624088,
            35624644,
            35624203,
            35626389,
            35626478,
            35625921
        ],
        "A": [
            35626916,
            35619951,
            35619990,
            35620867,
            43064576,
            35620290,
            35621938,
            35620031,
            35620370,
            35620395,
            35619980,
            35620028,
            35620003,
            35619970,
            35620016,
            35620214,
            35619977,
            35620645,
            35623155,
            35620719
        ],
        "B": [
            35625745,
            35621065,
            35621588,
            35622435,
            35622147,
            35624740,
            35624541,
            35622933,
            35622325,
            35621538,
            35621447,
            35624471,
            35622193,
            35621648,
            35621812,
            35621709,
            35623702,
            35624565,
            35622680
        ],
        "D": [
            35623541,
            35626308,
            35627049,
            35628539,
            35628655,
            35631444,
            35629469,
            35628621,
            35633730,
            35625705,
            35628318,
            35630442,
            35631472,
            35627122,
            35630218,
            35630123,
            35629593,
            35629487,
            35628885
        ]
    },
    "name": "C. Phone Numbers",
    "statement": "You are given a string consisting of lowercase English letters and an\r\ninteger . Find the lexicographically smallest string of length , such\r\nthat its set of letters is a subset of the set of letters of and is\r\nlexicographically smaller than .It\u2019s guaranteed that the answer\r\nexists.Note that the set of letters is a set, not a multiset. For\r\nexample, the set of letters of is .String is lexicographically smaller\r\nthan string , if is a prefix of , is not equal to or there exists , such\r\nthat and for all it is satisfied that . For example, is\r\nlexicographically smaller than , is lexicographically smaller than ,\r\nlexicographically smaller than and lexicographically smaller than .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint n, m;\nchar s[100005], b[100005];\nint vis[30], id[30];\nint stk[30], tp;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor(int i = 1; i <= n; i ++){\n\t\tvis[s[i] - 'a'] = 1;\n\t}\n\tfor(int i = 0; i < 26; i ++){\n\t\tif(vis[i]) stk[++tp] = i, id[i] = tp;\n\t}\n\tif(m > n){\n\t\tfor(int i = 1; i <= n; i ++){\n\t\t\tprintf(\"%c\", s[i]);\n\t\t}\n\t\tfor(int i = n + 1; i <= m; i ++){\n\t\t\tprintf(\"%c\", stk[1] + 'a');\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= m; i ++){\n\t\tb[i] = s[i];\n\t}\n\t\tint d = id[b[m] - 'a'], pos = m;\n\t\twhile(d == tp){\n\t\t\tb[pos] = (char)(stk[1] + 'a');\n\t\t\tpos--;\n\t\t\td = id[b[pos] - 'a'];\n\t\t}\n\t\tb[pos] = stk[d + 1] + 'a';\n\tfor(int i = 1; i <= m; i ++){\n\t\tprintf(\"%c\", b[i]);\n\t}\n\treturn 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Phone Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/58033",
    "editorial": "Consider cases: If we should simply add minimum symbols from . If we\r\nneed to replace all symbols in the suffix of first symbols of string\r\nconsisting of largest symbols to smallest symbols and next symbol before\r\nthis suffix replace with next symbol that exists in the string.\r\nComplexity of this solution is .\r\n"
}