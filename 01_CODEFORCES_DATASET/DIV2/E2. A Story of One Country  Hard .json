{
    "link": "https://codeforces.com//contest/1181/problem/E2",
    "problemId": "359265",
    "problem_idx": "E2",
    "shortId": "1181E2",
    "contest_number": "1181",
    "problem_submissions": {
        "E2": [
            55650122,
            55830557,
            55704213
        ],
        "E1": [
            55633819,
            55638516,
            55638501,
            55637414,
            55641214,
            55640980,
            55643225,
            55640108,
            55640609,
            55642576,
            55643544,
            55642412,
            55643807,
            55641985,
            55642964,
            240099989
        ],
        "D": [
            55631090,
            55633784,
            55633448,
            55631287,
            55633631,
            55633273,
            55636890,
            55634366,
            55634832,
            55638016,
            55638738,
            55634315,
            55639336,
            55636804,
            55635357,
            55637569,
            55636303,
            55635471,
            55634737,
            55630910
        ],
        "B": [
            55627797,
            55620636,
            55623454,
            55633957,
            55622559,
            55626217,
            109938468,
            109937680,
            55629226,
            55627039,
            55625976,
            55641971,
            55622249,
            55622014,
            55624276,
            55623137
        ],
        "C": [
            55625127,
            55629408,
            55627484,
            55625656,
            55629031,
            55630033,
            55628446,
            55636714,
            55636852,
            55632570,
            55634750,
            55628993,
            55633600,
            55628788,
            55626023,
            55632494,
            55631294,
            55629796,
            55629116,
            55636617
        ],
        "A": [
            55616968,
            55616973,
            55617720,
            55617671,
            55617776,
            55617314,
            55618111,
            109966538,
            109938562,
            109938324,
            55618923,
            55617442,
            55639586,
            55635703,
            55628269,
            55617672,
            55630717,
            55619287,
            55617106,
            55617973,
            55617169,
            55617325
        ]
    },
    "name": "E2. A Story of One Country  Hard ",
    "statement": "Petya decided to visit Byteland during the summer holidays. It turned\r\nout that the history of this country is quite unusual.Initially, there\r\nwere n different countries on the land that is now Berland. Each country\r\nhad its own territory that was represented as a rectangle on the map.\r\nThe sides of the rectangle were parallel to the axes, and the corners\r\nwere located at points with integer coordinates. Territories of no two\r\ncountries intersected, but it was possible that some territories touched\r\neach other. As time passed, sometimes two countries merged into one. It\r\nonly happened if the union of their territories was also a rectangle. In\r\nthe end only one country remained Byteland.Initially, each country had a\r\nrectangular castle inside its territory. Its sides were parallel to the\r\naxes and its corners had integer coordinates. Some castles might touch\r\nthe border of the corresponding country and sides or other castles.\r\nMiraculously, after all the unions the castles are still intact.\r\nUnfortunately, their locations are the only information we have to\r\nrestore the initial territories of the countries. The possible formation\r\nof Byteland. The castles are shown in blue. Petya wonders why no\r\ninformation about the initial countries remained. He suspected that the\r\nwhole story is a fake. You were recommended to him as a smart person.\r\nPlease check whether or not there exists a possible set of initial\r\nterritories that could make the story true.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=1e5, mxC=2*mxN;\nint n, a[mxN], b[mxN], c[mxN], d[mxN];\nint x[mxC], y[mxC], xs, ys;\n\nstruct st {\n\tar<int, 2> st[1<<19];\n\tint lz[1<<19];\n\tvoid bld(int i=1, int l=0, int r=mxC-1) {\n\t\tif(l==r) {\n\t\t\tst[i]={0, l};\n\t\t\treturn;\n\t\t}\n\t\tint m=(l+r)/2;\n\t\tbld(2*i, l, m);\n\t\tbld(2*i+1, m+1, r);\n\t\tst[i]=st[2*i];\n\t}\n\tvoid app(int i, int x) {\n\t\tst[i][0]+=x;\n\t\tlz[i]+=x;\n\t}\n\tvoid psh(int i) {\n\t\tapp(2*i, lz[i]);\n\t\tapp(2*i+1, lz[i]);\n\t\tlz[i]=0;\n\t}\n\tvoid upd(int l1, int r1, int x, int i=1, int l2=0, int r2=mxC-1) {\n\t\tif(l1>r1)\n\t\t\treturn;\n\t\tif(l1<=l2&&r2<=r1) {\n\t\t\tapp(i, x);\n\t\t\treturn;\n\t\t}\n\t\tint m2=(l2+r2)/2;\n\t\tpsh(i);\n\t\tif(l1<=m2)\n\t\t\tupd(l1, r1, x, 2*i, l2, m2);\n\t\tif(m2<r1)\n\t\t\tupd(l1, r1, x, 2*i+1, m2+1, r2);\n\t\tst[i]=min(st[2*i], st[2*i+1]);\n\t}\n\tar<int, 2> qry(int l1, int r1, int i=1, int l2=0, int r2=mxC-1) {\n\t\tif(l1>r1)\n\t\t\treturn {mxN};\n\t\tif(l1<=l2&&r2<=r1)\n\t\t\treturn st[i];\n\t\tint m2=(l2+r2)/2;\n\t\tpsh(i);\n\t\treturn min(l1<=m2?qry(l1, r1, 2*i, l2, m2):ar<int, 2>{mxN}, m2<r1?qry(l1, r1, 2*i+1, m2+1, r2):ar<int, 2>{mxN});\n\t}\n} stx, sty;\n\nstruct ft {\n\tint ft[mxC+1];\n\tvoid upd(int i, int x) {\n\t\tfor(++i; i<=mxC; i+=i&-i)\n\t\t\tft[i]+=x;\n\t}\n\tint qry(int i) {\n\t\tint r=0;\n\t\tfor(; i; i-=i&-i)\n\t\t\tr+=ft[i];\n\t\treturn r;\n\t}\n} ftx, fty;\n\nvoid rem(int i) {\n\tstx.upd(a[i]+1, c[i]-1, -1);\n\tsty.upd(b[i]+1, d[i]-1, -1);\n\tftx.upd(a[i], -1);\n\tfty.upd(b[i], -1);\n}\n\nbool dc(vector<int> &v) {\n\t//cout << \"dc \" << v.size() << endl;\n\t//for(int vi : v)\n\t\t//cout << vi << \" \";\n\t//cout << endl;\n\tset<ar<int, 2>> sx, sy, sx2, sy2;\n\tfor(int i : v) {\n\t\tstx.upd(a[i]+1, c[i]-1, 1);\n\t\tsty.upd(b[i]+1, d[i]-1, 1);\n\t\tftx.upd(a[i], 1);\n\t\tfty.upd(b[i], 1);\n\t\tsx.insert({a[i], i});\n\t\tsy.insert({b[i], i});\n\t\tsx2.insert({c[i], i});\n\t\tsy2.insert({d[i], i});\n\t}\n\t//cout << \"hi1\" << endl;\n\n\tvector<vector<int>> vl;\n\twhile(sx.size()>3) {\n\t\t//cout << \"sd\" << endl;\n\t\tint ss=sx.size();\n\t\tvl.push_back({});\n\t\tar<int, 2> px=stx.qry((*sx.begin())[0]+1, (*--sx2.end())[0]-1);\n\t\t//cout << px[0] << \" \" << px[1] << endl;\n\t\tif(!px[0]) {\n\t\t\tif(ftx.qry(px[1])>ss/2) {\n\t\t\t\tauto it=--sx.end();\n\t\t\t\twhile((*it)[0]>=px[1]) {\n\t\t\t\t\tint i=(*it)[1];\n\t\t\t\t\t//cout << i << endl;\n\t\t\t\t\tvl.back().push_back(i);\n\t\t\t\t\trem(i);\n\t\t\t\t\tit=--sx.erase(it);\n\t\t\t\t\tsy.erase({b[i], i});\n\t\t\t\t\tsx2.erase({c[i], i});\n\t\t\t\t\tsy2.erase({d[i], i});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tauto it=sx.begin();\n\t\t\t\twhile((*it)[0]<px[1]) {\n\t\t\t\t\tint i=(*it)[1];\n\t\t\t\t\tvl.back().push_back(i);\n\t\t\t\t\trem(i);\n\t\t\t\t\tit=sx.erase(it);\n\t\t\t\t\tsy.erase({b[i], i});\n\t\t\t\t\tsx2.erase({c[i], i});\n\t\t\t\t\tsy2.erase({d[i], i});\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tar<int, 2> py=sty.qry((*sy.begin())[0]+1, (*--sy2.end())[0]-1);\n\t\t//cout << py[0] << \" \" << py[1] << endl;\n\t\tif(!py[0]) {\n\t\t\tif(fty.qry(py[1])>ss/2) {\n\t\t\t\tauto it=--sy.end();\n\t\t\t\twhile((*it)[0]>=py[1]) {\n\t\t\t\t\tint i=(*it)[1];\n\t\t\t\t\tvl.back().push_back(i);\n\t\t\t\t\trem(i);\n\t\t\t\t\tsx.erase({a[i], i});\n\t\t\t\t\tit=--sy.erase(it);\n\t\t\t\t\tsx2.erase({c[i], i});\n\t\t\t\t\tsy2.erase({d[i], i});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tauto it=sy.begin();\n\t\t\t\twhile((*it)[0]<py[1]) {\n\t\t\t\t\tint i=(*it)[1];\n\t\t\t\t\tvl.back().push_back(i);\n\t\t\t\t\trem(i);\n\t\t\t\t\tsx.erase({a[i], i});\n\t\t\t\t\tit=sy.erase(it);\n\t\t\t\t\tsx2.erase({c[i], i});\n\t\t\t\t\tsy2.erase({d[i], i});\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(ar<int, 2> a : sx)\n\t\trem(a[1]);\n\tfor(vector<int> &vi : vl)\n\t\tif(!dc(vi))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\n\tmemcpy(x, a, 4*n);\n\tmemcpy(x+n, c, 4*n);\n\tsort(x, x+2*n);\n\txs=unique(x, x+2*n)-x;\n\tstx.bld();\n\n\tmemcpy(y, b, 4*n);\n\tmemcpy(y+n, d, 4*n);\n\tsort(y, y+2*n);\n\tys=unique(y, y+2*n)-y;\n\tsty.bld();\n\t\n\tfor(int i=0; i<n; ++i) {\n\t\ta[i]=lower_bound(x, x+xs, a[i])-x;\n\t\tc[i]=lower_bound(x, x+xs, c[i])-x;\n\t\tb[i]=lower_bound(y, y+ys, b[i])-y;\n\t\td[i]=lower_bound(y, y+ys, d[i])-y;\n\t}\n\n\tvector<int> v(n);\n\tiota(v.begin(), v.end(), 0);\n\tcout << (dc(v)?\"YES\":\"NO\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. A Story of One Country  Hard .json",
    "editorial_link": "https://codeforces.com//blog/entry/67727",
    "editorial": "We can rephrase the problem as follows:There is a set of\r\nnon-intersecting rectangles on the plane. Let\u00e2\u0080\u0099s say, that some\r\nrectangular area on the plane is , if it contains exactly one rectangle\r\nin it or there exists a vertical or horizontal cut, which cuts the area\r\ninto two good areas. You are asked to check whether the area is\r\ngood.It\u00e2\u0080\u0099s easy to see that it is exactly the same process as in the\r\nstatement, except we don\u00e2\u0080\u0099t merge countries into one, we look at the\r\nreversed process, where we split one country into many.Also let\u00e2\u0080\u0099s\r\nnotice, that when we found some cutting line, which doesn\u00e2\u0080\u0099t goes through\r\ninner part of any rectangle, we can always apply it to separate our area\r\ninto two. We can do that, since our predicate of set of rectangles being\r\nnice is monotonic: if we replace set of rectangles with its subset, it\r\nonly can make better.Now let\u00e2\u0080\u0099s analyze when the cut is good: This\r\nalready gives us a solution in , which passes the easy version of the\r\nproblem. Simply solve the problem recursively, sorting rectangles as\r\nshown above. (and symmetrically for horizontal cuts) and try finding a\r\ncut. Once we find it, solve the problem recursively.Now we have working\r\ntime: , where is a size of one part of the cut. The worse case is , so .\r\nFor the full version we need a faster solution.The key idea is: let\u00e2\u0080\u0099s\r\ncut always \"smaller from larger\". Suppose we are magically able to find\r\nany valid cut in (basically the number ). Then we could have spent to\r\ncut out the smaller part into new recursive call. While we can continue\r\nthe process of cutting with the remaining rectangles in this recursion\r\ncall.This solution works in : Each time the size of problem reduces at\r\nleast twice when we go into recursion, so there are only levels.However\r\nwe need to handle \"magic\" here. For example one could have used a\r\nsegment tree to implement all mentioned above (it would give a time).\r\nBut there is a simpler solution!Let\u00e2\u0080\u0099s sort rectangles using all possible\r\nsortings. And let\u00e2\u0080\u0099s iterate over all this sortings simultaneously. We\r\nneed directions instead of , because if we would e.g. only iterate from\r\nlet to right, we wouldn\u00e2\u0080\u0099t be able to cut out the \"smaller\" from\r\n\"larger\", in case the \"smaller\" is to the right of \"larger\". So we want\r\nto both go from left to right and from right to left.When in one of the\r\ndirections we see a valid place to make a cut, we remove all the\r\nrectangles into the separate recursion call. We also mark all those\r\nrectangles in the current recursion call as deleted and start the\r\nprocedure of cutting again. We can simply skip the rectangles marked as\r\ndeleted when we encounter them. For example we could use a linked list\r\nfor that: So now we got a solution in : one logarithm is from cutting\r\nsmaller from larger and one logarithm is from sorting.One could drop the\r\nsecond logarithm. For that we should sort all rectangles at the\r\nbeginning and then carefully pass the correct ordering down the\r\nrecursion. But that wasn\u00e2\u0080\u0099t required.\r\n"
}