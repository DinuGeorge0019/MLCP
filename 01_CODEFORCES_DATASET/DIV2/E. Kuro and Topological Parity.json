{"link": "https://codeforces.com//contest/979/problem/E", "problemId": "183087", "problem_idx": "E", "shortId": "979E", "contest_number": "979", "problem_submissions": {"E": [38239944, 38239626, 38239985, 38241605], "D": [38235368, 38234401, 38232573, 38240292, 38232946, 38238813, 38236674, 38234013, 38234028, 38242834, 38235224, 38238975, 38236273, 38233251, 38924559, 38232308, 38231709], "C": [38225119, 38222425, 38225946, 38230085, 38224078, 38228380, 38224768, 38225370, 38223169, 38226246, 38227575, 38228558, 38229693, 38227316, 38227594, 38232766, 38225714, 38226125], "B": [38223636, 38219953, 38246488, 38228424, 38221669, 38225321, 38237418, 38223126, 38229060, 38225443, 38231632, 38234671, 38223153, 38228913, 38349158, 38225310], "A": [38217437, 38220346, 38223788, 38219996, 38221134, 38219848, 38242600, 38216689, 38216875, 38216674, 38216872, 38217267, 38220684, 38217206, 38218341, 38218810, 38220203, 38217265]}, "name": "E. Kuro and Topological Parity", "statement": "Kuro has recently won the \"Most intelligent cat ever\" contest. The three\r\nfriends then decided to go to Katie\u2019s home to celebrate Kuro\u2019s winning.\r\nAfter a big meal, they took a small break then started playing\r\ngames.Kuro challenged Katie to create a game with only a white paper, a\r\npencil, a pair of scissors and a lot of arrows (you can assume that the\r\nnumber of arrows is infinite). Immediately, Katie came up with the game\r\ncalled .The paper is divided into n pieces enumerated from 1 to n. Shiro\r\nhas painted some pieces with some color. Specifically, the i-th piece\r\nhas color c_{i} where c_{i} = 0 defines black color, c_{i} = 1 defines\r\nwhite color and c_{i} = -1 means that the piece hasn\u2019t been colored\r\nyet.The rules of the game is simple. Players must put some arrows\r\nbetween some pairs of different pieces in such a way that for each\r\narrow, the number in the piece it starts from is less than the number of\r\nthe piece it ends at. Also, two different pieces can only be connected\r\nby one arrow. After that the players must choose the color (0 or 1) for\r\neach of the unpainted pieces. The score of a valid way of putting the\r\narrows and coloring pieces is defined as the number of paths of pieces\r\nof alternating colors. For example, [1\r\nto 0\r\nto 1\r\nto 0], [0\r\nto 1\r\nto 0\r\nto 1], [1], [0] are valid paths and will be counted. You can only travel\r\nfrom piece x to piece y if and only if there is an arrow from x to y.But\r\nKuro is not fun yet. He loves parity. Let\u2019s call his favorite parity p\r\nwhere p = 0 stands for \"even\" and p = 1 stands for \"odd\". He wants to\r\nput the arrows and choose colors in such a way that the score has the\r\nparity of p.It seems like there will be so many ways which satisfy Kuro.\r\nHe wants to count the number of them but this could be a very large\r\nnumber. Let\u2019s help him with his problem, but print it modulo 10^{9} + 7.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=57;\nconst LL mod=1e9+7;\n\nint n, p;\nint in[N];\n\nLL DP[N][N][N][N];\n\nLL add(LL &a, LL b){\n\ta=(a+b)%mod;\n}\n\nvoid modulo(LL &a){\n\ta%=mod;\n}\n\nint main(){\n\t\n\tscanf(\"%d%d\", &n, &p);\n\tFOR(i,1,n)\n\t\tscanf(\"%d\", &in[i]);\n\tDP[0][0][0][0]=1;\n\t\n\tLL res=0;\n\tFOR(i,0,n) FOR(j,0,n) FOR(l,0,n) FOR(k,0,n){\n\t\tint s=i+j+l+k;\n\t\tif (s==n && ((j+k)%2)==p)\n\t\t\tadd(res, DP[i][j][l][k]);\n\t\tif (s>=n)\n\t\t\tcontinue;\n\t\ts++;\n\t\tFOR(f,0,1){\n\t\t\tif (in[s]==(f^1))\n\t\t\t\tcontinue;\n\t\t\tif (DP[i][j][l][k])\n\t\t\tif (!f){\n\t\t\t\tLL chan=(1LL<<l)*(((1LL<<k)+1)/2);\n\t\t\t\tLL stay=(1LL<<l)*((1LL<<k)/2);\n\t\t\t\tmodulo(chan);\n\t\t\t\tmodulo(stay);\n\t\t\t\tchan*=(1LL<<(i+j));\n\t\t\t\tstay*=(1LL<<(i+j));\n\t\t\t\tmodulo(chan);\n\t\t\t\tmodulo(stay);\n\t\t\t\tadd(DP[i+1][j][l][k], DP[i][j][l][k]*stay);\n\t\t\t\tadd(DP[i][j+1][l][k], DP[i][j][l][k]*chan);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL chan=(1LL<<i)*(((1LL<<j)+1)/2);\n\t\t\t\tLL stay=(1LL<<i)*((1LL<<j)/2);\n\t\t\t\tmodulo(chan);\n\t\t\t\tmodulo(stay);\n\t\t\t\tchan*=(1LL<<(l+k));\n\t\t\t\tstay*=(1LL<<(l+k));\n\t\t\t\tmodulo(chan);\n\t\t\t\tmodulo(stay);\n\t\t\t\tadd(DP[i][j][l+1][k], DP[i][j][l][k]*stay);\n\t\t\t\tadd(DP[i][j][l][k+1], DP[i][j][l][k]*chan);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2400", "interactive": false}