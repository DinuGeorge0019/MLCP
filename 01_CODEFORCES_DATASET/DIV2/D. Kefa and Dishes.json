{
    "link": "https://codeforces.com//contest/580/problem/D",
    "problemId": "35998",
    "problem_idx": "D",
    "shortId": "580D",
    "contest_number": "580",
    "problem_submissions": {
        "E": [
            13169027,
            13165630,
            13172362,
            13172239,
            13276228,
            13276220,
            13181451,
            13180453
        ],
        "D": [
            13158152,
            13153446,
            13153124,
            13152837,
            13153644,
            13153078,
            13152233,
            13150734,
            13158863,
            13154097,
            13154459,
            13155410,
            13154153,
            13153936,
            13153904,
            13151772,
            13154328,
            13155366
        ],
        "C": [
            13152496,
            13147124,
            13149562,
            13149833,
            13149612,
            13149260,
            13148537,
            13148215,
            13150353,
            13147522,
            13151581,
            13150500,
            13149659,
            13151388,
            13150099,
            13149113,
            13149776,
            13150107
        ],
        "B": [
            13148061,
            13167252,
            13146021,
            13147235,
            13171070,
            13146699,
            13146714,
            13146413,
            13145854,
            13146150,
            13150066,
            13148456,
            13146468,
            13147058,
            13148187,
            13147219,
            13146687,
            13147097,
            13148044
        ],
        "A": [
            13145130,
            13166155,
            13143931,
            13143879,
            13144120,
            13143774,
            13143862,
            13143852,
            13143834,
            13144014,
            13143978,
            13143875,
            13144293,
            13145295,
            13145825,
            13143916,
            13144739,
            13143807
        ]
    },
    "name": "D. Kefa and Dishes",
    "statement": "When Kefa came to the restaurant and sat at a table, the waiter\r\nimmediately brought him the menu. There were dishes. Kefa knows that he\r\nneeds exactly dishes. But at that, he doesnâ€™t want to order the same\r\ndish twice to taste as many dishes as possible. Kefa knows that the -th\r\ndish gives him units of satisfaction. But some dishes do not go well\r\ntogether and some dishes go very well together. Kefa set to himself\r\nrules of eating food of the following type if he eats dish exactly\r\nbefore dish (there should be no other dishes between and ), then his\r\nsatisfaction level raises by . Of course, our parrot wants to get some\r\nmaximal possible satisfaction from going to the restaurant. Help him in\r\nthis hard task!\r\n",
    "solutions": [
        "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\n#include<bitset>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=18;\nint a[N],pp[N][N];\nlong long f[1<<18][N];\nint it_num(int x)\n{\n    int s=0;\n    while(x)\n    {\n        if (x % 2==1) s++;\n        x/=2;\n    }\n    return s;\n}\nint main() {\n    int n,m,k;\n    cin>>n>>m>>k;\n    memset(pp,0,sizeof(pp));\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=k;i++)\n    {\n        int p,q,t;\n        scanf(\"%d%d%d\",&p,&q,&t);\n        p--;q--;\n        pp[p][q]=t;\n    }\n    long long ans=0;\n    memset(f,0,sizeof(f));\n    for(int i=0;i<n;i++) f[1<<i][i]=a[i];\n    for(int mask=0;mask<(1<<n);mask++)\n        for(int t=0;t<n;t++)\n            if((mask & (1<<t)) !=0)\n            {\n                for(int i=0;i<n;i++)\n                    if((mask & (1<<i)) == 0)\n                    {\n                        int tmp=mask+(1<<i);\n                        f[tmp][i]=max(f[tmp][i],f[mask][t]+(long long)a[i]+(long long)pp[t][i]);\n                    }\n                if(it_num(mask) == m) ans=max(ans,f[mask][t]);\n            }\n    cout<<ans<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Kefa and Dishes.json",
    "editorial_link": "https://codeforces.com//blog/entry/20468",
    "editorial": "A two-dimensional DP will be used to solve the problem. The first\r\ndimention is the mask of already taken dishes, and the second the number\r\nof the last taken dish. We will go through all the zero bits of the\r\ncurrent mask for the transitions. We will try to put the one in them,\r\nand then update the answer for a new mask. The answer will consist of\r\nthe answer of the old mask, a dish value, which conforms to the added\r\nbit and the rule, that can be used. The final answer is the maximum of\r\nall the values of DP, where mask contains exactly ones. Asymptotics .\r\nSolution\r\n",
    "hint": []
}