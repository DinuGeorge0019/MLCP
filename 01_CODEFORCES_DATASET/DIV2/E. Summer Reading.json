{
    "link": "https://codeforces.com//contest/370/problem/E",
    "problemId": "4147",
    "problem_idx": "E",
    "shortId": "370E",
    "contest_number": "370",
    "problem_submissions": {
        "C": [
            5370412,
            5368730,
            5371522,
            5371990,
            5370195,
            5370131,
            5371258,
            5371358,
            5372807,
            5379034,
            5368672
        ],
        "D": [
            5369264,
            5370401,
            5370565,
            5371357,
            5372982,
            5372779,
            5373131,
            5372520,
            5372523,
            5370570,
            5370366,
            5371915,
            5371128,
            5372843,
            5372383,
            5373802
        ],
        "B": [
            5367928,
            5367560,
            5367818,
            5367866,
            5367916,
            5368321,
            5372838,
            5370234,
            5369841,
            5368420,
            5367832,
            5368440,
            5368950,
            5372070,
            5368698,
            5369739,
            5367644
        ],
        "A": [
            5367394,
            5369807,
            5367525,
            5367450,
            5367389,
            5367654,
            5369021,
            5369042,
            5374280,
            5368909,
            5367810,
            5367376,
            5367612,
            5368269,
            5373074,
            5367757,
            5368835,
            5367393
        ],
        "E": [
            5372646,
            5370095
        ]
    },
    "name": "E. Summer Reading",
    "statement": "At school Vasya got an impressive list of summer reading books. Unlike\r\nother modern schoolchildren, Vasya loves reading, so he read some book\r\neach day of the summer.As Vasya was reading books, he was making notes\r\nin the Reader\u2019s Diary. Each day he wrote the orderal number of the book\r\nhe was reading. The books in the list are numbered starting from 1 and\r\nVasya was reading them in the order they go in the list. Vasya never\r\nreads a new book until he finishes reading the previous one.\r\nUnfortunately, Vasya wasn\u2019t accurate and some days he forgot to note the\r\nnumber of the book and the notes for those days remained empty.As Vasya\r\nknows that the literature teacher will want to check the Reader\u2019s Diary,\r\nso he needs to restore the lost records. Help him do it and fill all the\r\nblanks. Vasya is sure that he spends at least two and at most five days\r\nfor each book. Vasya finished reading all the books he had started.\r\nAssume that the reading list contained many books. So many, in fact,\r\nthat it is impossible to read all of them in a summer. If there are\r\nmultiple valid ways to restore the diary records, Vasya prefers the one\r\nthat shows the maximum number of read books.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int N = 222222;\n\nint lower[N], upper[N];\nint n, a[N], le[N], ri[N];\n\nint main() {\n    \n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    lower[0] = upper[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        le[i] = n + 1;\n        ri[i] = -1;\n    }\n    \n    int maxNum = -1;\n    \n    for(int i = 1; i <= n; i++) \n        if (a[i]) {\n            if (a[i] < 1 || a[i] > n) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n            int x = a[i];\n            le[x] = min(le[x], i);\n            ri[x] = max(ri[x], i);\n            maxNum = max(maxNum, a[i]);\n        }\n    \n    if (maxNum == -1) {\n        if (n < 2) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", n / 2);\n            for(int i = 1; i <= n / 2; i++) {\n                a[i * 2 - 1] = a[i * 2] = i;\n            }\n            if (n % 2 == 1)\n                a[n] = a[n - 1];\n            for(int i = 1; i <= n; i++) {\n                printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n            }\n        }\n        \n        return 0;\n    }\n    \n    for(int i = 1; i <= n; i++) {\n        if (ri[i] == -1) {\n            lower[i] = lower[i - 1] + 2;\n            upper[i] = upper[i - 1] + 5;\n        } else {\n            int tmp = ri[i] - le[i] + 1;\n            if (tmp > 5) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n            \n            if (lower[i - 1] >= le[i] || ri[i] - upper[i - 1] > 5) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n            \n            lower[i] = max(ri[i], lower[i - 1] + 2);\n            upper[i] = min(le[i] + 4, upper[i - 1] + 5);\n        }\n    }\n    \n    int ans = 0;\n    \n    for(int i = maxNum; i <= n; i++) {\n        if (lower[i] <= n && upper[i] >= n)\n            ans = i;\n    }\n    \n    if (ans == 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    int nn = n;\n    \n    for(int i = ans; i >= 1; i--) {\n        for(int j = 2; j <= 5; j++) {\n            if (ri[i] != -1 && le[i] < nn - j + 1)\n                continue;\n            int tmp = nn - j;\n            bool flag = true; \n            if (lower[i - 1] <= tmp && tmp <= upper[i - 1]) {\n                for(int k = tmp + 1; k <= nn; k++)\n                    if (a[k] && a[k] != i)\n                        flag = false;\n                if (!flag)\n                    continue;\n                for(int k = tmp + 1; k <= nn; k++)\n                    a[k] = i;\n                nn = tmp;\n                break;\n            }\n        }\n    }\n    \n    for(int i = 1; i <= n; i++) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n    \n    return 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Summer Reading.json",
    "editorial_link": "https://codeforces.com//blog/entry/9866",
    "editorial": "For each book number that is in the sequence, find the leftmost and the\r\nrightmost position of this number. In other words, for each such book\r\nnumber we find a segment of positions that should consist of this\r\nnumber. If for some pair of numbers there segments intersect, it is\r\nimpossible to construct the answer. The same thing happens if some\r\nsegment has length more than 5. It is reasonable to separately handle\r\nthe case when all given numbers are zeroes. In this case, fill in the\r\nnumbers greedily, spending 2 days on each book (probably, except the\r\nlast one). So, we have some blocks of numbers and gaps between them.\r\nLets do the following DP: each state of DP is described by two values\r\n(): means the number of block (lets enumerate them consecutively), means\r\nhow far to the right will this block eventually extend (if there is a\r\ngap after this block, it is possible that we fill some prefix of this\r\ngap with the same book number that is in the block). It is clear that\r\nwill not exceed 5, so we actually can describe the state by values (),\r\nwhich may sound more convenient. So, the number of states is linear.\r\nLets say that is true if it it possible to correctly fill all the gaps\r\nthat come before the -th block, under condition that the -th block\r\nextends to the position , and is false otherwise. To calculate the value\r\nof , lets try to extend the -th block to the left in all (not so many)\r\npossible ways (to replace some number of consecutive zeroes that are in\r\nthe gap just before the -th block). Then, try to fix where the previous\r\nblock can actually end (fix the state , where is true, of course). To\r\nmake a transition in DP, we should check whether it possible or not to\r\nfill the rest of the gap between the -th block and the -th block. Lets\r\nsay that -th block consists of number , the -th block consists of number\r\n, and there are still unfilled positions in the gap. Than the gap can be\r\ncorrectly filled if and only if . If you understand this DP, it won t be\r\ndifficult for you to find out how to construct the answer from it.\r\n"
}