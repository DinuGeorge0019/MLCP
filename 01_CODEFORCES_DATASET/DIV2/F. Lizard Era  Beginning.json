{
    "link": "https://codeforces.com//contest/586/problem/F",
    "problemId": "37963",
    "problem_idx": "F",
    "shortId": "586F",
    "contest_number": "586",
    "problem_submissions": {
        "E": [
            13567845,
            13568877,
            13567853,
            13571593,
            13562355,
            13570559,
            13579749,
            13567129,
            13570139
        ],
        "D": [
            13563971,
            13564646,
            13563820,
            13563849,
            13568951,
            13565926,
            13563286,
            13563128,
            13565918,
            13569000,
            13562593,
            13568454,
            13565954,
            13567393,
            13563819,
            13565909,
            13564075,
            13560941,
            13564537
        ],
        "B": [
            13561164,
            13559370,
            13561077,
            13558098,
            13558769,
            13558957,
            13558122,
            13557083,
            13558517,
            13557741,
            13558248,
            13560292,
            13558220,
            13559476,
            13561469,
            13562240,
            13557548,
            13564661,
            13557987
        ],
        "C": [
            13559947,
            13561510,
            13560077,
            13560242,
            13565430,
            13561001,
            13561323,
            13561803,
            13560466,
            13563719,
            13560353,
            13561394,
            13595712,
            13558752,
            13585345,
            13584852
        ],
        "A": [
            13555951,
            13556306,
            13555953,
            13556124,
            13556417,
            13555955,
            13556118,
            13555916,
            13556066,
            13556106,
            13556370,
            13556409,
            13556782,
            13556040,
            13560781,
            13556168,
            13565723,
            13556286
        ],
        "F": [
            13577881,
            13572057,
            13572184,
            13570880,
            13588219,
            13595048,
            13570334,
            13571136,
            13601061
        ]
    },
    "name": "F. Lizard Era  Beginning",
    "statement": "In the game Lizard Era: Beginning the protagonist will travel with three\r\ncompanions: Lynn, Meliana and Worrigan. Overall the game has mandatory\r\nquests. To perform each of them, you need to take companions.The\r\nattitude of each of the companions to the hero is an integer. Initially,\r\nthe attitude of each of them to the hero of neutral and equal to 0. As\r\nthe hero completes quests, he makes actions that change the attitude of\r\nthe companions, whom he took to perform this task, in positive or\r\nnegative direction.Tell us what companions the hero needs to choose to\r\nmake their attitude equal after completing all the quests. If this can\r\nbe done in several ways, choose the one in which the value of resulting\r\nattitude is greatest possible.\r\n",
    "solutions": [
        "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\n#include<bitset>\n\nusing namespace std;\ntypedef long long LL;\nconst long long INF=1e18;\nmap<pair<long long,long long>,pair<long long,long long> >mm;\nlong long n,a[10000][3],pppp,s[3],ans,ww1,ww2;\nchar ch1[100],ch2[100];\nvoid dfs1(long long dep,pair<long long,long long> mask,long long lose,long long way)\n{\n    if (dep>pppp) \n    {\n        if (mm.find(mask)==mm.end() or mm[mask].first>lose)\n        {\n            mm[mask]=make_pair(lose,way);\n        }\n        return; \n    }\n    mask.first+=a[dep][0];\n    dfs1(dep+1,mask,lose+a[dep][0],way * 3 + 0);\n    mask.first-=a[dep][0];\n    \n    mask.first-=a[dep][1];\n    mask.second+=a[dep][1];\n    dfs1(dep+1,mask,lose+a[dep][1],way * 3 + 1);\n    mask.first+=a[dep][1];\n    mask.second-=a[dep][1];\n    \n    mask.second-=a[dep][2];\n    dfs1(dep+1,mask,lose+a[dep][2],way * 3 + 2);\n    mask.second+=a[dep][2];\n}\nvoid dfs2(long long dep,pair<long long,long long> mask,long long lose,long long way)\n{\n    if (dep==pppp)\n    {\n        long long t1,t2;\n        t1=s[0]-s[1]-mask.first;\n        t2=s[1]-s[2]-mask.second;\n        pair<long long,long long> p=make_pair(t1,t2);\n        if (mm.find(p)!=mm.end() && mm[p].first + lose<ans)\n        {\n            ans=mm[p].first + lose;\n            ww1=mm[p].second;\n            ww2=way;\n        }\n        return;\n    }\n    mask.first+=a[dep][0];\n    dfs2(dep-1,mask,lose+a[dep][0],way * 3 + 0);\n    mask.first-=a[dep][0];\n    \n    mask.first-=a[dep][1];\n    mask.second+=a[dep][1];\n    dfs2(dep-1,mask,lose+a[dep][1],way * 3 + 1);\n    mask.first+=a[dep][1];\n    mask.second-=a[dep][1];\n    \n    mask.second-=a[dep][2];\n    dfs2(dep-1,mask,lose+a[dep][2],way * 3 + 2);\n    mask.second+=a[dep][2];\n}\nint main() {\n    long long n;\n    cin>>n;\n    ans=INF;\n    s[0]=s[1]=s[2]=0;\n    for(long long i=1;i<=n;i++)\n        for(long long j=0;j<3;j++)\n        {\n            scanf(\"%I64d\",&a[i][j]);\n            s[j]+=a[i][j];\n        }\n    pppp=n/2;\n    pair<long long,long long> t;\n    t.first=t.second=0;\n    dfs1(1,t,0,0);\n    dfs2(n,t,0,0);\n    if (ans==INF)\n    {\n        puts(\"Impossible\");\n        return 0;\n    }\n    for(long long i=pppp;i>=1;i--)\n    {\n        if (ww1 % 3==0)\n        {\n            ch1[i]='M';\n            ch2[i]='W';\n        }else\n        if (ww1 % 3==1)\n        {\n            ch1[i]='L';\n            ch2[i]='W';\n        }else\n        {\n            ch1[i]='L';\n            ch2[i]='M';\n        }\n        ww1/=3;\n    }\n    for(long long i=pppp+1;i<=n;i++)\n    {\n        if (ww2 % 3==0)\n        {\n            ch1[i]='M';\n            ch2[i]='W';\n        }else\n        if (ww2 % 3==1)\n        {\n            ch1[i]='L';\n            ch2[i]='W';\n        }else\n        {\n            ch1[i]='L';\n            ch2[i]='M';\n        }\n        ww2/=3;\n    }\n    for(long long i=1;i<=n;i++) cout<<ch1[i]<<ch2[i]<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "meet-in-the-middle"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Lizard Era  Beginning.json",
    "editorial_link": "https://codeforces.com//blog/entry/20898",
    "editorial": "To solve the problem we will use meet-in-the-middle approach. For  we should consider all  variants. Let in some variant approval values of three companions are a,?b,?c respectively. If we will consider some variant from other half (there are  of them) and a',?b',?c' approval values, then to ``merge'' such two parts correctly, two conditions a?-?b?=?b'?-?a' ? b?-?c?=?c'?-?b' must be true (a?+?a'?=?b?+?b'?=?c?+?c' is true), and the value we are maximizing is a?+?a'.\n\nThis way, to solve the task one could consider every variant from the first half and store for every possible pair (a?-?b,?b?-?c) the maximum a value achievable (using, for example, the  structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b'?-?a',?c'?-?b') pair in the structure to get the maximum a value if possible and update answer with a?+?a' value. Answer restoring is pretty same to the algorithm above.\n\nSuch solution has  complexity.",
    "hint": []
}