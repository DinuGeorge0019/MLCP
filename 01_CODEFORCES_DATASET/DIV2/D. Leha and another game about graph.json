{
    "link": "https://codeforces.com//contest/841/problem/D",
    "problemId": "118952",
    "problem_idx": "D",
    "shortId": "841D",
    "contest_number": "841",
    "problem_submissions": {
        "E": [
            29577328,
            29576658
        ],
        "D": [
            29573001,
            29573684,
            29573988,
            29567705,
            29568708,
            29563027,
            29619966,
            29619959,
            29570707,
            29579930,
            29635245,
            29578546,
            29570875,
            29573682,
            29571760,
            29573458,
            29572414,
            29573926,
            29573655,
            29572331,
            29574140,
            29574859
        ],
        "C": [
            29568878,
            29565561,
            29563832,
            29563617,
            29560709,
            29568671,
            29561287,
            29566153,
            29562441,
            29563021,
            29564839,
            29566123,
            29561033,
            29567576,
            29565786,
            29566018,
            29563013,
            29569683,
            29564547,
            29563613
        ],
        "B": [
            29566528,
            29560935,
            29560133,
            29558137,
            29559052,
            29565221,
            29558422,
            29561026,
            29559272,
            29559733,
            29560675,
            29562151,
            29563589,
            29559692,
            29560534,
            29559741,
            29558805,
            29561017,
            29560298,
            29558218
        ],
        "A": [
            29564846,
            29556330,
            29556266,
            29556257,
            29556527,
            29557299,
            29556212,
            29556530,
            29556354,
            29556255,
            29556386,
            29557394,
            29556831,
            29556353,
            29556868,
            29557136,
            29556377,
            29556612,
            29557465,
            29556310
        ]
    },
    "name": "D. Leha and another game about graph",
    "statement": "Leha plays a computer game, where is on each level is given a connected\r\ngraph with vertices and edges. Graph can contain multiple edges, but can\r\nnot contain self loops. Each vertex has an integer , which can be equal\r\nto , or . To pass the level, he needs to find a good subset of edges of\r\nthe graph or say, that it doesn\u2019t exist. Subset is called good , if by\r\nby leaving only edges from this subset in the original graph, we obtain\r\nthe following: for every vertex i, = - 1 or it\u2019s degree modulo 2 is\r\nequal to . Leha wants to pass the game as soon as possible and ask you\r\nto help him. In case of multiple correct answers, print any of them.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define N 500001\nusing namespace std;\nint fa[N],deep[N],sig[N],f[N];\nbool bz[N];\nint n,m;\nint u;\nint g[N],b[N],a[N*2][2],d[N],ans[N];\nvoid ins(int x,int y){\n\tstatic int sum=1;\n\ta[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x){\n\tif (b[x]==-1)u=x;\n\telse\n\t\tif (b[x]==1)d[++d[0]]=x;\n\tbz[x]=1;\n\tdeep[x]++;\n\tfor (int i=g[x];i;i=a[i][1])\n\t\tif (!bz[a[i][0]]){\n\t\t\tdeep[a[i][0]]=deep[x];\n\t\t\tfa[a[i][0]]=x;\n\t\t\tsig[a[i][0]]=i/2;\n\t\t\tdfs(a[i][0]);\n\t\t}\n}\nbool cmp(int x,int y){\n\treturn deep[x]>deep[y];\n}\nint main(){\n\t//freopen(\"d.in\",\"r\",stdin);\n\t//freopen(\"d.out\",\"w\",stdout);\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&b[i]);\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tins(x,y),ins(y,x);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!bz[i]){\n\t\t\tu=-1;\n\t\t\td[0]=0;\n\t\t\tdfs(i);\n\t\t\tif ((d[0]&1)&&u==-1){\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int j=1;j<=d[0];j++)f[d[j]]^=1;\n\t\t\tif (d[0]&1)f[u]^=1;\n\t\t}\n\tfor (int i=1;i<=n;i++)d[i]=i;\n\tsort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tf[fa[d[i]]]^=f[d[i]];\n\t\tif (f[d[i]]&&sig[d[i]])ans[++ans[0]]=sig[d[i]];\n\t}\n\tfor (int i=0;i<=ans[0];i++)printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Leha and another game about graph.json",
    "editorial_link": "https://codeforces.com/blog/entry/53943?locale=en",
    "editorial": "Model solution uses the fact that the graph is connected.\nWe'll prove that \"good\" subset exists iff ?-?1 values among di can be changed to 0?/?1 so that  is even. If the sum can only be odd, there is no solution obviously (every single valid graph has even sum of degrees). Now we'll show how to build the answer for any case with even sum.\nFirst of all, change all ?-?1 values so that the sum becomes even.\nThen let's find any spanning tree and denote any vertex as the root. The problem is actually much easier now.\nLet's process vertices one by one, by depth: from leaves to root. Let's denote current vertex as cur.\nThere are two cases:\n1) dcur?=?0\nIn this case we ignore the edge from cur to parentcur and forget about cur. Sum remains even.\n2) dcur?=?1\nIn this case we add the edge from cur to parentcur to the answer, change dparentcur to the opposite value and forget about cur. As you can see, sum changed its parity when we changed dparentcur, but then it changed back when we discarded cur. So, again, sum remains even.\nUsing this simple manipulations we come up with final answer."
}