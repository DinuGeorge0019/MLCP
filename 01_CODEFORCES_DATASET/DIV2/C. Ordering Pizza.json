{"link": "https://codeforces.com//contest/867/problem/C", "problemId": "125349", "problem_idx": "C", "shortId": "867C", "contest_number": "867", "problem_submissions": {"D": [30884718, 30969715, 30908906], "E": [30880295, 30879986, 30881111, 30877764, 30881335, 30882295, 30883343, 30879932, 30880853, 30885039, 30883442, 30879026, 30879346, 30878760, 30879361, 30879208, 30881707, 30881486, 30883064], "C": [30879669, 30878960, 30878088, 30883610, 30879422, 30877573, 30877883, 30885041, 30885195, 30880421, 30881172], "B": [30876237, 30876507, 30875069, 30876283, 30877011, 30875260, 30875540, 30874844, 30874882, 30876892, 30881931, 30874579, 30875739, 30876833, 30876524, 30876752, 30874913, 30878747, 30875046], "A": [30873015, 30872603, 30873110, 30873218, 30872680, 30873140, 30873066, 30873137, 30873548, 30875168, 30873452, 30872738, 30874021, 30872548, 30873686, 30873869, 30872699, 30874649, 30873108]}, "name": "C. Ordering Pizza", "statement": "It\u2019s another Start[c]up finals, and that means there is pizza to order\r\nfor the onsite contestants. There are only 2 types of pizza (obviously\r\nnot, but let\u2019s just pretend for the sake of the problem), and all pizzas\r\ncontain exactly slices.It is known that the -th contestant will eat\r\nslices of pizza, and gain happiness for each slice of type 1 pizza they\r\neat, and happiness for each slice of type 2 pizza they eat. We can order\r\nany number of type 1 and type 2 pizzas, but we want to buy the minimum\r\npossible number of pizzas for all of the contestants to be able to eat\r\ntheir required number of slices. Given that restriction, what is the\r\nmaximum possible total happiness that can be achieved?\r\n", "solutions": ["#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\n#include <utility>\n#include <stack>\n#include <cstring>\n#include <bitset>\n#include <deque>\n#include <string>\n#include <list>\n#include <cstdlib>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 100000 + 100;\ntypedef long long ll;\ntypedef long double ld;\nll N, S;\nstruct node\n{\n\tll s, a, b;\n\tbool operator<(const node & rhs) const\n\t{\n\t\treturn a - b < rhs.a - rhs.b;\n\t}\n}ns[maxn];\nint main()\n{\n\twhile (~scanf(\"%lld%lld\", &N, &S))\n\t{\n\t\tll tot = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tscanf(\"%lld%lld%lld\", &ns[i].s, &ns[i].a, &ns[i].b);\n\t\t\ttot += ns[i].s;\n\t\t}\n\t\tsort(ns, ns + N);\n\t\tll ans = 0;\n\t\tll num = (tot + S - 1) / S;\n\t\tll las = (num * S) - tot;\n\t\tll cur = 0;\n\t\tll rem = 0;\n\t\tll pre = 0;\n\t\tint type = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (ns[i].b >= ns[i].a)\n\t\t\t{\n\t\t\t\tif (rem >= ns[i].s)\n\t\t\t\t{\n\t\t\t\t\trem -= ns[i].s;\n\t\t\t\t\tpre += (ns[i].a - ns[i].b) * ns[i].s;\n\t\t\t\t\tans += ns[i].b * ns[i].s;\n\t\t\t\t\tns[i].s = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans += ns[i].b * rem;\n\t\t\t\t\tns[i].s -= rem;\n\t\t\t\t\tpre = rem = 0;\n\t\t\t\t}\n\t\t\t\tint tmp = (ns[i].s) / S;\n\t\t\t\tns[i].s -= tmp * S;\n\t\t\t\tans += ns[i].b * tmp * S;\n\t\t\t\tpre = 0;\n\t\t\t\trem = 0;\n\t\t\t\tif (ns[i].s)\n\t\t\t\t{\n\t\t\t\t\tpre = (ns[i].a - ns[i].b) * ns[i].s;\n\t\t\t\t\tans += ns[i].b * ns[i].s;\n\t\t\t\t\trem = S - ns[i].s;\n\t\t\t\t\tns[i].s = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (type)\n\t\t\t\t{\n\t\t\t\t\tans += ns[i].s * ns[i].a;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trem -= las;\n\t\t\t\trem = max(rem, 0LL);\n\t\t\t\tlas = 0;\n\t\t\t\tif (rem == 0)\n\t\t\t\t{\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tans += ns[i].s * ns[i].a;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tif (rem >= ns[i].s)\n\t\t\t\t\t{\n\t\t\t\t\t\trem -= ns[i].s;\n\t\t\t\t\t\tpre += (ns[i].a - ns[i].b) * ns[i].s;\n\t\t\t\t\t\tans += ns[i].s * ns[i].b;\n\t\t\t\t\t\tns[i].s = 0;\n\t\t\t\t\t\tif (pre > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\tans += pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tns[i].s -= rem;\n\t\t\t\t\t\tans += ns[i].b * rem;\n\t\t\t\t\t\tpre += (ns[i].a - ns[i].b) * rem;\n\t\t\t\t\t\trem = 0;\n\t\t\t\t\t\tif (pre > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans += pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans += ns[i].s * ns[i].a;\n\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"], "input": "", "output": "", "tags": ["greedy", "implementation", "sortings", "ternary search"], "dificulty": "1900", "interactive": false}