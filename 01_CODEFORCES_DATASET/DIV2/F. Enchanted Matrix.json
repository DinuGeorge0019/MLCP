{"link": "https://codeforces.com//contest/1493/problem/F", "problemId": "916233", "problem_idx": "F", "shortId": "1493F", "contest_number": "1493", "problem_submissions": {"E": [109300691, 109266485, 109271539, 109262971, 109276076, 109269136, 109397471, 109327948, 109273809, 109280460, 109407951, 109291144], "B": [109260545, 109239746, 109254991, 109270234, 109241243, 109242522, 109253609, 109252334, 109327832, 109233296, 109238405, 109249942, 109232284, 109235737, 109235442, 109237822, 109237430, 109234756, 109237333, 109236735], "C": [109257705, 109251136, 109251134, 109246054, 109250920, 109266513, 109273162, 109327814, 109245427, 109240048, 109234896, 109238348, 109245265, 109246216, 109245882, 109254906, 109244489, 109256285, 109246006], "F": [109251446, 109300451, 109300023, 109263743, 109278727, 109492473, 109395367, 109755119], "D": [109250583, 109257293, 109245697, 109282268, 109255131, 109236733, 109257985, 109245022, 109241096, 109327857, 109262894, 109249582, 109243883, 109253883, 109249816, 109255048, 109252679, 109247391, 109256541, 109248836, 109257345], "A": [109228407, 109230343, 109243099, 109232737, 109227629, 109231368, 109228074, 109228388, 109327785, 109227973, 109230330, 109252518, 109227990, 109230461, 109228220, 109228782, 109229679, 109227822, 109229042, 109229707]}, "name": "F. Enchanted Matrix", "statement": "There exists a matrix a of size n\r\ntimes m (n rows and m columns), you know only numbers n and m. The rows\r\nof the matrix are numbered from 1 to n from top to bottom, and columns\r\nof the matrix are numbered from 1 to m from left to right. The cell on\r\nthe intersection of the x-th row and the y-th column is denoted as (x,\r\ny).You are asked to find the number of pairs (r, c) (1\r\nle r\r\nle n, 1\r\nle c\r\nle m, r is a divisor of n, c is a divisor of m) such that if we split\r\nthe matrix into rectangles of size r\r\ntimes c (of height r rows and of width c columns, each cell belongs to\r\nexactly one rectangle), all those rectangles are pairwise equal.You can\r\nuse queries of the following type: h w i_1 j_1 i_2 j_2 (1\r\nle h\r\nle n, 1\r\nle w\r\nle m, 1\r\nle i_1, i_2\r\nle n, 1\r\nle j_1, j_2\r\nle m) to check if subrectangles of height h rows and of width w columns\r\nof matrix a are equal or not. The upper left corner of the first\r\nrectangle is (i_1, j_1). The upper left corner of the second rectangle\r\nis (i_2, j_2). Subrectangles overlap, if they have at least one mutual\r\ncell. If the subrectangles in your query have incorrect coordinates (for\r\nexample, they go beyond the boundaries of the matrix) or overlap, your\r\nsolution will be considered incorrect. You can use at most 3\r\ncdot\r\nleft\r\nlfloor{\r\nlog_2{(n+m)} }\r\nright\r\nrfloor queries. All elements of the matrix a are fixed before the start\r\nof your program and do not depend on your queries.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,\"r\",stdin)\n#define Fout(s) freopen(s,\"w\",stdout)\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\n//#define int long long\nconst int P=998244353; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline void fprint(const vector<int> &f) {for(int i=0;i<(int)f.size();i++) fprintf(stderr,\"%d \",f[i]); fprintf(stderr,\"\\n\");}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\nint n,m;\nint query(int w,int h,int x1,int y1,int x2,int y2) {\n\tprintf(\"? %d %d %d %d %d %d\\n\",w,h,x1,y1,x2,y2); fflush(stdout);\n\tint ans; scanf(\"%d\",&ans);\n\treturn ans;\n}\nint lcm(int x,int y) {return x/__gcd(x,y)*y;}\nint qry1(int go,int len) {\n\tint l=1,r=len;\n\twhile(len>1) {\n\t\tint cur=len/2;\n\t\tif(!query(go*cur,m,(l-1)*go+1,1,(r-cur)*go+1,1)) return 0;\n\t\tlen=(len+1)/2,r-=cur;\n\t}\n\treturn 1;\n}\nint get1(int n) {\n\tint ans=1,tmp=n;\n\tfor(int i=2;i<=n;i++) {\n\t\tif(tmp%i==0) {\n\t\t\tint cnt=1,B=n/i;\n\t\t\twhile(tmp%i==0) {\n\t\t\t\tif(!qry1(B,i)) break;\n\t\t\t\tcnt++,B/=i,tmp/=i;\n\t\t\t}\n\t\t\twhile(tmp%i==0) tmp/=i;\n\t\t\tans*=cnt;\n\t\t}\n\t}\n\treturn ans;\n}\nint qry2(int go,int len) {\n\tint l=1,r=len;\n\twhile(len>1) {\n\t\tint cur=len/2;\n\t\tif(!query(n,go*cur,1,(l-1)*go+1,1,(r-cur)*go+1)) return 0;\n\t\tlen=(len+1)/2,r-=cur;\n\t}\n\treturn 1;\n}\nint get2(int n) {\n\tint ans=1,tmp=n;\n\tfor(int i=2;i<=n;i++) {\n\t\tif(tmp%i==0) {\n\t\t\tint A=1,B=n/i;\n\t\t\twhile(tmp%i==0) {\n\t\t\t\tif(!qry2(B,i)) break;\n\t\t\t\tA++,B/=i,tmp/=i;\n\t\t\t}\n\t\t\twhile(tmp%i==0) tmp/=i;\n\t\t\tans*=A;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tcin>>n>>m;\n\tint ans=get1(n)*get2(m);\n\tprintf(\"! %d\\n\",ans);\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/\n"], "input": "", "output": "", "tags": ["bitmasks", "interactive", "number theory"], "dificulty": "2600", "interactive": false}