{
    "link": "https://codeforces.com//contest/667/problem/D",
    "problemId": "57421",
    "problem_idx": "D",
    "shortId": "667D",
    "contest_number": "667",
    "problem_submissions": {
        "D": [
            17578505,
            17578570,
            17579983,
            17579852,
            17581346,
            17579873,
            17581494,
            17581266,
            17580319,
            17581259,
            17581685,
            17583097,
            17581442,
            17581402,
            17579446,
            17581355,
            17583002,
            17580142
        ],
        "C": [
            17573875,
            17572689,
            17574596,
            17575127,
            17573397,
            17573218,
            17573452,
            17575098,
            17575527,
            17575043,
            17576597,
            17575985,
            17576939,
            17575629,
            17580783,
            17576852,
            17576973,
            17576127
        ],
        "B": [
            17571142,
            17570505,
            17570987,
            17571612,
            17570711,
            17570822,
            17569944,
            17569925,
            17572245,
            17570880,
            17571749,
            17571220,
            17573489,
            17572815,
            17571948,
            17572494,
            17582197
        ],
        "A": [
            17569800,
            17569752,
            17569862,
            17572567,
            17569957,
            17570123,
            17569662,
            17569643,
            17571389,
            17569984,
            17569766,
            17570035,
            17570122,
            17570638,
            17571301,
            17570534,
            17583219
        ]
    },
    "name": "D. World Tour",
    "statement": "A famous sculptor Cicasso goes to a world tour!Well, it is not actually\r\na world-wide. But not everyone should have the opportunity to see works\r\nof sculptor, shouldn\u2019t he? Otherwise there will be no any exclusivity.\r\nSo Cicasso will entirely hold the world tour in his native country\r\nBerland.Cicasso is very devoted to his work and he wants to be\r\ndistracted as little as possible. Therefore he will visit only four\r\ncities. These cities will be different, so no one could think that he\r\nhas \"favourites\". Of course, to save money, he will chose the shortest\r\npaths between these cities. But as you have probably guessed, Cicasso is\r\na weird person. Although he doesn\u2019t like to organize exhibitions, he\r\nlikes to travel around the country and enjoy its scenery. So he wants\r\nthe total distance which he will travel to be as large as possible.\r\nHowever, the sculptor is bad in planning, so he asks you for help. There\r\nare cities and one-way roads in Berland. You have to choose four\r\ndifferent cities, which Cicasso will visit and also determine the order\r\nin which he will visit them. So that the total distance he will travel,\r\nif he visits cities in your order, starting from the first city in your\r\nlist, and ending in the last, choosing each time the shortest route\r\nbetween a pair of cities will be the largest. Note that intermediate\r\nroutes may pass through the cities, which are assigned to the tour, as\r\nwell as pass twice through the same city. For example, the tour can look\r\nlike that: . Four cities in the order of visiting marked as overlines:\r\n.Note that Berland is a high-tech country. So using nanotechnologies all\r\nroads were altered so that they have the same length. For the same\r\nreason moving using regular cars is not very popular in the country, and\r\nit can happen that there are such pairs of cities, one of which\r\ngenerally can not be reached by car from the other one. However, Cicasso\r\nis very conservative and cannot travel without the car. Choose cities so\r\nthat the sculptor can make the tour using only the automobile. It is\r\nguaranteed that it is always possible to do.\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:256000000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define TASK \"\"\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define for1(i, n) for (int i = 1; i <= (int)n; i++)\n#define forq(i, s, t) for (int i = s; i <= (int)t; i++)\n#define ford(i, s, t) for (int i = s; i >= (int)t; i--)\n#define mk make_pair\n#define pk\tpush_back\n#define all(v) v.begin(), v.end()\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n\nconst double EPS = 1e-15;\nconst double PI = acos(-1.0);\nconst int MAXN = (int)3e3 + 7;\nconst int INF = (int)1e9 + 7;\nconst ll LINF = (ll)2e18 + 7;\nconst int MOD = (int)1e9 + 7;\nconst ull P = 239017;\nconst ull MM = (ull)2147482661;\n\t\nint solve();\n\nint main()\n{\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tfreopen(\"test.txt\", \"w\", stderr);\n\tdouble tstart = TIME;\n#else\n\t//freopen(TASK\".in\", \"r\", stdin), freopen(TASK\".out\", \"w\", stdout);\n#endif\n\treturn solve();\n}\n\n\nint n, m;\nvi g[MAXN], gr[MAXN];\nvector<pii> order[MAXN], orderr[MAXN];\nint matr[MAXN][MAXN];\n\nvoid bfs(int v, vi gg[], vector<pii> &vec, bool ok) {\n\tvector<int> d(n + 1, INF);\n\td[v] = 0;\n\tqueue<int> q;\n\tq.push(v);\n\twhile (!q.empty()) {\n\t\tint curv = q.front();\n\t\tq.pop();\n\t\tfor (int to : gg[curv]) {\n\t\t\tint nd = d[curv] + 1;\n\t\t\tif (d[to] > nd) {\n\t\t\t\td[to] = nd;\n\t\t\t\tif (ok) matr[v][to] = nd;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor1(i, n) {\n\t\tvec.pk({ d[i], i });\n\t}\n\tsort(all(vec));\n\twhile (!vec.empty() && vec.back().first >= INF) {\n\t\tvec.pop_back();\n\t}\n\treverse(all(vec));\n}\n\nint solve()\n{\n\tcin >> n >> m;\n\tforn(i, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pk(v);\n\t\tgr[v].pk(u);\n\t}\n\n\tfor1(i, n) {\n\t\tfor1(j, n) {\n\t\t\tmatr[i][j] = INF;\n\t\t}\n\t\tmatr[i][i] = 0;\n\t}\n\n\tfor1(v, n) {\n\t\tbfs(v, g, order[v], 1);\n\t\tbfs(v, gr, orderr[v], 0);\n\t}\n\n\tint answer = 0;\n\tvi vans;\n\tfor1(u, n) {\n\t\tfor1(v, n) {\n\t\t\tif (u != v) {\n\t\t\t\tforn(i, 4) {\n\t\t\t\t\tif (orderr[u].size() > i) {\n\t\t\t\t\t\tforn(j, 4) {\n\t\t\t\t\t\t\tif (order[v].size() > j) {\n\t\t\t\t\t\t\t\tint u2 = orderr[u][i].second;\n\t\t\t\t\t\t\t\tint du = orderr[u][i].first;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint v2 = order[v][j].second;\n\t\t\t\t\t\t\t\tint dv = order[v][j].first;\n\n\t\t\t\t\t\t\t\tint sum = du + matr[u][v] + dv;\n\t\t\t\t\t\t\t\tif (sum < INF && sum > answer) {\n\t\t\t\t\t\t\t\t\tset<int> mset;\n\t\t\t\t\t\t\t\t\tmset.insert(u), mset.insert(v), mset.insert(u2), mset.insert(v2);\n\t\t\t\t\t\t\t\t\tif (mset.size() == 4) {\n\t\t\t\t\t\t\t\t\t\tanswer = sum;\n\t\t\t\t\t\t\t\t\t\tvans = { u2, u, v, v2 };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x : vans) {\n\t\tcout << x << ' ';\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. World Tour.json",
    "editorial_link": "https://codeforces.com//blog/entry/44622",
    "editorial": "You are given the oriented graph, find four distinct vertices such that\r\neach vertex if reachable from previous and the sum of shortest paths\r\nbetween consequitive vertices is as large as possible. First let\u00e2\u0080\u0099s run a\r\nBFS from each vertex and find three most distant vertices over given\r\ngraph and its reverse. Afterwards loop through each possible and .\r\nHaving them fixed, loop through among three most distant vertices from\r\nin the reversed graph and through among three most distant vertices from\r\nin tie initial graph. This is sufficient, because if we\u00e2\u0080\u0099ve fixed and and\r\nis not one of three furthest from then we could replace it with one of\r\nthem and improve the answer.\r\n"
}