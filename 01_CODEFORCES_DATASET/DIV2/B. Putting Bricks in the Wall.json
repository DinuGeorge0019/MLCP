{
    "link": "https://codeforces.com//contest/1421/problem/B",
    "problemId": "763577",
    "problem_idx": "B",
    "shortId": "1421B",
    "contest_number": "1421",
    "problem_submissions": {
        "E": [
            95894390,
            95897364,
            95896435,
            95890539,
            95992885,
            96032464,
            95960888,
            95899400
        ],
        "D": [
            95871709,
            95861267,
            95879423,
            95894755,
            95871704,
            95872756,
            95872599,
            95874589,
            95875351,
            95876553,
            95875903,
            95874887,
            95874932,
            95876575,
            95875075,
            95872464,
            95875457,
            95901124,
            95900956,
            95877542
        ],
        "B": [
            95869646,
            95869234,
            95864293,
            95863175,
            95860152,
            95861589,
            95869345,
            95861607,
            95862906,
            95862340,
            95863307,
            95861094,
            95864173,
            95860695,
            95863889,
            95864493,
            95862062,
            95861398
        ],
        "C": [
            95868136,
            95871765,
            95866274,
            95868511,
            95867450,
            95867807,
            95865115,
            95865747,
            95867493,
            95867265,
            95868458,
            95867762,
            95869507,
            95869832,
            95870224,
            95865361,
            95865425,
            95869153
        ],
        "A": [
            95860954,
            95862603,
            95857167,
            95856436,
            95856303,
            95856722,
            95856474,
            95856404,
            95859234,
            95857052,
            95856721,
            95856373,
            95856800,
            95856207,
            95856312,
            95856260,
            95856810,
            95856671
        ]
    },
    "name": "B. Putting Bricks in the Wall",
    "statement": "Roger Waters has a square grid of size n\r\ntimes n and he wants to traverse his grid from the upper left (1,1)\r\ncorner to the lower right corner (n,n). Waters can move from a square to\r\nany other square adjacent by a side, as long as he is still in the grid.\r\nAlso except for the cells (1,1) and (n,n) every cell has a value 0 or 1\r\nin it.Before starting his traversal he will pick either a 0 or a 1 and\r\nwill be able to only go to cells values in which are equal to the digit\r\nhe chose. The starting and finishing cells (1,1) and (n,n) are exempt\r\nfrom this rule, he may go through them regardless of picked digit.\r\nBecause of this the cell (1,1) takes value the letter ” and the cell\r\n(n,n) takes value the letter ”.For example, in the first example test\r\ncase, he can go from (1, 1) to (n, n) by using the zeroes on this path:\r\n(1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (3, 4), (4, 4)The rest of the\r\nband (Pink Floyd) wants Waters to not be able to do his traversal, so\r\nwhile he is not looking they will in the grid (from 0 to 1 or vice\r\nversa). They are afraid they will not be quick enough and asked for your\r\nhelp in choosing the cells. .We can show that there always exists a\r\nsolution for the given constraints.Also note that Waters will pick his\r\ndigit of the traversal after the band has changed his grid, so he must\r\nnot be able to reach (n,n) no matter what digit he picks.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\nchar s[505][505];\nint main(){\n\tint t, n;\n\tfor(cin >> t; t--;) {\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n ; i ++) cin >> s[i];\n\t\tif(s[0][1] == s[1][0]) {\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tif(s[0][1] != s[n - 1][n - 2]) {\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << 2 << endl;\n\t\t\t\t\tcout << \"1 2\" << endl;\n\t\t\t\t\tcout << \"2 1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == s[0][1]) {\n\t\t\t\t\tcout << n << ' ' << n - 1 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << n - 1<< ' ' << n << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[0][1] == s[n - 1][n - 2]) {\n\t\t\t\t\tcout << \"1 2\" << endl;\n\t\t\t\t}\n\t\t\t\telse cout << \"2 1\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 2 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == '1') cout << n << ' ' << n - 1 << endl;\n\t\t\t\telse cout << n - 1 << \" \" << n << endl;\n\t\t\t\tif(s[0][1] == '0') cout << \"1 2\" << endl;\n\t\t\t\telse cout << \"2 1\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Putting Bricks in the Wall.json",
    "editorial_link": "https://codeforces.com//blog/entry/83761",
    "editorial": "SolutionIf we pick the neighbours of to be we can make the neighbours of\r\nand there would be no way to go from to . But this requires in the worst\r\ncase switches, which is not good enough. Luckily, in order to get down\r\nto switches we only have to consider the other way around, making the\r\nsquares neighboring become and the squares neighboring . There must be a\r\nsolution of the two with at most two switches and you wonât get from to\r\nsince youâre forced to pick (or ) and canât get past the neighbours of\r\nwhich are opposite.\r\n",
    "hint": [
        "Hint It's hard to use the two valuable switches somewhere in the middle of the matrix, a much wiser choice would be to somehow block the cell or the cell. Perhaps you can set both neighbours of to to force Roger to pick ."
    ]
}