{
    "link": "https://codeforces.com//contest/1798/problem/A",
    "problemId": "1849267",
    "problem_idx": "A",
    "shortId": "1798A",
    "contest_number": "1798",
    "problem_submissions": {
        "F": [
            199301449,
            199635259,
            199378902,
            199319392,
            199574998,
            200590796,
            199735470,
            201129046,
            199317594
        ],
        "E": [
            199292979,
            199351345,
            199287102,
            199284185,
            199288971,
            199287988,
            199287959,
            199291669,
            199576167,
            199283535,
            199289650,
            199290902,
            199290821,
            199293377,
            199290100,
            199289126,
            199294280,
            199294488,
            199296355,
            199291720,
            199292702,
            199291551
        ],
        "C": [
            199282234,
            199260342,
            199262167,
            199263273,
            199268067,
            199264515,
            199261766,
            199308981,
            199268218,
            199266685,
            199267420,
            199260005,
            199259528,
            199264427,
            199273339,
            199266427,
            199263028,
            199263300,
            199265190,
            199268521,
            199269803
        ],
        "D": [
            199278441,
            199265876,
            199269760,
            199267498,
            199271957,
            199278028,
            199268206,
            199270707,
            199275816,
            199273016,
            199267038,
            199269245,
            199274308,
            199265125,
            199274313,
            199269059,
            199272118,
            199273321,
            199275125,
            199279668
        ],
        "B": [
            199256261,
            199253517,
            199260386,
            199254659,
            199254149,
            199255531,
            199254513,
            199253333,
            199254612,
            199260900,
            199256259,
            199253472,
            199256316,
            199258434,
            199255694,
            199256525,
            199257662,
            199261042,
            199260517
        ],
        "A": [
            199251141,
            199251302,
            199252305,
            199251756,
            199251041,
            199252000,
            199251140,
            199251087,
            199251123,
            199252263,
            199256364,
            199250912,
            199252253,
            199253426,
            199251686,
            199251495,
            199253540,
            199253141,
            199252510
        ]
    },
    "name": "A. Showstopper",
    "statement": "You are given two arrays a_1, a_2,\r\nldots, a_n and b_1, b_2,\r\nldots, b_n.In one operation, you can choose any integer i from 1 to n\r\nand swap the numbers a_i and b_i.Determine whether, after using any\r\n(possibly zero) number of operations, the following two conditions can\r\nbe satisfied simultaneously: a_n =\r\nmax(a_1, a_2,\r\nldots, a_n), b_n =\r\nmax(b_1, b_2,\r\nldots, b_n). Here\r\nmax(c_1, c_2,\r\nldots, c_k) denotes the maximum number among c_1, c_2,\r\nldots, c_k. For example,\r\nmax(3, 5, 4) = 5,\r\nmax(1, 7, 7) = 7,\r\nmax(6, 2) = 6.\r\n",
    "solutions": [
        "#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"Ofast,unroll-loops\")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline \"\\n\"                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<\" \"; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<\"{\"; _print(p.first);cerr<<\",\"; _print(p.second);cerr<<\"}\";}\ntemplate<class T>void _print(vector<T> v) {cerr<<\" [ \"; for (T i:v){_print(i);cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T>void _print(set<T> v) {cerr<<\" [ \"; for (T i:v){_print(i); cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< \" [ \"; for (T i:v){_print(i);cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<\" [ \"; for(auto i:v) {_print(i);cerr<<\" \";} cerr<<\"]\";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n; cin>>n;\n    vector<ll> a(n),b(n);\n    for(auto &it:a){\n        cin>>it;\n    }\n    for(auto &it:b){\n        cin>>it;\n    }\n    for(ll i=0;i<n;i++){\n        if(a[i]>b[i]){  \n            swap(a[i],b[i]);\n        }\n    }\n    for(ll i=0;i<n;i++){\n        if((a[i]>a[n-1]) or (b[i]>b[n-1])){\n            cout<<\"No\\n\";\n            return;\n        }\n    }\n    cout<<\"Yes\\n\";\n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(\"input.txt\", \"r\", stdin);                                              \n    freopen(\"output.txt\", \"w\", stdout);  \n    freopen(\"error.txt\", \"w\", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Showstopper.json",
    "editorial_link": "https://codeforces.com//blog/entry/114208",
    "editorial": "The first solution: Fix the position of the numbers . And for each other\r\nindex , letâs check whether the conditions and are met. If not, swap and\r\nand check again. If the conditions are not met for some index in both\r\nvariants the answer is , otherwise .The second solution: Let be the\r\nmaximum of all the numbers . Then if and the answer is , since in the\r\none of the arrays where the number appears after the operations, the\r\nmaximum will be , which is greater than and . Otherwise, either or . If\r\n, then swap and , now . So the condition will always be met, regardless\r\nof the numbers . Therefore, it would be best to put in the maximum of\r\nthe numbers for each . After that, it remains to check the condition for\r\nthe array , and if it is met, the answer is , otherwise\r\n",
    "hint": [
        "Hint 1 For each index , it makes no sense to perform the operation once, since applying the operation with the same index twice does not change anything.",
        "Hint 2 Condition is equivalent to for all . So for each index there are only 2 conditions: and ."
    ]
}