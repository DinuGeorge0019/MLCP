{
    "link": "https://codeforces.com//contest/1988/problem/E",
    "problemId": "2755743",
    "problem_idx": "E",
    "shortId": "1988E",
    "contest_number": "1988",
    "problem_submissions": {
        "E": [
            270685050,
            270705019,
            270700025,
            272334496,
            270690864,
            270707787,
            270701276,
            270700901,
            270718018,
            270707694,
            270712456,
            270717955,
            270717609,
            270717396,
            270722279,
            270721777,
            270713323,
            270726034,
            270728933,
            270723571,
            270713049
        ],
        "D": [
            270667414,
            270666131,
            270678688,
            270697022,
            270684902,
            270684329,
            270689879,
            270679010,
            270680404,
            270690647,
            270675498,
            270681957,
            270688264,
            270682354,
            270685580,
            270691868,
            270688997,
            270685310,
            270682871,
            270686949
        ],
        "A": [
            270656934,
            270657283,
            270646313,
            270648673,
            270647770,
            270646255,
            270646226,
            270646704,
            270646496,
            270646875,
            270646230,
            270646537,
            270649042,
            270647239,
            270646832,
            270647970,
            270646816,
            270646403,
            270647818,
            270690835
        ],
        "B": [
            270653903,
            270658113,
            270648318,
            270659660,
            270651609,
            270649653,
            270649456,
            270651315,
            270648898,
            270652028,
            270649680,
            270649413,
            270659881,
            270651090,
            270653561,
            270652761,
            270651998,
            270650038,
            270651450,
            270654441
        ],
        "C": [
            270647243,
            270657923,
            270653896,
            270669456,
            270664152,
            270658071,
            270658378,
            270659641,
            270660679,
            270663455,
            270660051,
            270666865,
            270671029,
            270662305,
            270672676,
            270661337,
            270662076,
            270660202,
            270665229,
            270662007
        ],
        "F": [
            276883705,
            276879542,
            270840778
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131581",
    "editorial": "Build the cartesian tree of a\n. Let lcx,rcx\n respectively be x\n's left and right children.\n\nConsider a vertex x\n. If we delete it, what would happen to the tree? Vertices that are on the outside of x\n's subtree will not be affected. Vertices inside the subtree of x\n will \"merge\". Actually, we can see that, only the right chain of x\n's left child (lcx?rclcx?rcrclcx?Â…\n) and the left chain of x\n's right child will merge in a way like what we do in mergesort.\n\nNow, if we merge the chains by bruteforce (use sorting or std::merge), the time complexity is O(n)\n! It's easy to see that each vertex will only be considered O(1)\n times.\n",
    "name": "E. Range Minimum Sum",
    "statement": "For an array [a_1,a_2,\r\nldots,a_n] of length n, define f(a) as the sum of the minimum element\r\nover all subsegments. That is, f(a)=\r\nsum_{l=1}^n\r\nsum_{r=l}^n\r\nmin_{l\r\nle i\r\nle r}a_i.A permutation is a sequence of integers from 1 to n of length n\r\ncontaining each number exactly once. You are given a permutation\r\n[a_1,a_2,\r\nldots,a_n]. For each i, solve the following problem independently: Erase\r\na_i from a, concatenating the remaining parts, resulting in b =\r\n[a_1,a_2,\r\nldots,a_{i-1},\r\n;a_{i+1},\r\nldots,a_{n}]. Calculate f(b).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}const int N=500005,L=20;int ST[N][L],a[N],n;int sf[N];il void add(int l,int r,int x){//\tcout<<\"[\"<<l<<\",\"<<r<<\"]:\"<<x<<\"\\n\";\tsf[l]+=x;\tsf[r+1]-=x;}il int chmin(int l,int r){\tint d=__lg(r-l+1);\tre min(ST[L][d],ST[r-(1<<d)+1][d]);}il int lsmin(int p,int k){\t//max i:i<p,a_i<k\tfor(int i=L-1;i>=0;i--)if(p>=(1<<i)&&ST[p-(1<<i)][i]>=k)p-=(1<<i);\tre p-1;}il int nxmin(int p,int k){\t//max i:i>p,a_i<k\tfor(int i=L-1;i>=0;i--)if(p+(1<<i)<n+2&&ST[p+1][i]>=k)p+=(1<<i);\tre p+1;}il void getans(){\tint s=0;\trept(i,1,n+1)s+=sf[i],cout<<s<<\" \";\tcout<<\"\\n\";}void run(){\tcin>>n;\trept(i,1,n+1)cin>>a[i];\ta[0]=a[n+1]=-1;\trep(i,n+2)ST[i][0]=a[i];\trep(i,L-1)rep(j,n+2-(2<<i)+1)ST[j][i+1]=min(ST[j][i],ST[j+(1<<i)][i]);\tint sum=0;\trep(i,n+2)sf[i]=0;\trept(i,1,n+1){\t\tint lf=lsmin(i,a[i]),rt=nxmin(i,a[i]);\t\tadd(lf+1,i-1,-a[i]*(rt-i));\t\tadd(i+1,rt-1,-a[i]*(i-lf));\t\tadd(i,i,-a[i]*(rt-i)*(i-lf));\t\tsum+=a[i]*(rt-i)*(i-lf);\t\tif(lf!=0){\t\t\tint clf=lsmin(lf,a[i]);\t\t\tadd(lf,lf,a[i]*(lf-clf-1)*(rt-i));\t\t}\t\tif(rt!=n+1){\t\t\tint crt=nxmin(rt,a[i]);\t\t\tadd(rt,rt,a[i]*(crt-rt-1)*(i-lf));\t\t}\t}\tadd(1,n,sum);\tgetans();}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Range Minimum Sum.json",
    "hint": []
}