{
    "link": "https://codeforces.com//contest/1794/problem/C",
    "problemId": "1808457",
    "problem_idx": "C",
    "shortId": "1794C",
    "contest_number": "1794",
    "problem_submissions": {
        "E": [
            196467319,
            196091024,
            196065447,
            196027516,
            196045507,
            196044539,
            196049784,
            196043653,
            196050334,
            196053527,
            196054181,
            196051837,
            196052921,
            196053608,
            196051434,
            196129108,
            196055320,
            196058590,
            196049523,
            196042891,
            196053778,
            196054545,
            196037576,
            196074501,
            196074391
        ],
        "D": [
            196083505,
            196016109,
            196024909,
            196024858,
            196021434,
            196025217,
            196028904,
            196025001,
            196032867,
            196029336,
            196033933,
            196031399,
            196038559,
            196037652,
            196048488,
            196050480,
            196036074,
            196036926,
            208633215,
            196022650
        ],
        "C": [
            196008950,
            196011685,
            196013987,
            196009207,
            196010114,
            196018308,
            196011596,
            196011705,
            196015187,
            196016689,
            196011713,
            196018563,
            196020776,
            196010830,
            196012003,
            196018106,
            196018224,
            196016136,
            196008531
        ],
        "B": [
            196004154,
            196004594,
            196009639,
            196005082,
            196031084,
            196004622,
            196004148,
            196006017,
            196007935,
            196006213,
            196009047,
            196004027,
            196017820,
            196010698,
            196013843,
            196006494,
            196003310,
            196003871
        ],
        "A": [
            196003031,
            196003363,
            196007521,
            196004024,
            196002777,
            196003379,
            196002990,
            196004171,
            196003805,
            196004167,
            196007050,
            196002947,
            196003739,
            196007194,
            196008753,
            196020821,
            196002700,
            196002959
        ]
    },
    "name": "C. Scoring Subsequences",
    "statement": "The of a sequence [s_1, s_2,\r\nldots, s_d] is defined as\r\ndisplaystyle\r\nfrac{s_1\r\ncdot s_2\r\ncdot\r\nldots\r\ncdot s_d}{d!}, where d!=1\r\ncdot 2\r\ncdot\r\nldots\r\ncdot d. In particular, the score of an empty sequence is 1.For a\r\nsequence [s_1, s_2,\r\nldots, s_d], let m be the maximum score among all its subsequences. Its\r\nis defined as the maximum length of a subsequence with a score of m.You\r\nare given a sequence [a_1, a_2,\r\nldots, a_n] of integers of length n. In other words, the condition a_1\r\nleq a_2\r\nleq\r\nldots\r\nleq a_n is satisfied. For each k=1, 2,\r\nldots , n, find the cost of the sequence [a_1, a_2,\r\nldots , a_k]. A sequence x is a subsequence of a sequence y if x can be\r\nobtained from y by deletion of several (possibly, zero or all) elements.\r\n",
    "solutions": [
        "#include <iostream>\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\ntemplate<class T>\nusing iset = tree<T, null_type, greater<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nstring read_s() {\n  string s;\n  char c = getchar();\n  while (isspace(c))\n    c = getchar();\n  while (c != EOF && !isspace(c))\n    s += c, c = getchar();\n  return s;\n}\n\nint main() {\n  int t = read();\n  while (t--) {\n    int n = read();\n    static int a[100000];\n    for (int i = 0; i < n; i++)\n      a[i] = read();\n    iset<pair<int, int>> s;\n    for (int i = 0; i < n; i++) {\n      s.insert({a[i], i});\n      int low = 1, hi = i + 1;\n      while (low < hi) {\n        int t = (low + hi) / 2 + 1;\n        if (s.find_by_order(t - 1)->first >= t)\n          low = t;\n        else\n          hi = t - 1;\n      }\n      printf(\"%d \", low);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Scoring Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/113500",
    "editorial": "We will first see how to find the cost of a single non-decreasing\r\nsequence .If we choose a subsequence with elements, to achieve the\r\nmaximum score it is optimal to choose the largest elements. As the\r\nsequence is in non-decreasing order, the largest elements will be the\r\nlast elements of the sequence. Thus, all possible candidates to be the\r\nanswer are the suffixes of the sequence.Now letâs divide the -th element\r\nfrom the right by . The sequence now turns into . Observe that the score\r\nof a suffix in the original sequence is equal to the product of the\r\nsuffix of the same size in the new sequence. The original sequence\r\nsatisfies . It also true that then combining these two inequalities we\r\nhave so the new sequence is also in non-decreasing order.In order to\r\nmaximize the product of a suffix in the new sequence, we will choose all\r\nthe elements in the new sequence which are greater or equal to (these\r\nelements form a suffix because the new sequence is non-decreasing). If\r\nthere are elements equal to in the new sequence, we have to choose them\r\nin order to get the subsquence with maximum length (among all the ones\r\nwith maximum score). Therefore, the cost of a sequence is the maximum\r\nlength of a suffix of such that each element is at least .Now, we have\r\nto find the cost of every prefix of the given sequence . For a fixed ,\r\nthe cost of will be the maximum length of a suffix of such that each\r\nelement is at least . We can find this length using binary search.\r\nObserve that we cannot compute the transformed sequence for every\r\nprefix, as that will be too slow. Instead, we can compute in each step\r\nof the binary search what would the number in that position be in the\r\ntransformed sequence. By doing these, we can find the score of each\r\nprefix in time. Intended complexity: per test case.\r\n",
    "hint": []
}