{
    "link": "https://codeforces.com//contest/1079/problem/G",
    "problemId": "257677",
    "problem_idx": "G",
    "shortId": "1079G",
    "contest_number": "1079",
    "problem_submissions": {
        "E": [
            45934267,
            45936636,
            45941806,
            45937565,
            45939333,
            45937199,
            45940743,
            45942158,
            45941402,
            46104036,
            45963146,
            45940904,
            45946313
        ],
        "D": [
            45931502,
            45929943,
            45928202,
            45933972,
            45932585,
            45928454,
            45926585,
            45928651,
            45928898,
            45928856,
            45930400,
            45930743,
            45929548,
            45929551,
            45931333,
            45929717,
            45931175,
            45930151,
            45933096
        ],
        "C": [
            45927571,
            45925544,
            45925366,
            45932689,
            45926037,
            45924078,
            45924314,
            45925482,
            45926594,
            45925976,
            45921399,
            45924312,
            45926518,
            45925797,
            45924767,
            45926026,
            45925780,
            45927583,
            45925054
        ],
        "B": [
            45922164,
            45922160,
            45923256,
            45930687,
            45951085,
            45921961,
            45921919,
            45922366,
            45922028,
            45923115,
            45924050,
            45922108,
            45922170,
            45923305,
            45921946,
            45922922,
            45922642,
            45922803,
            45922288
        ],
        "A": [
            45920252,
            45920257,
            45923913,
            45925594,
            45920970,
            45920420,
            45920504,
            45920483,
            45920269,
            45921357,
            45926632,
            45920349,
            45920289,
            45920409,
            45920196,
            45920480,
            45920373,
            45920574,
            45920303
        ],
        "F": [
            46007936,
            46007802,
            46007752,
            45995791,
            45995576,
            45995489,
            45995039,
            45994859,
            45992076
        ],
        "G": [
            45942230
        ]
    },
    "name": "G. Chattering",
    "statement": "There are n parrots standing in a circle. Each parrot has a certain\r\nlevel of respect among other parrots, namely r_i. When a parrot with\r\nrespect level x starts chattering, x neighbours to the right and to the\r\nleft of it start repeating the same words in 1 second. Their neighbours\r\nthen start repeating as well, and so on, until all the birds begin to\r\nchatter.You are given the respect levels of all parrots. For each parrot\r\nanswer a question: if this certain parrot starts chattering, how many\r\nseconds will pass until all other birds will start repeating it?\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#ifdef ONLINE_JUDGE\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#endif\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment(linker, \"/stack:200000000\")\n#include <bits/stdc++.h>\n#include <deque>\n#include <type_traits>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\ntemplate<typename Key=int,typename Mapped=__gnu_pbds::null_type,typename Cmp_Fn=std::less<Key>,typename Tag=__gnu_pbds::rb_tree_tag,template<typename Const_Node_Iterator,typename Node_Iterator,typename Cmp_Fn_,typename Allocator_>class Node_Update=__gnu_pbds::tree_order_statistics_node_update,typename Allocator=std::allocator<char>>class ordered_set_t:__gnu_pbds::tree<Key,Mapped,Cmp_Fn,Tag,Node_Update,Allocator>{};const int GRANDOM=std::chrono::high_resolution_clock::now().time_since_epoch().count();struct ghash{int operator()(int x){return std::hash<int>{}(x^GRANDOM);}};template<typename KeyType>class hash_table_t:__gnu_pbds::gp_hash_table<KeyType,int,ghash>{};namespace vh{template<class T>void _R(T&x){std::cin>>x;}inline void _R(int&x){scanf(\"%d\",&x);}inline void _R(int64_t&x){scanf(\"%\" SCNd64,&x);}inline void _R(double&x){scanf(\"%lf\",&x);}inline void _R(char&x){scanf(\" %c\",&x);}inline void _R(char*x){scanf(\"%s\",x);}inline void R(){}template<class T,class... U>inline void R(T&head,U&... tail){_R(head);R(tail...);}template<class T>void _W(const T&x){cout<<x;}inline void _W(const int&x){printf(\"%d\",x);}inline void _W(const int64_t&x){printf(\"%\" PRId64,x);}inline void _W(const double&x){printf(\"%.16f\",x);}inline void _W(const char&x){putchar(x);}inline void _W(const char*x){printf(\"%s\",x);}template<class T>inline void _W(const vector<T>&x){for(auto i=x.begin();i!=x.end();_W(*i++))if(i!=x.cbegin())putchar(' ');}inline void W(){}template<class T,class... U>inline void W(const T&head,const U&... tail){_W(head);if(sizeof...(tail))putchar(' '),W(tail...);}template<class T,class... U>inline void WL(const T&head,const U&... tail){_W(head);putchar(sizeof...(tail)? ' ':'\\n');W(tail...);}};\n#define prec setprecision\nnamespace vh{typedef long long ll;typedef unsigned long long llu;template<typename T>T gcd(T m,T n){while(n){T t=m%n;m=n;n=t;};return m;}template<typename T>T exgcd(T a,T b,T&sa,T&ta){T q,r,sb=0,tb=1,sc,tc;sa=1,ta=0;if(b)do q=a/b,r=a-q*b,a=b,b=r,sc=sa-q*sb,sa=sb,sb=sc,tc=ta-q*tb,ta=tb,tb=tc;while(b);return a;}template<typename T>T mul_inv(T a,T b){T t1=a,t2=b,t3;T v1=1,v2=0,v3;T x;while(t2!=1)x=t1/t2,t3=t1-x*t2,v3=v1-x*v2,t1=t2,t2=t3,v1=v2,v2=v3;return(v2+b)%b;}template<typename T>T powmod(T a,T b,T MOD){if(b<0)return 0;T rv=1;while(b)(b%2)&&(rv=(rv*a)%MOD),a=a*a%MOD,b/=2;return rv;}template<typename T>inline T isqrt(T k){T r=sqrt((double)k)+1;while(r*r>k)r--;return r;}template<typename T>inline T icbrt(T k){T r=cbrt((double)k)+1;while(r*r*r>k)r--;return r;}template<typename T>bool mul_overflow(T&r,T a,T b){return __builtin_mul_overflow(a,b,&r);}template<ll n>struct BitSize{enum{Size=BitSize<n/2>::Size+1};};template<>struct BitSize<0>{enum{Size=1};};template<>struct BitSize<1>{enum{Size=1};};\n#define BITSIZE(n) (BitSize<n>::Size)\n#define BITMAX(n) (BitSize<n>::Size - 1)\n#define DEBUG !defined(ONLINE_JUDGE)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define RALL(x) (x).rbegin(),(x).rend()\ntemplate<typename TH>void _dbg(const char*sdbg,TH h){cerr<<sdbg<<\"=\"<<h<<\"\\n\";}template<typename TH,typename... TA>void _dbg(const char*sdbg,TH h,TA... t){while(*sdbg!=',')cerr<<*sdbg++;cerr<<\"=\"<<h<<\",\";_dbg(sdbg+1,t...);}\n#ifdef DEBUG\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; for(auto itt: x) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n}namespace vh{template<typename T>int min_rotation(vector<T>s){int a=0,N=s.size();for(int b=0;b<N;b++)for(int i=0;i<N;i++){if(a+i==b||s[(a+i)%N]<s[(b+i)%N]){b+=max(0,i-1);break;}if(s[(a+i)%N]>s[(b+i)%N]){a=b;break;}}return a;}}namespace vh{pair<int,int>pinvalid={-1,-1};template<int N,typename T=ll>class OfflineRMQ{private:int _fr;int _to;T a[(N+1)*4];inline T combine(const T&a,const T&b){if(a==pinvalid)return b;if(b==pinvalid)return a;return{min(a.first,b.first),max(a.second,b.second)};}template<typename T2>void update(T2 arr[],int node,int fr,int to){if(fr==to){a[node]=arr[fr];}else{int m=(fr+to)/2;update(arr,node*2,fr,m);update(arr,node*2+1,m+1,to);a[node]=combine(a[node*2],a[node*2+1]);}}T query(int node,int fr,int to,int x,int y){if(to<x||fr>y)return pinvalid;if(x<=fr&&to<=y)return a[node];int m=(fr+to)/2;return combine(query(node*2,fr,m,x,y),query(node*2+1,m+1,to,x,y));}public:OfflineRMQ(){}template<typename T2>void prepare(T2 arr[],int fr,int to){_fr=fr;_to=to;update(arr,1,fr,to);}T query(int fr,int to){return query(1,_fr,_to,fr,to);}};};\nnamespace vh{\n  const int maxn=1e5+7;\n  const int maxnlog=18;\n  int n;\n  int r[maxn*3];\n  pair<int,int>rr[maxnlog][maxn*3];\n  OfflineRMQ<maxn*3,pair<int,int>>rmq[maxnlog];\n  int main(){\n    srand(GRANDOM);\n    cin>>n;\n    if(n==1){\n      cout<<0<<endl;\n      return 0;\n    }\n    for(int i=1;i<=n;i++){\n      cin>>r[i];\n      r[n+i]=r[n*2+i]=r[i];\n      for(int j=0;j<3;j++)\n        rr[0][i+j*n]={max(1,i+j*n-r[i]),min(n*3,i+j*n+r[i])};\n    }\n    rmq[0].prepare(rr[0],1,n*3);\n    for(int j=1;j<maxnlog;j++){\n      for(int i=1,ie=n*3;i<=ie;i++){\n        rr[j][i]=rmq[j-1].query(rr[j-1][i].first,rr[j-1][i].second);\n      }\n      rmq[j].prepare(rr[j],1,n*3);\n    }\n    int last=n;\n    for(int i=n+1,ie=n*2;i<=ie;i++){\n      int fr=(i==n+1)?1:max(1,last-1),to=min(n,last+1);\n      while(fr<=to){\n        int m=(fr+to)/2;\n        pair<int,int>p={i,i};\n        for(int j=maxnlog-1;j>=0;j--){\n          if((m>>j)&1){\n            p=rmq[j].query(p.first,p.second);\n            if(p.second-p.first+1>=n)break;\n          }\n        }\n        if(p.second-p.first+1>=n)to=m-1;\n        else fr=m+1;\n      }\n      last=fr;\n      cout<<fr<<' ';\n    }\n    return 0;\n  }\n};\nint main(int argc,char*argv[]){\n  std::cin.sync_with_stdio(false);std::cin.tie(nullptr);\n  return vh::main();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Chattering.json",
    "editorial_link": "https://codeforces.com//blog/entry/63324",
    "editorial": null,
    "hint": []
}