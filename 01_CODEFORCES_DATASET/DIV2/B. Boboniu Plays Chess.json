{"link": "https://codeforces.com//contest/1395/problem/B", "problemId": "697390", "problem_idx": "B", "shortId": "1395B", "contest_number": "1395", "problem_submissions": {"E": [89703350, 89708810, 89714112, 89712317, 89710869, 89721292, 89717279, 89724356, 89790658, 89720352, 89754109, 89972468, 89742493], "D": [89680583, 89688575, 89687431, 89686132, 89714959, 89699868, 89694770, 89698961, 89690630, 89691297, 89679330, 89689190, 89686103, 89687862, 89691233, 89685139, 89691247, 89695821, 89694043, 89690135], "C": [89667862, 89671025, 89670163, 89676747, 89709040, 89680699, 89672427, 89678496, 89680762, 89680781, 89671144, 89671940, 89675222, 89675842, 89668159, 89667746, 89679969, 89674140, 89676822, 89680839], "B": [89662013, 89665422, 89664182, 89669305, 89705735, 89669721, 89665457, 89671085, 89672065, 89669758, 89663771, 89663206, 89664323, 89667048, 89663548, 89692219, 89670175, 89666811, 89668290, 89675614], "A": [89659448, 89659999, 89659595, 89659674, 89701947, 89663005, 89660051, 89663077, 89666442, 89661809, 89659697, 89659449, 89659558, 89661691, 89659464, 89660991, 89660634, 89661384, 89662258, 89660765], "F": [89730004, 89698501, 89836189, 89729687]}, "name": "B. Boboniu Plays Chess", "statement": "Boboniu likes playing chess with his employees. As we know, no employee\r\ncan beat the boss in the chess game, so Boboniu has never lost in any\r\nround.You are a new applicant for his company. Boboniu will test you\r\nwith the following chess question:Consider a n\r\ntimes m grid (rows are numbered from 1 to n, and columns are numbered\r\nfrom 1 to m). You have a chess piece, and it stands at some cell\r\n(S_x,S_y) which is not on the border (i.e. 2\r\nle S_x\r\nle n-1 and 2\r\nle S_y\r\nle m-1).From the cell (x,y), you can move your chess piece to (x,y\u2019) (1\r\nle y\u2019\r\nle m, y\u2019\r\nneq y) or (x\u2019,y) (1\r\nle x\u2019\r\nle n, x\u2019\r\nneq x). In other words, the chess piece moves as a rook. From the cell,\r\nyou can move to any cell on the same row or column.Your goal is to visit\r\neach cell exactly once. Can you find a solution?Note that cells on the\r\npath between two adjacent cells in your route are not counted as\r\nvisited, and it is not required to return to the starting point.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nint a,b,c,d;\nint main(){\n\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\tprintf(\"%d %d\\n\",c,d);\n\tfor(int i=1;i<=a;i++)if(i!=c)printf(\"%d %d\\n\",i,d);\n\tfor(int i=1;i<=b;i++){\n\t\tif(i==d)continue;\n\t\tbool dir=(i&1);\n\t\tif(i>d)dir^=1;\n\t\tif(dir==1)for(int j=a;j;j--)printf(\"%d %d\\n\",j,i);\n\t\telse for(int j=1;j<=a;j++)printf(\"%d %d\\n\",j,i);\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1100", "interactive": false}