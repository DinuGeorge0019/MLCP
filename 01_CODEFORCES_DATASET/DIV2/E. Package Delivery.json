{
    "link": "https://codeforces.com//contest/635/problem/E",
    "problemId": "49958",
    "problem_idx": "E",
    "shortId": "635E",
    "contest_number": "635",
    "problem_submissions": {
        "F": [
            16715109,
            16429856
        ],
        "E": [
            16413519,
            16414980,
            16415683,
            16413671,
            16416127,
            16415965,
            16412886,
            16411309,
            16414895,
            16431030,
            16415653,
            16557734
        ],
        "D": [
            16411390,
            16412670,
            16411204,
            16413229,
            16412878,
            16413863,
            16411883,
            16412667,
            16409842,
            16411803,
            16408893,
            16411766,
            16411437,
            16412231,
            16411782,
            16413499,
            16413108
        ],
        "C": [
            16410177,
            16409314,
            16412788,
            16419061,
            16414730,
            16411184,
            16411076,
            16417490,
            16413342,
            16420377,
            16409924,
            16410108,
            16409728,
            16410259,
            16410185,
            16410892
        ],
        "A": [
            16409333,
            16408548,
            16407902,
            16407920,
            16407765,
            16408000,
            16407909,
            16408814,
            16407724,
            16408398,
            16412714,
            16407922,
            16407797,
            16408056,
            16414324,
            16407823,
            16407862
        ],
        "B": [
            16408961,
            16410486,
            16409109,
            16409265,
            16408639,
            16409212,
            16408803,
            16414234,
            16408509,
            16409385,
            16408280,
            16408866,
            16408225,
            16408994,
            16407968,
            16409084,
            16408701
        ]
    },
    "name": "E. Package Delivery",
    "statement": "Johnny drives a truck and must deliver a package from his hometown to\r\nthe district center. His hometown is located at point on a number line,\r\nand the district center is located at the point .Johnny’s truck has a\r\ngas tank that holds exactly liters, and his tank is initially full. As\r\nhe drives, the truck consumes exactly one liter per unit distance\r\ntraveled. Moreover, there are gas stations located at various points\r\nalong the way to the district center. The -th station is located at the\r\npoint on the number line and sells an unlimited amount of fuel at a\r\nprice of dollars per liter. Find the minimum cost Johnny must pay for\r\nfuel to successfully complete the delivery.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int N = 2e5 + 5;\nint x[N], p[N], n, d, ind[N];\nlong long ans = 0;\nvector<pair<int, int> > tank;\nint head, cur;\nbool cmp(int a, int b)\n{\n\treturn x[a] < x[b];\n}\nbool use(int dis)\n{\n\twhile (dis)\n\t{\n\t\tif (head == (int) tank.size()) return 1;\n\t\tint tmp = min(dis, tank[head].first);\n\t\tdis -= tmp;\n\t\ttank[head].first -= tmp;\n\t\tcur -= tmp;\n\t\tif (tank[head].first == 0) head ++;\n\t}\n\treturn 0;\n}\nvoid sale(int p)\n{\n\twhile ((int) tank.size() > head && tank.back().second > p)\n\t{\n\t\tans -= 1LL * tank.back().second * tank.back().first;\n\t\tcur -= tank.back().first;\n\t\ttank.pop_back();\n\t}\n}\nvoid buy(int p)\n{\n\tans += 1LL * p * (n - cur);\n\ttank.push_back(make_pair(n - cur, p));\n\tcur = n;\n}\nint main()\n{\n\tint m;\n\tscanf(\"%d%d%d\", &d, &n, &m);\n\tfor (int i = 1; i <= m; ++ i) scanf(\"%d%d\", &x[i], &p[i]), ind[i] = i;\n\tx[m + 1] = d;\n\tp[m + 1] = 0;\n\tind[m + 1] = m + 1;\n\tsort(ind + 1, ind + 1 + m, cmp);\n\ttank.push_back(make_pair(n, 0));\n\tcur = n;\n\tfor (int i = 1; i <= m + 1; ++ i)\n\t{\n\t\tint dis = x[ind[i]] - x[ind[i - 1]];\n\t\tif (use(dis)) return 0 * puts(\"-1\");\n\t\tsale(p[ind[i]]);\n\t\tbuy(p[ind[i]]);\n\t}\n\tcout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Package Delivery.json",
    "editorial_link": "https://codeforces.com//blog/entry/43467",
    "editorial": "We solve this with a greedy algorithm: for each gas station, we fill our tank to min(n,?d) liters of gasoline, where d is the distance to the next gas station with cheaper (or equal) gas. This is optimal, as, if we can make it to a station with cheaper gas without buying expensive gas, we should (and fill up our tank at the cheaper station). Otherwise, all stations within range n are more expensive, so we should buy as much gas as possible right now.\n\nAlternatively, if we say that we always use the gasoline we buy in the order we buy it, then the gasoline used in the ith unit must have been purchased within the last n units. Then we can greedily use the cheapest gas within the last n miles. We can maintain this in a queue with range-min-query, which gives us linear runtime (after sorting).",
    "hint": []
}