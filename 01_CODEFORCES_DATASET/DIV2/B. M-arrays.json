{"link": "https://codeforces.com//contest/1497/problem/B", "problemId": "925005", "problem_idx": "B", "shortId": "1497B", "contest_number": "1497", "problem_submissions": {"E1": [110218942, 110204547, 110209862, 110204250, 110204165, 110231486, 110202339, 110191058, 110208748, 110226922, 110214718, 110213615, 110206316, 110227739, 110214379, 110211872, 110213209, 110211236, 110214947, 110214631], "E2": [110218489, 110228575, 214425397, 110217629, 110222364, 110204786, 110244884, 110204758, 110216448, 128480996, 110231341, 110288360, 110287974, 110284396, 110226837, 110233982, 110227741], "D": [110209131, 110229942, 110235570, 110232860, 110227785, 110226987, 110217671, 110285138, 110213904, 110231090, 110226178, 110248432, 110223649, 110238019, 110211006, 110234017], "B": [110201204, 110197893, 110193488, 110190033, 110218332, 110197422, 110188452, 110197952, 110193152, 110191609, 110193962, 110209906, 110189973, 110196774, 110193252, 110192209, 110193977, 110191962, 110193050, 110190991], "A": [110197966, 110183441, 110185344, 110183392, 110207927, 110188054, 110182581, 110186628, 110190659, 110182727, 110186155, 110183196, 110185241, 110185407, 110184362, 110184636, 110184528, 110183883, 110183214, 110182538], "C1": [110193783, 110197460, 110198652, 110201523, 110223073, 110204540, 110193389, 110211919, 110203639, 110203131, 110197927, 110199227, 110194627, 110203913, 110203003, 110207436, 110203526, 110203044, 110197492, 110205586], "C2": [110193437, 110198415, 110198429, 110211803, 110223191, 110204421, 110194238, 110212138, 110204892, 110207285, 110199495, 110215157, 110198718, 110207240, 110202742, 110207482, 110291141, 110202605, 110201810, 110207375]}, "name": "B. M-arrays", "statement": "You are given an array a_1, a_2,\r\nldots, a_n consisting of n positive integers and a positive integer\r\nm.You should divide elements of this array into some arrays. You can\r\norder the elements in the new arrays as you want.Let\u2019s call an array\r\nm-divisible if for each two adjacent numbers in the array (two numbers\r\non the positions i and i+1 are called adjacent for each i) their sum is\r\ndivisible by m. An array of one element is m-divisible.Find the smallest\r\nnumber of m-divisible arrays that a_1, a_2,\r\nldots, a_n is possible to divide into.\r\n", "solutions": ["#pragma GCC optimize(\"Ofast\")\n\n#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define i128 __int128\n#define fi first\n#define se second\n#define mpa make_pair\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nusing namespace std;\nmt19937 gen(time(0));\nmt19937_64 gen64(time(0));\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T-->0) {\n        ll n, m;\n        cin >> n >> m;\n        vector<ll> a(n);\n        map<ll, ll> q;\n        ll ans = 0;\n        bool k = 0;\n        for (int i = 0; i < n; ++i) {\n            ll x;\n            cin >> x;\n            x %= m;\n            if (!x) {\n                k = 1;\n                continue;\n            }\n            ++q[x];\n            ++q[m - x];\n            --q[m - x];\n        }\n        if (k) ++ans;\n        for (auto &elem : q) {\n            ll c = m - elem.fi;\n            if (elem.fi <= c) {\n                if (elem.fi == c) ans += 1;\n                else ans += max(1ll, (max(elem.se, q[c]) - min(elem.se, q[c])));\n            }\n        }\n        cout << ans << '\\n';\n    }\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "math"], "dificulty": "1200", "interactive": false}