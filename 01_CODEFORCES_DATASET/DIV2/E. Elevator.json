{"link": "https://codeforces.com//contest/984/problem/E", "problemId": "183248", "problem_idx": "E", "shortId": "984E", "contest_number": "984", "problem_submissions": {"E": [38295174, 38292597, 38295542, 38294481, 38296992, 38308491, 38286876, 38291550, 38301305, 38295842, 38311834], "D": [38281653, 38286328, 38283274, 38285186, 38284520, 38278363, 38278548, 38283233, 38283814, 38283258, 38285731, 38282701, 38285537, 38283857, 38282865, 38284924, 38285935, 38282839, 38284166, 38284994], "C": [38277813, 38279909, 38280385, 38282567, 38284026, 38308575, 38279256, 38278014, 38280019, 38281587, 38278990, 38279032, 38276778, 38279263, 38279837, 38280121, 38280838, 38281513, 38280422], "B": [38277482, 38274043, 38276214, 38275539, 38274804, 38273916, 38280569, 38275485, 38274790, 38277380, 38303710, 38274483, 38273269, 38279129, 38273211, 38274320, 38274282, 38275265, 38276184, 38276792], "A": [38274250, 38270894, 38271892, 38271406, 38271964, 38270942, 38279477, 38271611, 38271008, 38273380, 38271243, 38272415, 38270860, 38271217, 38270890, 38271184, 38271009, 38271766, 38274300, 38271231]}, "name": "E. Elevator", "statement": "You work in a big office. It is a floor building with an elevator that\r\ncan accommodate up to people. It is your responsibility to manage this\r\nelevator.Today you are late, so there are queues on some floors already.\r\nFor each person you know the floor where he currently is and the floor\r\nhe wants to reach. Also, you know the order in which people came to the\r\nelevator.According to the company\u2019s rules, if an employee comes to the\r\nelevator earlier than another one, he has to enter the elevator earlier\r\ntoo (even if these employees stay on different floors). Note that the\r\nemployees are allowed to leave the elevator in arbitrary order.The\r\nelevator has two commands: Go up or down one floor. The movement takes\r\nsecond. Open the doors on the current floor. During this operation all\r\nthe employees who have reached their destination get out of the\r\nelevator. Then all the employees on the floor get in the elevator in the\r\norder they are queued up while it doesn\u2019t contradict the company\u2019s rules\r\nand there is enough space in the elevator. Each employee spends second\r\nto get inside and outside the elevator. Initially the elevator is empty\r\nand is located on the floor .You are interested what is the minimum\r\npossible time you need to spend to deliver all the employees to their\r\ndestination. It is not necessary to return the elevator to the floor .\r\n", "solutions": ["#include <bits/stdc++.h>\n#define debug(x) (cerr << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\nusing namespace std;\n\ntemplate<typename T>\nauto operator <<(ostream &out, T& container) -> decltype(container.begin(), container.end(), out) {\n    bool first = true; out << \"[\";\n    for(auto it = container.begin(); it != container.end(); ++it) {\n        if(!first) out << \", \"; out << *it; first = false;\n    } return out << \"]\";\n}\n\nint dp[2000][9][10][10][10][2]; // last employee, position, target 1, target 2, target 3, last employee is inside\nint n;\nint a[2000], c[2000];\n\nvoid calc(int l, int t1l, int t1r, int t2l, int t2r, int t3l, int t3r, int b) {\n    for (int p = 0; p < 9; ++p) {\n        for (int t1 = t1l; t1 <= t1r; ++t1) {\n            for (int t2 = t2l; t2 <= t2r; ++t2) {\n                for (int t3 = t3l; t3 <= t3r; ++t3) {\n                    int &cur = dp[l][p][t1][t2][t3][b];\n                    if (l < n-1) {\n                        if (b == 0) {\n                            dp[l+1][a[l+1]][t1][t2][t3][1] = min(dp[l+1][a[l+1]][t1][t2][t3][1], cur + abs(p-a[l+1]) + 1);\n                        } else if (t1 == 9) {\n                            dp[l+1][a[l+1]][c[l]][t2][t3][1] = min(dp[l+1][a[l+1]][c[l]][t2][t3][1], cur + abs(p-a[l+1]) + 1);\n                        } else if (t2 == 9) {\n                            dp[l+1][a[l+1]][t1][c[l]][t3][1] = min(dp[l+1][a[l+1]][t1][c[l]][t3][1], cur + abs(p-a[l+1]) + 1);\n                        } else if (t3 == 9) {\n                            dp[l+1][a[l+1]][t1][t2][c[l]][1] = min(dp[l+1][a[l+1]][t1][t2][c[l]][1], cur + abs(p-a[l+1]) + 1);\n                        }\n                    }\n\n                    if (b == 1) {\n                        dp[l][c[l]][t1][t2][t3][0] = min(dp[l][c[l]][t1][t2][t3][0], cur + abs(p-c[l]) + 1);\n                    }\n\n                    if (t1 != 9) {\n                        dp[l][t1][9][t2][t3][b] = min(dp[l][t1][9][t2][t3][b], cur + abs(p-t1) + 1);\n                    }\n\n                    if (t2 != 9) {\n                        dp[l][t2][t1][9][t3][b] = min(dp[l][t2][t1][9][t3][b], cur + abs(p-t2) + 1);\n                    }\n\n                    if (t3 != 9) {\n                        dp[l][t3][t1][t2][9][b] = min(dp[l][t3][t1][t2][9][b], cur + abs(p-t3) + 1);\n                    }\n\n                    //cout << \"dp[\" << l << \"][\" << p << \"][\" << t1 << \"][\" << t2 << \"][\" << t3 << \"][\" << b << \"] = \" << dp[l][p][t1][t2][t3][b] << \"\\n\";\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> c[i];\n        a[i]--; c[i]--;\n    }\n\n    for (int x1 = 0; x1 < n; ++x1) for (int x2 = 0; x2 < 9; ++x2)\n    for (int x3 = 0; x3 < 10; ++x3) for (int x4 = 0; x4 < 10; ++x4)\n    for (int x5 = 0; x5 < 10; ++x5) for (int x6 = 0; x6 < 2; ++x6)\n        dp[x1][x2][x3][x4][x5][x6] = 1e9;\n    dp[0][a[0]][9][9][9][1] = a[0] + 1;\n\n    for (int l = 0; l < n; ++l) {\n        calc(l, 0, 8, 0, 8, 0, 8, 1); // 4\n        calc(l, 0, 8, 0, 8, 0, 8, 0); // 3\n        calc(l, 0, 8, 0, 8, 9, 9, 1); // 3\n        calc(l, 0, 8, 9, 9, 0, 8, 1); // 3\n        calc(l, 9, 9, 0, 8, 0, 8, 1); // 3\n        calc(l, 0, 8, 0, 8, 9, 9, 0); // 2\n        calc(l, 0, 8, 9, 9, 0, 8, 0); // 2\n        calc(l, 9, 9, 0, 8, 0, 8, 0); // 2\n        calc(l, 0, 8, 9, 9, 9, 9, 1); // 2\n        calc(l, 9, 9, 0, 8, 9, 9, 1); // 2\n        calc(l, 9, 9, 9, 9, 0, 8, 1); // 2\n        calc(l, 0, 8, 9, 9, 9, 9, 0); // 1\n        calc(l, 9, 9, 0, 8, 9, 9, 0); // 1\n        calc(l, 9, 9, 9, 9, 0, 8, 0); // 1\n        calc(l, 9, 9, 9, 9, 9, 9, 1); // 1\n        calc(l, 9, 9, 9, 9, 9, 9, 0); // 0\n    }\n\n    int res = 1e9;\n    for (int i = 0; i < 9; ++i) res = min(res, dp[n-1][i][9][9][9][0]);\n    cout << res << \"\\n\";\n}\n"], "input": "", "output": "", "tags": ["dp", "graphs", "shortest paths"], "dificulty": "2400", "interactive": false}