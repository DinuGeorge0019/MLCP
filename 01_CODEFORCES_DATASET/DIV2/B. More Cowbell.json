{
    "link": "https://codeforces.com//contest/604/problem/B",
    "problemId": "42006",
    "problem_idx": "B",
    "shortId": "604B",
    "contest_number": "604",
    "problem_submissions": {
        "D": [
            14596500,
            14593346,
            14595214,
            14597164,
            14594625,
            14591286,
            14596851,
            14596627,
            14597744,
            14595935,
            14605132,
            14596012,
            14596656,
            14597363,
            14604366
        ],
        "E": [
            14595112,
            14597709,
            14599612,
            14601657,
            14601583,
            14602620,
            14601006,
            14598712,
            14611507,
            14600405,
            14603271,
            14606898,
            14598106
        ],
        "C": [
            14591727,
            14591485,
            14590401,
            14591803,
            14590167,
            14598812,
            14590931,
            14593957,
            14594227,
            14592838,
            14592345,
            14591994,
            14604053,
            14594007,
            14591853,
            14592988
        ],
        "B": [
            14589366,
            14588467,
            14587631,
            14589936,
            14596744,
            23519332,
            14588532,
            14589419,
            14589534,
            14587511,
            14588487,
            14588973,
            14588129,
            14588264,
            14589189
        ],
        "A": [
            14587013,
            14586403,
            14586260,
            14587679,
            14595485,
            14586765,
            14586177,
            14586973,
            14586715,
            14586347,
            14586267,
            14586259,
            14587001,
            14586457,
            14586288,
            14586867
        ]
    },
    "name": "B. More Cowbell",
    "statement": "Kevin Sun wants to move his precious collection of cowbells from\r\nNaperthrill to Exeter, where there is actually grass instead of corn.\r\nBefore moving, he must pack his cowbells into boxes of a fixed size. In\r\norder to keep his collection safe during transportation, he won’t place\r\nmore than cowbells into a single box. Since Kevin wishes to minimize\r\nexpenses, he is curious about the smallest size box he can use to pack\r\nhis entire collection. Kevin is a meticulous cowbell collector and knows\r\nthat the size of his -th () cowbell is an integer . In fact, he keeps\r\nhis cowbells sorted by size, so for any . Also an expert packer, Kevin\r\ncan fit one or two cowbells into a box of size if and only if the sum of\r\ntheir sizes does not exceed . Given this information, help Kevin\r\ndetermine the smallest for which it is possible to put all of his\r\ncowbells into boxes of size .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, K, a[200009], ap[200009];\n\nbool ok (int D)\n{\n    int j = 1, cnt = 0;\n    for (int i=1; i<=N; i++)\n        ap[i] = 0;\n    for (int i=N; i>=1; i--)\n    if (ap[i] == 0)\n    {\n        if (j < i && ap[j] == 0 && a[i] + a[j] <= D) ap[j] = ap[i] = 1, j ++;\n        else ap[i] = 1;\n        cnt ++;\n    }\n    return (cnt <= K);\n}\n\nint main()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &K);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &a[i]);\nint p = a[N], u = 2000009, mij, ras;\n//ok ((p + u) / 2);\n//return 0;\nwhile (p <= u)\n{\n    mij = (p + u) >> 1;\n    if (ok (mij)) ras = mij, u = mij - 1;\n    else p = mij + 1;\n}\nprintf (\"%d\\n\", ras);\n\nreturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. More Cowbell.json",
    "editorial_link": "https://codeforces.com//blog/entry/21885",
    "editorial": "Hint: Try thinking about a sorted list of cowbells. What do we do with\r\nthe largest ones? Intuitively, we want to use as many boxes as we can\r\nand put the largest cowbells by themselves. Then, we want to pair the\r\nleftover cowbells so that the largest sum of a pair is minimized.This\r\nleads to the following greedy algorithm: First, if , then each cowbell\r\ncan go into its own box, so our answer is . Otherwise, we can have at\r\nmost boxes that contain one cowbell. So as the cowbells are sorted by\r\nsize, we put the largest into their own boxes. For the remaining\r\ncowbells, we pair the th largest cowbell with the th largest. In other\r\nwords, we match the smallest remaining cowbell with the largest, the\r\nsecond smallest with the second largest, and so on. Given these\r\npairings, we can loop through them to find the largest box weâll need.\r\nThe complexity of this algorithm is in all cases. To prove that this\r\ngreedy works, think about the cowbell the the largest one gets paired\r\nwith. If itâs not the smallest, we can perform a swap so that the\r\nlargest cowbell is paired with the smallest and not make our answer\r\nworse. After weâve paired the largest cowbell, we can apply the same\r\nlogic to the second largest, third largest, etc. until weâre done. Code:\r\nhttp://codeforces.com/contest/604/submission/14608465\r\n",
    "hint": []
}