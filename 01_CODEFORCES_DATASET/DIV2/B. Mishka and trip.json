{
    "link": "https://codeforces.com//contest/703/problem/B",
    "problemId": "67402",
    "problem_idx": "B",
    "shortId": "703B",
    "contest_number": "703",
    "problem_submissions": {
        "E": [
            19666489,
            19673872
        ],
        "B": [
            19626552,
            19623646,
            19623489,
            19622672,
            19623589,
            19622607,
            19630316,
            19626462,
            19622834,
            19627334,
            19621557,
            19624072,
            19622040,
            19636121,
            19621168,
            19623567,
            19627920,
            19622029,
            19622154,
            19622540
        ],
        "D": [
            19626399,
            19625673,
            19630973,
            19636020,
            19629091,
            19634472,
            19637884,
            19624772,
            19628022,
            19634609,
            19626277,
            19629769,
            19629743,
            19636886,
            19631115,
            19635175,
            19634015,
            19631464,
            19625267,
            19625595,
            19625868
        ],
        "C": [
            19623139,
            19633081,
            19627637,
            19624674,
            19630730,
            19625930,
            19632821,
            19631298,
            19627565,
            19632128,
            19636417,
            19634592,
            19629638,
            19625401,
            19632242,
            19634683,
            19635534
        ],
        "A": [
            19617844,
            19618704,
            19618318,
            19617935,
            19617774,
            19620750,
            19618191,
            19619005,
            19619467,
            19627709,
            19617913,
            19620674,
            19618195,
            19621709,
            19617804,
            19620263,
            19618582,
            19620732,
            19617828,
            19618666
        ]
    },
    "name": "B. Mishka and trip",
    "statement": "Little Mishka is a great traveller and she visited many countries. After\r\nthinking about where to travel this time, she chose XXX beautiful, but\r\nlittle-known northern country.Here are some interesting facts about XXX:\r\nXXX consists of cities, of whose (just imagine!) are capital cities. All\r\nof cities in the country are beautiful, but each is beautiful in its own\r\nway. Beauty value of -th city equals to . All the cities are\r\nconsecutively connected by the roads, including -st and -th city,\r\nforming a cyclic route . Formally, for every there is a road between -th\r\nand -th city, and another one between -st and -th city. Each capital\r\ncity is connected with each other city directly by the roads. Formally,\r\nif city is a capital city, then for every , there is a road between\r\ncities and . There is road between any two cities. Price of passing a\r\nroad directly depends on beauty values of cities it connects. Thus if\r\nthere is a road between cities and , price of passing it equals .Mishka\r\nstarted to gather her things for a trip, but didn’t still decide which\r\nroute to follow and thus she asked you to help her determine summary\r\nprice of passing in XXX. Formally, for every pair of cities and (), such\r\nthat there is a road between and you are to find sum of products . Will\r\nyou help her?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name\".in\", \"r\", stdin); \\\n        freopen(name\".out\", \"w\", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << \" = \" << head << \" <<\" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=',' || c!=0) {\n        if (*s=='(' || *s=='[' || *s=='{' || *s=='<') c++;\n        if (*s==')' || *s==']' || *s=='}' || *s=='>') c--;\n        cerr << *s++;\n    }\n    cerr << \" = \" << head << \", \";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << \"\\033[32m>> \" << __LINE__ << \": \" << __PRETTY_FUNCTION__ << endl; \\\n    cout << \"   \"; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << \"\\033[0m\"; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss=\"\", const string se=\"\") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? \"\" : \", \") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << \"(\" << pair.F << \", \" << pair.S << \")\";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), \"[\", \"]\");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), \"{\", \"}\");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), \"|\", \"|\");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << \"{\";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?\"\":\", \") << it->F << \":\" << it->S;\n    }\n    o << \"}\";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << \"Not lucky\" << endl;\n        exit(0);\n    }\n}\n\n#define int long long\n\nconst int MX = 101010;\nint ip[MX];\n\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    int N, K;\n    cin>>N>>K;\n\n    for (int i=0; i<N; i++) {\n        cin>>ip[i];\n    }\n\n\n    int ans = 0;\n    int s = 0;\n    for (int i=0; i<N; i++) {\n        ans += ip[i] * ip[(i+1)%N];\n        s += ip[i];\n    }\n\n    int z = 0;\n    static bool us[MX];\n\n    for (int i=0; i<K; i++) {\n        int p;\n        cin>>p;\n        p--;\n        if (!us[(p+1)%N])\n            ans -= ip[p] * ip[(p+1)%N];\n\n        if (!us[(p+N-1)%N])\n            ans -= ip[p] * ip[(p+N-1)%N];\n\n        ans -= ip[p] * z;\n        ans += ip[p] * (s - ip[p]);\n        z += ip[p];\n        us[p] = 1;\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Mishka and trip.json",
    "editorial_link": "https://codeforces.com//blog/entry/46434",
    "editorial": "Letâs look at the first capital. Note that the total cost of the\r\noutgoing roads is , where summary beauty of all cities. Thus iterating\r\nthrough the capitals we can count the summary cost of roads between\r\ncapitals and all the other cities. But donât forget that in this case we\r\ncount the roads between pairs of capitals twice. To avoid this on each\r\nstep we should update , where is the position of current capital. In the\r\nend we should add to the answer the cost of roads between \"non-capital\"\r\nneighbour cities. Complexity .\r\n",
    "hint": []
}