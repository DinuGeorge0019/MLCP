{"link": "https://codeforces.com//contest/1262/problem/F2", "problemId": "479744", "problem_idx": "F2", "shortId": "1262F2", "contest_number": "1262", "problem_submissions": {"F1": [65643346, 65653823, 65643705, 65644730, 65690605, 65651588, 65651277, 66034817, 65646761, 65654524, 65651505, 65653937, 65645081, 65645973, 65647100, 65654475, 65687063, 65647622, 65647339, 65645959], "F2": [65643279, 65653692, 65828965, 65686253, 65649254, 65653062, 65651757, 71816951, 71815917, 71815485, 71815448, 71815068, 71814941, 71814802, 65654320, 65687047, 65652597, 65652697, 65651173], "E": [65639530, 65645042, 65648892, 65652057, 65690596, 65647275, 65647634, 65653097, 65651461, 65648284, 65647900, 97249054, 97246746, 65648360, 65650087, 65951237, 65651779], "D1": [65634593, 65638676, 65638313, 65637479, 65640274, 65640849, 65636529, 65639533, 65642238, 65648533, 65640691, 65638549, 65642536, 65639709, 65635698, 65639724, 65643528, 65642432, 65642224, 65638684], "D2": [65634523, 65638577, 65638418, 65637413, 65640211, 65640949, 65642851, 65639443, 65642574, 65642451, 65640796, 65638763, 65642667, 65639589, 65635638, 65639633, 65643328, 65643512, 65642176, 65638616], "C": [65629762, 65634294, 65634237, 65633719, 65632321, 65635540, 65633375, 65635292, 65633541, 65633864, 65634698, 65633061, 65637189, 65634072, 65640938, 65633298, 65638202, 65638218, 65637587, 65633967], "B": [65627254, 65629631, 65628216, 65627679, 65628556, 65630807, 65628279, 65630765, 65628901, 65628780, 65629802, 65628147, 65626929, 65628945, 65629119, 65627530, 65632823, 65631394, 65633894, 65629398], "A": [65626237, 65626820, 65626466, 65626311, 65627028, 65627733, 65626343, 65627142, 65629675, 65626752, 65627572, 65626402, 65628146, 65626239, 65626787, 65626257, 65626896, 65628642, 65626213, 65626672]}, "name": "F2. Wrong Answer on test 233  Hard Version ", "statement": "Your program fails again. This time it gets \"\".The problem is to finish\r\nn one-choice-questions. Each of the questions contains k options, and\r\nonly one of them is correct. The answer to the i-th question is h_{i},\r\nand if your answer of the question i is h_{i}, you earn 1 point,\r\notherwise, you earn 0 points for this question. The values h_1, h_2,\r\ndots, h_n are known to you in this problem.However, you have a mistake\r\nin your program. It moves the answer clockwise! Consider all the n\r\nanswers are written in a circle. Due to the mistake in your program,\r\nthey are shifted by one cyclically.Formally, the mistake moves the\r\nanswer for the question i to the question i\r\nbmod n + 1. So it moves the answer for the question 1 to question 2, the\r\nanswer for the question 2 to the question 3, ..., the answer for the\r\nquestion n to the question 1.We call all the n answers together an .\r\nThere are k^n possible answer suits in total.You\u2019re wondering, how many\r\nanswer suits satisfy the following condition: . You need to find the\r\nanswer modulo 998\r\n,244\r\n,353.For example, if n = 5, and your answer suit is a=[1,2,3,4,5], it\r\nwill submitted as a\u2019=[5,1,2,3,4] because of a mistake. If the correct\r\nanswer suit is h=[5,2,2,3,4], the answer suit a earns 1 point and the\r\nanswer suite a\u2019 earns 4 points. Since 4 > 1, the answer suit\r\na=[1,2,3,4,5] should be counted.\r\n", "solutions": ["//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 200000 + 239;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\n//const int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N], rfact[N];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N - 1] = rev(fact[N - 1]);\n    repb(i, N - 2, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint a[N];\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, k;\n    cin >> n >> k;\n    rep(i, 0, n) {\n        cin >> a[i];\n    }\n    if (k == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int cnt = 0, cnt1 = 0;\n    rep(i, 0, n) {\n        if (a[i] == a[(i + 1) % n]) {\n            cnt1++;\n        } else {\n            cnt++;\n        }\n    }\n    ll ans = 0;\n    rep(c, 1, cnt + 1) {\n        ll tmp = bin_pow(2, c);\n        if (c % 2 == 0) {\n            tmp = (tmp - C(c, c / 2) + MOD) % MOD;\n        }\n        tmp = tmp * rev(2) % MOD;\n        tmp = tmp * C(cnt, c) % MOD;\n        ans = (ans + tmp * bin_pow(k - 2, cnt - c)) % MOD;\n    }\n    ans = ans * bin_pow(k, cnt1) % MOD;\n    cout << ans << \"\\n\";\n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "math"], "dificulty": "2400", "interactive": false}