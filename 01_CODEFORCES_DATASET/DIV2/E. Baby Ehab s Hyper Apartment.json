{
    "link": "https://codeforces.com//contest/1514/problem/E",
    "problemId": "962262",
    "problem_idx": "E",
    "shortId": "1514E",
    "contest_number": "1514",
    "problem_submissions": {
        "E": [
            113528522,
            113530195,
            113565998,
            113829004,
            113597935,
            113646044,
            113584968,
            113566286,
            113569074
        ],
        "D": [
            113508768,
            113510778,
            113502539,
            113509039,
            113502444,
            116142094,
            113508651,
            113514400,
            113508947,
            113510664,
            113510706,
            113513958,
            113537785,
            113515183,
            113514322,
            113510627,
            113510608,
            113515221,
            113512482,
            113511797,
            113512424,
            113510335
        ],
        "C": [
            113497839,
            113503895,
            113492438,
            113500977,
            113496051,
            125221398,
            113496633,
            113501835,
            113497325,
            113497426,
            113503146,
            113504263,
            113499255,
            113504094,
            113504124,
            113506035,
            113503284,
            113501631,
            113505697,
            113499549,
            113501744
        ],
        "B": [
            113492786,
            113495281,
            113492225,
            113493324,
            113492091,
            125221427,
            113503162,
            113493531,
            113492227,
            113493586,
            113492727,
            113494979,
            113494843,
            113496894,
            113495291,
            113492924,
            113490836,
            113494606,
            113493594,
            113494186,
            113493708
        ],
        "A": [
            113490269,
            113491100,
            113495047,
            113490072,
            113489948,
            125221450,
            113504457,
            113489912,
            113489857,
            113490379,
            113490423,
            113490999,
            113495292,
            113490189,
            113492252,
            113490413,
            113493815,
            113492689,
            113490314,
            113489923,
            113490126
        ]
    },
    "name": "E. Baby Ehab s Hyper Apartment",
    "statement": "Baby Ehab loves crawling around his apartment. It has n rooms numbered\r\nfrom 0 to n-1. For every pair of rooms, a and b, there\u2019s either a direct\r\npassage from room a to room b, or from room b to room a, but never\r\nboth.Baby Ehab wants to go play with Baby Badawy. He wants to know if he\r\ncould get to him. However, he doesn\u2019t know anything about his apartment\r\nexcept the number of rooms. He can ask the baby sitter two types of\r\nquestions: is the passage between room a and room b directed from a to b\r\nor the other way around? does room x have a passage towards any of the\r\nrooms s_1, s_2, ..., s_k? He can ask at most 9n queries of the first\r\ntype and at most 2n queries of the second type.After asking some\r\nquestions, he wants to know for every pair of rooms a and b whether\r\nthere\u2019s a path from a to b or not. A path from a to b is a sequence of\r\npassages that starts from room a and ends at room b.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nint q[500];\n\nint hid[150][150];\n\nint ca, co, n;\n\nint ask(int v, int u) {\n    ca++;\n    assert(ca <= 9 * n);\n#ifndef ONPC\n    cout << \"1 \" << v << ' ' << u << endl;\n    int w;\n    cin >> w;\n    return w;\n#else\n    return hid[v][u];\n#endif\n}\n\nint ok(int v, vector<int> u) {\n    co++;\n    assert(co <= 2 * n);\n#ifndef ONPC\n    cout << \"2 \" << v << ' ' << u.size();\n    for (int i : u)\n        cout << ' ' << i;\n    cout << endl;\n    int w;\n    cin >> w;\n    return w;\n#else\n    for (int i : u)\n        if (hid[v][i])\n            return 1;\n    return 0;\n#endif\n}\n\nvoid init(int v, int l, int r) {\n    if (l == r) {\n        q[v] = l;\n        return;\n    }\n    int m = (l + r) / 2;\n    init(2 * v, l, m);\n    init(2 * v + 1, m + 1, r);\n    if (ask(q[2 * v], q[2 * v + 1]))\n        q[v] = q[2 * v];\n    else\n        q[v] = q[2 * v + 1];\n}\n\nvoid go(int v, int l, int r) {\n    if (l == r) {\n        q[v] = -1;\n        return;\n    }\n    int m = (l + r) / 2;\n    if (q[2 * v] == q[v]) {\n        go(2 * v, l, m);\n    } else {\n        go(2 * v + 1, m + 1, r);\n    }\n    if (q[2 * v] == -1)\n        q[v] = q[2 * v + 1];\n    else if (q[2 * v + 1] == -1)\n        q[v] = q[2 * v];\n    else if (ask(q[2 * v], q[2 * v + 1]))\n        q[v] = q[2 * v];\n    else\n        q[v] = q[2 * v + 1];\n}\n\nvoid trav(int v, int l, int r) {\n    cerr << v << ' ' << q[v] << '\\n';\n    if (l == r)\n        return;\n    int m = (l + r) / 2;\n    trav(2 * v, l, m);\n    trav(2 * v + 1, m + 1, r);\n}\n\nint p[200];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return 0;\n    if (x > y)\n        swap(x, y);\n    p[y] = x;\n    return 1;\n}\n\nvoid solve() {\n    ca = co = 0;\n    n = 10;\n    cin >> n;\n#ifdef ONPC\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++) {\n            hid[i][j] = (i < j);\n            if (i > 0)\n                hid[i][j] = rnd() & 1;\n            //hid[i][j] = rnd() % 2;\n            hid[j][i] = !hid[i][j];\n        }\n#endif\n    init(1, 0, n - 1);\n    vector<int> q;\n    //\n    for (int i = 0; i < n; i++) {\n        q.push_back(::q[1]);\n        //trav(1, 0, n - 1);\n        go(1, 0, n - 1);\n    }\n    //trav(1, 0, n - 1);\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n; i++) {\n        while (1) {\n            int x = get(i);\n            if (x == 0)\n                break;\n            int w = ok(q[i], vector<int>(q.begin(), q.begin() + x));\n            if (w == 1) {\n                uni(x, x - 1);\n            } else {\n                break;\n            }\n        }\n    }\n    cout << 3 << endl;\n    vector<vector<int>> g(n, vector<int>(n));\n    for (int i = 0; i < n; i++)\n        for (int j = i; j < n; j++)\n            g[q[i]][q[j]] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = i - 1; j >= 0; j--)\n            if (get(i) == get(j))\n                g[q[i]][q[j]] = 1;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << g[i][j];\n        }\n        cout << endl;\n    }\n    int ueban_tishachnogo_ranga;\n    cin >> ueban_tishachnogo_ranga;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    t = 100;\n    cin >> t;\n    while (t--) {\n        //cerr << t << '\\n';\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "graphs",
        "interactive",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Baby Ehab s Hyper Apartment.json",
    "editorial_link": "https://codeforces.com//blog/entry/89810",
    "editorial": "Throughout the editorial, I\u00e2\u0080\u0099ll call the first type of queries OneEdge\r\nand the second type ManyEdges. The basic idea behind this problem is to\r\nfind a few edges such that every path that could be traversed in your\r\ngraph could be traversed using only these edges. With that motivation in\r\nmind, let\u00e2\u0080\u0099s get started. The first observation is: the graph has a\r\nhamiltonian path. To prove this, suppose you split the graph into\r\nhalves, each containing some of the nodes. Then, we\u00e2\u0080\u0099ll proceed by\r\ninduction. Suppose each half has a hamiltonian path. I\u00e2\u0080\u0099ll describe a way\r\nto merge them into one path. First, let\u00e2\u0080\u0099s look at the first node in each\r\npath and ask about the edge between them. Suppose it\u00e2\u0080\u0099s directed from the\r\nfirst to the second one. Then, I\u00e2\u0080\u0099ll start my new merged path with the\r\nfirst node, remove it, and repeat. This works because no matter which\r\nnode follows it, it sends an edge out to it. This is best described by\r\nthe following picture: We start with the hamiltonian paths we got by\r\ninduction, then we query that red edge. We find that it\u00e2\u0080\u0099s from the grey\r\nnode to the white node. We then put our grey node as the start of the\r\npath and continue doing that with the rest of the nodes, and we don\u00e2\u0080\u0099t\r\ncare which node will follow it, because the edge is out from the black\r\nnode either way! If everything falls into place in your mind, you should\r\nrecognize that this algorithm is merge sort. We just run merge sort on\r\nthe nodes of the graph, using the comparator OneEdge. That gives you a\r\nhamiltonian path in queries. Now that we have a hamiltonian path, every\r\nedge that goes forward in it is useless, since you can just walk down\r\nthe path itself: So let\u00e2\u0080\u0099s focus on the edges going backwards. Suppose we\r\niterate through the hamiltonian path from its end to its beginning,\r\nlooking at the edges going back from the nodes we met. An edge going\r\nbackwards from the current node is important only if it goes back\r\nfurther than any of the edges we\u00e2\u0080\u0099ve met so far. That\u00e2\u0080\u0099s because we can\r\ntake a (much less direct) route instead of this edge if it doesn\u00e2\u0080\u0099t go so\r\nfar back: Now with a few more edges we can form all the paths! How do we\r\nget these edges? We can use pointers. Let\u00e2\u0080\u0099s iterate through the\r\nhamiltonian path from its end to its beginning, carrying a pointer that\r\ntells us how far back the edges we met so far can go. To update , let\u00e2\u0080\u0099s\r\nask ManyEdges from the node we\u00e2\u0080\u0099re currently at, to the first nodes in\r\nthe hamiltonian path. While the answer is , we\u00e2\u0080\u0099ll keep decreasing . This\r\nalgorithm calls ManyEdges times, since every time we call it, it either\r\nreturns and the node we\u00e2\u0080\u0099re at decreases, or it returns and decreases.\r\nCode link: https://pastebin.com/RU1yA697 Bonus task: can you get the\r\nhamiltonian path using insertion sort instead?\r\n"
}