{"link": "https://codeforces.com//contest/1514/problem/E", "problemId": "962262", "problem_idx": "E", "shortId": "1514E", "contest_number": "1514", "problem_submissions": {"E": [113528522, 113530195, 113565998, 113829004, 113597935, 113646044, 113584968, 113566286, 113569074], "D": [113508768, 113510778, 113502539, 113509039, 113502444, 116142094, 113508651, 113514400, 113508947, 113510664, 113510706, 113513958, 113537785, 113515183, 113514322, 113510627, 113510608, 113515221, 113512482, 113511797, 113512424, 113510335], "C": [113497839, 113503895, 113492438, 113500977, 113496051, 125221398, 113496633, 113501835, 113497325, 113497426, 113503146, 113504263, 113499255, 113504094, 113504124, 113506035, 113503284, 113501631, 113505697, 113499549, 113501744], "B": [113492786, 113495281, 113492225, 113493324, 113492091, 125221427, 113503162, 113493531, 113492227, 113493586, 113492727, 113494979, 113494843, 113496894, 113495291, 113492924, 113490836, 113494606, 113493594, 113494186, 113493708], "A": [113490269, 113491100, 113495047, 113490072, 113489948, 125221450, 113504457, 113489912, 113489857, 113490379, 113490423, 113490999, 113495292, 113490189, 113492252, 113490413, 113493815, 113492689, 113490314, 113489923, 113490126]}, "name": "E. Baby Ehab s Hyper Apartment", "statement": "Baby Ehab loves crawling around his apartment. It has n rooms numbered\r\nfrom 0 to n-1. For every pair of rooms, a and b, there\u2019s either a direct\r\npassage from room a to room b, or from room b to room a, but never\r\nboth.Baby Ehab wants to go play with Baby Badawy. He wants to know if he\r\ncould get to him. However, he doesn\u2019t know anything about his apartment\r\nexcept the number of rooms. He can ask the baby sitter two types of\r\nquestions: is the passage between room a and room b directed from a to b\r\nor the other way around? does room x have a passage towards any of the\r\nrooms s_1, s_2, ..., s_k? He can ask at most 9n queries of the first\r\ntype and at most 2n queries of the second type.After asking some\r\nquestions, he wants to know for every pair of rooms a and b whether\r\nthere\u2019s a path from a to b or not. A path from a to b is a sequence of\r\npassages that starts from room a and ends at room b.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nint q[500];\n\nint hid[150][150];\n\nint ca, co, n;\n\nint ask(int v, int u) {\n    ca++;\n    assert(ca <= 9 * n);\n#ifndef ONPC\n    cout << \"1 \" << v << ' ' << u << endl;\n    int w;\n    cin >> w;\n    return w;\n#else\n    return hid[v][u];\n#endif\n}\n\nint ok(int v, vector<int> u) {\n    co++;\n    assert(co <= 2 * n);\n#ifndef ONPC\n    cout << \"2 \" << v << ' ' << u.size();\n    for (int i : u)\n        cout << ' ' << i;\n    cout << endl;\n    int w;\n    cin >> w;\n    return w;\n#else\n    for (int i : u)\n        if (hid[v][i])\n            return 1;\n    return 0;\n#endif\n}\n\nvoid init(int v, int l, int r) {\n    if (l == r) {\n        q[v] = l;\n        return;\n    }\n    int m = (l + r) / 2;\n    init(2 * v, l, m);\n    init(2 * v + 1, m + 1, r);\n    if (ask(q[2 * v], q[2 * v + 1]))\n        q[v] = q[2 * v];\n    else\n        q[v] = q[2 * v + 1];\n}\n\nvoid go(int v, int l, int r) {\n    if (l == r) {\n        q[v] = -1;\n        return;\n    }\n    int m = (l + r) / 2;\n    if (q[2 * v] == q[v]) {\n        go(2 * v, l, m);\n    } else {\n        go(2 * v + 1, m + 1, r);\n    }\n    if (q[2 * v] == -1)\n        q[v] = q[2 * v + 1];\n    else if (q[2 * v + 1] == -1)\n        q[v] = q[2 * v];\n    else if (ask(q[2 * v], q[2 * v + 1]))\n        q[v] = q[2 * v];\n    else\n        q[v] = q[2 * v + 1];\n}\n\nvoid trav(int v, int l, int r) {\n    cerr << v << ' ' << q[v] << '\\n';\n    if (l == r)\n        return;\n    int m = (l + r) / 2;\n    trav(2 * v, l, m);\n    trav(2 * v + 1, m + 1, r);\n}\n\nint p[200];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return 0;\n    if (x > y)\n        swap(x, y);\n    p[y] = x;\n    return 1;\n}\n\nvoid solve() {\n    ca = co = 0;\n    n = 10;\n    cin >> n;\n#ifdef ONPC\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++) {\n            hid[i][j] = (i < j);\n            if (i > 0)\n                hid[i][j] = rnd() & 1;\n            //hid[i][j] = rnd() % 2;\n            hid[j][i] = !hid[i][j];\n        }\n#endif\n    init(1, 0, n - 1);\n    vector<int> q;\n    //\n    for (int i = 0; i < n; i++) {\n        q.push_back(::q[1]);\n        //trav(1, 0, n - 1);\n        go(1, 0, n - 1);\n    }\n    //trav(1, 0, n - 1);\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n; i++) {\n        while (1) {\n            int x = get(i);\n            if (x == 0)\n                break;\n            int w = ok(q[i], vector<int>(q.begin(), q.begin() + x));\n            if (w == 1) {\n                uni(x, x - 1);\n            } else {\n                break;\n            }\n        }\n    }\n    cout << 3 << endl;\n    vector<vector<int>> g(n, vector<int>(n));\n    for (int i = 0; i < n; i++)\n        for (int j = i; j < n; j++)\n            g[q[i]][q[j]] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = i - 1; j >= 0; j--)\n            if (get(i) == get(j))\n                g[q[i]][q[j]] = 1;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << g[i][j];\n        }\n        cout << endl;\n    }\n    int ueban_tishachnogo_ranga;\n    cin >> ueban_tishachnogo_ranga;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    t = 100;\n    cin >> t;\n    while (t--) {\n        //cerr << t << '\\n';\n        solve();\n    }\n}"], "input": "", "output": "", "tags": ["binary search", "graphs", "interactive", "sortings", "two pointers"], "dificulty": "2700", "interactive": false}