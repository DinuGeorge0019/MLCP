{
    "link": "https://codeforces.com//contest/1143/problem/E",
    "problemId": "322170",
    "problem_idx": "E",
    "shortId": "1143E",
    "contest_number": "1143",
    "problem_submissions": {
        "F": [
            52053740,
            52050934,
            52050482,
            52062719,
            52055575,
            52054357,
            52076504
        ],
        "E": [
            52046060,
            52048486,
            52043358,
            52058930,
            52058895,
            52049207,
            55234591,
            52050524,
            52048224,
            52050760,
            52051220,
            52053112,
            52050926,
            52052963,
            52050945,
            52050663,
            52053672,
            52036984,
            52045903,
            52047555,
            52045657
        ],
        "D": [
            52040246,
            52046189,
            52043627,
            52047099,
            52042762,
            52041339,
            52043500,
            52043687,
            52042595,
            52044385,
            52045161,
            52053326,
            52047450,
            52055219,
            52044406,
            52056142
        ],
        "C": [
            52036464,
            52037535,
            52035451,
            52038786,
            52041257,
            52036692,
            52038846,
            52038521,
            52038180,
            52037738,
            52037545,
            52038495,
            52044091,
            52038551,
            52042781,
            52055743,
            52055719,
            52040142,
            52039670,
            52037936,
            52038436,
            52040034
        ],
        "B": [
            52033342,
            52033709,
            52032791,
            52033130,
            52035639,
            52033900,
            52034782,
            52034155,
            52034558,
            52034491,
            52039225,
            52034867,
            52038126,
            52034618,
            52038019,
            52033785,
            52033506,
            52033683,
            52034719,
            52033623
        ],
        "A": [
            52030926,
            52030199,
            52030454,
            52030456,
            52032409,
            52030129,
            52032198,
            52031102,
            52031072,
            52030448,
            52032154,
            52030694,
            52034881,
            52030728,
            52032731,
            52030521,
            52030424,
            52030417,
            52030138,
            52030163
        ]
    },
    "name": "E. Lynyrd Skynyrd",
    "statement": "Recently Lynyrd and Skynyrd went to a shop where Lynyrd bought a\r\npermutation p of length n, and Skynyrd bought an array a of length m,\r\nconsisting of integers from 1 to n. Lynyrd and Skynyrd became bored, so\r\nthey asked you q queries, each of which has the following form: \"does\r\nthe subsegment of a from the l-th to the r-th positions, inclusive, have\r\na subsequence that is a cyclic shift of p?\" Please answer the queries.A\r\nof length n is a sequence of n integers such that each integer from 1 to\r\nn appears exactly once in it.A of a permutation (p_1, p_2,\r\nldots, p_n) is a permutation (p_i, p_{i + 1},\r\nldots, p_{n}, p_1, p_2,\r\nldots, p_{i - 1}) for some i from 1 to n. For example, a permutation (2,\r\n1, 3) has three distinct cyclic shifts: (2, 1, 3), (1, 3, 2), (3, 2,\r\n1).A of a subsegment of array a from the l-th to the r-th positions,\r\ninclusive, is a sequence a_{i_1}, a_{i_2},\r\nldots, a_{i_k} for some i_1, i_2,\r\nldots, i_k such that l\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq r.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N=2e5+10;\nint a[N],b[N],c[N],n,m,q;\nint nex[N],nx[N][20],la[N];\nint ans[N];\nint main(){\n\tcin>>n>>m>>q;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&c[i]),nex[c[i-1]]=c[i];\n\tnex[c[n]]=c[1];\n\tfor (int i=1;i<=m;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)la[i]=m+1;\n\tans[m+1]=m+1;\n\tfor (int i=0;i<20;i++)nx[m+1][i]=m+1;\n\tfor (int i=m;i>=1;i--){\n\t\tnx[i][0]=la[nex[a[i]]];\n\t\tla[a[i]]=i;\n\t\tfor (int u=1;u<20;u++)nx[i][u]=nx[nx[i][u-1]][u-1];\n\t\tint x=n-1,p=i;\n\t\tfor (int u=19;~u;u--)\n\t\t\tif (x>=(1<<u))x-=(1<<u),p=nx[p][u];\n\t\tans[i]=min(p,ans[i+1]);\n\t}\n\twhile (q--){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tputchar('0'+(ans[l]<=r));\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Lynyrd Skynyrd.json",
    "editorial_link": "https://codeforces.com//blog/entry/66301",
    "editorial": "For each ai\n if the number ai\n has position j\n in p\n, let's find the greatest l\n, such that l\n is less then i\n and al=pj?1\n (let's define p0=pn\n) We will call this position bi\n. This can be done in O(n)\n time, just for each pj\n we will keep the last it's position in a\n while iterating over a\n.\n\nNow let's notice that using this info for each i\n we can find the beginning of right most subsequence of a\n which is a ciclic shift of p\n and ends exactly at ai\n. This can easily be done because if there is a subsequence of a\n ai1,ai2,ain?1,ai\n, which is the right most such subsequence, then in?1\n is bi\n, in?2\n is bin?1\n, and so on. So to find such subsequence and the position of it's beginning, we need to calculate b[b[bb[i]]]\n n?1\n times. To do it we can use binary lifting. Then we will have O(mlogn)\n precalc and we will get the beginning of such subsequence in O(logn)\n time.\n\nNow for each prefix of a\n let's calculate the the beginning of right most subsequence of it, which is a cyclic shift of p\n. This can be calculated in linear time, first we look at the answer for this prefix without the last number, and then update it with the right most subsequence, which ends at the end of prefix.\n\nNow we can answer each query in O(1)\n time, because we just need to find the beginning of the right most subsequence, which ends at prefix of length r\n and compare it with l\n.",
    "hint": []
}