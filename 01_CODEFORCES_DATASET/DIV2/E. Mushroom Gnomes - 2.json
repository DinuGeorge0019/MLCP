{
    "link": "https://codeforces.com//contest/139/problem/E",
    "problemId": "731",
    "problem_idx": "E",
    "shortId": "139E",
    "contest_number": "139",
    "problem_submissions": {
        "E": [
            980042,
            1355508,
            989840
        ],
        "D": [
            978407,
            979258,
            981500,
            981141,
            981629,
            981112,
            981003,
            978361,
            980314,
            982438
        ],
        "C": [
            976486,
            980221,
            979576,
            975661,
            979182,
            978241,
            976343,
            980246,
            977234,
            977300,
            980151,
            975292,
            976905,
            979088,
            978354,
            975803
        ],
        "B": [
            975799,
            976102,
            976580,
            980368,
            976461,
            976842,
            977973,
            977389,
            975833,
            975600,
            976651,
            976089,
            975820,
            976583,
            976416,
            977370
        ],
        "A": [
            974412,
            974563,
            974849,
            979612,
            974810,
            975009,
            974390,
            974654,
            984067,
            974272,
            974267,
            976572,
            974588,
            974309,
            974688,
            974303,
            977612
        ]
    },
    "name": "E. Mushroom Gnomes - 2",
    "statement": "One day Natalia was walking in the woods when she met a little mushroom\r\ngnome. The gnome told her the following story:Everybody knows that the\r\nmushroom gnomes\u2019 power lies in the magic mushrooms that grow in the\r\nnative woods of the gnomes. There are trees and magic mushrooms in the\r\nwoods: the -th tree grows at a point on a straight line with coordinates\r\nand has the height of , the -th mushroom grows at the point with\r\ncoordinates and has magical powers .But one day wild mushroommunchers,\r\nthe sworn enemies of mushroom gnomes unleashed a terrible storm on their\r\nhome forest. As a result, some of the trees began to fall and crush the\r\nmagic mushrooms. The supreme oracle of mushroom gnomes calculated in\r\nadvance the probability for each tree that it will fall to the left, to\r\nthe right or will stand on. If the tree with the coordinate and height\r\nfalls to the left, then all the mushrooms that belong to the right-open\r\ninterval , are destroyed. If a tree falls to the right, then the\r\nmushrooms that belong to the left-open interval are destroyed. Only\r\nthose mushrooms that are not hit by a single tree survive.Knowing that\r\nall the trees fall independently of each other (i.e., all the events are\r\nmutually independent, and besides, the trees do not interfere with other\r\ntrees falling in an arbitrary direction), the supreme oracle was also\r\nable to quickly calculate what would be the expectation of the total\r\npower of the mushrooms which survived after the storm. His calculations\r\nultimately saved the mushroom gnomes from imminent death.Natalia, as a\r\ngood Olympiad programmer, got interested in this story, and she decided\r\nto come up with a way to quickly calculate the expectation of the sum of\r\nthe surviving mushrooms\u2019 power.\r\n",
    "solutions": [
        "#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, s, t) for(i = (s); i < (t); i++)\n#define RFOR(i, s, t) for(i = (s)-1; i >= (t); i--)\nconst int MAXN = 100004;\nconst int MAXM = 10004;\n\npair<int, double> cha[MAXN*2];\npair<int, int> mus[MAXM];\n\nint x[MAXN], h[MAXN], l[MAXN], r[MAXN];\ndouble p[MAXM];\n\nint main()\n{\n  #ifdef __FIO\n  freopen(\"in.txt\", \"r\", stdin);\n  freopen(\"out.txt\", \"w\", stdout);\n  #endif\n  int n, m;\n  int i, j;\n  double t;\n  scanf(\"%d%d\", &n, &m);\n  for(i = 0; i < n; i++)\n  {\n    scanf(\"%d%d%d%d\", &x[i], &h[i], &l[i], &r[i]);\n  }\n  for(i = 0; i < m; i++)\n    scanf(\"%d%lf\", &mus[i].fi, &p[i]);\n  for(i = 0; i < m; i++)\n    mus[i].se = i;\n  sort(mus, mus+m);\n  for(i = 0; i < n; i++)\n  {\n    if(r[i] != 100)\n    {\n      cha[i] = mp(x[i], (100-r[i])/100.);\n      cha[i+n] = mp(x[i]+h[i], 100./(100-r[i]));\n    }\n    else\n    {\n      cha[i] = mp(x[i], 1e-10);\n      cha[i+n] = mp(x[i]+h[i], 1e10);\n    }\n  }\n  sort(cha, cha+n*2);\n  i = 0;\n  j = 0;\n  t = 0.;\n  while(i < 2*n && j < m)\n  {\n    if(cha[i].fi < mus[j].fi)\n    {\n      t += log(cha[i++].se);\n    }\n    else\n    {\n      p[mus[j++].se] *= exp(t);\n    }\n  }\n  for(i = 0; i < n; i++)\n  {\n    if(l[i] != 100)\n    {\n      cha[i] = mp(x[i]-h[i], (100-l[i])/100.);\n      cha[i+n] = mp(x[i], 100./(100-l[i]));\n    }\n    else\n    {\n      cha[i] = mp(x[i]-h[i], 1e-10);\n      cha[i+n] = mp(x[i], 1e10);\n    }\n  }\n  sort(cha, cha+n*2);\n  i = 0;\n  j = 0;\n  t = 0.;\n  while(i < 2*n && j < m)\n  {\n    if(cha[i].fi <= mus[j].fi)\n    {\n      t += log(cha[i++].se);\n    }\n    else\n    {\n      p[mus[j++].se] *= exp(t);\n    }\n  }\n  t = 0.;\n  for(i = 0; i < m; i++)\n    t += p[i];\n  cout<<t<<endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "probabilities",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Mushroom Gnomes - 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/3462",
    "editorial": "First of all - the answer is the sum for all mushrooms of the probabilities of not being destroyed multiplied by that mushroom's power. That is a simple property of random variables' means.\n\nSo we come to the equivalent statement: we still have mushrooms, but now instead of trees we have a family of segments with probabilities arranged to them. Every segment \"exists\" with this probability, otherwise it doesn't, and all these events are independent. We want to count the sum of probabilities (with weights) for each mushroom not to lie in any \"existing\" segment. (Note that we can reformulate the statement this way because any segments containing any fixed point are truly independent: they can't belong to the same tree. Thus the probability to survive for any point in this statement is equal to the probability for this point in the original statement).\n\nNow, how do we count this? There are several ways:\n\n1) \"Scanning line\". If we go from left to right, we can meet three kinds of events: \"the segment i started\", \"the segment i finished\", \"the mushroom j found\". We can easily support the probability of current point being covered by \"existing\" segment if we multiply it by segment's probability when we find its beginning and divide by it if we find its end. If we find a mushroom by the way, we can add the known probability to answer (multiplied by its power). To perform the above trick we just sort the array of events by x-coordinate and iterate over it.\n\nThis solution is good in theory, but in practice it has a flaw: if the number of segments is large, after multiplying lots of real numbers less then 1 we can exceed the negative explonent of the real type used, and thus get a 0 in a variable instead of desired value. And after any number of divisions it still would be 0, so we couldn't get any sane answer anymore.\n\nThis trouble can be resolved in several ways (without changing the solution much):\n\na) We can have no more than 101 distinct values of probabilities for segments. So, if we store an array for quantities of segments containing current point and having a corresponding probability, we just add and substract 1's from array's elements. When we find a mushroom we find the product of degrees with exponents stored in array, spending ~100 operations.\n\nb) We can store a set of segments containing current point. Every operation with set works in O(log N) time, and iterating over the whole set works in O(N) time. So, upon meeting mushroom we iterate over set and multiply the probabilities for all segments in it.\nThe next thing that helps us is that we can drop the answer for current mushroom if it's too small. If we don't store the segments with probability 1, the most number of segments which probabilities' product more than 1e-8 is about 2000 (since 0.99 ^ 2000 < 1e-8). So we can count everything in time.\n\nc) If we use logs of probabilities instead of themselves, we have to add and substract them instead of multiplying and dividing. This way we won't encounter any precision troubles.\n\n2) Segment tree.\n\nLet's sort the mushrooms by their coordinates. Let's also assume we have some set of segments and already counted the desired probabilities. And now we want to add a new segment to the set. What will change? The probabilities of mushrooms lying in this segment (and thus forming a segment in the array) will multiply by segment's probability.\nNow it's clear we can use multiplication segment tree (or simple addition segment tree if we use logs again) to perform the queries for all segments and then sum up the elements in the end.\n\nAbout the strange score and pretest: we discovered the trouble with precision quite late, and realized that it makes the problem way harder ('cause it's hard to predict during writing and submission phases). What's worse, it won't show itself on the small tests. So we decided to \"show up\" the test and let the contestants solve this additional problem, for additional score. (However, not all solutions from above list do actually deal with this problem. Unfortunately, we didn't came up with them beforehand.)"
}