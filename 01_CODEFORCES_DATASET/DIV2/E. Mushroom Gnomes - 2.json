{"link": "https://codeforces.com//contest/139/problem/E", "problemId": "731", "problem_idx": "E", "shortId": "139E", "contest_number": "139", "problem_submissions": {"E": [980042, 1355508, 989840], "D": [978407, 979258, 981500, 981141, 981629, 981112, 981003, 978361, 980314, 982438], "C": [976486, 980221, 979576, 975661, 979182, 978241, 976343, 980246, 977234, 977300, 980151, 975292, 976905, 979088, 978354, 975803], "B": [975799, 976102, 976580, 980368, 976461, 976842, 977973, 977389, 975833, 975600, 976651, 976089, 975820, 976583, 976416, 977370], "A": [974412, 974563, 974849, 979612, 974810, 975009, 974390, 974654, 984067, 974272, 974267, 976572, 974588, 974309, 974688, 974303, 977612]}, "name": "E. Mushroom Gnomes - 2", "statement": "One day Natalia was walking in the woods when she met a little mushroom\r\ngnome. The gnome told her the following story:Everybody knows that the\r\nmushroom gnomes\u2019 power lies in the magic mushrooms that grow in the\r\nnative woods of the gnomes. There are trees and magic mushrooms in the\r\nwoods: the -th tree grows at a point on a straight line with coordinates\r\nand has the height of , the -th mushroom grows at the point with\r\ncoordinates and has magical powers .But one day wild mushroommunchers,\r\nthe sworn enemies of mushroom gnomes unleashed a terrible storm on their\r\nhome forest. As a result, some of the trees began to fall and crush the\r\nmagic mushrooms. The supreme oracle of mushroom gnomes calculated in\r\nadvance the probability for each tree that it will fall to the left, to\r\nthe right or will stand on. If the tree with the coordinate and height\r\nfalls to the left, then all the mushrooms that belong to the right-open\r\ninterval , are destroyed. If a tree falls to the right, then the\r\nmushrooms that belong to the left-open interval are destroyed. Only\r\nthose mushrooms that are not hit by a single tree survive.Knowing that\r\nall the trees fall independently of each other (i.e., all the events are\r\nmutually independent, and besides, the trees do not interfere with other\r\ntrees falling in an arbitrary direction), the supreme oracle was also\r\nable to quickly calculate what would be the expectation of the total\r\npower of the mushrooms which survived after the storm. His calculations\r\nultimately saved the mushroom gnomes from imminent death.Natalia, as a\r\ngood Olympiad programmer, got interested in this story, and she decided\r\nto come up with a way to quickly calculate the expectation of the sum of\r\nthe surviving mushrooms\u2019 power.\r\n", "solutions": ["#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, s, t) for(i = (s); i < (t); i++)\n#define RFOR(i, s, t) for(i = (s)-1; i >= (t); i--)\nconst int MAXN = 100004;\nconst int MAXM = 10004;\n\npair<int, double> cha[MAXN*2];\npair<int, int> mus[MAXM];\n\nint x[MAXN], h[MAXN], l[MAXN], r[MAXN];\ndouble p[MAXM];\n\nint main()\n{\n  #ifdef __FIO\n  freopen(\"in.txt\", \"r\", stdin);\n  freopen(\"out.txt\", \"w\", stdout);\n  #endif\n  int n, m;\n  int i, j;\n  double t;\n  scanf(\"%d%d\", &n, &m);\n  for(i = 0; i < n; i++)\n  {\n    scanf(\"%d%d%d%d\", &x[i], &h[i], &l[i], &r[i]);\n  }\n  for(i = 0; i < m; i++)\n    scanf(\"%d%lf\", &mus[i].fi, &p[i]);\n  for(i = 0; i < m; i++)\n    mus[i].se = i;\n  sort(mus, mus+m);\n  for(i = 0; i < n; i++)\n  {\n    if(r[i] != 100)\n    {\n      cha[i] = mp(x[i], (100-r[i])/100.);\n      cha[i+n] = mp(x[i]+h[i], 100./(100-r[i]));\n    }\n    else\n    {\n      cha[i] = mp(x[i], 1e-10);\n      cha[i+n] = mp(x[i]+h[i], 1e10);\n    }\n  }\n  sort(cha, cha+n*2);\n  i = 0;\n  j = 0;\n  t = 0.;\n  while(i < 2*n && j < m)\n  {\n    if(cha[i].fi < mus[j].fi)\n    {\n      t += log(cha[i++].se);\n    }\n    else\n    {\n      p[mus[j++].se] *= exp(t);\n    }\n  }\n  for(i = 0; i < n; i++)\n  {\n    if(l[i] != 100)\n    {\n      cha[i] = mp(x[i]-h[i], (100-l[i])/100.);\n      cha[i+n] = mp(x[i], 100./(100-l[i]));\n    }\n    else\n    {\n      cha[i] = mp(x[i]-h[i], 1e-10);\n      cha[i+n] = mp(x[i], 1e10);\n    }\n  }\n  sort(cha, cha+n*2);\n  i = 0;\n  j = 0;\n  t = 0.;\n  while(i < 2*n && j < m)\n  {\n    if(cha[i].fi <= mus[j].fi)\n    {\n      t += log(cha[i++].se);\n    }\n    else\n    {\n      p[mus[j++].se] *= exp(t);\n    }\n  }\n  t = 0.;\n  for(i = 0; i < m; i++)\n    t += p[i];\n  cout<<t<<endl;\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "probabilities", "sortings"], "dificulty": "2200", "interactive": false}