{
    "link": "https://codeforces.com//contest/1243/problem/B2",
    "problemId": "461413",
    "problem_idx": "B2",
    "shortId": "1243B2",
    "contest_number": "1243",
    "problem_submissions": {
        "E": [
            64413060,
            64469730,
            64408846,
            64417229,
            64399200,
            64470547,
            64416699,
            64442944
        ],
        "D": [
            64391286,
            64397713,
            64431742,
            64397869,
            64387912,
            64386733,
            64389402,
            64387675,
            64408229,
            64380388,
            64396146,
            64395794,
            64394593,
            64392997,
            64394432,
            64400786,
            64397002,
            64396496,
            64397563,
            64397111,
            64393509
        ],
        "C": [
            64384895,
            64387481,
            64390976,
            64405340,
            64382337,
            64385693,
            64385929,
            64394275,
            64434799,
            64386198,
            64382497,
            64383809,
            64377823,
            64389605,
            64376790,
            64385883,
            64378335,
            64383814,
            64387181,
            64382731,
            64387786
        ],
        "B2": [
            64382237,
            64381285,
            64379711,
            64392921,
            64382257,
            64380535,
            64394999,
            64387075,
            64388632,
            64389667,
            64386828,
            64401152,
            64379896,
            64404188,
            64390999,
            64383775,
            64439469,
            64397436,
            64400046
        ],
        "B1": [
            64376943,
            64376875,
            64382975,
            64410900,
            64376252,
            64375532,
            64376537,
            64399066,
            64383882,
            64379534,
            64379185,
            64385521,
            64377760,
            64384722,
            64375586,
            64377602,
            64378450,
            64377183,
            64379613,
            64377830
        ],
        "A": [
            64373589,
            64373694,
            64408041,
            64373563,
            64373607,
            64373538,
            64381662,
            64378360,
            64376936,
            64374179,
            64380404,
            64373751,
            64374463,
            64373629,
            64373483,
            64374884,
            64373477,
            64375133,
            64374905
        ]
    },
    "name": "B2. Character Swap  Hard Version ",
    "statement": "After struggling and failing many times, Ujan decided to try to clean up\r\nhis house again. He decided to get his strings in order first.Ujan has\r\ntwo strings s and t of length n consisting of only of lowercase English\r\ncharacters. He wants to make them equal. Since Ujan is lazy, he will\r\nperform the following operation at most 2n times: he takes two positions\r\ni and j (1\r\nle i,j\r\nle n, the values i and j can be equal or different), and swaps the\r\ncharacters s_i and t_j.Ujanâ€™s goal is to make the strings s and t equal.\r\nHe does not need to minimize the number of performed operations:\r\nsequence of operations of length 2n or shorter is suitable.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long   ll;\ntypedef long double ld;\n\n#define all(x)  (x).begin(), (x).end()\n#define sz(x)   (x).size()\n#define pb      push_back\n#define mp      make_pair\n#define fr      first\n#define sc      second\n\nstring s, t;\nint n;\n\nvoid input() {\n    cin >> n;\n    cin >> s >> t;\n}\n\nvoid solve() {\n    vector<int> cnts(26, 0);\n    for(char c : s) {\n        cnts[c - 'a']++;\n    }\n    for(char c : t) {\n        cnts[c - 'a']++;\n    }\n    for(int elem : cnts) {\n        if (elem & 1) {\n            puts(\"No\");\n            return;\n        }\n    }\n    vector<pair<int, int>> ans;\n    for(int i = 0; i < n; i++) {\n        if (s[i] == t[i]) continue;\n        bool fndt = 0;\n        for(int j = i + 1; j < n; j++) {\n            if (t[i] == t[j]) {\n                ans.emplace_back(i, j);\n                swap(s[i], t[j]);\n                fndt = true;\n                break;\n            }\n        }\n        if (fndt) continue;\n        for(int j = i + 1; j < n; j++) {\n            if (s[j] == t[i]) {\n                ans.emplace_back(j, i + 1);\n                swap(s[j], t[i + 1]);\n                ans.emplace_back(i, i + 1);\n                swap(s[i], t[i + 1]);\n                break;\n            }\n        }\n    }\n    puts(\"Yes\");\n    cout << sz(ans) << endl;\n    for(auto& pr : ans) {\n        cout << pr.fr + 1 << \" \" << pr.sc + 1 << endl;\n    }\n}\n\nint main() {\n    int testcases = 1;\n    scanf(\"%d\", &testcases);\n    while(testcases--) {\n        input();\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B2. Character Swap  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "We claim that you can make the strings equal if and only if the total\r\nnumber of each character in both of the strings and is even.Proof that\r\nthis is a necessary condition. If we can make the strings equal, then\r\nfor each position, the characters of and will be the same. Therefore,\r\neach character must appear an even number of times in both strings\r\ntogether.Algorithm, if all characters appear even number of times.\r\nIterate over the index from to . If , then one of the following cases\r\nholds: There is an index such that . Then simply swap with and then the\r\nstrings will have the same character at position . There is an index\r\nsuch that . Then first swap with , and then swap with . Again, the\r\nstrings will have the same character at position . Since we make at most\r\nswaps for each position, this algorithm produces two equal strings and\r\nmakes at most swaps in total. The complexity of the algorithm: .This\r\nproblem was introduced by [user:MikeMirzayanov] inspired by the easier\r\nversion of the problem (with a single swap).\r\n",
    "hint": []
}