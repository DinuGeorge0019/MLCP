{
    "link": "https://codeforces.com//contest/1457/problem/B",
    "problemId": "814142",
    "problem_idx": "B",
    "shortId": "1457B",
    "contest_number": "1457",
    "problem_submissions": {
        "E": [
            99868612,
            99868820,
            99868894,
            99871379,
            99876241,
            99873210,
            99873073,
            99877427,
            99875242,
            99874362,
            99880934,
            99878599,
            99880282,
            99880267,
            99880129,
            99881010,
            99881186,
            99878842,
            99883433,
            99887042
        ],
        "D": [
            99860413,
            99858501,
            99859224,
            99855503,
            99852261,
            99861676,
            99862738,
            99863057,
            99864198,
            99864361,
            99855111,
            99866971,
            99857047,
            99869259,
            99872023,
            99871057,
            99871185,
            99871389,
            99870989,
            99870957
        ],
        "C": [
            99848523,
            99846546,
            99854121,
            99849522,
            99849975,
            99852554,
            99857957,
            99855488,
            99850137,
            99854183,
            99851123,
            99848085,
            99862644,
            99857309,
            99851618,
            99858097,
            99853416,
            99850485,
            99861161,
            99863907
        ],
        "B": [
            99842172,
            99842416,
            99847160,
            99843642,
            99841920,
            99843802,
            99852704,
            99845703,
            99844331,
            99847361,
            99846671,
            99841358,
            99851090,
            99848157,
            99844121,
            99845368,
            99843677,
            99857603,
            99853155,
            99848846
        ],
        "A": [
            99839848,
            99840102,
            99841257,
            99839720,
            99841011,
            99840218,
            99839732,
            99841278,
            99840508,
            99841843,
            99839833,
            99839677,
            99846294,
            99845677,
            99840019,
            99840219,
            99840262,
            99842567,
            99843366,
            99841538
        ]
    },
    "name": "B. Repainting Street",
    "statement": "There is a street with n houses in a line, numbered from 1 to n. The\r\nhouse i is initially painted in color c_i. The street is considered\r\nbeautiful if all houses are painted in the same color. Tom, the painter,\r\nis in charge of making the street beautiful. Tom’s painting capacity is\r\ndefined by an integer, let’s call it k.On one day, Tom can do the\r\nfollowing repainting process that consists of two steps: He chooses two\r\nintegers l and r such that 1\r\nle l\r\nle r\r\nle n and r - l + 1 = k . For each house i such that l\r\nle i\r\nle r, he can either repaint it with any color he wants, or ignore it and\r\nlet it keep its current color. Note that in the same day Tom can use\r\ndifferent colors to repaint different houses.Tom wants to know the\r\nminimum number of days needed to repaint the street so that it becomes\r\nbeautiful.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pre(i,a,b) for(int i=a;i>=b;i--)\n#define N 100005\nusing namespace std;\nint n,k,a[N];\nint calc(int x){\n\tint now=0,ans=0;\n\trep(i,1,n){\n\t\tif(i<=now)continue;\n\t\tif(a[i]==x)continue;\n\t\tans++;now=i+k-1;\n\t}\n\treturn ans;\n}\nvoid solve(){\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,1,n)scanf(\"%d\",&a[i]);\n\tint ans=0x7fffffff;\n\trep(i,1,100)ans=min(ans,calc(i));\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--)solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Repainting Street.json",
    "editorial_link": "https://codeforces.com//blog/entry/85118",
    "editorial": "If we want to paint every house on the street with color x\n, it is easy to see that we need to change every house with color different from x\n, and not necessarily repaint houses already painted in color x\n. We can do the following greedy algorithm to minimize the number of days: Find leftmost house not painted in color x\n. Assume this is in position i\n. Then we will paint [i,i+k?1]\n with color x\n. Repeat this until all houses are painted in color x\n. Why is this optimal? When we find the leftmost house not painted in x\n, we know we need to change it, and as it is the leftmost one, everything before it is painted in x\n. To maximize our chances of changing other houses that need repainting, we choose this as the leftmost position in our painting range. This can be implemented easily with a linear pass. However, we don't know the color x\n that we will have at the end. Limit of colors are small enough, so we can try all of them and just keep the smallest answer.",
    "hint": []
}