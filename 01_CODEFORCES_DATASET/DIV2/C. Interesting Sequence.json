{
    "link": "https://codeforces.com//contest/1775/problem/C",
    "problemId": "1730875",
    "problem_idx": "C",
    "shortId": "1775C",
    "contest_number": "1775",
    "problem_submissions": {
        "F": [
            188713433,
            188725196,
            188731396,
            188734657,
            188732056,
            188733441,
            188727879,
            188728779,
            188732238,
            188744590,
            188740643,
            188819082,
            188726758,
            188730587,
            188740657,
            188744867,
            188749677,
            188736230,
            188750878,
            188747224,
            188750488
        ],
        "E": [
            188705052,
            188711810,
            188702314,
            188703997,
            188719714,
            188707610,
            188716487,
            188718865,
            188714441,
            188704775,
            188725287,
            188819074,
            188708013,
            188721335,
            188719084,
            188719253,
            188714969,
            188726615,
            188723431,
            188727896,
            188725883
        ],
        "D": [
            188702613,
            188703020,
            188697830,
            188697522,
            188707471,
            188696985,
            188707674,
            188710332,
            188711385,
            188724357,
            188713699,
            188819118,
            188819061,
            188695392,
            188715707,
            188723783,
            188712755,
            188710335,
            188700501,
            188714975,
            188711803,
            188710270
        ],
        "C": [
            188694431,
            188698020,
            188689331,
            188692115,
            188699073,
            188721317,
            188698207,
            188703599,
            188700577,
            188691524,
            188697369,
            188818955,
            188729950,
            188704268,
            188712641,
            188705362,
            188703234,
            188716581,
            188706582,
            188705592,
            188701989
        ],
        "B": [
            188689294,
            188694420,
            188688425,
            188705924,
            188692481,
            188693569,
            188693704,
            188692884,
            188692641,
            188690496,
            188689877,
            188818945,
            188737766,
            188698596,
            188704549,
            188701478,
            188699101,
            188697811,
            188699643,
            188700904,
            188695734
        ],
        "A2": [
            188688478,
            188690842,
            188692472,
            188689269,
            188688789,
            188704546,
            188691442,
            188689540,
            188689829,
            188692114,
            188699776,
            188818970,
            188727805,
            188692265,
            188700238,
            188696195,
            188689432,
            188688599,
            188695159,
            188698301,
            188690756
        ],
        "A1": [
            188688462,
            188690964,
            188692352,
            188689360,
            188688853,
            188699704,
            188691533,
            188689633,
            188689929,
            188688691,
            188699645,
            188818981,
            188689698,
            188692382,
            188700463,
            188696403,
            188689492,
            188688657,
            188694924,
            188695874,
            188690864
        ]
    },
    "name": "C. Interesting Sequence",
    "statement": "Petya and his friend, robot Petya++, like to solve exciting math\r\nproblems.One day Petya++ came up with the numbers n and x and wrote the\r\nfollowing equality on the board: n\r\n&\r\n(n+1)\r\n&\r\ndots\r\n&\r\nm = x, where\r\n& denotes the bitwise AND operation. Then he suggested his friend Petya\r\nfind such a minimal m (m\r\nge n) that the equality on the board holds.Unfortunately, Petya couldnâ€™t\r\nsolve this problem in his head and decided to ask for computer help. He\r\nquickly wrote a program and found the answer.Can you solve this\r\ndifficult problem?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \": \" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\twhile (TC--){\n\t\tint n,x;\n\t\tcin>>n>>x;\n\t\t\n\t\tint res=n^x;\n\t\t\n\t\tif (n==x) cout<<n<<endl;\n\t\telse if (x==0) cout<<(2LL<<__lg(n))<<endl;\n\t\telse if ((n&x)==x && __builtin_ctzll(n^res)>__lg(res)+1){\n\t\t\tint temp=2LL<<__lg(res);\n\t\t\tn-=n&(temp-1);\n\t\t\tn|=temp;\n\t\t\tcout<<n<<endl;\n\t\t}\n\t\telse cout<<\"-1\"<<endl;\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Interesting Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/111286",
    "editorial": "Note that the answer will be when AND . This holds if there is a bit\r\nwith number which exists in number , but it does not exist in number .\r\nWhat is clear now is that some bits in must be zeroed. Since we have\r\nbitwise AND going sequentially with numbers larger than , we change the\r\nbits from the lowest to the highest. Thus, in number some bit prefix is\r\nzeroed out, so if number is not number with a zeroed prefix (possibly\r\nempty) of bits, then there is no answer.Now we can calculate for each\r\nbit the minimal number such that AND AND AND has in the -th bit.Now\r\ncalculate as the maximum on all bits to be zeroed, and as the minimum on\r\nall bits to be left untouched. Then, if , we will take as the answer,\r\notherwise there is no answer. The problem can also be solved by binary\r\nsearch: we will use it to find , and check the answer by the formula:\r\nfor each bit find the nearest , at which it will be zeroed. We can do\r\nthis using the following fact: for -th bit, the first numbers (starting\r\nfrom zero) will not contain it, then will, then again will not and so\r\non. Such a solution works for .\r\n",
    "hint": []
}