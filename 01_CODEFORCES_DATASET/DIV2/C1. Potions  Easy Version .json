{
    "link": "https://codeforces.com//contest/1526/problem/C1",
    "problemId": "998296",
    "problem_idx": "C1",
    "shortId": "1526C1",
    "contest_number": "1526",
    "problem_submissions": {
        "F": [
            117674501,
            117718090
        ],
        "E": [
            117641265,
            117622832,
            117632917,
            117655078,
            117650360,
            117639127,
            117655021,
            117622676,
            117655327,
            117632538,
            117657710,
            117639481,
            117666815,
            117667694,
            117675419,
            117641336,
            117667368,
            117663164,
            117676666,
            117665783
        ],
        "D": [
            117632533,
            117637660,
            117642436,
            117623173,
            117637988,
            117639630,
            117639808,
            117654338,
            117642482,
            117656737,
            117641555,
            117661726,
            117632865,
            117643854,
            117639700,
            117671596,
            117639266,
            117649770,
            117640101,
            117649235
        ],
        "C2": [
            117607723,
            117607154,
            117602271,
            117601746,
            117613546,
            117613022,
            117607432,
            117606655,
            117614092,
            117605064,
            117613264,
            117601205,
            117618975,
            117612210,
            117617886,
            117613492,
            117619366,
            117636680,
            117605737,
            117632479
        ],
        "C1": [
            117607362,
            117607834,
            117601722,
            117602159,
            117613090,
            117613322,
            117607889,
            117607044,
            117614454,
            117603816,
            117613790,
            117601639,
            117616576,
            117603874,
            117618238,
            117612867,
            117619659,
            117635895,
            117606026,
            117617120
        ],
        "B": [
            117601602,
            117610780,
            117595803,
            117598275,
            117596391,
            117609017,
            117598567,
            117600812,
            117600764,
            117618105,
            117599167,
            117612003,
            117600763,
            117595368,
            117595660,
            117608430,
            117600516,
            117617181,
            117613055,
            117606766
        ],
        "A": [
            117595740,
            117594587,
            117593757,
            117594246,
            117593849,
            117594075,
            117595264,
            117593810,
            117605058,
            117594287,
            117594338,
            117603759,
            117594059,
            117594193,
            117593995,
            117604884,
            117594125,
            117594212,
            117608105,
            117606903
        ]
    },
    "name": "C1. Potions  Easy Version ",
    "statement": "There are n potions in a line, with potion 1 on the far left and potion\r\nn on the far right. Each potion will increase your health by a_i when\r\ndrunk. a_i can be negative, meaning that potion will decrease will\r\nhealth.You start with 0 health and you will walk from left to right,\r\nfrom first potion to the last one. At each potion, you may choose to\r\ndrink it or ignore it. .What is the largest number of potions you can\r\ndrink?\r\n",
    "solutions": [
        "//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0){\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar('-') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + '0' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\nint n,ans,temp;\nll now;\nmultiset<int>s;\nint main() {\n\tcin>>n;\n\tF(i,1,n){temp=read();\n\t\tif(temp>=0){\n\t\t\t++ans;\n\t\t\tnow+=temp;\n\t\t}else{\n\t\t\ttemp=-temp;\n\t\t\tif(now>=temp){\n\t\t\t\t++ans;\n\t\t\t\tnow-=temp;\n\t\t\t\ts.insert(temp);\n\t\t\t}else{if(!s.empty())\n\t\t\t\tif(temp<*s.rbegin()){\n\t\t\t\t\tnow+=*s.rbegin()-temp;\n\t\t\t\t\ts.erase(s.lower_bound(*s.rbegin()));\n\t\t\t\t\ts.insert(temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}cout<<ans;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C1. Potions  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/91195",
    "editorial": "Method 1 DPLet\u00e2\u0080\u0099s\nconsider a dynamic programming solution. Let be the maximum possible\nhealth achievable if we consider only the first potions, and is the\ntotal number of potions taken. The transition is as follows: if , and\njust otherwise. The first term represents the case if we take potion and\nthe second term is when we ignore potion .This runs in and passes the\neasy version.Method 2 Greedy 1We iterate through the potions in\nnon-decreasing order and drink the potion if we do not die.For\nconvenience, we define , where is a very small real number so that we\ncan treat as distinct integers. We will show by exchange argument that\nour greedy is optimal.Let be the set of potions that is an optimal\nsolution.Suppose and . If and , then removing and adding into will still\nmake a valid solution.Now, suppose that position is not drunk. We can\nassume that there are no () such that and is drunk by the previous\nassertion. Suppose we add into . If we reach a position (we possibly die\nat ) where , then we can remove from and add to . Otherwise, our greedy\nwill also not choose , as it was not chosen when we only consider\nindexes such that .Notice that we can arbitrarily define the way is\nadded, so basically we can process in any non-increasing fashion.Doing\nthis naively is as well. However, using a range add range max lazy\npropagation segment tree, we can check if a certain potion can be drunk\nwithout dying, and the solution runs in .Method 3 Greedy 2 / DP 2We\nprocess the potions from left to right. At the same time, we maintain\nthe list of potions we have taken so far. When processing potion , if we\ncan take without dying, then we take it. Otherwise, if the most negative\npotion we\u00e2\u0080\u0099ve taken is more negative than potion , then we can swap out\npotion for that potion. To find the most negative potion we\u00e2\u0080\u0099ve taken, we\ncan maintain the values of all potions in a minimum priority_queue. This\nruns in as wellTo prove that this works, let\u00e2\u0080\u0099s consider best solution\nwhere we take exactly potions (best as in max total health). The\nsolution involves taking the largest values in our priority queue. Then\nwhen considering a new potion, we should see whether swapping out the\nnew potion for the kth largest potion will improve the answer. Since the\npriority queue is strictly decreasing, there will be a cutoff , where\nfor at most , the answer is not affected, and for larger than , we swap\nout the th largest potion. It turns out this process is equivalent to\ninserting the new potion\u00e2\u0080\u0099s value into the priority_queue. For those\npositions at most , they are not affected. For the positions larger than\n, the elements get pushed back one space, meaning that the smallest\nelement is undrinked.This can also be seen as an efficient way to to\ntransition from one layer of the table to the next.\n"
}