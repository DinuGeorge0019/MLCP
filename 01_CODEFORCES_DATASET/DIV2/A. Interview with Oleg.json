{
    "link": "https://codeforces.com//contest/738/problem/A",
    "problemId": "81055",
    "problem_idx": "A",
    "shortId": "738A",
    "contest_number": "738",
    "problem_submissions": {
        "E": [
            22355357,
            22354524,
            22368260,
            22349644,
            22355331,
            22356088,
            22356163,
            22356096,
            22357408,
            22351061,
            22356973,
            22355298,
            22358187,
            22357834,
            22357953,
            22357991,
            22358891,
            22358107,
            22359096,
            22358176,
            22359681
        ],
        "D": [
            22352887,
            22353039,
            22402501,
            22352355,
            22352815,
            22351941,
            22352850,
            22352916,
            22350647,
            22353806,
            22348566,
            22353986,
            22349405,
            22355113,
            22351157,
            22350006,
            22354616,
            22352089,
            22346385,
            22351808,
            22354557
        ],
        "C": [
            22348617,
            22348545,
            22351859,
            22348840,
            22349718,
            22349641,
            22349601,
            22352863,
            22355987,
            22353264,
            22351200,
            22353844,
            22349294,
            22354485,
            22353883,
            22349940,
            22349844,
            22371503,
            22354418,
            22355326,
            22351271
        ],
        "B": [
            22345078,
            22345223,
            22347131,
            22345520,
            22345422,
            22345771,
            22345810,
            22346401,
            22348268,
            22345003,
            22348061,
            22346211,
            22344435,
            22345892,
            22345784,
            22345313,
            22344813,
            22347694,
            22347099,
            22346201
        ],
        "A": [
            22343882,
            22343979,
            22345882,
            22343953,
            22344058,
            22344097,
            22344370,
            22344195,
            22346397,
            22343753,
            22346250,
            22343907,
            22343833,
            22344008,
            22343904,
            22343686,
            22344348,
            22345077
        ],
        "F": [
            22415691,
            22576726,
            22658711,
            22371212,
            22371207,
            22371193,
            22371178,
            22371166,
            22368114,
            22469249,
            22468405,
            22458802
        ]
    },
    "name": "A. Interview with Oleg",
    "statement": "Polycarp has interviewed Oleg and has written the interview down without\r\npunctuation marks and spaces to save time. Thus, the interview is now a\r\nstring consisting of lowercase English letters.There is a filler word in\r\nOleg’s speech. All words that can be obtained from by adding several\r\ntimes to the end of it are also considered to be fillers. For example,\r\nthe words , , are fillers, but the words , , , and are not fillers.The\r\nfillers have maximal size, for example, for speech we can’t consider a\r\nfiller and as a normal phrase. We should consider as a filler here.To\r\nprint the interview, Polycarp has to replace each of the fillers with\r\nthree asterisks. Note that a filler word is replaced with exactly three\r\nasterisks regardless of its length.Polycarp has dealt with this problem\r\nin no time. Can you do the same? The clock is ticking!\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <unordered_map>\nusing namespace std;\n\nint n;\n\nint main()\n{\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    string s1;\n    for (int i = 0; i < s.length();)\n    {\n        if (i + 2 < s.length() && s[i] == 'o' && s[i + 1] == 'g' && s[i + 2] == 'o')\n        {\n            i += 3;\n            while (i + 1 < s.length() && s[i] == 'g' && s[i + 1] == 'o')\n            {\n                i += 2;\n            }\n\n            s1 += \"***\";\n        } else\n        {\n            s1 += s[i];\n            i++;\n        }\n\n    }\n\n    cout << s1 << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Interview with Oleg.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "In this problem it is enough to iterate through the given string from the left to the right and find the longest substring like \"ogo...go\" from each position of the string. If such substring was founded add \"***\" and move to the end of this substring. In the other case, add current letter to the answer and move to the next position.",
    "hint": []
}