{
    "link": "https://codeforces.com//contest/1486/problem/A",
    "problemId": "897789",
    "problem_idx": "A",
    "shortId": "1486A",
    "contest_number": "1486",
    "problem_submissions": {
        "F": [
            107822308,
            107853234,
            107892513,
            107856479,
            107858609,
            107818883,
            107863062,
            107864151,
            107861898,
            107852447
        ],
        "C2": [
            107807571,
            107798543,
            107798512,
            107824454,
            107833215,
            107807829,
            107808299,
            107893894,
            107831280,
            107798206,
            107803513,
            107805796,
            107796329,
            107802055,
            107801594,
            107810753,
            107807623,
            107804366,
            107800246,
            107794787
        ],
        "C1": [
            107807442,
            107798262,
            107798783,
            107806766,
            107826187,
            107799740,
            107808102,
            107806459,
            107804345,
            107798724,
            107803748,
            107805504,
            107796790,
            107802993,
            107801883,
            107810564,
            107806537,
            107804166,
            107800475,
            107795337
        ],
        "E": [
            107800531,
            107809228,
            107835383,
            107836319,
            107858202,
            107831953,
            107841935,
            107828250,
            107866676,
            107815626,
            107818145,
            107822115,
            107819777,
            107823506,
            107819582,
            107793061,
            107821827,
            107818526,
            107827724,
            107835623
        ],
        "D": [
            107794075,
            107802130,
            107818757,
            107810014,
            107838771,
            107823356,
            107812461,
            107800692,
            107835785,
            107804842,
            107809012,
            107812317,
            107808246,
            107810696,
            107812569,
            107833103,
            107812854,
            107810102,
            107818249,
            107811436
        ],
        "B": [
            107789021,
            107789484,
            107787615,
            107791480,
            107795217,
            107789100,
            107788278,
            107793717,
            107792766,
            107788662,
            107787061,
            107791923,
            107801559,
            107790818,
            107784811,
            107802492,
            107792788,
            107796149,
            107790292,
            107785066
        ],
        "A": [
            107783058,
            107787485,
            107782747,
            107783451,
            107784857,
            107784942,
            107784010,
            107783293,
            107785695,
            107784794,
            107783365,
            107784072,
            107790054,
            107785033,
            107793025,
            107799971,
            107782733,
            107782509,
            107783469,
            107782641
        ]
    },
    "name": "A. Shifting Stacks",
    "statement": "You have n stacks of blocks. The i-th stack contains h_i blocks and it\u2019s\r\nheight is the number of blocks in it. In one move you can take a block\r\nfrom the i-th stack (if there is at least one block) and put it to the\r\ni + 1-th stack. Can you make the sequence of heights strictly\r\nincreasing?Note that the number of stacks always remains n: stacks don\u2019t\r\ndisappear when they have 0 blocks.\r\n",
    "solutions": [
        "//#pragma GCC target(\"avx,avx2\")\t\n#include<bits/stdc++.h>\n//#include<immintrin.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nchar readc()\n{\n\tchar c;\n\twhile(isspace(gc));\n\treturn c;\n}\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\t\n\tint tt=read();\n\twhile(tt--)\n\t{\n\t\tint n=read();\n\t\ts64 sum=0;\n\t\tbool ok=1;\n\t\trep(i,1,n)\n\t\t{\n\t\t\tsum+=read();\n\t\t\tok&=sum>=s64(i)*(i-1)/2;\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Shifting Stacks.json",
    "editorial_link": "https://codeforces.com//blog/entry/87849",
    "editorial": "SolutionLet\u00e2\u0080\u0099s consider the smallest amount of blocks we need to make the\r\nfirst heights ascending. As heights are non-negative and ascending the\r\nheights should look like , so the minimum sum is . It turns out that\r\nthis is the only requirement. If it\u00e2\u0080\u0099s not the case for every prefix the\r\nanswer is because we can\u00e2\u0080\u0099t make some prefix ascending. Otherwise the\r\nanswer is because you can move the blocks right till there is at least\r\nblocks in the -th stack and this would make the heights ascending.\r\n"
}