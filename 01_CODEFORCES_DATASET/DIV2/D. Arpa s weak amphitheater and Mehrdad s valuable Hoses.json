{
    "link": "https://codeforces.com//contest/742/problem/D",
    "problemId": "83318",
    "problem_idx": "D",
    "shortId": "742D",
    "contest_number": "742",
    "problem_submissions": {
        "E": [
            22752019,
            22759064,
            22754657,
            22765857,
            22788546,
            23197143,
            22762814
        ],
        "D": [
            22744910,
            22741651,
            22753078,
            22751028,
            22744888,
            22741846,
            22758632,
            22746446,
            22753836,
            22737034,
            22750995,
            22752528,
            22743466,
            22751854,
            22752496,
            22748899,
            22753642,
            22754503,
            22748134,
            22740266
        ],
        "C": [
            22740173,
            22743352,
            22744642,
            22741334,
            22739680,
            22738371,
            22747384,
            22741807,
            22746641,
            22740018,
            22741232,
            22742624,
            22739762,
            22746069,
            22745352,
            22744071,
            22747640,
            22744802,
            22742428,
            22742553
        ],
        "B": [
            22735430,
            22735137,
            22736961,
            22737223,
            22746763,
            22733523,
            22752994,
            22735820,
            22738249,
            22738141,
            197150958,
            22734885,
            22737066,
            22734297,
            22733944,
            22735191,
            22739491,
            22740891,
            22739140,
            22736069,
            22734748
        ],
        "A": [
            22733155,
            22734578,
            22732981,
            22745942,
            22747296,
            22732607,
            22733617,
            22732946,
            22732749,
            22733033,
            197151042,
            22732771,
            22732850,
            22741111,
            22733718,
            22732738,
            22736352,
            22735420,
            22733368,
            22763624
        ]
    },
    "name": "D. Arpa s weak amphitheater and Mehrdad s valuable Hoses",
    "statement": "Mehrdad wants to invite some Hoses to the palace for a dancing party.\r\nEach Hos has some weight and some beauty . Also each Hos may have some\r\nfriends. Hoses are divided in some friendship groups. Two Hoses and are\r\nin the same friendship group if and only if there is a sequence of Hoses\r\nsuch that and are friends for each , and and . Arpa allowed to use the\r\namphitheater of palace to Mehrdad for this party. Arpa’s amphitheater\r\ncan hold at most weight on it. Mehrdad is so greedy that he wants to\r\ninvite some Hoses such that sum of their weights is not greater than and\r\nsum of their beauties is as large as possible. Along with that, from\r\neach friendship group he can either invite all Hoses, or no more than\r\none. Otherwise, some Hoses will be hurt. Find for Mehrdad the maximum\r\npossible total beauty of Hoses he can invite so that no one gets hurt\r\nand the total weight doesn’t exceed .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\nconst int MAX = 1e3 + 10;\nconst int MOD = 1e9 + 7;\n\n//#define acm_local\nint w[MAX];\nint b[MAX];\n\nint uf[MAX];\nint FIND( int x ) { return uf[x] == x ? x : uf[x] = FIND( uf[x] ); }\nvoid UNION( int x, int y ) { uf[FIND( x )] = FIND( y ); }\n\n\nbool seen[MAX];\nint ww[MAX], bb[MAX];\nint dp[MAX][MAX];\nint main()\n{\n\n\n#ifdef acm_local\n    freopen(\"data.in\", \"r\", stdin);\n    return 0;\n#else\n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n\n    int n, m, W; cin >> n >> m >> W;\n    for(int i = 1; i <= n; i++)cin >>w[i];\n    for(int i = 1; i <= n; i++)cin>>b[i];\n    for(int i = 1; i <= n; i++)uf[i] = i;\n    while(m--){\n        int a, b; cin >> a >> b;\n        UNION(a, b);\n    }\n\n\n    for(int i = 1; i <= n; i++){\n        ww[FIND(i)] += w[i];\n        bb[FIND(i)] += b[i];\n    }\n    dp[0][0] = 0;\n    int cc = 1;\n    for(int j = 1; j <= n; j++){\n        int pp = FIND(j);\n        if(seen[pp])continue;\n        seen[pp] = true;\n        for(int i = 1; i <= W; i++){\n            dp[cc][i] = dp[cc - 1][i];\n            if(ww[pp] <= i){\n                dp[cc][i] = max(dp[cc][i], dp[cc - 1][i - ww[pp]] + bb[pp]);\n            }\n        }\n\n\n        for(int t = 1; t <= n; t++){\n            if(FIND(t)!= pp)continue;\n\n            for(int i = 1; i <= W; i++){\n                if(w[t] <= i){\n                    dp[cc][i] = max(dp[cc][i], dp[cc - 1][i - w[t]] + b[t]);\n                }\n            }\n        }\n\n        cc++;\n    }\n    int ans = 0;\n    for(int i = W; i >= 0; i--){\n        ans = max(dp[cc - 1][i], ans);\n    }\n    cout << ans << endl;\n\n\n\n\n\n\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Arpa s weak amphitheater and Mehrdad s valuable Hoses.json",
    "editorial_link": "https://codeforces.com//blog/entry/48871",
    "editorial": "Its a simple knapsack problem. Lets solve this version of knapsack problem first: we have n sets of items, each item has value and weight, find the maximum value we can earn if we can choose at most one item from each set and the sum of the chosen items must be less than or equal to W. Let dpw be the max value we can earn if the sum of weights of chosen items is less than or equal to w. Now iterate on sets one by one and update dp as follows: for each item X, and for each weight w, newDpw?=?max(newDpw,?oldDpw?-?X.weight?+?X.value).\n\nRun dfs and find groups at first. The problem is same with above problem, each group is some set in above problem, just add the whole group as an item to the set that related to this group.",
    "hint": []
}