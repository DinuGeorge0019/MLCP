{"link": "https://codeforces.com//contest/1695/problem/E", "problemId": "1432676", "problem_idx": "E", "shortId": "1695E", "contest_number": "1695", "problem_submissions": {"E": [161099994, 161385353], "D1": [161071005, 161074543, 161081125, 161072748, 161085205, 161076792, 161086180, 161088285, 161078663, 161087570, 161090981, 161081382, 161096600, 161083265, 161094007, 161083359, 161087191, 161099464, 161103072], "D2": [161070538, 161074164, 161080949, 161072924, 161085070, 161077074, 161086067, 161090573, 161078799, 161087356, 161091244, 161098503, 161096503, 161083640, 161093884, 161083859, 161106845, 161102938, 161103184], "C": [161049795, 161059348, 161063490, 161060415, 161055337, 161053834, 161061413, 161054883, 161053215, 161065273, 161068360, 161076346, 161062519, 161063339, 161079032, 161066869, 161096184, 161063492, 161059254, 161053168], "B": [161047262, 161053402, 161051570, 161054862, 161050104, 161049992, 161050979, 161048731, 161049540, 161057199, 161054074, 161054984, 161050691, 161052531, 161068152, 161056401, 161053679, 161049800, 161064268, 161048819], "A": [161046762, 161046971, 161046828, 161047950, 161046933, 161046876, 161047188, 161046813, 161046805, 161048336, 161047711, 161049772, 161046830, 161047996, 161062872, 161046949, 161047484, 161047163, 161047431, 161046827]}, "name": "E. Ambiguous Dominoes", "statement": "Polycarp and Monocarp are both solving the same puzzle with dominoes.\r\nThey are given the same set of n dominoes, the i-th of which contains\r\ntwo numbers x_i and y_i. They are also both given the same m by k grid\r\nof values a_{ij} such that m\r\ncdot k = 2n.The puzzle asks them to place the n dominoes on the grid in\r\nsuch a way that none of them overlap, and the values on each domino\r\nmatch the a_{ij} values that domino covers. Dominoes can be rotated\r\narbitrarily before being placed on the grid, so the domino (x_i, y_i) is\r\nequivalent to the domino (y_i, x_i).They have both solved the puzzle,\r\nand compared their answers, but noticed that not only did their\r\nsolutions not match, but none of the n dominoes were in the same\r\nlocation in both solutions! Formally, if two squares were covered by the\r\nsame domino in Polycarp\u2019s solution, they were covered by different\r\ndominoes in Monocarp\u2019s solution. The diagram below shows one potential a\r\ngrid, along with the two players\u2019 solutions. Polycarp and Monocarp\r\nremember the set of dominoes they started with, but they have lost the\r\ngrid a. Help them reconstruct one possible grid a, along with both of\r\ntheir solutions, or determine that no such grid exists.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 6e5 + 5;\n\nmultiset<int> adj[N];\nint a[N][3], ans1[2][N], cnt[N];\nchar ans2[2][N], ans3[2][N];\nint len, tot;\n\nvoid del(int u, int v) {\n    adj[u].erase(adj[u].find(v));\n    adj[v].erase(adj[v].find(u));\n}\n\nvoid add1(vector<pair<int, int>> a) {\n    int l = tot + 1, r = tot + a.size();\n    for (int i = 0; i < a.size(); i++) {\n        ans1[0][l + i] = a[i].first;\n        ans1[1][l + i] = a[i].second;\n    }\n    if (a.size() % 2 == 0) {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = 'U';\n            ans2[1][i] = 'D';\n            ans3[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n        }\n    } else {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans2[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[0][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n        }\n        ans2[0][r] = 'U'; ans2[1][r] = 'D';\n        ans3[0][l] = 'U'; ans3[1][l] = 'D';\n    }\n    tot = r;\n}\n\nvoid add2(vector<pair<int, int>> a) {\n    int l = tot + 1, r = tot + a.size();\n    for (int i = 0; i < a.size(); i++) {\n        if (i % 2 == 1) swap(a[i].first, a[i].second);\n        ans1[0][l + i] = a[i].first;\n        ans1[1][l + i] = a[i].second;\n    }\n    if (a.size() % 2 == 0) {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = 'U';\n            ans2[1][i] = 'D';\n            ans3[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n        }\n    } else {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans2[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[0][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n        }\n        ans2[0][r] = 'U'; ans2[1][r] = 'D';\n        ans3[0][l] = 'U'; ans3[1][l] = 'D';\n    }\n    tot = r;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int u, v;\n        cin >> u >> v;\n        if (u == v) {\n            ++cnt[u];\n        } else {\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n    }\n    for (int i = 1; i <= n * 2; i++) {\n        while (adj[i].size() + cnt[i] >= 2) {\n            ++len;\n            int x, y;\n            if (adj[i].size()) {\n                x = *adj[i].begin(); del(x, i);\n            } else {\n                x = i; --cnt[i];\n            }\n            if (adj[i].size()) {\n                y = *adj[i].begin(); del(y, i);\n            } else {\n                y = i; --cnt[i];\n            }\n            a[len][0] = x; a[len][1] = i; a[len][2] = y;\n        }\n    }\n    for (int i = 1; i <= len; i++) {\n        int x = a[i][0], y = a[i][1], z = a[i][2];\n        int xx = 0, yy = 0, zz = 0;\n        if (adj[x].size() || cnt[x]) {\n            if (adj[x].size()) {\n                xx = *adj[x].begin(); del(xx, x);\n            } else {\n                xx = x; cnt[x] = 0;\n            }\n        }\n        if (adj[y].size() || cnt[y]) {\n            if (adj[y].size()) {\n                yy = *adj[y].begin(); del(yy, y);\n            } else {\n                yy = y; cnt[y] = 0;\n            }\n        }\n        if (adj[z].size() || cnt[z]) {\n            if (adj[z].size()) {\n                zz = *adj[z].begin(); del(zz, z);\n            } else {\n                zz = z; cnt[z] = 0;\n            }\n        }\n        if (xx && yy && zz) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}});\n            add1(vector<pair<int, int>> {{yy, y}, {y, z}, {z, zz}});\n        } else if (xx && yy) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}});\n            add1(vector<pair<int, int>> {{yy, y}, {y, z}});\n        } else if (xx && zz) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}});\n            add1(vector<pair<int, int>> {{y, z}, {z, zz}});\n        } else if (yy && zz) {\n            add1(vector<pair<int, int>> {{x, y}, {y, yy}});\n            add1(vector<pair<int, int>> {{y, z}, {z, zz}});\n        } else if (xx) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}, {y, z}});\n        } else if (zz) {\n            add1(vector<pair<int, int>> {{x, y}, {y, z}, {z, zz}});\n        } else if (yy) {\n            add2(vector<pair<int, int>> {{y, x}, {y, yy}, {y, z}});\n        } else {\n            add1(vector<pair<int, int>> {{x, y}, {y, z}});\n        }\n    }\n    for (int i = 1; i <= n * 2; i++) {\n        if (adj[i].size() || cnt[i]) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    cout << 2 << \" \" << n << endl;\n    for (int i = 0; i <= 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << ans1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    for (int i = 0; i <= 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << ans2[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i <= 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << ans3[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs"], "dificulty": "2700", "interactive": false}