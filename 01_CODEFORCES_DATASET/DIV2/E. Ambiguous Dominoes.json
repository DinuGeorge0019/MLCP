{
    "link": "https://codeforces.com//contest/1695/problem/E",
    "problemId": "1432676",
    "problem_idx": "E",
    "shortId": "1695E",
    "contest_number": "1695",
    "problem_submissions": {
        "E": [
            161099994,
            161385353
        ],
        "D1": [
            161071005,
            161074543,
            161081125,
            161072748,
            161085205,
            161076792,
            161086180,
            161088285,
            161078663,
            161087570,
            161090981,
            161081382,
            161096600,
            161083265,
            161094007,
            161083359,
            161087191,
            161099464,
            161103072
        ],
        "D2": [
            161070538,
            161074164,
            161080949,
            161072924,
            161085070,
            161077074,
            161086067,
            161090573,
            161078799,
            161087356,
            161091244,
            161098503,
            161096503,
            161083640,
            161093884,
            161083859,
            161106845,
            161102938,
            161103184
        ],
        "C": [
            161049795,
            161059348,
            161063490,
            161060415,
            161055337,
            161053834,
            161061413,
            161054883,
            161053215,
            161065273,
            161068360,
            161076346,
            161062519,
            161063339,
            161079032,
            161066869,
            161096184,
            161063492,
            161059254,
            161053168
        ],
        "B": [
            161047262,
            161053402,
            161051570,
            161054862,
            161050104,
            161049992,
            161050979,
            161048731,
            161049540,
            161057199,
            161054074,
            161054984,
            161050691,
            161052531,
            161068152,
            161056401,
            161053679,
            161049800,
            161064268,
            161048819
        ],
        "A": [
            161046762,
            161046971,
            161046828,
            161047950,
            161046933,
            161046876,
            161047188,
            161046813,
            161046805,
            161048336,
            161047711,
            161049772,
            161046830,
            161047996,
            161062872,
            161046949,
            161047484,
            161047163,
            161047431,
            161046827
        ]
    },
    "name": "E. Ambiguous Dominoes",
    "statement": "Polycarp and Monocarp are both solving the same puzzle with dominoes.\r\nThey are given the same set of n dominoes, the i-th of which contains\r\ntwo numbers x_i and y_i. They are also both given the same m by k grid\r\nof values a_{ij} such that m\r\ncdot k = 2n.The puzzle asks them to place the n dominoes on the grid in\r\nsuch a way that none of them overlap, and the values on each domino\r\nmatch the a_{ij} values that domino covers. Dominoes can be rotated\r\narbitrarily before being placed on the grid, so the domino (x_i, y_i) is\r\nequivalent to the domino (y_i, x_i).They have both solved the puzzle,\r\nand compared their answers, but noticed that not only did their\r\nsolutions not match, but none of the n dominoes were in the same\r\nlocation in both solutions! Formally, if two squares were covered by the\r\nsame domino in Polycarp\u2019s solution, they were covered by different\r\ndominoes in Monocarp\u2019s solution. The diagram below shows one potential a\r\ngrid, along with the two players\u2019 solutions. Polycarp and Monocarp\r\nremember the set of dominoes they started with, but they have lost the\r\ngrid a. Help them reconstruct one possible grid a, along with both of\r\ntheir solutions, or determine that no such grid exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 6e5 + 5;\n\nmultiset<int> adj[N];\nint a[N][3], ans1[2][N], cnt[N];\nchar ans2[2][N], ans3[2][N];\nint len, tot;\n\nvoid del(int u, int v) {\n    adj[u].erase(adj[u].find(v));\n    adj[v].erase(adj[v].find(u));\n}\n\nvoid add1(vector<pair<int, int>> a) {\n    int l = tot + 1, r = tot + a.size();\n    for (int i = 0; i < a.size(); i++) {\n        ans1[0][l + i] = a[i].first;\n        ans1[1][l + i] = a[i].second;\n    }\n    if (a.size() % 2 == 0) {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = 'U';\n            ans2[1][i] = 'D';\n            ans3[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n        }\n    } else {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans2[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[0][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n        }\n        ans2[0][r] = 'U'; ans2[1][r] = 'D';\n        ans3[0][l] = 'U'; ans3[1][l] = 'D';\n    }\n    tot = r;\n}\n\nvoid add2(vector<pair<int, int>> a) {\n    int l = tot + 1, r = tot + a.size();\n    for (int i = 0; i < a.size(); i++) {\n        if (i % 2 == 1) swap(a[i].first, a[i].second);\n        ans1[0][l + i] = a[i].first;\n        ans1[1][l + i] = a[i].second;\n    }\n    if (a.size() % 2 == 0) {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = 'U';\n            ans2[1][i] = 'D';\n            ans3[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n        }\n    } else {\n        for (int i = l; i <= r; i++) {\n            ans2[0][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans2[1][i] = (i - l) % 2 == 0 ? 'L' : 'R';\n            ans3[0][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n            ans3[1][i] = (i - l) % 2 == 1 ? 'L' : 'R';\n        }\n        ans2[0][r] = 'U'; ans2[1][r] = 'D';\n        ans3[0][l] = 'U'; ans3[1][l] = 'D';\n    }\n    tot = r;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int u, v;\n        cin >> u >> v;\n        if (u == v) {\n            ++cnt[u];\n        } else {\n            adj[u].insert(v);\n            adj[v].insert(u);\n        }\n    }\n    for (int i = 1; i <= n * 2; i++) {\n        while (adj[i].size() + cnt[i] >= 2) {\n            ++len;\n            int x, y;\n            if (adj[i].size()) {\n                x = *adj[i].begin(); del(x, i);\n            } else {\n                x = i; --cnt[i];\n            }\n            if (adj[i].size()) {\n                y = *adj[i].begin(); del(y, i);\n            } else {\n                y = i; --cnt[i];\n            }\n            a[len][0] = x; a[len][1] = i; a[len][2] = y;\n        }\n    }\n    for (int i = 1; i <= len; i++) {\n        int x = a[i][0], y = a[i][1], z = a[i][2];\n        int xx = 0, yy = 0, zz = 0;\n        if (adj[x].size() || cnt[x]) {\n            if (adj[x].size()) {\n                xx = *adj[x].begin(); del(xx, x);\n            } else {\n                xx = x; cnt[x] = 0;\n            }\n        }\n        if (adj[y].size() || cnt[y]) {\n            if (adj[y].size()) {\n                yy = *adj[y].begin(); del(yy, y);\n            } else {\n                yy = y; cnt[y] = 0;\n            }\n        }\n        if (adj[z].size() || cnt[z]) {\n            if (adj[z].size()) {\n                zz = *adj[z].begin(); del(zz, z);\n            } else {\n                zz = z; cnt[z] = 0;\n            }\n        }\n        if (xx && yy && zz) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}});\n            add1(vector<pair<int, int>> {{yy, y}, {y, z}, {z, zz}});\n        } else if (xx && yy) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}});\n            add1(vector<pair<int, int>> {{yy, y}, {y, z}});\n        } else if (xx && zz) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}});\n            add1(vector<pair<int, int>> {{y, z}, {z, zz}});\n        } else if (yy && zz) {\n            add1(vector<pair<int, int>> {{x, y}, {y, yy}});\n            add1(vector<pair<int, int>> {{y, z}, {z, zz}});\n        } else if (xx) {\n            add1(vector<pair<int, int>> {{xx, x}, {x, y}, {y, z}});\n        } else if (zz) {\n            add1(vector<pair<int, int>> {{x, y}, {y, z}, {z, zz}});\n        } else if (yy) {\n            add2(vector<pair<int, int>> {{y, x}, {y, yy}, {y, z}});\n        } else {\n            add1(vector<pair<int, int>> {{x, y}, {y, z}});\n        }\n    }\n    for (int i = 1; i <= n * 2; i++) {\n        if (adj[i].size() || cnt[i]) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    cout << 2 << \" \" << n << endl;\n    for (int i = 0; i <= 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << ans1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    for (int i = 0; i <= 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << ans2[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i <= 1; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << ans3[i][j];\n        }\n        cout << endl;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ambiguous Dominoes.json",
    "editorial_link": "https://codeforces.com//blog/entry/103996",
    "editorial": "We represent the set of dominoes as a graph on vertices, where the\r\nvertices are the values to , and the ith domino represents an edge\r\nbetween and . Note that this graph can contain self-loops and duplicate\r\nedges.If any of the connected components of the graph contain only one\r\nedge, then that means that there is a domino such that its and values\r\ndon\u00e2\u0080\u0099t appear in any other dominoes. Therefore, this domino must be in\r\nthe same location in both grids, so there is no solution.Otherwise,\r\niterate over all connected components with edges, which must therefore\r\ncontain edges. For a component with edges, we will run a DFS that will\r\ngenerate a valid by grid for the dominoes in this component.As we go\r\nthrough this DFS, we keep track of which vertices and which edges we\u00e2\u0080\u0099ve\r\nalready seen. When we DFS from a vertex we haven\u00e2\u0080\u0099t seen, mark it as\r\nseen, and iterate over all edges adjacent to that we haven\u00e2\u0080\u0099t seen. Mark\r\neach one as seen, and then traverse it to the other vertex , marking as\r\nits parent. Once we backtrack to , continue to the next unseen edge.\r\nOnce all unseen edges are traversed, traverse back to the parent of .\r\nWhen we visit a vertex we have already seen, just traverse the edge back\r\nto its parent.Throughout this process, maintain a list of all vertices\r\nwe\u00e2\u0080\u0099ve seen in order, including any duplicates. Because we traverse every\r\nedge exactly twice (once in each direction) in this DFS, this list will\r\nbe of size , and every two adjacent vertices in the list are connected\r\nby an edge. Each edge will be represented in two positions in this\r\nlist.We can additionally prove that within this list, each edge appears\r\nin one even position and one odd position.Proof: Let be an edge that we\r\ninitially traverse from to . If has already been traversed by this point\r\nin the DFS, we immediately traverse back to , so the two positions of\r\nare adjacent in the list, and thus on different parity positions.If not,\r\nconsider the final sequence of edges traversed, but removing any edges\r\nthat are immediately traversed backwards. Note that since we are only\r\nremoving pairs of adjacent edges, the parities of positions of edges in\r\nthe list are unchanged. Now, the sequence of edges is just a DFS\r\ntraversal of a tree. So because the graph is now a tree, and thus\r\nbipartite, any path from to itself must be of even length. Therefore,\r\nthe sequence of moves looks like [an even number of edges], and\r\ntherefore the two occurrences of must be on different parities.Now, to\r\ngenerate the by grid that works for this component, we note that the\r\nlist of size can be seen as a cyclic list of size , because the first\r\nand last element of the list must be equal. So we pop the last element\r\nof the list off, and insert the remaining vertices of the list into a by\r\ngrid in clockwise order. Now, the edges form a cycle of length , and\r\nbecause each edge appears on one odd and one even position, each domino\r\nwill appear exactly once in both of the below orientations. Each of\r\nthese orientations takes the dominoes going around the cycle in order.To\r\nget the solution for the whole problem, simply concatenate the by grids\r\nfor each component into a by grid.The below example demonstrates the\r\nwhole process. The blue edges are the edges to previously-seen vertices,\r\nand the red edges are the edges to previously-unseen\r\nvertices.Complexity:\r\n"
}