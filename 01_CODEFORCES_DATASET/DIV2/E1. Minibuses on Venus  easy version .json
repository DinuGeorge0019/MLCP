{"link": "https://codeforces.com//contest/1808/problem/E1", "problemId": "1854694", "problem_idx": "E1", "shortId": "1808E1", "contest_number": "1808", "problem_submissions": {"D": [199663586, 199652295, 199649543, 199658153, 199660313, 199664555, 199663522, 199658681, 199662131, 199663211, 199665809, 199666904, 199686788, 200680943, 199672659, 199667818, 199670491, 199654888, 199672673], "E3": [199660988, 199675708, 199684437, 199678631, 199683096, 201130452, 199666847, 199711014], "E2": [199660914, 199675587, 199684591, 199669150, 199671171, 199672422, 199667417, 199667886, 199667544, 199677124, 199673172, 199673912, 199667116, 200681161, 200681118, 199662837, 199681512, 199697948, 199682318], "E1": [199660827, 199647476, 199655105, 199665173, 199671231, 199655192, 199650032, 199667518, 199667485, 199670735, 199673329, 199674123, 199667097, 200681014, 199659398, 199681451, 199697918, 199676180, 199669612, 199661602], "C": [199660389, 199669471, 199646653, 199653605, 199654568, 199648568, 199646672, 199649651, 199653794, 199654418, 199657068, 199657978, 199676868, 200680878, 200680798, 199678734, 199656497, 199658569, 199658535, 199649977], "A": [199643949, 199642214, 199639989, 199639150, 199640540, 199639256, 199639177, 199639048, 199640380, 199639173, 199640678, 199639746, 199643343, 200680660, 199641247, 199641300, 199640545, 199639604, 199639018], "B": [199639404, 199640164, 199644601, 199640956, 199642784, 199641076, 199640175, 199641302, 199643530, 199641294, 199644684, 199643246, 199643095, 200680723, 199647537, 199644556, 199644782, 199642649, 199640242]}, "name": "E1. Minibuses on Venus  easy version ", "statement": "Maxim is a minibus driver on Venus.To ride on Maxim\u2019s minibus, you need\r\na ticket. Each ticket has a number consisting of n digits. However, as\r\nwe know, the residents of Venus use a numeral system with base k, rather\r\nthan the decimal system. Therefore, the ticket number can be considered\r\nas a sequence of n integers from 0 to k-1, inclusive.The residents of\r\nVenus consider a ticket to be if there is a digit on it that is equal to\r\nthe sum of the remaining digits, modulo k. For example, if k=10, then\r\nthe ticket 7135 is lucky because 7 + 1 + 5\r\nequiv 3\r\npmod{10}. On the other hand, the ticket 7136 is not lucky because no\r\ndigit is equal to the sum of the others modulo 10.Once, while on a trip,\r\nMaxim wondered: how many lucky tickets exist? At the same time, Maxim\r\nunderstands that this number can be very large, so he is interested only\r\nin the answer modulo some prime number m.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\n\nll n;\nint k, mod;\n\ninline int addmod(int x) { return x >= mod ? x - mod : x; }\ninline int submod(int x) { return x < 0 ? x + mod : x; }\nint fpow(int x, ll y) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n    y /= 2;\n  }\n  return ans;\n}\n\nsigned main() {\n  scanf(\"%lld%d%d\", &n, &k, &mod);\n  if (n == 1) {\n    printf(\"%d\\n\", 1 % mod);\n    return 0;\n  }\n  if (k % 2) {\n    int fl = 1;\n    if (n % 2 == 1) fl = mod - 1;\n    int ans1 = 1ll * (1ll * fpow(k - 1, n) - fl + mod) % mod * fpow(k, mod - 2) % mod;\n    int ans2 = 0;\n    for (int i = 0; i < k; i++) {\n      if (1ll * n % k * i % k == 2 * i % k) {\n        ans2++;\n      }\n    }\n    ans1 = (1ll * ans1 * k + 1ll * fl * ans2) % mod;\n    ans1 = submod(fpow(k, n) - ans1);\n    printf(\"%d\\n\", ans1);\n    return 0;\n  } else {\n    int fl = fpow(2, n);\n    if (n % 2 == 1) fl = submod(-fl);\n    int ans1 = 1ll * (1ll * fpow(k - 2, n) - fl + mod) % mod * fpow(k, mod - 2) % mod;\n    int ans2 = 0;\n    for (int i = 0; i * 2 < k; i++) {\n      int u = 1ll * n % k * i % k;\n      if (u == 2 * i % k) ans2++;\n      if ((u + k / 2) % k == 2 * i % k) ans2++;\n    }\n    //\tprintf(\"ans1=%d,ans2=%d,fl=%d\\n\",ans1,ans2,fl);\n    ans2 = 1ll * ans2 * fpow(2, mod - 2) % mod;\n    ans1 = (1ll * ans1 * (k / 2) + 1ll * fl * ans2) % mod;\n    ans1 = submod(1ll * fpow(k, n) * fpow(2, mod - 2) % mod - ans1);\n    printf(\"%d\\n\", ans1);\n    return 0;\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "divide and conquer", "dp"], "dificulty": "2200", "interactive": false}