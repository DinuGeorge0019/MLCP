{
    "link": "https://codeforces.com//contest/1582/problem/F2",
    "problemId": "1156637",
    "problem_idx": "F2",
    "shortId": "1582F2",
    "contest_number": "1582",
    "problem_submissions": {
        "G": [
            133300654,
            132904411,
            132903819,
            132921500,
            132938189,
            132915561,
            132904925,
            132893999,
            132930384,
            132930246,
            132930119,
            132929885,
            132929830,
            132917984,
            132923122,
            132922486,
            132909943,
            132922580,
            132929375,
            132930555,
            133312799,
            132969396
        ],
        "F2": [
            132908314,
            132865018,
            132905309,
            132899324,
            132901682,
            132900235,
            132911727,
            132926934,
            132906558,
            132909549,
            132893391,
            132884523,
            132901241,
            132906554,
            132898256,
            133312622,
            132970055,
            132969976,
            132904321
        ],
        "F1": [
            132881252,
            132864382,
            132880627,
            132888291,
            132872964,
            132880051,
            132887180,
            132892561,
            132900410,
            132897751,
            132862757,
            132872739,
            132870584,
            132888250,
            132889092,
            132882038,
            132891013,
            132872187,
            132887941,
            133312616,
            132891504
        ],
        "E": [
            132874913,
            132878099,
            132874176,
            132880923,
            132882227,
            132876672,
            132871740,
            132883982,
            132905776,
            132893914,
            132871055,
            132859358,
            132881562,
            132870144,
            132885086,
            132894857,
            132869674,
            132887914,
            132877059,
            133312375,
            132888626
        ],
        "D": [
            132866716,
            132891541,
            132886280,
            132871648,
            132863103,
            132871610,
            132863993,
            132875189,
            132911684,
            132876113,
            132889182,
            132879862,
            132890109,
            132872530,
            132875475,
            132891337,
            132884986,
            132886500,
            132884112,
            133312126,
            132970973,
            132882901
        ],
        "C": [
            132859265,
            132871828,
            132860284,
            132861165,
            132856817,
            132935747,
            132866931,
            132863031,
            132863018,
            132893464,
            132893294,
            132866549,
            132861428,
            132858872,
            132861957,
            132863927,
            132861005,
            132863860,
            132868896,
            133312107,
            132858386
        ],
        "B": [
            132856790,
            132867123,
            132856747,
            132855505,
            132854485,
            132859085,
            132858770,
            132858595,
            132856173,
            132857637,
            132856186,
            132859468,
            132855951,
            132855099,
            132854810,
            132855351,
            132856357,
            132855765,
            132859435,
            133312040,
            132970544,
            132854847
        ],
        "A": [
            132855030,
            132855528,
            132854523,
            132892082,
            132854129,
            132904251,
            132854758,
            132854419,
            132906994,
            132854763,
            132856077,
            132854737,
            132984138,
            132854196,
            132859118,
            132854306,
            132855186,
            132865041,
            132857131,
            133311808,
            132970350,
            132854128
        ]
    },
    "name": "F2. Korney Korneevich and XOR  hard version ",
    "statement": "Korney Korneevich dag up an array a of length n. Korney Korneevich has\r\nrecently read about the operation bitwise XOR, so he wished to\r\nexperiment with it. For this purpose, he decided to find all integers x\r\nge 0 such that there exists an subsequence of the array a, in which the\r\nbitwise XOR of numbers is equal to x.It didn\u2019t take a long time for\r\nKorney Korneevich to find all such x, and he wants to check his result.\r\nThat\u2019s why he asked you to solve this problem!A sequence s is a\r\nsubsequence of a sequence b if s can be obtained from b by deletion of\r\nseveral (possibly, zero or all) elements.A sequence s_1, s_2,\r\nldots , s_m is called increasing if s_1 < s_2 <\r\nldots < s_m.\r\n",
    "solutions": [
        "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 8192;\n\nvoid solve(const vector<int>& a) {\n\tint n = a.size();\n\tvector<int> next_eq(n);\n\tvector<int> next_val(M + 1, n);\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tnext_eq[i] = next_val[a[i]];\n\t\tnext_val[a[i]] = i;\n\t}\n\tvector<int> f(M, M);\n\tvector<vector<int>> events(n);\n\tauto up = [&](int at, int val) {\n\t\tint prev = f[at];\n\t\tif (val >= prev) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = val + 1; i <= prev; ++i) {\n\t\t\tif (next_val[i] < n) {\n\t\t\t\tevents[next_val[i]].push_back(at);\n\t\t\t}\n\t\t}\n\t\tf[at] = val;\n\t};\n\tup(0, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint val = a[i];\n\t\tnext_val[val] = next_eq[i];\n\t\tfor (int at : events[i]) {\n\t\t\tassert(f[at] < val);\n\t\t\tup(at ^ val, val);\n\t\t}\n\t}\n\tint count = 0;\n\tfor (int val = 0; val < M; ++val) {\n\t\tif (f[val] < M) {\n\t\t\t++count;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", count);\n\tfor (int val = 0; val < M; ++val) {\n\t\tif (f[val] < M) {\n\t\t\tprintf(\"%d \", val);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"f.in\", \"r\", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tsolve(a);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Korney Korneevich and XOR  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/96267",
    "editorial": "Let\u00e2\u0080\u0099s iterate over all numbers of the array and for each number maintain\r\na list of all numbers , such that it\u00e2\u0080\u0099s possible to choose an increasing\r\nsubsequence on the current prefix, in which of numbers is equal to , and\r\nthe last number of that increasing subsequence is less than .Let us\r\ncurrently consider the element . Then let\u00e2\u0080\u0099s consider elements of there\r\nwill be all values of -s of the subsequences to which we can append the\r\nelement . If contains a value , then it\u00e2\u0080\u0099s possible to get a value , then\r\nlet\u00e2\u0080\u0099s add the value to all lists from to the maximal value of (if the\r\nvalue that is being added is already in some -s, it\u00e2\u0080\u0099s unnecessary to add\r\nit there again).Let\u00e2\u0080\u0099s perform some optimizations for this solution.\r\nLet\u00e2\u0080\u0099s stop considering the values that have already been considered.\r\nThat is, if we have already considered at some iteration, then let\u00e2\u0080\u0099s\r\nerase it, but remember that we never need to add the values of , that\r\nare being erased. That optimization is sufficient to get the asymptotic\r\nbehaviour , where is the greatest one among all numbers of the array\r\n(for every number and its possible value of we will pass over the value\r\nto all states ; the amount of different is , the amount of is as well,\r\nand the passing of the value each time is performed in ). Let\u00e2\u0080\u0099s notice\r\nthat when we pass some value of equal to to elements , and find the\r\nelement , in which that value of has already been, then the value is\r\nalready in all elements greater than , and that\u00e2\u0080\u0099s why we don\u00e2\u0080\u0099t have to\r\nadd the value any further. Using this optimization we can finally get a\r\nsolution in , since for every value of (the amount of them is ), we\r\nperform operations. In total (considering all optimizations), the\r\nasymptotic behaviour of the solution is .\r\n"
}