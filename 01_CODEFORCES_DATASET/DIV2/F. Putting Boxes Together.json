{
    "link": "https://codeforces.com//contest/1058/problem/F",
    "problemId": "223738",
    "problem_idx": "F",
    "shortId": "1058F",
    "contest_number": "1058",
    "problem_submissions": {
        "F": [
            43329652,
            43322741,
            43327075,
            43339320,
            43397318
        ],
        "E": [
            43317169,
            43335127,
            43311536,
            43318971,
            43319046,
            43349236,
            43325041,
            43322181,
            43322626,
            43309860,
            43322794,
            43327406,
            43321904,
            43323656,
            43323747,
            43323713,
            43316209,
            43327281,
            43327505
        ],
        "B": [
            43314909,
            43299015,
            43298589,
            43304743,
            43300553,
            43310414,
            43301962,
            43300188,
            43303702,
            43317695,
            43301396,
            43299393,
            43301629,
            43300037,
            43301041,
            43302979,
            43330380,
            43303019,
            43303281
        ],
        "C": [
            43311113,
            43302266,
            43300372,
            43301786,
            43303858,
            43309140,
            43303996,
            43302098,
            43308312,
            43301537,
            43306280,
            43302496,
            43303833,
            43303884,
            43307063,
            43311748,
            43303475,
            43307737,
            43305316
        ],
        "D": [
            43306998,
            43306866,
            43307236,
            43307768,
            43312416,
            43307189,
            43309783,
            43309198,
            43312128,
            43330363,
            43309334,
            43310807,
            43315529,
            43315808,
            43314759,
            43307976,
            43322616,
            43315377,
            43313629
        ],
        "A": [
            43304464,
            43296152,
            43295312,
            43296932,
            43295838,
            43311418,
            43296719,
            43295347,
            43301760,
            43297317,
            43296398,
            43295888,
            43295686,
            43295956,
            43297191,
            43296417,
            43297679,
            43297174,
            43295748
        ]
    },
    "name": "F. Putting Boxes Together",
    "statement": "There is an infinite line consisting of cells. There are n boxes in some\r\ncells of this line. The i-th box stands in the cell a_i and has weight\r\nw_i. All a_i are distinct, moreover, a_{i - 1} < a_i holds for all valid\r\ni.You would like to put together some boxes. Putting together boxes with\r\nin the segment [l, r] means that you will move some of them in such a\r\nway that their will form some segment [x, x + (r - l)].In one step you\r\ncan move any box to a neighboring cell if it isn\u2019t occupied by another\r\nbox (i.e. you can choose i and change a_i by 1, all positions should\r\nremain distinct). You spend w_i units of energy moving the box i by one\r\ncell. You can move any box any number of times, in arbitrary\r\norder.Sometimes weights of some boxes change, so you have queries of two\r\ntypes: id nw weight w_{id} of the box id becomes nw. l r you should\r\ncompute the minimum total energy needed to put together boxes with\r\nindices in [l, r]. Since the answer can be rather big, print the\r\nremainder it gives when divided by 1000\r\n,000\r\n,007 = 10^9 + 7. Note that the boxes are not moved during the query, you\r\nonly should compute the answer.\r\n",
    "solutions": [
        "//Williams Wu\n/*#include <EGE.h> //\ufffd\ufffd\u037c\u0377\ufffd\u013c\ufffd\n#define SHOW_CONSOLE*/\n/*#include <cstdio> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <iostream> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <algorithm> //STL\u0368\ufffd\ufffd\ufffd\u3de8\n#include <cmath> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0467\ufffd\ufffd\ufffd\ufffd\n#include <cstdlib> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ueeaf\ufffd\ufffd\ufffd\ufffd\ufffd\u06b4\ufffd\ufffd\ufffd\u4eaf\ufffd\ufffd\n#include <cstring> //\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <string> //\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <ctime> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u02b1\ufffd\ufffd\u013a\ufffd\ufffd\ufffd*/\n/*#include <bitset> //STL\u03bb\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <cstype> //\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <cerrno> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <complex> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <clocale> //\ufffd\ufffd\ufffd\u5c7e\ufffd\u063b\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <deque> //STL\u02eb\ufffd\u02f6\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <exception> //\ufffd\ucce3\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <fstream> //\ufffd\u013c\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <functional> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u3eaf\ufffd\ufffd(\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd)\n#include <limits> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u05b5\ufffd\ufffd\ufffd\ufffd\n#include <listt> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\u0431\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <mapp> //STL\u04f3\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <iomanip> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <ios> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\u05a7\ufffd\ufffd\n#include <iosfwd> //\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\u03f5\u0373\u02b9\ufffd\u00f5\ufffd\u01f0\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <istream> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <ostream> //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <queue> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <sett> //STL\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <sstream> //\ufffd\ufffd\ufffd\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <stackk> //STL\ufffd\ufffd\u057b\ufffd\ufffd\ufffd\ufffd\n#include <stdexcept> //\ufffd\ufffd\u05fc\ufffd\ucce3\ufffd\ufffd\n#include <streambuf> //\ufffd\u05f2\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\u05a7\ufffd\ufffd\n#include <utility> //STL\u0368\ufffd\ufffd\u0123\ufffd\ufffd\ufffd\ufffd\n#include <vector> //STL\ufffd\ufffd\u032c\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n#include <cwchar.h> //\ufffd\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd/\ufffd\ufffd\ufffd\n#include <cwctype.h> //\ufffd\ufffd\ufffd\u05b7\ufffd\ufffd\ufffd\ufffd\ufffd*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(u,v,nxt) for(int u=(v);(u)<=(nxt);(u)++)\n#define rep_(u,v,nxt) for(int u=(v);(u)<(nxt);(u)++)\n#define repf(u,v,nxt) for(int u=(v);(u)>=(nxt);(u)--)\n#define repf_(u,v,nxt) for(int u=(v);(u)>(nxt);(u)--)\n#define inf 0x3f3f3f3f  //0x7fffffff\n#define cle(u) memset(u,0,sizeof(u))\n#define clemin(u) memset(u,-1,sizeof(u))\n#define clemax(u) memset(u,0x3f,sizeof(u))  //127\nconst double PI=3.14159265358979323846264338327950288419716939937510;\nconst double E=2.7182818284590452353602874713526624977572470936999596;\nconst double eps=0.000000001;\nconst int MOD=1e9+7;\ntypedef long long LL;\ninline int max(int u,int v){return u>v?u:v;}\ninline int min(int u,int v){return u<v?u:v;}\ninline LL gcd(LL u,LL v){return v?gcd(v,u%v):u;}\n///////////////////////optimize//////////////////////////\ntemplate <typename T>\ninline void read(T& u){char id;u=0;bool used=0;id=getchar();\nwhile(id>'9'||id<'0'){if(id=='-')used=1;id=getchar();}\nwhile((id<='9'&&id>='0')){u=u*10+id-'0';id=getchar();}if(used)u*=-1;}\ntemplate <typename T>\ninline void read(T& u,T& v){read(u);read(v);}\ntemplate <typename T>\ninline void read(T& u,T& v,T& tmp){read(u);read(v);read(tmp);}\n/////////////////variables&functions/////////////////////\n\nstruct node{\n    int l,r,root;\n}tree[500100];\n\nint num[1000100],val[1000100];\nLL a[1000100],b[1000100];\nint tot=0;\n\ninline void pushup(int root)\n{\n    a[root]=a[root*2]+a[root*2+1];\n    b[root]=(b[root*2]+b[root*2+1])%MOD;\n}\n\nvoid build(int l,int r,int root)\n{\n    if(l==r)\n    {\n        a[root]=val[l];\n        b[root]=1ll*val[l]*num[l]%MOD;\n        return;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,root*2);\n    build(mid+1,r,root*2+1);\n    pushup(root);\n}\n\nvoid update(int l,int r,int root,int x)\n{\n    if(l==r)\n    {\n        a[root]=val[l];\n        b[root]=1ll*num[l]*val[l]%MOD;\n        return;\n    }\n    int mid=(l+r)/2;\n    if(x<=mid) update(l,mid,root*2,x);\n        else update(mid+1,r,root*2+1,x);\n    pushup(root);\n}\n\nvoid que(int l,int r,int root,int ll,int rr)\n{\n    if(l>=ll&&r<=rr)\n    {\n        tree[++tot].l=l;\n        tree[tot].r=r;\n        tree[tot].root=root;\n        return;\n    }\n    int mid=(l+r)/2;\n    if(ll<=mid) que(l,mid,root*2,ll,rr);\n    if(rr>mid) que(mid+1,r,root*2+1,ll,rr);\n}\n\nint find(int l,int r,int root,LL x)\n{\n    if(l==r) return l;\n    int mid=(l+r)/2;\n    if(a[root*2]>=x) return find(l,mid,root*2,x);\n        else return find(mid+1,r,root*2+1,x-a[root*2]);\n}\n\nint main()\n{\n    int n,T;\n    read(n,T);\n    rep(i,1,n) \n    {\n        read(num[i]);\n        num[i]-=i;\n    }\n    rep(i,1,n) read(val[i]);\n    build(1,n,1);\n    while(T--)\n    {\n        int x,y;\n        read(x,y);\n        if(x<0)\n        {\n            val[-x]=y;\n            update(1,n,1,-x);\n        }\n        else\n        {\n            tot=0;\n            que(1,n,1,x,y);\n            LL tp=0;\n            rep(i,1,tot) tp+=a[tree[i].root];\n            LL tp2=(tp+1)/2,tp3=0;\n            int R=0;\n            rep(i,1,tot)\n            {\n                if(tp3+a[tree[i].root]<tp2)\n                {\n                    tp3+=a[tree[i].root];\n                    R=i;\n                }\n                    else break;               \n            }\n            int height=find(tree[R+1].l,tree[R+1].r,tree[R+1].root,tp2-tp3);\n            LL ans=0;\n            if(x<=height-1)\n            {\n                tot=0;\n                que(1,n,1,x,height-1);\n                LL tmp=0;\n                rep(i,1,tot) (tmp+=a[tree[i].root])%=MOD;\n                (ans+=1ll*num[height]*tmp)%=MOD;\n                rep(i,1,tot) (ans-=b[tree[i].root])%=MOD;\n            }\n            if(height+1<=y)\n            {\n                tot=0;\n                que(1,n,1,height+1,y);\n                LL tmp=0;\n                rep(i,1,tot) (tmp+=a[tree[i].root])%=MOD;\n                (ans-=1ll*num[height]*tmp)%=MOD;\n                rep(i,1,tot) (ans+=b[tree[i].root])%=MOD;\n            }\n            ans=(ans%MOD+MOD)%MOD;\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Putting Boxes Together.json",
    "editorial_link": "https://codeforces.com/blog/entry/62013",
    "editorial": "Firstly, let's prove that it's always optimal to leave one of the boxes untouched. By contradiction: if all boxes will move, so some left part will move right and right part will move left. Let the total cost of shifting the whole left part by one be equal to Sl\n and cost of the right part be Sr\n. We can replace the move of one of the parts by extra move of the other part, so we can change max(Sl,Sr)\n by min(Sl,Sr)\n \u0097 total cost doesn't increase \u0097 contradiction.\n\nLet S(l,r)=?i=lrwi\n. Then, secondly, let's prove that for some segment [l,r]\n it's always optimal to choose untouched box k\n such that S(l,k?1)?S(l,r)2\n, but S(l,k)?S(l,r)2\n. Again: if it is not true then either S(l,k?1)>S(l,r)2\n or S(k+1,r)>S(l,r)2\n. And we again can replace either S(l,k?1)\n by S(k,r)\n or S(k+1,r)\n by S(l,k)\n. Total cost is decreasing \u0097 contradiction.\n\nSo, finally, all we need is to process the following queries: for given [l,r]\n find maximum k\n that S(l,k?1)?S(l,r)2\n, but S(l,k)>S(l,r)2\n (>\n or ?\n doesn't really matter). It can be done with binary search + BIT in O(log2n)\n time or by \"descending\" down the Segment Tree in O(logn)\n time.\n\nNext part is how to calculate the answer for the known k\n. Since the cost of moving box i\n to the right place is equal to wi(ak?ai?(k?i))\n if i<k\n and wi(ai?ak?(i?k))\n otherwise so, if we shift from ai\n to ai?i\n then the cost to move all left indices are equal to ?i=lk?1wi(ak?ai)=ak?S(l,k?1)??i=lk?1wiai\n. The right part transforms in the same way. Since answer is modulo 109+7\n we can calculate ?i=lk?1(wiaimod109+7)\n using another BIT.\n\nResult complexity is O(nlogn+qlog2n)\n or O((n+q)logn)\n (which isn't really faster in this task)."
}