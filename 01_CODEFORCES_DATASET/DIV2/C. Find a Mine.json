{
    "link": "https://codeforces.com//contest/1934/problem/C",
    "problemId": "2505361",
    "problem_idx": "C",
    "shortId": "1934C",
    "contest_number": "1934",
    "problem_submissions": {
        "D2": [
            249138861,
            249138286,
            249148347,
            249142453,
            249157574,
            249154795,
            249156400,
            249152916,
            249153265,
            249152468,
            249159235,
            249151373,
            249157739,
            249158790,
            249158719,
            249157715,
            249151531,
            249154568
        ],
        "D1": [
            249125699,
            249128677,
            249134651,
            249133932,
            249131438,
            249132804,
            249141726,
            249142358,
            249133864,
            249137039,
            249209635,
            249137420,
            249137703,
            249134521,
            249138551,
            249144781,
            249136421,
            249139126,
            249137860
        ],
        "C": [
            249115447,
            249119119,
            249121601,
            249125691,
            249121785,
            249119998,
            249118653,
            249123649,
            249122623,
            249127946,
            249126111,
            249128427,
            249128773,
            249122463,
            249117989,
            249122384,
            249127040,
            249126459
        ],
        "B": [
            249103913,
            249106551,
            249108288,
            249115212,
            249104799,
            249109733,
            249104490,
            249108744,
            249111760,
            249108303,
            249108953,
            249111319,
            249106725,
            249111924,
            249107412,
            249112945,
            249107802,
            249115127
        ],
        "A": [
            249100199,
            249101211,
            249103188,
            249100104,
            249099925,
            249108944,
            249100108,
            249104411,
            249104537,
            249100853,
            249102757,
            249099965,
            249100710,
            249100333,
            249102042,
            249101590,
            249101009,
            249100585
        ],
        "E": [
            249308601
        ]
    },
    "name": "C. Find a Mine",
    "statement": "You are given a grid with n rows and m columns. The coordinates (x, y)\r\nrepresent the cell on the grid, where x (1\r\nleq x\r\nleq n) is the row number counting from the top and y (1\r\nleq y\r\nleq m) is the column number counting from the left. It is guaranteed\r\nthat there are exactly 2 mines in the grid at cells, denoted as (x_1,\r\ny_1) and (x_2, y_2). You are allowed to make no more than 4 queries to\r\nthe interactor, and after these queries, you need to provide the\r\nlocation of .In each query, you can choose any grid cell (x, y), and in\r\nreturn, you will receive the minimum Manhattan distance from both the\r\nmines to the chosen cell, i.e., you will receive the value\r\nmin(|x-x_1|+|y-y_1|, |x-x_2|+|y-y_2|).Your task is to determine the\r\nlocation of one of the mines after making the queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n//#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nint query(int x, int y){\n    cout << \"? \" << x << ' ' << y << endl;\n    int ret; cin >> ret;\n    return ret;\n}\n\nsigned main(){\n    //IOS;\n\n    int T; cin >> T;\n    while(T--){\n        int n, m; cin >> n >> m;\n\n        int ret1, ret2, ret3, ret4, x1, y1, x2, y2;\n        ret1 = query(1, 1);\n        if(ret1 + 1 <= m) ret2 = query(1, ret1 + 1), x1 = 1 + ret2 / 2, y1 = ret1 + 1 - ret2 / 2;\n        else ret2 = query(ret1 + 2 - m, m), x1 = ret1 + 2 - m + ret2 / 2, y1 = m - ret2 / 2;\n        if(ret1 + 1 <= n) ret3 = query(ret1 + 1, 1), x2 = ret1 + 1 - ret3 / 2, y2 = 1 + ret3 / 2;\n        else ret3 = query(n, ret1 + 2 - n), x2 = n - ret3 / 2, y2 = ret1 + 2 - n + ret3 / 2;\n\n        if(x1 <= 0 || y1 <= 0 || x1 > n || y1 > m || query(x1, y1) != 0) cout << \"! \" << x2 << ' ' << y2 << endl;\n        else cout << \"! \" << x1 << ' ' << y1 << endl;\n        \n    }\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "geometry",
        "greedy",
        "interactive",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Find a Mine.json",
    "editorial_link": "https://codeforces.com//blog/entry/126423",
    "editorial": "First, we query \"?\n 1\n 1\n\" then you get a value a1\n and you know that at least one of the mine is on the line x+y=a1+2\n.\n\nNow we make two more queries on both ends of this line where it touches the grid. After these two queries, we get two possible locations of the mine. We query one of these positions if we receive 0\n as the answer then this location otherwise the other location is the answer.\n\nReason: One of that two locations contains a mine. The other mine could spoil the result of the query only from one end. If it was closer from the other mine to both of the ends, it would mean that going from one end to the other is shorter through that mine, than through the diagonal. That's impossible."
}