{"link": "https://codeforces.com//contest/1649/problem/E", "problemId": "1318587", "problem_idx": "E", "shortId": "1649E", "contest_number": "1649", "problem_submissions": {"E": [148570405, 148567587, 148573812, 148564341, 148576426, 148573557, 148575813, 148579228, 148575906, 148578716, 148579271, 148582328, 148662355, 148583368, 148578883, 148582802, 148585418, 148586818, 148585982, 148581078, 148612161, 148588539], "D": [148557933, 148560820, 148562956, 148546618, 148566533, 148563719, 148566682, 148565430, 148568037, 148566184, 148563368, 148567438, 148563519, 148569228, 148568798, 148555841, 148568207, 148564278, 148570230, 148612195, 148612000, 148565213], "C": [148552699, 148553185, 148557085, 148565920, 148554169, 148559874, 148558298, 148559324, 148560060, 148552010, 148557966, 148557845, 148558319, 148563597, 148559134, 148551291, 148559957, 148557540, 148559934, 148557341], "B": [148549340, 148547930, 148551996, 148570058, 148544445, 148556309, 148549430, 148554177, 148555299, 148555535, 148553000, 148547200, 148552578, 148554529, 148552354, 148559155, 148554077, 149225497, 148573979, 148552460, 148550780], "A": [148541954, 148570044, 148542065, 148571095, 148541611, 148544925, 148541660, 148544973, 148544958, 148558109, 148541535, 148542135, 148541834, 148556570, 148541907, 148561936, 148542732, 149225451, 148543259, 148541552, 148544161], "F": [148802496, 148696109, 148694405]}, "name": "E. Tyler and Strings", "statement": "While looking at the kitchen fridge, the little boy Tyler noticed\r\nmagnets with symbols, that can be aligned into a string s.Tyler likes\r\nstrings, and especially those that are lexicographically smaller than\r\nanother string, t. After playing with magnets on the fridge, he is\r\nwondering, how many distinct strings can be composed out of letters of\r\nstring s by rearranging them, so that the resulting string is\r\nlexicographically smaller than the string t? Tyler is too young, so he\r\ncan\u2019t answer this question. The alphabet Tyler uses is very large, so\r\nfor your convenience he has already replaced the same letters in s and t\r\nto the same integers, keeping that different letters have been replaced\r\nto different integers.We call a string x lexicographically smaller than\r\na string y if one of the followings conditions is fulfilled: There\r\nexists such position of symbol m that is presented in both strings, so\r\nthat before m-th symbol the strings are equal, and the m-th symbol of\r\nstring x is smaller than m-th symbol of string y. String x is the prefix\r\nof string y and x\r\nneq y. Because the answer can be too large, print it modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define deb(...) 4\n#endif\n\nconst int mod=998244353;\nstruct mint{\n\tint a;\n\tmint()=default;\n\tmint(int x):a((x%mod+mod)%mod){}\n\tmint operator+(const mint &x)const{return this->a+x.a;}\n\tmint operator-(const mint &x)const{return this->a-x.a;}\n\tmint operator*(const mint &x)const{return this->a*x.a;}\n\tmint &operator+=(const mint x){*this=*this+x; return *this;}\n\tmint &operator-=(const mint x){*this=*this-x; return *this;}\n\tmint &operator*=(const mint x){*this=*this*x; return *this;}\n\tmint operator-()const{return (this->a?mod-this->a:0);}\n\tmint power(int y)const{\n\t\tmint x=*this;\n\t\tmint res=1;\n\t\twhile(y){\n\t\t\tif(y&1) res*=x;\n\t\t\tx*=x;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return power(mod-2);} //mod must be prime\n\tmint operator/(const mint &x)const{return *this*x.inv();}\n\tmint &operator/=(const mint &x){*this=*this/x; return *this;}\n\tbool operator==(mint x)const{return (this->a==x.a);}\n\tbool operator!=(mint x)const{return (this->a!=x.a);}\n\tbool operator<(mint x)const{return (this->a<x.a);}\n\tbool operator>(mint x)const{return (this->a>x.a);}\n};\nmint operator*(int &x,mint &y){return y*x;}\nistream&operator>>(istream&stream,mint&y){int x;stream>>x;y=x;return stream;}\nostream&operator<<(ostream&stream,mint y){return stream<<y.a;}\nvector<mint>fact(1,1),invf(1,1);\nmint ncr(int n,int k){\n\tif(n<0||k<0||n<k) return 0;\n\tint x=(int)(fact.size());\n\twhile(x<=n){\n\t\tmint f=fact[x-1]*x;\n\t\tfact.push_back(f);\n\t\tinvf.push_back(f.inv());\n\t\tx++;\n\t}\n\treturn fact[n]*invf[k]*invf[n-k];\n}\n\ntemplate<typename T>\nstruct segtree{\n    vector<T>tr;\n    T def;\n \n    void init(int N,T x){\n        tr.assign(4*N+10,x);\n        def=x;\n    }\n    T merge(T x,T y){\n        return x+y;\n    }\n    void build(int no,int l,int r,vector<T>&v){\n        if(l==r){\n            tr[no]+=v[l];\n            return;\n        }\n        int mid=(l+r)>>1;\n        build(no<<1,l,mid,v);\n        build(no<<1|1,mid+1,r,v);\n        tr[no]=merge(tr[no<<1],tr[no<<1|1]);\n    }\n    void update(int no,int l,int r,int wh,T x){\n        if(l==r){\n            tr[no]+=x;\n            return;\n        }\n        int mid=(l+r)>>1;\n        if(wh<=mid) update(no<<1,l,mid,wh,x);\n        else update(no<<1|1,mid+1,r,wh,x);\n        tr[no]=merge(tr[no<<1],tr[no<<1|1]);\n    }\n    T qry(int no,int l,int r,int st,int en){\n        if(r<st||l>en) return def;\n        if(l>=st&&r<=en) return tr[no];\n        int mid=(l+r)>>1;\n        return merge(qry(no<<1,l,mid,st,en),qry(no<<1|1,mid+1,r,st,en));\n    }\n};\n\nconst int N=200005;\nsigned main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tncr(N+1,N+1);\n\tint n,m;\n\tcin>>n>>m;\n\tvector<int>s(n),t(m);\n\tfor(int i=0;i<n;i++) cin>>s[i];\n\tfor(int j=0;j<m;j++) cin>>t[j];\n\tmint ans=0;\n\tsegtree<mint>sg;\n\tsg.init(N,0);\n\tvector<int>cnt(N);\n\tmint cur=1;\n\tfor(int i=0;i<n;i++){\n\t\tcnt[s[i]]++;\n\t\tsg.update(1,0,N,s[i],1);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcur*=invf[cnt[i]];\n\t}\n\tbool p=false;\n\tfor(int i=0;i<min(n,m);i++){\n\t\tmint tot=sg.qry(1,0,N,0,t[i]-1);\n\t\tans+=fact[n-i-1]*cur*tot;\n\t\tif(cnt[t[i]]){\n\t\t\tcur*=fact[cnt[t[i]]];\n\t\t\tcnt[t[i]]--;\n\t\t\tcur*=invf[cnt[t[i]]];\n\t\t\tsg.update(1,0,N,t[i],-1);\n\t\t}\n\t\telse{\n\t\t\tp=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!p&&n<m) ans+=1;\n\tcout<<ans;\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "data structures", "dp", "math"], "dificulty": "1900", "interactive": false}