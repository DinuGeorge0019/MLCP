{
    "link": "https://codeforces.com//contest/1649/problem/E",
    "problemId": "1318587",
    "problem_idx": "E",
    "shortId": "1649E",
    "contest_number": "1649",
    "problem_submissions": {
        "E": [
            148570405,
            148567587,
            148573812,
            148564341,
            148576426,
            148573557,
            148575813,
            148579228,
            148575906,
            148578716,
            148579271,
            148582328,
            148662355,
            148583368,
            148578883,
            148582802,
            148585418,
            148586818,
            148585982,
            148581078,
            148612161,
            148588539
        ],
        "D": [
            148557933,
            148560820,
            148562956,
            148546618,
            148566533,
            148563719,
            148566682,
            148565430,
            148568037,
            148566184,
            148563368,
            148567438,
            148563519,
            148569228,
            148568798,
            148555841,
            148568207,
            148564278,
            148570230,
            148612195,
            148612000,
            148565213
        ],
        "C": [
            148552699,
            148553185,
            148557085,
            148565920,
            148554169,
            148559874,
            148558298,
            148559324,
            148560060,
            148552010,
            148557966,
            148557845,
            148558319,
            148563597,
            148559134,
            148551291,
            148559957,
            148557540,
            148559934,
            148557341
        ],
        "B": [
            148549340,
            148547930,
            148551996,
            148570058,
            148544445,
            148556309,
            148549430,
            148554177,
            148555299,
            148555535,
            148553000,
            148547200,
            148552578,
            148554529,
            148552354,
            148559155,
            148554077,
            149225497,
            148573979,
            148552460,
            148550780
        ],
        "A": [
            148541954,
            148570044,
            148542065,
            148571095,
            148541611,
            148544925,
            148541660,
            148544973,
            148544958,
            148558109,
            148541535,
            148542135,
            148541834,
            148556570,
            148541907,
            148561936,
            148542732,
            149225451,
            148543259,
            148541552,
            148544161
        ],
        "F": [
            148802496,
            148696109,
            148694405
        ]
    },
    "name": "E. Tyler and Strings",
    "statement": "While looking at the kitchen fridge, the little boy Tyler noticed\r\nmagnets with symbols, that can be aligned into a string s.Tyler likes\r\nstrings, and especially those that are lexicographically smaller than\r\nanother string, t. After playing with magnets on the fridge, he is\r\nwondering, how many distinct strings can be composed out of letters of\r\nstring s by rearranging them, so that the resulting string is\r\nlexicographically smaller than the string t? Tyler is too young, so he\r\ncan’t answer this question. The alphabet Tyler uses is very large, so\r\nfor your convenience he has already replaced the same letters in s and t\r\nto the same integers, keeping that different letters have been replaced\r\nto different integers.We call a string x lexicographically smaller than\r\na string y if one of the followings conditions is fulfilled: There\r\nexists such position of symbol m that is presented in both strings, so\r\nthat before m-th symbol the strings are equal, and the m-th symbol of\r\nstring x is smaller than m-th symbol of string y. String x is the prefix\r\nof string y and x\r\nneq y. Because the answer can be too large, print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"\n#else\n#define deb(...) 4\n#endif\n\nconst int mod=998244353;\nstruct mint{\n\tint a;\n\tmint()=default;\n\tmint(int x):a((x%mod+mod)%mod){}\n\tmint operator+(const mint &x)const{return this->a+x.a;}\n\tmint operator-(const mint &x)const{return this->a-x.a;}\n\tmint operator*(const mint &x)const{return this->a*x.a;}\n\tmint &operator+=(const mint x){*this=*this+x; return *this;}\n\tmint &operator-=(const mint x){*this=*this-x; return *this;}\n\tmint &operator*=(const mint x){*this=*this*x; return *this;}\n\tmint operator-()const{return (this->a?mod-this->a:0);}\n\tmint power(int y)const{\n\t\tmint x=*this;\n\t\tmint res=1;\n\t\twhile(y){\n\t\t\tif(y&1) res*=x;\n\t\t\tx*=x;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return power(mod-2);} //mod must be prime\n\tmint operator/(const mint &x)const{return *this*x.inv();}\n\tmint &operator/=(const mint &x){*this=*this/x; return *this;}\n\tbool operator==(mint x)const{return (this->a==x.a);}\n\tbool operator!=(mint x)const{return (this->a!=x.a);}\n\tbool operator<(mint x)const{return (this->a<x.a);}\n\tbool operator>(mint x)const{return (this->a>x.a);}\n};\nmint operator*(int &x,mint &y){return y*x;}\nistream&operator>>(istream&stream,mint&y){int x;stream>>x;y=x;return stream;}\nostream&operator<<(ostream&stream,mint y){return stream<<y.a;}\nvector<mint>fact(1,1),invf(1,1);\nmint ncr(int n,int k){\n\tif(n<0||k<0||n<k) return 0;\n\tint x=(int)(fact.size());\n\twhile(x<=n){\n\t\tmint f=fact[x-1]*x;\n\t\tfact.push_back(f);\n\t\tinvf.push_back(f.inv());\n\t\tx++;\n\t}\n\treturn fact[n]*invf[k]*invf[n-k];\n}\n\ntemplate<typename T>\nstruct segtree{\n    vector<T>tr;\n    T def;\n \n    void init(int N,T x){\n        tr.assign(4*N+10,x);\n        def=x;\n    }\n    T merge(T x,T y){\n        return x+y;\n    }\n    void build(int no,int l,int r,vector<T>&v){\n        if(l==r){\n            tr[no]+=v[l];\n            return;\n        }\n        int mid=(l+r)>>1;\n        build(no<<1,l,mid,v);\n        build(no<<1|1,mid+1,r,v);\n        tr[no]=merge(tr[no<<1],tr[no<<1|1]);\n    }\n    void update(int no,int l,int r,int wh,T x){\n        if(l==r){\n            tr[no]+=x;\n            return;\n        }\n        int mid=(l+r)>>1;\n        if(wh<=mid) update(no<<1,l,mid,wh,x);\n        else update(no<<1|1,mid+1,r,wh,x);\n        tr[no]=merge(tr[no<<1],tr[no<<1|1]);\n    }\n    T qry(int no,int l,int r,int st,int en){\n        if(r<st||l>en) return def;\n        if(l>=st&&r<=en) return tr[no];\n        int mid=(l+r)>>1;\n        return merge(qry(no<<1,l,mid,st,en),qry(no<<1|1,mid+1,r,st,en));\n    }\n};\n\nconst int N=200005;\nsigned main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tncr(N+1,N+1);\n\tint n,m;\n\tcin>>n>>m;\n\tvector<int>s(n),t(m);\n\tfor(int i=0;i<n;i++) cin>>s[i];\n\tfor(int j=0;j<m;j++) cin>>t[j];\n\tmint ans=0;\n\tsegtree<mint>sg;\n\tsg.init(N,0);\n\tvector<int>cnt(N);\n\tmint cur=1;\n\tfor(int i=0;i<n;i++){\n\t\tcnt[s[i]]++;\n\t\tsg.update(1,0,N,s[i],1);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tcur*=invf[cnt[i]];\n\t}\n\tbool p=false;\n\tfor(int i=0;i<min(n,m);i++){\n\t\tmint tot=sg.qry(1,0,N,0,t[i]-1);\n\t\tans+=fact[n-i-1]*cur*tot;\n\t\tif(cnt[t[i]]){\n\t\t\tcur*=fact[cnt[t[i]]];\n\t\t\tcnt[t[i]]--;\n\t\t\tcur*=invf[cnt[t[i]]];\n\t\t\tsg.update(1,0,N,t[i],-1);\n\t\t}\n\t\telse{\n\t\t\tp=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!p&&n<m) ans+=1;\n\tcout<<ans;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dp",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tyler and Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/100592",
    "editorial": "Let K\n be the size of the alphabet, that is, the number of the maximum letter that occurs in it.\n\nFirst, let's calculate how many different strings can be composed if we have c1\n letters of the 1\nth type, c2\n letters of the 2\nth type, \n, cK\n letters of the K\n type. This is the school formula:\n\nP(c1,c2,,cK)=(c1+c2++cK)!c1!?c2!??cK!\n\nto quickly calculate it for different c1,c2,,ck\n pre-calculate all factorials and their reciprocals modulo C=998244353\n in O(n?logC\n)\n\nIn order for the string x\n to be less than the string t, they must have the same prefix. Let's iterate over the length of this matching prefix from 0\n to min(n,m)\n. If strings x\n and t\n have the same first i\n characters, then we know exactly how many letters we have left. To support this, let's create an array cnt, at the i\n-th position of which there will be the number of remaining letters of type i\n.\n\nLet's iterate over the letter that will appear immediately after the matching prefix. For the resulting string to be less than t\n, this letter must be strictly less than the corresponding letter in t\n, and all subsequent letters can be arranged in any order. Let's calculate the number of rows x\n considered in this way according to the formula above.\n\nThe only case where the resulting string x\n can be lexicographically less than t\n, which we will not count, is when it is a prefix of the string t\n, but has a shorter length. We will separately check whether we can get such a string, and if so, add 1 to the answer.\n\nSince at each of at most min(n,m)\n steps we need to go through at most K\n options for the next letter, and we calculate each option in O(K\n) - we get the asymptotics O(min(n,m)?K2+n?logC\n)\n\nTo speed up the resulting solution, let's create an array add\n, in the i\n-th cell of which we store how many ways it will be possible to arrange the remaining letters if the letter i\n is put in the current position. In fact addi=(cnt1+cnt2++cntK?1)!cnt1!?cnt2!??(cnti?1)!??cntK!\n\nIf we learn how to maintain this array, then at each step we only need to take the sum of the elements at some of its prefix. Let's see how it changes if the next letter in the string t\n is i\n, i.e. cnti\n should decrease by 1.\n\nFor all cells j?i\n addj\n is replaced by addj?cnticnt1+cnt2++cntK?1\n. To apply modifications to the entire array, let's create a separate variable modify\n, by which we need to multiply the value in the cell to get the value that should be there.\n\nFor cell i\n, addi\n will be replaced by addi?cnti?1cnt1+cnt2++cntK?1\n. And taking into account the fact that we applied a modifier to all cells, it is enough to multiply the value of addi\n by cnti?1cnti\n\nWith this optimization, we now spend only O(K) actions at each step to calculate the prefix sum, and O(log(C)\n) to calculate what to multiply the array cells by. We get the asymptotics O(min(n,m)?(K+log(C))\n) To get rid of K\n asymptotically, note that the only thing we want to do with the add\n array is take the sum at the prefix and change the value at the point. This can be done in O(log(K)\n using the Fenwick Tree or the Segment Tree. Applying them, we get the final asymptotic O(min(n,m)?(log(K)+log(C))\n).\n\nIn fact, log(C)\n in the asymptotics can be eliminated by precalculating modulo reciprocals for all numbers from 1\n to n\n faster than O(n?log(C)\n), but in this task was not required.",
    "hint": []
}