{"link": "https://codeforces.com//contest/877/problem/B", "problemId": "130129", "problem_idx": "B", "shortId": "877B", "contest_number": "877", "problem_submissions": {"F": [31654167, 31653139, 31655134, 31656955, 31639931, 31650204, 31648622, 31651887, 33479364, 31655646, 31694169, 31893110], "E": [31643937, 31646320, 31646382, 31649500, 31641532, 31645322, 31640350, 31645337, 31641515, 31644016, 31652300, 31648164, 31648540, 31649482, 31644271, 31648366, 31646891, 31648638, 31653283, 31654866], "D": [31641155, 31644336, 31643884, 31647657, 31665021, 31739883, 31649498, 31650176, 31649638, 31639062, 31644913, 31645497, 31649880, 31645363, 31666561, 31654457, 31648925, 31649435], "C": [31638971, 31647846, 31638928, 31641413, 31644732, 31639320, 31637367, 31649045, 31644989, 31640032, 31639911, 31643252, 31638722, 31638437, 31636874, 31639305, 31642602, 31642153, 31643991, 31641659], "B": [31638394, 31636212, 31636559, 31636226, 31644604, 31636106, 31634815, 31636547, 31636242, 31637676, 31679870, 31636958, 31645807, 31636913, 31635284, 31638201, 31637074, 31636966, 31638021, 31639655, 31639274], "A": [31635408, 31634914, 31634587, 31634665, 31664979, 31634608, 31634317, 31634960, 31650654, 31634394, 31634371, 31644024, 31634639, 31634521, 31634889, 31634575, 31635175, 31640619, 31635186, 31635511]}, "name": "B. Nikita and string", "statement": "One day Nikita found the string containing letters \"\" and \"\" only.\r\nNikita thinks that string is beautiful if it can be cut into strings\r\n(possibly empty) without changing the order of the letters, where the\r\n-st and the -rd one contain only letters \"\" and the -nd contains only\r\nletters \"\".Nikita wants to make the string beautiful by removing some\r\n(possibly none) of its characters, but without changing their order.\r\nWhat is the maximum length of the string he can get?\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long  LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define F first\n#define S second\ninline int read(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\n#include<string>\nconst int N=5005;\nchar s[N];\nint dp[N][3];\nint main(){\n\tcin>>(s+1);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<3;j++)dp[i][j]=dp[i-1][j];\n\t\tif(s[i]=='a'){\n\t\t\tdp[i][0]++;\n\t\t\tdp[i][1]=max(dp[i][1],dp[i][0]);\n\t\t\tdp[i][2]=max(max(dp[i][1],dp[i][2]+1),dp[i-1][1]+1);\n\t\t}else{\n\t\t\tdp[i][1]=max(dp[i][1]+1,max(dp[i-1][0]+1,dp[i][0]));\n\t\t\tdp[i][2]=max(dp[i][2],dp[i][1]);\n\t\t}\n\t}\n\tcout<<dp[n][2]<<endl;\n}"], "input": "", "output": "", "tags": ["brute force", "dp"], "dificulty": "1500", "interactive": false}