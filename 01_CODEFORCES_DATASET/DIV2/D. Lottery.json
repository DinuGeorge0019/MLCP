{"link": "https://codeforces.com//contest/1836/problem/D", "problemId": "1971176", "problem_idx": "D", "shortId": "1836D", "contest_number": "1836", "problem_submissions": {"E": [210147681, 210156192, 210163487, 210136429, 210157213, 210315010, 210158073, 210164123, 210155192, 210164163, 210159525], "C": [210130232, 210131057, 210124529, 210133873, 210151231, 210126284, 210133931, 210138158, 210136673, 210132463, 210128133, 210140056, 210148028, 210143853, 210137711, 210137608, 210128551, 210120166, 210126121], "B": [210123440, 210126296, 210116405, 210125585, 210144712, 210122722, 210125845, 210141461, 210122883, 210123468, 210120670, 210126915, 210118094, 210134923, 210163701, 210137111, 210115730, 210115790], "A": [210111620, 210110060, 210110623, 210116661, 210139143, 210111484, 210110034, 210110353, 210111957, 210118244, 210112250, 210110488, 210111107, 210115218, 210110094, 210110963, 210112266, 210116067, 210110124], "D": [210158558, 210154147, 210162752, 210191544, 210162490, 210160449, 210160513, 210163603]}, "name": "D. Lottery", "statement": "n people indexed with integers from 1 to n came to take part in a\r\nlottery. Each received a ticket with an integer from 0 to m.In a\r\nlottery, one integer called is drawn uniformly from 0 to m. k tickets\r\n(or less, if there are not enough participants) with the closest numbers\r\nto the target are declared the winners. In case of a draw, a ticket\r\nbelonging to the person with a smaller index is declared a winner.Bytek\r\ndecided to take part in the lottery. He knows the values on the tickets\r\nof all previous participants. He can pick whatever value he wants on his\r\nticket, but unfortunately, as he is the last one to receive it, he is\r\nindexed with an integer n + 1. Bytek wants to win the lottery. Thus, he\r\nwants to know what he should pick to maximize the chance of winning. He\r\nwants to know the smallest integer in case there are many such integers.\r\nYour task is to find it and calculate his chance of winning.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n//Safe lowerbound for 1 second is 10^8 operations\n\n#define f0r(a, b) for (long long a = 0; a < b; a++)\n#define f1r(a, b, c) for (long long a = b; a < c; a++)\n#define r0f(a, b) for (long long a = b - 1; a >= 0; a--)\n#define r1f(a, b, c) for (long long a = b; a >= c; a--)\n#define pb push_back\n#define f first\n#define s second\n\n#define mp make_pair\n#define t third\n#define pll pair<ll, ll>\n#define pii pair<int, int>\n\n/* For Debugging Purposes */\n#ifdef LOCAL\n#define DEBUG(...) debug(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DEBUG(...) 6\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) {bool f = true; os << \"[\"; for (const auto &x : c) {if (!f) os << \", \"; f = false; os << x;} return os << \"]\";}\ntemplate<typename T> void debug(string s, T x) {cerr << \"\\033[1;34m\" << s << \"\\033[0;32m = \\033[35m\" << x << \"\\033[0m\\n\";}\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) {for (int i=0, b=0; i<(int)s.size(); i++) if (s[i] == '(' || s[i] == '{') b++; else\n        if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {cerr << \"\\033[1;34m\" << s.substr(0, i) << \"\\033[0;32m = \\033[35m\" << x << \"\\033[31m | \"; debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}\n\n/* Variartic Macros and Functions so max(a, b, c, d, ... z) works out of box */\ntemplate<typename T> constexpr const inline T& _max(const T& x, const T& y) {return x<y?y:x;}\ntemplate<typename T> constexpr const inline T& _min(const T& x, const T& y) {return x<y?x:y;}\ntemplate<typename T,typename ...S>constexpr const inline T& _max(const T& m, const S&...s){return _max(m,_max(s...));}\ntemplate<typename T,typename ...S>constexpr const inline T& _min(const T& m, const S&...s){return _min(m,_min(s...));}\n#define max(...) _max(__VA_ARGS__)\n#define min(...) _min(__VA_ARGS__)\n\n#define io ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nvoid usaco(string filename) {\n    io;\n    freopen((filename + \".in\").c_str(), \"r\", stdin);\n    freopen((filename + \".out\").c_str(), \"w\", stdout);\n}\n\n#include <chrono>\nusing namespace std::chrono;\nstruct timer {\n    high_resolution_clock::time_point begin;\n\n    timer() {}\n    timer(bool b) {\n        if (b) start();\n    }\n\n    void start() {\n        begin = high_resolution_clock::now();\n    }\n\n    void print() {\n        cout << \"Time taken: \" << duration_cast<duration<double>>(high_resolution_clock::now() - begin).count() << \" seconds\" << endl;\n    }\n\n    double report() {\n        return duration_cast<duration<double>>(high_resolution_clock::now() - begin).count();\n    }\n};\n// Start of main put tin, end of main put tpr (tgt gives you value not printed)\n#define tin timer __timer__(1);\n#define tpr __timer__.print();\n#define tgt __timer__.report()\n\nll q, Q, T, k, l, r, x, y, z;\nll n, m;\n\nvoid solve();\n\n// Problem URL:\nint main() {\n    io;\n    long long test_cases = 1;\n//    cin >> test_cases;\n\n    for (int i = 0; i < test_cases; i++) {\n        solve();\n    }\n}\n\nvector<ll> pt;\nvector<ll> v;\nmap<ll, ll> cnt;\n\nvoid solve() {\n\tcin >> n >> m >> k;\n\t\n\tpt.push_back(0);\n\tpt.push_back(m);\n\tfor (ll i = 0; i < n; i++) {\n\t\tcin >> x;\n\t\tv.push_back(x);\n\t\tfor (ll t = -2; t <= 2; t++) {\n\t\t\tll y = x + t;\n\t\t\tif (0 <= y && y <= m) pt.push_back(y);\n\t\t}\n\t\t// ++cnt[x];\n\t}\n\tsort(pt.begin(), pt.end());\n\tpt.resize(unique(pt.begin(), pt.end()) - pt.begin());\n\tsort(v.begin(), v.end());\n\t\n\tll ansv = -1, ansi = -1;\n\n\tll li = 0, ri = 0;\n\tfor (ll x: pt) {\n\t\tll ans = 0;\n\t\twhile (li < ll(v.size()) && (li < 0 || v[li] <= x)) ++li;\n\t\t--li;\n\t\twhile (ri < v.size() && v[ri] < x) ++ri;\n\n\t\t{\n\t\t\tll lv = li - k + 1;\n\t\t\tif (lv < 0) ans += x;\n\t\t\telse {\n\t\t\t\tans += (x - v[lv] - 1) / 2;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tll rv = ri + k - 1;\n\t\t\tif (rv >= v.size()) ans += m - x;\n\t\t\telse {\n\t\t\t\tans += (v[rv] - x - 1) / 2;\n\t\t\t}\n\t\t}\n\t\t// if (cnt[x] < k) ++ans;\n\n\t\tll ct = 0;\n\t\tif (li >= 0 && li < v.size() && v[li] == x) ct = li - ri + 1;\n\t\tif (ct < k) ++ans;\n\n\t\tDEBUG(x, ans, li, ri);\n\t\tif (ans > ansv) {\n\t\t\tansv = ans;\n\t\t\tansi = x;\n\t\t}\n\t}\n\tcout << ansv << \" \" << ansi << '\\n';\n}\n"], "input": "", "output": "", "tags": ["binary search", "implementation", "two pointers"], "dificulty": "2500", "interactive": false}