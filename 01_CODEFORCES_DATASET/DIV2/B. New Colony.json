{
    "link": "https://codeforces.com//contest/1481/problem/B",
    "problemId": "888832",
    "problem_idx": "B",
    "shortId": "1481B",
    "contest_number": "1481",
    "problem_submissions": {
        "E": [
            106575657,
            106580122,
            106571072,
            106587922,
            106596561,
            106601300,
            106598150,
            106588203,
            106555230,
            106601691,
            106603323,
            106598805,
            106606116,
            106598692,
            106597406,
            106601560,
            106559099,
            106600288,
            106602866
        ],
        "D": [
            106568002,
            106573123,
            106565784,
            106576955,
            106573210,
            106578133,
            106576417,
            106596842,
            106581404,
            106583159,
            106580270,
            106581784,
            106581178,
            106589786,
            106588485,
            106598470,
            106585012,
            106578937,
            106593218
        ],
        "C": [
            106554240,
            106561563,
            106587826,
            106564449,
            106557128,
            106554455,
            106561081,
            106556949,
            106593975,
            106567836,
            106563207,
            106566579,
            106560187,
            106560571,
            106563380,
            106553575,
            106571925,
            106575164,
            106574000
        ],
        "B": [
            106545453,
            106545635,
            106575045,
            106557114,
            106546143,
            106544431,
            106547512,
            106547628,
            106600777,
            106555535,
            106546768,
            106552994,
            106545917,
            106549686,
            106553008,
            106544154,
            106594934,
            106546830,
            106553782
        ],
        "A": [
            106540084,
            106539696,
            106539972,
            106539768,
            106541130,
            106540757,
            106539872,
            106540973,
            106602935,
            106540095,
            106541018,
            106540813,
            106540248,
            106541459,
            106539556,
            106539597,
            106547797,
            106540934,
            106542940
        ],
        "F": [
            106632220,
            111955794,
            218518749,
            218505572
        ]
    },
    "name": "B. New Colony",
    "statement": "After reaching your destination, you want to build a new colony on the\r\nnew planet. Since this planet has many mountains and the colony must be\r\nbuilt on a flat surface you decided to flatten the mountains using\r\nboulders (you are still dreaming so this makes sense to you). You are\r\ngiven an array h_1, h_2,\r\ndots, h_n, where h_i is the height of the i-th mountain, and k the\r\nnumber of boulders you have.You will start throwing boulders from the\r\ntop of the first mountain one by one and they will roll as follows\r\n(letâ€™s assume that the height of the current mountain is h_i): if h_i\r\nge h_{i + 1}, the boulder will roll to the next mountain; if h_i <\r\nh_{i + 1}, the boulder will stop rolling and increase the mountain\r\nheight by 1 (h_i = h_i + 1); if the boulder reaches the last mountain it\r\nwill fall to the waste collection system and disappear. You want to find\r\nthe position of the k-th boulder or determine that it will fall into the\r\nwaste collection system.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint h[100009];\nmain(){\n    int t;\n    cin >> t;\n    while(t--){\n        int n, k;\n        cin >> n >> k;\n        for(int i = 1; i <= n; i++){\n            cin >> h[i];\n        }\n        int ans;\n        while(k--){\n            int i;\n            for(i = 1; i < n; i++){\n                if(h[i] < h[i+1]) break;\n            }\n            ans = i; h[i]++;\n            if(i == n) break;\n        }\n        if(ans == n) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. New Colony.json",
    "editorial_link": "https://codeforces.com//blog/entry/87523",
    "editorial": "The two key observation here is that if one boulder fall into the\r\ncollection system all later boulders will fall into the collection\r\nsystem too and the number of boulders that will end up at any mountain\r\nis too small (Hence it will be at most ).So we can simulate all boulders\r\nthrowing until one boulder fall into the collection system, this will\r\ntake at most .\r\n",
    "hint": []
}