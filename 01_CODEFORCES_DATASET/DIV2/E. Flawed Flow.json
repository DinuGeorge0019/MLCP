{
    "link": "https://codeforces.com//contest/270/problem/E",
    "problemId": "2576",
    "problem_idx": "E",
    "shortId": "270E",
    "contest_number": "270",
    "problem_submissions": {
        "E": [
            3056054,
            3058059,
            3068984,
            3080996
        ],
        "D": [
            3050127,
            3055561,
            3050397,
            3049548,
            3052822,
            3053009,
            3054445,
            3053861,
            3054191,
            3055863,
            3055631,
            3055839,
            3055560,
            3054894,
            3056305,
            3055011,
            3055694,
            3057529
        ],
        "B": [
            3048641,
            3045871,
            3045836,
            3047541,
            3048502,
            3048657,
            3047926,
            3048630,
            3048541,
            3047300,
            3048508,
            3046687,
            3050138,
            3050574,
            3048964,
            3050600,
            3048557,
            3052052
        ],
        "C": [
            3047282,
            3051469,
            3048138,
            3054706,
            3050612,
            3051213,
            3050203,
            3052136,
            3050827,
            3049962,
            3053006,
            3051668,
            3051745,
            3053806,
            3052573,
            3052416,
            3053557,
            3053872,
            3049732
        ],
        "A": [
            3045411,
            3045427,
            3045431,
            3045729,
            3045456,
            3045883,
            3045584,
            3046227,
            3045772,
            3045573,
            3046141,
            3045605,
            3046597,
            3045891,
            3046067,
            3045859,
            3045602,
            3045847
        ]
    },
    "name": "E. Flawed Flow",
    "statement": "Emuskald considers himself a master of flow algorithms. Now he has\r\ncompleted his most ingenious program yet it calculates the maximum flow\r\nin an undirected graph. The graph consists of vertices and edges.\r\nVertices are numbered from 1 to . Vertices and being the source and the\r\nsink respectively.However, his max-flow algorithm seems to have a little\r\nflaw it only finds the flow volume for each edge, but not its direction.\r\nHelp him find for each edge the direction of the flow through this\r\nedges. Note, that the resulting flow should be correct maximum flow.More\r\nformally. You are given an undirected graph. For each it\u2019s undirected\r\nedge (, ) you are given the flow volume . You should direct all edges in\r\nsuch way that the following conditions hold: for each vertex , sum of of\r\nincoming edges is equal to the sum of of outcoming edges; vertex with\r\nnumber has no incoming edges; the obtained directed graph .\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define fr(i,n) for(int i=0;i<n;i++)\n#define fo(i,n) for(int i=1;i<=n;i++)\n#define fe(i,n) for(__typeof(n.begin()) i=n.begin();i!=n.end();i++)\ntypedef long long ll;\nll a1[400020],a0[400020],h[400020],tot = 0, a2[400020];\nvoid add(ll b,ll e,ll cc)\n{\n\ta1[++tot]=e;\n\ta0[tot]=h[b];\n\th[b]=tot;\n\ta2[tot]=a2[tot+1]=cc;\n\ta1[++tot]=b;\n\ta0[tot]=h[e];\n\th[e]=tot;\n}\nll d[400020],q[400020],ans[400020],n,m;\nbool v[400020];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y,z; \n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadd(x,y,z);\n\t\td[x]+=z;\n\t\td[y]+=z;\n\t}\n\tll b=0,f=0;\n\tq[f++]=1;\n\tv[1]=1;\n\twhile(b<f)\n\t{\n\t\tll u=q[b++];\n\t\tfor(ll i=h[u];i;i=a0[i])\n\t\t\tif(!v[a1[i]])\n\t\t\t\t{\n\t\t\t\t\td[a1[i]]-=a2[i]*2;\n\t\t\t\t\tans[(i-1)/2]=1-(i&1);\n\t\t\t\t\tif(d[a1[i]]==0&&a1[i]!=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tv[a1[i]]=1;\n\t\t\t\t\t\tq[f++]=a1[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tfor(int i=0;i<m;i++)\n\t\tprintf(\"%d\\n\",(int)ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Flawed Flow.json",
    "editorial_link": "https://codeforces.com//blog/entry/6596",
    "editorial": "Problem\nIn this problem we are given an undirected graph and its flow, and we must reconstruct the edge directions of this flow.\n\nSolution\nThe key element to solving the task is the following observation: if we know all the incoming edges of a vertex, all the remaining edges must be outgoing. The source has no incoming edges, so we already know that all its edges are outgoing. For all other vertices except the sink the amount of incoming and outcoming flow is the same, and is equal to half of the sum of the flow along its incident edges. The algorithm then is to repeatedly direct all the flow from the vertices for which all the incoming edges are known. This can be done with a single BFS:\nAs the flow contains no cycles, we can sort the vertices topologically. Then we can be sure that, until all edge directions are known, we can put at least the first vertex with unknown edges in the queue, as all of its incoming edges will be from vertices with lower indices, but we took the first vertex with unknown edges."
}