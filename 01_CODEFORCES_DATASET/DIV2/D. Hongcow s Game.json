{
    "link": "https://codeforces.com//contest/745/problem/D",
    "problemId": "85237",
    "problem_idx": "D",
    "shortId": "745D",
    "contest_number": "745",
    "problem_submissions": {
        "D": [
            23063628,
            23061434,
            23062278,
            23062946,
            23063952,
            23062953,
            23063684,
            23065227,
            23067508,
            23064054,
            23066325,
            23064778,
            23065417,
            23065640,
            23065940,
            23064035,
            23066189,
            23064933,
            23065850
        ],
        "C": [
            23058754,
            23056208,
            23058146,
            23057537,
            23056194,
            23058075,
            23057431,
            23056700,
            23056696,
            23059037,
            23057208,
            23057100,
            23059888,
            23057785,
            23058711,
            23057786,
            23057804,
            23058775,
            23060465,
            23060269
        ],
        "B": [
            23054534,
            23053936,
            23055906,
            23053616,
            23057561,
            59539483,
            23055581,
            23054327,
            23058797,
            23055722,
            23054071,
            23052962,
            23055965,
            23054973,
            23055010,
            23060679,
            23060284,
            23055704,
            23055472,
            23055306
        ],
        "A": [
            23052643,
            23052117,
            23054108,
            23052198,
            23052470,
            23052835,
            23052386,
            23052148,
            23052356,
            23052891,
            23052103,
            23052050,
            23052345,
            23052453,
            23052723,
            23054138,
            23052447,
            23052434
        ],
        "E": [
            23177019,
            25241753,
            23067030,
            23140409
        ]
    },
    "name": "D. Hongcow s Game",
    "statement": "In this problem, you will be playing a game with Hongcow. How lucky of\r\nyou!Hongcow has a hidden by matrix . Let denote the entry -th row and\r\n-th column of the matrix. The rows and columns are labeled from to .The\r\nmatrix entries are between and . In addition, for all valid . Your task\r\nis to find the minimum value along each row, excluding diagonal\r\nelements. Formally, for each , you must find .To do this, you can ask\r\nHongcow some questions.A question consists of giving Hongcow a subset of\r\ndistinct indices , with . Hongcow will respond with integers. The -th\r\ninteger will contain the minimum value of .You may only ask Hongcow at\r\nmost questions he thinks you only need that many questions answered.When\r\nyou are ready to answer, print out a single integer on its own line,\r\nthen integers on the next line. The -th integer should be the minimum\r\nvalue in the -th row of the matrix, excluding the -th element. Do not\r\nforget to flush the final answer as well. Printing the answer does not\r\ncount as asking a question.You will get verdict if Your question or\r\nanswers are not in the format described in this statement. You ask\r\nstrictly more than questions. Your question contains duplicate indices.\r\nThe value of in your question does not lie in the range from to ,\r\ninclusive. Your final answer is not correct. You will get if you don\u2019t\r\nprint anything or if you forget to flush the output, including for the\r\nfinal answer (more info about flushing output below).\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define FORU(i,j,k) for(int i=(j);i<=(k);++i)\n#define FORD(i,j,k) for(int i=(j);i>=(k);--i)\n\nusing namespace std;\n\nusing lli = long long int;\nusing pll = pair<lli, lli>;\n\nconst long long int oo = 1000*1000*1000;\n\nstruct Coord\n{\n\tint x, y;\n\tCoord(int x = 0, int y = 0) : x(x), y(y) {}\n\tCoord operator + (const Coord& droite) const\n\t{\n\t\treturn Coord(x + droite.x, y + droite.y);\n\t}\n};\n\nint dicho[1042][10][2];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR(k, n)\n\t\tFOR(i, 10)\n\t\t\tFOR(j, 2)\n\t\t\t\tdicho[k][i][j] = oo;\n\tint low = 1;\n\twhile((1 << low) <= n)\n\t\t++low;\n\tFOR(i, low)\n\t\tFOR(j, 2)\n\t\t{\n\t\t\tvector<int> req;\n\t\t\tFOR(k, n)\n\t\t\t\tif((bool)((1 << i) & k) == j)\n\t\t\t\t\treq.push_back(k);\n\t\t\tif(req.size())\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", req.size());\n\t\t\t\tfor(auto k : req)\n\t\t\t\t\tprintf(\"%d \", k+1);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tfflush(stdout);\n\t\t\t\tFOR(k, n)\n\t\t\t\t\tscanf(\"%d\", &dicho[k][i][j]);\n\t\t\t}\n\t\t}\n\tprintf(\"-1\\n\");\n\t//FOR(k, n)\n\t//{\n\t//\tprintf(\"LINE %d:\\n\", k);\n\t//\tFOR(i, low)\n\t//\t{\n\t//\t\tprintf(\"BIT %d: \", i);\n\t//\t\tFOR(j, 2)\n\t//\t\t\tprintf(\" %d\", dicho[k][i][j]);\n\t//\t\tprintf(\"\\n\");\n\t//\t}\n\t//\tprintf(\"\\n\");\n\t//}\n\tFOR(i, n)\n\t{\n\t\tint mini = oo;\n\t\tFOR(j, low)\n\t\t\tmini = min(mini, dicho[i][j][1 - (bool)((1 << j) & i)]);\n\t\tprintf(\"%d \", mini);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "divide and conquer",
        "interactive"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Hongcow s Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/49126",
    "editorial": "For the bits solution: We want to create 20 questions where for every i != j, there exists a question\n\nthat contains j and not i, and also a qusetion that contains i and not j. If we can do this, we can find the min for each row.\n\nNote that i != j implies that there exists a bit index where i and j differ.\n\nSo, let's ask 2 questions for each bit position, one where all indices have a value of 0 in that position, and one where all indices have a value of 1 in that position. This is a total of at most 20 questions, and we can show that this satisfies the condition above, so this solves the problem.\n\nParallelization will basically reduce to the above solution, but is another way of looking at the problem.\n\nFirst, let's ask {1,2,...,n/2} and {n/2+1,...,n} This handles the case where the min lies on the opposite half.\n\n[\nOOOOXXXX\nOOOOXXXX\nOOOOXXXX\nOOOOXXXX\nXXXXOOOO\nXXXXOOOO\nXXXXOOOO\nXXXXOOOO\n]\nFor example, this handles the case where the min lies in the X part of the matrix, and we split it into two identical problems of size n/2 within the O matrix.\n\nNow, we can ask questions for each submatrix, but we can notice that these two don't interact so we can combine all the questions at this level.\n\nHowever, we should ask the questions in parallel, as we don't have that many questions For example, for n=8, we should ask"
}