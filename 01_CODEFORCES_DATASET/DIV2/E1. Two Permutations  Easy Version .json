{
    "link": "https://codeforces.com//contest/1882/problem/E1",
    "problemId": "2227518",
    "problem_idx": "E1",
    "shortId": "1882E1",
    "contest_number": "1882",
    "problem_submissions": {
        "E2": [
            225204189,
            225160002,
            225202768,
            225477016,
            225476880,
            225475232,
            225472626
        ],
        "E1": [
            225123936,
            225133746,
            225140131,
            225133665,
            225132240,
            225138063,
            225142760,
            225139602,
            225142422,
            225147512,
            225146106,
            225142740,
            225141291,
            225138856,
            225144845,
            225148151,
            225478094,
            225148992,
            225162295,
            225152100,
            225152337,
            225148869
        ],
        "D": [
            225106356,
            225113280,
            225112999,
            225122785,
            225103764,
            225119012,
            225120043,
            225120508,
            225110063,
            225117734,
            225117249,
            225125156,
            225114397,
            225121683,
            225123705,
            225117693,
            225627016,
            225115870,
            225118591,
            225116324,
            225122541
        ],
        "C": [
            225101844,
            225106102,
            225108446,
            225110739,
            225110971,
            225110665,
            225111630,
            225111292,
            225113490,
            225109057,
            225111482,
            225110667,
            225107121,
            225115756,
            225110831,
            225108821,
            225109177,
            225108521,
            225104527,
            225107759
        ],
        "B": [
            225097300,
            225100132,
            225102630,
            225101761,
            225116077,
            225104479,
            225103013,
            225101827,
            225105709,
            225102804,
            225106906,
            225101186,
            225121302,
            225101604,
            225099036,
            225100746,
            225104002,
            225103297,
            225100386,
            225100570
        ],
        "A": [
            225093910,
            225094018,
            225094163,
            225094069,
            225115330,
            225094938,
            225094567,
            225094063,
            225094790,
            225097756,
            225096481,
            225094301,
            225094479,
            225093976,
            225093977,
            225093952,
            225104147,
            225094178,
            225095571,
            225096872
        ]
    },
    "name": "E1. Two Permutations  Easy Version ",
    "statement": "You have two permutations^{\r\ndagger} p_{1}, p_{2},\r\nldots, p_{n} (of integers 1 to n) and q_{1}, q_{2},\r\nldots, q_{m} (of integers 1 to m). Initially p_{i}=a_{i} for i=1, 2,\r\nldots, n, and q_{j} = b_{j} for j = 1, 2,\r\nldots, m. You can apply the following operation on the permutations\r\nseveral (possibly, zero) times.In one operation, p and q will change\r\naccording to the following three steps: You choose integers i, j which\r\nsatisfy 1\r\nle i\r\nle n and 1\r\nle j\r\nle m. Permutation p is partitioned into three parts using p_i as a\r\npivot: the left part is formed by elements p_1, p_2,\r\nldots, p_{i-1} (this part may be empty), the middle part is the single\r\nelement p_i, and the right part is p_{i+1}, p_{i+2},\r\nldots, p_n (this part may be empty). To proceed, swap the left and the\r\nright parts of this partition. Formally, after this step, p will become\r\np_{i+1}, p_{i+2},\r\nldots, p_{n}, p_{i}, p_{1}, p_{2},\r\nldots, p_{i-1}. The elements of the newly formed p will be reindexed\r\nstarting from 1. Perform the same transformation on q with index j.\r\nFormally, after this step, q will become q_{j+1}, q_{j+2},\r\nldots, q_{m}, q_{j}, q_{1}, q_{2},\r\nldots, q_{j-1}. The elements of the newly formed q will be reindexed\r\nstarting from 1. Your goal is to simultaneously make p_{i}=i for i=1, 2,\r\nldots, n, and q_{j} = j for j = 1, 2,\r\nldots, m.Find any valid way to achieve the goal using at most 10\r\n,000 operations, or say that none exists. Please note that you minimize\r\nthe number of operations.It can be proved that if it is possible to\r\nachieve the goal, then there exists a way to do so using at most 10\r\n,000 operations.^{\r\ndagger} A permutation of length k is an array consisting of k distinct\r\nintegers from 1 to k in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (k=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T;\nint a[maxn],b[maxn],c[maxn],d[maxn];\nvector<int>ans[2];\nvector< pair<int,int> >res;\nvoid opt(int n,int p,int o){\n\tint ds=0;\n\tans[o].emplace_back(p);\n\tfor(int i=p+1;i<=n;i++)\n\t\td[++ds]=c[i];\n\td[++ds]=c[p];\n\tfor(int i=1;i<=p-1;i++)\n\t\td[++ds]=c[i];\n\tfor(int i=1;i<=n;i++)\n\t\tc[i]=d[i];\n}\nvoid solve(int n,int o){\n//\tfor(int i=1;i<=n;i++)\n//\t\tprintf(\"%d%c\",c[i],i==n? '\\n':' ');\n\tfor(int p=n;p>=1;p--){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(c[i]==p){\n\t\t\t\topt(n,i,o);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(c[i]==p){\n\t\t\t\tif(i>1)\n\t\t\t\t\topt(n,i-1,o);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++)\n//\t\tprintf(\"%d%c\",c[i],i==n? '\\n':' ');\n//\tfor(int i=0;i<ans[o].size();i++)\n//\t\tprintf(\"%d%c\",ans[o][i],i==ans[o].size()-1? '\\n':' ');\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tmemcpy(c,a,sizeof(c)),solve(n,0),memcpy(c,b,sizeof(c)),solve(m,1);\n\tif((ans[0].size()&1)!=(ans[1].size()&1)&&(n&1)==1)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[0].emplace_back(1);\n\tif((ans[0].size()&1)!=(ans[1].size()&1)&&(m&1)==1)\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tans[1].emplace_back(1);\n\tif((ans[0].size()&1)!=(ans[1].size()&1)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tres.resize(max(ans[0].size(),ans[1].size()));\n\tfor(int i=0,p=0,q=0;i<res.size();i++){\n\t\tint u,v;\n\t\tif(i<ans[0].size())\n\t\t\tu=ans[0][i];\n\t\telse u=p==0? 1:n,p^=1;\n\t\tif(i<ans[1].size())\n\t\t\tv=ans[1][i];\n\t\telse v=q==0? 1:m,q^=1;\n\t\tres[i]=make_pair(u,v);\n\t}\n\tprintf(\"%d\\n\",res.size());\n\tfor(int i=0;i<res.size();i++)\n\t\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\t/*memcpy(c,a,sizeof(c));\n\tfor(int i=0;i<res.size();i++)\n\t\topt(n,res[i].first,0);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d%c\",c[i],i==n? '\\n':' '),assert(c[i]==i);\n\tmemcpy(c,b,sizeof(c));\n\tfor(int i=0;i<res.size();i++)\n\t\topt(m,res[i].second,1);\n\tfor(int i=1;i<=m;i++)\n\t\tprintf(\"%d%c\",c[i],i==m? '\\n':' '),assert(c[i]==i);*/\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Two Permutations  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/120792",
    "editorial": "TutorialAdd an extra character â in front of the permutation. Here\r\nposition of wonât be changed by the operation, and will always locate at\r\nleft of . Then in each operation, the permutation will change as: .Now,\r\nletâs consider the array made by and permutation as circular. This is\r\npossible because is always in left of st element, so it marks the start\r\nof the permutation. Then is equivalent with .Then the operation is: ,\r\nwhich is same with swapping and .Now we need to calculate the minimum\r\nodd number of swaps and even number of swaps(of and any element) each,\r\nturning to one of , , , , .To calculate the minimum number of swaps\r\nrequired to turn to the given array, first renumber the initial array to\r\n, then change the given array in the same correspondence. Do permutation\r\ncycle decomposition. Then the answer is (sum of (size + 1) for cycles\r\nwhich have size 2 and donât contain ) + (âs cycle size 1). This can be\r\nproven easily by counting the number of elements which go into the\r\nproper place in each operations.Calculate this for all , , , , . Since\r\nwe canât make the same array using different parity of number of swaps,\r\nwe can achieve the goal by calculating the minimum odd number and\r\nminimum even number each.The overall time complexity is .\r\n",
    "hint": [
        "Hint 1 Let's think two permutations independently. The goal is to make sequence of operations for each permutation which have same parity of number of operations.",
        "Hint 2 Try to sort single permutation of length , using at most operations. It is always possible.",
        "Hint 3 If the permutation's length is odd, you can perform operation at index for times and return to the same permutation.",
        "Hint 4 If the permutation's length is even, the parity of inversion number changes in each operations."
    ]
}