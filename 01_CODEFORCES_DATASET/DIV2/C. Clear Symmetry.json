{"link": "https://codeforces.com//contest/202/problem/C", "problemId": "1462", "problem_idx": "C", "shortId": "202C", "contest_number": "202", "problem_submissions": {"D": [1844313, 1842311, 1841979, 1843395, 1842912, 1842950, 1842562, 1842138, 1840497, 1843444, 1843135], "E": [1843349, 1841002, 1841817, 1843089], "C": [1841155, 1839729, 1840113, 1840755, 1841271, 1841797, 1841819, 1842476, 1840829, 1842962, 1840554, 1841522, 1842232, 1841398, 1840867], "B": [1840403, 1843403, 1840044, 1839954, 1840486, 1839533, 1840191, 1840994, 1839874, 1842121], "A": [1838706, 1838919, 1839372, 1838770, 1838876, 1838669, 1839147, 1841443, 1839411, 1838689, 1838642, 1838754, 1838807, 1838635, 1838833, 1838650]}, "name": "C. Clear Symmetry", "statement": "Consider some square matrix with side consisting of zeros and ones.\r\nThere are rows numbered from to from top to bottom and columns numbered\r\nfrom to from left to right in this matrix. We\u2019ll denote the element of\r\nthe matrix which is located at the intersection of the -row and the -th\r\ncolumn as .Let\u2019s call matrix if no two cells containing ones have a\r\ncommon side.Let\u2019s call matrix if it matches the matrices formed from it\r\nby a horizontal and/or a vertical reflection. Formally, for each pair\r\nboth of the following conditions must be met: and .Let\u2019s define the of\r\nmatrix as the number of ones in it.Given integer , your task is to find\r\nthe smallest positive integer such that there exists a clear symmetrical\r\nmatrix with side and sharpness .\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#ifndef LEEWINGS_DEBUG\n#define LEEWINGS_DEBUG 0\n#endif\n\n#define debug(x) if (LEEWINGS_DEBUG) cerr << #x << \" = \" << (x) << endl\n\n#define debug_line(a, n) do {                                                \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << \"[\" << #n << \"]:\" << endl;                             \\\n        for (int i = 0; i < (n); i++) cerr << (a)[i] << \" \";                 \\\n        cerr << endl;                                                        \\\n    }                                                                        \\\n} while (0)\n\n#define debug_mat(a, n, m) do {                                              \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << \"[\" << #n << \"][\" << #m \"]:\" << endl;                  \\\n        for (int i = 0; i < (n); i++) {                                      \\\n            for (int j = 0; j < (m); j++) cerr << (a)[i][j] << \" \";          \\\n            cerr << endl;                                                    \\\n        }                                                                    \\\n    }                                                                        \\\n} while(0)\n\ntypedef pair<int, int> pii;\ntypedef vector<int>::const_iterator vci;\ntypedef map<int, int>::const_iterator mci;\n\nconst int INF = 0x3f3f3f3f;\nconst long long LLINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1.0/0.0f;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n\ninline int LC(int x) { return x << 1; }\ninline int RC(int x) { return (x << 1) | 1; }\ninline bool eq0(double x) { return fabs(x) < eps; }\ninline bool eq(double x, double y) { return fabs(x - y) < eps; }\ninline bool ls(double x, double y) { return x + eps < y; }\ninline bool gr(double x, double y) { return x - eps > y; }\ninline bool greq(double x, double y) { return x + eps >= y; }\ninline bool lseq(double x, double y) { return x - eps <= y; }\ninline double fmax(double x, double y) { return gr(x, y) ? x : y; }\ninline double fmin(double x, double y) { return ls(x, y) ? x : y; }\n\ntemplate<class T> inline T sqr(T x) { return x * x; }\n\nint main()\n{\n    int n;\n    while (cin >> n) {\n        if (n == 3) cout << 5 << endl;\n        else {\n            for (int i = 1; ; i += 2) {\n                if ((i * i + 1) >> 1 >= n) {\n                    cout << i << endl;\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "math"], "dificulty": "1700", "interactive": false}