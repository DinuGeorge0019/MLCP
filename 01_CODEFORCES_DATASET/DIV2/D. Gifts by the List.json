{"link": "https://codeforces.com//contest/681/problem/D", "problemId": "62560", "problem_idx": "D", "shortId": "681D", "contest_number": "681", "problem_submissions": {"E": [18473617, 18479418], "D": [18465030, 18465518, 18465862, 18467403, 18466936, 18467028, 18466296, 18466578, 18464030, 18470842, 18472466, 18467659, 18469382, 18468431, 18468146, 18474068, 18472044, 18469596, 18470424], "C": [18461194, 18461464, 18461743, 18461928, 18464405, 18461875, 18462398, 18461641, 18467308, 18461870, 18461760, 18464265, 18463730, 18463224, 18460036, 18461042, 18464863, 18463886, 18462766], "B": [18458177, 18458124, 18456973, 18457752, 18459469, 18459156, 18458143, 18457120, 18457840, 18462206, 18457571, 18458202, 18457782, 18458846, 18457327, 18456130, 18460750, 18458949, 18458321], "A": [18456291, 18456107, 18458037, 18456137, 18457389, 18456748, 18456511, 18456015, 18456218, 18456056, 18455988, 18456198, 18456050, 18456723, 18456074, 18457095, 18458719, 18456145, 18456265]}, "name": "D. Gifts by the List", "statement": "Sasha lives in a big happy family. At the Man\u2019s Day all the men of the\r\nfamily gather to celebrate it following their own traditions. There are\r\nmen in Sasha\u2019s family, so let\u2019s number them with integers from to .Each\r\nman has at most one father but may have arbitrary number of sons.Man\r\nnumber is considered to be the of the man number if at least one of the\r\nfollowing conditions is satisfied: ; the man number is the father of the\r\nman number ; there is a man number , such that the man number is his\r\nancestor and the man number is the father of the man number . Of course,\r\nif the man number is an ancestor of the man number and , then the man\r\nnumber is not an ancestor of the man number .The tradition of the\r\nSasha\u2019s family is to give gifts at the Man\u2019s Day. Because giving gifts\r\nin a normal way is boring, each year the following happens. A list of\r\ncandidates is prepared, containing some (possibly all) of the men in\r\nsome order. Each of the men decides to give a gift. In order to choose a\r\nperson to give a gift to, man looks through the list and picks the first\r\nman in the list, such that is an ancestor of and gives him a gift. Note\r\nthat according to definition it may happen that a person gives a gift to\r\nhimself. If there is no ancestor of a person in the list, he becomes sad\r\nand leaves the celebration without giving a gift to anyone. This year\r\nyou have decided to help in organizing celebration and asked each of the\r\nmen, who do they want to give presents to (this person is chosen only\r\namong ancestors). Are you able to make a list of candidates, such that\r\nall the wishes will be satisfied if they give gifts according to the\r\nprocess described above?\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 120000;\n\n\nint n, m;\nint gfl;\nint p[MAXN];\nvector<int> eds[MAXN];\nint g[MAXN];\nint tin[MAXN];\nint tm2;\nint fl[MAXN];\n\nvoid dfs(int v) {\n\ttin[v] = tm2++;\n\tfor (int u: eds[v])\n\t\tdfs(u);\n}\n\n\nvoid dfs2(int v, int now) {\n\tif (fl[v])\n\t\tnow = v;\n\tif (now != g[v]) {\n\t\tgfl = 1;\n\t}\n\tfor (int i: eds[v])\n\t\tdfs2(i, now);\n}\n\n\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; ++i)\n\t\tp[i] = -1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a;\n\t\t--b;\n\t\tp[b] = a;\n\t\teds[a].push_back(b);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", g + i), --g[i];\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (p[i] == -1)\n\t\t\tdfs(i);\n\n\tvector<pair<int, int> > vv;\n\tfor (int i = 0; i < n; ++i) {\n\t\tvv.push_back(make_pair(tin[g[i]], g[i]));\n\t}\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\n\treverse(vv.begin(), vv.end());\n\tfor (int i = 0; i < (int)vv.size(); ++i)\n\t\tfl[vv[i].second] = 1;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (p[i] == -1)\n\t\t\tdfs2(i, -1);\n\t}\n\tif (gfl) {\n\t\tprintf(\"-1\\n\");\n\t}\n\telse {\n\t\tprintf(\"%d\\n\", (int)vv.size());\n\t\tfor (auto i: vv)\n\t\t\tprintf(\"%d\\n\", i.second + 1);\n\t}\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "trees"], "dificulty": "2000", "interactive": false}