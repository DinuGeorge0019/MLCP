{
    "link": "https://codeforces.com//contest/681/problem/D",
    "problemId": "62560",
    "problem_idx": "D",
    "shortId": "681D",
    "contest_number": "681",
    "problem_submissions": {
        "E": [
            18473617,
            18479418
        ],
        "D": [
            18465030,
            18465518,
            18465862,
            18467403,
            18466936,
            18467028,
            18466296,
            18466578,
            18464030,
            18470842,
            18472466,
            18467659,
            18469382,
            18468431,
            18468146,
            18474068,
            18472044,
            18469596,
            18470424
        ],
        "C": [
            18461194,
            18461464,
            18461743,
            18461928,
            18464405,
            18461875,
            18462398,
            18461641,
            18467308,
            18461870,
            18461760,
            18464265,
            18463730,
            18463224,
            18460036,
            18461042,
            18464863,
            18463886,
            18462766
        ],
        "B": [
            18458177,
            18458124,
            18456973,
            18457752,
            18459469,
            18459156,
            18458143,
            18457120,
            18457840,
            18462206,
            18457571,
            18458202,
            18457782,
            18458846,
            18457327,
            18456130,
            18460750,
            18458949,
            18458321
        ],
        "A": [
            18456291,
            18456107,
            18458037,
            18456137,
            18457389,
            18456748,
            18456511,
            18456015,
            18456218,
            18456056,
            18455988,
            18456198,
            18456050,
            18456723,
            18456074,
            18457095,
            18458719,
            18456145,
            18456265
        ]
    },
    "name": "D. Gifts by the List",
    "statement": "Sasha lives in a big happy family. At the Man’s Day all the men of the\r\nfamily gather to celebrate it following their own traditions. There are\r\nmen in Sasha’s family, so let’s number them with integers from to .Each\r\nman has at most one father but may have arbitrary number of sons.Man\r\nnumber is considered to be the of the man number if at least one of the\r\nfollowing conditions is satisfied: ; the man number is the father of the\r\nman number ; there is a man number , such that the man number is his\r\nancestor and the man number is the father of the man number . Of course,\r\nif the man number is an ancestor of the man number and , then the man\r\nnumber is not an ancestor of the man number .The tradition of the\r\nSasha’s family is to give gifts at the Man’s Day. Because giving gifts\r\nin a normal way is boring, each year the following happens. A list of\r\ncandidates is prepared, containing some (possibly all) of the men in\r\nsome order. Each of the men decides to give a gift. In order to choose a\r\nperson to give a gift to, man looks through the list and picks the first\r\nman in the list, such that is an ancestor of and gives him a gift. Note\r\nthat according to definition it may happen that a person gives a gift to\r\nhimself. If there is no ancestor of a person in the list, he becomes sad\r\nand leaves the celebration without giving a gift to anyone. This year\r\nyou have decided to help in organizing celebration and asked each of the\r\nmen, who do they want to give presents to (this person is chosen only\r\namong ancestors). Are you able to make a list of candidates, such that\r\nall the wishes will be satisfied if they give gifts according to the\r\nprocess described above?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 120000;\n\n\nint n, m;\nint gfl;\nint p[MAXN];\nvector<int> eds[MAXN];\nint g[MAXN];\nint tin[MAXN];\nint tm2;\nint fl[MAXN];\n\nvoid dfs(int v) {\n\ttin[v] = tm2++;\n\tfor (int u: eds[v])\n\t\tdfs(u);\n}\n\n\nvoid dfs2(int v, int now) {\n\tif (fl[v])\n\t\tnow = v;\n\tif (now != g[v]) {\n\t\tgfl = 1;\n\t}\n\tfor (int i: eds[v])\n\t\tdfs2(i, now);\n}\n\n\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; ++i)\n\t\tp[i] = -1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a;\n\t\t--b;\n\t\tp[b] = a;\n\t\teds[a].push_back(b);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", g + i), --g[i];\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (p[i] == -1)\n\t\t\tdfs(i);\n\n\tvector<pair<int, int> > vv;\n\tfor (int i = 0; i < n; ++i) {\n\t\tvv.push_back(make_pair(tin[g[i]], g[i]));\n\t}\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\n\treverse(vv.begin(), vv.end());\n\tfor (int i = 0; i < (int)vv.size(); ++i)\n\t\tfl[vv[i].second] = 1;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (p[i] == -1)\n\t\t\tdfs2(i, -1);\n\t}\n\tif (gfl) {\n\t\tprintf(\"-1\\n\");\n\t}\n\telse {\n\t\tprintf(\"%d\\n\", (int)vv.size());\n\t\tfor (auto i: vv)\n\t\t\tprintf(\"%d\\n\", i.second + 1);\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Gifts by the List.json",
    "editorial_link": "https://codeforces.com//blog/entry/45425",
    "editorial": "Formal statement of the problem: You have a directed acyclic graph,\r\nevery vertex has at most one ingoing edge. Vertex is an ancestor of\r\nvertex if there is a path from to in graph. Also every vertex is an\r\nancestor of itself. Every vertex has a pair vertex , ancestor of . You\r\nneed to build such sequence of vertex, that for every vertex the\r\nleftmost vertex in the sequence which is ancestor of must be equal to .\r\nOr you need to tell, that such sequence does not exists. Solution:\r\nAssume sequence , which contains every vertex from sequence by once and\r\nonly them. Letâs order elements of this sequence in such way, that for\r\nevery and if ancestor of , then . If this sequecne is the answer, then\r\nprint it. Otherwise, there is no answer. Why? If some vertex from\r\nsequence in not present in , then a man, who needs to give a gift to a\r\nman number , will not be able to do it. So every vertex must have place\r\nin the resulting sequence. If ancestor of and , then a man, who needs to\r\ngive a gift to a man number will not be able to do it. How can we build\r\nthis sequence? Letâs sort vertices topologically, than reverse it and\r\nremove redundant vertices. Now we need to check if that this sequence\r\ncan be the answer. Letâs calculate to whom every man will give his gift.\r\nAt start for any man we donât know that. Letâs iterate through vertices\r\nof the resulting sequence. For every vertex (man) from current vertex\r\nsubtree (i.e. for vertices whose ancestor is current vertex) such that\r\nwe still donât know whom will this vertex (man) give a gift to, stays\r\nthat these vertices would give a gift to current vertex, because it is\r\ntheir first ancestor in the list. Iterate through that vertices (men) in\r\ndfs order and remember for them, to whom they will give their gift.\r\nAfter we apply this operation to all vertices from resulting sequence,\r\ncompare for each man to whom he will give his gift and to whom he needs\r\nto give his gift. If there is at least one mismatch, then the answer\r\ndoesnât exist. Code\r\n",
    "hint": []
}