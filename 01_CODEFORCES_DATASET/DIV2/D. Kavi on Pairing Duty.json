{
    "link": "https://codeforces.com//contest/1529/problem/D",
    "problemId": "994171",
    "problem_idx": "D",
    "shortId": "1529D",
    "contest_number": "1529",
    "problem_submissions": {
        "E": [
            117241256,
            117224077,
            117234541,
            117233577,
            117569320,
            117237517,
            117242490,
            117246187,
            117240165,
            117245259,
            117241507,
            117250798,
            117245729,
            117250742,
            117250857,
            117218644
        ],
        "D": [
            117230306,
            117212621,
            117202664,
            117207279,
            117225346,
            117220644,
            117216468,
            117216196,
            117213173,
            117222042,
            117220584,
            117225498,
            117227881,
            117216922,
            117220354,
            117229060,
            117222399,
            117222507,
            117238884
        ],
        "C": [
            117214605,
            117199641,
            117194393,
            117203572,
            117194679,
            117202937,
            117207535,
            117193168,
            117200629,
            117205705,
            117207405,
            117200109,
            117211977,
            117207102,
            117207383,
            117205160,
            117202511,
            117210501,
            117233461
        ],
        "B": [
            117211463,
            117191644,
            117208208,
            117195752,
            117203773,
            117196989,
            117200392,
            117204712,
            117192618,
            117194128,
            117187965,
            117194040,
            117204576,
            117200157,
            117198432,
            117201536,
            117194899,
            117196661,
            117225707
        ],
        "A": [
            117204278,
            117182610,
            117191375,
            117182552,
            117181735,
            117183060,
            117186706,
            117181614,
            117182779,
            117184006,
            117181468,
            117181785,
            117189122,
            117193871,
            117183062,
            117182596,
            117181449,
            117183504,
            117220486
        ],
        "F": [
            117202382,
            117258211,
            117241820,
            117455126,
            117572881,
            117239369,
            117247608,
            117266116,
            117251683,
            117256888,
            117254087
        ]
    },
    "name": "D. Kavi on Pairing Duty",
    "statement": "Kavi has 2n points lying on the OX axis, i-th of which is located at x =\r\ni.Kavi considers all ways to split these 2n points into n pairs. Among\r\nthose, he is interested in pairings, which are defined as\r\nfollows:Consider n segments with ends at the points in correspondent\r\npairs. The pairing is called good, if for every 2 different segments A\r\nand B among those, at least one of the following holds: One of the\r\nsegments A and B lies completely inside the other. A and B have the same\r\nlength. Consider the following example: A is a good pairing since the\r\nred segment lies completely inside the blue segment.B is a good pairing\r\nsince the red and the blue segment have the same length.C is not a good\r\npairing since none of the red or blue segments lies inside the other,\r\nneither do they have the same size.Kavi is interested in the number of\r\ngood pairings, so he wants you to find it for him. As the result can be\r\nlarge, find this number modulo 998244353.Two pairings are called\r\ndifferent, if some two points are in one pair in some pairing and in\r\ndifferent pairs in another.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000006;\nconst int mod = 998244353;\n\nlong long f[maxn];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n    for(int i = 1; i < maxn; ++i) {\n        for(int j = i; j < maxn; j += i) {\n            f[j]++;\n            if (j > 2) {\n                int w = (j - 2) / i;\n            }\n        }\n    }\n\n    int s = f[1];\n    for(int i = 2; i < maxn; ++i) {\n        f[i] += s;\n        f[i] %= mod;\n        s += f[i];\n        s %= mod;\n    }\n\n    int n; cin >> n;\n    cout << f[n] << endl;\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Kavi on Pairing Duty.json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "Let dpi\n be the number of good pairings of 2i\n points.\n\nClearly, the answer is dpn\n.\n\nLemma: Denote x\n as the point matched with the point 1\n. Notice that each point p\n (x<p?2n)\n belongs to a segment with length equal to [1,x]\n's length.\n\nProof: Assume some point p\n (x<p?2n)\n is paired with a point q\n (q>p)\n, since [p,q]\n doesn't lie inside [1,x]\n then their size must be the equal for the pairing to be good.\n\nTo compute dpn\n, consider the following cases:\n\nx>n\n: Similar to lemma mentioned above, it can be proved that each point p\n (1?p?2n?x+1)\n is paired with the point i+x?1\n, the remaining unpaired x?n?1\n points form a continuous subarray which lies inside each of the current pairs, thus they can be paired in dpx?n?1\n ways.\nx?n\n: In this case, due to the lemma mentioned above all the segments must have the same length, thus their length must be a divisor of n\n, in this case they can be paired in D(n)\n ways; where D(n)\n is the number of divisors of n\n.\nSo dpn\n = D(n)+?n?1i=0dpi\n.\n\nNote that dp0=dp1=1\n."
}