{"link": "https://codeforces.com//contest/1138/problem/E", "problemId": "309127", "problem_idx": "E", "shortId": "1138E", "contest_number": "1138", "problem_submissions": {"F": [51023634, 51022679, 51020619, 51116992, 51021353, 51023578, 51058557, 51025400, 51024171, 51210412], "D": [51010497, 51010075, 51011127, 51013543, 51016946, 51013080, 51010984, 51018905, 51015654, 51021599, 51016846, 51011106, 51012210, 51010079, 51014682, 51012504, 51012027, 51012863, 51011280, 51013123], "C": [51009558, 51007967, 51009995, 51010952, 51015174, 51011344, 51014468, 51017187, 51013830, 51019773, 51013378, 51012781, 51010541, 51011719, 51010213, 51010247, 51010268, 51010649, 51012791, 51010664], "B": [51008088, 51018029, 51007957, 51203745, 51017235, 51013207, 51009939, 51015227, 51016412, 51016667, 51019928, 51008726, 51015366, 51011120, 51014342, 51015668, 51014019, 51015624, 51013885], "A": [51005649, 51019409, 51005726, 51203724, 51006686, 51010568, 51006260, 51011468, 51005966, 51005745, 51006723, 51007288, 51005675, 51005671, 51006328, 51008250, 51006899, 51005800, 51005715, 51005850, 51006402], "E": [51015293, 51019023, 51203589, 51203519, 51023924, 51025422, 51204108]}, "name": "E. Museums Tour", "statement": "In the country N, there are n cities connected by m one-way roads.\r\nAlthough this country seems unremarkable, there are two interesting\r\nfacts about it. At first, a week lasts d days here. At second, there is\r\nexactly one museum in each city of the country N.Travel agency \"Open\r\nmuseums\" is developing a new program for tourists interested in museums.\r\nAgency\u2019s employees know which days each of the museums is open. The tour\r\nshould start in the capital the city number 1, and the first day of the\r\ntour must be on the first day of a week. Each day a tourist will be in\r\nsome city, watching the exposition in its museum (in case museum is open\r\ntoday), and by the end of the day, the tour either ends or the tourist\r\ngoes into another city connected by a road with the current one. The\r\nroad system of N is designed in such a way that traveling by a road\r\nalways takes one night and also all the roads are . It\u2019s allowed to\r\nvisit a city multiple times during the trip.You should develop such\r\nroute for the trip that the number of museums, possible to visit during\r\nit, is maximum.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n#define prev previous\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n    cerr << \"[\";\n    for (auto e : aux) cerr << e << ' ';\n    cerr << \"]\";\n    return cerr;\n}\n\nstruct state{\n    int x, y;\n    int where;\n};\n\nconst int maxN = 100011;\nconst int maxD = 52;\nconst int init = 1000000000;\n\nint n, m, d, x, y;\nvector<int> adj[maxN], rev[maxN];\nchar open[maxN][maxD];\n\nbool us[maxN][maxD];\nint best[maxN][maxD];\nstack< pair<int, int> > S;\nint nxt[maxD], prev[maxD];\nvector< pair<int, int> > here;\nint best_here;\n\nint cnt_vis;\nbool vis[maxN];\nint sol;\n\nstack<state> dfStack; \n\nvoid dfs(int x, int y) {\n    int wh;\n\n    dfStack.push({x, y, 0});\n    while (!dfStack.empty()) {\n        auto act = dfStack.top();\n        dfStack.pop();\n\n        x = act.x;\n        y = act.y;\n        wh = act.where;\n\n        us[x][y] = true;\n       \n        while (wh < adj[x].size() && us[adj[x][wh]][nxt[y]])\n            wh++;\n       \n        if (wh == adj[x].size()) {\n            S.push(mp(x, y));\n            continue;\n        } else {\n            dfStack.push({x, y, wh + 1});\n            dfStack.push({adj[x][wh], nxt[y], 0});\n        }\n    }\n\n}\n\nvoid dfs2(int x, int y) {\n    int wh;\n\n    dfStack.push({x, y, 0});\n    while (!dfStack.empty()) {\n        auto act = dfStack.top();\n        dfStack.pop();\n\n        x = act.x;\n        y = act.y;\n        wh = act.where;\n\n        us[x][y] = true;\n        if (wh == 0) {\n            here.pb(mp(x, y));\n            best_here = max(best_here, best[x][y]);\n            if (open[x][y] == '1' && vis[x] == false) {\n                vis[x] = true;\n                cnt_vis++;\n            }\n        }\n       \n        while (wh < rev[x].size() && us[rev[x][wh]][prev[y]])\n            wh++;\n       \n        if (wh == rev[x].size()) {\n            continue;\n        } else {\n            dfStack.push({x, y, wh + 1});\n            dfStack.push({rev[x][wh], prev[y], 0});\n        }\n    }\n}\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%d%d\\n\", &n, &m, &d);\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d%d\\n\", &x, &y);\n        adj[x].pb(y);\n        rev[y].pb(x);\n    }\n\n    for (int i = 1; i <= n; i++) scanf(\"%s\\n\", open[i]);\n    for (int i = 0; i < d; i++) {\n        nxt[i] = (i + 1) % d;\n        prev[i] = (i - 1 + d) % d;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < d; j++) {\n            if (us[i][j]) continue;\n            dfs(i, j);\n        }\n    }\n\n    memset(us, 0, sizeof(us));\n    best[1][0] = init;\n\n    while (!S.empty()) {\n        auto act = S.top(); S.pop();\n        x = act.first;\n        y = act.second;\n\n        if (us[x][y]) continue;\n        here.clear();\n        best_here = 0;\n        cnt_vis = 0;\n\n        dfs2(x, y);\n\n        for (auto e : here) {\n            x = e.first;\n            y = e.second;\n            best[x][y] = best_here + cnt_vis;\n            for (auto to : adj[x]) {\n                best[to][nxt[y]] = max(best[to][nxt[y]], best[x][y]);\n            }\n\n            vis[x] = false;\n        }\n\n        sol = max(sol, best_here + cnt_vis);\n\n        continue;\n        cerr << best_here + cnt_vis << '\\n';\n        for (auto e : here) cerr << e.first << \" \" << e.second << '\\n';\n    }\n\n    printf(\"%d\", sol - init);\n\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs"], "dificulty": "2500", "interactive": false}