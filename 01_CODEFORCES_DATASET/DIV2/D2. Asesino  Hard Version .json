{
    "link": "https://codeforces.com//contest/2022/problem/D2",
    "problemId": "2947278",
    "problem_idx": "D2",
    "shortId": "2022D2",
    "contest_number": "2022",
    "problem_submissions": {
        "D1": [
            285726010,
            285732443,
            285720467,
            285721725,
            285710598,
            285716496,
            285709185,
            285722223,
            285721840,
            285726265,
            285729782,
            285729870,
            285772115,
            285771713,
            285716249,
            285713460,
            285712248,
            285718533,
            285715843
        ],
        "E2": [
            285719910,
            285720748,
            285735574,
            285735176,
            288055359,
            286524378,
            285733091,
            285771493,
            285770412,
            285770170,
            285769301
        ],
        "E1": [
            285717777,
            285720862,
            285735538,
            285732412,
            285730131,
            285734694,
            285730466,
            285740393,
            285736961,
            285737293,
            285738689,
            285733822,
            285723809
        ],
        "C": [
            285713470,
            285709435,
            285713964,
            285712717,
            285726534,
            285712313,
            285728850,
            285716262,
            285717872,
            285721376,
            285719625,
            285718527,
            285713136,
            285713916,
            285709969,
            285709168,
            285707306,
            285710892,
            285710354
        ],
        "B": [
            285703660,
            285702595,
            285706421,
            285702197,
            285705976,
            285703966,
            285719780,
            285706485,
            285711437,
            285705925,
            285707565,
            285707987,
            285708651,
            285708053,
            285702275,
            285704156,
            285708490,
            285702360,
            285704264
        ],
        "A": [
            285702679,
            285701420,
            285703196,
            285701332,
            285704286,
            285701973,
            285705578,
            285709500,
            285703987,
            285704902,
            285704417,
            285704940,
            285701496,
            285701330,
            285702274,
            285701454,
            285701489,
            285702531
        ],
        "D2": [
            286191597,
            285736183,
            290850953,
            285816124
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135095",
    "editorial": "Consider the natural directed graph representation, adding a\ndirected edge with weight between node and if the answer to the query â?\ni jâ was yes, and a otherwise. We will also denote this query by .We\nwill use a lemma, that generalizes the idea for D1.Lemma: The sum of\nweights of a cycle is odd if and only if the impostor is among us (among\nthe cycle, I mean). Proof Suppose the impostor is not in the cycle. Then\nobserve that the only time you get an edge with weight is whenever there\nare two consecutive nodes with different roles. Consider consecutive\nsegments of nodes with the same role in this cycle, and compress each of\nthis segments into one node. The image bellow illustrates how, grey\nedges are queries with answer no. The new graph is bipartite, and thus\nhas an even number of edges. But all the edges in this new graph, are\nall the grey edges in the original graph, which implies what we want. If\nthe impostor is in the cycle, there are three ways of inserting it\n(assume the cycle has more than nodes that case is exactly what we\nproved in hint 2). We can insert the impostor into one of this\nâsegmentsâ of consecutive nodes with the same role. This would increase\nthe number of grey edges by , changing the parity, We can insert it\nbetween two segments. If we have Knight Impostor Knave, the number of\ngrey edges decreases by . If thee is Knave Impostor Knight, the number\nof grey edges increases by . Either way, we changed the parity of the\ncycle. The algorithm that solves the problem is the following:If , First\ncasequery and , If queries match, is the impostor. Else, query and . If\nqueries match, is the impostor. Else, is the impostor. Else, . To solve\nplayers with queries, do: While , query and . If their answers donât\nmatch, one of them is the impostor. Query and . If their answers donât\nmatch, is the impostor. Otherwise, is the impostor. If the answers\nmatch, do . If doesnât hold and we havenât found the impostor, we either\nhave the case or the case, we solve them optimally in or queries each.\nTo solve in queries, Second caseWe will form a cycle of size , asking\nfor , and (blue edges in the image below). If the cycle has an even\nnumber of noâs, we know the impostor is among or . So we ask and (green\nedges). If both queries match, is the impostor. Else, is the impostor.\nElse, The impostor is among us (among the cycle, I mean). Ask and\n(purple edges). If doesnât match with and doesnât match with , is the\nimpostor. If doesnât match with and matches with , is the impostor. If\nmatches with and doesnât match with , is the impostor. It is impossible\nfor to match with and to match with , because we know at least one of\nthis cycles will contain the impostor. To solve in queries, Third caseWe\nwill query , , and . If doesnât match with and doesnât match with , is\nthe impostor. If doesnât match with and matches with , is the impostor.\nIf matches with and doesnât match with , is the impostor. If matches\nwith and matches with , then is the impostor. We have proven that that .\nNow we will prove that . Proof of the lower boundWe will show it is\nimpossible to solve the problem for any with only queries. We will show\nthat the grader always has a strategy of answering queries, such that\nthere exists at least 2 different assignments of roles that are\nconsistent with the answers given, and have different nodes as the\nimpostor.Consider the directed graph generated from the queries. By\npigeonhole principle at least one node has in-degree , and at least one\nnode has out-degree . If those two nodes are different, call the node\nwith in-degree and the node with out-degree . Let the grader always\nreply yes to your queries. can be the impostor and everyone else Knaves.\ncan be the impostor and everyone else Knights. If those two nodes are\nthe same, then the graph looks like a collection of cycles and one\nisolated node. The grader will always reply yes except for the last\nquery where it replies no. Let the last query be to player about player\n. The two assignments of roles are: is the impostor and everyone else in\nthe cycle is a Knight. is the impostor and everyone else in the cycle is\na Knave. Thus, we have shown that regardless what the questions asked\nare, it is impossible to find the impostor among players, in queries.\nNow, we prove that : âProofâ Stare at this image:lol, Actually, one of\nthe testers coded the exhaustive checker. I will let them post their\ncode if they want to.\n",
    "name": "D2. Asesino  Hard Version ",
    "statement": ".It is a tradition in Mexico’s national IOI trainings to play the game\r\n\"\", which is similar to \"\" or \"\".Today, n players, numbered from 1 to n,\r\nwill play \"\" with the following three roles: : a Knight is someone who\r\nalways tells the truth. : a Knave is someone who always lies. : an\r\nImpostor is someone everybody thinks is a Knight, but is secretly a\r\nKnave. Each player will be assigned a role in the game. There will be\r\nImpostor but there can be any (possible zero) number of Knights and\r\nKnaves.As the game moderator, you have accidentally forgotten the roles\r\nof everyone, but you need to determine the player who is the Impostor.To\r\ndetermine the Impostor, you will ask some questions. In each question,\r\nyou will pick two players i and j (1\r\nleq i, j\r\nleq n; i\r\nneq j) and ask if player i thinks that player j is a Knight. The results\r\nof the question is shown in the table below.\r\nKnightKnaveImpostorKnightYesNoYesKnaveNoYesNoImpostorNoYes Find the\r\nImpostor in the minimum number of queries possible. That is, let f(n) be\r\nthe minimum integer such that for n players, there exists a strategy\r\nthat can determine the Impostor using at most f(n) questions. Then, you\r\nshould use at most f(n) questions to determine the Impostor. the roles\r\nof the players are not fixed in the beginning and may change depending\r\non your questions. However, it is guaranteed that there exists an\r\nassignment of roles that is consistent with all previously asked\r\nquestions under the constraints of this problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>std::string to_string(__int128_t value) {    if (value == 0) return \"0\";        std::string result;    bool negative = (value < 0);    if (negative) value = -value;        while (value > 0) {        result += '0' + (value % 10);        value /= 10;    }        if (negative) result += '-';        std::reverse(result.begin(), result.end());    return result;} // Overload << operator for __int128std::ostream& operator<<(std::ostream& os, __int128_t value) {    return os << to_string(value);}template<typename T1, typename T2>std::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& p) {    os << \"(\" << p.first << \", \" << p.second << \")\";    return os;}template <typename T, std::size_t N>std::ostream& operator<<(std::ostream& os, const std::array<T, N>& arr) {    os << \"[\";    for (std::size_t i = 0; i < N; ++i) {        os << arr[i];        if (i < N - 1) {            os << \", \";        }    }    os << \"]\";    return os;}template<typename T> std::ostream& operator<<(std::ostream& os, const std::set<T>& s) {    os << \"{ \";    for(const auto& elem : s) {        os << elem << \" \";    }    os << \"}\";    return os;}template<typename T> std::ostream& operator<<(std::ostream& os, const std::multiset<T>& s) {    os << \"{ \";    for(const auto& elem : s) {        os << elem << \" \";    }    os << \"}\";    return os;} template<typename T> std::ostream& operator<<(std::ostream& os, std::queue<T> q) {    // Print each element in the queue    os << \"{ \";    while (!q.empty()) {        os << q.front() << \" \";        q.pop();    }    os << \"}\";    // Print a newline at the end    return os;}template<typename T> std::ostream& operator<<(std::ostream& os, std::deque<T> q) {    // Print each element in the queue    os << \"{ \";    while (!q.empty()) {        os << q.front() << \" \";        q.pop_front();    }    os << \"}\";    // Print a newline at the end    return os;}template<typename T> std::ostream& operator<<(std::ostream& os, std::stack<T> q) {    // Print each element in the queue    os << \"{ \";    while (!q.empty()) {        os << q.top() << \" \";        q.pop();    }    os << \"}\";    // Print a newline at the end    return os;}template<typename T> std::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {    // Print each element in the queue    os << \"{ \";    while (!q.empty()) {        os << q.top() << \" \";        q.pop();    }    os << \"}\";    // Print a newline at the end    return os;} template<typename T> std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {    os << \"[ \";    for(const auto& elem : vec) {        os << elem << \" \";    }    os << \"]\";    return os;}template<typename K, typename V> std::ostream& operator<<(std::ostream& os, const std::map<K, V>& m) {    os << \"{ \";    for(const auto& pair : m) {        os << pair.first << \" : \" << pair.second << \", \";    }    os << \"}\";    return os;}template<typename T>using min_pq = std::priority_queue<T, std::vector<T>, std::greater<T>>;using namespace std;using ll = long long;#define add push_back #define FOR(i,a,b) for (int i = (a); i < (b); ++i)#define F0R(i,a) FOR(i,0,a)#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)#define R0F(i,a) ROF(i,0,a)#define f first#define s second#define trav(a,x) for (auto& a: x)#define int long long#define vt vector#define double long doublell inf = 1e18;mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());typedef unsigned long long ull;typedef __uint128_t L;ll mod = 1000000007;struct FastMod {\tull b, m;\tFastMod(ull bb) : b(bb), m(ull((L(1) << 64) / b)) {}\tull reduce(ull a) {\t\tull q = (ull)((L(m) * a) >> 64);\t\tull r = a - q * b; // can be proven that 0 <= r < 2*b\t\treturn r >= b ? r - b : r;\t}};FastMod fs(mod);int qLeft = 0;int query(int x, int y) {    qLeft--;    cout << \"? \" << x+1 << \" \" << y+1 << endl;    int ans;    cin >> ans;    return ans;}signed main() {    ios_base::sync_with_stdio(false);     cin.tie(0);    // freopen(\"input.txt\" , \"r\" , stdin);    // freopen(\"output.txt\" , \"w\", stdout);     int t = 1;    cin >> t;    while(t--) {        int n;        cin >> n;        if(n==3) {            if(query(0,1)==query(1,0)) {                cout << \"! 3\" << endl;                continue;            } else if(query(0,2)==query(2,0)) {                cout << \"! 2\" << endl;                continue;            } else {                cout << \"! 1\" << endl;                continue;            }        } else if(n%2==0) {            pair<int,int> bad = {0, 1};            for(int i = 3; i < n; i+=2) {                if(query(i-1, i)!=query(i, i-1)) {                    bad={i-1,i};                    break;                }            }            if(bad.f==0) {                if(query(0,2)==query(2,0)) {                    cout << \"! 2\" << endl;                    continue;                } else {                    cout << \"! 1\" << endl;                    continue;                }            } else {                if(query(0, bad.f)==query(bad.f, 0)) {                    cout << \"! \" << bad.f+2 << endl;                } else {                    cout << \"! \" << bad.f+1 << endl;                }                continue;            }        } else {            int x = query(0,1), y = query(1,2), z = query(2,0);            if((x+y+z)%2==0) {                if(query(1,0)==x) {                    cout << \"! 3\" << endl;                } else if(query(2,1)==y) {                    cout << \"! 1\" << endl;                } else {                    cout << \"! 2\" << endl;                }                continue;            }             pair<int,int> bad = {3,4};            for(int i = 6; i < n; i+=2) {                if(query(i,i-1)!=query(i-1,i)) {                    bad={i-1,i};                    break;                }            }            if(query(0,bad.f)!=query(bad.f,0)) {                cout << \"! \" << bad.f+1 << endl;            } else {                cout << \"! \" << bad.s+1 << endl;            }        }    }    return 0;}/*NNN: 111NNK: 100NKK: 010KKK: 111NNI: 110NKI: 000KKI: 101*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "interactive"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Asesino  Hard Version .json",
    "hint": [
        "Hint 4 What is the minimal value anyway? Our solution to D1 used queries if is even and queries when is odd. Is this the optimal strategy? Can we find a lower bound? Can we find the optimal strategy for small ?",
        "Hint 5 There's only possible unlabeled directed graphs with nodes and at most edges, you might as well draw them. They are illustrated in the image below for convenience though. Stare at them and convince yourself queries is the optimal for .",
        "Hint 6 We would have to prove that for all and for odd. How could we structure a proof?",
        "Hint 7 For we have some control over the graph. We can show by pigeonhole principle that at least one of them has in-degree , and at least one of them has out-degree . If those two nodes are different, call the node with in-degree and the node with out-degree . Let the grader always reply yes to your queries. can be the impostor and everyone else Knaves. can be the impostor and everyone else Knights. If those two nodes are the same, then the graph looks like a collection of cycles and one isolated node. The grader will always reply yes except for the last query where it replies no.  Let the last query be to player about player . The two assignments of roles are: is the impostor and everyone else in the cycle is a Knight. is the impostor and everyone else in the cycle is a Knave.",
        "Hint 8 Note that the structure of our proof is very general and is very easy to simulate for small values of and small number of queries. Can we extend it to odd and queries? Try writing an exhaustive checker and run it for small values. According to our conjecture, shouldn't solvable with queries. So we should find a set of answers that for any queries yields two valid assignments with different nodes as the impostor.",
        "Hint 9 It doesn't exist! Which means is solvable with queries. How? Also, observe that if we find a solution to we can apply the same idea and recursively solve the problem in queries for all ."
    ]
}