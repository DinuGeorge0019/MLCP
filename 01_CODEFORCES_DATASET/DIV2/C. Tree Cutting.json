{
    "link": "https://codeforces.com//contest/1946/problem/C",
    "problemId": "2546663",
    "problem_idx": "C",
    "shortId": "1946C",
    "contest_number": "1946",
    "problem_submissions": {
        "F": [
            252778634,
            252785320,
            252786013,
            252792288,
            252797773,
            252760159,
            252805049,
            252802973,
            252797418,
            252804807,
            252802498,
            252803677,
            252806450,
            252799639,
            252798045,
            252805458,
            253149787,
            253149764,
            252804697,
            252968362,
            252967816,
            252967536,
            252967308,
            252806243,
            252801898,
            252945361
        ],
        "E": [
            252767893,
            252755066,
            252775649,
            252778497,
            252788255,
            252768645,
            252781620,
            252778378,
            252791272,
            252783666,
            252792255,
            252787037,
            252788438,
            252796123,
            252791048,
            252789043,
            253149820,
            252796931,
            252794065,
            252793295,
            252769537
        ],
        "D": [
            252762969,
            252760657,
            252762929,
            252773084,
            252775710,
            252791493,
            252768538,
            252788123,
            252780760,
            252772529,
            252780806,
            252771784,
            252771623,
            252765540,
            252785160,
            252771914,
            253149843,
            252783465,
            252776484,
            252789596,
            252761305
        ],
        "C": [
            252755980,
            252750182,
            252755510,
            252756532,
            252756457,
            252786638,
            252755577,
            252760887,
            252765082,
            252758814,
            252754307,
            252762090,
            252762611,
            252762199,
            252764272,
            252764206,
            253149881,
            252762872,
            252757806,
            252747947,
            252752185
        ],
        "B": [
            252751889,
            252748922,
            252750334,
            252750610,
            252747768,
            252788061,
            252749547,
            252752546,
            252752071,
            252751826,
            252749973,
            252750830,
            252751955,
            252750419,
            252760194,
            252752821,
            253149896,
            252756666,
            252745823,
            252761849,
            252754627
        ],
        "A": [
            252743735,
            252744280,
            252743830,
            252744601,
            252743817,
            252788730,
            252743641,
            252745268,
            252744800,
            252746033,
            252743616,
            252744372,
            252744103,
            252744348,
            252750764,
            252744631,
            253149908,
            252746630,
            252743684,
            252757716,
            252743737
        ]
    },
    "name": "C. Tree Cutting",
    "statement": "You are given a tree with n vertices.Your task is to find the maximum\r\nnumber x such that it is possible to remove exactly k edges from this\r\ntree in such a way that the size of each remaining connected component^{\r\ndagger} is at least x.^{\r\ndagger} Two vertices v and u are in the same connected component if\r\nthere exists a sequence of numbers t_1, t_2,\r\nldots, t_k of arbitrary length k, such that t_1 = v, t_k = u, and for\r\neach i from 1 to k - 1, vertices t_i and t_{i+1} are connected by an\r\nedge.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=1e5+5;\nint n,k;\nvector<int> edg[MAXN];\nint siz[MAXN],cnt=0;\nvoid dfs(int u,int fa,int x){\n\tsiz[u]=1;\n\tfor(int v:edg[u]) if(v!=fa){\n\t\tdfs(v,u,x);\n\t\tsiz[u]+=siz[v];\n\t}\n\tif(siz[u]>=x){\n\t\tcnt++;\n\t\tsiz[u]=0;\n\t}\n}\nint check(int x){\n\tcnt=0;\n\tdfs(1,0,x);\n\treturn cnt-1;\n}\nvoid solve(){\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) edg[i].clear();\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;\n\t\tedg[u].push_back(v);\n\t\tedg[v].push_back(u);\n\t}\n\tint l=1,r=n,mid;\n\twhile(l<r){\n\t\tmid=l+r+1>>1;\n\t\tif(check(mid)>=k) l=mid;\n\t\telse r=mid-1;\n\t}\n\tcout<<l<<'\\n';\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(\"Otomachi_Una.in\",\"r\",stdin);\n\t// freopen(\"Otomachi_Una.out\",\"w\",stdout);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Tree Cutting.json",
    "editorial_link": "https://codeforces.com//blog/entry/127439",
    "editorial": "Letâs hang the tree from an arbitrary vertex, for definiteness letâs\r\nhang the tree from vertex (proof is given below). First of all, notice\r\nthat if we can obtain some answer , then we can also obtain the answer\r\n(exactly the same way as for ), so we can do a binary search for .To\r\ncheck the condition for a fixed , we will use a greedy algorithm. We\r\nwill find the maximum number of connected components into which we can\r\ncut our tree so that each component has at least vertices. We will start\r\na dfs from vertex , letâs say we are currently at vertex and the number\r\nof vertices in its subtree is greater than or equal to , then it is\r\nadvantageous for us to remove the edge from vertex to its parent. If\r\nafter this process there are at least connected components, then the\r\ncondition is satisfied for this , otherwise it is not.Proof that it\r\ndoesnât matter which vertex to hang the tree from:We need to prove that\r\nthe greedy algorithm will obtain the same number of cuts for all roots.\r\nWe will prove this in the order of depth-first search. It is also\r\nimportant to note that it doesnât matter in which order to run the\r\ngreedy algorithm from the children. Let the initial root be , and we\r\nwant to prove it for its child . Then letâs see how the greedy algorithm\r\nwill act in the first case: it will start from vertex , and then from\r\nall its adjacent vertices except , and remove some edges. When we run\r\nthe greedy algorithm in the second case, we can reorder the vertices,\r\nand first run it from all adjacent vertices except , and there will be\r\nthe same removals. Then we will run the greedy algorithm from vertex ,\r\nit will perform the same removals as in the first case, if we made\r\nvertex the last one. So the only edge that may not coincide in these\r\nremovals is . If this edge did not participate in the removals the first\r\ntime, then the size of the remaining part of vertex , so we cannot\r\nremove it now. If the edge was removed in the first variant, then the\r\nsize of the component was , and there were no vertices of subtree in it.\r\nThen when running the greedy algorithm from the second vertex, it will\r\ncut the edge , because the size of this part became , so the set of\r\nedges coincides.\r\n",
    "hint": []
}