{"link": "https://codeforces.com//contest/35/problem/B", "problemId": "165", "problem_idx": "B", "shortId": "35B", "contest_number": "35", "problem_submissions": {"E": [154745, 154634, 155001, 155046, 155106, 155283, 155729], "D": [154342, 154272, 154130, 154311, 153835, 155440, 154204, 154250, 154067, 154477, 154655, 154659, 154763, 154771, 153757, 154608], "C": [154062, 153916, 153821, 154057, 153649, 155441, 153981, 153912, 153668, 154279, 154275, 154526, 154222, 154207, 153616, 154747], "B": [153817, 153677, 154472, 153724, 155455, 153704, 154027, 154569, 154040, 154009, 154129, 154473, 154591, 155725, 154964], "A": [153493, 153454, 153281, 153341, 153328, 153676, 153548, 153463, 154008, 153336, 154158, 154206, 153882, 153410, 154421]}, "name": "B. Warehouse", "statement": "Once upon a time, when the world was more beautiful, the sun shone\r\nbrighter, the grass was greener and the sausages tasted better Arlandia\r\nwas the most powerful country. And its capital was the place where our\r\nhero DravDe worked. He couldn t program or make up problems (in fact,\r\nfew people saw a computer those days) but he was nevertheless happy. He\r\nworked in a warehouse where a magical but non-alcoholic drink\r\nOgudar-Olok was kept. We won t describe his work in detail and take a\r\nbetter look at a simplified version of the warehouse.The warehouse has\r\none set of shelving. It has shelves, each of which is divided into\r\nsections. The shelves are numbered from top to bottom starting from and\r\nthe sections of each shelf are numbered from left to right also starting\r\nfrom . Each section can contain exactly one box of the drink, and try as\r\nhe might, DravDe can never put a box in a section that already has one.\r\nIn the course of his work DravDe frequently notices that he has to put a\r\nbox in a filled section. In that case his solution is simple. DravDe\r\nignores that section and looks at the next one to the right. If it is\r\nempty, he puts the box there. Otherwise he keeps looking for the first\r\nempty section to the right. If no empty section is found by the end of\r\nthe shelf, he looks at the shelf which is under it, then the next one,\r\netc. Also each time he looks at a new shelf he starts from the shelf s\r\nbeginning. If DravDe still can t find an empty section for the box, he\r\nimmediately drinks it all up and throws the empty bottles away not to be\r\ncaught.After one great party with a lot of Ogudar-Olok drunk DravDe\r\nasked you to help him. Unlike him, you can program and therefore\r\nmodeling the process of counting the boxes in the warehouse will be easy\r\nwork for you.The process of counting contains two types of query\r\nmessages: (where , are integers, , , and is a string of lower case Latin\r\nletters from to characters long). That query means that the warehouse\r\ngot a box identified as , which should be put in the section on the\r\nshelf . If the section is full, use the rules described above. It is\r\nguaranteed that every moment of the process the identifiers of all the\r\nboxes in the warehouse are different. You don t have to answer this\r\nquery. (where is a string of lower case Latin letters from to characters\r\nlong). That query means that a box identified as is removed from the\r\nwarehouse. You have to answer this query (see output format).\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nint n, m, k;\nchar cmd[3];\nmap<string, PII> n2pos;\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d%d%d\", &n, &m, &k);\n    bool shelve[n][m];\n    memset(shelve, false, sizeof(shelve));\n    for(int i=0; i<k; i++){\n        scanf(\"%s\", cmd);\n        if (strcmp(cmd, \"+1\")==0){\n            int x, y;\n            string name;\n            scanf(\"%d%d\", &x, &y); x--; y--;\n            cin >> name;\n            for(;;){\n                if (y >= m){\n                    y = 0;\n                    x ++;\n                }\n                if (x >= n) break;\n                if (!shelve[x][y]){\n                    shelve[x][y] = true;\n                    n2pos[name] = make_pair(x, y);\n                    break;\n                }\n                else y++;\n            }\n        }\n        else {\n            string name;\n            cin >> name;\n            if (n2pos.find(name) != n2pos.end()){\n                int x, y;\n                x = n2pos[name].first;\n                y = n2pos[name].second;\n                printf(\"%d %d\\n\", x+1, y+1);\n                shelve[x][y] = false;\n                n2pos.erase(name);\n            }\n            else{\n                printf(\"-1 -1\\n\");\n            }\n        }\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1700", "interactive": false}