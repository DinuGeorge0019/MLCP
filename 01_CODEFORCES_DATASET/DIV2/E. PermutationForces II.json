{
    "link": "https://codeforces.com//contest/1698/problem/E",
    "problemId": "1443730",
    "problem_idx": "E",
    "shortId": "1698E",
    "contest_number": "1698",
    "problem_submissions": {
        "F": [
            162124470,
            162134445,
            162141749,
            162152934,
            177654064,
            216084662,
            162196377,
            162139942,
            162355602,
            162159626,
            162690820
        ],
        "E": [
            162087630,
            162097353,
            162109816,
            162103301,
            162126529,
            162103867,
            162097541,
            162101116,
            162109117,
            162107378,
            162110311,
            162151314,
            162112938,
            162118264,
            162120819,
            162122603,
            162129047,
            162116428,
            162113567,
            162115753
        ],
        "D": [
            162072106,
            162078971,
            162084618,
            162091663,
            162091608,
            162080384,
            162079742,
            162083927,
            162089597,
            162090503,
            162089228,
            162119224,
            162090409,
            162087036,
            162090706,
            162084921,
            162084389,
            162101274,
            162089309,
            162089923
        ],
        "C": [
            162065641,
            162067112,
            162066151,
            162070233,
            162081538,
            162071658,
            162069982,
            162072714,
            162074007,
            162068223,
            162076542,
            162110420,
            162075987,
            162073114,
            162072860,
            162074806,
            162073708,
            162075609,
            162078161,
            162072891
        ],
        "B": [
            162059543,
            162058156,
            162059458,
            162060292,
            162065675,
            162061709,
            162057759,
            162058869,
            162063379,
            162060397,
            162060756,
            162115063,
            162060812,
            162061896,
            162062035,
            162068563,
            162064118,
            162063059,
            162062265,
            162061711
        ],
        "A": [
            162055540,
            162055455,
            162055545,
            162055770,
            162057397,
            162055986,
            162055221,
            162055288,
            162058360,
            162055918,
            162055534,
            162055768,
            162055783,
            162057223,
            162056112,
            162055836,
            162057629,
            162055832,
            162056104,
            162055773
        ],
        "G": [
            162150291,
            162713012
        ]
    },
    "name": "E. PermutationForces II",
    "statement": "You are given a permutation a of length n. Recall that permutation is an\r\narray consisting of n distinct integers from 1 to n in arbitrary\r\norder.You have a strength of s and perform n moves on the permutation a.\r\nThe i-th move consists of the following: Pick two integers x and y such\r\nthat i\r\nleq x\r\nleq y\r\nleq\r\nmin(i+s,n), and swap the positions of the integers x and y in the\r\npermutation a. Note that you select x=y in the operation, in which case\r\nno swap will occur. You want to turn a into another permutation b after\r\nn moves. However, some elements of b are missing and are replaced with\r\n-1 instead. Count the number of ways to replace each -1 in b with some\r\ninteger from 1 to n so that b is a permutation and it is possible to\r\nturn a into b with a strength of s. Since the answer can be large,\r\noutput it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define N 300005\n#define ll long long\n#define mod 998244353\nint T,n,i,j,qwq,s,c[N],fl,p[N],a[N],b[N];\nll ans;\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>s;\n\t\tfor(i=1;i<=n;++i)cin>>a[i];\n\t\tfor(i=1;i<=n;++i)cin>>b[i],p[a[i]]=b[i];\n\t\tfl=0;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tif(p[i]!=-1&&p[i]<i-s)fl=1;\n\t\t\tif(p[i]!=-1)c[p[i]]=1;\n\t\t}ans=1;\n\t\tj=1;qwq=0;\n\t\tfor(i=1;i<=n;++i){\n\t\t\twhile(j<=i+s&&j<=n){if(p[j]==-1)++qwq;++j;}\n\t\t\tif(!c[i]&&qwq==0)fl=1;\n\t\t\telse if(!c[i])ans=ans*qwq%mod,--qwq;\n\t\t}\n\t\tfor(i=1;i<=n;++i)c[i]=0;\n\t\tif(fl==1)cout<<\"0\\n\";\n\t\telse cout<<ans<<\"\\n\";\n\t}\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "greedy",
        "sortings",
        "trees",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. PermutationForces II.json",
    "editorial_link": "https://codeforces.com//blog/entry/104310",
    "editorial": "Suppose that we know the elements of . We claim that the minimum\r\nstrength needed is . Letâs prove it. For simplicity letâs sort the\r\nelements of from to , and rearrange the corresponding elements of in the\r\nsame way. In other words, we only need to turn this new array into the\r\nidentity .First note that on the -th operation, we need to move the\r\nnumber to the correct position. This is because of the format of the\r\noperations; in any future operation, will not be in the given range, so\r\nit is required to move in the current operation.Letâs look at the number\r\n. If , then we donât need any strength. Otherwise, we need strength to\r\nswap and . Afterwards, we can essentially ignore for the rest of the\r\noperations, since there is no need to move it again.In general, there\r\nare two cases for when we need to move to its correct place: . In this\r\ncase, weâll never move until the -th operation, where we swap and . We\r\nneed a strength of for that. This is necessary. . In this case, we will\r\nswap in an earlier operation (since , so we must swap it to its correct\r\nplace in the -th operation). If we again end up with some smaller\r\nnumber, we will need to swap that before , and so on. Suppose that after\r\nsome time, the current element in the -th position is at least . Then\r\nthis element must have been swapped with some other element smaller than\r\n(since we only perform swaps with elements smaller than before the -th\r\noperation). In particular, this element originally started somewhere to\r\nthe left of , say at position . Then in the strength calculation, we\r\ncounted , which is more than , i.e. more than we actually need to swap\r\nand . This is sufficient. Hence we only need to check the inequality for\r\nall . Now we proceed to the counting part.Rewrite this as . Suppose that\r\nvalues of are missing. Call them in increasing order. Then note that if\r\nsome element of satisfies this inequality, all larger elements of will.\r\nIn other words, for each whose corresponding element of is missing, some\r\nsuffix of will work. We can simply binary search to find this suffix for\r\neach . Let denote the length of this suffix.Afterwards, we need to count\r\nthe number of ways to assign each missing element to an . Process the\r\nelements greedily, from the with the fewest choices to the one with the\r\nmost (that is, the largest to the smallest). The first has choices, the\r\nsecond (one element of was already taken), the third , and so on. We can\r\ncompute this product straightforwardly.The time complexity is .\r\n",
    "hint": [
        "Hint 1 When can you make into ?",
        "Hint 2 To swap with , we need a strength of at least . Is it enough?",
        "Hint 3 The minimum strength needed is . How can we count the number of solutions?"
    ]
}