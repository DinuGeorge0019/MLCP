{
    "link": "https://codeforces.com//contest/1831/problem/E",
    "problemId": "1942565",
    "problem_idx": "E",
    "shortId": "1831E",
    "contest_number": "1831",
    "problem_submissions": {
        "F": [
            208138276,
            207709337
        ],
        "E": [
            208138261,
            207648682,
            207658220,
            207656838,
            207666357,
            207774368,
            207656515,
            207695977,
            207710932,
            207657876,
            208163887,
            207670786,
            207664348,
            207669868,
            207660228
        ],
        "D": [
            208138229,
            207624019,
            207622747,
            207707096,
            207639773,
            207642056,
            207665762,
            207606856,
            207612471,
            207613443,
            207614547,
            207617717,
            207621891,
            207622928,
            207622371,
            207623544,
            207626326,
            207683940,
            207628627
        ],
        "C": [
            208138202,
            207603654,
            207591133,
            207610375,
            207604106,
            207604842,
            207591198,
            207597318,
            207602578,
            207595759,
            207597417,
            207600531,
            207601702,
            207596236,
            207598453,
            207596408,
            207607400,
            207594213,
            207608501,
            207603207
        ],
        "B": [
            207933759,
            207587309,
            207585317,
            207591044,
            207597740,
            207626518,
            207586353,
            207592366,
            207588011,
            207586628,
            207590623,
            207592643,
            207591011,
            207586905,
            209739181,
            207587547,
            207588237,
            207602435,
            207588035,
            207591775,
            207591535
        ],
        "A": [
            207933729,
            207580780,
            207580051,
            207582133,
            207593347,
            207580551,
            207581151,
            207591960,
            207580225,
            207581009,
            207582654,
            207583238,
            207580711,
            207581264,
            209739158,
            207580917,
            207581616,
            207598296,
            207580446,
            207582701,
            207581592
        ]
    },
    "name": "E. Hyperregular Bracket Strings",
    "statement": "You are given an integer n and k intervals. The i-th interval is\r\n[l_i,r_i] where 1\r\nleq l_i\r\nleq r_i\r\nleq n.Let us call a bracket sequence^{\r\ndagger,\r\nddagger} of length n if for each i such that 1\r\nleq i\r\nleq k, the substring\r\noverline{s_{l_i} s_{l_{i}+1}\r\nldots s_{r_i}} is also a regular bracket sequence.Your task is to count\r\nthe number of hyperregular bracket sequences. Since this number can be\r\nreally large, you are only required to find it modulo 998\r\n,244\r\n,353.^\r\ndagger A bracket sequence is a string containing only the characters \"\"\r\nand \"\".^\r\nddagger A bracket sequence is called regular if one can turn it into a\r\nvalid math expression by adding characters and . For example, sequences\r\n, , and the empty string are regular, while , , and are not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate < typename T >\ninline const void read(T &x)\n{\n\tbool flg = x = 0;\n\tchar c;\n\twhile ((c = getchar()) < 48 || c > 57)\n\t\tflg |= c == '-';\n\tdo\n\t\tx = (x << 1) + (x << 3) + (c ^ 48);\n\twhile ((c = getchar()) > 47 && c < 58);\n\tif (flg) x = -x;\n}\n\nint OUTPUT[45];\n\ntemplate < typename T >\ninline const void write(T x)\n{\n\tif (x < 0)\n\t{\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tint len = 0;\n\tdo\n\t{\n\t\tOUTPUT[++len] = x % 10 | 48;\n\t\tx /= 10;\n\t}while (x);\n\twhile (len)\n\t\tputchar(OUTPUT[len--]);\n}\n\ntemplate < typename T >\ninline const void writesp(const T x)\n{\n\twrite(x);\n\tputchar(32);\n}\n\ntemplate < typename T >\ninline const void writeln(const T x)\n{\n\twrite(x);\n\tputchar(10);\n}\n\nconst int N = 1e6 + 5, P = 998244353;\nconst unsigned long long Base = 19260817ull;\nunsigned long long pw[N], cf[N];\nint T, n, k, fac[N], inv[N], finv[N];\npair < int, int > a[N]/*, b[N]*/;\nmap < unsigned long long, int > mp;\n\ninline int C(int x, int y)\n{\n\tif (x < y) return 0;\n\tif (y < 0) return 0;\n\treturn (long long)fac[x] * (long long)finv[y] % P * (long long)finv[x - y] % P;\n}\n\ninline int Cat(int x)\n{\n\treturn (long long)C((x << 1), x) * (long long)inv[x + 1] % P;\n}\n\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tpw[0] = 1ull;\n\tfor (int i = 1; i <= 1000000; ++i)\n\t\tpw[i] = pw[i - 1] * Base;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= 1000000; ++i)\n\t\tfac[i] = (long long)fac[i - 1] * i % P;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 1000000; ++i)\n\t\tinv[i] = (long long)(P - P / i) * (long long)inv[P % i] % P;\n\tfinv[0] = 1;\n\tfor (int i = 1; i <= 1000000; ++i)\n\t\tfinv[i] = (long long)finv[i - 1] * inv[i] % P;\n//\twriteln(C(6, 3));\n//\tfor (int i = 1; i <= 1000000; ++i)\n//\t\tassert((long long)fac[i] * finv[i] % P == 1);\n//\treturn 0;\n\tread(T);\n\twhile (T--)\n\t{\n\t\tread(n);\n\t\tread(k);\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tread(a[i].first);\n\t\t\tread(a[i].second);\n\t\t}\n\t\tif (n & 1)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tint /*len = 0, rst = 0, */ans = 1;\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t\tif ((a[i].second - a[i].first + 1) & 1)\n\t\t\t{\n\t\t\t\tputs(\"0\");\n\t\t\t\tgoto End;\n\t\t\t}\n\t\tfor (int i = n + 1; ~i; --i)\n\t\t\tcf[i] = 0;\n\t\tfor (int i = 1; i <= k; ++i)\n\t\t{\n\t\t\tcf[a[i].first] += pw[i];\n\t\t\tcf[a[i].second + 1] -= pw[i];\n\t\t}\n\t\tmp.clear();\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tcf[i] += cf[i - 1];\n\t\t\t++mp[cf[i]];\n//\t\t\tif (cf[i])\n//\t\t\t{\n//\t\t\t\tif (!len) b[++len] = make_pair(i, i);\n//\t\t\t\telse if (cf[i] == cf[i - 1]) ++b[len].second;\n//\t\t\t\telse b[++len] = make_pair(i, i);\n//\t\t\t}\n//\t\t\telse ++rst;\n\t\t}\n//\t\twritesp(rst), puts(\"rst\");\n//\t\tif (rst & 1)\n//\t\t{\n//\t\t\tputs(\"0\");\n//\t\t\tcontinue;\n//\t\t}\n//\t\tfor (int i = 1; i <= len; ++i)\n//\t\t\twritesp(b[i].first), writesp(b[i].second), puts(\"b\");\n//\t\tfor (int i = 1; i <= len; ++i)\n//\t\t\tif ((b[i].second - b[i].first + 1) & 1)\n//\t\t\t{\n//\t\t\t\tputs(\"0\");\n//\t\t\t\tgoto End;\n//\t\t\t}\n//\t\tfor (int i = 1; i <= len; ++i)\n//\t\t\tans = (long long)ans * Cat((b[i].second - b[i].first + 1) >> 1) % P;\n//\t\tans = (long long)ans * Cat(rst >> 1) % P;\n\t\tfor (auto i : mp)\n\t\t\tif (i.second & 1)\n\t\t\t{\n\t\t\t\tputs(\"0\");\n\t\t\t\tgoto End;\n\t\t\t}\n\t\tfor (auto i : mp)\n\t\t\tans = (long long)ans * (long long)Cat(i.second >> 1) % P;\n\t\twriteln(ans);\n\t\tEnd:;\n\t}\n\treturn 0;\n}\n/*\n\u6574\u4e2a\u62ec\u53f7\u5e8f\u5217\u662f\u5408\u6cd5\u7684 \n\n\u6bcf\u4e2a\u533a\u95f4\u5185\u7684\u62ec\u53f7\u5e8f\u5217\u90fd\u662f\u5408\u6cd5\u7684 \n\n1 8\n2 5\n3 6\n\n1 4\n3 6\n5 8\n7 10\n\n1 2 3 4 5 6 7 8 9 10\na a a a\n\tb b b b\n\t\tc c c c\n\t\t\td d d d\n\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "hashing",
        "math",
        "number theory",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hyperregular Bracket Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "First and foremost, the number of regular bracket strings of length 2?n\n is equal to Cn=1n+1(2nn)\n.\n\nSecondly, for a bracket string s1s2\u0085sk\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\n, let:\n\nf(si)={1,?1,if si='('if si=')'\n\n\n?i=?ij=1f(sj)\nA bracket string s1s2\u0085sk\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\n is a regular bracket string if both of the following statements are true:\n\n?k=0\n\n?i?0,i=1,k\u00af\u00af\u00af\u00af\u00af\u00af\u00af\n\nFrom now on we'll call a set of indices i1<i2<\u0085<ik\n a group if si1si2\u0085sik\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\n must be an RBS.\n\nThere are two main cases to consider, both of which can be proven with the aforementioned conditions for a string to be an RBS:\n\nCase 1: Included intervals\nCase 2: Partially overlapping intervals\nBy taking both of these cases into account, we can conclude that all indices ik\n covered by the same subset of intervals are part of the same group.\n\nFinding the subset of intervals which cover a certain index i\n can be implemented using difference arrays and xor hashing.\n\nHow does xor hashing on difference arrays work?\nTime complexity: O(maxn?log(mod))\n for precomputing every Cn\n, and O(k?log(k))\n per test case."
}