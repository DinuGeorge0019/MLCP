{
    "link": "https://codeforces.com//contest/658/problem/C",
    "problemId": "53371",
    "problem_idx": "C",
    "shortId": "658C",
    "contest_number": "658",
    "problem_submissions": {
        "E": [
            17004085,
            49157877,
            17061517,
            17156655
        ],
        "D": [
            16999449,
            17015215,
            16997780,
            17002007,
            17001539,
            17001492,
            17003628,
            17003492,
            17003016,
            17002794,
            17003833,
            17004549,
            17006375,
            17005499,
            17005815,
            17005114,
            17019978,
            17005108,
            17005065,
            17003630,
            17006976
        ],
        "C": [
            16995068,
            16993450,
            16995031,
            16997375,
            16996718,
            16996690,
            16995850,
            16997578,
            17001691,
            16996778,
            16998533,
            16997776,
            16998853,
            16997308,
            16999990,
            16997317,
            16999080,
            17004966,
            16999164
        ],
        "B": [
            16992735,
            16994253,
            16992611,
            16991812,
            16993314,
            16992931,
            16992391,
            16993663,
            16993303,
            16993084,
            16992706,
            16992701,
            16994956,
            16993684,
            16993760,
            16992879,
            16993582,
            16992643,
            16994378
        ],
        "A": [
            16990896,
            16990442,
            16990585,
            16990357,
            16991634,
            16990650,
            16990607,
            16990450,
            16991276,
            16991187,
            16990751,
            16990621,
            16991771,
            16990461,
            16991470,
            16990648,
            16991140,
            16990764,
            16991241
        ]
    },
    "name": "C. Bear and Forgotten Tree 3",
    "statement": "A tree is a connected undirected graph consisting of vertices and edges.\r\nVertices are numbered through .Limak is a little polar bear and\r\nRadewoosh is his evil enemy. Limak once had a tree but Radewoosh stolen\r\nit. Bear is very sad now because he doesn\u2019t remember much about the tree\r\nhe can tell you only three values , and : The tree had exactly vertices.\r\nThe tree had diameter . In other words, was the biggest distance between\r\ntwo vertices. Limak also remembers that he once rooted the tree in\r\nvertex and after that its height was . In other words, was the biggest\r\ndistance between vertex and some other vertex. The distance between two\r\nvertices of the tree is the number of edges on the simple path between\r\nthem.Help Limak to restore his tree. Check whether there exists a tree\r\nsatisfying the given conditions. Find any such tree and print its edges\r\nin any order. It\u2019s also possible that Limak made a mistake and there is\r\nno suitable tree in this case print \"\".\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define all(x) x.begin() , x.end()\n#define fi first\n#define se second\n#define pb push_back\n#define umax( x , y ) x = max( x , (y) )\n#define umin( x , y ) x = min( x , (y) )\n#define For( i , a ) for(int i=1;i<=a;i++)\n#define ort (((b+s) < 0 )? (b+s)/2-1:(b+s)/2)\n#define y2 asrwjaelkf\n#define y1 asseopirwjaelkf\n\nusing namespace std;\n\ninline int read() {\n\tint res = 0 ;int neg ;\n\twhile(true){char ch = getchar();if(ch>='0' && ch<='9' || ch=='-'){if(ch=='-') neg = -1;else neg = 1 , res = ch-'0';break;} }\n\twhile(true){char ch = getchar();if(ch>='0' && ch<='9') res*=10 , res+=ch-'0';else break;}\n\treturn res*neg;\n}\n\ntypedef long long Lint;\ntypedef double db;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\n\nconst int maxn = 1000020;\nconst int MOd = 1e9+7;\n\nint a, d, h;\nint ar[maxn], t[maxn];\n\nint main() {\n\t\n\tscanf(\"%d %d %d\",&a,&d,&h);\n\t\n\tif( a == 2 && d == 1 && h == 1 ) {\n\t\tprintf(\"1 2\\n\");\n\t\treturn 0;\n\t}\n\t\n\tif( d > h + h ) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif( d < h ) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint bag = 1;\n\tif( d == h ) {\n\t\tif( d < 2 ) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbag = 2;\n\t}\n\tint n = 1;\n\tint back = 1;\n\tfor(int i=1;i<=h;i++) {\n\t\tprintf(\"%d %d\\n\",back,++n);\n\t\tback = n;\n\t}\n\tback = 1;\n\tfor(int i=1;i<=d-h;i++) {\n\t\tprintf(\"%d %d\\n\",back,++n);\n\t\tback = n;\n\t}\n\t\n\twhile( n < a ) {\n\t\tprintf(\"%d %d\\n\",bag,++n);\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bear and Forgotten Tree 3.json",
    "editorial_link": "https://codeforces.com//blog/entry/44047",
    "editorial": "You may want to write some special if for n?=?2. Let's assume n???3. If d?=?1 or d?>?2h then there is no answer (it isn't hard to see and prove). Otherwise, let's construct a tree as follows.\n\nWe need a path of length h starting from vertex 1 and we can just build it. If d?>?h then we should also add an other path from vertex 1, this one with length d?-?h. Now we have the required height and diameter but we still maybe have too few vertices used. But what we built is one path of length d where d???2. You can choose any vertex on this path other than ends of the path (let's call him v), and add new vertices by connecting them all directly with v. You can draw it to see that you won't increase height or diameter this way. In my code I sometimes had v?=?1 but sometimes (when d?=?h) I needed some other vertex and v?=?2 was fine."
}