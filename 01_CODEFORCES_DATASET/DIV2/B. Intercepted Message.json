{
    "link": "https://codeforces.com//contest/950/problem/B",
    "problemId": "163623",
    "problem_idx": "B",
    "shortId": "950B",
    "contest_number": "950",
    "problem_submissions": {
        "F": [
            36110799,
            36106874,
            36110418,
            36111996,
            36110842,
            36112881,
            36112066,
            36111037,
            36115685,
            36107783,
            36111061,
            36110969
        ],
        "E": [
            36106600,
            36110576,
            36107020,
            36108185,
            36105421,
            36110602,
            36104100,
            36112036,
            36103180,
            36119591,
            36103520,
            36104391,
            36111839,
            36104803,
            36105285,
            36106153,
            36105692,
            36107917,
            36133513,
            36106022
        ],
        "D": [
            36099255,
            36103207,
            36103975,
            36101168,
            36099422,
            36104316,
            36100451,
            36105727,
            36100010,
            36100957,
            36098808,
            36101447,
            36108972,
            36101180,
            36100807,
            36101948,
            36101824,
            36102198,
            36099705,
            36115114,
            36103338
        ],
        "B": [
            36097037,
            36093570,
            36096763,
            36102283,
            36107341,
            36096070,
            36118539,
            36103628,
            36098191,
            36093324,
            36097654,
            36092909,
            36097186,
            36093092,
            36094178,
            36093761,
            36093826,
            36092324,
            36094422,
            36093177
        ],
        "C": [
            36095719,
            36096428,
            36100419,
            36099281,
            36103315,
            36101716,
            36094357,
            36100382,
            36094934,
            36098794,
            36096378,
            36098545,
            36106922,
            36096674,
            36097941,
            36096847,
            36097394,
            36095627,
            36097024,
            36097344
        ],
        "A": [
            36091256,
            36091581,
            36094574,
            36100244,
            36107668,
            36091536,
            36095298,
            36101664,
            36095785,
            36091314,
            36098215,
            36091291,
            36093398,
            36091393,
            36091803,
            36091568,
            36091610,
            36091266,
            36092123,
            36091364
        ]
    },
    "name": "B. Intercepted Message",
    "statement": "Hacker Zhorik wants to decipher two secret messages he intercepted\r\nyesterday. Yeah message is a sequence of encrypted blocks, each of them\r\nconsists of several bytes of information.Zhorik knows that each of the\r\nmessages is an archive containing one or more files. Zhorik knows how\r\neach of these archives was transferred through the network: if an\r\narchive consists of files of sizes bytes, then the -th file is split to\r\none or more blocks (here the total length of the blocks is equal to the\r\nlength of the file ), and after that all blocks are transferred through\r\nthe network, maintaining the order of files in the archive.Zhorik thinks\r\nthat the two messages contain the same archive, because their total\r\nlengths are equal. However, each file can be split in blocks in\r\ndifferent ways in the two messages.You are given the lengths of blocks\r\nin each of the two messages. Help Zhorik to determine what is the\r\nmaximum number of files could be in the archive, if the Zhorik\u2019s\r\nassumption is correct.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nlong long a[N],b[N];\nint ans,n,m;\nset<long long> s;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%I64d\",&a[i]),a[i]+=a[i-1],s.insert(a[i]);\n\tfor(int i=1;i<=m;i++)scanf(\"%I64d\",&b[i]),b[i]+=b[i-1],ans+=s.count(b[i]);\n\tcout<<ans;\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Intercepted Message.json",
    "editorial_link": "https://codeforces.com//blog/entry/58291",
    "editorial": "Let\u00e2\u0080\u0099s define and as sums of first elements of and (, , , ). and can be\r\nsame file iff this three conditions are true: because we need to divide\r\nprefix into files. because we need to divide suffix into files. segments\r\nhave same sum. It\u00e2\u0080\u0099s easy to see that if two first conditions are true\r\nthen the third are true too because and because of this fact and\r\ncondition from statement answer is a number of non-empty prefixes with\r\nthe same sum.Time complexity is if you use two pointers or if you use\r\nsome data structure. You lost block from second message and you\r\ninterested in maximal possible number of files if you can insert this\r\nblock anywhere in second message. In this case it graduated that .\r\n"
}