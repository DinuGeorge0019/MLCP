{
    "link": "https://codeforces.com//contest/1543/problem/E",
    "problemId": "1038890",
    "problem_idx": "E",
    "shortId": "1543E",
    "contest_number": "1543",
    "problem_submissions": {
        "E": [
            121638293,
            121640122,
            121646039,
            121646816,
            121811012,
            121760431,
            121760422,
            121760385,
            121760374,
            121760355,
            121760336,
            121760282,
            121760064,
            121760038,
            121759905,
            121653632,
            121644982,
            121669265,
            121699461,
            121677102,
            121676768,
            121663043,
            121682193,
            121682008,
            121681968,
            121681825
        ],
        "C": [
            121607103,
            121580363,
            121606682,
            121627500,
            121653560,
            121590146,
            121589009,
            121582693,
            121614005,
            121615009,
            121616095,
            121613756,
            121596961,
            121599154,
            121597926,
            121608185,
            121597933,
            121606103,
            121606203
        ],
        "D2": [
            121596158,
            121601464,
            121617704,
            121620392,
            121626490,
            121619638,
            121618444,
            121618704,
            121605621,
            121605043,
            121602716,
            121616842,
            121615764,
            121615962,
            121615812,
            121620480,
            121619304,
            121615169,
            121624602
        ],
        "D1": [
            121576532,
            121593477,
            121613266,
            121597889,
            121614339,
            121601755,
            121604364,
            121608739,
            121598195,
            121595487,
            121589696,
            121586209,
            121618059,
            121609771,
            121609361,
            121593980,
            121614987,
            121614945,
            121599352
        ],
        "B": [
            121572816,
            121573125,
            121599866,
            121581407,
            121575511,
            121573418,
            121573029,
            121584593,
            121575414,
            121574254,
            121573423,
            121577407,
            121575483,
            121573867,
            121576997,
            121576837,
            121577599,
            121574767,
            121583481
        ],
        "A": [
            121572516,
            121572434,
            121598213,
            121578311,
            121573469,
            121572491,
            121577467,
            121587968,
            121572718,
            121572541,
            121572464,
            121574176,
            121573349,
            121572610,
            121574728,
            121572920,
            121574400,
            121572846,
            121578119
        ]
    },
    "name": "E. The Final Pursuit",
    "statement": "Finally, you have defeated Razor and now, you are the Most Wanted street\r\nracer. Sergeant Cross has sent the full police force after you in a\r\ndeadly pursuit. Fortunately, you have found a hiding spot but you fear\r\nthat Cross and his force will eventually find you. To increase your\r\nchances of survival, you want to tune and repaint your BMW M3 GTR.The\r\ncar can be imagined as a n-dimensional hypercube. A simple n-dimensional\r\nhypercube is an undirected unweighted graph built recursively as\r\nfollows: Take two simple (n-1)-dimensional hypercubes one having\r\nvertices numbered from 0 to 2^{n-1}-1 and the other having vertices\r\nnumbered from 2^{n-1} to 2^{n}-1. A simple 0-dimensional Hypercube is\r\njust a single vertex. Add an edge between the vertices i and i+2^{n-1}\r\nfor each 0\r\nleq i < 2^{n-1}. A permuted n-dimensional hypercube is formed by\r\npermuting the vertex numbers of a simple n-dimensional hypercube in any\r\narbitrary manner.Examples of a simple and permuted 3-dimensional\r\nhypercubes are given below: Note that a permuted n-dimensional hypercube\r\nhas the following properties: There are exactly 2^n vertices. There are\r\nexactly n\r\ncdot 2^{n-1} edges. Each vertex is connected to exactly n other\r\nvertices. There are no self-loops or duplicate edges. Let’s denote the\r\npermutation used to generate the permuted n-dimensional hypercube,\r\nrepresenting your car, from a simple n-dimensional hypercube by P.\r\nBefore messing up the functionalities of the car, you want to find this\r\npermutation so that you can restore the car if anything goes wrong. But\r\nthe job isn’t done yet.You have n different colours numbered from 0 to\r\nn-1. You want to colour the vertices of this permuted n-dimensional\r\nhypercube in such a way that for each and every vertex u satisfying 0\r\nleq u < 2^n and for each and every colour c satisfying 0\r\nleq c < n, there is at least one vertex v adjacent to u having a colour\r\nc. In other words, from each and every vertex, it must be possible to\r\nreach a vertex of any colour by just moving to an adjacent vertex. Given\r\nthe permuted n-dimensional hypercube, find any valid permutation P and\r\ncolouring.\r\n",
    "solutions": [
        "// Problem: E. The Final Pursuit\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nvector<int> e[65536];\nint vis[65536];\nint id[65536],inv[65536];\nint col[65536];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tint m=n*(1<<(n-1));\n\t\tint N=1<<n;\n\t\tfor(int i=0; i<N; ++i) e[i].clear(),vis[i]=0,id[i]=0;\n\t\tfor(int i=1; i<=m; ++i) \n\t\t{\n\t\t\tint u=read(),v=read();\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tint visc=1;\n\t\tvector<int> cur,nxt;\n#define pb push_back\n\t\tvis[0]=2;\n\t\tint powpowpow2=1;\n\t\tfor(int i:e[0])\n\t\t{\n\t\t\tvis[i]=1,cur.pb(i),id[i]=powpowpow2,++visc;\n\t\t\tpowpowpow2<<=1;\n\t\t}\n\t\twhile(visc!=N)\n\t\t{\n\t\t\tnxt.clear();\n\t\t\tfor(int i:cur) vis[i]=2;\n\t\t\tfor(int i:cur) for(int j:e[i]) if(vis[j]!=2)\n\t\t\t{\n\t\t\t\tid[j]|=id[i];\n\t\t\t\tif(!vis[j]) vis[j]=1,++visc,nxt.pb(j);\n\t\t\t}\n\t\t\tcur=nxt;\n\t\t}\n\t\tfor(int i=0; i<N; ++i) inv[id[i]]=i;\n\t\tfor(int i=0; i<N; ++i) printf(\"%d \",inv[i]);\n\t\tputs(\"\"); \n\t\tint o=n;\n\t\twhile(!(o&1)) o>>=1;\n\t\tif(o!=1) puts(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor(int i=0; i<N; ++i)\n\t\t\t{\n\t\t\t\tint s=0;\n\t\t\t\tfor(int j=0; j<n; ++j) if(i&(1<<j)) s^=j;\n\t\t\t\tcol[inv[i]]=s;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; ++i)\n\t\t\t{\n\t\t\t\tset<int> s;\n\t\t\t\tfor(int j:e[i]) s.insert(col[j]);\n\t\t\t\tassert((int)s.size()==n);\n\t\t\t}\n\t\t\tfor(int i=0; i<N; ++i) printf(\"%d \",col[i]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "divide and conquer",
        "graphs",
        "greedy",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Final Pursuit.json",
    "editorial_link": "https://codeforces.com//blog/entry/92582",
    "editorial": "Tutorial: Part 1 - Finding the PermutationBefore moving to the solution,\r\nnotice a very important property of simple -Dimensional Hypercubes Two\r\nvertices and are connected if and only if and differ by exactly one bit\r\nin their binary representations.The permutation can be found using the\r\nfollowing greedy algorithm First, assign any arbitrary vertex as . This\r\nis obvious since all vertices are equivalent. Then, in the simple\r\n-Dimensional Hypercube, all powers of must be connected to the vertex .\r\nMoreover, these vertices are added only when we are adding another\r\ndimension to the cube. Since all directions are also equivalent, it does\r\nnot matter in which direction we add a new dimension. So, we can assign\r\nall the vertices connected to in the permuted -Dimensional Hypercube as\r\n, , , , , in any arbitrary order. Now, we will find for the remaining\r\nvertices in increasing order of .In order to find , first find a set of\r\nvertices such that and is connected to in the simple -Dimensional\r\nHypercube. Then find any vertex connected to all the vertices such that\r\nin the permuted -Dimensional Hypercube and assign . I claim that we can\r\nnever make a wrong choice because we will never have a choice! There\r\nwill only be one such vertex for any . Letâs prove it. ProofConsider two\r\nvertices and in the set . These vertices will differ by exactly bits in\r\ntheir binary representation. Let the bits in which they differ be and .\r\nThen, they will have the form and where represent the same bits. Now,\r\nonly two vertices and can be connected to both and . Since a permuted\r\n-Dimensional Hypercube is isomorphic to a simple -Dimensional Hypercube,\r\nthere will only be two vertices connected to both and in the permuted\r\n-Dimensional Hypercube also.If we iterate over in increasing order, then\r\n, otherwise one of or will be greater than which is a contradiction. So,\r\nthe only vertices connected to both and will have the forms and . Now\r\nsince and , has already been calculated and so, one of the vertex\r\nconnected to both and in the permuted -Dimensional Hypercube has already\r\nbeen used. So, we are left with only one choice for such a vertex .\r\nAlternate method of finding the permutation (by mshiladityam)Letâs call\r\nthe vertex connected to a given vertex and which is in the opposite\r\nconstituent smaller hypercube the image of the given vertex.Lemma if\r\nthere is an edge in the -Dimensional hypercube where vertices and lie in\r\ndifferent constituent -Dimensional Hypercubes (in other words, and are\r\nimages of each other), then for all vertices adjacent to , the image of\r\nis adjacent to .This lemma can be proved by using the fact that two\r\nvertex are connected if and only if they differ by exactly bit.Select\r\nany two vertices and . They form a starting point: we treat them as two\r\nvertices in opposite constituents (by symmetry, we can prove that any\r\npairs can be treated as such).Now let us perform multisource BFS with\r\nand as source nodes. Due to the lemma, the nodes which are discovered\r\nfrom first lie in the component of , and those which are discovered from\r\nfirst lie in the component of (it is easy again to prove it using\r\ninduction on depth of already discovered vertices). So we have separated\r\nthese two constituent smaller dimension hypercubes. Lets call a\r\nrecursive function on any one of them: this recursive function returns a\r\npermutation which transforms the permutated hypercube to the simple\r\nhypercube. Now, we find for each vertex, in the constituent hypercube\r\nwhose permutation we just found, its image. Then we can find the\r\npermutation for the other constituent by just adding to the\r\ncorresponding image. Hence we perform the merging process of\r\nrecursion.The time complexity of this approach is\r\n",
    "hint": []
}