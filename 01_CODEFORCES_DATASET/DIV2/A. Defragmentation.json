{"link": "https://codeforces.com//contest/180/problem/A", "problemId": "1260", "problem_idx": "A", "shortId": "180A", "contest_number": "180", "problem_submissions": {"A": [1612011, 1611035, 1611491, 1610423, 1608646, 1612209, 1610289, 1609636, 1609133, 1612193, 1612229, 1611072, 1612163, 1611991, 1610400, 1612436, 1617622], "E": [1610692, 1609351, 1609009, 1613114, 1609269, 1610641, 1610622, 1610904, 1610311, 1609559, 1609099, 1609957, 1610472, 1610971, 1609912, 1608828], "D": [1610104, 1610284, 1610538, 1611279, 1611479, 1611395, 1611538, 1611063, 1611009, 1611925, 1611800, 1650220], "B": [1609708, 1612372, 1611456, 1610499], "F": [1608611, 1608642, 1608360, 1608443, 1609619, 1608802, 1608911, 1609865, 1608836, 1608333, 1608944, 1608579, 1608822, 1608381], "C": [1608408, 1608345, 1608245, 1608291, 1608998, 1608357, 1608524, 1609626, 1608493, 1608501, 1608480, 1609176, 1608550, 1608260]}, "name": "A. Defragmentation", "statement": "In this problem you have to implement an algorithm to defragment your\r\nhard disk. The hard disk consists of a sequence of clusters, numbered by\r\nintegers from to . The disk has recorded files, the -th file occupies\r\nclusters with numbers , , ..., . These clusters are not necessarily\r\nlocated consecutively on the disk, but the order in which they are given\r\ncorresponds to their sequence in the file (cluster contains the first\r\nfragment of the -th file, cluster has the second fragment, etc.). Also\r\nthe disc must have one or several clusters which are free from files.You\r\nare permitted to perform operations of copying the contents of cluster\r\nnumber to cluster number ( and must be different). Moreover, if the\r\ncluster number used to keep some information, it is lost forever.\r\nClusters are not cleaned, but after the defragmentation is complete,\r\nsome of them are simply declared unusable (although they may possibly\r\nstill contain some fragments of files).Your task is to use a sequence of\r\ncopy operations to ensure that each file occupies a contiguous area of\r\nmemory. Each file should occupy a consecutive cluster section, the files\r\nmust follow one after another from the beginning of the hard disk. After\r\ndefragmentation all free (unused) clusters should be at the end of the\r\nhard disk. After defragmenting files can be placed in an arbitrary\r\norder. Clusters of each file should go consecutively from first to last.\r\nSee explanatory examples in the notes.Print the sequence of operations\r\nleading to the disk defragmentation. Note that the number of operations,\r\nbut it should not exceed .\r\n", "solutions": ["#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint ntest = 0, test = 0;\ninline void init();\ninline void run();\ninline void stop() {\n\tntest = test - 1;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input\", \"r\", stdin);\n//\tfreopen(\"output\", \"w\", stdout);\n#endif\n\tinit();\n\twhile (++test <= ntest) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); it++)\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<typeof(*(v).begin())>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = (int) 1E9 + 5;\nconst double EPS = 1E-11;\nconst ll MOD = (ll) 1E9 + 7;\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\ninline void init() {\n\tntest = 1;\n}\n\nint n, m;\nint whatPos[205], contain[205];\nint step;\nvector<pii> ret;\n\ninline int doMove(int what, int to) {\n\tint oldPos = whatPos[what];\n\n\tret.PB(MP(whatPos[what], to));\n\tstep++;\n\n\twhatPos[what] = to;\n\tcontain[to] = what;\n\n\tcontain[oldPos] = 0;\n\treturn oldPos;\n}\n\ninline void run() {\n\tscanf(\"%d%d\", &n, &m);\n\n\tSET(contain, 0);\n\n\tint cnt = 0, t;\n\tREP(i, m) {\n\t\tscanf(\"%d\", &t);\n\t\tREP(j, t) {\n\t\t\tcnt++;\n\t\t\tscanf(\"%d\", &whatPos[cnt]);\n\t\t\tcontain[whatPos[cnt]] = cnt;\n\t\t}\n\t}\n\n\tint w;\n\tFOR(i, 1, n) {\n\t\tif (contain[i] == 0) {\n\t\t\tw = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstep = 0;\n\tret.clear();\n\n\twhile (1) {\n\t\tif (w <= cnt) {\n\t\t\tw = doMove(w, w);\n\t\t} else {\n\t\t\tbool found = false;\n\t\t\tFOR(i, 1, cnt) {\n\t\t\t\tif (whatPos[i] != i && whatPos[i] <= cnt) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tw = doMove(i, w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tFOR(i, 1, cnt) {\n\t\t\t\t\tif (contain[i] == 0) {\n\t\t\t\t\t\tw = i;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << SZ(ret) << endl;\n\tFIT(it, ret) {\n\t\tcout << it->F << \" \" << it->S << endl;\n\t}\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1800", "interactive": false}