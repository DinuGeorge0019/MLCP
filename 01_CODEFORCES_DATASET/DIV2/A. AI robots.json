{"link": "https://codeforces.com//contest/1046/problem/A", "problemId": "223473", "problem_idx": "A", "shortId": "1046A", "contest_number": "1046", "problem_submissions": {"B": [43252358, 43255928], "A": [43250309, 43254410, 43250987], "H": [43247639, 43245779, 43247215, 43247770], "F": [43246486, 43244046, 43246380, 43248077], "C": [43245566, 43247893, 43247771, 43244424, 43243585], "I": [43253744, 43258105, 43258173], "G": [43269050]}, "name": "A. AI robots", "statement": "In the last mission, MDCS has successfully shipped N AI robots to Mars.\r\nBefore they start exploring, system initialization is required so they\r\nare arranged in a line. Every robot can be described with three numbers:\r\nposition (x_i), radius of sight (r_i) and IQ (q_i).Since they are\r\nintelligent robots, some of them will talk if they see each other.\r\nRadius of sight is inclusive, so robot can see other all robots in range\r\n[x_i - r_i, x_i + r_i]. But they don\u2019t walk to talk with anybody, but\r\nonly with robots who have similar IQ. By similar IQ we mean that their\r\nabsolute difference isn\u2019t more than K. Help us and calculate how many\r\npairs of robots are going to talk with each other, so we can timely\r\nupdate their software and avoid any potential quarrel.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct robot {\n\tint x, r, s;\n\n\tinline bool operator < (const robot &a) const {\n\t\treturn x < a.x;\n\t}\n};\n\nstruct node {\n\tint x;\n\tnode *l, *r;\n\tnode() {\n\t\tx = 0;\n\t\tl = r = 0;\n\t}\n\tnode(int xx) {\n\t\tx = xx;\n\t\tl = r = 0;\n\t}\n};\n\ninline void upd(node *t, int Tl, int Tr, int x, int delta) {\n\tif (Tl > x || Tr < x) {\n\t\treturn;\n\t}\n\tif (Tl == x && Tr == x) {\n\t\tt -> x += delta;\n\t\treturn;\n\t}\n\n\tint mid = (Tl + Tr) / 2;\n\tif (x <= mid) {\n\t\tif (!t -> l)\n\t\t\tt -> l = new node();\n\t\tupd(t -> l, Tl, mid, x, delta);\n\n\t} else {\n\t\tif (!t -> r)\n\t\t\tt -> r = new node();\n\t\tupd(t -> r, mid + 1, Tr, x, delta);\n\t}\n\tt -> x = 0;\n\tif (t -> l)\n\t\tt -> x += t -> l -> x;\n\tif (t -> r)\n\t\tt -> x += t -> r -> x;\n}\n\ninline int get(node *t, int Tl, int Tr, int l, int r) {\n\tif (Tl > r || Tr < l)\n\t\treturn 0;\n\tif (!t)\n\t\treturn 0;\n\tif (l <= Tl && Tr <= r)\n\t\treturn t -> x;\n\tint mid = (Tl + Tr) / 2;\n\treturn get(t -> l, Tl, mid, l, r) + get(t -> r, mid + 1, Tr, l, r);\n}\n\nconst int N = 1e5 + 100;\n\nrobot a[N];\nunordered_map <int, node*> c;\n\n\ninline void upd(int s, int x, int val) {\n\tif (c[s] == nullptr)\n\t\tc[s] = new node();\n\tx = max(x, 0);\n\tx = min(x, (int)1e9);\n\tupd(c[s], 0, 1e9, x, val);\n}\n\ninline int get(int s, int x) {\n\tx = max(x, 0);\n\tx = min(x, (int)1e9);\n\treturn get(c[s], 0, 1e9, x, 1e9);\n}\n\n\ninline int get(int s, int x, int r) {\n\t/*\n\tif (!c.count(s))\n\t\treturn 0;\n\tvector<int> *a = &c[s];\n\tint n = (*a).size();\n\treturn n - (lower_bound((*a).begin(), (*a).end(), x) - (*a).begin());\n\t*/\n\treturn get(s, x - r);\n}\n\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"in\", \"r\", stdin);\n    #endif\n\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    \n    int n, k;\n    cin >> n >> k;\n    \n    for (int i = 0; i < n; ++i) {\n    \tint x, r, s;\n    \tcin >> x >> r >> s;\n\t\ta[i] = {x, r, s};\n    }\n\n\tsort(a, a + n);\n\n\n\tmultiset<pair <int, pair <int, int> > > Set;\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (Set.size() && Set.begin() -> first < a[i].x) {\n\t\t\tauto val = Set.begin() -> second;\n\t\t\tupd(val.first, val.second, -1);\n\t\t\tSet.erase(Set.begin());\n\t\t}\n\t\tfor (int j = a[i].s - k; j <= a[i].s + k; ++j) {\n\t\t\tans += get(j, a[i].x, a[i].r);\n\t\t}\n\t\tSet.insert(make_pair(a[i].x + a[i].r, make_pair(a[i].s, a[i].x)));\n\t\tupd(a[i].s, a[i].x, 1);\n\t}\n\n\tcout << ans;\t\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2200", "interactive": false}