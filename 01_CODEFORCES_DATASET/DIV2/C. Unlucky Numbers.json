{
    "link": "https://codeforces.com//contest/1808/problem/C",
    "problemId": "1854692",
    "problem_idx": "C",
    "shortId": "1808C",
    "contest_number": "1808",
    "problem_submissions": {
        "D": [
            199663586,
            199652295,
            199649543,
            199658153,
            199660313,
            199664555,
            199663522,
            199658681,
            199662131,
            199663211,
            199665809,
            199666904,
            199686788,
            200680943,
            199672659,
            199667818,
            199670491,
            199654888,
            199672673
        ],
        "E3": [
            199660988,
            199675708,
            199684437,
            199678631,
            199683096,
            201130452,
            199666847,
            199711014
        ],
        "E2": [
            199660914,
            199675587,
            199684591,
            199669150,
            199671171,
            199672422,
            199667417,
            199667886,
            199667544,
            199677124,
            199673172,
            199673912,
            199667116,
            200681161,
            200681118,
            199662837,
            199681512,
            199697948,
            199682318
        ],
        "E1": [
            199660827,
            199647476,
            199655105,
            199665173,
            199671231,
            199655192,
            199650032,
            199667518,
            199667485,
            199670735,
            199673329,
            199674123,
            199667097,
            200681014,
            199659398,
            199681451,
            199697918,
            199676180,
            199669612,
            199661602
        ],
        "C": [
            199660389,
            199669471,
            199646653,
            199653605,
            199654568,
            199648568,
            199646672,
            199649651,
            199653794,
            199654418,
            199657068,
            199657978,
            199676868,
            200680878,
            200680798,
            199678734,
            199656497,
            199658569,
            199658535,
            199649977
        ],
        "A": [
            199643949,
            199642214,
            199639989,
            199639150,
            199640540,
            199639256,
            199639177,
            199639048,
            199640380,
            199639173,
            199640678,
            199639746,
            199643343,
            200680660,
            199641247,
            199641300,
            199640545,
            199639604,
            199639018
        ],
        "B": [
            199639404,
            199640164,
            199644601,
            199640956,
            199642784,
            199641076,
            199640175,
            199641302,
            199643530,
            199641294,
            199644684,
            199643246,
            199643095,
            200680723,
            199647537,
            199644556,
            199644782,
            199642649,
            199640242
        ]
    },
    "name": "C. Unlucky Numbers",
    "statement": "Olympus City recently launched the production of personal starships. Now\r\neveryone on Mars can buy one and fly to other planets inexpensively.Each\r\nstarship has a number some positive integer x. Let’s define the of a\r\nnumber x as the difference between the largest and smallest digits of\r\nthat number. For example, 142857 has 8 as its largest digit and 1 as its\r\nsmallest digit, so its luckiness is 8-1=7. And the number 111 has all\r\ndigits equal to 1, so its luckiness is zero.Hateehc is a famous Martian\r\nblogger who often flies to different corners of the solar system. To\r\nrelease interesting videos even faster, he decided to buy himself a\r\nstarship. When he came to the store, he saw starships with numbers from\r\nl to r inclusively. While in the store, Hateehc wanted to find a\r\nstarship with the number.Since there are a lot of starships in the\r\nstore, and Hateehc can’t program, you have to help the blogger and write\r\na program that answers his question.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define pii pair<int, int>\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define mk make_pair\n#define sml(x, y) (x = min(x, y))\n#define big(x, y) (x = max(x, y))\n#define ll long long\n#define uint unsigned\n#define ull unsigned long long\n#define umap unordered_map\n#define db double\n#define fo(i, x, y) for (int i = (x); i <= (y); ++i)\n#define go(i, x, y) for (int i = (x); i >= (y); --i)\n#define ptc putchar\n#define gc getchar\n#define emp emplace\n#define re return\n#define co continue\n#define brk break\n#define HH (ptc('\\n'))\n#define bctz __builtin_ctz\n#define bclz __builtin_clz\n#define bppc __builtin_popcount\n#define int ll\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ntemplate <typename T>\nvoid out(T *a, int l, int r) {\n  fo(i, l, r) cout << *(a + i) << ' ';\n  puts(\"\");\n}\n\nconst int N = 1e6 + 5;\nint pw[100], al[N], ar[N], pos, a[N], L, R, bit;\n\nbool dfs(int id, int fl1, int fl2) {\n  //\tprintf(\"dfs(%d,%d,%d)\\n\",id,fl1,fl2);\n  // fl1:是否顶下界\n  // fl2:是否顶上界\n  if (id == -1)\n    re\n      1;\n  if (!fl1 && !fl2) {\n    a[id] = L;\n    re\n      dfs(id - 1, fl1, fl2);\n  }\n  if (fl1 & fl2) {\n    a[id] = al[id];\n    if (a[id] >= L && a[id] <= R && dfs(id - 1, 1, 0))\n      re\n        1;\n    a[id] = ar[id];\n    if (a[id] >= L && a[id] <= R && dfs(id - 1, 0, 1))\n      re\n        1;\n\n    fo(i, L, R) if (i > al[id] && i < ar[id]) {\n      a[id] = i;\n      re\n        dfs(id - 1, 0, 0);\n    }\n    re\n      0;\n  }\n  if (fl1) {\n    fo(i, max(L, al[id]), R) {\n      a[id] = i;\n      if (i == al[id]) {\n        if (dfs(id - 1, 1, 0))\n          re\n            1;\n      } else if (i > al[id])\n        re\n          dfs(id - 1, 0, 0);\n    }\n    re\n      0;\n  }\n  if (fl2) {\n    go(i, min(R, ar[id]), L) {\n      a[id] = i;\n      if (i == ar[id]) {\n        if (dfs(id - 1, 0, 1))\n          re\n            1;\n      } else if (i < ar[id])\n        re\n          dfs(id - 1, 0, 0);\n    }\n    re\n      0;\n  }\n  re\n    0;\n}\n\nbool chk() {\n  //\tprintf(\"chk(%d,%d)\\n\",L,R);\n  go(i, bit, pos + 1) assert(al[i] == ar[i]);\n  go(i, bit, pos + 1) if (al[i] < L || al[i] > R) re 0;\n  fo(i, pos + 1, 18) a[i] = al[i];\n  re\n    dfs(pos, 1, 1);\n}\n\nvoid solve() {\n  fo(i, 0, 18) a[i] = al[i] = ar[i] = 0;\n  int l = read(), r = read();\n  if (l == r) {\n    cout << l << '\\n';\n    re\n      ;\n  }\n  fo(i, 0, 18) al[i] = l / pw[i] % 10;\n  fo(i, 0, 18) ar[i] = r / pw[i] % 10;\n  //\tcout<<\"al:\";out(al,0,18);\n  //\tcout<<\"ar:\";out(ar,0,18);\n  go(i, 18, 0) if (al[i] != ar[i]) {\n    pos = i;\n    brk;\n  }\n  go(i, 18, 0) if (ar[i]) {\n    bit = i;\n    if (!al[i]) {\n      fo(j, 0, i - 1) ptc('9');\n      HH;\n      re\n        ;\n    }\n    brk;\n  }\n  //\tL=4,R=4;cout<<chk()<<'\\n';re;\n  fo(len, 0, 9) fo(i, 0, 9 - len) {\n    L = i, R = i + len;\n    if (chk()) {\n      go(j, 18, 0) if (a[j]) {\n        go(k, j, 0) ptc(a[k] + '0');\n        HH;\n        re\n          ;\n      }\n      re\n        ;\n    }\n  }\n}\n\nsigned main() {\n  pw[0] = 1;\n  fo(i, 1, 18) pw[i] = pw[i - 1] * 10;\n  int T = read();\n  while (T--) solve();\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Unlucky Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/114523",
    "editorial": "Check all pairs (, ) the minimum and maximum digits of the number from\r\nthe answer. Discard the common prefix of and . Now we are left with some\r\ndigits and as the leftmost digits of the number, with < . If , then we\r\ncan put at the beginning of the number, and then put any digit from the\r\ninterval .Otherwise, we try , and then always put the largest digit of\r\nthat we can. Similarly, then try putting , and then always put the\r\nsmallest digit of you can.Of all and , for which it is possible to\r\nconstruct a given number, choose such that is minimal, and the number\r\nconstructed at these and .\r\n",
    "hint": []
}