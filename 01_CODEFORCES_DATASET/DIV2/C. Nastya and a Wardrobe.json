{
    "link": "https://codeforces.com//contest/992/problem/C",
    "problemId": "191473",
    "problem_idx": "C",
    "shortId": "992C",
    "contest_number": "992",
    "problem_submissions": {
        "E": [
            39379971,
            39367354,
            39383435,
            39383874,
            39377809,
            39387889,
            39394476,
            39394446,
            39415001,
            39392776
        ],
        "D": [
            39367228,
            39375773,
            39372594,
            39378835,
            39367744,
            39373260,
            39369394,
            39372029,
            39372974,
            39365892,
            39371246,
            39373661,
            39373903,
            39372053,
            39374817,
            39372239,
            39375168,
            39375159,
            39373219
        ],
        "C": [
            39364165,
            39377468,
            39374599,
            39369673,
            39390179,
            39368182,
            39365924,
            39366169,
            39367079,
            39370888,
            39367372,
            39369592,
            39366923,
            39366841,
            39366909,
            39368981,
            39367582
        ],
        "B": [
            39362525,
            39369978,
            39364265,
            39363783,
            39364539,
            39390973,
            39364179,
            39363741,
            39364940,
            39371207,
            39363548,
            39366410,
            39364261,
            39363633,
            39364663,
            39364278,
            39364004,
            39364073,
            39364080
        ],
        "A": [
            39360959,
            39367984,
            39361000,
            39360904,
            39364171,
            39360934,
            39362882,
            39361086,
            39361354,
            39361964,
            39363683,
            39362014,
            39362194,
            39360828,
            39362485,
            39364246,
            39462075,
            39360847,
            39362002,
            39361147
        ]
    },
    "name": "C. Nastya and a Wardrobe",
    "statement": "Nastya received a gift on New Year a magic wardrobe. It is magic because\r\nin the end of each month the number of dresses in it doubles (i.e. the\r\nnumber of dresses becomes twice as large as it is in the beginning of\r\nthe month).Unfortunately, right after the doubling the wardrobe eats one\r\nof the dresses (if any) with the probability. It happens every month\r\nexcept the last one in the year. Nastya owns dresses now, so she became\r\ninterested in the expected number of dresses she will have in one year.\r\nNastya lives in Byteland, so the year lasts for months.Nastya is really\r\nbusy, so she wants you to solve this problem. You are the programmer,\r\nafter all. Also, you should find the answer modulo , because it is easy\r\nto see that it is always integer.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int m>\nstruct modint {\n\n\tunsigned x;\n\n\tmodint() : x(0) {}\n\n\tmodint(long long arg) {\n\t\targ %= m;\n\t\tif (arg < 0) {\n\t\t\tx = arg + m;\n\t\t} else {\n\t\t\tx = arg;\n\t\t}\n\t}\t\n\n\tmodint& operator+= (const modint& other) {\n\t\tx += other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator*= (const modint& other) {\n\t\tx = (x * 1ll * other.x) % m;\n\t\treturn *this;\n\t}\n\n\tmodint& operator-= (const modint& other) {\n\t\tx += m - other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator+ (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp += other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator- (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp -= other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator* (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp *= other;\n\t\treturn tmp;\n\t}\n\n\texplicit operator int () const {\n\t\treturn x;\n\t}\n\n\tmodint& operator++ () {\n\t\t++x;\n\t\tif (x == m) {\n\t\t\tx = 0;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator-- () {\n\t\tif (x == 0) {\n\t\t\tx = m-1;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator++ (int) {\n\t\tmodint tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\n\tmodint operator-- (int) {\n\t\tmodint tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\n\tbool operator== (const modint& other) const {\n\t\treturn x == other.x;\n\t}\n\n\tbool operator!= (const modint& other) const {\n\t\treturn x != other.x;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^ (T arg) const {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg == 1) {\n\t\t\treturn x;\n\t\t}\n\t\tauto t = *this ^ (arg >> 1);\n\t\tt *= t;\n\t\tif (arg & 1) {\n\t\t\tt *= *this;\n\t\t}\n\t\treturn t;\n\t}\n\n\tmodint inv() const {\n\t\treturn *this ^ (m-2);\n\t}\n};\n\nconst int MOD = 1'000'000'007;\ntypedef modint<MOD> mint;\n\ntypedef long long ll;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tll x, k;\n\tcin >> x >> k;\n\n\tif (x == 0)\n\t\treturn cout << \"0\\n\", 0;\n\n\tmint z = x;\n\tz *= mint(2) ^ (k+1);\n\tz -= mint(2) ^ k;\n\tz += 1;\n\n\tcout << (int)z << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Nastya and a Wardrobe.json",
    "editorial_link": "https://codeforces.com/blog/entry/60083",
    "editorial": "Letâs present we have initially dresses.What does occur in the first\r\nmonth? Initially the number of dresses is multiplied by 2, that is\r\nbecomes . Then with probability the wardrobe eats a dress, that is\r\nexpected value of the number of dresses becomes . The same way after the\r\nsecond month expected value becomes . Itâs easy to notice that after -th\r\nmonth(if ) expected value equals . Eventually it will be only doubled(as\r\nthe wardrobe doesnât eat a dress in the last month), that is will be\r\nequal .Thus, answer of the problem is . Expressing it with , we get: = .\r\n= .Thus, we need to calculate degree of 2 right up to . Complexity of\r\nthe soltion is .Letâs notice that the case we need to calculate\r\nseparately, because wardrobe canât eat a dress when it doesnât exist. If\r\nitâs easy to proof that the number of dresses is never negative, that is\r\nthe formula works.\r\n",
    "hint": []
}