{"link": "https://codeforces.com//contest/1894/problem/E", "problemId": "2312802", "problem_idx": "E", "shortId": "1894E", "contest_number": "1894", "problem_submissions": {"E": [231780542, 231780764, 231783721, 231789834, 231788705, 231788269, 231784914, 231788986, 231801971, 231786358, 231788036, 231815440, 231786637, 231808858, 231789692, 231801877, 231817632, 231801951], "D": [231763745, 231766056, 231762523, 231754895, 231759834, 231769389, 231770188, 231758327, 231760530, 231775160, 231770452, 231759047, 231773241, 231762950, 231774799, 231763275, 231763670, 231771730], "C": [231756298, 231755831, 231757004, 231877074, 231770559, 231763470, 231760236, 231765769, 231774024, 231754920, 231758557, 231758057, 231762243, 231765459, 231756919, 231760340, 231755946, 231756421, 231763397], "A": [231751883, 231747419, 231747509, 231747329, 231751165, 231747346, 231747376, 231747139, 231747693, 231747813, 231746849, 231749093, 231749182, 231746695, 231748186, 231747273, 231747195, 231746971], "B": [231748751, 231750138, 231749611, 231749322, 231755477, 231750451, 231753159, 231749369, 231750440, 231749706, 231748963, 231754750, 231753097, 231749553, 231754197, 231749717, 231750764, 231754291]}, "name": "E. Freedom of Choice", "statement": "Let\u2019s define the anti-beauty of a multiset\r\n{b_1, b_2,\r\nldots, b_{len}\r\n} as the number of occurrences of the number len in the multiset.You are\r\ngiven m multisets, where the i-th multiset contains n_i distinct\r\nelements, specifically: c_{i, 1} copies of the number a_{i,1}, c_{i, 2}\r\ncopies of the number a_{i,2},\r\nldots, c_{i, n_i} copies of the number a_{i, n_i}. It is guaranteed that\r\na_{i, 1} < a_{i, 2} <\r\nldots < a_{i, n_i}. You are also given numbers l_1, l_2,\r\nldots, l_m and r_1, r_2,\r\nldots, r_m such that 1\r\nle l_i\r\nle r_i\r\nle c_{i, 1} +\r\nldots + c_{i, n_i}.Let\u2019s create a multiset X, initially empty. Then, for\r\neach i from 1 to m, you must perform the following action : Choose some\r\nv_i such that l_i\r\nle v_i\r\nle r_i Choose any v_i numbers from the i-th multiset and add them to the\r\nmultiset X.You need to choose v_1,\r\nldots, v_m and the added numbers in such a way that the resulting\r\nmultiset X has the anti-beauty.\r\n", "solutions": ["#include <iostream>\n#include <limits>\n#include <unordered_map>\nusing namespace std;\n\nusing ll = long long;\n\nll a[100010], c[100010];\n\nvoid solve() {\n    int m;\n    cin >> m;\n\n    unordered_map<ll, ll> choose, consume;\n    ll total_l = 0, total_r = 0;\n\n    for (int i = 1; i <= m; i++) {\n        int n;\n        ll l, r;\n        cin >> n >> l >> r;\n\n        for (int j = 1; j <= n; j++) {\n            cin >> a[j];\n        }\n        for (int j = 1; j <= n; j++) {\n            cin >> c[j];\n        }\n\n        total_l += l;\n        total_r += r;\n\n        ll sum = 0;\n        for (int j = 1; j <= n; j++) {\n            sum += c[j];\n        }\n        for (int j = 1; j <= n; j++) {\n            choose[a[j]] += max<ll>(0, l - (sum - c[j]));\n            consume[a[j]] += max<ll>(0, r - (sum - c[j]));\n        }\n    }\n\n    ll ans = numeric_limits<ll>::max();\n    for (ll i = total_l; i <= total_r; i++) {\n        if (choose.count(i) == 0) {\n            ans = 0;\n            break;\n        } else {\n            ans = min(ans, max(choose[i], i - (total_r - consume[i])));\n        }\n    }\n\n    cout << ans << '\\n';\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n}"], "input": "", "output": "", "tags": ["brute force", "data structures", "greedy", "implementation"], "dificulty": "2000", "interactive": false}