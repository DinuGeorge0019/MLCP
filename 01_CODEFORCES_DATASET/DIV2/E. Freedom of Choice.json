{
    "link": "https://codeforces.com//contest/1894/problem/E",
    "problemId": "2312802",
    "problem_idx": "E",
    "shortId": "1894E",
    "contest_number": "1894",
    "problem_submissions": {
        "E": [
            231780542,
            231780764,
            231783721,
            231789834,
            231788705,
            231788269,
            231784914,
            231788986,
            231801971,
            231786358,
            231788036,
            231815440,
            231786637,
            231808858,
            231789692,
            231801877,
            231817632,
            231801951
        ],
        "D": [
            231763745,
            231766056,
            231762523,
            231754895,
            231759834,
            231769389,
            231770188,
            231758327,
            231760530,
            231775160,
            231770452,
            231759047,
            231773241,
            231762950,
            231774799,
            231763275,
            231763670,
            231771730
        ],
        "C": [
            231756298,
            231755831,
            231757004,
            231877074,
            231770559,
            231763470,
            231760236,
            231765769,
            231774024,
            231754920,
            231758557,
            231758057,
            231762243,
            231765459,
            231756919,
            231760340,
            231755946,
            231756421,
            231763397
        ],
        "A": [
            231751883,
            231747419,
            231747509,
            231747329,
            231751165,
            231747346,
            231747376,
            231747139,
            231747693,
            231747813,
            231746849,
            231749093,
            231749182,
            231746695,
            231748186,
            231747273,
            231747195,
            231746971
        ],
        "B": [
            231748751,
            231750138,
            231749611,
            231749322,
            231755477,
            231750451,
            231753159,
            231749369,
            231750440,
            231749706,
            231748963,
            231754750,
            231753097,
            231749553,
            231754197,
            231749717,
            231750764,
            231754291
        ]
    },
    "name": "E. Freedom of Choice",
    "statement": "Let’s define the anti-beauty of a multiset\r\n{b_1, b_2,\r\nldots, b_{len}\r\n} as the number of occurrences of the number len in the multiset.You are\r\ngiven m multisets, where the i-th multiset contains n_i distinct\r\nelements, specifically: c_{i, 1} copies of the number a_{i,1}, c_{i, 2}\r\ncopies of the number a_{i,2},\r\nldots, c_{i, n_i} copies of the number a_{i, n_i}. It is guaranteed that\r\na_{i, 1} < a_{i, 2} <\r\nldots < a_{i, n_i}. You are also given numbers l_1, l_2,\r\nldots, l_m and r_1, r_2,\r\nldots, r_m such that 1\r\nle l_i\r\nle r_i\r\nle c_{i, 1} +\r\nldots + c_{i, n_i}.Let’s create a multiset X, initially empty. Then, for\r\neach i from 1 to m, you must perform the following action : Choose some\r\nv_i such that l_i\r\nle v_i\r\nle r_i Choose any v_i numbers from the i-th multiset and add them to the\r\nmultiset X.You need to choose v_1,\r\nldots, v_m and the added numbers in such a way that the resulting\r\nmultiset X has the anti-beauty.\r\n",
    "solutions": [
        "#include <iostream>\n#include <limits>\n#include <unordered_map>\nusing namespace std;\n\nusing ll = long long;\n\nll a[100010], c[100010];\n\nvoid solve() {\n    int m;\n    cin >> m;\n\n    unordered_map<ll, ll> choose, consume;\n    ll total_l = 0, total_r = 0;\n\n    for (int i = 1; i <= m; i++) {\n        int n;\n        ll l, r;\n        cin >> n >> l >> r;\n\n        for (int j = 1; j <= n; j++) {\n            cin >> a[j];\n        }\n        for (int j = 1; j <= n; j++) {\n            cin >> c[j];\n        }\n\n        total_l += l;\n        total_r += r;\n\n        ll sum = 0;\n        for (int j = 1; j <= n; j++) {\n            sum += c[j];\n        }\n        for (int j = 1; j <= n; j++) {\n            choose[a[j]] += max<ll>(0, l - (sum - c[j]));\n            consume[a[j]] += max<ll>(0, r - (sum - c[j]));\n        }\n    }\n\n    ll ans = numeric_limits<ll>::max();\n    for (ll i = total_l; i <= total_r; i++) {\n        if (choose.count(i) == 0) {\n            ans = 0;\n            break;\n        } else {\n            ans = min(ans, max(choose[i], i - (total_r - consume[i])));\n        }\n    }\n\n    cout << ans << '\\n';\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Freedom of Choice.json",
    "editorial_link": "https://codeforces.com//blog/entry/122074",
    "editorial": "Note that after performing all operations, the multiset X\n can have any integer size from ?li\n to ?ri\n. And the number of distinct numbers that can potentially be in X\n is definitely not greater than ?ni\n. Therefore, if ?ri??li>?ni\n, there will always be a number from ?li\n to ?ri\n that is not present in any of the m\n given multisets, and thus will not be in X\n. By making X\n of such size, we will have the anti-beauty of X\n equal to 0\n, which is the minimum achievable anti-beauty. So, if ?ri??li>?ni\n, we can output 0\n and terminate. Then we solve the problem under the condition ?ri??li??ni\n.\n\n?ni\n is limited to 105\n. Therefore, we can explicitly iterate through all possible sizes of the multiset X\n, from ?li\n to ?ri\n, and for a fixed size s\n, determine the minimum anti-beauty if X\n has size s\n. Then we take the minimum of these values as the answer.\n\nFor a fixed size s\n, to minimize the anti-beauty, we want to include as many numbers not equal to s\n in X\n as possible. For the multisets where s\n is not present, we want to take ri\n. To calculate this sum, we can take the sum of all ri\n and subtract from it the sum of ri\n for the multisets in which s\n is present. And for those multisets where s\n is present, we can explicitly iterate through them and use simple formulas to calculate how many s\n we are obligated to take from each multiset. This will take at most O(?ni)\n. For specific formulas, refer to the code.",
    "hint": []
}