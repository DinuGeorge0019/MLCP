{
    "link": "https://codeforces.com//contest/948/problem/E",
    "problemId": "164147",
    "problem_idx": "E",
    "shortId": "948E",
    "contest_number": "948",
    "problem_submissions": {
        "E": [
            36168620,
            36172204,
            36251405,
            36251326,
            36173384,
            36169252,
            36404487,
            36183304
        ],
        "D": [
            36163433,
            36167670,
            36167120,
            36164480,
            36164445,
            36162609,
            36165068,
            36162200,
            36164897,
            36162927,
            36164670,
            36161208,
            36169789,
            36165340,
            36163154,
            36157640,
            36165228,
            36165543,
            36161744,
            36165169
        ],
        "B": [
            36163096,
            36159675,
            36159702,
            36174211,
            36158845,
            36165864,
            36161702,
            36167381,
            36159372,
            36164193,
            36184907,
            36158822,
            36161863,
            36169531,
            36169227,
            36162688,
            36159710,
            36169741,
            36162780
        ],
        "C": [
            36159863,
            36162632,
            36162843,
            36159971,
            36160946,
            36158478,
            36159665,
            36159515,
            36161458,
            36161320,
            36162443,
            36163093,
            36159021,
            36158894,
            36174132,
            36201237,
            36164405,
            36159793,
            36161953,
            36158807,
            36162111
        ],
        "A": [
            36156394,
            36155837,
            36155755,
            36155535,
            36178220,
            36155392,
            36158997,
            36155227,
            36155148,
            36155311,
            36155229,
            36155259,
            36162558,
            36155502,
            36155114,
            36170875,
            36158967,
            36155326,
            36155358,
            36163726,
            36155813
        ]
    },
    "name": "E. Picking Strings",
    "statement": "Alice has a string consisting of characters ”, ” and ”. Bob can use the\r\nfollowing transitions on any substring of our string in any order any\r\nnumber of times: empty string Note that a substring is one or more\r\nconsecutive characters. For given queries, determine whether it is\r\npossible to obtain the target string from source.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint BS[100005];\nint BT[100005];\nchar S[100005];\nchar T[100005];\nint SN, TN;\nint ans[100005];\nint AS[100005];\nint AT[100005];\n\nint main() {\n\tscanf(\" %s\", S+1);\n\tscanf(\" %s\", T+1);\n\tSN = (int)strlen(S+1);\n\tTN = (int)strlen(T+1);\n\tS[0] = T[0] = 0;\n\n\tfor(int i = 1; i <= SN; i++) {\n\t\tBS[i] = BS[i - 1];\n\t\tif(S[i] == 'B' || S[i] == 'C') BS[i]++;\n\t}\n\tfor(int i = 1; i <= TN; i++) {\n\t\tBT[i] = BT[i - 1];\n\t\tif(T[i] == 'B' || T[i] == 'C') BT[i]++;\n\t}\n\tfor(int i = 1; i <= SN; i++) {\n\t\tif(S[i] != 'A') AS[i] = 0;\n\t\telse AS[i] = AS[i - 1] + 1;\n\t}\n\tfor(int i = 1; i <= TN; i++) {\n\t\tif(T[i] != 'A') AT[i] = 0;\n\t\telse AT[i] = AT[i - 1] + 1;\n\t}\n\n\tint Q; scanf(\"%d\", &Q);\n\tfor(int q = 0; q < Q; q++) {\n\t\tint a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint scnt = BS[b] - BS[a - 1];\n\t\tint tcnt = BT[d] - BT[c - 1];\n\t\tif(scnt > tcnt) { ans[q] = 0; continue; }\n\t\tif(scnt % 2 != tcnt % 2) { ans[q] = 0; continue; }\n\t\tint x = min(b - a + 1, AS[b]), y = min(d - c + 1, AT[d]);\n\t\tif(x < y) { ans[q] = 0; continue; }\n\t\tif(x > y && (x - y) % 3 && scnt + 2 > tcnt) { ans[q] = 0; continue; }\n\t\tif(x == y && x == b - a + 1 && y != d - c + 1) { ans[q] = 0; continue; }\n\t\tans[q] = 1;\n\t}\n\tfor(int i = 0; i < Q; i++) printf(\"%d\", ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Picking Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/58286",
    "editorial": "First note that B can be always changed to C and vice versa: . Hence we can replace all C's with B's.\n\nFurthermore, see that: .\n\nThe above implies the set of following rules:\n\n\n\n\n\nWe can translate these rules to the following:\n\nthe number of Bs can be increased by any non-negative even number\nthe number of As before any B may change arbitrarily\nThe only remaining thing is to determine what should happen to the number of trailing A's. There are three cases:\n\nThe number of B's is the same in the source and target  the number of trailing A's can decrease by any non-negative multiple of 3, as no application of the first rule occurs, and the second and third rule cannot affect trailing A's.\nThere are some B's in the source and the number of B's increases  the number of trailing A's can decrease by any non-negative number. To decrease the number to k, just morph the k?+?1-th A from the end to BB. To keep it the same, morph any B to AB and then to BBB to introduce extra B's as needed.\nThere are no B's in the source, but some B's in the target  the number of trailing A's has to decrease by any positive integer.\nIt is now easy to calculate prefix sums of the B and C occurrences, and calculate the number of trailing A's for every end position. The rest is just casework.",
    "hint": []
}