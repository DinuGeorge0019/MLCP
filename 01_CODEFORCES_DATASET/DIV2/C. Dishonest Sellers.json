{"link": "https://codeforces.com//contest/779/problem/C", "problemId": "95637", "problem_idx": "C", "shortId": "779C", "contest_number": "779", "problem_submissions": {"E": [25041597, 25042966, 25042647, 25042184, 25041738, 25044527, 25046776, 25043037, 25043576, 25044558, 25045642, 25044076, 25043684, 25042226, 25043678, 25045366, 25044333], "C": [25035763, 25034520, 25036373, 25034120, 25034894, 25035381, 25035813, 25032607, 25034344, 25034774, 25035579, 25035162, 25033556, 25036921, 25034938, 25034865, 25034643], "B": [25034403, 25033009, 25035076, 25032745, 25033238, 25033475, 25034138, 25036437, 25032923, 25032280, 25033532, 25033250, 25032318, 25036213, 25033673, 25033347, 25032551], "A": [25033465, 25031856, 25033923, 25031374, 25031707, 25031479, 25032790, 25034086, 25031239, 25031289, 25031285, 25031689, 25031337, 25035671, 25032432, 25031702, 25031272], "D": [25032517, 25037114, 25032438, 25036092, 25036499, 25037466, 25043534, 25038470, 25037495, 25037533, 25041359, 25039849, 25037140, 25038656, 25037700, 25037570, 25037825]}, "name": "C. Dishonest Sellers", "statement": "Igor found out discounts in a shop and decided to buy items. Discounts\r\nat the store will last for a week and Igor knows about each item that\r\nits price now is , and after a week of discounts its price will be .Not\r\nall of sellers are honest, so now some products could be more expensive\r\nthan after a week of discounts.Igor decided that buy of items now, but\r\nwait with the rest of the week in order to save money as much as\r\npossible. Your task is to determine the minimum money that Igor can\r\nspend to buy all items.\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <time.h>\n#include <string.h>\n#include <queue>\n#include <stack>\n#define sz size()\n#define pb push_back\nusing namespace std;\ntypedef long long int ll;\nll mod=1e9+7;\nll exp(ll t,ll x){if(x==0) return 1;if(x==1) return t;if(x%2==1) return (t*exp((t*t)%mod,x/2))%mod;if(x%2==0) return exp((t*t)%mod,x/2);} \nll gcd(ll x,ll y){return x%y==0?y:gcd(y,x%y);}\nll lcm(ll x,ll y){return x*(y/gcd(x,y));}\nll bsum(ll u,ll b){return u<b?u:bsum(u/b,b)+u%b;}\nll prival(ll u,ll p){int cn=0;while(u%p==0){cn++;u=u/p;}return cn;}\nbool isprime(ll x){for(ll i=2;i*i<=x;i++){if(x%i==0){return false;}}return true;}\nvoid YAY(void){cout<<\"YES\"<<endl;}\nvoid NAY(void){cout<<\"NO\"<<endl;}\nll a[222222];\nll b[222222];\npair<ll, int> stuf[222222]; // a-b, index\nint n, k, epo;\nll ans;\n\nint main(void)\n{\n\tint i, j;\n\tcin>>n>>k;\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tscanf(\"%lld\",&b[i]);\n\t}\n\tfor(i=1 ; i<=n ; i++)\n\t{\n\t\tstuf[i].first=a[i]-b[i];\n\t\tstuf[i].second=i;\n\t}\n\tsort(stuf+1,stuf+n+1);\n\tfor(i=k ; i<=n ; i++)\n\t{\n\t\tif(i==n || stuf[i+1].first>=0)\n\t\t{\n\t\t\tbreak; // ~i use \n\t\t}\n\t}\n\tepo=i;\n\tfor(i=1 ; i<=epo ; i++)\n\t{\n\t\tans+=a[stuf[i].second];\n\t}\n\tfor(i=epo+1 ; i<=n ; i++)\n\t{\n\t\tans+=b[stuf[i].second];\n\t}\n\tcout<<ans;\n\t\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings"], "dificulty": "1200", "interactive": false}