{"link": "https://codeforces.com//contest/2103/problem/F", "problemId": "3344324", "problem_idx": "F", "shortId": "2103F", "contest_number": "2103", "problem_submissions": {"E": [316580259, 316596724, 317172040, 316590039, 316595391], "F": [316566749, 316554849, 316570194, 316571690, 316564753, 316565334, 316570375, 316566324, 316575470, 316580599], "D": [316555496, 316575935, 316547933, 316557810, 316581217, 316583504, 316574629, 316579069, 316561467, 316554031, 316570027], "C": [316551349, 316539195, 316536817, 316551152, 316552060, 316551470, 316558008, 316550915, 316554352, 316539931, 316539580], "B": [316531722, 316533206, 316540972, 316534158, 316532366, 316536408, 316536066, 316548057, 316551531, 316531957, 316544497], "A": [316523865, 316526077, 316528063, 316524687, 316526522, 316532444, 316526800, 316525336, 316545204, 316523615, 316541424]}, "editorial_link": "https://codeforces.com//blog/entry/142149", "editorial": "", "name": "F. Maximize Nor", "statement": "The bitwise nor^{\r\ntext{ }} of an array of k-bit integers b_1, b_2,\r\nldots, b_m can be computed by calculating the bitwise nor cumulatively\r\nfrom left to right. More formally,\r\noperatorname{nor}(b_1, b_2,\r\nldots, b_m) =\r\noperatorname{nor}(\r\noperatorname{nor}(b_1, b_2,\r\nldots, b_{m - 1}), b_m) for m\r\nge 2, and\r\noperatorname{nor}(b_1) = b_1.You are given an array of k-bit integers\r\na_1, a_2,\r\nldots, a_n. For each index i (1\r\nle i\r\nle n), find the maximum bitwise nor among all subarrays^{\r\ntext{ }} of a containing index i. In other words, for each index i, find\r\nthe maximum value of\r\noperatorname{nor}(a_l, a_{l+1},\r\nldots, a_r) among all 1\r\nle l\r\nle i\r\nle r\r\nle n.^{\r\ntext{ }} The logical nor of two boolean values is 1 if both values are\r\n0, and 0 otherwise. The bitwise nor of two k-bit integers is calculated\r\nby performing the logical nor operation on each pair of the\r\ncorresponding bits.For example, let us compute\r\noperatorname{nor}(2, 6) when they are represented as 4-bit numbers. In\r\nbinary, 2=0010_2 and 6=0110_2. Therefore,\r\noperatorname{nor}(2,6) = 1001_2 = 9 as by performing the logical nor\r\noperations from left to right, we have:\r\noperatorname{nor}(0,0) = 1\r\noperatorname{nor}(0,1) = 0\r\noperatorname{nor}(1,0) = 0\r\noperatorname{nor}(1,1) = 0 Note that if 2 and 6 were represented as\r\n3-bit integers instead, then\r\noperatorname{nor}(2,6) = 1. ^{\r\ntext{ }}An array x is a subarray of an array y if x can be obtained from\r\ny by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n", "solutions": [], "input": "", "output": "", "tags": ["bitmasks", "data structures", "dp", "implementation", "sortings"], "dificulty": "2600", "interactive": false, "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Maximize Nor.json"}