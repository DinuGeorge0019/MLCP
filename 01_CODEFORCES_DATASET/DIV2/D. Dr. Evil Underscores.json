{
    "link": "https://codeforces.com//contest/1285/problem/D",
    "problemId": "512929",
    "problem_idx": "D",
    "shortId": "1285D",
    "contest_number": "1285",
    "problem_submissions": {
        "F": [
            68545833,
            68535522,
            68573334,
            96999211,
            96999146,
            68573161,
            69098509,
            68626658,
            68682994
        ],
        "E": [
            68524941,
            68518417,
            68530554,
            68529308,
            68531407,
            68531344,
            68531615,
            68534357,
            68534051,
            68529832,
            68540790,
            68535869,
            68541711,
            68538608,
            68538163,
            68537974,
            68541963,
            68539842,
            68536496,
            68538129
        ],
        "D": [
            68507082,
            68557516,
            68506902,
            68508017,
            68510947,
            68510777,
            68514189,
            68853550,
            68517438,
            68515728,
            68517316,
            68510494,
            68517322,
            68513984,
            68513219,
            68519377,
            68516492,
            68513650,
            68514808,
            68520824,
            68521323
        ],
        "C": [
            68504523,
            68504942,
            68504769,
            68508581,
            68506887,
            68517568,
            68507055,
            68509904,
            68509741,
            68512066,
            68504310,
            68506343,
            68505577,
            68506877,
            68502537,
            68507690,
            68510042,
            68506486,
            68506105,
            68511726
        ],
        "B": [
            68502726,
            68503606,
            68501596,
            68503575,
            68503622,
            68503646,
            68503039,
            68505606,
            68503233,
            68506583,
            68503941,
            68502210,
            68503653,
            68503110,
            68508414,
            68502653,
            68505318,
            68503675,
            68512385,
            68505519
        ],
        "A": [
            68497804,
            68499469,
            68497513,
            68497595,
            68499958,
            68498702,
            68497961,
            68500159,
            68498048,
            68499346,
            68497975,
            68497626,
            68497817,
            68498423,
            68498520,
            68497604,
            68497745,
            68497829,
            68499449,
            68499473
        ]
    },
    "name": "D. Dr. Evil Underscores",
    "statement": "Today, as a friendship gift, Bakry gave Badawy n integers a_1, a_2,\r\ndots, a_n and challenged him to choose an integer X such that the value\r\nunderset{1\r\nleq i\r\nleq n}{\r\nmax} (a_i\r\noplus X) is minimum possible, where\r\noplus denotes the bitwise XOR operation.As always, Badawy is too lazy,\r\nso you decided to help him and find the minimum possible value of\r\nunderset{1\r\nleq i\r\nleq n}{\r\nmax} (a_i\r\noplus X).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nconst int maxn = 100100, lg = 30;\nint to[maxn * lg][2], nds = 1;\nvoid insert(int x){\n\tint cur = 0;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tint & v = to[cur][(x>>i)&1];\n\t\tif(v == 0) v = nds++;\n\t\tcur = v;\n\t}\n}\nint get(int r, int b){\n\tif(to[r][0] == 0 && to[r][1] == 0) return 0;\n\tif(to[r][0] == 0) return get(to[r][1], b - 1);\n\tif(to[r][1] == 0) return get(to[r][0], b - 1);\n\treturn min(get(to[r][0], b - 1), get(to[r][1], b - 1)) + (1<<b);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tinsert(x);\n\t}\n\tcout << get(0, 29) << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "greedy",
        "strings",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Dr. Evil Underscores.json",
    "editorial_link": "https://codeforces.com//blog/entry/72950",
    "editorial": "We will solve this problem recursively starting from the most\r\nsignificant bit. Letâs split the elements into two groups, one with the\r\nelements which have the current bit on and one with the elements which\r\nhave the current bit off. If either group is empty, we can assign the\r\ncurrent bit of accordingly so that we have the current bit off in our\r\nanswer, so we will just proceed to the next bit. Otherwise, both groups\r\narenât empty, so whatever value we assign to the current bit of , we\r\nwill have this bit on in our answer. Now, to decide which value to\r\nassign to the current bit of , we will solve the same problem\r\nrecursively for each of the groups for the next bit; let and be the\r\nanswers of the recursive calls for the on and the off groups\r\nrespectively. Note that if we assign to the current bit of , the answer\r\nwill be , and if we assign to the current bit of , the answer will be ,\r\nwhere is the current bit. So, simply we will choose the minimum of these\r\ntwo cases for our answer to be .Time complexity:\r\n",
    "hint": []
}