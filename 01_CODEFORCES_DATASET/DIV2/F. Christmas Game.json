{
    "link": "https://codeforces.com//contest/1498/problem/F",
    "problemId": "939727",
    "problem_idx": "F",
    "shortId": "1498F",
    "contest_number": "1498",
    "problem_submissions": {
        "F": [
            111387402,
            111392757,
            111390775,
            111403691,
            111584572,
            111473088,
            111426854,
            111399920,
            111425764,
            111390588,
            111477247,
            111409684
        ],
        "E": [
            111380663,
            111380198,
            111394052,
            111391669,
            111387992,
            111389314,
            111390832,
            111389181,
            111394144,
            111392605,
            111394352,
            111387457,
            111380754,
            111393900,
            111397027,
            111441836,
            111441307,
            111400155,
            111385873,
            111395643
        ],
        "D": [
            111375931,
            111387383,
            111378758,
            111377203,
            111379613,
            111383007,
            111378160,
            111383542,
            111383036,
            111382698,
            111387981,
            111395336,
            111398482,
            111384225,
            111554241,
            111398142,
            111389221
        ],
        "C": [
            111364680,
            111369793,
            111370806,
            111367823,
            111370857,
            111369057,
            111366879,
            111378226,
            111375527,
            111375807,
            111372267,
            111374177,
            111372378,
            111369667,
            111372541,
            111380311,
            111372933,
            111374210
        ],
        "B": [
            111358809,
            111373602,
            111364638,
            111359716,
            111363279,
            111361795,
            111359400,
            111362980,
            111362321,
            111366507,
            111367101,
            111362617,
            111361122,
            111360963,
            111365072,
            111367219,
            111360331,
            111363745
        ],
        "A": [
            111356336,
            111356639,
            111356331,
            111356474,
            111357691,
            111356258,
            111356269,
            111358101,
            111357535,
            111358945,
            111356500,
            111356580,
            111356352,
            111356349,
            111359311,
            111357626,
            111356520,
            111357210
        ]
    },
    "name": "F. Christmas Game",
    "statement": "Alice and Bob are going to celebrate Christmas by playing a game with a\r\ntree of presents. The tree has n nodes (numbered 1 to n, with some node\r\nr as its root). There are a_i presents are hanging from the i-th\r\nnode.Before beginning the game, a special integer k is chosen. The game\r\nproceeds as follows: Alice begins the game, with moves alternating each\r\nturn; in any move, the current player may choose some node (for example,\r\ni) which has depth at least k. Then, the player picks some positive\r\nnumber of presents hanging from that node, let’s call it m (1\r\nle m\r\nle a_i); the player then places these m presents on the k-th ancestor\r\n(let’s call it j) of the i-th node (the k-th ancestor of vertex i is a\r\nvertex j such that i is a descendant of j, and the difference between\r\nthe depth of j and the depth of i is exactly k). Now, the number of\r\npresents of the i-th node (a_i) is decreased by m, and, correspondingly,\r\na_j is increased by m; Alice and Bob both play optimally. The player\r\nunable to make a move loses the game. of the tree, find who among Alice\r\nor Bob wins the game.Note: The depth of a node i in a tree with root r\r\nis defined as the number of edges on the simple path from node r to node\r\ni. The depth of root r itself is zero.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002],k,f[100002][42],g[100002][42];\ninline void add(re int x,re int y){e[++cnt]=(edge){y,head[x]},head[x]=cnt;}\ninline void dfs(re int x,re int y,re int d){\n\tif((d/k)&1)ans^=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to^y)dfs(e[i].to,x,d+1);\n}\ninline void dfs1(re int x,re int y){\n\tf[x][0]=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to^y){\n\t\t\tdfs1(e[i].to,x);\n\t\t\tfor(re int j=0;j<k*2;++j)f[x][j+1]^=f[e[i].to][j];\n\t\t\tf[x][0]^=f[x][k*2],f[x][k*2]=0;\n\t\t}\n}\ninline void dfs2(re int x,re int y){\n\tif(y){\n\tfor(re int j=0;j<k*2;++j)g[x][j+1]^=g[y][j];\n\tg[x][0]^=g[x][k*2],g[x][k*2]=0;\n\tg[x][1]^=a[y];\n\tfor(re int j=0;j<k*2;++j)f[y][j+1]^=f[x][j];\n\tf[y][0]^=f[y][k*2],f[y][k*2]=0;\n\tfor(re int j=0;j<k*2;++j)g[x][j+1]^=f[y][j];\n\tg[x][0]^=g[x][k*2],g[x][k*2]=0;\n\tfor(re int j=0;j<k*2;++j)f[y][j+1]^=f[x][j];\n\tf[y][0]^=f[y][k*2],f[y][k*2]=0;\n\t}\n\tg[x][0]^=a[x];\n\tfor(re int i=head[x];i;i=e[i].next)if(e[i].to^y)dfs2(e[i].to,x);\n}\nsigned main(){\n\tn=read(),k=read();\n\tfor(re int i=1,x,y;i<n;++i)x=read(),y=read(),add(x,y),add(y,x);\n\tfor(re int i=1;i<=n;++i)a[i]=read();\n\tdfs1(1,1),dfs2(1,0);\n\tfor(re int i=1;i<=n;++i){\n\t\tans=0;\n\t\tfor(re int j=k;j<k*2;++j)ans^=f[i][j]^g[i][j];\n\t\tif(ans)printf(\"1 \");\n\t\telse printf(\"0 \"); \n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "dp",
        "games",
        "math",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Christmas Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/89137",
    "editorial": "How do we solve a standard Nim game on arrays?By the Sprague-Grundy\r\ntheorem, we know that the current player has a winning strategy if\r\n(xorsum of sizes of the existing piles) is non-zero. For a proof, read\r\ndetails on CP-algorithms.\r\n",
    "hint": []
}