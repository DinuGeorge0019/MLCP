{"link": "https://codeforces.com//contest/448/problem/B", "problemId": "11517", "problem_idx": "B", "shortId": "448B", "contest_number": "448", "problem_submissions": {"B": [7132360, 7126812, 7131705, 7128126, 7126975, 7130368, 7133849, 7126556, 7137379, 7128333, 7127308, 7138326, 7127246, 7126908, 7126783, 7127446, 7129637], "A": [7131281, 7124641, 7124604, 7125918, 7124627, 7138197, 7130895, 7124806, 7126069, 7130700, 7124540, 7137566, 7124981, 7125197, 7124518, 7124798, 7124709], "E": [7130571, 7134588, 7144432, 7133164, 7135434, 7135739, 7134555, 7135492, 7137501, 7137792, 7136520, 7138444, 7137089, 7135078, 7144128, 7138750], "C": [7127523, 7128095, 7131570, 7129889, 7129858, 7136406, 7126752, 7135156, 7136170, 7132158, 7130231, 7128623, 7134636, 7130788, 7130040, 7131300, 7133349, 7129026], "D": [7125339, 7129364, 7128228, 7132669, 7131873, 7129212, 7129065, 7128867, 7128240, 7130235, 7125766, 7129601, 7132488, 7131074, 7132807, 7131262, 7131953, 7129050, 7133299]}, "name": "B. Suffix Structures", "statement": "Bizon the Champion isn\u2019t just a bison. He also is a favorite of the\r\n\"Bizons\" team.At a competition the \"Bizons\" got the following problem:\r\n\"You are given two distinct words (strings of English letters), and .\r\nYou need to transform word into word \". The task looked simple to the\r\nguys because they know the suffix data structures well. Bizon Senior\r\nloves suffix automaton. By applying it once to a string, he can remove\r\nfrom this string any single character. Bizon Middle knows suffix array\r\nwell. By applying it once to a string, he can swap any two characters of\r\nthis string. The guys do not know anything about the suffix tree, but it\r\ncan help them do much more. Bizon the Champion wonders whether the\r\n\"Bizons\" can solve the problem. Perhaps, the solution do not require\r\nboth data structures. Find out whether the guys can solve the problem\r\nand if they can, how do they do it? Can they solve it either only with\r\nuse of suffix automaton or only with use of suffix array or they need\r\nboth structures? Note that any structure may be used an unlimited number\r\nof times, the structures may be used in any order.\r\n", "solutions": ["#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define N 110\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m;\nchar p[N],s[N];\ninline void fail(int ty) {\n\tif (ty==1) printf(\"automaton\\n\");\n\tif (ty==2) printf(\"array\\n\");\n\tif (ty==3) printf(\"both\\n\");\n\tif (ty==4) printf(\"need tree\\n\");\n\texit(0);\n}\ninline bool ju1() {\n\tint i,j;\n\ti=j=1;\n\tFor(j,1,m) {\n\t\tfor (;i<=n&&p[i]!=s[j];i++);\n\t\tif (i>n) return 0;\n\t\ti++;\n\t}\n\treturn 1;\n}\ninline bool ju2() {\n\tint i;\n\tif (n!=m) return 0;\n\tFor(i,1,n) if (s[i]!=p[i]) return 0;\n\treturn 1;\n}\nint main() {\n\tscanf(\"%s%s\",p+1,s+1);\n\tn=strlen(p+1);\n\tm=strlen(s+1);\n\tif (n<m) fail(4);\n\tif (ju1()) fail(1);\n\tsort(p+1,p+n+1);\n\tsort(s+1,s+m+1);\n\tif (ju2()) fail(2);\n\tif (ju1()) fail(3);\n\tfail(4);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["implementation", "strings"], "dificulty": "1400", "interactive": false}