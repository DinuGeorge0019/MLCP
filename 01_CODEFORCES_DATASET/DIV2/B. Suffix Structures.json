{
    "link": "https://codeforces.com//contest/448/problem/B",
    "problemId": "11517",
    "problem_idx": "B",
    "shortId": "448B",
    "contest_number": "448",
    "problem_submissions": {
        "B": [
            7132360,
            7126812,
            7131705,
            7128126,
            7126975,
            7130368,
            7133849,
            7126556,
            7137379,
            7128333,
            7127308,
            7138326,
            7127246,
            7126908,
            7126783,
            7127446,
            7129637
        ],
        "A": [
            7131281,
            7124641,
            7124604,
            7125918,
            7124627,
            7138197,
            7130895,
            7124806,
            7126069,
            7130700,
            7124540,
            7137566,
            7124981,
            7125197,
            7124518,
            7124798,
            7124709
        ],
        "E": [
            7130571,
            7134588,
            7144432,
            7133164,
            7135434,
            7135739,
            7134555,
            7135492,
            7137501,
            7137792,
            7136520,
            7138444,
            7137089,
            7135078,
            7144128,
            7138750
        ],
        "C": [
            7127523,
            7128095,
            7131570,
            7129889,
            7129858,
            7136406,
            7126752,
            7135156,
            7136170,
            7132158,
            7130231,
            7128623,
            7134636,
            7130788,
            7130040,
            7131300,
            7133349,
            7129026
        ],
        "D": [
            7125339,
            7129364,
            7128228,
            7132669,
            7131873,
            7129212,
            7129065,
            7128867,
            7128240,
            7130235,
            7125766,
            7129601,
            7132488,
            7131074,
            7132807,
            7131262,
            7131953,
            7129050,
            7133299
        ]
    },
    "name": "B. Suffix Structures",
    "statement": "Bizon the Champion isnâ€™t just a bison. He also is a favorite of the\r\n\"Bizons\" team.At a competition the \"Bizons\" got the following problem:\r\n\"You are given two distinct words (strings of English letters), and .\r\nYou need to transform word into word \". The task looked simple to the\r\nguys because they know the suffix data structures well. Bizon Senior\r\nloves suffix automaton. By applying it once to a string, he can remove\r\nfrom this string any single character. Bizon Middle knows suffix array\r\nwell. By applying it once to a string, he can swap any two characters of\r\nthis string. The guys do not know anything about the suffix tree, but it\r\ncan help them do much more. Bizon the Champion wonders whether the\r\n\"Bizons\" can solve the problem. Perhaps, the solution do not require\r\nboth data structures. Find out whether the guys can solve the problem\r\nand if they can, how do they do it? Can they solve it either only with\r\nuse of suffix automaton or only with use of suffix array or they need\r\nboth structures? Note that any structure may be used an unlimited number\r\nof times, the structures may be used in any order.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define N 110\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m;\nchar p[N],s[N];\ninline void fail(int ty) {\n\tif (ty==1) printf(\"automaton\\n\");\n\tif (ty==2) printf(\"array\\n\");\n\tif (ty==3) printf(\"both\\n\");\n\tif (ty==4) printf(\"need tree\\n\");\n\texit(0);\n}\ninline bool ju1() {\n\tint i,j;\n\ti=j=1;\n\tFor(j,1,m) {\n\t\tfor (;i<=n&&p[i]!=s[j];i++);\n\t\tif (i>n) return 0;\n\t\ti++;\n\t}\n\treturn 1;\n}\ninline bool ju2() {\n\tint i;\n\tif (n!=m) return 0;\n\tFor(i,1,n) if (s[i]!=p[i]) return 0;\n\treturn 1;\n}\nint main() {\n\tscanf(\"%s%s\",p+1,s+1);\n\tn=strlen(p+1);\n\tm=strlen(s+1);\n\tif (n<m) fail(4);\n\tif (ju1()) fail(1);\n\tsort(p+1,p+n+1);\n\tsort(s+1,s+m+1);\n\tif (ju2()) fail(2);\n\tif (ju1()) fail(3);\n\tfail(4);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Suffix Structures.json",
    "editorial_link": "https://codeforces.com//blog/entry/13042",
    "editorial": " Consider each case separately. If we use only suffix\nautomaton then transform to some of its subsequence. Checking that is a\nsubsequence of can be performed in different ways. Easiest and fastest\nwell-known two pointers method. In case of using suffix array we can get\nevery permutation of . If it is not obvious for you, try to think. Thus,\nand must be anagrams. If we count number of each letter in each string,\nwe can check this. If every letter appears in the same times as in then\nwords are anagrams. In case of using both structures strategy is: remove\nsome letters and shuffle the rest. It is possible if every letter\nappears in not less times than in . Otherwise it is impossible to make\nfrom . Total complexity .\n",
    "hint": []
}