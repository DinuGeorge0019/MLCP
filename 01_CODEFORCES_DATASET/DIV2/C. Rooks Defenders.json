{"link": "https://codeforces.com//contest/1679/problem/C", "problemId": "1399038", "problem_idx": "C", "shortId": "1679C", "contest_number": "1679", "problem_submissions": {"E": [157180775, 157191404, 157182377, 157177036, 157184415, 157176870, 157175927, 157179358, 157179949, 157181138, 157181082, 157188651, 158765685, 157182719, 157183341, 157204752, 157188040, 157183760, 157190456, 157188869], "F": [157169392, 157164382, 157193064, 157199663, 157199138, 157186552, 157273261, 157180874, 158765715, 157250679, 157197475, 157509965], "A": [157160334, 157139962, 157137818, 157155828, 157137804, 157138382, 157140445, 157138960, 157138642, 157138794, 157144480, 157142439, 162719211, 158765634, 157138332, 157138320, 157139854, 157140729, 157138982, 157137953, 157138211], "B": [157157060, 157145020, 157140369, 157158458, 157140367, 157140216, 157144197, 157146569, 157143365, 157142315, 157148129, 157146141, 157198440, 158765655, 157143823, 157143623, 157144426, 157145542, 157143138, 157142676, 157142878], "C": [157154751, 157170214, 157147368, 157161435, 157149801, 157145630, 157152376, 157151562, 157149876, 157147868, 157153893, 157150787, 157196725, 158765679, 157151559, 157154130, 157157802, 157152042, 157149676, 157150426, 157148575], "D": [157148745, 157180439, 157159044, 157144096, 157159383, 157154423, 157160087, 157161413, 157158556, 157158664, 157164328, 157159039, 157192557, 158765668, 157159304, 157162810, 157169333, 157162480, 157162127, 157163382, 157167439]}, "name": "C. Rooks Defenders", "statement": "You have a square chessboard of size n\r\ntimes n. Rows are numbered from top to bottom with numbers from 1 to n,\r\nand columns from left to right with numbers from 1 to n. So, each cell\r\nis denoted with pair of integers (x, y) (1\r\nle x, y\r\nle n), where x is a row number and y is a column number.You have to\r\nperform q queries of three types: Put a new rook in cell (x, y). Remove\r\na rook from cell (x, y). It\u2019s guaranteed that the rook was put in this\r\ncell before. Check if each cell of (x_1, y_1) - (x_2, y_2) of the board\r\nis attacked by at least one rook. is a set of cells (x, y) such that for\r\neach cell two conditions are satisfied: x_1\r\nle x\r\nle x_2 and y_1\r\nle y\r\nle y_2.Recall that cell (a, b) is attacked by a rook placed in cell (c,\r\nd) if either a = c or b = d. In particular, the cell containing a rook\r\nis attacked by this rook.\r\n", "solutions": ["#include<algorithm>\n#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#define lc(x) (x<<1)\n#define rc(x) (x<<1|1)\n#define mid (l+r>>1)\nusing namespace std;\nconst int maxn=500005,maxt=maxn<<2;\nint n,m,T,ans;\nint t[maxn][2],mn[maxt][2];\nvoid update(int l,int r,int now,int p,int v,int tp){\n\tif(l==r){\n\t\tmn[now][tp]+=v;\n\t\treturn ;\n\t}\n\tif(p<=mid)\n\t\tupdate(l,mid,lc(now),p,v,tp);\n\telse update(mid+1,r,rc(now),p,v,tp);\n\tmn[now][tp]=min(mn[lc(now)][tp],mn[rc(now)][tp]);\n}\nint query(int l,int r,int now,int L,int R,int tp){\n\tif(L<=l&&r<=R)\n\t\treturn mn[now][tp];\n\tint res=2;\n\tif(L<=mid)\n\t\tres=min(res,query(l,mid,lc(now),L,R,tp));\n\tif(mid<R)\n\t\tres=min(res,query(mid+1,r,rc(now),L,R,tp));\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m--){\n\t\tint t,x,y,a,b;\n\t\tscanf(\"%d%d%d\",&t,&x,&y);\n\t\tif(t==1)\n\t\t\tupdate(1,n,1,x,1,0),update(1,n,1,y,1,1);\n\t\tif(t==2)\n\t\t\tupdate(1,n,1,x,-1,0),update(1,n,1,y,-1,1);\n\t\tif(t==3){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tif(query(1,n,1,x,a,0)||query(1,n,1,y,b,1))\n\t\t\t\tputs(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "1400", "interactive": false}