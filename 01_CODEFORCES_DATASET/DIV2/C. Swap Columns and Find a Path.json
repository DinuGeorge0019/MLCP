{
    "link": "https://codeforces.com//contest/2047/problem/C",
    "problemId": "3064635",
    "problem_idx": "C",
    "shortId": "2047C",
    "contest_number": "2047",
    "problem_submissions": {
        "F": [
            294576018
        ],
        "D": [
            294556181,
            294550999,
            294551362,
            294549113,
            294552457,
            294549132,
            294545443,
            294545413,
            294553157,
            294554253,
            294547704,
            294545194,
            294551491,
            294546981,
            294545215,
            294554235,
            294551596,
            294555080,
            294553722
        ],
        "E": [
            294553658,
            294561058,
            294564356,
            294560884,
            294607752,
            294607657,
            294607423,
            294566840,
            294564602,
            294566710,
            294567902,
            294566502,
            294566942,
            294570129,
            294573472,
            294575252,
            294574930,
            294577351,
            294571682,
            294573929,
            294572766,
            294572872
        ],
        "C": [
            294537935,
            294544794,
            294543033,
            294543024,
            294539849,
            294544621,
            294540793,
            294540644,
            294546521,
            294548997,
            294552751,
            294541180,
            294538453,
            294540477,
            294539426,
            294541750,
            294543785,
            294533886,
            294545247
        ],
        "B": [
            294536414,
            294542160,
            294535717,
            294539853,
            294536380,
            294540106,
            294537951,
            294533781,
            294538848,
            294537306,
            294538421,
            294536540,
            294535134,
            294536248,
            294536341,
            294535891,
            294535533,
            294543631,
            294541462
        ],
        "A": [
            294533410,
            294535816,
            294532913,
            294532916,
            294533402,
            294535536,
            294533238,
            294535567,
            294533545,
            294533451,
            294534370,
            294533884,
            294532708,
            294533038,
            294533136,
            294533187,
            294540270,
            294536728,
            294532860
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136908",
    "editorial": "We can divide the columns in the matrix into three different groups:\n\nthe columns where we go through the top cell;\nthe columns where we go through the bottom cell;\nthe columns where we go through both cells.\nThere should be exactly one column in the 3\n-rd group \u0097 this will be the column where we shift from the top row to the bottom row. However, all other columns can be redistributed between groups 1\n and 2\n as we want: if we want to put a column into the 1\n-st group, we put it before the column where we go down; otherwise, we put it after the column where we go down. So, we can get any distribution of columns between the 1\n-st and the 2\n-nd group.\n\nNow let's consider the contribution of each column to the answer. Columns from the 1\n-st group add a1,i\n to the answer, columns from the 2\n-nd group add a2,i\n, the column from the 3\n-rd group adds both of these values. So, we can iterate on the index of the column where we go down, take a1,i+a2,i\n for it, and take max(a1,j,a2,j)\n for every other column. This works in O(n2)\n, and under the constraints of the problem, it is enough.\n\nHowever, it is possible to solve the problem in O(n)\n. To do so, calculate the sum of max(a1,j,a2,j)\n over all columns. Then, if we pick the i\n-th column as the column where we go down, the answer be equal to this sum, plus min(a1,i,a2,i)\n, since this will be the only column where we visit both cells.",
    "name": "C. Swap Columns and Find a Path",
    "statement": "There is a matrix consisting of 2 rows and n columns. The rows are\r\nnumbered from 1 to 2 from top to bottom; the columns are numbered from 1\r\nto n from left to right. Let\u2019s denote the cell on the intersection of\r\nthe i-th row and the j-th column as (i,j). Each cell contains an\r\ninteger; initially, the integer in the cell (i,j) is a_{i,j}.You can\r\nperform the following operation any number of times (possibly zero):\r\nchoose two columns and swap them (i. e. choose two integers x and y such\r\nthat 1\r\nle x < y\r\nle n, then swap a_{1,x} with a_{1,y}, and then swap a_{2,x} with\r\na_{2,y}). After performing the operations, you have to choose a path\r\nfrom the cell (1,1) to the cell (2,n). For every cell (i,j) in the path\r\nexcept for the last, the next cell should be either (i+1,j) or (i,j+1).\r\nObviously, the path cannot go outside the matrix.The of the path is the\r\nsum of all integers in all (n+1) cells belonging to the path. You have\r\nto perform the operations and choose a path so that its cost is\r\npossible.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"-Ofast\",\"-funroll-all-loops\",\"-ffast-math\")#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")//#pragma GCC target(\"avx,avx2,sse,sse2,sse3,ssse3,sse4,abm,popcnt,mmx\")#include <bits/stdc++.h>using namespace std;#define endl '\\n'\u00a0mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());mt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\u00a0int rnd(int a, int b) {\treturn rng() % (b - a + 1) + a;}\u00a0string to_string(string s) { return s; }template <typename T> string to_string(T v) {  bool first = true;  string res = \"[\";  for (const auto &x : v) {    if (!first)      res += \", \";    first = false;    res += to_string(x);  }  res += \"]\";  return res;}\u00a0void dbg_out() { cerr << endl; }template <typename Head, typename... Tail> void dbg_out(Head H, Tail... T) {  cerr << ' ' << to_string(H);  dbg_out(T...);}\u00a0#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\u00a0template<class T> inline void chkmin(T& x, T y) { if (y < x) x = y; }template<class T> inline void chkmax(T& x, T y) { if (y > x) x = y; }\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\u00a0const i64 INF = 1e18;const int oo = 1e9;const int mod = 1e9 + 7;const int MX = 10005;const int inf = 1e9;int s[MX], t[MX], a[2][MX];\u00a0void solve() {\tint n;\tcin >> n;\tfor (int i = 0; i < 2; i ++) for (int j = 0; j < n;j  ++) cin >> a[i][j];\tint ans = -inf;\tfor (int i = 0; i < n; i ++) {\t\tint s = 0;\t\tfor (int j = 0; j < n; j ++) {\t\t\tif (j == i) continue;\t\t\ts += max(a[0][j], a[1][j]);\t\t}\t\ts += a[0][i] + a[1][i];\t\tans = max(ans, s);\t}\tcout << ans << endl;}\u00a0int main() {#ifndef ONLINE_JUDGE\tfreopen(\"in.txt\", \"r\", stdin);//\tfreopen(\"out.txt\", \"w\", stdout);#endif\u00a0\tios::sync_with_stdio(0);\tcin.tie(0); cout.tie(0);\u00a0\tint Tc = 1;\tcin >> Tc;\twhile (Tc --) {\t\tsolve();\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Swap Columns and Find a Path.json"
}