{
    "link": "https://codeforces.com//contest/1853/problem/B",
    "problemId": "2099140",
    "problem_idx": "B",
    "shortId": "1853B",
    "contest_number": "1853",
    "problem_submissions": {
        "E": [
            215240531,
            215240313,
            215246116,
            215249458,
            215251653,
            215250635,
            216838871,
            215350430,
            215284663,
            215314853,
            215261254
        ],
        "D": [
            215214411,
            215220885,
            215224382,
            215226640,
            215227143,
            215237178,
            215219268,
            215220212,
            216838036,
            215216388,
            215222732,
            215221541,
            215222391,
            215228057,
            215226498,
            215216178,
            215232515,
            215230797,
            215230860,
            215230625,
            215227427
        ],
        "C": [
            215208066,
            215209029,
            215218445,
            215213557,
            215221549,
            215215979,
            215208850,
            215209462,
            216838362,
            215211675,
            215212482,
            215215977,
            215215848,
            215207971,
            215220425,
            215219406,
            215210968,
            215214808,
            215215587,
            215214690,
            215214191
        ],
        "B": [
            215201834,
            215199354,
            215203429,
            215207887,
            215208000,
            215209486,
            215199874,
            215202601,
            216837998,
            215205609,
            215206019,
            215207012,
            215203260,
            215203474,
            215206199,
            215210556,
            215204325,
            215206260,
            216063043,
            216062841,
            215207209,
            215210173,
            215204057
        ],
        "A": [
            215192467,
            215191692,
            215193758,
            215193193,
            215193397,
            215196782,
            215192166,
            215194407,
            216837978,
            215192246,
            215196759,
            215192559,
            215192820,
            215193114,
            215192996,
            215192748,
            215192883,
            215192440,
            216062816,
            215194635,
            215194796,
            215192776
        ],
        "F": [
            225845923
        ]
    },
    "name": "B. Fibonaccharsis",
    "statement": "Ntarsis has received two integers n and k for his birthday. He wonders\r\nhow many fibonacci-like sequences of length k can be formed with of the\r\nsequence. A sequence of integers is considered fibonacci-like if f_i =\r\nf_{i-1} + f_{i-2} for all i > 2, where f_i denotes the i-th element in\r\nthe sequence. Note that f_1 and f_2 can be arbitrary.For example,\r\nsequences such as [4,5,9,14] and [0,1,1] are considered fibonacci-like\r\nsequences, while [0,0,0,1,1], [1, 2, 1, 3], and [-1,-1,-2] are not: the\r\nfirst two do not always satisfy f_i = f_{i-1} + f_{i-2}, the latter does\r\nnot satisfy that the elements are non-negative.Impress Ntarsis by\r\nhelping him with this task.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint T;\n\tfor (cin >> T; T; T--) {\n\t\tint n, k; cin >> n >> k;\n\t\tint x = 1, y = 1;\n\t\tbool ok = 1;\n\t\tfor (int i = 0; i < k - 3; i++) {\n\t\t\tint z = x + y;\n\t\t\tx = y, y = z;\n\t\t\tif (x > n && y > n) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) cout << \"0\\n\";\n\t\telse {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i * x <= n; i++)\n\t\t\t\tif ((n - i * x) % y == 0 && i <= (n - i * x) / y)\n\t\t\t\t\tans++;\n\t\t\tcout << ans << '\\n';\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Fibonaccharsis.json",
    "editorial_link": "https://codeforces.com//blog/entry/116940",
    "editorial": "Problem Credits: ntarsis30, cry Analysis: cry SolutionThe terms of the\r\nfibonacci sequence will increase exponentially. This is quite intuitive,\r\nbut mathematically, fibonnaci-like sequences will increase at a rate of\r\nphi to the power of , where phi (the golden ratio) is about . Thus, the\r\nmaximum number of terms a sequence can have before it reaches , or the\r\nmaximum value of , is pretty small (around ). Instead of trying to fix\r\nthe first two elements of the sequence and counting how many sequences\r\nwill have , note that we already have fixed. If we loop over the th\r\nelement of the sequence, the sequence is . If we know the th element and\r\nth element of , we can find that . Thus, we can just go backwards and\r\nsimulate for iterations in since is small, breaking at any point if the\r\ncurrent sequence is not fibonnaci-like (there are negative elements or\r\nit is not strictly increasing). Otherwise, we add to our answer. The\r\ntime complexity is .\r\n",
    "hint": [
        "Hint 1 Can a sequence involving , which is up to , really have up to terms?",
        "Hint 1 Suppose that the numbers are arranged in a line in increasing order. Take a look at each number before some day. If it isn't deleted on that day, what new position does it occupy, and how is that impacted by its previous position? Answer If is between and , it will move to a new position of , since positions before it are deleted.",
        "Hint 2 Take this observation, and apply it to simulate the process backwards.",
        "Hint 1 You can solve the problem by picking one number from each pair , , .",
        "Hint 2 implies .",
        "Hint 3 First, try to determine one index in , or determine if that's impossible.",
        "Hint 4 Sort the array to optimize the solution.",
        "Hint 2 Can you figure out an solution? And can you improve on it?",
        "Hint 3 Suppose you already had the optimal solution for the subarray . How could you extend it to ?",
        "Hint 1 Solve the samples for all values of .",
        "Hint 2 What does constructing a second row from left to right look like?",
        "Hint 3 How does knowing the possible for any first row help you construct a second row?",
        "Hint 4 Apply dynamic programming to calculate the possible , and use the information in the DP to construct a solution.",
        "Hint 1 For each distinct value, only the leftmost and rightmost positions actually have an effect on the power.",
        "Hint 2 Think of each distinct value as an interval corresponding to its leftmost and rightmost positions, and let that distinct value be the value of its interval. If interval strictly contains an interval with greater value, then will not have an effect on the power and it can be discarded.",
        "Hint 3 In order to not change the power, we can only add intervals that strictly contain an interval with greater value. Afterwards, if is not the endpoint of an interval, equals the largest value of an interval containing .",
        "Hint 4 There will only be at most one interval that we have to add. Assume that there are multiple intervals that we can add without changing the answer. In this case it is easy to see that its more optimal to combine the interval with smaller value into the interval with larger value. Thus, it is never optimal to add multiple intervals.",
        "Hint 1 If we want to answer one of the questions (say, the question involving all the events) in polynomial time, how do we do it?",
        "Hint 2 Construct a network with edges from the source to each of the red panda events with capacities equal to the number of red pandas, edges from red panda events to blue panda events with innite capacities if the red pandas can catch the corresponding blue pandas, and edges from each of the blue panda events to the sink with capacities equal to the number of blue pandas.",
        "Hint 3 The next step is to use the max-flow min-cut theorem: the maximum flow is equal to the minimum number of red pandas plus blue pandas we need to remove from the graph such that no remaining red panda can reach any remaining blue panda. How do we go from here?",
        "Hint 4 For any cut, consider the region of the - plane reachable by the remaining red pandas. No remaining blue pandas can lie in this region, and its border is a polyline that intersects each vertical line in the - plane exactly once. Furthermore, the slope of every segment in this polyline has slope plus or minus . Conversely, we can associate every polyline satisfying this condition with a cut; we just need to remove every red panda lying below the polyline and every blue panda lying on or above the polyline. Now, figure out how to answer the queries online."
    ]
}