{
    "link": "https://codeforces.com//contest/814/problem/D",
    "problemId": "108816",
    "problem_idx": "D",
    "shortId": "814D",
    "contest_number": "814",
    "problem_submissions": {
        "D": [
            27647493,
            27672108,
            27640106,
            27643923,
            27641961,
            27641720,
            27642103,
            27641350,
            27644262,
            27643542,
            27643790,
            27645753,
            27644413,
            27642630,
            27644185,
            27644064,
            27644363,
            27643194,
            27644293,
            27646026
        ],
        "C": [
            27645217,
            27635551,
            27636661,
            27634217,
            27636436,
            27636571,
            27637453,
            27638720,
            27637173,
            27637214,
            27639563,
            27637118,
            27638741,
            27639783,
            27640321,
            27639165,
            27639941,
            27659642,
            27639358,
            27640727,
            27637633
        ],
        "A": [
            27642326,
            27632216,
            27632277,
            27632196,
            27632419,
            27632275,
            27632342,
            27633234,
            27632333,
            27632408,
            27632471,
            27632235,
            27632967,
            27632675,
            27632317,
            27633643,
            27632625,
            27632707,
            27632622,
            27632717
        ],
        "E": [
            27641600,
            27647168,
            27666856,
            27661378,
            27652552,
            27730170,
            27729667,
            27669973,
            27692659
        ],
        "B": [
            27634262,
            27635046,
            27632554,
            27634627,
            27634088,
            27635201,
            27635429,
            27634469,
            27634865,
            27635554,
            27634700,
            27635414,
            27636492,
            27635586,
            27636132,
            27636741,
            27636455,
            27636685,
            27634894
        ]
    },
    "name": "D. An overnight dance in discotheque",
    "statement": "The crowdedness of the discotheque would never stop our friends from\r\nhaving fun, but a bit more spaciousness won’t hurt, will it?The\r\ndiscotheque can be seen as an infinite -plane, in which there are a\r\ntotal of dancers. Once someone starts moving around, they will move only\r\ninside their own movement range, which is a circular area described by a\r\ncenter and a radius . , that is for every pair () either ranges and are\r\ndisjoint, or one of them is a subset of the other. Note that it’s\r\npossible that two ranges’ borders share a single common point, but no\r\ntwo dancers have exactly the same ranges.Tsukihi, being one of them,\r\ndefines the to be . An example is shown below, with shaded regions\r\nrepresenting the if everyone moves at the same time. But no one keeps\r\nmoving for the whole night after all, so the whole night’s time is\r\ndivided into two halves before midnight and after midnight. Every dancer\r\nmoves around in one half, while sitting down with friends in the other.\r\nThe of two halves are calculated separately and their sum should, of\r\ncourse, be as large as possible. The following figure shows an optimal\r\nsolution to the example above. By different plans of who dances in the\r\nfirst half and who does in the other, different sums of over two halves\r\nare achieved. You are to find the largest achievable value of this sum.\r\n",
    "solutions": [
        "/*\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst ld PI = atan2(0, -1);\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint p[maxn];\n\nvector<int> e[maxn];\n\nint n;\n\npair<ll, pair<ll, ll> > a[maxn];\n\nll dist(pair<ll, ll> x, pair<ll, ll> y){\n    return sqr(x.first - y.first) + sqr(x.second - y.second);\n}\n\nbool vis[maxn];\n\nld answer;\n\nll fun(int h){\n    if (h < 2 || (h & 1) == 1)\n        return 1;\n    return -1;\n}\n\nvoid dfs(int v, int h){\n    vis[v] = 1;\n    answer += PI * a[v].first * a[v].first * fun(h);\n    for (int i = 0; i < e[v].size(); i++)\n        dfs(e[v][i], h + 1);\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(\"a.in\");\n    ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i].second.first >> a[i].second.second >> a[i].first, p[i] = -1;\n    sort(a, a + n);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < i; j++)\n            if (dist(a[i].second, a[j].second) <= a[i].first * a[i].first && p[j] == -1)\n                e[i].push_back(j), p[j] = i;\n    for (int i = n - 1; i >= 0; i--)\n        if (!vis[i])\n            dfs(i, 0);\n    cout << fixed << setprecision(20) << answer;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "geometry",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. An overnight dance in discotheque.json",
    "editorial_link": "https://codeforces.com//blog/entry/52449",
    "editorial": "Circlesâ borders do not intersect, that is, each circle is \"directly\"\r\ncontained in another circle, or is among the outermost ones. Can you see\r\na tree/forest structure out of this?We create a node for each of the\r\ncircles , with weight equal to its area . Its parent is the circle which\r\n\"directly\" contains it, namely the one with smallest radius among those\r\ncircles containing . If a circle is an outermost one, then itâs made a\r\nroot. This tree structure can be found in time.Consider what happens if\r\nthereâs only one group: the equals the sum of weights of all nodes whose\r\ndepths are even, minus the sum of weights of all nodes whose depths are\r\nodd. Now we are to split the original tree/forest into two disjoint\r\ngroups. This inspires us to think of a DP approach consider a vertex ,\r\nand the parity (oddness/evenness) of number of nodes in its ancestors\r\nfrom the first and the second group. Under this state, let be the\r\nlargest achievable answer in âs subtree.The recursion can be done from\r\nbottom to top in , and the answer we need is the sum of for all being\r\nroots. Time complexity is for the tree part and for the DP part. See the\r\ncode for the complete recursion. Build the tree in time. Find different\r\ngreedy solutions for this problem and try to prove their correctness.\r\n",
    "hint": []
}