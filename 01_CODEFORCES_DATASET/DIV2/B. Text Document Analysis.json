{"link": "https://codeforces.com//contest/723/problem/B", "problemId": "74118", "problem_idx": "B", "shortId": "723B", "contest_number": "723", "problem_submissions": {"F": [21155697, 21154113, 21155933, 21154904, 21149973, 21159426, 21152095, 21153693, 21156752, 21154148, 21155446, 21158512, 21156719, 21157841, 63684195, 21157428, 21156472, 21165079], "D": [21145243, 21158845, 21147482, 21142220, 21145053, 21143706, 21144743, 21145722, 21163140, 21144768, 21147552, 21144060, 21144166, 21146675, 21148374, 21147946, 21149603, 21146889, 21147955, 21145653], "E": [21142890, 21148616, 21159045, 21149920, 21158556, 21150731, 21180051, 21153029, 21177875, 21161980, 21155864, 21154968, 21148045], "C": [21140474, 21141296, 21140148, 21162108, 21142166, 21146292, 21147879, 21142862, 21142174, 21148589, 21144499, 21141215, 21141347, 21144291, 21144339, 21143781, 21144417, 21143640, 21144289, 21142493], "B": [21138785, 21138330, 21144052, 21141269, 21138610, 21139747, 21138581, 21138753, 21138976, 21139782, 21142236, 21137955, 21139130, 21139752, 21139693, 21141265, 21138488, 21140188, 21156231], "A": [21135605, 21135289, 21141496, 21135525, 21135366, 21137068, 21135345, 21136036, 21135454, 21135984, 21136355, 21135335, 21136286, 21136540, 21136310, 21138762, 21135363, 21135712, 21156449]}, "name": "B. Text Document Analysis", "statement": "Modern text editors usually show some information regarding the document\r\nbeing edited. For example, the number of words, the number of pages, or\r\nthe number of characters.In this problem you should implement the\r\nsimilar functionality.You are given a string which only consists of:\r\nuppercase and lowercase English letters, underscore symbols (they are\r\nused as separators), parentheses (both opening and closing). It is\r\nguaranteed that each opening parenthesis has a succeeding closing\r\nparenthesis. Similarly, each closing parentheses has a preceding opening\r\nparentheses matching it. For each pair of matching parentheses there are\r\nno other parenthesis between them. In other words, each parenthesis in\r\nthe string belongs to a matching \"opening-closing\" pair, and such pairs\r\ncan\u2019t be nested.For example, the following string is valid: \"\". is a\r\nmaximal sequence of consecutive letters, i.e. such sequence that the\r\nfirst character to the left and the first character to the right of it\r\nis an underscore, a parenthesis, or it just does not exist. For example,\r\nthe string above consists of seven words: \"\", \"\", \"\", \"\", \"\", \"\" and \"\".\r\nWrite a program that finds: the length of the longest word outside the\r\nparentheses (print , if there is no word outside the parentheses), the\r\nnumber of words inside the parentheses (print , if there is no word\r\ninside the parentheses).\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tstring st, cur;\n\tcin >> st;\n\tint inp(0);\n\tint ans1(0), ans2(0);\n\tst.push_back('(');\n\tfor(int i(0); i < (int)st.size(); i++) {\n\t\tif(st[i] == '_' || st[i] == '(' || st[i] == ')') {\n\t\t\tif(!cur.empty()) {\n\t\t\t\tif(inp) {\n\t\t\t\t\tans2++;\n\t\t\t\t}else {\n\t\t\t\t\tans1 = max(ans1, (int)cur.size());\n\t\t\t\t}\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t\tif(st[i] == '(') {\n\t\t\t\tinp = true;\n\t\t\t}else if(st[i] == ')') {\n\t\t\t\tinp = false;\n\t\t\t}\n\t\t}else {\n\t\t\tcur.push_back(st[i]);\n\t\t}\n\t}\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n"], "input": "", "output": "", "tags": ["expression parsing", "implementation", "strings"], "dificulty": "1100", "interactive": false}