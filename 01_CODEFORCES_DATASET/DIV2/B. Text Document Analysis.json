{
    "link": "https://codeforces.com//contest/723/problem/B",
    "problemId": "74118",
    "problem_idx": "B",
    "shortId": "723B",
    "contest_number": "723",
    "problem_submissions": {
        "F": [
            21155697,
            21154113,
            21155933,
            21154904,
            21149973,
            21159426,
            21152095,
            21153693,
            21156752,
            21154148,
            21155446,
            21158512,
            21156719,
            21157841,
            63684195,
            21157428,
            21156472,
            21165079
        ],
        "D": [
            21145243,
            21158845,
            21147482,
            21142220,
            21145053,
            21143706,
            21144743,
            21145722,
            21163140,
            21144768,
            21147552,
            21144060,
            21144166,
            21146675,
            21148374,
            21147946,
            21149603,
            21146889,
            21147955,
            21145653
        ],
        "E": [
            21142890,
            21148616,
            21159045,
            21149920,
            21158556,
            21150731,
            21180051,
            21153029,
            21177875,
            21161980,
            21155864,
            21154968,
            21148045
        ],
        "C": [
            21140474,
            21141296,
            21140148,
            21162108,
            21142166,
            21146292,
            21147879,
            21142862,
            21142174,
            21148589,
            21144499,
            21141215,
            21141347,
            21144291,
            21144339,
            21143781,
            21144417,
            21143640,
            21144289,
            21142493
        ],
        "B": [
            21138785,
            21138330,
            21144052,
            21141269,
            21138610,
            21139747,
            21138581,
            21138753,
            21138976,
            21139782,
            21142236,
            21137955,
            21139130,
            21139752,
            21139693,
            21141265,
            21138488,
            21140188,
            21156231
        ],
        "A": [
            21135605,
            21135289,
            21141496,
            21135525,
            21135366,
            21137068,
            21135345,
            21136036,
            21135454,
            21135984,
            21136355,
            21135335,
            21136286,
            21136540,
            21136310,
            21138762,
            21135363,
            21135712,
            21156449
        ]
    },
    "name": "B. Text Document Analysis",
    "statement": "Modern text editors usually show some information regarding the document\r\nbeing edited. For example, the number of words, the number of pages, or\r\nthe number of characters.In this problem you should implement the\r\nsimilar functionality.You are given a string which only consists of:\r\nuppercase and lowercase English letters, underscore symbols (they are\r\nused as separators), parentheses (both opening and closing). It is\r\nguaranteed that each opening parenthesis has a succeeding closing\r\nparenthesis. Similarly, each closing parentheses has a preceding opening\r\nparentheses matching it. For each pair of matching parentheses there are\r\nno other parenthesis between them. In other words, each parenthesis in\r\nthe string belongs to a matching \"opening-closing\" pair, and such pairs\r\ncan\u2019t be nested.For example, the following string is valid: \"\". is a\r\nmaximal sequence of consecutive letters, i.e. such sequence that the\r\nfirst character to the left and the first character to the right of it\r\nis an underscore, a parenthesis, or it just does not exist. For example,\r\nthe string above consists of seven words: \"\", \"\", \"\", \"\", \"\", \"\" and \"\".\r\nWrite a program that finds: the length of the longest word outside the\r\nparentheses (print , if there is no word outside the parentheses), the\r\nnumber of words inside the parentheses (print , if there is no word\r\ninside the parentheses).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tstring st, cur;\n\tcin >> st;\n\tint inp(0);\n\tint ans1(0), ans2(0);\n\tst.push_back('(');\n\tfor(int i(0); i < (int)st.size(); i++) {\n\t\tif(st[i] == '_' || st[i] == '(' || st[i] == ')') {\n\t\t\tif(!cur.empty()) {\n\t\t\t\tif(inp) {\n\t\t\t\t\tans2++;\n\t\t\t\t}else {\n\t\t\t\t\tans1 = max(ans1, (int)cur.size());\n\t\t\t\t}\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t\tif(st[i] == '(') {\n\t\t\t\tinp = true;\n\t\t\t}else if(st[i] == ')') {\n\t\t\t\tinp = false;\n\t\t\t}\n\t\t}else {\n\t\t\tcur.push_back(st[i]);\n\t\t}\n\t}\n\tcout << ans1 << ' ' << ans2 << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "expression parsing",
        "implementation",
        "strings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Text Document Analysis.json",
    "editorial_link": "https://codeforces.com//blog/entry/47502",
    "editorial": "It is an implementation problem. Let\u00e2\u0080\u0099s store in the variable the number\r\nof words inside brackets and in the variable the maximum length of the\r\nword outside brackets. You can add the symbol to the end of the given\r\nstring, to correctly process the last word.Let\u00e2\u0080\u0099s iterate through the\r\ngiven string from the left to the right and store in the variable the\r\ncurrent word. Also in the variable we need to store balance of the open\r\nand close brackets.If the current symbol is letter add it to the end of\r\nthe string and go to the next symbol of the given string.If the current\r\nsymbol is open bracket, make . If the current symbol is close bracket,\r\nmake . After that if is non-empty string add 1 to if equals to . Else if\r\nequals to update with length of the string . After that we need to\r\nassign to the empty string and go to the next symbol of the given\r\nstring.\r\n"
}