{"link": "https://codeforces.com//contest/1888/problem/E", "problemId": "2278993", "problem_idx": "E", "shortId": "1888E", "contest_number": "1888", "problem_submissions": {"F": [229262682, 229268295, 229279653, 229267586, 229284334, 229285219, 229276083, 229277377, 229286489, 229272406, 229252945, 229288627, 229285987, 229284770, 229272187, 229286826, 229310887, 229370513, 229258123], "E": [229238149, 229253666, 229242208, 229240816, 229251553, 229257846, 229263590, 229246780, 229256433, 229260591, 229262076, 229254649, 229262399, 229264412, 229251739, 229252208, 229245030, 229246776, 229279792, 229232132], "D1": [229222092, 229223803, 229219681, 229242098, 229224322, 229226334, 229230293, 229225358, 229225894, 229221773, 229390860, 229390801, 229280774, 229219651, 229226571, 229247689, 229239543, 229239851, 229221782, 229224303, 229234438, 229241304], "D2": [229221620, 229240091, 229246606, 229255361, 229242055, 229240834, 229234843, 229232629, 229235145, 229252762, 229279873, 229223341, 229239577, 229247845, 229239473, 229239980, 229230893, 229230000, 229249174], "C": [229213092, 229215650, 229211600, 229221568, 229217105, 229211091, 229222386, 229215704, 229220556, 229215982, 229217769, 229237908, 229219310, 229234524, 229356337, 229293687, 229216398, 229217719, 229216289, 229211094], "B": [229206630, 229208842, 229207631, 229222626, 229213726, 229207125, 229214934, 229208511, 229211534, 229208329, 229211710, 229231180, 229214082, 229214817, 229207834, 229209367, 229209606, 229206410, 229208095, 229206540], "A": [229204153, 229204837, 229204508, 229215610, 229209518, 229204005, 229205998, 229204440, 229204217, 229204234, 229205240, 229226330, 229204261, 229205698, 229204405, 229204097, 229205791, 229203960, 229211403, 229235978]}, "name": "E. Time Travel", "statement": "Berland is a country with ancient history, where roads were built and\r\ndestroyed for centuries. It is known that there always were n cities in\r\nBerland. You also have records of t key moments in the history of the\r\ncountry, numbered from 1 to t. Each record contains a list of roads\r\nbetween some pairs of cities, which could be used for travel in Berland\r\nat a specific moment in time.You have discovered a time machine that\r\ntransports you between key moments. Unfortunately, you cannot choose\r\nwhat point in time to end up at, but you know the order consisting of k\r\nmoments in time a_{i}, in which the machine will transport you. Since\r\nthere is little time between the travels, when you find yourself in the\r\nnext key moment in time (), you can travel on at most one existing road\r\nat that moment, coming out from the city you were in before time\r\ntravel.Currently, you are in city 1, and the time machine has already\r\ntransported you to moment a_{1}. You want to reach city n as quickly as\r\npossible. Determine the minimum number of time travels, , that you need\r\nto make in order to reach city n.\r\n", "solutions": ["#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<queue>\nconst int maxn=2e5+5;\nstruct pii{\n\tint v,id;\n\tfriend bool operator>(pii now,pii oth){return now.id>oth.id;}\n};\nint n,k,t;\nint tp[maxn];\nstd::vector<pii>lin[maxn];\nstd::vector<int>apr[maxn];\nbool in[maxn];\nstd::priority_queue<pii,std::vector<pii>,std::greater<pii>>q;\nvoid put(int x,int ti){\n\tin[x]=true;\n//\tprintf(\"put:%d,%d\\n\",x,ti);\n\tfor(pii now:lin[x])if(!in[now.v]){\n\t\tif(apr[now.id].empty())continue;\n\t\tif(apr[now.id].back()<=ti)continue;\n\t\tint nv=*std::upper_bound(apr[now.id].begin(),apr[now.id].end(),ti);\n//\t\tprintf(\"{%d,%d}\\n\",now.v,nv);\n\t\tq.push((pii){now.v,nv});\n\t}\n\treturn;\n}\nsigned main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=k;i++){\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y),lin[x].push_back((pii){y,i}),lin[y].push_back((pii){x,i});\n\t\t}\n\t}\n\tscanf(\"%d\",&t);\n\tfor(int i=1;i<=t;i++)scanf(\"%d\",tp+i),apr[tp[i]].push_back(i);\n\tput(1,0);\n\tfor(int i=1;i<=t;i++){\n\t\twhile(!q.empty()){\n\t\t\tif(q.top().id>i)break;\n\t\t\tpii now=q.top();\n\t\t\tq.pop();\n\t\t\tif(in[now.v])continue;\n\t\t\tput(now.v,i);\n\t\t}\n\t\tif(in[n]){\n\t\t\tprintf(\"%d\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"-1\");\n\treturn 0;\n}\n//namespace burningContract\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "graphs", "implementation", "shortest paths"], "dificulty": "1900", "interactive": false}