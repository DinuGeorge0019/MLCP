{
    "link": "https://codeforces.com//contest/1516/problem/C",
    "problemId": "963908",
    "problem_idx": "C",
    "shortId": "1516C",
    "contest_number": "1516",
    "problem_submissions": {
        "D": [
            113744317,
            113734893,
            113732174,
            113735658,
            113736689,
            113753948,
            113752217,
            113742709,
            113733277,
            113772079,
            113758509,
            113765675,
            113749541,
            113745751,
            113782529,
            113747411,
            113750921,
            113756461
        ],
        "B": [
            113738828,
            113716225,
            113717222,
            113722044,
            113718441,
            113730595,
            113730731,
            113724024,
            113714979,
            113731503,
            113722149,
            113770715,
            113734481,
            113725894,
            113728293,
            113726022,
            113720823,
            113721935
        ],
        "A": [
            113731086,
            113713802,
            113713787,
            113716079,
            113713803,
            113733865,
            113718261,
            113723529,
            113713794,
            113715315,
            113715862,
            113721754,
            113725712,
            113721388,
            113714099,
            113715023,
            113714544
        ],
        "C": [
            113728258,
            113723880,
            113721257,
            113726835,
            113726539,
            113723017,
            113756433,
            113727327,
            113747091,
            113766829,
            113742469,
            113777547,
            113761975,
            113734529,
            113746406,
            113736795,
            113734065,
            113734539
        ],
        "E": [
            113723992,
            113762256,
            113769222,
            113761842,
            113767857,
            113776100,
            113769406,
            113784620,
            113781943,
            113761572,
            113785543,
            113747187,
            113860370,
            113784367,
            113787186,
            113776311,
            113821800
        ]
    },
    "name": "C. Baby Ehab Partitions Again",
    "statement": "Baby Ehab was toying around with arrays. He has an array a of length n.\r\nHe defines an array to be good if there’s no way to partition it into 2\r\nsubsequences such that the sum of the elements in the first is equal to\r\nthe sum of the elements in the second. Now he wants to remove the\r\nminimum number of elements in a so that it becomes a good array. Can you\r\nhelp him?A sequence b is a subsequence of an array a if b can be\r\nobtained from a by deleting some (possibly zero or all) elements. A\r\npartitioning of an array is a way to divide it into 2 subsequences such\r\nthat every element belongs to exactly one subsequence, so you must use\r\nall the elements, and you can’t share any elements.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,a[2002],sum,G;\nbitset<200002>B;\nint main(){\n\tn=read(),B[0]=1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=read(),sum+=a[i];\n\t\tB|=(B<<a[i]);\n\t}\n\tif((sum&1)||(!B[sum>>1]))return puts(\"0\"),0;\n\tG=a[1];\n\tfor(re int i=2;i<=n;++i)G=__gcd(G,a[i]);\n\tfor(re int i=1;i<=n;++i)a[i]/=G;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]&1){\n\t\t\tprintf(\"1\\n%d\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Baby Ehab Partitions Again.json",
    "editorial_link": "https://codeforces.com//blog/entry/89846",
    "editorial": "First of all, letâs check if the array is already good. This can be done\r\nwith knapsack dp. If it is, the answer is . If it isnât, I claim you can\r\nalways remove one element to make it good, and hereâs how to find it:\r\nSince the array can be partitioned, its sum is even. So if we remove an\r\nodd element, it will be odd, and there will be no way to partition it.\r\nIf thereâs no odd element, then all elements are even. But then, you can\r\ndivide all the elements by without changing the answer. Why? Because a\r\npartitioning in the new array after dividing everything by is a\r\npartitioning in the original array and vice versa. We just re-scaled\r\neverything. So, while all the elements are even, you can keep dividing\r\nby , until one of the elements becomes odd. Remove it and youâre done.\r\nIf you want the solution in one sentence, remove the element with the\r\nsmallest possible least significant bit. Alternatively, for a very\r\nsimilar reasoning, you can start by dividing the whole array by its and\r\nremove any odd element (which must exist because the is ,) but I think\r\nthis doesnât give as much insight ;) Code link:\r\nhttps://pastebin.com/aiknVwkZ\r\n",
    "hint": []
}