{"link": "https://codeforces.com//contest/1516/problem/C", "problemId": "963908", "problem_idx": "C", "shortId": "1516C", "contest_number": "1516", "problem_submissions": {"D": [113744317, 113734893, 113732174, 113735658, 113736689, 113753948, 113752217, 113742709, 113733277, 113772079, 113758509, 113765675, 113749541, 113745751, 113782529, 113747411, 113750921, 113756461], "B": [113738828, 113716225, 113717222, 113722044, 113718441, 113730595, 113730731, 113724024, 113714979, 113731503, 113722149, 113770715, 113734481, 113725894, 113728293, 113726022, 113720823, 113721935], "A": [113731086, 113713802, 113713787, 113716079, 113713803, 113733865, 113718261, 113723529, 113713794, 113715315, 113715862, 113721754, 113725712, 113721388, 113714099, 113715023, 113714544], "C": [113728258, 113723880, 113721257, 113726835, 113726539, 113723017, 113756433, 113727327, 113747091, 113766829, 113742469, 113777547, 113761975, 113734529, 113746406, 113736795, 113734065, 113734539], "E": [113723992, 113762256, 113769222, 113761842, 113767857, 113776100, 113769406, 113784620, 113781943, 113761572, 113785543, 113747187, 113860370, 113784367, 113787186, 113776311, 113821800]}, "name": "C. Baby Ehab Partitions Again", "statement": "Baby Ehab was toying around with arrays. He has an array a of length n.\r\nHe defines an array to be good if there\u2019s no way to partition it into 2\r\nsubsequences such that the sum of the elements in the first is equal to\r\nthe sum of the elements in the second. Now he wants to remove the\r\nminimum number of elements in a so that it becomes a good array. Can you\r\nhelp him?A sequence b is a subsequence of an array a if b can be\r\nobtained from a by deleting some (possibly zero or all) elements. A\r\npartitioning of an array is a way to divide it into 2 subsequences such\r\nthat every element belongs to exactly one subsequence, so you must use\r\nall the elements, and you can\u2019t share any elements.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,a[2002],sum,G;\nbitset<200002>B;\nint main(){\n\tn=read(),B[0]=1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=read(),sum+=a[i];\n\t\tB|=(B<<a[i]);\n\t}\n\tif((sum&1)||(!B[sum>>1]))return puts(\"0\"),0;\n\tG=a[1];\n\tfor(re int i=2;i<=n;++i)G=__gcd(G,a[i]);\n\tfor(re int i=1;i<=n;++i)a[i]/=G;\n\tfor(re int i=1;i<=n;++i){\n\t\tif(a[i]&1){\n\t\t\tprintf(\"1\\n%d\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "dp", "math"], "dificulty": "1700", "interactive": false}