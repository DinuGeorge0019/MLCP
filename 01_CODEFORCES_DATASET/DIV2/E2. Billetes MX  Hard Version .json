{
    "link": "https://codeforces.com//contest/2022/problem/E2",
    "problemId": "2947280",
    "problem_idx": "E2",
    "shortId": "2022E2",
    "contest_number": "2022",
    "problem_submissions": {
        "D1": [
            285726010,
            285732443,
            285720467,
            285721725,
            285710598,
            285716496,
            285709185,
            285722223,
            285721840,
            285726265,
            285729782,
            285729870,
            285772115,
            285771713,
            285716249,
            285713460,
            285712248,
            285718533,
            285715843
        ],
        "E2": [
            285719910,
            285720748,
            285735574,
            285735176,
            288055359,
            286524378,
            285733091,
            285771493,
            285770412,
            285770170,
            285769301
        ],
        "E1": [
            285717777,
            285720862,
            285735538,
            285732412,
            285730131,
            285734694,
            285730466,
            285740393,
            285736961,
            285737293,
            285738689,
            285733822,
            285723809
        ],
        "C": [
            285713470,
            285709435,
            285713964,
            285712717,
            285726534,
            285712313,
            285728850,
            285716262,
            285717872,
            285721376,
            285719625,
            285718527,
            285713136,
            285713916,
            285709969,
            285709168,
            285707306,
            285710892,
            285710354
        ],
        "B": [
            285703660,
            285702595,
            285706421,
            285702197,
            285705976,
            285703966,
            285719780,
            285706485,
            285711437,
            285705925,
            285707565,
            285707987,
            285708651,
            285708053,
            285702275,
            285704156,
            285708490,
            285702360,
            285704264
        ],
        "A": [
            285702679,
            285701420,
            285703196,
            285701332,
            285704286,
            285701973,
            285705578,
            285709500,
            285703987,
            285704902,
            285704417,
            285704940,
            285701496,
            285701330,
            285702274,
            285701454,
            285701489,
            285702531
        ],
        "D2": [
            286191597,
            285736183,
            290850953,
            285816124
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135095",
    "editorial": "Please read the solution to E1 beforehand, as well as all the hints.\r\nSolution 1Through the observations in E1, we can reduce the problem to\r\nthe following: We have a graph, we add edges, and we want to determine\r\nafter each addition if all its cycles have xor 0, and the number of\r\nconnected components in the graph.The edges are never removed, so\r\nwhenever an edge is added that creates a cycle with xor distinct to\r\nzero, this cycle will stay in the graph for all following updates. So we\r\ncan binary search the first addition that creates a cycle with xor\r\ndistinct to zero, using the same dfs we used in E1. After the first such\r\nedge, the answer will always be zero. Now, for all the additions before\r\nthat, we must determine how many connected components the graph has at\r\neach step. But this is easily solvable with Disjoint Set\r\nUnion.Complexity: .\r\n",
    "name": "E2. Billetes MX  Hard Version ",
    "statement": "An integer grid A with p rows and q columns is called if: All elements\r\nof the grid are integers between 0 and 2^{30}-1, and For any subgrid,\r\nthe XOR of the values at the corners is equal to 0. Formally, for any\r\nfour integers i_1, i_2, j_1, j_2 (1\r\nle i_1 < i_2\r\nle p; 1\r\nle j_1 < j_2\r\nle q), A_{i_1, j_1}\r\noplus A_{i_1, j_2}\r\noplus A_{i_2, j_1}\r\noplus A_{i_2, j_2} = 0, where\r\noplus denotes the bitwise XOR operation. There is a partially filled\r\ninteger grid G with n rows and m columns where only k cells are filled.\r\nPolycarp wants to know how many ways he can assign integers to the\r\nunfilled cells so that the grid is beautiful.However, Monocarp thinks\r\nthat this problem is too easy. Therefore, he will perform q updates on\r\nthe grid. In each update, he will choose an unfilled cell and assign an\r\ninteger to it. Note that these updates are . That is, changes made to\r\nthe grid will apply when processing future updates.For each of the q + 1\r\nstates of the grid, the initial state and after each of the q queries,\r\ndetermine the number of ways Polycarp can assign integers to the\r\nunfilled cells so that the grid is beautiful. Since this number can be\r\nvery large, you are only required to output their values modulo 10^9+7.\r\n",
    "solutions": [
        "#line 1 \"library/Template/template.hpp\"#include <bits/stdc++.h>using namespace std;\u00a0#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin())\u00a0using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff;\u00a0template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));}\u00a0template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << \"P(\" << p.first << \", \" << p.second << \")\";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << \"{\";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");    }    os << \"}\";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << \"{\";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << \"(\" << itr->first << \", \" << itr->second << \")\";        itr++;        if (itr != map_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << \"{\";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << '\\n';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != ',' && a[i] != '\\0'; i++)        cerr << a[i];    cerr << \":\" << b << \" \";    _show(i + 1, a, c...);}#line 2 \"library/Utility/fastio.hpp\"#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf\u00a0uint32_t pil = 0, pir = 0, por = 0;\u00a0struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | '0';                n /= 10;            }        }    }} constexpr pre;\u00a0inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = '\\n';}\u00a0inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;}\u00a0void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));}\u00a0void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));}\u00a0template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);}\u00a0template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < '-');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == '-') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while ('0' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }}\u00a0void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);}\u00a0template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);}\u00a0template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);}\u00a0void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);}\u00a0void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);}\u00a0template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = '-', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | '0';        obuf[por + 1] = (x - q * 10) | '0';        por += 2;    } else        obuf[por++] = x | '0';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;}\u00a0template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);}\u00a0void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);}\u00a0template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(' ');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(' ');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }}\u00a0void print() {    wt('\\n');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(' ');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio\u00a0using fastio::flush;using fastio::print;using fastio::read;\u00a0inline void first(bool i = true) {    print(i ? \"first\" : \"second\");}inline void Alice(bool i = true) {    print(i ? \"Alice\" : \"Bob\");}inline void Takahashi(bool i = true) {    print(i ? \"Takahashi\" : \"Aoki\");}inline void yes(bool i = true) {    print(i ? \"yes\" : \"no\");}inline void Yes(bool i = true) {    print(i ? \"Yes\" : \"No\");}inline void No() {    print(\"No\");}inline void YES(bool i = true) {    print(i ? \"YES\" : \"NO\");}inline void NO() {    print(\"NO\");}inline void Yay(bool i = true) {    print(i ? \"Yay!\" : \":(\");}inline void Possible(bool i = true) {    print(i ? \"Possible\" : \"Impossible\");}inline void POSSIBLE(bool i = true) {    print(i ? \"POSSIBLE\" : \"IMPOSSIBLE\");}\u00a0/** * @brief Fast IO */#line 3 \"sol.cpp\"\u00a0#line 2 \"library/Math/modint.hpp\"\u00a0template <unsigned mod = 1000000007> struct fp {    unsigned v;    static constexpr int get_mod() {        return mod;    }    constexpr unsigned inv() const {        assert(v != 0);        int x = v, y = mod, p = 1, q = 0, t = 0, tmp = 0;        while (y > 0) {            t = x / y;            x -= t * y, p -= t * q;            tmp = x, x = y, y = tmp;            tmp = p, p = q, q = tmp;        }        if (p < 0)            p += mod;        return p;    }    constexpr fp(ll x = 0) : v(x >= 0 ? x % mod : (mod - (-x) % mod) % mod) {}    fp operator-() const {        return fp() - *this;    }    fp pow(ull t) {        fp res = 1, b = *this;        while (t) {            if (t & 1)                res *= b;            b *= b;            t >>= 1;        }        return res;    }    fp &operator+=(const fp &x) {        if ((v += x.v) >= mod)            v -= mod;        return *this;    }    fp &operator-=(const fp &x) {        if ((v += mod - x.v) >= mod)            v -= mod;        return *this;    }    fp &operator*=(const fp &x) {        v = ull(v) * x.v % mod;        return *this;    }    fp &operator/=(const fp &x) {        v = ull(v) * x.inv() % mod;        return *this;    }    fp operator+(const fp &x) const {        return fp(*this) += x;    }    fp operator-(const fp &x) const {        return fp(*this) -= x;    }    fp operator*(const fp &x) const {        return fp(*this) *= x;    }    fp operator/(const fp &x) const {        return fp(*this) /= x;    }    bool operator==(const fp &x) const {        return v == x.v;    }    bool operator!=(const fp &x) const {        return v != x.v;    }    friend istream &operator>>(istream &is, fp &x) {        return is >> x.v;    }    friend ostream &operator<<(ostream &os, const fp &x) {        return os << x.v;    }};\u00a0template <unsigned mod> void rd(fp<mod> &x) {    fastio::rd(x.v);}template <unsigned mod> void wt(fp<mod> x) {    fastio::wt(x.v);}\u00a0/** * @brief Modint */#line 5 \"sol.cpp\"using Fp = fp<>;\u00a0#line 2 \"library/DataStructure/weightedunionfind.hpp\"\u00a0template <typename T> struct WeightedUnionFind {    int n;    vector<int> par;    vector<T> pot;    WeightedUnionFind(int _n = 0) : n(_n), par(n, -1), pot(n) {}    int root(int x) {        if (par[x] < 0)            return x;        else {            int r = root(par[x]);            pot[x] = pot[par[x]] + pot[x];            return par[x] = r;        }    }    bool same(int x, int y) {        return root(x) == root(y);    }    int size(int x) {        return -par[root(x)];    }    T diff(int x, int y) {        root(x);        root(y);        return -pot[y] + pot[x];    }    bool unite(int x, int y, T w) {        int rx = root(x), ry = root(y);        if (rx == ry)            return false;        if (par[rx] < par[ry])            swap(x, y), swap(rx, ry), w = -w;        par[ry] += par[rx];        par[rx] = ry;        pot[rx] = pot[y] + w - pot[x];        n--;        return true;    }};\u00a0/** * @brief Weighted Union Find */#line 8 \"sol.cpp\"\u00a0void solve(int _rot) {    // write(\"Case #\"+to_string(_rot)+\": \");    int n, m, k, Q;    read(n, m, k, Q);\u00a0    vector<int> X(k), Y(k), V(k);    rep(i, 0, k) {        read(X[i], Y[i], V[i]);        X[i]--, Y[i]--;    }\u00a0    vector uni(32, WeightedUnionFind<int>(n + m));    bool ch = 1;    auto push = [&](int x, int y, int v) -> void {        rep(b, 0, 30) {            if (!uni[b].unite(x, y + n, v >> b & 1)) {                int d = uni[b].diff(x, y + n);                if ((d & 1) != (v >> b & 1)) {                    ch = 0;                }            }        }    };    auto que = [&]() -> Fp {        if (!ch)            return 0;        Fp ret = 1;        rep(b, 0, 30) ret *= Fp(2).pow(uni[b].n - 1);        return ret;    };    rep(i, 0, k) push(X[i], Y[i], V[i]);    print(que());    while (Q--) {        int x, y, v;        read(x, y, v);        x--, y--;        push(x, y, v);        print(que());    }}\u00a0int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "data structures",
        "dsu",
        "graphs"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Billetes MX  Hard Version .json"
}