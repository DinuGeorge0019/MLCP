{
    "link": "https://codeforces.com//contest/1481/problem/E",
    "problemId": "888835",
    "problem_idx": "E",
    "shortId": "1481E",
    "contest_number": "1481",
    "problem_submissions": {
        "E": [
            106575657,
            106580122,
            106571072,
            106587922,
            106596561,
            106601300,
            106598150,
            106588203,
            106555230,
            106601691,
            106603323,
            106598805,
            106606116,
            106598692,
            106597406,
            106601560,
            106559099,
            106600288,
            106602866
        ],
        "D": [
            106568002,
            106573123,
            106565784,
            106576955,
            106573210,
            106578133,
            106576417,
            106596842,
            106581404,
            106583159,
            106580270,
            106581784,
            106581178,
            106589786,
            106588485,
            106598470,
            106585012,
            106578937,
            106593218
        ],
        "C": [
            106554240,
            106561563,
            106587826,
            106564449,
            106557128,
            106554455,
            106561081,
            106556949,
            106593975,
            106567836,
            106563207,
            106566579,
            106560187,
            106560571,
            106563380,
            106553575,
            106571925,
            106575164,
            106574000
        ],
        "B": [
            106545453,
            106545635,
            106575045,
            106557114,
            106546143,
            106544431,
            106547512,
            106547628,
            106600777,
            106555535,
            106546768,
            106552994,
            106545917,
            106549686,
            106553008,
            106544154,
            106594934,
            106546830,
            106553782
        ],
        "A": [
            106540084,
            106539696,
            106539972,
            106539768,
            106541130,
            106540757,
            106539872,
            106540973,
            106602935,
            106540095,
            106541018,
            106540813,
            106540248,
            106541459,
            106539556,
            106539597,
            106547797,
            106540934,
            106542940
        ],
        "F": [
            106632220,
            111955794,
            218518749,
            218505572
        ]
    },
    "name": "E. Sorting Books",
    "statement": "One day you wanted to read something, so you went to your bookshelf to\r\ngrab some book. But when you saw how messy the bookshelf was you decided\r\nto clean it up first. There are n books standing in a row on the shelf,\r\nthe i-th book has color a_i.Youâ€™d like to rearrange the books to make\r\nthe shelf look beautiful. The shelf is considered if all books of the\r\nsame color are next to each other.In one operation you can take one book\r\nfrom any position on the shelf and move it to the right end of the\r\nshelf.What is the minimum number of operations you need to make the\r\nshelf beautiful?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint a[500009],l[500009],r[500009],cnt[500009],mx[500009],dp[500009];\nmain(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n        if(l[a[i]] == 0) l[a[i]] = i;\n        r[a[i]] = i;\n    }\n    for(int i = n; i >= 1; i--){\n        cnt[a[i]]++;\n        mx[i] = max(mx[i+1], cnt[a[i]]);\n    }\n    int ans = mx[1];\n    for(int i = 1; i <= n; i++){\n        dp[i] = dp[i-1];\n        if(i == r[a[i]]) dp[i] = max(dp[i], cnt[a[i]] + dp[l[a[i]]-1]);\n        ans = max(ans, dp[i] + mx[i+1]);\n    }\n    cout<<n-ans<<endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sorting Books.json",
    "editorial_link": "https://codeforces.com//blog/entry/87523",
    "editorial": "Lets try to solve the opposite version of the problem where you want to\r\nfind the maximum number of books that will stay unmoved, so we will\r\nchoose number of books that will stay unmoved and then move the rest in\r\na way that will make the shelf beautiful.To do that lets first for each\r\ncolor find the leftmost and rightmost occurrence and and the frequency\r\nof this color .Then we will use which will find for each the maximum\r\nnumber of books that we can leave unmoved in the suffix .We will go from\r\nright to left and for each index the will work as follow : If , we leave\r\nall occurrences of color unmoved and move everything in between the\r\nfirst and last occurrence of color , so between and only books with\r\ncolor will stay unmoved, we can see that this will be only true if we\r\nare at the first occurrence of color (when because we want to cover the\r\nsegment ), as a result . If , we can keep all books with color in range\r\nunmoved and move everything else, as a result where is the number of\r\nbooks with color in range (we can update this array as we move) (note\r\nthat here we move all books even those after ). In either cases we can\r\nmove the book and get . The answer will be and the time is .\r\n",
    "hint": []
}