{
    "link": "https://codeforces.com//contest/279/problem/C",
    "problemId": "2703",
    "problem_idx": "C",
    "shortId": "279C",
    "contest_number": "279",
    "problem_submissions": {
        "D": [
            3249313,
            3247594,
            3244905,
            3249853,
            3249691,
            3249081,
            3250467,
            3250451,
            3250359,
            3474157
        ],
        "E": [
            3244979,
            3247752,
            3238796,
            3241502,
            3241802,
            3249970,
            3248144,
            3243573,
            3243340,
            3243108,
            3244030,
            3244923,
            3240469,
            3247041,
            3244724,
            3242537,
            3242804,
            3247622
        ],
        "C": [
            3242350,
            3240214,
            3241436,
            3243563,
            3243315,
            3242680,
            3242006,
            3239324,
            3241143,
            3241800,
            3242584,
            3244958,
            3240145,
            3241851,
            3245710,
            3247069,
            3242483
        ],
        "A": [
            3240766,
            3242016,
            3239749,
            3239283,
            3250054,
            3239155,
            3241094,
            3244109,
            3239779,
            3240700,
            3243000,
            3238846,
            3246020,
            3239320,
            3239919,
            3240334
        ],
        "B": [
            3238919,
            3240626,
            3239249,
            3238903,
            3240194,
            3239523,
            3239885,
            3242187,
            3239867,
            3240726,
            3239001,
            3243481,
            3239120,
            3239326,
            3240278,
            3240808,
            3239300
        ]
    },
    "name": "C. Ladder",
    "statement": "You\u2019ve got an array, consisting of integers . Also, you\u2019ve got queries,\r\nthe -th query is described by two integers . Numbers define a subsegment\r\nof the original array, that is, the sequence of numbers . For each query\r\nyou should check whether the corresponding segment is a ladder. A is a\r\nsequence of integers , such that it first doesn\u2019t decrease, then doesn\u2019t\r\nincrease. In other words, there is such integer , that the following\r\ninequation fulfills: . Note that the non-decreasing and the\r\nnon-increasing sequences are also considered ladders.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:256000000\")\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <stdio.h>\n#include <set>\n#include <map>\n#include <stack>\n#include <fstream>\n#include <deque>\n#include <list>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n\n#define SZ(a) (int(a.size()))\n#define MEM(a, val) memset(a, val, sizeof(a))\n#define MP(a, b) make_pair(a, b)\n#define PB(a) push_back(a)\n#define ALL(a) a.begin(), a.end()\n#define REP(i, n) for(int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))\n#define SQR(a) ((a) * (a))\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef long double dbl;\ntypedef pair<int, int> pii ;\ntypedef vector<int> vint;\ntypedef vector<LL> vLL;\n\nconst int nmax = 100009;\n\nint F1[nmax], F2[nmax];\nint a[nmax];\n\nvoid update(int F[nmax], int i, int val) {\n    for (; i < nmax; i = 2 * i - (i & (i - 1)))\n        F[i] += val;\n}\n\nint get(int F[nmax], int i) {\n    int ans = 0;\n    for (; i > 0; i = i & (i - 1))\n        ans += F[i];\n    return ans;\n}\n\nint main()\n{\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    REP(i, n) {\n        scanf(\"%d\", &a[i]);\n        if (i > 0 && a[i] > a[i - 1])\n            update(F1, i, 1);\n        if (i > 0 && a[i] < a[i - 1])\n            update(F2, i, 1);\n    }\n    REP(step, m) {\n        int L, R;\n        scanf(\"%d %d\", &L, &R);\n        --L;\n        --R;\n        int l = L, r = R + 1;\n        while (l < r -1) {\n            int mid = (l + r) / 2;\n            if (get(F2, mid) - get(F2, L) == 0)\n                l = mid;\n            else\n                r = mid;\n        }\n        if (get(F1, R) - get(F1, l) == 0)\n            printf(\"Yes\\n\");\n        else\n            printf(\"No\\n\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Ladder.json",
    "editorial_link": "https://codeforces.com//blog/entry/95148",
    "editorial": "Let\u00e2\u0080\u0099s calculate two arrays before answering queries. is the smallest\r\nindex such that is nonincreasing, and is the largest index such that is\r\nnondecreasing. Then for each query we can take and and compare them. The\r\nanswer is \"Yes\" iff . In other words, we are checking if the largest\r\nnondecreasing segment from and largest nonincreasing segment from are\r\nintersecting. To calculate , go over from to and maintain largest\r\nnonincreasing suffix. For do the same in reverse. Code\r\n"
}