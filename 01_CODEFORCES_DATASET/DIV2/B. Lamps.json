{
    "link": "https://codeforces.com//contest/1839/problem/B",
    "problemId": "1950159",
    "problem_idx": "B",
    "shortId": "1839B",
    "contest_number": "1839",
    "problem_submissions": {
        "D": [
            208378999,
            208378969,
            208378832,
            208349629,
            208349595,
            208328924,
            208318842,
            208320348,
            208320009,
            208322670,
            208334872,
            252078530,
            208941980,
            208322481,
            208320363,
            208321362,
            208327211,
            208323287,
            208323939,
            208326005,
            208322044,
            238787448,
            208326918,
            208338715,
            208324800,
            208326544,
            208326069,
            208328427
        ],
        "E": [
            208319512,
            208328631,
            208328272,
            208332229,
            208329987,
            208322483,
            208941985,
            208331621,
            208337019,
            208333546,
            208333532,
            208337451,
            208338255,
            208336016,
            208341143,
            238787342,
            208337777,
            208329186,
            208341540,
            208340328,
            208345193,
            208341230
        ],
        "C": [
            208312529,
            208312433,
            208313019,
            208312784,
            208314192,
            208314831,
            208941969,
            208315364,
            208314601,
            208315655,
            208313303,
            208314023,
            208311295,
            208317114,
            208312761,
            208316692,
            208311943,
            208319701,
            208315483,
            208313786,
            208316277
        ],
        "B": [
            208308892,
            208309149,
            208309789,
            208308399,
            208310012,
            208310211,
            208941953,
            208312078,
            208308633,
            208312628,
            208307832,
            208309526,
            208306915,
            208309002,
            208309419,
            208310463,
            208308132,
            208308049,
            208311860,
            208308608,
            208311306
        ],
        "A": [
            208307199,
            208306621,
            208306837,
            208306359,
            208306401,
            208306556,
            208941945,
            208307764,
            208306608,
            208308716,
            208306828,
            208306416,
            208307882,
            208306972,
            208306698,
            208306776,
            208306761,
            208306697,
            208307597,
            208306680,
            208308663
        ]
    },
    "name": "B. Lamps",
    "statement": "You have n lamps, numbered by integers from 1 to n. Each lamp i has two\r\ninteger parameters a_i and b_i.At each moment each lamp is : it may be\r\nturned on, turned off, or broken.Initially all lamps are turned off. In\r\none operation you can select one lamp that is turned off and turn it on\r\n(you can\u2019t turn on broken lamps). You b_i points for turning lamp i on.\r\nThe following happens after each performed operation: Let\u2019s denote the\r\nnumber of lamps that are turned on as x (broken lamps ). All lamps i\r\nsuch that a_i\r\nle x simultaneously break, whether they were turned on or off. Please\r\nnote that broken lamps never count as turned on and that after a turned\r\non lamp breaks, you still keep points received for turning it on.You can\r\nperform an arbitrary number of operations.Find the maximum number of\r\npoints you can get.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define pb push_back\nusing namespace std;\nconst int mxN = 2e5 + 1;\nvector<int> freq[mxN];\nint n;\nvoid init() {\n\t\n}\nvoid reset() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfreq[i].clear();\n\t}\n}\nvoid solve() {\n\tcin >> n;\n\treset();\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tfreq[a].pb(b);\n\t}\n\tqueue<int> q;\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(freq[i].begin(), freq[i].end(), greater<int>());\n\t\tfor (int &x : freq[i]) {\n\t\t\tans += x;\n\t\t\tq.push(i);\n\t\t\tif (q.size() >= q.front()) {\n\t\t\t\tint cur = q.size();\n\t\t\t\twhile (!q.empty() && q.front() <= cur) q.pop();\n\t\t\t\tif (cur == i) break;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint32_t main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tinit();\n\tint t = 1;\n\tcin >> t;\n\twhile (t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Lamps.json",
    "editorial_link": "https://codeforces.com//blog/entry/116963",
    "editorial": "Let\u00e2\u0080\u0099s denote number of lamps with as . If and you turn lamps with lamps\r\non, all of them will break and you will not be able to receive points\r\nfor the other lamps. If we denote values for all such that as (), then\r\nyou can\u00e2\u0080\u0099t get more than points for lamps with .So, the total number of\r\npoints is not bigger than .This bound can always be achieved in the\r\nfollowing way: while there is at least one lamp that is not turned on\r\nand not broken, turn on the one with minimum (if there are multiple\r\nlamps with minimum , choose the one with maximum ).This works because if\r\nat least lamps are turned on, then all lamps with are already broken.\r\n"
}