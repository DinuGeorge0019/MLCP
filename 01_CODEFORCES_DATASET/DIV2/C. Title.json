{
    "link": "https://codeforces.com//contest/59/problem/C",
    "problemId": "309",
    "problem_idx": "C",
    "shortId": "59C",
    "contest_number": "59",
    "problem_submissions": {
        "E": [
            280965,
            279581,
            281138,
            281387,
            280873,
            283124,
            283115,
            283111,
            283109,
            283100,
            283096,
            283092,
            283085,
            283084,
            281969,
            7020454
        ],
        "D": [
            280391,
            284138,
            281502,
            281236,
            281590,
            282219,
            282005,
            282011,
            281002
        ],
        "C": [
            279741,
            280383,
            280157,
            280215,
            279940,
            280089,
            280651,
            282540,
            280526,
            280047,
            280179,
            280617,
            280421
        ],
        "B": [
            279223,
            280161,
            279355,
            279326,
            279379,
            279486,
            283681,
            280066,
            279671,
            279598,
            279324,
            279470,
            279615,
            279517,
            280028
        ],
        "A": [
            278986,
            280065,
            279027,
            279062,
            279003,
            279074,
            283673,
            279299,
            279346,
            279565,
            279059,
            279097,
            279211,
            279043,
            279837
        ]
    },
    "name": "C. Title",
    "statement": "Vasya has recently finished writing a book. Now he faces the problem of\r\ngiving it the title. Vasya wants the title to be vague and mysterious\r\nfor his book to be noticeable among others. That\u2019s why the title should\r\nbe represented by a single word containing at least once each of the\r\nfirst Latin letters and not containing any other ones. Also, the title\r\nshould be a palindrome, that is it should be read similarly from the\r\nleft to the right and from the right to the left.Vasya has already\r\ncomposed the approximate variant of the title. You are given the title\r\ntemplate consisting of lowercase Latin letters and question marks. Your\r\ntask is to replace all the question marks by lowercase Latin letters so\r\nthat the resulting word satisfies the requirements, described above.\r\nEach question mark should be replaced by exactly one letter, it is not\r\nallowed to delete characters or add new ones to the template. If there\r\nare several suitable titles, choose the first in the alphabetical order,\r\nfor Vasya\u2019s book to appear as early as possible in all the catalogues.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\nusing namespace std;\nint k;\nchar arr[256];\nint n;\nbool used[256];\nint main()\n{\n\tcin>>k>>arr;\n\tn = strlen(arr);\n\tfor(int i=0; i<n; ++i) {\n\t\tif (arr[i]!='?') {\n\t\t\tint a = n-1-i;\n\t\t\tif (arr[a]=='?') arr[a]=arr[i];\n\t\t\tif (arr[a]!=arr[i]) {\n\t\t\t\tcout<<\"IMPOSSIBLE\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; ++i) used[(int)arr[i]] = 1;\n\tint c = 'a' + (k-1);\n\tfor(int i=(n+0)/2; i>=0; --i) {\n\t\twhile(c>='a' && used[c]) --c;\n\t\tif (arr[i]!='?') continue;\n\t\tint a = n-1-i;\n\t\tif (c>='a') {\n\t\t\tarr[a] = arr[i] = c--;\n\t\t} else {\n\t\t\tarr[a] = arr[i] = 'a';\n\t\t}\n\t}\n\twhile(c>='a' && used[c]) --c;\n\tif (c>='a') {\n\t\tcout<<\"IMPOSSIBLE\\n\";\n\t\treturn 0;\n\t}\n\tcout<<arr<<'\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "expression parsing"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Title.json",
    "editorial_link": "https://codeforces.com//blog/entry/1276",
    "editorial": "This was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...\nIf you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.\nOnce you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.\n\nNow simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome."
}