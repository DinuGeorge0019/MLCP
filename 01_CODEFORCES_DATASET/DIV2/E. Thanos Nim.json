{
    "link": "https://codeforces.com//contest/1162/problem/E",
    "problemId": "339908",
    "problem_idx": "E",
    "shortId": "1162E",
    "contest_number": "1162",
    "problem_submissions": {
        "F": [
            53760255
        ],
        "E": [
            53755729,
            53755411,
            53755882,
            53754129,
            53757378,
            53756764,
            53757700,
            53758454,
            53758416,
            53754833,
            53757407,
            53756313,
            53758588,
            53756165,
            53758997,
            53756619,
            53758311,
            53759677
        ],
        "D": [
            53752747,
            53753462,
            53754325,
            53757481,
            53752843,
            53755399,
            53755520,
            53755668,
            53754940,
            53755489,
            53758915,
            53755731,
            53754946,
            53755618,
            53759491,
            53755508,
            53758786,
            53755777,
            53756167
        ],
        "C": [
            53749836,
            53750600,
            53751425,
            53750020,
            53750391,
            53752273,
            53751033,
            53751621,
            53752004,
            53752815,
            53754220,
            53751629,
            53753641,
            53751893,
            53752886,
            53751070,
            53756767,
            53753219
        ],
        "B": [
            53748291,
            53748052,
            53748376,
            53747817,
            53748626,
            53748146,
            53748574,
            53749401,
            53805701,
            53749421,
            53749906,
            53748692,
            53758550,
            53750610,
            53749077,
            53749412,
            53749393,
            53748736,
            53751212
        ],
        "A": [
            53746666,
            53746560,
            53746976,
            53746641,
            53746514,
            53746879,
            53746868,
            53747863,
            53805694,
            53747143,
            53747013,
            53746924,
            53746595,
            53746573,
            53747849,
            53746548,
            53747762,
            53747182,
            53748613
        ]
    },
    "name": "E. Thanos Nim",
    "statement": "Alice and Bob are playing a game with n piles of stones. It is\r\nguaranteed that n is an even number. The i-th pile has a_i stones.Alice\r\nand Bob will play a game alternating turns with Alice going first.On a\r\nplayerâ€™s turn, they must choose\r\nfrac{n}{2} nonempty piles and independently remove a positive number of\r\nstones from each of the chosen piles. They remove a number of stones\r\nfrom the piles in a single turn. The first player unable to make a move\r\nloses (when there are less than\r\nfrac{n}{2} nonempty piles).Given the starting configuration, determine\r\nwho will win the game.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    scanf(\"%d\", &N);\n    int minval = 100;\n    int mincnt = 0;\n    for (int i = 0; i < N; ++i) {\n        int x;\n        scanf(\"%d\", &x);\n        if (x < minval) {\n            minval = x;\n            mincnt = 1;\n        }\n        else if (x == minval) {\n            mincnt += 1;\n        }\n    }\n    if (mincnt > N / 2) {\n        printf(\"Bob\\n\");\n    }\n    else {\n        printf(\"Alice\\n\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Thanos Nim.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "The main claim is that if a player is forced to reduce the minimum number of stones over all piles, then they lose. Intuitively, every time a player reduces the minimum, the other player has a move that doesn't reduce the minimum, and if a player isn't forced to reduce the minimum, they have a move that will force the other player to reduce the minimum.\n\nMore formally, let m\n be the minimum number of stones in a pile, and let x\n be the number of piles with m\n stones. Alice can win if and only if x?n/2\n. Let's call the positions where Alice can win \"winning positions\", and all other positions \"losing positions\"\n\nTo see why this works, we need to show from a winning position, we can reach some losing position, and if we are at a losing position, we can only reach winning positions.\n\nIf we are at a winning position, there are at least n/2\n piles that have strictly more than m\n stones, so we can choose any arbitrary subset of them and reduce them to m\n stones. This is now a losing position.\n\nIf we are at a losing position, no matter what we do, we must include a pile of size m\n in our chosen subset. If m\n is zero, this means we have no available moves. Otherwise, the minimum will strictly decrease, but only at most n/2\n piles (from the piles that we chose) can reach that new minimum. Thus, losing positions can only reach winning positions.\n\nThe solution is then as follows. Find the min of the array and find the frequency of the min. Print \"Alice\" if the frequency is less than or equal to n/2\n, otherwise, print \"Bob\". The time complexity is O(n)\n. Alternatively, you can sort and check the index 0\n and index n/2\n are the same for a short three line solution.",
    "hint": []
}