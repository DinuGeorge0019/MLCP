{"link": "https://codeforces.com//contest/1847/problem/D", "problemId": "1996641", "problem_idx": "D", "shortId": "1847D", "contest_number": "1847", "problem_submissions": {"F": [212433608, 212431110, 212414836, 212437044, 212436646, 212438573, 212439809, 212461142, 212444034, 212441048, 212442560, 212446414, 212448526, 212446363, 212477387, 212473113, 212447258, 212445412, 212440060, 212484613, 212430011, 212447626, 212448642, 212429172], "D": [212389437, 212405663, 212427981, 212401825, 212406614, 212408665, 212391793, 212412178, 212420289, 212416938, 212416798, 212415041, 212411965, 212408607, 212417943, 212402342, 212440813, 212424407, 212414209, 212448028], "C": [212379554, 212388481, 212381978, 212383167, 212391492, 212395637, 212408363, 212918680, 212459952, 212459679, 212387499, 212392748, 212401136, 212392067, 212389261, 212394523, 212454918, 212396638, 212395742, 212387056, 212410808, 212403757, 212388758, 212439567], "B": [212375586, 212386366, 212383195, 212377114, 212379209, 212382779, 212400416, 212381176, 212374781, 212381202, 212383485, 212376778, 212384302, 212388840, 212379283, 212442148, 212382593, 212383125, 212398777, 212403514], "A": [212372531, 212381099, 212372843, 212372985, 212372832, 212383462, 212396957, 212372898, 212372422, 212372468, 212373223, 212373301, 212373237, 212373415, 212375604, 212372629, 212374004, 212375662, 212372722, 212387500], "E": [212780531, 212480822]}, "name": "D. Professor Higashikata", "statement": "Josuke is tired of his peaceful life in Morioh. Following in his nephew\r\nJotaro\u2019s footsteps, he decides to study hard and become a professor of\r\ncomputer science. While looking up competitive programming problems\r\nonline, he comes across the following one: Let s be a binary string of\r\nlength n. An operation on s is defined as choosing two distinct integers\r\ni and j (1\r\nleq i < j\r\nleq n), and swapping the characters s_i, s_j.Consider the m strings t_1,\r\nt_2,\r\nldots, t_m, where t_i is the substring ^\r\ndagger of s from l_i to r_i. Define t(s) = t_1+t_2+\r\nldots+t_m as the concatenation of the strings t_i in that order.There\r\nare q updates to the string. In the i-th update s_{x_i} gets flipped.\r\nThat is if s_{x_i}=1, then s_{x_i} becomes 0 and vice versa. After each\r\nupdate, find the minimum number of to make t(s) lexicographically as\r\nlarge^\r\nddagger as possible. Note that no operation is actually performed. We\r\nare only interested in the number of operations.Help Josuke in his dream\r\nby solving the problem for him.\r\ndagger A string a is a substring of a string b if a can be obtained from\r\nb by the deletion of several (possibly, zero or all) characters from the\r\nbeginning and several (possibly, zero or all) characters from the end.\r\nddagger A string a is lexicographically larger than a string b of the\r\nsame length if and only if the following holds: in the first position\r\nwhere a and b differ, the string a has a 1, and the string b has a 0.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define N 300'005\n\nint n, m, q, l[N], r[N], id[N], tot;\nstring s;\nstruct BIT\n{\n    int s[N];\n    int lowbit(int x) { return x & -x; }\n    void update(int x, int y)\n    {\n        while (x < N)\n        {\n            s[x] += y;\n            x += lowbit(x);\n        }\n    }\n    int query(int x)\n    {\n        int res = 0;\n        while (x)\n        {\n            res += s[x];\n            x -= lowbit(x);\n        }\n        return res;\n    }\n} tr;\nvoid solve()\n{\n    cin >> n >> m >> q >> s;\n    s = ' ' + s;\n    for (int i = 1; i <= m; i++)\n        cin >> l[i] >> r[i];\n    set<int> num;\n    for (int i = 1; i <= n; i++)\n        num.insert(i);\n    for (int i = 1; i <= m; i++)\n    {\n        auto it = num.lower_bound(l[i]);\n        while (it != num.end() && *it <= r[i])\n        {\n            int u = *it;\n            it++;\n            id[u] = ++tot;\n            num.erase(u);\n        }\n    }\n    int cnt1 = 0, limit = tot;\n    for (int i : num)\n        id[i] = ++tot;\n    for (int i = 1; i <= n; i++)\n    {\n        if (s[i] == '1')\n            cnt1++;\n        else\n            tr.update(id[i], 1);\n    }\n    while (q--)\n    {\n        int x;\n        cin >> x;\n        if (s[x] == '1')\n        {\n            cnt1--;\n            tr.update(id[x], 1);\n            int sum = min(limit, cnt1);\n            cout << tr.query(sum) << '\\n';\n            s[x] = '0';\n        }\n        else\n        {\n            cnt1++;\n            tr.update(id[x], -1);\n            int sum = min(limit, cnt1);\n            cout << tr.query(sum) << '\\n';\n            s[x] = '1';\n        }\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    // cin >> t;\n    while (t--)\n        solve();\n}"], "input": "", "output": "", "tags": ["data structures", "dsu", "greedy", "implementation", "strings"], "dificulty": "1900", "interactive": false}