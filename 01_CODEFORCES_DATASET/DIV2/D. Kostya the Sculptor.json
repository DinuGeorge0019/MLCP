{
    "link": "https://codeforces.com//contest/733/problem/D",
    "problemId": "78300",
    "problem_idx": "D",
    "shortId": "733D",
    "contest_number": "733",
    "problem_submissions": {
        "F": [
            21944181,
            21943396,
            21967823,
            21944382,
            21944760,
            21938912,
            21991227,
            22059840,
            21937562,
            21938035,
            21985645,
            21991821,
            21953425,
            22015051,
            21990688
        ],
        "E": [
            21937191,
            21938008,
            21943531,
            21943185,
            21953321,
            21943118,
            21945071,
            21961545
        ],
        "D": [
            21929126,
            21923181,
            21934246,
            21934699,
            21930359,
            21930083,
            21921931,
            21937281,
            21933013,
            21933051,
            21930915,
            21933717,
            21930137,
            21931610,
            21929842,
            21935332,
            21929335,
            21936423,
            21930780,
            21933993
        ],
        "C": [
            21927957,
            21950571,
            21931020,
            21929401,
            21936037,
            21935885,
            21953665,
            21934528,
            21938848,
            21929683,
            21937215,
            21940711,
            21934393,
            21928582,
            21934351,
            21931346,
            21936860,
            21931930
        ],
        "B": [
            21922288,
            21927937,
            21923164,
            21922462,
            21923910,
            21924025,
            21925504,
            21933294,
            21928279,
            21922570,
            21924161,
            21922272,
            21921961,
            21923577,
            21924912,
            21921350,
            21922700,
            21923311,
            21923198,
            21925029
        ],
        "A": [
            21919764,
            21920167,
            21920208,
            21919696,
            21920676,
            21920418,
            21919388,
            21932202,
            21929074,
            21920399,
            21925006,
            21920161,
            21919497,
            21919471,
            21922256,
            21919494,
            21926774,
            21920063,
            21919707,
            21927283
        ]
    },
    "name": "D. Kostya the Sculptor",
    "statement": "Kostya is a genial sculptor, he has an idea: to carve a marble sculpture\r\nin the shape of a sphere. Kostya has a friend Zahar who works at a\r\ncareer. Zahar knows about Kostya’s idea and wants to present him a\r\nrectangular parallelepiped of marble from which he can carve the sphere.\r\nZahar has stones which are rectangular parallelepipeds. The edges sizes\r\nof the -th of them are , and . He can take and present them to Kostya.\r\nIf Zahar takes two stones, he should glue them together on one of the\r\nfaces in order to get a new piece of rectangular parallelepiped of\r\nmarble. Thus, it is possible to glue a pair of stones together if and\r\nonly if two faces on which they are glued together match as rectangles.\r\nIn such gluing it is allowed to rotate and flip the stones in any way.\r\nHelp Zahar choose such a present so that Kostya can carve a sphere of\r\nthe maximum possible volume and present it to Zahar.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define f first\n#define s second\n\nusing namespace std;\n\npair<pair<int, int>, pair<int, int> > arr[600005];\npair<int, int> tmp[2];\n\nvoid update(pair<int, int> x)\n{\n  if(x.f > tmp[0].f)\n  {\n    if(x.s != tmp[0].s) tmp[1] = tmp[0];\n    tmp[0] = x;\n  }\n  else if(x.s != tmp[0].s && x.f > tmp[1].f)\n    tmp[1] = x;\n}\n\nvoid clr()\n{\n  tmp[0] = tmp[1] = mp(-1, -1);\n}\n\nint main()\n{\n  int n, x, y, z;\n  cin >> n;\n  int ans = 0;\n  pair<int, int> ch = mp(-1, -1);\n  for(int i=0;i<n;i++)\n  {\n    scanf(\"%d %d %d\", &x, &y, &z);\n    arr[i*6] = mp(mp(x, y), mp(z, i));\n    arr[i*6+1] = mp(mp(y, x), mp(z, i));\n    arr[i*6+2] = mp(mp(x, z), mp(y, i));\n    arr[i*6+3] = mp(mp(z, x), mp(y, i));\n    arr[i*6+4] = mp(mp(z, y), mp(x, i));\n    arr[i*6+5] = mp(mp(y, z), mp(x, i));\n    if(min(x, min(y, z)) > ans)\n    {\n      ans = min(x, min(y, z));\n      ch.f = i + 1;\n    }\n  }\n  n *= 6;\n  sort(arr, arr + n);\n  clr();\n  update(arr[0].s);\n  for(int i=1;i<n;i++)\n  {\n    if(arr[i].f != arr[i - 1].f)\n    {\n      if(tmp[1].s != -1)\n      {\n        if(min(min(arr[i-1].f.f, arr[i-1].f.s), tmp[0].f + tmp[1].f) > ans)\n        {\n          ans = min(min(arr[i-1].f.f, arr[i-1].f.s), tmp[0].f + tmp[1].f);\n          ch = mp(tmp[0].s+1, tmp[1].s+1);\n        }\n      }\n      clr();\n    }\n    update(arr[i].s);\n  }\n  if(tmp[1].s != -1)\n  {\n    if(min(min(arr[n-1].f.f, arr[n-1].f.s), tmp[0].f + tmp[1].f) > ans)\n    {\n      ans = min(min(arr[n-1].f.f, arr[n-1].f.s), tmp[0].f + tmp[1].f);\n      ch = mp(tmp[0].s+1, tmp[1].s+1);\n    }\n  }\n  if(ch.s == -1)\n    cout << \"1\\n\" << ch.f;\n  else cout << \"2\\n\" << ch.f << \" \" << ch.s;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Kostya the Sculptor.json",
    "editorial_link": "https://codeforces.com//blog/entry/48133",
    "editorial": "Radius of inscribed sphere = .Letâs create list of pairwise distinct\r\nedges where two edges is condered different when either minimal sides of\r\nedges differ or maximal ones. For every edge letâs find two maximal\r\nlengths of adjacent side and . These are two parallelepipeds of maximal\r\nvolume with one of edges being equal to . If you glue them together then\r\nyou will get parallelepiped with sides . Also donât forget cases where\r\nthere is only one maximal side for edge.There are no more than edges. So\r\niterating over every parallelepiped with structure to store maximums\r\nworks in where .\r\n",
    "hint": []
}