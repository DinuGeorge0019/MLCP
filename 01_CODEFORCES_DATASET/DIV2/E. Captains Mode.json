{
    "link": "https://codeforces.com//contest/378/problem/E",
    "problemId": "4960",
    "problem_idx": "E",
    "shortId": "378E",
    "contest_number": "378",
    "problem_submissions": {
        "E": [
            5563219,
            5595791,
            8179323,
            5559860,
            20070615,
            5562227
        ],
        "D": [
            5556813,
            5557228,
            5557861,
            5557995,
            5559128,
            5559510,
            5560131,
            5559854,
            5564039,
            5558835,
            5562214,
            5559720,
            5555845,
            5561731,
            5562171,
            5561606,
            5562261,
            5561403,
            8216379
        ],
        "C": [
            5554238,
            5554337,
            5554949,
            5554592,
            5554549,
            5556387,
            5557557,
            5554236,
            5556931,
            5559205,
            5555878,
            5557269,
            5561573,
            5555439,
            5557184,
            5557477,
            5558631,
            5558088,
            5558866
        ],
        "B": [
            5553450,
            5553574,
            5553632,
            5553677,
            5555408,
            5554569,
            5553596,
            5556019,
            5554338,
            5553306,
            5553948,
            5560235,
            5560773,
            5557562,
            5554753,
            5556550,
            5557175,
            5558723,
            5557766
        ],
        "A": [
            5551839,
            5552020,
            5551945,
            5551789,
            5552122,
            5552095,
            5551986,
            5551831,
            5552492,
            5551800,
            5551769,
            5551863,
            5552473,
            5552326,
            5555120,
            5553391,
            5552249,
            5552366
        ]
    },
    "name": "E. Captains Mode",
    "statement": "Kostya is a progamer specializing in the discipline of Dota 2. Valve\r\nCorporation, the developer of this game, has recently released a new\r\npatch which turned the balance of the game upside down. Kostya, as the\r\ncaptain of the team, realizes that the greatest responsibility lies on\r\nhim, so he wants to resort to the analysis of innovations patch from the\r\nmathematical point of view to choose the best heroes for his team in\r\nevery game.A Dota 2 match involves two teams, each of them must choose\r\nsome heroes that the players of the team are going to play for, and it\r\nis forbidden to choose the same hero several times, even in different\r\nteams. In large electronic sports competitions where Kostya’s team is\r\ngoing to participate, the matches are held in the Captains Mode. In this\r\nmode the captains select the heroes by making one of two possible\r\nactions in a certain, predetermined order: pick or ban. To pick a hero\r\nfor the team. After the captain picks, the picked hero goes to his team\r\n(later one of a team members will play it) and can no longer be selected\r\nby any of the teams. To ban a hero. After the ban the hero is not sent\r\nto any of the teams, but it still can no longer be selected by any of\r\nthe teams. The team captain may miss a pick or a ban. If he misses a\r\npick, a random hero is added to his team from those that were available\r\nat that moment, and if he misses a ban, no hero is banned, as if there\r\nwas no ban.Kostya has already identified the strength of all the heroes\r\nbased on the new patch fixes. Of course, Kostya knows the order of picks\r\nand bans. The strength of a team is the sum of the strengths of the\r\nteam’s heroes and both teams that participate in the match seek to\r\nmaximize the difference in strengths in their favor. Help Kostya\r\ndetermine what team, the first one or the second one, has advantage in\r\nthe match, and how large the advantage is.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nint s[300];\nint type[50];\nint team[50];\nint p, picks[50];\nint dp[1<<20];\n\nint gogo(int instruction, int prev, int state) {\n  if (instruction == m) {\n    return 0;\n  } else {\n    int ret = 0;\n    if (type[instruction] == 1) {\n      while (state&(1<<prev)) ++prev;\n      if (team[instruction] == 0) ret = s[prev] + gogo(instruction + 1, prev + 1, state);\n      else ret = -s[prev] + gogo(instruction + 1, prev + 1, state);\n    } else {\n      if (dp[state] != -1000000001) return dp[state];\n      int best = -1000000000;\n      int worst = 1000000000;\n\n      for (int i = m - 1; i >= prev; --i) {\n        if ((state&(1<<i)) == 0) {\n          int cost = gogo(instruction + 1, prev, state|(1<<i));\n          best = max(best, cost);\n          worst = min(worst, cost);\n        }\n      }\n      if (team[instruction] == 0) ret = best;\n      else ret = worst;\n      dp[state] = ret;\n    }\n    return ret;\n  }\n}\n\nint main() {\n  scanf (\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", s + i);\n  sort(s, s + n);\n  for (int i = 0; i < n/2; ++i) swap(s[i], s[n - i - 1]);\n  scanf (\"%d\", &m);\n\n  p = 0;\n  for (int i = 0; i < m; ++i) {\n    char c;\n    int t;\n    scanf (\" %c %d \", &c, &t);\n    team[i] = t - 1;\n    type[i] = c == 'p';\n  }\n  for (int i = 0; i < (1<<m); ++i) dp[i] = -1000000001;\n  printf (\"%d\\n\", gogo(0, 0, 0));\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Captains Mode.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "There are some observations that do the problem very simple. The first one is that we always should pick the strongest hero. But we cannot say something similar about the bans  in different situations different bans are the best. But the most important observation is that we should consider only m strongest heroes. Indeed, in every game where only strongest heroes are picked, no hero except m strongest can be picked. That's why we don't need to ban them and therefore we don't need to consider them.\n\nSo now we have only 20 heroes. It means we can solve the problem using the dynamic programming with bitmasks: dpmask will be the difference between the teams' strengths when only those heroes are picked or banned whose bits are set to 1 in the mask. At every state we try to pick or ban every available hero and go to the other state. The simpliest way to implement it is the recursion with memoization. The answer will be stored in dp2m?-?1.\n\nUnfortunately, we couldn't estimate the real complexity of this problem (despite it has the simple solution, this solution is not so easy to think of  standard 1500 points for problem C would be better) and set too big TL (many solutions written in C++ whose complexity is m2·2m passed  we should have been set TL to 1 second or even to 0.75 seconds). So if you solved it in m2·2m, you may assume that you're just lucky and your correct verdict is Time Limit Exceeded.\n\nWhy it can be solved in m·2m? There is no point of missing a ban  if we ban the weakest hero, nothing will change since the weakest hero won't be picked.\n\nAlso this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test.",
    "hint": []
}