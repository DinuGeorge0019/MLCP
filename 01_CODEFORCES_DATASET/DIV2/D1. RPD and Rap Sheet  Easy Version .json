{
    "link": "https://codeforces.com//contest/1543/problem/D1",
    "problemId": "1038888",
    "problem_idx": "D1",
    "shortId": "1543D1",
    "contest_number": "1543",
    "problem_submissions": {
        "E": [
            121638293,
            121640122,
            121646039,
            121646816,
            121811012,
            121760431,
            121760422,
            121760385,
            121760374,
            121760355,
            121760336,
            121760282,
            121760064,
            121760038,
            121759905,
            121653632,
            121644982,
            121669265,
            121699461,
            121677102,
            121676768,
            121663043,
            121682193,
            121682008,
            121681968,
            121681825
        ],
        "C": [
            121607103,
            121580363,
            121606682,
            121627500,
            121653560,
            121590146,
            121589009,
            121582693,
            121614005,
            121615009,
            121616095,
            121613756,
            121596961,
            121599154,
            121597926,
            121608185,
            121597933,
            121606103,
            121606203
        ],
        "D2": [
            121596158,
            121601464,
            121617704,
            121620392,
            121626490,
            121619638,
            121618444,
            121618704,
            121605621,
            121605043,
            121602716,
            121616842,
            121615764,
            121615962,
            121615812,
            121620480,
            121619304,
            121615169,
            121624602
        ],
        "D1": [
            121576532,
            121593477,
            121613266,
            121597889,
            121614339,
            121601755,
            121604364,
            121608739,
            121598195,
            121595487,
            121589696,
            121586209,
            121618059,
            121609771,
            121609361,
            121593980,
            121614987,
            121614945,
            121599352
        ],
        "B": [
            121572816,
            121573125,
            121599866,
            121581407,
            121575511,
            121573418,
            121573029,
            121584593,
            121575414,
            121574254,
            121573423,
            121577407,
            121575483,
            121573867,
            121576997,
            121576837,
            121577599,
            121574767,
            121583481
        ],
        "A": [
            121572516,
            121572434,
            121598213,
            121578311,
            121573469,
            121572491,
            121577467,
            121587968,
            121572718,
            121572541,
            121572464,
            121574176,
            121573349,
            121572610,
            121574728,
            121572920,
            121574400,
            121572846,
            121578119
        ]
    },
    "name": "D1. RPD and Rap Sheet  Easy Version ",
    "statement": "Every decimal number has a base k equivalent. The individual digits of a\r\nbase k number are called k-its. Let’s define the k-itwise XOR of two\r\nk-its a and b as (a + b)\r\nbmod k.The k-itwise XOR of two base k numbers is equal to the new number\r\nformed by taking the k-itwise XOR of their corresponding k-its. The\r\nk-itwise XOR of two decimal numbers a and b is denoted by a\r\noplus_{k} b and is equal to the decimal representation of the k-itwise\r\nXOR of the base k representations of a and b. All further numbers used\r\nin the statement below are in decimal unless specified. When k = 2 (it\r\nis always true in this version), the k-itwise XOR is the same as the\r\nbitwise XOR.You have hacked the criminal database of Rockport Police\r\nDepartment (RPD), also known as the Rap Sheet. But in order to access\r\nit, you require a password. You don’t know it, but you are quite sure\r\nthat it lies between 0 and n-1 inclusive. So, you have decided to guess\r\nit. Luckily, you can try at most n times without being blocked by the\r\nsystem. But the system is adaptive. Each time you make an incorrect\r\nguess, it changes the password. Specifically, if the password before the\r\nguess was x, and you guess a different number y, then the system changes\r\nthe password to a number z such that x\r\noplus_{k} z=y. Guess the password and break into the system.\r\n",
    "solutions": [
        "// Problem: D1. RPD and Rap Sheet (Easy Version)\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/D1\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),k=read();\n\t\tint s=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t{\n\t\t\tprintf(\"%lld\\n\",i^s);\n\t\t\tfflush(stdout);\n\t\t\ts=i;\n\t\t\tif(read()==1) break;\n\t\t\t//如果i是0，会变成ixor s\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "interactive",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. RPD and Rap Sheet  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/92582",
    "editorial": "In this version of the problem, . So, the -itwise XOR is the\nsame as Bitwise XOR.In case of incorrect guess, the system changes\npassword to such that . Taking XOR with on both sides, because we know\nthat .Since the original password is less than and we have queries, we\nneed to find a way to make queries such that if the original password\nwas , then the -th query will be equal to the current password. There\nare many different approaches. I will describe two of them. Method 1Let\ndenote the -th query. Then, . for . Letâs see why this works.Claim If\nthe original password was , after queries, the current password will be\n. ProofLetâs prove this by induction.Base Condition After -st query, the\npassword becomes .Induction Hypothesis Let the password after -th query\nbe .Inductive step The -th query will be . If this is not equal to the\ncurrent password, the password will change to .Hence, proved by\ninduction.Now notice that after queries, the password will become . And\nour -th query will be which is the same as the current password. So, the\nproblem will be solved after queries. Since , the problem will be solved\nin at most queries. Method 2 (Idea by KAN)Again, let denote the -th\nquery. Then,Letâs see why this works.Claim If the original password was\n, after queries, the current password will be . ProofLetâs prove this by\ninduction.Base Condition The first query is . After -st query, the\npassword becomes .Induction Hypothesis Let the password after -th query\nbe .Inductive step The -th query will be . So, the password after -th\nquery will be .Hence, proved by induction. Now notice that after\nqueries, the password will become . And our -th query will be which is\nthe same as the current password. So, the problem will be solved after\nqueries. Since , the problem will be solved in at most queries.But we\nare not done yet. We canât afford to calculate the value of each query\nnaively in because this will time out. To handle this, we need to\nmaintain a prefix XOR whose value will be after queries. For the -th\nquery, find and update . Time Complexity or depending upon the\nimplementation.\n",
    "hint": []
}