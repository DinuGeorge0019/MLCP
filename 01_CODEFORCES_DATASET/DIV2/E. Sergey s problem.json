{
    "link": "https://codeforces.com//contest/1020/problem/E",
    "problemId": "207012",
    "problem_idx": "E",
    "shortId": "1020E",
    "contest_number": "1020",
    "problem_submissions": {
        "D": [
            41489189,
            41489089,
            41486423,
            41490197,
            41489917,
            41487075,
            41490349,
            41489723,
            41491006,
            41484021,
            41492712,
            41493543,
            41493068,
            41492267,
            41492744,
            41493565,
            41533654,
            41492210,
            41493418,
            41496467
        ],
        "C": [
            41482847,
            41481559,
            41490429,
            41483828,
            41484432,
            41483284,
            41481342,
            41482980,
            41482276,
            41494412,
            41483383,
            41483904,
            41482436,
            41484813,
            41483954,
            41484715,
            41485204,
            41486868,
            41484572
        ],
        "B": [
            41472124,
            41472495,
            41472169,
            41471832,
            41473647,
            41472819,
            41474467,
            41474217,
            41476517,
            41474465,
            41477984,
            41542441,
            41472876,
            41475507,
            41474290,
            41474434,
            41473754,
            41480874,
            41476912,
            41474412
        ],
        "A": [
            41471287,
            41471470,
            41471174,
            41471276,
            41471647,
            41482521,
            41482998,
            41483546,
            41473507,
            41472376,
            41472014,
            41542424,
            41471633,
            41471835,
            41472031,
            41471489,
            41471801,
            41474026,
            41472191,
            41471736
        ],
        "E": [
            41565578
        ]
    },
    "name": "E. Sergey s problem",
    "statement": "Sergey just turned five years old! When he was one year old, his parents\r\ngave him a number; when he was two years old, his parents gave him an\r\narray of integers. On his third birthday he received a string. When he\r\nwas four, his mother woke him up in a quiet voice, wished him to be a\r\ngood boy and gave him a rooted tree. Today he celebrates his birthday\r\nagain! He found a directed graph without loops as a present from his\r\nparents.Since Sergey is a very curious boy, he immediately came up with\r\na thing to do. He decided to find a set Q of vertices in this graph,\r\nsuch that no two vertices x, y\r\nin Q are connected by an edge, and it is possible to reach any vertex z\r\nnotin Q from some vertex of Q in no more than two moves. After a little\r\nthought, Sergey was able to solve this task. Can you solve it too?A\r\nvertex y is reachable from a vertex x in at most two moves if either\r\nthere is a directed edge (x,y), or there exist two directed edges (x,z)\r\nand (z, y) for some vertex z.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define y0    lol\n#define y1    lool\n#define yn    loool\n#define prev  looool\n#define next  loooool\n#define read  looooool\n#define fi first\n#define se second\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define rep(i,a,b) for(int i = (a); i <= (b); i++)\n#define rrep(i,a,b) for(int i = (b); i >= (a); i--)\n#ifdef LOCAL\n#define rall(x,a) for(x : a)\n#else\n#define rall(x,a) for(auto x : a)\n#endif\n#define rng(a) a.begin(), a.end()\n#define PI 3.14159265358979323846\n#define MOD 1000000007\n#define endl \"\\n\"\ntypedef long long ll;\nusing namespace std;\n\nconst int N = 1111111;\nvector<int> graph[N];\nbool rem[N], is[N], re[N];\nint n, m;\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, 1, m) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].pb(v);\n    }\n    vector<int> add;\n    rep(i, 1, n) {\n        if(!rem[i]) {\n            add.pb(i);\n            rem[i] = true;\n            rall(j, graph[i]) {\n                rem[j] = true;\n            }\n        }\n    }\n    reverse(rng(add));\n    vector<int> ans;\n    rall(u, add) {\n        if(!re[u]) {\n            is[u] = true;\n            re[u] = true;\n            ans.pb(u);\n            rall(v, graph[u]) {\n                re[v] = true;\n            }\n        }\n    }\n    cout << sz(ans) << endl;\n    rall(x, ans) {\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sergey s problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/61161",
    "editorial": "Let's build the solution by induction. Suppose we have to solve the problem for n\n vertices and we can solve this problem for all k\n (k<n\n). Take an arbitrary vertex A\n. Remove A\n from the graph, as well as all vertices that A\n has an outgoing edge to. Resulting graph has less than n\n vertices, so by induction, we can build the solution for it. Let's call the answer set for the new graph M\n. After this we have two cases: either there is an edge from set M\n to vertex A\n or there is not. If there is an edge from M\n to A\n, then M\n is a correct answer for initial graph, because every removed vertex can be reached from M\n in at most two steps. Otherwise, we can add A\n to M\n and, again, this set will satisfy the required condition. This also proves the answer always exists.\n\nHow to implement it? Let's iterate over all vertices in order from 1\n to n\n and remember whether each vertex is currently present in the graph or not. Whenever we encounter a currently present vertex u\n, we save u\n and mark u\n and all vertices reachable from u\n in one step as removed. After that, we go over all saved vertices in reverse order and add them to answer set if it's not reachable from the answer set in one step.",
    "hint": []
}