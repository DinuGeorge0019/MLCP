{
    "link": "https://codeforces.com//contest/1417/problem/C",
    "problemId": "740373",
    "problem_idx": "C",
    "shortId": "1417C",
    "contest_number": "1417",
    "problem_submissions": {
        "D": [
            94021013,
            93997987,
            93994414,
            94008928,
            93994813,
            93993974,
            93997393,
            93994886,
            93995533,
            94000707,
            94022056,
            93991179,
            93997856,
            94000293,
            94004446,
            94003381,
            93990919,
            93999146,
            94004809,
            93994289,
            93993273
        ],
        "C": [
            94008586,
            93979621,
            93985626,
            93982539,
            93981622,
            93998363,
            93982359,
            93986555,
            93983202,
            93992239,
            93983337,
            93991411,
            93986598,
            93990140,
            93991651,
            94001522,
            93986870,
            93985359,
            93998445,
            93985761
        ],
        "B": [
            94003048,
            93973490,
            93978330,
            93975968,
            93973585,
            93982217,
            93975658,
            93979313,
            93975689,
            93981775,
            93977350,
            93981714,
            93975469,
            93979278,
            93978354,
            96285430,
            93978356,
            93980291,
            93977440,
            94041345,
            93979236,
            93977870
        ],
        "A": [
            94001724,
            93970294,
            93970800,
            93971885,
            93969936,
            93980954,
            93971325,
            93970349,
            93971917,
            93971289,
            93969984,
            93970972,
            93971064,
            93971068,
            93971066,
            96285403,
            93971270,
            93973889,
            93971400,
            94041333,
            93974793,
            93971921
        ],
        "E": [
            94000180,
            93995718,
            94008025,
            93998585,
            94011058,
            94003165,
            94008902,
            94012205,
            94012202,
            94009571,
            94022535,
            94014181,
            94009089,
            94015399,
            94011955,
            94009323,
            94016150,
            94015958,
            94013413,
            94011012,
            94019762
        ],
        "F": [
            93992993,
            94142204,
            94142122
        ]
    },
    "name": "C. k-Amazing Numbers",
    "statement": "You are given an array a consisting of n integers numbered from 1 to\r\nn.Let\u2019s define the k-amazing number of the array as the minimum number\r\nthat occurs in all of the subsegments of the array having length k\r\n(recall that a subsegment of a of length k is a contiguous part of a\r\ncontaining exactly k elements). If there is no integer occuring in all\r\nsubsegments of length k for some value of k, then the k-amazing number\r\nis -1.For each k from 1 to n calculate the k-amazing number of the array\r\na.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nvoid solve(){\n\tint n; cin >> n;\n\tvector<vector<int> > a(n);\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x; x--;\n\t\ta[x].push_back(i);\n\t}\n\tvector<int> ans(n + 1, -1);\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i].empty())continue;\n\t\tint dist = max(a[i][0] + 1, n - a[i].back());\n\t\tfor(int j = 1; j < a[i].size(); j++){\n\t\t\tdist = max(dist, a[i][j] - a[i][j - 1]);\n\t\t}\n\t\tif(ans[dist] == -1)ans[dist] = i;\n\t}\n\tfor(int i = 2; i <= n; i++){\n\t\tif(ans[i - 1] != -1){\n\t\t\tif(ans[i] == -1)ans[i] = ans[i - 1];\n\t\t\telse ans[i] = min(ans[i], ans[i - 1]);\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tif(ans[i] == -1)cout << -1 << \" \";\n\t\telse cout << ans[i] + 1 << \" \";\n\t}\n\tcout << '\\n';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout<<setprecision(32);\n\n\tint t; cin >> t;\n\twhile(t--)solve();\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. k-Amazing Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/83036",
    "editorial": "Let's fix some arbitrary number x\n and calculate the minimum value of k\n such that x\n occurs in all segments of length k\n. Let p1<p2<?<pm\n be the indices of entries of x\n in the array. Then, for each 1?i<m\n it is clear that k\n should be at least the value of pi+1?pi\n. Also, k?p1\n and k?n?pm+1\n. It is enough to just take the maximum of those values. Let's call this derived value of k\n as f(x)\n.\n\nNow, we can just go in increasing order of x\n from 1\n to n\n and try update the suffix [f(x),n]\n with x\n. This can be done straightforwardly, just iterating over the range [f(x),n]\n. If we arrive at a cell for which the value of x\n is already calculated, we immediately terminate our loop and continue our algorithm from x+1\n.\n\nTime complexity: O(n)\n.\n\nSpace complexity: O(n)\n."
}