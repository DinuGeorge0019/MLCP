{
    "link": "https://codeforces.com//contest/1114/problem/E",
    "problemId": "295527",
    "problem_idx": "E",
    "shortId": "1114E",
    "contest_number": "1114",
    "problem_submissions": {
        "E": [
            49723158,
            49715728,
            49717586,
            49715673,
            49722801,
            49716158,
            49718191,
            49719573,
            49752574,
            49752490,
            49731134,
            49732179,
            49723266,
            49731088,
            49731791,
            49709398,
            49709699,
            49747930,
            49752856,
            49752305,
            49752243,
            49751661,
            49717020,
            49711667,
            49716380
        ],
        "D": [
            49715413,
            49709860,
            49711770,
            49711237,
            49709601,
            49710358,
            49712973,
            49713792,
            49713441,
            49727466,
            49728830,
            49707199,
            49710354,
            49729290,
            49706402,
            49726434,
            49712605,
            49711462,
            49713489,
            49710031
        ],
        "F": [
            49712180,
            49727873,
            49729579,
            49729533,
            49726481,
            49727101,
            49727851,
            49731205,
            49722332,
            49708876,
            49721497,
            49732987,
            49730916,
            49722816,
            49711859,
            49722110,
            49737560,
            49795547
        ],
        "B": [
            49703429,
            49701684,
            49702412,
            49706794,
            49704297,
            49702841,
            49708341,
            49704456,
            49705411,
            49718896,
            49701034,
            49703871,
            49704671,
            49716920,
            49700530,
            49704223,
            49704334,
            49707941,
            49702883,
            49701403
        ],
        "C": [
            49701343,
            49703467,
            49706082,
            49704226,
            49698909,
            49708135,
            49709609,
            49709215,
            49708563,
            49712949,
            49704721,
            49705449,
            49707404,
            49724763,
            49703776,
            49705794,
            49710442,
            49704405,
            49704935,
            49704203
        ],
        "A": [
            49696863,
            49696786,
            49698271,
            49697340,
            49701634,
            49697080,
            49706366,
            49697215,
            49702348,
            49720550,
            49696844,
            49696791,
            49698691,
            49696775,
            49697211,
            49696953,
            49699702,
            49696860,
            49697429,
            49697130
        ]
    },
    "name": "E. Arithmetic Progression",
    "statement": "An arithmetic progression or arithmetic sequence is a sequence of\r\nintegers such that the subtraction of element with its previous element\r\n(x_i - x_{i - 1}, where i\r\nge 2) is constant such difference is called a of the sequence.That is,\r\nan arithmetic progression is a sequence of form x_i = x_1 + (i - 1) d,\r\nwhere d is a common difference of the sequence.There is a secret list of\r\nn integers a_1, a_2,\r\nldots, a_n.It is guaranteed that all elements a_1, a_2,\r\nldots, a_n are between 0 and 10^9, inclusive.This list is special: if\r\nsorted in increasing order, it will form an arithmetic progression with\r\npositive common difference (d > 0). For example, the list [14, 24, 9,\r\n19] satisfies this requirement, after sorting it makes a list [9, 14,\r\n19, 24], which can be produced as x_n = 9 + 5\r\ncdot (n - 1).Also you are also given a device, which has a quite\r\ndischarged battery, thus you can only use it to perform at most 60\r\nqueries of following two types: Given a value i (1\r\nle i\r\nle n), the device will show the value of the a_i. Given a value x (0\r\nle x\r\nle 10^9), the device will return 1 if an element with a value strictly\r\ngreater than x exists, and it will return 0 otherwise.Your can use this\r\nspecial device for at most 60 queries. Could you please find out the\r\nsmallest element and the common difference of the sequence? That is,\r\nvalues x_1 and d in the definition of the arithmetic progression. Note\r\nthat the array a is not sorted.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 5050;\nconst int MOD = 1000000007;\n\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  int l = 0, r = 1000000000;\n  while(r - l > 1) {\n    int md = (l + r) / 2;\n\n    cout << '>' << ' ' << md << endl;\n    int res;\n    cin >> res;\n    if (res == 0) r = md;\n    else l = md;\n  }\n\n  int mx = l + 1;\n  vector<int> values;\n  for (int i = 0; i < n; ++i) {\n    values.push_back(i);\n  }\n  for (int i = 1; i < n; ++i) {\n    swap(values[i], values[rnd() % i]);\n  }\n\n  vector<int> nums;\n  nums.push_back(mx);\n  for (int i = 0; i < min<int>(values.size(), 30u); ++i) {\n    cout << '?' << ' ' << values[i] + 1 << endl;\n    int x;\n    cin >> x;\n    nums.push_back(x);\n  }\n\n  int d = 0;\n  for (int x : nums) for (int y : nums) if (x != y) {\n    d = __gcd(d, abs(x - y));\n  }\n  cout << '!' << ' ' << mx - (n - 1) * d << ' ' << d << endl;\n  return 0;\n}\n\n/*\n * an = a1 + (n-1)x\n * ai = a1 + (i-1)x\n * aj = a1 + (j-1)x\n * (n-i)x=c1\n * (n-j)x=c2\n *\n */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive",
        "number theory",
        "probabilities"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Arithmetic Progression.json",
    "editorial_link": "https://codeforces.com/blog/entry/65136",
    "editorial": "TutorialThe > query type allows you to find the max value of the array\r\nthrough binary searching, which will cost queries.The remaining queries\r\nwill be spent for the queries of the ? type to get some random elements\r\nof the array. will be calculated as greatest common divisors of all\r\ndifference between all consecutive elements, provided all elements found\r\n(yes, including the max one) is kept into a list sorted by increasing\r\norder.Having d and max, we can easily find the min value: .The number of\r\nallowed queries seem small ( queries to be exact), yet itâs enough for\r\nus to have reasonable probability of passing the problem.By some maths,\r\nwe can find out the probability of our solution to fail being relatively\r\nsmall approximately . Proof on the probability, written by\r\nxuanquang1999For simplicity, assumed that the sequence is . Suppose that\r\nwe randomly (and uniformly) select a subsequence containing elements\r\nfrom sequence (when is the number of ? query asked). Denote . Let the\r\nGCD of all difference between consecutive elements in . In other word, .\r\nOur solution will success if and will fail otherwise. Let the\r\nprobability that our solution will pass (). Then the failing probability\r\nis .We will apply M bius inversion to calculate : Let the probability\r\nthat is divisible by . Then, (where is the M bius function).Now we need\r\nto calculate . It can be shown that is divisible by if and only if for\r\nall . In other word, there is some from to such that for all .Let the\r\nnumber of ways to select a subsequence such that for all . Then,\r\naccording to definition: The denominator is simply . To calculate ,\r\nnotice that for each , the value of can be for some integer . In other\r\nword, must be a subsequence of the sequence . Let . If , has elements.\r\nTherefore, If , has elements. Therefore, . In summary:The complexity of\r\nthis calculating method is . My implementation of the above method can\r\nbe found here.Keep in mind to use a good random number generator and a\r\nseed which is hard to obtain, thus making your solution truly random and\r\nnot falling into corner cases.Some of the tutorials of neal might be\r\nhelpful:Donât use rand(): a guide to random number generators in C++How\r\nrandomized solutions can be hacked, and how to make your solution\r\nunhackable\r\n",
    "hint": []
}