{"link": "https://codeforces.com//contest/1459/problem/F", "problemId": "837953", "problem_idx": "F", "shortId": "1459F", "contest_number": "1459", "problem_submissions": {"C": [101746653, 101722886, 101730123, 101721760, 101730712, 101728008, 101731166, 101730952, 101740001, 101726009, 101726762, 101728277, 101727158, 101729187, 101723361, 101723810, 101728376, 101726644, 101732897, 101727240], "E": [101738323, 101839753, 102232354, 101778763], "D": [101727682, 101736410, 101735995, 101740518, 101738063, 101735219, 101739686, 101738152, 101733975, 101740963, 101743516, 101745649, 101741362, 101744865, 101740597, 101748885, 101751093, 101741581, 101747404, 101748856], "B": [101727154, 101727768, 101730156, 101728078, 101737211, 101728162, 101729594, 101812219, 101721826, 101733013, 101722434, 101734872, 101735665, 101845089, 101726205, 101744534, 101734571, 101725649, 101745878, 101729907, 101738583], "A": [101719213, 101723947, 101718569, 101719365, 101718481, 101720960, 101718492, 101812211, 101718737, 101720191, 101718915, 101722560, 101731743, 101845090, 101719378, 101727785, 101719966, 101719274, 101731147, 101726149, 101719284], "F": [101844942]}, "name": "F. Flip and Reverse", "statement": "You are given a string s of \u2019s and \u2019s. You are allowed to perform the\r\nfollowing operation: choose a non-empty contiguous substring of s that\r\ncontains an equal number of \u2019s and \u2019s; flip all characters in the\r\nsubstring, that is, replace all \u2019s with \u2019s, and vice versa; reverse the\r\nsubstring. For example, consider s = , and the following operation:\r\nChoose the first six characters as the substring to act upon: . Note\r\nthat the number of \u2019s and \u2019s are equal, so this is a legal choice.\r\nChoosing substrings , , or the entire string would not be possible. Flip\r\nall characters in the substring: . Reverse the substring: . Find the\r\nlexicographically smallest string that can be obtained from s after zero\r\nor more operations.\r\n", "solutions": ["#include <bits/stdc++.h>\nconst int N = 1e6+5;\nint T, n, L[N], R[N], m, a[N]; char s[N];\nvoid dfs(int x)\n{\n    if(R[x]) --R[x], dfs(x+1);\n    if(L[x]) --L[x], dfs(x-1);\n    a[++m] = x;\n}\nint main()\n{\n    for(scanf(\"%d\", &T); T--; )\n    {\n        scanf(\"%s\", s+1), n = strlen(s+1);\n        for(int i = 1, x = n; i <= n; ++i) if(s[i] == '0') ++R[x], ++x; else ++L[x], --x;\n        m = 0, dfs(n); for(int i = m; i > 1; --i) putchar(a[i-1]-a[i] == 1?'0':'1'); puts(\"\");\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["graphs", "greedy"], "dificulty": "3100", "interactive": false}