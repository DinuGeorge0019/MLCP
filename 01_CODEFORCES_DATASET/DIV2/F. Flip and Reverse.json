{
    "link": "https://codeforces.com//contest/1459/problem/F",
    "problemId": "837953",
    "problem_idx": "F",
    "shortId": "1459F",
    "contest_number": "1459",
    "problem_submissions": {
        "C": [
            101746653,
            101722886,
            101730123,
            101721760,
            101730712,
            101728008,
            101731166,
            101730952,
            101740001,
            101726009,
            101726762,
            101728277,
            101727158,
            101729187,
            101723361,
            101723810,
            101728376,
            101726644,
            101732897,
            101727240
        ],
        "E": [
            101738323,
            101839753,
            102232354,
            101778763
        ],
        "D": [
            101727682,
            101736410,
            101735995,
            101740518,
            101738063,
            101735219,
            101739686,
            101738152,
            101733975,
            101740963,
            101743516,
            101745649,
            101741362,
            101744865,
            101740597,
            101748885,
            101751093,
            101741581,
            101747404,
            101748856
        ],
        "B": [
            101727154,
            101727768,
            101730156,
            101728078,
            101737211,
            101728162,
            101729594,
            101812219,
            101721826,
            101733013,
            101722434,
            101734872,
            101735665,
            101845089,
            101726205,
            101744534,
            101734571,
            101725649,
            101745878,
            101729907,
            101738583
        ],
        "A": [
            101719213,
            101723947,
            101718569,
            101719365,
            101718481,
            101720960,
            101718492,
            101812211,
            101718737,
            101720191,
            101718915,
            101722560,
            101731743,
            101845090,
            101719378,
            101727785,
            101719966,
            101719274,
            101731147,
            101726149,
            101719284
        ],
        "F": [
            101844942
        ]
    },
    "name": "F. Flip and Reverse",
    "statement": "You are given a string s of \u2019s and \u2019s. You are allowed to perform the\r\nfollowing operation: choose a non-empty contiguous substring of s that\r\ncontains an equal number of \u2019s and \u2019s; flip all characters in the\r\nsubstring, that is, replace all \u2019s with \u2019s, and vice versa; reverse the\r\nsubstring. For example, consider s = , and the following operation:\r\nChoose the first six characters as the substring to act upon: . Note\r\nthat the number of \u2019s and \u2019s are equal, so this is a legal choice.\r\nChoosing substrings , , or the entire string would not be possible. Flip\r\nall characters in the substring: . Reverse the substring: . Find the\r\nlexicographically smallest string that can be obtained from s after zero\r\nor more operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nconst int N = 1e6+5;\nint T, n, L[N], R[N], m, a[N]; char s[N];\nvoid dfs(int x)\n{\n    if(R[x]) --R[x], dfs(x+1);\n    if(L[x]) --L[x], dfs(x-1);\n    a[++m] = x;\n}\nint main()\n{\n    for(scanf(\"%d\", &T); T--; )\n    {\n        scanf(\"%s\", s+1), n = strlen(s+1);\n        for(int i = 1, x = n; i <= n; ++i) if(s[i] == '0') ++R[x], ++x; else ++L[x], --x;\n        m = 0, dfs(n); for(int i = m; i > 1; --i) putchar(a[i-1]-a[i] == 1?'0':'1'); puts(\"\");\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Flip and Reverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/85750",
    "editorial": "Let\u00e2\u0080\u0099s go over characters of left to right and keep track of the = (the\r\nnumber of \u00e2\u0080\u0099s) - (the number of \u00e2\u0080\u0099s) among the visited characters. We can\r\nthink about starting at the point , and moving right (from to ) when we\r\nsee a , and moving left (to ) when we see a . Each time we go from to ,\r\nlet\u00e2\u0080\u0099s connect the two points with an edge. We\u00e2\u0080\u0099ll keep track of all the\r\nedges, even if there are multiple ones connecting the same pair of\r\npoints. Since our path visits all edges we\u00e2\u0080\u0099ve created exactly once, it\r\nis an in the (multi)graph constructed this way. The start point of the\r\npath is , and the finish point is equal to the total balance of the\r\nstring .Now, let\u00e2\u0080\u0099s think about what a transformation does. A valid\r\nsubstring subject to the transformation has an equal number of \u00e2\u0080\u0099s and\r\n\u00e2\u0080\u0099s, thus it must correspond to a part of our path which is a round tour\r\nfrom a point back to itself. Flipping and reversing the substring makes\r\nus traverse all the same edges, but and . Thus, in terms of graphs and\r\npaths, what we\u00e2\u0080\u0099re doing is that occurs in the Eulerian path. Note that\r\nthe collection of edges is preserved after every operation, in other\r\nwords, the graph is an of the process. Furthermore, the start and finish\r\nof the path also stay the same.The answer (= lex. min. string) thus also\r\ncorresponds to a certain Eulerian path in the very same graph, but which\r\none? It should be the lex. min. path (where we prefer going right before\r\ngoing left) that is obtainable from the initial one with cycle reverses.\r\nHowever, the important observation is: in this particular graph Eulerian\r\npath is obtainable from other one with cycle reverses (as long as they\r\nstart and finish in the same places).There are a few ways to prove this.\r\nFor example, consider two Eulerian paths, and look at the first point\r\nwhere they diverge: say, one goes , while the other goes . But both\r\npaths will have to eventually return to to go in the other direction,\r\nthus there is at least one extra edge in each direction and , unvisited\r\nbefore the divergence happened. Let\u00e2\u0080\u0099s wait until the first path visits\r\nat least two edges between and , returning back to , and reverse the\r\nresulting cycle. With this, the next edge after diverging have changed\r\nfrom to , and now the two paths diverge some time later. We can proceed\r\nuntil both paths are the same.The observation implies that we should\r\nsimply look for the lex. min. Eulerian path in the entire graph. Let\u00e2\u0080\u0099s\r\ntry to do this greedily: build the path from the beginning, marking\r\nedges as used when we traverse them. Take the transition whenever there\r\nis a unused edge leading there, otherwise settle for . There is a\r\ncaveat, though: we can not go if this uses the last edge between and ,\r\nand additionally we still have to visit some time later (say, if has\r\nunused edges to ). However, with this extra condition in place, the\r\ngreedy algorithm will always find an Eulerian path, and it\u00e2\u0080\u0099s clearly the\r\nlex. min. one. This procedure is fairly easy to implement in linear\r\ntime: reconstruct the graph and do the greedy thing.\r\n"
}