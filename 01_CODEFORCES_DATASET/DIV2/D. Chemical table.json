{
    "link": "https://codeforces.com//contest/1013/problem/D",
    "problemId": "203188",
    "problem_idx": "D",
    "shortId": "1013D",
    "contest_number": "1013",
    "problem_submissions": {
        "E": [
            40956112,
            40954604,
            40952959,
            40954177,
            40956704,
            40954852,
            40958592,
            40955861,
            40956957,
            40959161,
            40962228,
            40958309,
            40954877,
            40961226,
            40962426,
            40963172,
            40959599,
            40960095,
            40962704,
            40960316
        ],
        "D": [
            40947895,
            40949235,
            40948190,
            40942963,
            40949230,
            40956987,
            40949637,
            40959376,
            40954303,
            40954900,
            40949703,
            40954385,
            40960744,
            40953417,
            40949714,
            40950014,
            40955109,
            40955161,
            40948236,
            40957040
        ],
        "C": [
            40945093,
            40946094,
            40946460,
            40948959,
            40947981,
            40948222,
            40950831,
            40945123,
            40948645,
            40944950,
            40947268,
            40951753,
            40947430,
            40945326,
            40946788,
            40945079,
            40948090,
            40945103,
            40952740,
            40948559
        ],
        "B": [
            40941603,
            40943452,
            40942391,
            40945819,
            40943517,
            40942695,
            40945308,
            40942798,
            40941517,
            40942505,
            40944306,
            40945361,
            40944304,
            40947125,
            40945606,
            40951205,
            40942971,
            40942106,
            40951005,
            40945032
        ],
        "A": [
            40939736,
            40940294,
            40939785,
            40944381,
            40940232,
            40940059,
            40941218,
            40939821,
            40939967,
            40940115,
            40940253,
            40940672,
            40939837,
            40940000,
            40940214,
            40942500,
            40940832,
            40939878,
            40942490,
            40940286
        ],
        "F": [
            82478981,
            40991650
        ]
    },
    "name": "D. Chemical table",
    "statement": "Innopolis University scientists continue to investigate the periodic\r\ntable. There are known elements and they form a periodic table: a\r\nrectangle with rows and columns. Each element can be described by its\r\ncoordinates (, ) in the table.Recently scientists discovered that for\r\nevery four different elements in this table that form a rectangle with\r\nsides parallel to the sides of the table, if they have samples of three\r\nof the four elements, they can produce a sample of the fourth element\r\nusing nuclear fusion. So if we have elements in positions , , , where\r\nand , then we can produce element . Samples used in fusion are not\r\nwasted and can be used again in future fusions. Newly crafted elements\r\nalso can be used in future fusions.Innopolis University scientists\r\nalready have samples of elements. They want to obtain samples of all\r\nelements. To achieve that, they will purchase some samples from other\r\nlaboratories and then produce all remaining elements using an arbitrary\r\nnumber of nuclear fusions in some order. Help them to find the minimal\r\nnumber of elements they need to purchase.\r\n",
    "solutions": [
        "/// In The Name Of God\n/// I wish, that I could leave it all behind me / Go to my own world where no one can find me\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define int long long\n#define ll long long\n#define pii pair <int , int>\n#define ld long double\n#define for2(a,b,c) for(int (a) = (b); (a) < (c); (a)++)\n#define for3(a,b,c) for(    (a) = (b); (a) < (c); (a)++)\n#define setp cout << fixed << setprecision(15)\n#define endl \"\\n\"\n#define minit(a,b) a = min(a,b)\n#define maxit(a,b) a = max(a,b)\n#define PII pair<int,int>\n#define Vec vector<int>\n#define error(x) cerr << #x << \" = \" << (x) << endl;\n#define all(x) (x).begin() , (x).end()\n\nconst int maxn = 400000+200;\nvector<int> adj[maxn];\nbool seen[maxn];\nint cnt;\nvoid dfs(int root){\n    seen[root] = 1;\n    for(auto x : adj[root]) if(!seen[x]) dfs(x);\n}\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,m,q; cin >> n >> m >> q;\n    for2(i,0,q){\n        int x,y; cin >> x >> y;\n        x--,y--;\n        y += 200000;\n        adj[x].pb(y);\n        adj[y].pb(x);\n    }\n    for2(i,0,n) if(!seen[i]) dfs(i),cnt++;\n    for2(i,0,m) if(!seen[i+200000]) dfs(i+200000),cnt++;\n    cout << cnt-1 << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "matrices"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Chemical table.json",
    "editorial_link": "https://codeforces.com//blog/entry/60920",
    "editorial": "One of the way to solve this problem is to interprete the cells in 2d matrix as an edge in the bipartite graph, that is a cell (i,?j) is an edge between i of the left part and j of the right part.\n\nNote, that each fusion operation (we have edges (r1,?c1), (r1,?c2), (r2,?c1) and get edge (r2,?c2)) doesn't change the connected components of the graph.\n\nMoreover, we can prove, that we can obtain each edge in the connected component by fusion.\n\nLet's examine example edge (x,?y), and some path between x and y (since they lay in one connected component). Since the graph is bipartite, the length of this path must be odd, and it is ???3, otherwise the edge already exists.\n\nSo we have this path. Take first three edges and make the corresponding fusion, replace this three edges with the brand new fused edge. The length of the path decreased by 2. Repeat until the path is a mere edge.\n\nThis way, the number of edges to add (cells to buy) is just number of connected components minus one."
}