{
    "link": "https://codeforces.com//contest/1689/problem/E",
    "problemId": "1426172",
    "problem_idx": "E",
    "shortId": "1689E",
    "contest_number": "1689",
    "problem_submissions": {
        "E": [
            160112065,
            160122128,
            160125790,
            160125174,
            160129572,
            160129585,
            160131786,
            160198613,
            160135003,
            160132850,
            160130305,
            160129724,
            160130309,
            160134699,
            160132208,
            160134730,
            160133947,
            160135624,
            160132845
        ],
        "D": [
            160105444,
            160106619,
            160103165,
            160105284,
            160109476,
            160111661,
            160111580,
            160114903,
            160117754,
            160223912,
            160117858,
            160115373,
            160119358,
            160119569,
            160110447,
            160119288,
            160122102,
            160117625,
            160122103
        ],
        "C": [
            160101725,
            160101027,
            160100377,
            160100502,
            160102947,
            160104518,
            160104470,
            160103940,
            160105751,
            160106384,
            160109439,
            160101319,
            160107036,
            160099160,
            160109505,
            160110151,
            160109766,
            160109925
        ],
        "B": [
            160095106,
            160095099,
            160095692,
            160094546,
            160098042,
            160100154,
            160098117,
            160097987,
            160101496,
            160099759,
            160105755,
            160095146,
            160101519,
            160094285,
            160105059,
            160102238,
            160103140,
            160102070
        ],
        "A": [
            160093939,
            160093596,
            160093753,
            160097601,
            160094503,
            160096047,
            160095876,
            160093955,
            160095035,
            160094694,
            160102269,
            160093545,
            160098465,
            160096387,
            160095131,
            160099800,
            160098054,
            160096796
        ]
    },
    "name": "E. ANDfinity",
    "statement": "After graduating from computer sciences, Vlad has been awarded an array\r\na_1,a_2,\r\nldots,a_n of n non-negative integers. As it is natural, he wanted to\r\nconstruct a graph consisting of n vertices, numbered 1, 2,\r\nldots, n. He decided to add an edge between i and j if and only if a_i\r\n& a_j > 0, where\r\n& denotes the bitwise AND operation.Vlad also wants the graph to be\r\nconnected, which might not be the case initially. In order to satisfy\r\nthat, he can do the following two types of operations on the array:\r\nChoose some element a_i and increment it by 1. Choose some element a_i\r\nand decrement it by 1 (possible only if a_i > 0). It can be proven that\r\nthere exists a finite sequence of operations such that the graph will be\r\nconnected. So, can you please help Vlad find the minimum possible number\r\nof operations to do that and also provide the way how to do that?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (a[i] == 0) a[i] = 1, ++ans;\n        }\n        auto check = [&](vector<int> a) {\n            vector<int> vis(31), f(31);\n            function<int(int)> find = [&](int x) {\n                if (f[x] == x) return f[x];\n                return f[x] = find(f[x]);\n            };\n            for (int i = 0; i <= 30; i++) f[i] = i;\n            for (auto i : a) {\n                int r = -1;\n                for (int b = 0; b <= 30; b++) {\n                    if ((i >> b) & 1) {\n                        vis[b] = 1;\n                        if (r == -1) r = b;\n                        f[find(b)] = find(r);\n                    }\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < 30; i++) {\n                if (vis[i] && find(i) == i) {\n                    ++cnt;\n                }\n            }\n            return cnt == 1;\n        };\n        if (check(a)) {\n            cout << ans << endl;\n            for (auto i : a) cout << i << \" \";\n            cout << endl;\n            continue;\n        }\n        int ok = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 1) {\n                --a[i];\n                if (check(a)) {\n                    cout << ans + 1 << endl;\n                    for (auto i : a) cout << i << \" \";\n                    cout << endl;\n                    ok = 1;\n                    break;\n                }\n                ++a[i];\n            }\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 1 << endl;\n                for (auto i : a) cout << i << \" \";\n                cout << endl;\n                ok = 1;\n                break;\n            }\n            --a[i];\n        }\n        if (ok) continue;\n        vector<int> vis(30), f(30);\n        for (int i = 0; i < 30; i++) f[i] = i;\n        function<int(int)> find = [&](int x) {\n            if (f[x] == x) return f[x];\n            return f[x] = find(f[x]);\n        };\n        for (auto i : a) {\n            int r = -1;\n            for (int b = 0; b <= 29; b++) {\n                if ((i >> b) & 1) {\n                    vis[b] = 1;\n                    if (r == -1) r = b;\n                    int x = find(b), y = find(r);\n                    if (x > y) f[x] = y;\n                    else f[y] = x;\n                }\n            }\n        }\n        for (int i = 29; i >= 0; i--) {\n            if (vis[i] && find(i) == i) {\n                for (int j = 0; j < n; j++) {\n                    if ((a[j] >> i) & 1) {\n                        --a[j];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 2 << endl;\n                for (auto i : a) cout << i << \" \";\n                cout << endl;\n                break;\n            }\n            --a[i];\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. ANDfinity.json",
    "editorial_link": "https://codeforces.com//blog/entry/103471",
    "editorial": "SolutionFirslty, let\u00e2\u0080\u0099s understand how to check whether the graph induced\r\nby some array is connected in . We create a graph over bits. Let\u00e2\u0080\u0099s take\r\nall elements and add an edge between their adjacent bits (all bits of a\r\nsingle will be connected). To quickly access the lowest bit we will use\r\nin code. Now we just check whether the graph over bits is connected.We\r\ncheck whether the graph for initial array is connected. If it is, the\r\nanswer is 0.Then, we wonder if the answer is . Check if at least one of\r\nthe graphs for arrays for every is connected. Do the same for arrays .\r\nIf none of the graphs is connected, the answer is and otherwise .Now\r\nlet\u00e2\u0080\u0099s see how the answer will be at most . Let be the sequence of\r\nindices denoting that has the highest lowest bit (the highest value of\r\n). if then we can just decrease by and connect everything. If and we do\r\nthe same we might disconnect that number from other numbers having the\r\nhighest lowest bit, thus an additional operation of adding to is needed\r\nto keep everything connected. The answer is in this case.Complexity of\r\nthis solution is .\r\n"
}