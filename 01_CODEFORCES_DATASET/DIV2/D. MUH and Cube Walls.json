{
    "link": "https://codeforces.com//contest/471/problem/D",
    "problemId": "14358",
    "problem_idx": "D",
    "shortId": "471D",
    "contest_number": "471",
    "problem_submissions": {
        "D": [
            7965405,
            7963038,
            7965335,
            7968421,
            7966244,
            7968397,
            7967934,
            7967754,
            7962449,
            7971169,
            7966737,
            7967640,
            7966907,
            7965389,
            7968194,
            7968684,
            7968144,
            7968063,
            7969059,
            7969743
        ],
        "C": [
            7963799,
            7964161,
            7963025,
            7965860,
            7964576,
            7965647,
            7964444,
            7963849,
            7964165,
            7964646,
            7964390,
            7964067,
            7964677,
            7967841,
            7964930,
            7962467,
            7965383,
            7966049,
            7964548,
            7964611
        ],
        "B": [
            7962693,
            7961062,
            7959880,
            7962852,
            7961634,
            7961073,
            7961603,
            7961941,
            7966053,
            7965991,
            7961463,
            7961486,
            7962239,
            7963641,
            7962519,
            7960810,
            7962445,
            7961115,
            7962351,
            7961842
        ],
        "A": [
            7960020,
            7958602,
            7958473,
            7958790,
            7958822,
            7958588,
            7958849,
            7958927,
            7967090,
            7966996,
            7958571,
            7958632,
            7958550,
            7959873,
            7959046,
            7969496,
            7958766,
            7958587,
            7958630,
            7959368
        ]
    },
    "name": "D. MUH and Cube Walls",
    "statement": "Polar bears Menshykov and Uslada from the zoo of St. Petersburg and\r\nelephant Horace from the zoo of Kiev got hold of lots of wooden cubes\r\nsomewhere. They started making cube towers by placing the cubes one on\r\ntop of the other. They defined multiple towers standing in a line as a\r\nwall. A wall can consist of towers of different heights.Horace was the\r\nfirst to finish making his wall. He called his wall an elephant. The\r\nwall consists of towers. The bears also finished making their wall but\r\nthey didn’t give it a name. Their wall consists of towers. Horace looked\r\nat the bears’ tower and wondered: in how many parts of the wall can he\r\n\"see an elephant\"? He can \"see an elephant\" on a segment of contiguous\r\ntowers if the heights of the towers on the segment match as a sequence\r\nthe heights of the towers in Horace’s wall. In order to see as many\r\nelephants as possible, Horace can raise and lower his wall. He even can\r\nlower the wall below the ground level (see the pictures to the samples\r\nfor clarification).Your task is to count the number of segments where\r\nHorace can \"see an elephant\".\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int maxn=2e5+5;\n\nint dis[maxn],next[maxn],s[maxn],t[maxn];\n\nvoid KMP(int s[],int len1,int t[],int len2)\n{\n\tint i,p=-1;\n\tnext[0]=-1;\n\tfor(i=1;i<len2;i++)\n\t{\n\t\twhile(p>=0&&t[p+1]!=t[i]) p=next[p];\n\t\tif(t[i]==t[p+1])\n\t\t\tp++;\n\t\tnext[i]=p;\n\t}\n\tp=-1;\n\tfor(i=0;i<len1;i++)\n\t{\n\t\twhile((p+1>=len2)||(p>=0&&s[i]!=t[p+1])) p=next[p];\n\t\tif(s[i]==t[p+1])\n\t\t\tp++;\n\t\tdis[i]=p;\n\t}\n}\n\nint n,m;\nint f[maxn];\n\nvoid init(int n,int s[]){\n    for(int i=0;i<n;i++)\n        scanf(\"%d\",&f[i]);\n    for(int i=0;i+1<n;i++)\n        s[i]=f[i+1]-f[i];\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    init(n,s);\n    init(m,t);\n    if(m==1){\n        cout<<n<<endl;\n        return 0;\n    }\n    n--,m--;\n    KMP(s,n,t,m);\n    int ans=0;\n    for(int i=0;i<n;i++)\n        if(dis[i]==m-1)ans++;\n    cout<<ans<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "string suffix structures",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. MUH and Cube Walls.json",
    "editorial_link": "https://codeforces.com//blog/entry/13986",
    "editorial": "In this problem we are given two arrays of integers and we need to find\r\nhow many times we can see second array as a subarray in the first array\r\nif we can add some arbitrary constant value to every element of the\r\nsecond array. Letâs call these arrays and . As many people noticed or\r\nknew in advance this problem can be solved easily if we introduce\r\ndifference arrays like that: (for every ) If we do that with both input\r\narrays we will receive two arrays both of which have one element less\r\nthan original arrays. Then with these arrays the problem simply becomes\r\nthe word search problem (though with possibly huge alphabet). This can\r\nbe solved using your favourite string data structure or algorithm.\r\nOriginally it was intended to look for linear solution but then we made\r\ntime limit higher in case if somebody will decide to send solution. I\r\nhavenât seen such solutions (that is understandable) but some people\r\ntried to squeeze in a quadratic solution. Linear solution can be made\r\nusing Z-function or KMP algorithm. In order to add a logarithmic factor\r\nyou can exercise with suffix array for example. I had suffix array\r\nsolution as well, but itâs a lot messier than linear solution. There is\r\none corner case you need to consider when Horaceâs wall contains only\r\none tower, then it matches bearsâ wall in every tower so the answer is .\r\nThough for some algorithms it might not even be a corner case if you\r\nassume that empty string matches everywhere. Another error which several\r\npeople did was to use actual string data structures to solve this\r\nproblem, so they converted the differences to chars. This doesnât work\r\nsince char canât hold the entire range an integer type can hold. I\r\ndidnât think that switching to difference arrays will be that obvious or\r\nwell-known, so I didnât expect that this problem will be solved by that\r\nmany people. Authorâs Z-function solution: 7978022 Authorâs suffix array\r\nsolution: 7978033\r\n",
    "hint": []
}