{
    "link": "https://codeforces.com//contest/2005/problem/B2",
    "problemId": "2874762",
    "problem_idx": "B2",
    "shortId": "2005B2",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "For this version, there are three cases, too. Case 1 and Case 2 from the above solution are still correct, but the last one should be changed a bit because now it is important between which two consecutive teachers David is. To find that teachers, we can use binary search (after sorting b\n, of course). After finding that David is between teachers i\n and i+1\n, the answer is (bi+1?bi)/2\n, just like the easy version.",
    "name": "B2. The Strict Teacher  Hard Version ",
    "statement": "Narek and Tsovak were busy preparing this round, so they have not\r\nmanaged to do their homework and decided to steal David\u2019s homework.\r\nTheir strict teacher noticed that David has no homework and now wants to\r\npunish him. She hires other teachers to help her catch David. And now m\r\nteachers together are chasing him. Luckily, the classroom is big, so\r\nDavid has many places to hide.The classroom can be represented as a\r\none-dimensional line with cells from 1 to n, inclusive.At the start, all\r\nm teachers and David are in cells. Then they make moves. During each\r\nmove David goes to an adjacent cell or stays at the current one. Then,\r\neach of the m teachers simultaneously goes to an adjacent cell or stays\r\nat the current one. This continues until David is caught. David is\r\ncaught if any of the teachers (possibly more than one) is located in the\r\nsame cell as David. Your task is to find how many moves it will take for\r\nthe teachers to catch David if they all act optimally.Acting optimally\r\nmeans the student makes his moves in a way that maximizes the number of\r\nmoves the teachers need to catch him; and the teachers coordinate with\r\neach other to make their moves in a way that minimizes the number of\r\nmoves they need to catch the student.Also, as Narek and Tsovak think\r\nthis task is easy, they decided to give you q queries on David\u2019s\r\nposition.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0int sir[100001];\u00a0inline void Solve (){    int limita , lungime , numar_intrebari;    cin >> limita >> lungime >> numar_intrebari;\u00a0    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[indice]; }\u00a0    sort(sir + 1 , sir + lungime + 1);\u00a0    while (numar_intrebari--)    {        int locatie;        cin >> locatie;\u00a0        if (locatie < sir[1])            { cout << sir[1] - 1 << '\\n'; continue; }\u00a0        if (locatie > sir[lungime])            { cout << limita - sir[lungime] << '\\n'; continue; }\u00a0        int pozitie = 0;        for (int putere = 65536 ; putere ; putere >>= 1) {            if ((pozitie | putere) <= lungime && sir[pozitie | putere] < locatie)                { pozitie |= putere; }        }\u00a0        cout << (sir[pozitie + 1] + sir[pozitie]) / 2 - sir[pozitie] << '\\n';    }   }\u00a0int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);\u00a0    int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }\u00a0    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B2. The Strict Teacher  Hard Version .json"
}