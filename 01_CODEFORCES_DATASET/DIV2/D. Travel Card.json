{
    "link": "https://codeforces.com//contest/760/problem/D",
    "problemId": "89819",
    "problem_idx": "D",
    "shortId": "760D",
    "contest_number": "760",
    "problem_submissions": {
        "F": [
            24048996,
            24334592,
            24109967
        ],
        "D": [
            24042480,
            24043732,
            24050024,
            24046176,
            24044696,
            24045116,
            24042014,
            24043570,
            24047853,
            24043885,
            24739234,
            24045094,
            24044167,
            24044943,
            24049808,
            24041812,
            24045235
        ],
        "C": [
            24040885,
            24041111,
            24041193,
            24043138,
            24047007,
            24043013,
            24038951,
            24041237,
            24046096,
            24041744,
            24041798,
            24042387,
            24042705,
            24049213,
            24042229,
            24044994,
            24042730
        ],
        "B": [
            24039488,
            24039342,
            24037031,
            24040294,
            24041983,
            24041211,
            24039467,
            24039465,
            24039319,
            24038489,
            24040344,
            24039097,
            24039942,
            24040090,
            24041062
        ],
        "A": [
            24036025,
            24035890,
            24035872,
            24036889,
            24036131,
            24037811,
            24035954,
            24036348,
            24036507,
            24036069,
            24036108,
            24036146,
            24036211,
            24041066,
            24035881,
            24035886,
            24036867
        ],
        "E": [
            24050782,
            24048436,
            24049579,
            24049178,
            24050210,
            24052439,
            24072140,
            24052585,
            24324528,
            24324402,
            24048812,
            24049062,
            24108774
        ]
    },
    "name": "D. Travel Card",
    "statement": "A new innovative ticketing systems for public transport is introduced in\r\nBytesburg. Now there is a single travel card for all transport. To make\r\na trip a passenger scan his card and then he is charged according to the\r\nfare.The fare is constructed in the following manner. There are three\r\ntypes of tickets: a ticket for one trip costs byteland rubles, a ticket\r\nfor minutes costs byteland rubles, a ticket for one day ( minutes) costs\r\nbyteland rubles. Note that a ticket for minutes activated at time can be\r\nused for trips started in time range from to , inclusive. Assume that\r\nall trips take exactly one minute.To simplify the choice for the\r\npassenger, the system automatically chooses the optimal tickets. After\r\neach trip starts, the system analyses all the previous trips and the\r\ncurrent trip and chooses a set of tickets for these trips with a minimum\r\ntotal cost. Let the minimum total cost of tickets to cover all trips\r\nfrom the first to the current is , and the total sum charged before is .\r\nThen the system charges the passenger the sum .You have to write a\r\nprogram that, for given trips made by a passenger, calculates the sum\r\nthe passenger is charged after each trip.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 100;\n\nint cost[N], t[N];\n\nint main(){\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &t[i]);\n\n\tcost[0] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tcost[i + 1] = cost[i] + 20;\n\n\t\tint ind = upper_bound(t, t + i, t[i] - 90) - t;\n\t\tcost[i + 1] = min(cost[ind] + 50, cost[i + 1]);\n\n\t\tind = upper_bound(t, t + i, t[i] - 1440) - t;\n\t\tcost[i + 1] = min(cost[ind] + 120, cost[i + 1]);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d\\n\", cost[i + 1] - cost[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Travel Card.json",
    "editorial_link": "https://codeforces.com//blog/entry/49946",
    "editorial": "Hint: the problem looks difficult because tickets can change, however, it's can be solved with simple dynamic programming. You are asked the difference between neighboring dp's subtasks."
}