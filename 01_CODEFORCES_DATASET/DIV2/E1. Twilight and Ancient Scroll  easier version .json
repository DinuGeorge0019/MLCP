{
    "link": "https://codeforces.com//contest/1393/problem/E1",
    "problemId": "693074",
    "problem_idx": "E1",
    "shortId": "1393E1",
    "contest_number": "1393",
    "problem_submissions": {
        "D": [
            89235864,
            89237678,
            89239942,
            89241904,
            89240571,
            89239873,
            89230308,
            89237378,
            89247700,
            89240803,
            89243160,
            89243648,
            89242883,
            89238243,
            89242864,
            89249422,
            89245780,
            89244250
        ],
        "B": [
            89221116,
            89217441,
            89220933,
            89222989,
            89220509,
            89223779,
            89220401,
            89219535,
            89219377,
            89227149,
            89220055,
            89224518,
            89222569,
            89225245,
            89223599,
            89220060,
            89222338,
            89225655
        ],
        "C": [
            89218957,
            89225521,
            89228764,
            89230329,
            89224448,
            89234176,
            89238147,
            89233693,
            89228718,
            89234223,
            89234984,
            89234287,
            89231225,
            89232086,
            89232825,
            89232005,
            89235490,
            89236144
        ],
        "A": [
            89218814,
            89212583,
            89214268,
            89213479,
            89214230,
            89213219,
            89213191,
            89220955,
            89212600,
            89213989,
            89213307,
            89215648,
            89216757,
            89215210,
            89215943,
            89213088,
            89214183
        ],
        "E1": [
            89281813
        ]
    },
    "name": "E1. Twilight and Ancient Scroll  easier version ",
    "statement": "Twilight Sparkle has received a new task from Princess Celestia. This\r\ntime she asked to decipher the ancient scroll containing important\r\nknowledge of pony origin.To hide the crucial information from evil eyes,\r\npony elders cast a spell on the scroll. That spell adds exactly one\r\nletter in any place to each word it is cast on. To make the path to the\r\nknowledge more tangled elders chose of words in the scroll and cast a\r\nspell on them.Twilight Sparkle knows that the elders admired the order\r\nin all things so the scroll original scroll contained words in . She is\r\nasked to delete one letter from some of the words of the scroll (to undo\r\nthe spell) to get some version of the original scroll. Unfortunately,\r\nthere may be more than one way to recover the ancient scroll. To not let\r\nthe important knowledge slip by Twilight has to look through all\r\nvariants of the original scroll and find the required one. To estimate\r\nthe maximum time Twilight may spend on the work she needs to know the\r\nnumber of variants she has to look through. She asks you to find that\r\nnumber! Since that number can be very big, Twilight asks you to find it\r\nmodulo 10^9+7.It may occur that princess Celestia has sent a wrong\r\nscroll so the answer may not exist.A string a is lexicographically\r\nsmaller than a string b if and only if one of the following holds: a is\r\na prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring arr[2009];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    long long t=1;\n    //cin>>t;\n    while(t--) {\n        int n;\n        cin>>n;\n        int x=0,y=0;\n        for(int f=0;f<n;f++) {\n            cin>>arr[f];\n            x+=arr[f].size()+1;\n        }\n        long long ans=0,dp[22009]={0},mod=1e9+7;\n        for(int f=0;f<=arr[n-1].size();f++) {\n            dp[--x]=1;\n        }\n        y=x;\n        for(int f=n-2;f>=0;f--) {\n            x-=arr[f].size()+1;\n            int m=max(arr[f].size(),arr[f+1].size());\n            int m1=arr[f].size();\n            int m2=arr[f+1].size();\n            while(arr[f].size()<m)\n                arr[f]+=('a'-1);\n            while(arr[f+1].size()<m)\n                arr[f+1]+=('a'-1);\n            for(int f1=-1;f1<m1;f1++) {\n                bool ok[20009]={0};\n                int i=m-1;\n                if(f1==-1) {\n                    arr[f+1]+=('a'-1);\n                    m++;\n                }\n                ok[m]=1;\n                for(int f2=m-1;f2>=1;f2--) {\n                    if(i==f1)\n                        i--;\n                    if(arr[f][i]<arr[f+1][f2]||arr[f][i]==arr[f+1][f2]&&(f2==m-1||ok[f2+1]))\n                        ok[f2]=1;\n                    i--;\n                }\n                bool b=0;\n                bool k=0;\n                i=0;\n                if(arr[f].substr(0,max(0,f1))+arr[f].substr(f1+1)<=arr[f+1]) {\n                    dp[x+f1+1]=(dp[x+f1+1]+dp[y])%mod;\n                    //cout<<x+f1+1<<\" \"<<y<<endl;\n                }\n                for(int f2=0;f2<m2;f2++){\n                    int x1=x+f1+1;\n                    int y1=y+f2+1;\n                    //cout<<\"f2: \"<<f2<<\" x: \"<<x1<<\" y: \"<<y1<<endl;\n\n                    if(i==f1)\n                        i++;\n                    if(b) {\n                        //cout<<\"1 \"<<x1<<\" \"<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&f2+1==m) {\n                        //cout<<\"2 \"<<x1<<\" \"<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]>arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<\"3 \"<<x1<<\" \"<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]==arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<\"4 \"<<x1<<\" \"<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]<arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<\"5 \"<<x1<<\" \"<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    if(b==0&&f2>=0&&arr[f][i]>arr[f+1][f2]) {\n                        k=1;\n                        //cout<<\"k\"<<endl;\n                    }\n                    if(k==0&&f2>=0&&arr[f][i]<arr[f+1][f2]) {\n                        b=1;\n                        //cout<<\"b\"<<endl;\n                    }\n                    i++;\n                }\n            }\n            arr[f]=arr[f].substr(0,m1);\n            arr[f+1]=arr[f+1].substr(0,m2);\n            y-=arr[f].size()+1;\n        }\n        //cout<<\"x: \"<<x<<endl;\n        for(int f=0;f<=arr[0].size();f++) {\n            ans=(ans+dp[f])%mod;\n        }\n        //for(int f=0;f<x;f++)\n        //    cout<<dp[f]<<\" \";\n        //cout<<endl;\n        cout<<ans<<endl;\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "hashing",
        "implementation",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Twilight and Ancient Scroll  easier version .json",
    "editorial_link": "https://codeforces.com//blog/entry/81161",
    "editorial": "Let's use dynamic programming. dp[i][j]\n: the number of ways to form the non-decreasing subsequence on the strings 1\u0085i\n, s.t. the delete character in string i\n is j\n. This works in O(L3)\n, where L\n is the total length of all strings.\n\nLet's optimize this solution. For each string, sort all strings obtained by deleting at most one character from this string. You can do it in O(L2?logL)\n for all strings. Then you can use two pointers to calculate or dp. To calculate the answer for the layer i\n we will consider strings in the sorted order, and add all dp values for the smaller strings. We can calculate this dp in O(L2)\n and solve the problem in O(L2?logL)\n. We can use binary search and hash to compare strings in O(logL)\n. Then you can sort all the strings in O(L?log2L)\n.\n\nNote that you can sort the strings in O(L)\n. Look at the string s\n. For each character find the first character to the right not equal to it (array nxt[i]\n). Then we will store two pointers: to the beginning and the end of the list. Consider characters in the order from left to right. If si\n > snxt[i]\n, add i\n to the beginning of the list (to the position l\n and increase l\n by 1\n), otherwise add it to the end of the list (to the position r\n and decrease r\n by 1\n). Then add s\n to some position in the list (s\n will be in the list after it without the last character). Then you can use the hash to make the comparisons for two pointers in O(logL)\n. This sol works in O(L?logL)\n and fits into TL."
}