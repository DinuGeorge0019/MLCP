{"link": "https://codeforces.com//contest/965/problem/D", "problemId": "178362", "problem_idx": "D", "shortId": "965D", "contest_number": "965", "problem_submissions": {"E": [37616803, 37610971, 41503980, 40197656, 37654456, 37654431, 40318499, 37616580], "D": [37611930, 37607040, 41317763, 37610171, 37612067, 37611181, 37613901, 37612776, 37612200, 37613391, 37614260, 37613271, 37613054, 37610290, 37613116, 37613596, 37613050, 37608849, 37612402], "C": [37610216, 37627090, 37608448, 37610114, 37609387, 37611531, 37607821, 37608408, 37609724, 37610645, 37613952, 37610230, 37612051, 37612323], "B": [37605866, 37605512, 37606428, 37607027, 37606169, 37607177, 37606751, 37606339, 37606193, 37607495, 37606252, 37606978, 37608449, 37606976, 37606755, 37607765, 37606148, 37607397], "A": [37604550, 37604452, 37604479, 37604681, 37604781, 37605030, 37604765, 37604552, 37605013, 37605227, 37604704, 37604697, 37605015, 37604932, 37605063, 37605445, 37634065, 37604890]}, "name": "D. Single-use Stones", "statement": "A lot of frogs want to cross a river. A river is w units width, but\r\nfrogs can only jump l units long, where l < w. Frogs can also jump on\r\nlengths shorter than l. but can\u2019t jump longer. Hopefully, there are some\r\nstones in the river to help them.The stones are located at integer\r\ndistances from the banks. There are a_i stones at the distance of i\r\nunits from the bank the frogs are currently at. Each stone can only be\r\nused once by one frog, after that it drowns in the water.What is the\r\nmaximum number of frogs that can cross the river, given that then can\r\nonly jump on the stones?\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nll w, l;\n\nll a[N];\nll b[N];\n\nset <int> st;\n\nint main() {\n scanf(\"%d%d\", &w, &l);\n st.insert(w);\n for (int i = 1; i < w; i++) {\n  scanf(\"%d\", &a[i]);\n  if (a[i] > 0) st.insert(i);\n }\n b[0] = int(1e9);\n a[w] = int(1e9);\n for (int i = 0; i < w; i++) {\n  while (b[i] > 0) {\n   set <int>::iterator it = st.upper_bound(i + l);\n   if (it != st.begin()) {\n    it--;\n    int x = min(a[*it], b[i]);\n    b[i] -= x;\n    a[*it] -= x;\n    b[*it] += x;\n    if (!a[*it]) st.erase(it);\n   } else break;\n  }\n }\n cout << b[w];\n return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "flows", "greedy", "two pointers"], "dificulty": "1900", "interactive": false}