{
    "link": "https://codeforces.com//contest/1313/problem/D",
    "problemId": "546724",
    "problem_idx": "D",
    "shortId": "1313D",
    "contest_number": "1313",
    "problem_submissions": {
        "E": [
            71681170,
            71676206,
            71701918,
            71678634,
            71684245
        ],
        "D": [
            71668784,
            71676711,
            71679066,
            71902295,
            71669382,
            71676113,
            71676282,
            71682897,
            71682850,
            71684110,
            71683951,
            71679478,
            71685695,
            71684314,
            71693014,
            71684216,
            71672133,
            71677829,
            71681283
        ],
        "C1": [
            71659792,
            71665149,
            71664308,
            71663397,
            71902274,
            71657100,
            71662551,
            71666875,
            71662026,
            71660339,
            71665119,
            71670647,
            71661830,
            71671471,
            71673887,
            71666482,
            71663477,
            71673192,
            71664658,
            71659547,
            71660235
        ],
        "C2": [
            71659727,
            71665106,
            71664225,
            71663324,
            71902282,
            71657182,
            71679705,
            71666789,
            71661927,
            71660290,
            71665068,
            71670595,
            71672508,
            71671524,
            71673974,
            71666543,
            71663428,
            71673118,
            71664615,
            71659474,
            71664008
        ],
        "B": [
            71658438,
            71660532,
            71661422,
            71660555,
            71902225,
            71683862,
            71659255,
            71661835,
            71671081,
            71672434,
            71661140,
            71675335,
            71666293,
            71666358,
            71674883,
            71661144,
            71675700,
            71667622
        ],
        "A": [
            71654494,
            71655402,
            71656261,
            71655976,
            71902195,
            71678655,
            71654489,
            71655616,
            71656192,
            71666785,
            71655624,
            71657167,
            71655162,
            71654706,
            71657644,
            71657443,
            71657488,
            71654829,
            71654475,
            71655371,
            71655189
        ]
    },
    "name": "D. Happy New Year",
    "statement": "Being Santa Claus is very difficult. Sometimes you have to deal with\r\ndifficult situations.Today Santa Claus came to the holiday and there\r\nwere m children lined up in front of him. Let\u2019s number them from 1 to m.\r\nGrandfather Frost knows n spells. The i-th spell gives a candy to every\r\nchild whose place is in the [L_i, R_i] range. Each spell can be used at\r\nmost once. It is also known that if all spells are used, each child will\r\nreceive at most k candies.It is not good for children to eat a lot of\r\nsweets, so each child can eat no more than one candy, while the\r\nremaining candies will be equally divided between his (or her) Mom and\r\nDad. So it turns out that if a child would be given an even amount of\r\ncandies (possibly zero), then he (or she) will be unable to eat any\r\ncandies and will go sad. However, the rest of the children (who received\r\nan odd number of candies) will be happy.Help Santa Claus to know the\r\nmaximum number of children he can make happy by casting some of his\r\nspells.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint L[100010],R[100010],U[200010],u;\nint f[200010][1<<8|1];\nstd::vector<int>v[200010];\nint MX[1<<8|1],par[1<<8|1],pos[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),____=gi(),___=gi();\n\tfor(int i=1;i<=n;++i)L[i]=gi(),R[i]=gi()+1,U[++u]=L[i],U[++u]=R[i];\n\tstd::sort(U+1,U+u+1);u=std::unique(U+1,U+u+1)-U-1;\n\tfor(int i=1;i<=n;++i)L[i]=std::lower_bound(U+1,U+u+1,L[i])-U;\n\tfor(int i=1;i<=n;++i)R[i]=std::lower_bound(U+1,U+u+1,R[i])-U-1;\n\tfor(int i=1;i<=n;++i)for(int j=L[i];j<=R[i];++j)v[j].push_back(i);\n\tmemset(f,-63,sizeof f);\n\tfor(int i=0;i<1<<8;++i)par[i]=__builtin_parity(i);\n\tf[0][0]=0;\n\tmemset(pos,-1,sizeof pos);\n\tfor(int i=0;i<u;++i){\n\t\tint o=v[i].size();\n\t\tmemset(MX,-63,sizeof MX);\n\t\tfor(int j=0;j<1<<o;++j){\n\t\t\tint S=0;\n\t\t\tfor(int k=0;k<o;++k)if((j>>k&1)&&R[v[i][k]]>i)S|=1<<k;\n\t\t\tif(par[j]&&f[i][j]>=0)f[i][j]+=U[i+1]-U[i];\n\t\t\tMX[S]=std::max(MX[S],f[i][j]);\n\t\t}\n\t\tint old=0;\n\t\tfor(int j=0;j<v[i].size();++j)pos[v[i][j]]=-1;\n\t\tfor(int j=0;j<v[i+1].size();++j)pos[v[i+1][j]]=j;\n\t\tfor(int j=0;j<o;++j)if(~pos[v[i][j]])old|=1<<pos[v[i][j]];\n\t\tint O=v[i+1].size();\n\t\tfor(int j=0;j<1<<o;++j){\n\t\t\tif(MX[j]>=0){\n\t\t\t\tint nS=0;\n\t\t\t\tfor(int k=0;k<o;++k)\n\t\t\t\t\tif((j>>k&1)&&R[v[i][k]]>i)\n\t\t\t\t\t\tnS|=1<<pos[v[i][k]];\n\t\t\t\tint E=((1<<O)-1)^old;\n\t\t\t\tfor(int k=E;;k=(k-1)&E){\n\t\t\t\t\tf[i+1][k|nS]=std::max(f[i+1][k|nS],MX[j]);\n\t\t\t\t\tif(!k)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[u][0]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Happy New Year.json",
    "editorial_link": "https://codeforces.com//blog/entry/74146",
    "editorial": "We wil use scanline to solve this problem. For all segments, we add\r\nevent of its beginning and end. Let\u00e2\u0080\u0099s maintain , where is number of\r\nevents that we have already processed. is mask of bits, where in some\r\nbit means that segment corresponding to this bit is taken.How to move\r\nfrom one coordinate to another? For all masks we can count number of\r\nbits and if it is odd, we should add distance between to points to value\r\nof this .How to add new segment? As we know, at one point can be at most\r\nsegments, so when we add segment we can find free bit and create match\r\nto this segment. After this operation we also should change some values\r\nof . Deleting of the segments is similar to adding.As you may notice,\r\nonly -th lay is needed to calculate -th lay, so we can use only\r\nadditional memory.Total complexity .\r\n"
}