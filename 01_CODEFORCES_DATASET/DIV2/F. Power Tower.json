{
    "link": "https://codeforces.com//contest/907/problem/F",
    "problemId": "140862",
    "problem_idx": "F",
    "shortId": "907F",
    "contest_number": "907",
    "problem_submissions": {
        "A": [
            33575410,
            33562373,
            33540675,
            33541958,
            33569551,
            33540657,
            33540926,
            33554400,
            33543519,
            33543455,
            33545359,
            33546723,
            33543893,
            33544746,
            33541852,
            33545259,
            33542765,
            33544738,
            33545990
        ],
        "E": [
            33569336,
            33565777,
            33581296,
            33581269,
            33579404,
            33566284,
            33569922,
            33629468,
            33568809,
            33566385,
            33570242,
            33565403,
            33570350
        ],
        "D": [
            33565126,
            33562641,
            33581688,
            33581260,
            33565908,
            33566346,
            33568422,
            33569754,
            33570678
        ],
        "C": [
            33549830,
            33551329,
            33554149,
            33567015,
            33549957,
            33554343,
            33567823,
            33552808,
            33554965,
            33557383,
            33556644,
            33558626,
            33561202,
            33556067,
            33558273,
            33556336,
            33558166,
            33556124
        ],
        "B": [
            33544318,
            33546636,
            33559945,
            33562988,
            33544727,
            33549069,
            33570043,
            33548318,
            33549618,
            33552052,
            33550884,
            33550827,
            33550979,
            33551429,
            33553199,
            33549528,
            33551065,
            33549896
        ],
        "F": [
            33567143,
            33554423,
            33558532,
            40494408
        ]
    },
    "name": "F. Power Tower",
    "statement": "Priests of the Quetzalcoatl cult want to build a tower to represent a\r\npower of their god. Tower is usually made of power-charged rocks. It is\r\nbuilt with the help of rare magic by levitating the current top of tower\r\nand adding rocks at its bottom. If top, which is built from rocks,\r\npossesses power and we want to add the rock charged with power then\r\nvalue of power of a new tower will be . Rocks are added from the last to\r\nthe first. That is for sequence value of power will beAfter tower is\r\nbuilt, its power may be extremely large. But still priests want to get\r\nsome information about it, namely they want to know a number called\r\ncumulative power which is the true value of power taken modulo . Priests\r\nhave rocks numbered from to . They ask you to calculate which value of\r\ncumulative power will the tower possess if they will build it from rocks\r\nnumbered .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nnamespace IO{\n\tconst int __buffsize = 1000000;char __buff[__buffsize];char *__buffS, *__buffT;\n\tchar getch(){if (__buffS == __buffT){__buffT = (__buffS = __buff) + fread(__buff,1,__buffsize,stdin);if (__buffS == __buffT) return EOF;}return *__buffS++;}\n\t#define getch getchar\n\tint read(){int T = 0,f = 1;char c = getch();while ((c<'0'||c>'9')&&c!='-') c=getch();if(c=='-')f=-1,c=getch();while (c>='0'&&c<='9'){T=((T<<1)+(T<<3))+c-48;c=getch();}return T*f;}\n\tvoid write(int x){if(x < 0) putchar('0'),x = -x;if (x>=10) write(x / 10);putchar((x % 10)+'0');}\n\tvoid writeln(int x){write(x);puts(\"\");}\n};\ntypedef long long LL;\nusing namespace IO;\nint n;\nconst int maxn = 800010;\nLL a[maxn],p[maxn];\n//p保存欧拉函数 \nint Pow(int,int,int);\nint solve(int l,int r,int Mod,int deep){\n\tif (Mod == 1) return 1;\n\tLL now = a[l] % Mod;\n\tif (!now) return 0;\n\tif (l == r) return now;\n\tint nxt = min(l+5,r);\n\tfor (int i=l+1;i<nxt;i++)\n\t\tif (a[i] == 1){\n\t\t\tnxt = r = i;\n\t\t\tbreak;\n\t\t}//考虑得到指数是否为1，如果指数为1那么可以直接算 \n\tLL last = a[nxt],x;\n\t//然后到nxt可以query出幂次是否可能超过phi \n\tif (last >= p[deep])\n\t\treturn Pow(now,solve(l+1,r,p[deep],deep+1) + p[deep],Mod);\n//考虑扩展欧拉定理，如果满足\n\tfor (int i=nxt-1;i>l;i--){\n\t\tLL mi = last;\n\t\tlast = 1;\n\t\tx = a[i];\n\t\tfor (int j=1;j<=mi;j++){\n\t\t\tlast = last * x;\n\t\t\tif (last >= p[deep]) return Pow(now,solve(l+1,r,p[deep],deep+1) + p[deep],Mod);\n\t\t}\n\t}\n\treturn Pow(now,solve(l+1,r,p[deep],deep+1),Mod);\n}\n\nint Pow(int a,int b,int Mod){\n\tint Ans = 1;\n\tfor (;b;b>>=1,a=1LL*a*a%Mod)\n\t\tif (b&1) Ans = 1LL * Ans * a % Mod;\n\treturn Ans;\n}\nint Getphi(int x){\n\tint ans = x;\n\tfor (int i=2;i*i<=x;i++){\n\t\tif (x % i == 0){\n\t\t\tans = ans / i * (i-1);\n\t\t\twhile (x % i == 0) x /= i;\n\t\t}\n\t}\n\tif (x > 1) ans = ans / x * (x-1);\n\treturn ans;\n}\nint Mod,cnt;\nvoid init(){\n\tscanf(\"%d%d\",&n,&Mod);\n\tfor (int i=1;i<=n;i++) scanf(\"%I64d\",&a[i]);\n\tcnt = 0;\n\tp[0] = Mod;\n\twhile (p[cnt] != 1) p[++cnt] = Getphi(p[cnt - 1]);\n\tp[++cnt] = 1;\n}\nint main(){\n\tinit();\n\tint m = read();\n\twhile (m--){\n\t\tint x = read(),y = read();\n\t\tprintf(\"%d\\n\",solve(x,y,Mod,1) % Mod);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Power Tower.json",
    "editorial_link": "https://codeforces.com//blog/entry/56601",
    "editorial": "Let's learn to calculate . Assume that we want to find  where n and m non necessary co-prime, and x is some big number which we can calculate only modulo some value.\n\nWe can solve this problem for co-prime n and m via Euler's theorem. Let's reduce general case to that one. Note that . Indeed if n?=?d·m?+?r,?|r|?<?m, then an?=?d·am?+?ar,?|ar|?<?|am|. Let p1,?...,?pt to be common prime divisors of n and m, a?=?p1k1... ptkt to be such number that it divisible by such divisors to the power they occur in m, and k to be least number such that . Then we have a chain\n\n\nHere n and m?/?a are co-prime so we can calculate power value module . Moreover, , thus case x?<?k can be considered in .\n\nThis is already enough to solve the problem, but continuing one can prove that for  it holds\n\n\nWhere ?(m) is Euler totient function of m. Finally, to solve the problem one shoud note that  so it will take only  steps before m turns into 1.",
    "hint": []
}