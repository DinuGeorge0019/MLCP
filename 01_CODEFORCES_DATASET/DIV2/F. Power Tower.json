{"link": "https://codeforces.com//contest/907/problem/F", "problemId": "140862", "problem_idx": "F", "shortId": "907F", "contest_number": "907", "problem_submissions": {"A": [33575410, 33562373, 33540675, 33541958, 33569551, 33540657, 33540926, 33554400, 33543519, 33543455, 33545359, 33546723, 33543893, 33544746, 33541852, 33545259, 33542765, 33544738, 33545990], "E": [33569336, 33565777, 33581296, 33581269, 33579404, 33566284, 33569922, 33629468, 33568809, 33566385, 33570242, 33565403, 33570350], "D": [33565126, 33562641, 33581688, 33581260, 33565908, 33566346, 33568422, 33569754, 33570678], "C": [33549830, 33551329, 33554149, 33567015, 33549957, 33554343, 33567823, 33552808, 33554965, 33557383, 33556644, 33558626, 33561202, 33556067, 33558273, 33556336, 33558166, 33556124], "B": [33544318, 33546636, 33559945, 33562988, 33544727, 33549069, 33570043, 33548318, 33549618, 33552052, 33550884, 33550827, 33550979, 33551429, 33553199, 33549528, 33551065, 33549896], "F": [33567143, 33554423, 33558532, 40494408]}, "name": "F. Power Tower", "statement": "Priests of the Quetzalcoatl cult want to build a tower to represent a\r\npower of their god. Tower is usually made of power-charged rocks. It is\r\nbuilt with the help of rare magic by levitating the current top of tower\r\nand adding rocks at its bottom. If top, which is built from rocks,\r\npossesses power and we want to add the rock charged with power then\r\nvalue of power of a new tower will be . Rocks are added from the last to\r\nthe first. That is for sequence value of power will beAfter tower is\r\nbuilt, its power may be extremely large. But still priests want to get\r\nsome information about it, namely they want to know a number called\r\ncumulative power which is the true value of power taken modulo . Priests\r\nhave rocks numbered from to . They ask you to calculate which value of\r\ncumulative power will the tower possess if they will build it from rocks\r\nnumbered .\r\n", "solutions": ["#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nnamespace IO{\n\tconst int __buffsize = 1000000;char __buff[__buffsize];char *__buffS, *__buffT;\n\tchar getch(){if (__buffS == __buffT){__buffT = (__buffS = __buff) + fread(__buff,1,__buffsize,stdin);if (__buffS == __buffT) return EOF;}return *__buffS++;}\n\t#define getch getchar\n\tint read(){int T = 0,f = 1;char c = getch();while ((c<'0'||c>'9')&&c!='-') c=getch();if(c=='-')f=-1,c=getch();while (c>='0'&&c<='9'){T=((T<<1)+(T<<3))+c-48;c=getch();}return T*f;}\n\tvoid write(int x){if(x < 0) putchar('0'),x = -x;if (x>=10) write(x / 10);putchar((x % 10)+'0');}\n\tvoid writeln(int x){write(x);puts(\"\");}\n};\ntypedef long long LL;\nusing namespace IO;\nint n;\nconst int maxn = 800010;\nLL a[maxn],p[maxn];\n//p\u4fdd\u5b58\u6b27\u62c9\u51fd\u6570 \nint Pow(int,int,int);\nint solve(int l,int r,int Mod,int deep){\n\tif (Mod == 1) return 1;\n\tLL now = a[l] % Mod;\n\tif (!now) return 0;\n\tif (l == r) return now;\n\tint nxt = min(l+5,r);\n\tfor (int i=l+1;i<nxt;i++)\n\t\tif (a[i] == 1){\n\t\t\tnxt = r = i;\n\t\t\tbreak;\n\t\t}//\u8003\u8651\u5f97\u5230\u6307\u6570\u662f\u5426\u4e3a1\uff0c\u5982\u679c\u6307\u6570\u4e3a1\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u7b97 \n\tLL last = a[nxt],x;\n\t//\u7136\u540e\u5230nxt\u53ef\u4ee5query\u51fa\u5e42\u6b21\u662f\u5426\u53ef\u80fd\u8d85\u8fc7phi \n\tif (last >= p[deep])\n\t\treturn Pow(now,solve(l+1,r,p[deep],deep+1) + p[deep],Mod);\n//\u8003\u8651\u6269\u5c55\u6b27\u62c9\u5b9a\u7406\uff0c\u5982\u679c\u6ee1\u8db3\n\tfor (int i=nxt-1;i>l;i--){\n\t\tLL mi = last;\n\t\tlast = 1;\n\t\tx = a[i];\n\t\tfor (int j=1;j<=mi;j++){\n\t\t\tlast = last * x;\n\t\t\tif (last >= p[deep]) return Pow(now,solve(l+1,r,p[deep],deep+1) + p[deep],Mod);\n\t\t}\n\t}\n\treturn Pow(now,solve(l+1,r,p[deep],deep+1),Mod);\n}\n\nint Pow(int a,int b,int Mod){\n\tint Ans = 1;\n\tfor (;b;b>>=1,a=1LL*a*a%Mod)\n\t\tif (b&1) Ans = 1LL * Ans * a % Mod;\n\treturn Ans;\n}\nint Getphi(int x){\n\tint ans = x;\n\tfor (int i=2;i*i<=x;i++){\n\t\tif (x % i == 0){\n\t\t\tans = ans / i * (i-1);\n\t\t\twhile (x % i == 0) x /= i;\n\t\t}\n\t}\n\tif (x > 1) ans = ans / x * (x-1);\n\treturn ans;\n}\nint Mod,cnt;\nvoid init(){\n\tscanf(\"%d%d\",&n,&Mod);\n\tfor (int i=1;i<=n;i++) scanf(\"%I64d\",&a[i]);\n\tcnt = 0;\n\tp[0] = Mod;\n\twhile (p[cnt] != 1) p[++cnt] = Getphi(p[cnt - 1]);\n\tp[++cnt] = 1;\n}\nint main(){\n\tinit();\n\tint m = read();\n\twhile (m--){\n\t\tint x = read(),y = read();\n\t\tprintf(\"%d\\n\",solve(x,y,Mod,1) % Mod);\n\t}\n}"], "input": "", "output": "", "tags": ["math", "number theory"], "dificulty": "2700", "interactive": false}