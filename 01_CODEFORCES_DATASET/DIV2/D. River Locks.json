{
    "link": "https://codeforces.com//contest/1700/problem/D",
    "problemId": "1433685",
    "problem_idx": "D",
    "shortId": "1700D",
    "contest_number": "1700",
    "problem_submissions": {
        "F": [
            161204184,
            161175037,
            161206125,
            161212939,
            161208920,
            161208613,
            161221499,
            161209546
        ],
        "E": [
            161198687,
            161196286,
            161355967,
            161718414,
            161625123,
            161210058,
            161186427,
            161205675,
            161211460,
            161212251,
            161209815,
            161226432,
            161215179,
            161212687,
            161209759,
            161208133,
            161212427
        ],
        "D": [
            161181899,
            161187142,
            161172748,
            161191235,
            161182477,
            161193166,
            161184771,
            161194388,
            161383056,
            161196489,
            161188119,
            161188891,
            161183798,
            161190373,
            161201766,
            161189358,
            161191653,
            161196390,
            161376237,
            161189700,
            161191427
        ],
        "C": [
            161179311,
            161183541,
            161180380,
            161184212,
            161718390,
            161184885,
            161181511,
            161178526,
            161188654,
            161193034,
            161183225,
            161183002,
            161175389,
            161193124,
            161191878,
            161177816,
            161183179,
            161187003,
            161183522,
            161177845
        ],
        "B": [
            161174411,
            161180612,
            161180415,
            161180363,
            161174680,
            161179087,
            161174700,
            161180026,
            161190959,
            161175925,
            161173974,
            161173339,
            161174147,
            161181560,
            161181382,
            161172925,
            161174110
        ],
        "A": [
            161167944,
            161176736,
            161168168,
            161168440,
            161176515,
            161168925,
            161168213,
            161168654,
            161187609,
            161168766,
            161168663,
            161168483,
            161168047,
            161169513,
            161168007,
            161168296,
            161173279,
            161168814,
            161167994
        ]
    },
    "name": "D. River Locks",
    "statement": "Recently in Divanovo, a huge river locks system was built. There are now\r\nn locks, the i-th of them has the volume of v_i liters, so that it can\r\ncontain any amount of water between 0 and v_i liters. Each lock has a\r\npipe attached to it. When the pipe is open, 1 liter of water enters the\r\nlock every second.The locks system is built in a way to immediately\r\ntransfer all water exceeding the volume of the lock i to the lock i + 1.\r\nIf the lock i + 1 is also full, water will be transferred further. Water\r\nexceeding the volume of the last lock pours out to the river. Note that\r\nthe volume of the i-th lock may be greater than the volume of the i +\r\n1-th lock.To make all locks work, you need to completely fill each one\r\nof them. The mayor of Divanovo is interested in q independent queries.\r\nFor each query, suppose that initially all locks are empty and all pipes\r\nare closed. Then, some pipes are opened simultaneously. For the j-th\r\nquery the mayor asks you to calculate the minimum number of pipes to\r\nopen so that all locks are filled no later than after t_j seconds.Please\r\nhelp the mayor to solve this tricky problem and answer his queries.\r\n",
    "solutions": [
        "/*\n\n_/      _/       _/_/_/      _/      _/    _/           _/_/_/_/_/\n _/    _/      _/      _/     _/    _/     _/           _/\n  _/  _/      _/               _/  _/      _/           _/\n   _/_/       _/                 _/        _/           _/_/_/_/\n  _/  _/      _/                 _/        _/           _/\n _/    _/      _/      _/        _/        _/           _/\n_/      _/       _/_/_/          _/        _/_/_/_/_/   _/_/_/_/_/\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\nusing namespace std;\ninline int read()\n{\n\tint x = 0, w = 0; char ch = getchar();\n\twhile(!isdigit(ch)) {w |= ch == '-'; ch = getchar();}\n\twhile(isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\treturn w ? -x : x;\n}\nint a[200005];\nvoid solve()\n{\n\tint n = read();\n\tll sum = 0, lim = 0;\n\tru(i, 1, n)\n\t{\n\t\ta[i] = read();\n\t\tsum += a[i];\n\t\tlim = max(lim, (sum + i - 1) / i);\n\t}\n\tint q = read();\n\twhile(q--)\n\t{\n\t\tint t = read();\n\t\tif(t < lim) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", (sum + t - 1) / t);\n\t}\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. River Locks.json",
    "editorial_link": "https://codeforces.com//blog/entry/103978",
    "editorial": "To begin with, we note that it makes sense to open only some pipe\r\nprefix, because we need to fill all the locks, and more left pipes\r\naffect the total volume of the baths, which is obviously beneficial.\r\nLetâs enumerate how many pipes we will open, namely which prefix of\r\npipes we will open and calculate - how long it will take to fill the\r\nfirst locks if the first pipes are open. Letâs introduce an auxiliary\r\narray - the sum of the capacities of the gateways on the prefix . Then .\r\nLetâs see why this is so. We need all gateways on prefix to be filled,\r\nand also that the -th gateway be filled. Note that if the -th gateway\r\ndoes not have time to fill up in the time , then it will fill up in the\r\ntime (filling will occur at the time , but since in the condition we are\r\nasked about integer times, we can round up and not use real arithmetic),\r\nit turns out when the required amount of water is poured into all the\r\nlocks in total from all pipes. Now knowing for all open we can similarly\r\ncalculate when all n gateways are full. For this will be . It is also\r\nobvious that when an additional pipe is opened, the time will not\r\nincrease, therefore we can do a bin search by time and find out the\r\nanswer for the desired request. If the request is less than the minimum\r\nfilling time for the locks (when all pipes are open), then you need to\r\nprint . Total running time O().\r\n",
    "hint": []
}