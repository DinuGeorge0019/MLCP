{
    "link": "https://codeforces.com//contest/574/problem/D",
    "problemId": "34318",
    "problem_idx": "D",
    "shortId": "574D",
    "contest_number": "574",
    "problem_submissions": {
        "E": [
            12777654,
            12761905,
            12761141,
            12767794,
            12812186,
            12765590,
            12765583,
            12795832
        ],
        "D": [
            12753243,
            12754709,
            12749273,
            12752316,
            12751860,
            34986711,
            12751794,
            12753633,
            12752636,
            12753482,
            12752444,
            12753915,
            12754683,
            12753066,
            12754887,
            12755381,
            12754991,
            12754068,
            12756274,
            12755316,
            12755471
        ],
        "C": [
            12751208,
            12750732,
            12747796,
            12748107,
            12749130,
            34986465,
            12750242,
            12746917,
            12765952,
            12749775,
            12747265,
            12751486,
            12748422,
            12748315,
            12751012,
            12748270,
            12746927,
            12748796,
            12751828,
            12748701,
            12751210,
            12751267
        ],
        "B": [
            12749719,
            12749612,
            12747301,
            12747302,
            12748361,
            34986352,
            12748979,
            12749853,
            23873486,
            12748845,
            12751204,
            12749303,
            12751151,
            12749688,
            12749272,
            12749406,
            12751674,
            12752041,
            12750218,
            12747923,
            12747922,
            12748657
        ],
        "A": [
            12746925,
            12747156,
            12746306,
            12746196,
            12746305,
            34986203,
            34986199,
            12746356,
            12747131,
            12746281,
            12748351,
            12747087,
            12746932,
            12747573,
            12747386,
            12747413,
            12748055,
            12746903,
            12747183,
            12746649,
            12749265,
            12747493
        ]
    },
    "name": "D. Bear and Blocks",
    "statement": "Limak is a little bear who loves to play. Today he is playing by\r\ndestroying block towers. He built towers in a row. The -th tower is made\r\nof identical blocks. For clarification see picture for the first\r\nsample.Limak will repeat the following operation till everything is\r\ndestroyed.Block is called internal if it has all four neighbors, i.e. it\r\nhas each side (top, left, down and right) adjacent to other block or to\r\nthe floor. Otherwise, block is boundary. In one operation Limak destroys\r\nall boundary blocks. His paws are very fast and he destroys all those\r\nblocks at the same time.Limak is ready to start. You task is to count\r\nhow many operations will it take him to destroy all towers.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vpi> vvpi;\n\nint main(){\n  int n;\n  cin>>n;\n  int k[n];\n  for(int i = 0;i < n;++i) cin>>k[i];\n  for(int i = 0;i < n;++i){\n    k[i] = min(k[i],i+1);\n    if(i > 0) k[i] = min(k[i],k[i-1]+1);\n  }\n  for(int i = n-1;i >= 0;--i){\n    k[i] = min(k[i],n-i);\n    if(i < n-1) k[i] = min(k[i],k[i+1]+1);\n  }\n  int m = 0;\n  for(int i = 0;i < n;++i) m = max(m,k[i]);\n  cout<<m<<endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "math",
        "shortest paths"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bear and Blocks.json",
    "editorial_link": "https://codeforces.com//blog/entry/20040",
    "editorial": "In one operation the highest block in each tower disappears. So do all\r\nblocks above heights of neighbour towers. And all other blocks remain.\r\nIt means that in one operation all heights change according to formula\r\nwhere . By using this formula two times we get height after two\r\noperations: and so on. From now I will omit part to make it easier to\r\nread. After operations we get where for and is defined similarly.\r\nbecomes zero when or becomes zero. And becomes zero when we will find\r\nthis value for all . If you are now lost in this editorial, try to draw\r\nsome test and analyze my formulas with it. For each we are looking for .\r\nWe can iterate over from left to right keeping some variable : We should\r\nto the same for and take for each . Then final answer is maximum over\r\nanswers for . Code Div1C Bear and Drawing Let\u00e2\u0080\u0099s consider a tree already\r\ndrawn on a strip of paper. Let\u00e2\u0080\u0099s take first vertex on the left and last\r\nvertex on the right (in case of two vertices with the same , we choose\r\nany of them). There is a path between them. Let\u00e2\u0080\u0099s forget about vertices\r\nnot on this path. A path divides a strip into 1D regions. What can be\r\nadded to the main path? Only simple paths attached to it with one edge.\r\nSo it can be one of the following structures Y-letter or Line: Note that\r\nY-letter can have long legs but its central part can have only one edge.\r\nHow to check if given tree is a path + Y-letters + Lines? First, let\u00e2\u0080\u0099s\r\nmove from each leaf till we have vertex with degree at least , marking\r\nvertices as deleted. We don\u00e2\u0080\u0099t mark last vertex (that with degree at\r\nleast ) as deleted but we increase his number of legs. Finally, for each\r\nnot-deleted vertex we count his not-deleted neighbours for which\r\notherwise this neighbour is start of Line or Y-letter. Each vertex on\r\nthe main path can have at most two neighbours that also belong to the\r\nmain path. There can be more neighbours but they must be in Lines or\r\nY-letters that\u00e2\u0080\u0099s why we didn\u00e2\u0080\u0099t count them. So answer is \"No\" iff for\r\nsome vertex we counted more than two neighbours. Code\r\n"
}