{"link": "https://codeforces.com//contest/237/problem/E", "problemId": "2050", "problem_idx": "E", "shortId": "237E", "contest_number": "237", "problem_submissions": {"D": [2433036, 2432295, 2433500, 2432355, 2433903, 2433329, 2434102, 2434333, 2432248, 2432915, 2696259, 2434308], "E": [2431587, 2432589, 2431675, 2431055, 2432864, 2432954, 2431021, 2430681, 2431544, 2429287, 2431020, 2434055, 2432007, 2431656, 2432219, 2432671, 2432758], "C": [2430148, 2430407, 2429504, 2429737, 2429937, 2428700, 2428982, 2428966, 2427820, 2428219, 2429089, 2428238, 2428941, 2428553, 2429636, 2429650], "B": [2429161, 2428110, 2430688, 2429293, 2429097, 2430858, 2428364, 2428379, 2429868, 2430294, 2429444, 2430807, 2429497, 2429431, 2430215, 2428764, 2429093], "A": [2427471, 2426382, 2427215, 2426994, 2428604, 2426466, 2426659, 2426416, 2427387, 2426339, 2427186, 2426639, 2432021, 2427667, 2426349, 2427479]}, "name": "E. Build String", "statement": "You desperately need to build some string . For that you\u2019ve got more\r\nstrings . To build string , you are allowed to perform exactly ( is the\r\nlength of string ) operations on these strings. Each operation looks\r\nlike that: choose any non-empty string from strings ; choose an\r\narbitrary character from the chosen string and write it on a piece of\r\npaper; remove the chosen character from the chosen string. Note that\r\nafter you perform the described operation, the total number of\r\ncharacters in strings decreases by 1. We are assumed to build string ,\r\nif the characters, written on the piece of paper, in the order of\r\nperformed operations form string .There are other limitations, though.\r\nFor each string you know number the maximum number of characters you are\r\nallowed to delete from string . You also know that each operation that\r\nresults in deleting a character from string , costs rubles. That is, an\r\noperation on string is the cheapest (it costs ruble), and the operation\r\non string is the most expensive one (it costs rubles).Your task is to\r\ncount the minimum amount of money (in rubles) you will need to build\r\nstring by the given rules. Consider the cost of building string to be\r\nthe sum of prices of the operations you use.\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <memory.h>\n#include <cstring>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define down(i,b,a) for(int i=b;i>=a;i--)\n#define foredge(e,x) for(edge *e = x->first;e;e = e->next)\ntypedef long long ll;\nconst int maxn = 300,maxm = 30*maxn,geps = 1,inf = 0x3fffffff;\nconst int maxV = maxn+geps,maxE = maxm;\nstruct Graph{\n    struct point;struct edge;\n    struct point{\n        edge *first,*enow;\n        int path;bool inq;\n    }points[maxV+geps];\n    struct edge{\n        edge *next,*opp;\n        point *to;\n        int c,w;\n    }edges[maxE*2+geps];int edgenum;\n    point *st,*ed;int V;\n    void initialize(int _V,int _st,int _ed){\n        V = _V,st = points+_st,ed = points+_ed;edgenum = -1;\n        rep(i,1,V) points[i].first = 0;\n    }void addedge(point *x,point *y,int c,int w){\n        edge *e = edges+(++edgenum);\n        e->to = y,e->c = c,e->w = w,e->next = x->first,x->first = e;\n    }void add(int _x,int _y,int c,int w){\n        point *x = points+_x,*y = points+_y;\n        addedge(x,y,c,w);addedge(y,x,0,-w);\n        edges[edgenum].opp = edges+edgenum-1,edges[edgenum-1].opp = edges+edgenum;\n    }\n    point *myque[maxV*maxV+geps];\n    bool spfa(){\n        int qhead = 0,qtail = -1;\n        rep(i,1,V) points[i].path = -inf,points[i].inq = false;\n        myque[++qtail] = ed,ed->path = 0,ed->inq = true;\n        while(qhead<=qtail){\n            point *now = myque[qhead++];now->inq = false;\n            foredge(e,now) if(e->opp->c>0 && now->path + e->w > e->to->path){\n                e->to->path = e->w + now->path,e->to->enow = e->opp;\n                if(!e->to->inq){\n                    myque[++qtail] = e->to,e->to->inq = true;\n                    if(myque[qhead]->path > myque[qtail]->path) swap(myque[qhead],myque[qtail]);\n                }\n            }\n        }return st->path > -inf;\n    }\n    int getflow(point *x,int cost,int lim,int &totcost){\n        if(x==ed) {totcost += lim*cost;return lim;}\n        int ret = 0;x->inq = true;\n        for(edge *e = x->enow;e;e = e->next) if(e->c>0 && !e->to->inq && x->path + e->w == e->to->path){\n            int k = getflow(e->to,cost + e->w,min(lim-ret,e->c),totcost);\n            ret+=k,e->c-=k,e->opp->c+=k;\n        }x->inq = false;return ret;\n    }\n    int costflow(){\n        int totcost = 0;\n        while(spfa())\n            getflow(st,0,inf,totcost);\n\t\tforedge(e,st) if(e->c!=0) return -1;\n        return totcost;\n    }\n}G;\nint cnt[maxn+geps][27],a[maxn+geps];\nint n;\nstring input;\nvoid getcnt(int ind){\n\tint len = input.size();\n\trep(i,0,len-1) cnt[ind][input[i]-'a'+1]++;\n}\nvoid Init(){\n\tint len;\n\tcin>>input;getcnt(0);\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t\tcin>>input>>a[i];\n\t\tgetcnt(i);\n\t}\n}\n\nvoid solve(){\n\tint st = 26+n+1,ed = 26+n+2;\n\tG.initialize(ed,st,ed);\n\trep(i,1,26) G.add(st,i,cnt[0][i],0);\n\trep(i,1,26) rep(j,1,n)\n\t\tG.add(i,26+j,cnt[j][i],0);\n\trep(j,1,n) G.add(26+j,ed,a[j],j);\n\tprintf(\"%d\\n\",G.costflow());\n}\n\nint main(){\n\tInit();\n\tsolve();\n\t//system(\"pause\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["flows", "graphs"], "dificulty": "2000", "interactive": false}