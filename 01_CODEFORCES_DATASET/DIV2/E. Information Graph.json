{"link": "https://codeforces.com//contest/466/problem/E", "problemId": "13621", "problem_idx": "E", "shortId": "466E", "contest_number": "466", "problem_submissions": {"E": [7763666, 7769585, 7768735, 7765359, 7770616, 7766927, 7769884, 7936642, 7936570, 7804886], "D": [7760155, 7763392, 7765904, 7759889, 7764966, 7764929, 7766580, 7764380, 7763942, 7761240, 7768596, 7764705, 7771255, 7771465, 7770057, 7768205, 7768615, 7771047], "C": [7757835, 7757048, 7761148, 7755629, 7761932, 7754727, 7758439, 7760456, 7753794, 7759346, 7760630, 7760707, 7767525, 7760730, 7766019, 7761785, 7755926, 7763063], "B": [7756023, 7760247, 7761532, 7779459, 7760026, 7758357, 7756812, 7758808, 7762686, 7763357, 7765778, 7757733, 7758154, 7761303, 7770307, 7779355, 7764832], "A": [7753709, 7753409, 7756375, 7767138, 7753599, 7759314, 7753051, 7754371, 7755884, 7753912, 7754692, 7753400, 7753875, 7756172, 7753401, 7753155, 7754269]}, "name": "E. Information Graph", "statement": "There are employees working in company \"X\" (let\u2019s number them from 1 to\r\nfor convenience). Initially the employees didn\u2019t have any relationships\r\namong each other. On each of next days one of the following events took\r\nplace: either employee became the boss of employee (at that, employee\r\ndidn\u2019t have a boss before); or employee gets a packet of documents and\r\nsigns them; then he gives the packet to his boss. The boss signs the\r\ndocuments and gives them to his boss and so on (the last person to sign\r\nthe documents sends them to the archive); or comes a request of type\r\n\"determine whether employee signs certain documents\". Your task is to\r\nwrite a program that will, given the events, answer the queries of the\r\ndescribed type. At that, it is guaranteed that throughout the whole\r\nworking time the company didn\u2019t have cyclic dependencies.\r\n", "solutions": ["#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define MAXN 200005\n#define MAXL 20\nusing namespace std ;\ntypedef long long LL ;\n\nint N, M, Q, P ;\nint fa[MAXN] ;\nint deep[MAXN], go[MAXN][MAXL] ;\nint q[MAXN][2] ;\nint st[MAXN], ed[MAXN] ;\nvector<int> son[MAXN] ;\n\nint find(int x)\n{\n\tif(fa[x] == x) return x ;\n\treturn fa[x] = find(fa[x]) ;\t\n}\n\nvoid Dfs(int x)\n{\n\tint i, tmp ;\n\tfor(i = 1; i <= 18; i ++)\n\t\tgo[x][i] = go[go[x][i-1]][i-1] ;\n\tfor(i = 0; i < son[x].size(); i ++)\n\t{\n\t\ttmp = son[x][i] ;\n\t\tdeep[tmp] = deep[x]+1 ;\n\t\tgo[tmp][0] = x ;\n\t\tDfs(tmp) ;\n\t}\n}\nint lca(int a, int b)\n{\n\tif(deep[a] < deep[b]) swap(a, b) ;\n\tint i ;\n\tfor(i = 18; i >= 0; i --)\n\t\tif(deep[a]-(1<<i) >= deep[b])\n\t\t\ta = go[a][i] ;\n\tif(a == b) return a ;\n\tfor(i = 18; i >= 0; i --)\n\t\tif(go[a][i] != go[b][i])\n\t\t\ta = go[a][i], b = go[b][i] ;\n\treturn go[a][0] ;\n}\n\nint main()\n{\n\tint i, j ;\n\tint type, fr, to ;\n\t//freopen(\"1.in\", \"r\", stdin) ;\n\tscanf(\"%d %d\", &N, &M) ;\n\tfor(i = 1; i <= N; i ++)\n\t\tfa[i] = i ;\n\tfor(i = 1; i <= M; i ++)\n\t{\t\t\n\t\tscanf(\"%d\", &type) ;\n\t\tif(type == 1)\n\t\t{\n\t\t\tscanf(\"%d %d\", &fr, &to) ;\n\t\t\tfa[fr] = to, son[to].push_back(fr) ;\n\t\t}\n\t\telse if(type == 2)\n\t\t{\n\t\t\tP ++ ;\n\t\t\tscanf(\"%d\", &fr) ;\n\t\t\tst[P] = fr, ed[P] = find(fr) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQ ++ ;\n\t\t\tscanf(\"%d %d\", &q[Q][0], &q[Q][1]) ;\n\t\t}\n\t}\n\tfor(i = 1; i <= N; i ++)\n\t\tif(fa[i] == i) Dfs(i) ; \n\tfor(i = 1; i <= Q; i ++)\n\t{\n\t\tfr = q[i][0], to = st[q[i][1]] ;\n\t\tif(find(fr) != find(to) || lca(fr, to) != fr) \n\t\t\tprintf(\"NO\\n\") ;\n\t\telse if(deep[ed[q[i][1]]] > deep[fr])\n\t\t\tprintf(\"NO\\n\") ;\n\t\telse printf(\"YES\\n\") ;\n\t}\n\t//system(\"pause\") ;\n\treturn 0 ;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "graphs", "trees"], "dificulty": "2100", "interactive": false}