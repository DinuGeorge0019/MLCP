{"link": "https://codeforces.com//contest/365/problem/E", "problemId": "4040", "problem_idx": "E", "shortId": "365E", "contest_number": "365", "problem_submissions": {"D": [5161161, 5161283, 5157384, 5159815, 5158624, 5166469, 5178120, 5170486, 5160944, 5162347], "E": [5158821, 5170866, 5166357, 5165530, 5170983, 5164746], "B": [5151375, 5150963, 5158725, 5151658, 5151363, 5150980, 5151686, 5152429, 5152202, 5152201, 5151731, 5151488, 5151955, 5151063, 5151172, 5152598, 5152621, 5153442], "A": [5150339, 5150212, 5155091, 5150784, 5150472, 5150332, 5150310, 5150370, 5150233, 5150237, 5150565, 5150277, 5150807, 5150147, 5150215, 5150852, 5150793, 5151650], "C": [5155955, 5153146, 5157421, 5169511, 5154928, 5157528, 5157115, 5178157, 5156809, 5157646, 5156758, 5158767, 5156252, 5158740, 5158464, 5159088]}, "name": "E. Beautiful Set", "statement": "We\u2019ll call a set of positive integers beautiful if the following\r\ncondition fulfills: for any prime , if , then . In other words, if one\r\nnumber from the set is divisible by prime , then at least half of\r\nnumbers from the set is divisible by .Your task is to find any beautiful\r\nset, where the number of elements is equal to and each element doesn\u2019t\r\nexceed .\r\n", "solutions": ["#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\nint main(){\n\n    vector<int> nums;\n    int primes[15] = {2,3,5,7,11,13,17,19,23,29,31,37,41};\n    int used[15];\n    int n,i,j,temp,maxnum;\n    \n    memset(used,0,sizeof(used));\n    \n    scanf(\"%d\",&n);\n    maxnum=2*n*n;\n    \n    for( i=0 ; nums.size()<n ; i++ ){\n        nums.push_back(primes[i]);\n        for( j=0 ; j<nums.size() ; j++ ){\n            temp = nums[j]*primes[i];\n            if( temp<=maxnum ){\n                nums.push_back(temp);\n                used[i]++;\n            }\n        }\n        for( j=0 ; j<i ; j++ ){\n            used[j]+=used[i];   \n        }\n    }\n//  printf(\"%d\\n\",nums.size());\n//  for( j=0 ; j<i ; j++ ) printf(\"%d %d\\n\",primes[j],used[j]);\n    \n    sort(nums.begin(),nums.end());\n    for( i=nums.size()-n ; i<nums.size(); i ++ ){\n        printf(\"%d \",nums[i]);\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "number theory"], "dificulty": "2300", "interactive": false}