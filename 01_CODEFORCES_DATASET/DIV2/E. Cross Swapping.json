{
    "link": "https://codeforces.com//contest/1713/problem/E",
    "problemId": "1496888",
    "problem_idx": "E",
    "shortId": "1713E",
    "contest_number": "1713",
    "problem_submissions": {
        "E": [
            167272157,
            167275947,
            167255255,
            167280552,
            167277532,
            167281915,
            167286271,
            167295534,
            167291747,
            167285691,
            167290110,
            167289826,
            167289470,
            167288114,
            167295399,
            167293392,
            167292517,
            167288991,
            167292413,
            167295616
        ],
        "D": [
            167262934,
            167264444,
            167275938,
            167266127,
            167264903,
            167407463,
            167265717,
            167269013,
            167270800,
            167270098,
            167276487,
            167270258,
            167267741,
            167270166,
            167269509,
            167261936,
            167272225,
            167242557,
            167276667,
            167276744,
            167278772
        ],
        "C": [
            167243257,
            167245150,
            167266251,
            167242115,
            167251589,
            167255369,
            167252792,
            167244013,
            167251870,
            167263156,
            167253225,
            167255260,
            167254692,
            167249536,
            167241452,
            167251627,
            167255063,
            167259927,
            167257077,
            167247512
        ],
        "B": [
            167234078,
            167234734,
            167230438,
            167233192,
            167236986,
            167243546,
            167240561,
            167234594,
            167236064,
            167235869,
            167233392,
            167241862,
            167238018,
            167234909,
            167233503,
            167237613,
            167277571,
            167236123,
            167238131,
            167235652
        ],
        "A": [
            167230129,
            167230356,
            167231376,
            167230475,
            167230244,
            167239741,
            167232628,
            167231141,
            167231690,
            167230947,
            167230261,
            167230810,
            167230984,
            167230721,
            167230524,
            167233664,
            167273402,
            167231481,
            167232153,
            167230801
        ],
        "F": [
            167345887,
            167645094,
            167481610
        ]
    },
    "name": "E. Cross Swapping",
    "statement": "You are given a square matrix A of size n\r\ntimes n whose elements are integers. We will denote the element on the\r\nintersection of the i-th row and the j-th column as A_{i,j}.You can\r\nperform operations on the matrix. In each operation, you can choose an\r\ninteger k, then for each index i (1\r\nleq i\r\nleq n), swap A_{i, k} with A_{k, i}. Note that cell A_{k, k} remains\r\nunchanged.For example, for n = 4 and k = 3, this matrix will be\r\ntransformed like this: You can perform this operation any number of\r\ntimes. Find the lexicographically smallest matrix^\r\ndagger you can obtain after performing arbitrary number of\r\noperations.{}^\r\ndagger For two matrices A and B of size n\r\ntimes n, let a_{(i-1)\r\ncdot n + j} = A_{i,j} and b_{(i-1)\r\ncdot n + j} = B_{i,j}. Then, the matrix A is lexicographically smaller\r\nthan the matrix B when there exists an index i (1\r\nleq i\r\nleq n^2) such that a_i < b_i and for all indices j such that 1\r\nleq j < i, a_j = b_j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nstruct UF {\n\tvi e;\n\tUF(int n) : e(n, -1) {}\n\tbool sameSet(int a, int b) { return find(a) == find(b); }\n\tint size(int x) { return -e[find(x)]; }\n\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\tbool join(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a == b) return false;\n\t\tif (e[a] > e[b]) swap(a, b);\n\t\te[a] += e[b]; e[b] = a;\n\t\treturn true;\n\t}\n};\n\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vector<vi> arr(n, vi(n));\n    cin >> arr;\n\n    UF dsu(2*n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (arr[i][j] < arr[j][i]) {\n                // don't swap\n                if (!dsu.sameSet(2*i+1, 2*j)) {\n                    dsu.join(2*i, 2*j);\n                    dsu.join(2*i+1, 2*j+1);\n                }\n                else {\n                    swap(arr[i][j], arr[j][i]);\n                }\n            }\n            else if (arr[j][i] < arr[i][j]) {\n                // do swap\n                if (!dsu.sameSet(2*i, 2*j)) {\n                    dsu.join(2*i+1, 2*j);\n                    dsu.join(2*i, 2*j+1);\n                    swap(arr[i][j], arr[j][i]);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << arr[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return false;\n}\n\n\nint main() {\n    // freopen(\"input.in\", \"r\", stdin);\n    // freopen(\"input.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "data structures",
        "dsu",
        "greedy",
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cross Swapping.json",
    "editorial_link": "https://codeforces.com//blog/entry/105419",
    "editorial": "Let\u00e2\u0080\u0099s take a look at what the lexicographically smallest matrix is.\r\nLet\u00e2\u0080\u0099s call a cell that is in the intersection of row and column of the\r\nmatrix, and the integer written on that cell is . A cell of this matrix\r\nis called more significant than the another cell if and only if , or and\r\n. The problem asks us to find the smallest matrix so the best suitable\r\nway to solve this problem is to traverse through the most to the least\r\nsignificant cell of the matrix, then determine if the current cell can\r\nbe minimized or not. Suppose the current cell we are looking at is . If\r\nthen its position will not change after performing the operations. But\r\nif , there are exactly operations that swap with another cell, that is\r\nand . Both of these operations swap with the same cell . So the only way\r\nwe can minimize the value of is to try swapping it with (if and ) in\r\nsome way. As a result we have our constructive algorithm. Remind that\r\nfor each operation of the matrix (), there are states: it is being\r\nperformed and not being performed. Suppose we have traversed to the cell\r\n. If , ignore it. If then we try to make by deciding to swap or not to\r\nswap the cells. If , try to swap with by making operations and having\r\ndifferent states. And if then we should keep their positions unchanged\r\nby making operations and having the same state. Note that if , we do\r\nnothing. Let\u00e2\u0080\u0099s implement this algorithm using a simple DSU where the\r\nnode represents the operation . We define the value in such a way that,\r\nsuppose is the root of the node\u00e2\u0080\u0099s component, if operations and should\r\nhave the same state, or if operations and should have different states.\r\nDefine another function to union nodes and to the same component. Note\r\nthat and are always in the same component and . Thus, for the current\r\ncell , we want to swap it with by calling , or keep its position\r\nunchanged by calling . After constructing the graphs, the last thing to\r\ndo is to determine which operations should be performed. One way to do\r\nso is for each root of the components of the DSU, we perform the\r\noperation which this root represents for. Then for other nodes just\r\ncheck for the node and if it is true, the operation should be performed.\r\nWhen we have the list of the operations that need to be performed, we\r\ncan bruteforcely perform each operation from the list one by one and the\r\nfinal matrix will be the lexicographically smallest matrix. Time\r\ncomplexity: Solution\r\n"
}