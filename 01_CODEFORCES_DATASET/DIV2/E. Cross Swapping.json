{"link": "https://codeforces.com//contest/1713/problem/E", "problemId": "1496888", "problem_idx": "E", "shortId": "1713E", "contest_number": "1713", "problem_submissions": {"E": [167272157, 167275947, 167255255, 167280552, 167277532, 167281915, 167286271, 167295534, 167291747, 167285691, 167290110, 167289826, 167289470, 167288114, 167295399, 167293392, 167292517, 167288991, 167292413, 167295616], "D": [167262934, 167264444, 167275938, 167266127, 167264903, 167407463, 167265717, 167269013, 167270800, 167270098, 167276487, 167270258, 167267741, 167270166, 167269509, 167261936, 167272225, 167242557, 167276667, 167276744, 167278772], "C": [167243257, 167245150, 167266251, 167242115, 167251589, 167255369, 167252792, 167244013, 167251870, 167263156, 167253225, 167255260, 167254692, 167249536, 167241452, 167251627, 167255063, 167259927, 167257077, 167247512], "B": [167234078, 167234734, 167230438, 167233192, 167236986, 167243546, 167240561, 167234594, 167236064, 167235869, 167233392, 167241862, 167238018, 167234909, 167233503, 167237613, 167277571, 167236123, 167238131, 167235652], "A": [167230129, 167230356, 167231376, 167230475, 167230244, 167239741, 167232628, 167231141, 167231690, 167230947, 167230261, 167230810, 167230984, 167230721, 167230524, 167233664, 167273402, 167231481, 167232153, 167230801], "F": [167345887, 167645094, 167481610]}, "name": "E. Cross Swapping", "statement": "You are given a square matrix A of size n\r\ntimes n whose elements are integers. We will denote the element on the\r\nintersection of the i-th row and the j-th column as A_{i,j}.You can\r\nperform operations on the matrix. In each operation, you can choose an\r\ninteger k, then for each index i (1\r\nleq i\r\nleq n), swap A_{i, k} with A_{k, i}. Note that cell A_{k, k} remains\r\nunchanged.For example, for n = 4 and k = 3, this matrix will be\r\ntransformed like this: You can perform this operation any number of\r\ntimes. Find the lexicographically smallest matrix^\r\ndagger you can obtain after performing arbitrary number of\r\noperations.{}^\r\ndagger For two matrices A and B of size n\r\ntimes n, let a_{(i-1)\r\ncdot n + j} = A_{i,j} and b_{(i-1)\r\ncdot n + j} = B_{i,j}. Then, the matrix A is lexicographically smaller\r\nthan the matrix B when there exists an index i (1\r\nleq i\r\nleq n^2) such that a_i < b_i and for all indices j such that 1\r\nleq j < i, a_j = b_j.\r\n", "solutions": ["#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nstruct UF {\n\tvi e;\n\tUF(int n) : e(n, -1) {}\n\tbool sameSet(int a, int b) { return find(a) == find(b); }\n\tint size(int x) { return -e[find(x)]; }\n\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\tbool join(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a == b) return false;\n\t\tif (e[a] > e[b]) swap(a, b);\n\t\te[a] += e[b]; e[b] = a;\n\t\treturn true;\n\t}\n};\n\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vector<vi> arr(n, vi(n));\n    cin >> arr;\n\n    UF dsu(2*n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (arr[i][j] < arr[j][i]) {\n                // don't swap\n                if (!dsu.sameSet(2*i+1, 2*j)) {\n                    dsu.join(2*i, 2*j);\n                    dsu.join(2*i+1, 2*j+1);\n                }\n                else {\n                    swap(arr[i][j], arr[j][i]);\n                }\n            }\n            else if (arr[j][i] < arr[i][j]) {\n                // do swap\n                if (!dsu.sameSet(2*i, 2*j)) {\n                    dsu.join(2*i+1, 2*j);\n                    dsu.join(2*i, 2*j+1);\n                    swap(arr[i][j], arr[j][i]);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << arr[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return false;\n}\n\n\nint main() {\n    // freopen(\"input.in\", \"r\", stdin);\n    // freopen(\"input.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}"], "input": "", "output": "", "tags": ["2-sat", "data structures", "dsu", "greedy", "matrices"], "dificulty": "2400", "interactive": false}