{
    "link": "https://codeforces.com//contest/1419/problem/D1",
    "problemId": "729810",
    "problem_idx": "D1",
    "shortId": "1419D1",
    "contest_number": "1419",
    "problem_submissions": {
        "F": [
            93295033,
            93295948,
            93577512,
            141950739,
            141949703,
            93333082
        ],
        "E": [
            93234753,
            93227212,
            93234200,
            93238693,
            93238493,
            93238433,
            93238275,
            93245697,
            93246537,
            93242848,
            93246826,
            93247065,
            93245207,
            93241549,
            93243538,
            93254913,
            93249479,
            93238516
        ],
        "D2": [
            93212522,
            93217506,
            93213686,
            93220590,
            93215812,
            93218918,
            93214966,
            93215328,
            93210409,
            93223664,
            93218002,
            93222549,
            93220767,
            93225667,
            93221756,
            93229039,
            93216049,
            93227118
        ],
        "D1": [
            93210697,
            93214622,
            93213970,
            93213840,
            93206345,
            93211719,
            93208773,
            93212321,
            93204619,
            93213170,
            93216390,
            93214097,
            93210302,
            93207013,
            93214684,
            93211970,
            93215865,
            93206978
        ],
        "C": [
            93207169,
            93210000,
            93209428,
            93210195,
            93217148,
            93208516,
            93207753,
            93214333,
            93218732,
            93213670,
            93211157,
            93218160,
            93211807,
            93211495,
            93209180,
            93205213,
            93217455
        ],
        "B": [
            93202581,
            93203801,
            93204920,
            93203314,
            93203851,
            93201764,
            93202768,
            93202454,
            93208579,
            93203844,
            93205640,
            93206433,
            93220603,
            93204341,
            93204189,
            93202311,
            93214207
        ],
        "A": [
            93200129,
            93200069,
            93200258,
            93200020,
            93200369,
            93204977,
            93200037,
            93200656,
            93201705,
            93200310,
            93200086,
            93201198,
            93200525,
            93199999,
            93201236,
            93200136,
            93200638
        ]
    },
    "name": "D1. Sage s Birthday  easy version ",
    "statement": "Today is Sageâ€™s birthday, and she will go shopping to buy ice spheres.\r\nAll n ice spheres are placed in a row and they are numbered from 1 to n\r\nfrom left to right. Each ice sphere has a positive integer price. In\r\nthis version all prices are different.An ice sphere is cheap if it costs\r\nstrictly less than two neighboring ice spheres: the nearest to the left\r\nand the nearest to the right. The leftmost and the rightmost ice spheres\r\nare not cheap. Sage will choose all cheap ice spheres and then buy only\r\nthem.You can visit the shop before Sage and reorder the ice spheres as\r\nyou wish. Find out the maximum number of ice spheres that Sage can buy,\r\nand show how the ice spheres should be reordered.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s\".in\", \"r\", stdin); freopen(s\".out\", \"w\", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, \"%d \", a[i]); fprintf(stderr, \"\\n\");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = '0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint n, a[MAXN], v, ans[MAXN];\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(\"pro\");\n    #endif\n    cin >> n;\n\tFor(i, 1, n) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tcout << (n - 1) / 2 << endl;\n\tFor(i, 1, n / 2)\n\t\tans[i * 2] = a[i];\n\tFor(i, n / 2 + 1, n)\n\t\tans[(i - n / 2) * 2 - 1] = a[i];\n\tFor(i, 1, n) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Sage s Birthday  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/82817",
    "editorial": "Let's learn how to check whether it's possible to buy x\n ice spheres. Let's sort the array a\n in the non-decreasing order and then take x\n smallest elements of it. We will suppose that these x\n ice spheres will be cheap. To make these ice spheres cheap, we need x+1\n ice spheres more, so let's take x+1\n most expensive ice spheres. Why it's always good to take x+1\n most expensive ice spheres? If we had an ice sphere with the price y\n and we took an ice sphere with price z?y\n the answer will not become worse. Now we know how to check whether it's possible to buy x\n ice spheres. If we can buy x\n ice spheres then it's also possible to buy x?1\n ice spheres. For that reason the binary search for the answer is working.",
    "hint": []
}