{"link": "https://codeforces.com//contest/1629/problem/C", "problemId": "1270552", "problem_idx": "C", "shortId": "1629C", "contest_number": "1629", "problem_submissions": {"E": [143691687, 143672752, 143687137, 143663655, 143674506, 143679445, 143862635, 143682492, 143680665, 143680424, 143685684, 143684891, 143753002, 143685619, 143692185, 143689230, 143685863, 143687115, 143695099, 143693974], "F2": [143688718, 143726329, 143690987], "F1": [143676123, 143697164, 143692998, 143741879, 143678223, 143750588, 143750365], "D": [143667461, 143661533, 143674891, 143656107, 143648676, 143665361, 143663909, 143668220, 143661278, 143662732, 143656926, 143668180, 143668746, 143665526, 143669234, 143667378, 143676861, 143663591, 143664123], "C": [143651046, 143647499, 143659885, 143651714, 143662268, 143651456, 143647120, 143654421, 143646086, 143650221, 143697555, 143656282, 143655178, 143644392, 143657665, 143654804, 143651022, 143650097, 143652583], "B": [143642034, 143637040, 143638720, 143651837, 143664772, 143638989, 143637268, 143641201, 143638312, 143634980, 143632383, 143644246, 143635339, 143635326, 143637617, 143639992, 143639371, 143640785, 143642627], "A": [143633916, 143631168, 143632391, 143651906, 143666062, 143631304, 143631044, 143630886, 143631218, 143630607, 143639841, 143633922, 143630487, 143630572, 143630653, 143631188, 143630505, 143635250, 143635282]}, "name": "C. Meximum Array", "statement": "Mihai has just learned about the MEX concept and since he liked it so\r\nmuch, he decided to use it right away.Given an array a of n non-negative\r\nintegers, Mihai wants to create that is formed in the following\r\nway:While a is not empty: Choose an integer k (1\r\nleq k\r\nleq |a|). Append the MEX of the first k numbers of the array a to the\r\nend of array b and erase them from the array a, shifting the positions\r\nof the remaining numbers in a. But, since Mihai loves big arrays as much\r\nas the MEX concept, he wants the new array b to be the . So, Mihai asks\r\nyou to tell him what the maximum array b that can be created by\r\nconstructing the array optimally is.An array x is lexicographically\r\ngreater than an array y if in the first position where x and y differ\r\nx_i > y_i or if |x| > |y| and y is a prefix of x (where |x| denotes the\r\nsize of the array x).The of a set of non-negative integers is the\r\nminimal non-negative integer such that it is not in the set. For\r\nexample, ({{1, 2, 3}}) = 0 and ({{0, 1, 2, 4, 5}}) = 3.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 998244353\nll read() {\n\tll x=0,f=1;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\nstruct Data {\n\tint a,b;\n\tbool operator <(const Data tmp) const {\n\t\treturn a<tmp.a;\n\t}\n}t[1010];\nint T;\nint n,k,l,r;\nint a[202020],ansa[202020];\nvector<int> vec[202020];\nint main() {\n\tT=read();\n\twhile(T--) {\n\t\tint ans=0;\n\t\tn=read();\n\t\tvec[0].clear();\n\t\tfor(int i=1;i<=n;i++) {a[i]=read();vec[i].clear();}\n\t\tfor(int i=1;i<=n;i++) {vec[a[i]].push_back(i);} \n\t\tfor(int i=0;i<=n;i++) vec[i].push_back(n+1);\n\t\tint tmp=0,end=1;\n\t\tfor(int l=1;l<=n;) {\n\t\t\tint t1=*lower_bound(vec[tmp].begin(),vec[tmp].end(),end),t2=*lower_bound(vec[tmp].begin(),vec[tmp].end(),l+1);\n\t\t\tif(t1!=t2){tmp++;continue;}\n\t\t\tif(t2-1==n) {\n\t\t\t\tansa[++ans]=tmp;\n\t\t\t\ttmp=0;\n\t\t\t\tend=l=l+1;\n\t\t\t}\n\t\t\telse l=t2;\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tfor (int i=1;i<=ans;i++) cout<<ansa[i]<<' ';\n\t\tcout<<endl;\n\t}\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "greedy", "math", "two pointers"], "dificulty": "1400", "interactive": false}