{
    "link": "https://codeforces.com//contest/1608/problem/F",
    "problemId": "1223928",
    "problem_idx": "F",
    "shortId": "1608F",
    "contest_number": "1608",
    "problem_submissions": {
        "G": [
            138775127
        ],
        "F": [
            138754387,
            138771178,
            138771063,
            138772062,
            138791656,
            138791262,
            138768315,
            138766868,
            157787859,
            164237887,
            237837030,
            237836998,
            237835750
        ],
        "E": [
            138739786,
            138742154,
            138749882,
            138750135,
            138747933,
            138773994,
            138772884,
            138751851,
            138752060,
            138750338,
            138775532,
            138760313,
            138774000,
            138762726,
            138757936,
            138757827,
            138764476,
            138758978,
            138759090,
            138760707,
            138762156,
            138756888
        ],
        "D": [
            138734567,
            138734532,
            138736194,
            138735000,
            138740009,
            138735872,
            138737965,
            138741407,
            138737384,
            138742340,
            138747991,
            138746601,
            138745994,
            138748332,
            138739363,
            138743644,
            138745225,
            138751720,
            138746081
        ],
        "C": [
            138730911,
            138728412,
            138732051,
            138729895,
            138733167,
            138732651,
            138732813,
            138735111,
            138729971,
            138736027,
            138735972,
            138737416,
            138733290,
            138734144,
            138732973,
            138735675,
            138739036,
            138733532,
            138737913
        ],
        "B": [
            138728496,
            138730558,
            138729168,
            138727806,
            138728454,
            138727786,
            138728495,
            138729879,
            138726790,
            138731838,
            138730784,
            138733303,
            138728802,
            138731138,
            138729760,
            138729468,
            138732919,
            138731528,
            138735209
        ],
        "A": [
            138720875,
            138721636,
            138720831,
            138720708,
            138721065,
            138720677,
            138722900,
            138720671,
            138720647,
            138720885,
            138721095,
            138720890,
            138720651,
            138720737,
            138720886,
            138721221,
            138721571,
            138720878,
            138720786
        ]
    },
    "name": "F. MEX counting",
    "statement": "For an array c of nonnegative integers, MEX(c) denotes the smallest\r\nnonnegative integer that doesn\u2019t appear in it. For example, MEX([0, 1,\r\n3]) = 2, MEX([42]) = 0.You are given integers n, k, and an array [b_1,\r\nb_2,\r\nldots, b_n].Find the number of arrays [a_1, a_2,\r\nldots, a_n], for which the following conditions hold:0\r\nle a_i\r\nle n for each i for each i from 1 to n.|MEX([a_1, a_2,\r\nldots, a_i]) - b_i|\r\nle k for each i from 1 to n.As this number can be very big, output it\r\nmodulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 \u306f verify \u3057\u3066\u306d\u3048\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nconst int nmax=2010;\nmint dp[2][nmax][nmax];\nint len[2][nmax];\nint cur,nx;\nvoid clear(){\n\tzero(dp[nx]);\n\tzero(len[nx]);\n}\nvoid add(int i,int j,mint v){\n\tdp[nx][i][j]+=v;\n\tchmax(len[nx][i],j+1);\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvc<pi> lr(n+1);\n\tlr[0]=pi(0,1);\n\trep(i,n){\n\t\tint b;cin>>b;\n\t\tlr[i+1]=pi(max(b-k,0),min(b+k,n)+1);\n\t}\n\trep(i,n)chmax(lr[i+1].a,lr[i].a);\n\tper(i,n)chmin(lr[i].b,lr[i+1].b);\n\trep(i,n+1)if(lr[i].a>=lr[i].b){\n\t\treturn print(0);\n\t}\n\tdmp(lr);\n\tnx=1;\n\trng(i,lr[n].a,lr[n].b)\n\t\tadd(i,1,1);\n\tswap(cur,nx);\n\tper(step,n){\n\t\tclear();\n\t\trng(i,max(lr[step+1].a,1),lr[step+1].b){\n\t\t\trep(j,len[cur][i]){\n\t\t\t\tadd(i-1,j+1,dp[cur][i][j]);\n\t\t\t}\n\t\t}\n\t\tgnr(i,lr[step].a+1,lr[step+1].b){\n\t\t\trep(j,len[nx][i]){\n\t\t\t\tadd(i-1,j,dp[nx][i][j]);\n\t\t\t\tadd(i-1,j+1,-dp[nx][i][j]);\n\t\t\t}\n\t\t}\n\t\trng(i,lr[step+1].a,lr[step+1].b){\n\t\t\trep(j,len[cur][i]){\n\t\t\t\tadd(i,j,dp[cur][i][j]*(n+1-j));\n\t\t\t}\n\t\t}\n\t\tswap(cur,nx);\n\t}\n\tmint ans=0;\n\trep(j,len[cur][0])\n\t\tans+=dp[cur][0][j];\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "implementation"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. MEX counting.json",
    "editorial_link": "https://codeforces.com//blog/entry/97782",
    "editorial": "Let\u00e2\u0080\u0099s count the number of ways to assign first elements in a way that:\r\nfor each from to .There are exactly distinct elements among , which are\r\nbigger then . Let\u00e2\u0080\u0099s call them .We don\u00e2\u0080\u0099t care about the exact values of\r\nelements, we care only about their positions and who of them is equal to\r\nwho. For example, arrays would all be equivalent. We care about the\r\nexact values of all other elements.We only need to consider at most\r\npossible values of for each . Now, let\u00e2\u0080\u0099s learn how to transition from to\r\n.Let\u00e2\u0080\u0099s say that now we are at state . Where can we transition after\r\nassigning ?There are two cases. doesn\u00e2\u0080\u0099t change.It happens when . Then,\r\nif is among those elements or is less than , the number of elements\r\nwon\u00e2\u0080\u0099t change. Otherwise, the number of elements increases by (but we\r\ndon\u00e2\u0080\u0099t care about its value other than it being bigger than ).So, we need\r\nto add to , and to . becomes .It happens only when , and all numbers\r\nfrom to appear among those elements. There are ways to choose their\r\npositions there, and all of them will stop being , so there will be only\r\nelements remaining.So, we have to add to for all valid .This already\r\ngives solution, as we have iterations and transitions on each of them.\r\nHowever, this TLEs. So, let\u00e2\u0080\u0099s try to optimize our transitions. We will\r\nprocess cases when doesn\u00e2\u0080\u0099t change as before, as it\u00e2\u0080\u0099s only transitions.\r\nSo consider only transitions where changes.Note that increases exactly\r\nby one in such transitions. Also note that we have to multiply by when\r\nnumber of elements previously was and divide by when the number of\r\nelements now becomes .Then let\u00e2\u0080\u0099s only consider states with some fixed\r\nfor now, then we have transitions of sort with coefficients . So, to\r\nfind what we have to add to , we have to find sum of over all valid ,\r\nand to divide this sum by . This is easy to do with prefix sums.So, the\r\nfinal complexity is .\r\n"
}