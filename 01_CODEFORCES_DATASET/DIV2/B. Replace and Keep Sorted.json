{
    "link": "https://codeforces.com//contest/1485/problem/B",
    "problemId": "893885",
    "problem_idx": "B",
    "shortId": "1485B",
    "contest_number": "1485",
    "problem_submissions": {
        "F": [
            107209277,
            107219103,
            108814340,
            107211258,
            107197599,
            107216697,
            107217119,
            107223985,
            107214681,
            107225337,
            107211172,
            107212087,
            107214541,
            107225911,
            107220634,
            107211306,
            107210013,
            107218638,
            107648531,
            107215873,
            107226560
        ],
        "E": [
            107206284,
            107213007,
            108814429,
            107225053,
            107217938,
            107209463,
            107222855,
            107215802,
            107226662,
            107217485,
            107225279,
            107225123,
            107220161,
            107219375,
            107225854,
            107230167,
            107219696,
            107215124
        ],
        "C": [
            107199370,
            107197518,
            107195894,
            107212349,
            107194668,
            107198452,
            107203154,
            107405885,
            107204141,
            107200897,
            107195457,
            107204332,
            107206480,
            107202401,
            107199135,
            107196987,
            107201461,
            107206165,
            107648559,
            107207854,
            107199515
        ],
        "D": [
            107198594,
            107202657,
            108814890,
            107201144,
            107221310,
            107222056,
            107207281,
            107209220,
            107207652,
            107242764,
            107209063,
            107227592,
            107218419,
            107224633,
            107210347,
            107214905,
            107204658,
            107199967,
            107648549,
            107199904,
            107235149
        ],
        "B": [
            107193807,
            107194488,
            107194267,
            107201652,
            107196319,
            107195681,
            107197432,
            107195701,
            107196325,
            107193269,
            107196934,
            107197687,
            107195885,
            107193973,
            107195238,
            107214292,
            107194216,
            107202326,
            107195370
        ],
        "A": [
            107192260,
            107192259,
            107192294,
            107199267,
            107192201,
            107192549,
            107194901,
            107192510,
            107192573,
            107192159,
            107193301,
            107195540,
            107193638,
            107192240,
            107193340,
            107196993,
            107192336,
            107193653,
            107192814
        ]
    },
    "name": "B. Replace and Keep Sorted",
    "statement": "Given a positive integer k, two arrays are called k-similar if: they are\r\n; they have the same length; all their elements are positive integers\r\nbetween 1 and k (inclusive); they differ in one position. You are given\r\nan integer k, a array a and q queries. For each query, you are given two\r\nintegers l_i\r\nleq r_i. Your task is to find how many arrays b exist, such that b is\r\nk-similar to array [a_{l_i},a_{l_i+1}\r\nldots,a_{r_i}].\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,a[100005],q,k;\nll s[100005];\nint main(){\n\tscanf(\"%d%d%d\",&n,&q,&k);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tfor(int i=2;i<n;++i)s[i]=a[i+1]-a[i-1]-2+s[i-1];\n\twhile(q--){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(l==r)printf(\"%d\\n\",k-1);\n\t\telse printf(\"%I64d\\n\",s[r-1]-s[l]+k-a[r-1]+a[l+1]-3);\n\t}\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Replace and Keep Sorted.json",
    "editorial_link": "https://codeforces.com//blog/entry/87470",
    "editorial": "SolutionLet\u00e2\u0080\u0099s consider each value from to . If , you can replace with\r\n(and you get -similar array). There are such values of . If , you can\r\nreplace with (and you get -similar array). There are such values of . If\r\n, and for all in , you can either replace the rightmost which is less\r\nthan , or the leftmost which is greater than (and you get -similar\r\narrays). There are such values of . If for some in , no -similar arrays\r\ncan be made. The total count is , which simplifies to .Complexity: .\r\n"
}