{
    "link": "https://codeforces.com//contest/1592/problem/F2",
    "problemId": "1129225",
    "problem_idx": "F2",
    "shortId": "1592F2",
    "contest_number": "1592",
    "problem_submissions": {
        "F2": [
            130713058,
            130745405,
            130752812,
            130700115,
            130719186,
            130720967,
            130722508,
            130857743,
            130747284
        ],
        "F1": [
            130708913,
            130716472,
            130712966,
            130690640,
            130721286,
            130704100,
            130714549,
            130712433,
            130713697,
            130851358,
            130725206,
            130716184
        ],
        "E": [
            130702698,
            130695073,
            130712585,
            130690161,
            130713929,
            130713176,
            130705621,
            130689937,
            130710720,
            130851028,
            130710139,
            130712353,
            130705313,
            130701661,
            130698871,
            130698929,
            130696498
        ],
        "D": [
            130686766,
            130712124,
            130687989,
            130703162,
            130719297,
            130699331,
            130692683,
            130699442,
            130699159,
            130850999,
            130702540,
            130701084,
            130699463,
            130712566,
            130716938,
            130713876,
            130700116
        ],
        "C": [
            130673756,
            130678234,
            130691078,
            130722241,
            130692718,
            130685086,
            130684627,
            130684454,
            130695547,
            130686901,
            130682234,
            130850976,
            130687343,
            130686079,
            130680261,
            130693322,
            130682408,
            130683213,
            130708723,
            130704235
        ],
        "B": [
            130668341,
            130668419,
            130669045,
            130704250,
            130680256,
            130671878,
            130678194,
            130668270,
            130665664,
            130670263,
            130668846,
            130676770,
            130673397,
            130708534,
            130677615,
            130673769,
            130685667,
            130666906
        ],
        "A": [
            130663321,
            130663779,
            130671236,
            130667562,
            130676197,
            130664558,
            130674304,
            130663697,
            130663364,
            130664358,
            130664439,
            130664164,
            130666634,
            130663540,
            130663720,
            130665536,
            130664639,
            130664321,
            130671799
        ]
    },
    "name": "F2. Alice and Recoloring 2",
    "statement": "Alice has a grid of size n\r\ntimes m, . The cell on the intersection of i-th row and j-th column is\r\ndenoted as (i, j). Alice can do the following operations with this\r\ngrid:Choose any subrectangle containing cell (1, 1), and flip the colors\r\nof all its cells. (Flipping means changing its color from white to black\r\nor from black to white). Choose any subrectangle containing cell (n, 1),\r\nand flip the colors of all its cells. Choose any subrectangle containing\r\ncell (1, m), and flip the colors of all its cells. Choose any\r\nsubrectangle containing cell (n, m), and flip the colors of all its\r\ncells. .Alice wants to obtain her favorite coloring with these\r\noperations. What\u2019s the smallest number of coins that she would have to\r\nspend? It can be shown that it\u2019s always possible to transform the\r\ninitial grid into any other.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,m;\nint sum,ans;\nint a[505][505],b[505][505];\nint mt[505],vis[505];\nbool dfs(int x)\n{\n\tif(vis[x])return 0;\n\tvis[x]=1;\n\tfor(int i=2;i<=m;i++)if(b[x][m+1]&&b[n+1][i]&&b[x][i]) \n\t{\n\t\tif(!mt[i]||dfs(mt[i]))\n\t\t{\n\t\t\tmt[i]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid solve()\n{\n\tcin>>n>>m;rep(i,n)rep(j,m){char c;cin>>c;a[i][j]=(c=='B');}\n\trep(i,n+1)rep(j,m+1)b[i][j]=a[i-1][j-1]^a[i-1][j]^a[i][j-1]^a[i][j];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i);\n\t}\n\tfor(int i=2;i<=m;i++) if(mt[i])\n\t{\n\t\tb[mt[i]][i]^=1;b[n+1][i]^=1;b[mt[i]][m+1]^=1;b[n+1][m+1]^=1;\n\t\tsum+=2;\n\t}\n\tfor(int i=2;i<=n+1;i++)for(int j=2;j<=m+1;j++) sum+=b[i][j];\n\tans=sum;\n\tif(b[n+1][m+1])\n\t{\n\t\tfor(int i=2;i<=n;i++)for(int j=2;j<=m;j++)\n\t\t{\n\t\t\tint tmp=sum-b[i][j]-b[i][m+1]-b[n+1][j]-b[n+1][m+1];\n\t\t\ttmp+=4-b[i][j]-b[i][m+1]-b[n+1][j]-b[n+1][m+1];\n\t\t\tans=min(ans,tmp+2); \n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "flows",
        "graph matchings",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Alice and Recoloring 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/95583",
    "editorial": "Everything from the editorial of the first part of the problem stays the\r\nsame, except one thing: now the second operation on the modified grid\r\ncosts only coins. Sadly, now it\u00e2\u0080\u0099s not true that it\u00e2\u0080\u0099s not optimal to use\r\nthe second operation more than once. Let\u00e2\u0080\u0099s denote the second operation\r\non by (meaning that we invert numbers at ). New claim is that it\u00e2\u0080\u0099s not\r\noptimal to make operations which have the same or the same . Indeed,\r\nsuppose that we made and . Then cells and haven\u00e2\u0080\u0099t changed, so we only\r\nflipped cells with cost of coins. We could have done this with\r\noperations of the first type.Another observation: it doesn\u00e2\u0080\u0099t make sense\r\nto make , unless all the cells are . Indeed, no other operation of this\r\ntype will affect any of these cells. If some cell here is , and we still\r\nmake in coins, then we will have to spend one additional coin on\r\nreverting it back to with the operation of the first type. Instead, you\r\ncould have just flipped other cells from with the operations of the\r\nfirst type in the same coins.How many such operations can we make then?\r\nLet\u00e2\u0080\u0099s build a bipartite graph, with parts of sizes and , and connect\r\nnode from the left part with node from the right part iff . Find the\r\nmaximum matching in this graph with your favorite algorithm (for\r\nexample, in with Hopcroft Karp), let its size be . Then, for each , we\r\ncan find the number of ones that will be left in the grid if we make\r\nexactly operations of the second type. Then the answer to the problem is\r\njust the minimum of over all .\r\n"
}