{"link": "https://codeforces.com//contest/1853/problem/F", "problemId": "2099144", "problem_idx": "F", "shortId": "1853F", "contest_number": "1853", "problem_submissions": {"E": [215240531, 215240313, 215246116, 215249458, 215251653, 215250635, 216838871, 215350430, 215284663, 215314853, 215261254], "D": [215214411, 215220885, 215224382, 215226640, 215227143, 215237178, 215219268, 215220212, 216838036, 215216388, 215222732, 215221541, 215222391, 215228057, 215226498, 215216178, 215232515, 215230797, 215230860, 215230625, 215227427], "C": [215208066, 215209029, 215218445, 215213557, 215221549, 215215979, 215208850, 215209462, 216838362, 215211675, 215212482, 215215977, 215215848, 215207971, 215220425, 215219406, 215210968, 215214808, 215215587, 215214690, 215214191], "B": [215201834, 215199354, 215203429, 215207887, 215208000, 215209486, 215199874, 215202601, 216837998, 215205609, 215206019, 215207012, 215203260, 215203474, 215206199, 215210556, 215204325, 215206260, 216063043, 216062841, 215207209, 215210173, 215204057], "A": [215192467, 215191692, 215193758, 215193193, 215193397, 215196782, 215192166, 215194407, 216837978, 215192246, 215196759, 215192559, 215192820, 215193114, 215192996, 215192748, 215192883, 215192440, 216062816, 215194635, 215194796, 215192776], "F": [225845923]}, "name": "F. Miriany and Matchstick", "statement": "Miriany\u2019s matchstick is a 2\r\ntimes n grid that needs to be filled with characters or . He has already\r\nfilled in the first row of the grid and would like you to fill in the\r\nsecond row. You must do so in a way such that the number of ^\r\ndagger is equal to k. If it is impossible, report so.^\r\ndagger An is a pair of cells (r_1, c_1) and (r_2, c_2) (1\r\nle r_1, r_2\r\nle 2, 1\r\nle c_1, c_2\r\nle n) such that |r_1 - r_2| + |c_1 - c_2| = 1 and the characters in\r\n(r_1, c_1) and (r_2, c_2) are different.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint n,k;\nchar a[N];\nstruct node {\n    int l,r,p;\n    friend node operator +(node a,node b) {\n        bool u=~a.p&&(a.p<b.l||a.p>b.r||a.p==b.p),v=~b.p&&(b.p<a.l||b.p>a.r||b.p==a.p);\n        if(max(a.l,b.l)<=min(a.r,b.r)+1) return {min(a.l,b.l),max(a.r,b.r),u?a.p:(v?b.p:-1)};\n        else return {min(a.l,b.l),max(a.r,b.r),min(a.r,b.r)+1};\n    }\n    friend node move(node x,int y) {return {x.l+y,x.r+y,~x.p?x.p+y:x.p};}\n    friend bool in(node x,int y) {return x.l<=y&&y<=x.r&&y!=x.p;}\n} f[N][2];\nint read() {\n    int x=0; char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if(c=='A'||c=='B') return c=='B';\n    for(;c>='0'&&c<='9';c=getchar()) x=x*10+c-48;\n    return x;\n}\nvoid print(int n,int c,int k) {\n    if(n==1) {putchar('A'+c); return ;}\n    if(in(move(f[n-1][c],a[n]!=c),k)) print(n-1,c,k-(a[n]!=c));\n    else if(in(move(move(f[n-1][!c],a[n]!=c),1),k)) print(n-1,!c,k-(a[n]!=c)-1);\n    putchar('A'+c);\n}\nvoid solve() {\n    n=read(); k=read();\n    for(int i=1;i<=n;i++) a[i]=read();\n    for(int i=2;i<=n;i++) if(a[i]^a[i-1]) k--;\n    for(int i=1;i<=n;i++) for(int j=0;j<2;j++) f[i][j]={0,0,0};\n    f[1][a[1]]={0,0,-1}; f[1][!a[1]]={1,1,-1};\n    for(int i=2;i<=n;i++) {\n        f[i][0]=move(f[i-1][0],a[i])+move(move(f[i-1][1],a[i]),1);\n        f[i][1]=move(move(f[i-1][0],!a[i]),1)+move(f[i-1][1],!a[i]);\n    }\n    if(in(f[n][0],k)) puts(\"YES\"),print(n,0,k),puts(\"\");\n    else if(in(f[n][1],k)) puts(\"YES\"),print(n,1,k),puts(\"\");\n    else puts(\"NO\");\n}\nint main() {\n    for(int T=read();T--;) solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy"], "dificulty": "2800", "interactive": false}