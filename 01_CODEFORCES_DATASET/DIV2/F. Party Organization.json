{"link": "https://codeforces.com//contest/1600/problem/F", "problemId": "1136955", "problem_idx": "F", "shortId": "1600F", "contest_number": "1600", "problem_submissions": {"D": [131326791, 131319774, 131349265, 131313616, 131318416, 131323729], "F": [131320345, 131329426, 131350388], "E": [131316574, 131313861, 131305576, 131310151, 131314773], "I": [131312786, 131309903, 131307758, 131305198, 131310781], "A": [131307398], "J": [131302886, 131305362, 131303377, 131303391, 131305512], "B": [], "C": []}, "name": "F. Party Organization", "statement": "On the great island of Baltia, there live N people, numbered from 1 to\r\nN. There are exactly M pairs of people that are friends with each other.\r\nThe people of Baltia want to organize a successful party, but they have\r\nvery strict rules on what a party is and when the party is successful.\r\nOn the island of Baltia, a party is a gathering of exactly 5 people. The\r\nparty is considered to be successful if either all the people at the\r\nparty are friends with each other (so that they can all talk to each\r\nother without having to worry about talking to someone they are not\r\nfriends with) or no two people at the party are friends with each other\r\n(so that everyone can just be on their phones without anyone else\r\nbothering them). Please help the people of Baltia organize a successful\r\nparty or tell them that it\u2019s impossible to do so.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for (int i = a; i <= b; i++)\n#define FORD(i,a,b) for (int i = a; i >= b; i--)\n\n///// DEBUG TEMPLATE /////\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n///// DEBUG TEMPLATE /////\n\n///// MODNUM TEMPLATE /////\ntemplate <int MOD_> struct modnum {\n  static constexpr int MOD = MOD_;\n  static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n  using ll = long long;\n\n  int v;\n\n  static int minv(int a, int m) {\n    a %= m;\n    assert(a);\n    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n  }\n\npublic:\n\n  modnum() : v(0) {}\n  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n  explicit operator int() const { return v; }\n  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n  modnum inv() const {\n    modnum res;\n    res.v = minv(v, MOD);\n    return res;\n  }\n  friend modnum inv(const modnum& m) { return m.inv(); }\n  modnum neg() const {\n    modnum res;\n    res.v = v ? MOD-v : 0;\n    return res;\n  }\n  friend modnum neg(const modnum& m) { return m.neg(); }\n\n  modnum operator- () const {\n    return neg();\n  }\n  modnum operator+ () const {\n    return modnum(*this);\n  }\n\n  modnum& operator ++ () {\n    v ++;\n    if (v == MOD) v = 0;\n    return *this;\n  }\n  modnum& operator -- () {\n    if (v == 0) v = MOD;\n    v --;\n    return *this;\n  }\n  modnum& operator += (const modnum& o) {\n    v += o.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  modnum& operator -= (const modnum& o) {\n    v -= o.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  modnum& operator *= (const modnum& o) {\n    v = int(ll(v) * ll(o.v) % MOD);\n    return *this;\n  }\n  modnum& operator /= (const modnum& o) {\n    return *this *= o.inv();\n  }\n\n  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n  assert(b >= 0);\n  T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9 + 13)>;\n///// MODNUM TEMPLATE /////\n\nint n, m;\nvector<set<int>> adj;\nvector<int> friends;\nvector<int> priorityList;\n\nint randi() {\n  return rand() % 1000 * 1000 + rand() % 1000;\n}\n\nvoid bf(int i) {\n  if (i == 5) {\n    REP(j, 5) cout << friends[j] << \" \";\n    exit(0);\n  }\n  int last = friends[i - 1];\n  for (int u: adj[last]) if (u > last && adj[u].size() >= 4) {\n    bool ok = true;\n    REP(j, i) if (!adj[u].count(friends[j])) {\n      ok = false; break;\n    }\n    if (ok) {\n      friends.push_back(u);\n      bf(i + 1);\n      friends.pop_back();\n    }\n  }\n}\n\nvoid bff(int i) {\n  if (i == 5) {\n    REP(j, 5) cout << friends[j] << \" \";\n    exit(0);\n  }\n  int last = friends[i - 1];\n  FOR(u, last + 1, n) if (adj[u].size() + 4 <= n) {\n    bool ok = true;\n    REP(j, i) if (adj[u].count(friends[j])) {\n      ok = false; break;\n    }\n    if (ok) {\n      friends.push_back(u);\n      bff(i + 1);\n      friends.pop_back();\n    }\n  }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> m;\n    adj.assign(n + 1, set<int>());\n    REP(i, m) {\n      int u, v;\n      cin >> u >> v;\n      adj[u].insert(v);\n      adj[v].insert(u);\n    }\n\n    FOR(i, 1, n) priorityList.push_back(i);\n    sort(priorityList.begin(), priorityList.end(), [&](const int i, const int j) {\n      if (adj[i].size() != adj[j].size()) {\n        return adj[i].size() > adj[j].size();\n      } else {\n        return i < j;\n      }\n    });\n\n    FOR(i, 1, n) if (adj[i].size() >= 4) {\n      friends.clear();\n      friends.push_back(i);\n      bf(1);\n    }\n\n    FOR(i, 1, n) if (adj[i].size() + 4 <= n) {\n      friends.clear();\n      friends.push_back(i);\n      bff(1);\n    }\n\n    // FOR(times, 1, 1000000) {\n    //   friends.clear();\n    //   FOR(i, 1, 5) friends.push_back(randi() % n + 1);\n    //   sort(friends.begin(), friends.end());\n    //   bool ok = true;\n    //   FOR(i, 0, 4) if (friends[i] == friends[i + 1]) {\n    //     ok = false;\n    //   }\n    //   FOR(i, 0, 4) {\n    //     FOR(j, i + 1, 4) {\n    //       int u = friends[i];\n    //       int v = friends[j];\n    //       if (adj[u].count(v)) {\n    //         ok = false;\n    //         break;\n    //       }\n    //     }\n    //     if (!ok) break;\n    //   }\n    //   if (ok) {\n    //     for (int u: friends) cout << u << \" \";\n    //     exit(0);        \n    //   }\n    // }\n\n    cout << -1 << endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "math", "probabilities"], "dificulty": "2300", "interactive": false}