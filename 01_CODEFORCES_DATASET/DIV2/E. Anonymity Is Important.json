{
    "link": "https://codeforces.com//contest/1642/problem/E",
    "problemId": "1306242",
    "problem_idx": "E",
    "shortId": "1642E",
    "contest_number": "1642",
    "problem_submissions": {
        "E": [
            147461190,
            147448894,
            147463582,
            147629005,
            147463721,
            147465007,
            147464536,
            147464772,
            154238571,
            147442248,
            147468697,
            147546721,
            147530401
        ],
        "D": [
            147438364,
            147485650,
            147449537,
            147450562,
            147452894,
            147455461,
            147452625,
            147459786,
            147436803,
            147442745,
            147526042,
            147444306,
            147445760,
            147446955,
            147445886,
            147445039,
            147443394,
            147443106,
            147445514,
            147441961
        ],
        "B": [
            147422743,
            147420129,
            147417727,
            147418273,
            147417851,
            147419235,
            147432654,
            147420007,
            147417444,
            147417393,
            147418769,
            147419164,
            147418158,
            147418261,
            147419265,
            147416406,
            147420612,
            147425669,
            147421032,
            147423752
        ],
        "C": [
            147419008,
            147423535,
            147421085,
            147425938,
            147438330,
            147422534,
            147436627,
            147425010,
            147420010,
            147419556,
            147423431,
            147424779,
            147424498,
            147421790,
            147424573,
            147422658,
            147423818,
            147428109,
            147426206,
            147427103
        ],
        "A": [
            147415594,
            147416949,
            147415861,
            147433429,
            147415090,
            147426989,
            147415984,
            147416265,
            147415834,
            147415031,
            147415872,
            147416127,
            147415441,
            147414768,
            147415249,
            147414961,
            147417533,
            147420604,
            147417311,
            147415231
        ],
        "F": [
            147464749,
            147653708,
            147464855,
            147521397
        ]
    },
    "name": "E. Anonymity Is Important",
    "statement": "In the work of a doctor, it is important to maintain the anonymity of\r\nclients and the results of tests. The test results are sent to everyone\r\npersonally by email, but people are very impatient and they want to know\r\nthe results right away.That’s why in the testing lab \"De-vitro\" doctors\r\ncame up with an experimental way to report the results. Let’s assume\r\nthat n people took the tests in the order of the queue. Then the chief\r\ndoctor Sam can make several statements, in each telling if there is a\r\nsick person among the people in the queue from l-th to r-th (inclusive),\r\nfor some values l and r.During the process, Sam will check how well this\r\nscheme works and will be interested in whether it is possible to find\r\nout the test result of i-th person from the information he announced.\r\nAnd if it can be done, then is that patient sick or not.Help Sam to test\r\nhis scheme.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define inline __attribute((always_inline))\n\n#define cmax(x,y) x=max(x,y)\n#define cmin(x,y) x=min(x,y)\n#define eb emplace_back\n#define MP make_pair\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int,int> Pair;\n\ninline ll read(){\n\tll x=0,c; bool f=0;\n\tfor (;(c=getchar())<'0'||c>'9';f|=c=='-');\n\tfor (;c>='0'&&c<='9';c=getchar()) x=x*10+c-48;\n\treturn f?-x:x;\n}\n\n#define N 300005\n\nint n,q;\n\nvoid init(){\n\tn=read(),q=read();\n}\n\nint t[N<<2];\n\nvoid pushup(int i){\n\tt[i]=t[i<<1]+t[i<<1|1];\n}\n\n\nvoid pushdown(int i){\n\tif (t[i]==0) t[i<<1|1]=t[i<<1]=0;\n}\n\nvoid build(int l,int r,int i){\n\tif (l==r) return t[i]=1,void();\n\tint mid=l+r>>1;\n\tbuild(l,mid,i<<1);\n\tbuild(mid+1,r,i<<1|1);\n\tpushup(i);\n}\n\nvoid modify(int l,int r,int i,int x,int y){\n\tif (x<=l&&r<=y) return t[i]=0,void();\n\tpushdown(i);\n\tif (t[i]==0) return;\n\tint mid=l+r>>1;\n\tif (x<=mid) modify(l,mid,i<<1,x,y);\n\tif (mid+1<=y) modify(mid+1,r,i<<1|1,x,y);\n\tpushup(i);\n}\n\nint query(int l,int r,int i,int x){\n\tif (r<=x) return t[i];\n\tpushdown(i);\n\tif (t[i]==0) return 0;\n\tint mid=l+r>>1;\n\tint ans=query(l,mid,i<<1,x);\n\tif (mid+1<=x) ans+=query(mid+1,r,i<<1|1,x);\n\treturn ans;\n}\n\nint get(int i){\n\tif (i==1) return query(1,n,1,1);\n\treturn query(1,n,1,i)-query(1,n,1,i-1);\n}\n\nset<pair<int,int>> s;\nint c[N];\n\nvoid solve(){\n\tbuild(1,n,1);\n\tfor (int i=1;i<=n;i++) c[i]=0;\n\ts.clear();\n\ts.insert(MP(n+1,n+1));\n\tfor (;q--;){\n\t\tint t=read();\n\t\tif (t==0){\n\t\t\tint l=read(),r=read(),p=read();\n\t\t\tif (p==0){\n\t\t\t\tmodify(1,n,1,l,r);\n\t\t\t}else{\n\t\t\t\tif (c[l]){\n\t\t\t\t\tr=min(c[l],r);\n\t\t\t\t\ts.erase(MP(l,c[l]));\n\t\t\t\t}\n\t\t\t\ts.insert(MP(l,r));\n\t\t\t\tc[l]=r;\n\t\t\t\tauto p=s.find(MP(l,r)),z=p;\n\t\t\t\t++z;\n\t\t\t\twhile (z!=s.end()){\n\t\t\t\t\tif ((*z).se<=(*p).se) s.erase(p),p=z,++z;else break;\n\t\t\t\t}\n\t\t\t\twhile (p!=s.begin()){\n\t\t\t\t\tz=p;\n\t\t\t\t\t--z;\n\t\t\t\t\tif ((*z).se>=(*p).se) s.erase(z);else break;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint x=read();\n\t\t\tif (get(x)==0){\n\t\t\t\tputs(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint now=query(1,n,1,x),l=x,r=x;\n\t\t\tif (now==1) l=1;else{\n\t\t\t\tint u=1,v=x;\n\t\t\t\twhile (u<v){\n\t\t\t\t\tint mid=u+v>>1;\n\t\t\t\t\tif (query(1,n,1,mid)==now-1) v=mid;else u=mid+1;\n\t\t\t\t}\n\t\t\t\tl=u+1;\n\t\t\t}\n\t\t\tint u=x,v=n;\n\t\t\twhile (u<v){\n\t\t\t\tint mid=(u+v>>1)+1;\n\t\t\t\tif (query(1,n,1,mid)==now) u=mid;else v=mid-1;\n\t\t\t}\n\t\t\tr=u;\n\t\t\tauto p=*s.lower_bound(MP(l,l));\n\t\t\tif (p.se<=r) puts(\"YES\");else puts(\"N/A\");\n\t\t}\n\t}\n}\n\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint cas=1;\n\tfor (;cas--;){\n\t\t//printf(\"Case #%d: \",v);\n\t\tinit();\n\t\tsolve();\n\t\t//puts(\"!!!\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Anonymity Is Important.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "If -th person is not ill, the following query exists: , such that .\r\nOtherwise, the personâs status is either unknown or they are ill.If -th\r\nperson is ill, the following query exists:, such that , and every person\r\nsuch that are not ill. If there is such person that they are not ill,\r\nand . In this case, it is impossible to determine if -th person is ill\r\nor not.Letâs maintain the indices of the people who might be ill using .\r\nWhen we get a query , we can find the first possible ill person with an\r\nindex of at least using , after that, we need to delete this person from\r\nour set, find the next one and do the same thing until we find the first\r\nindex greater than . This works in . If a person is not in the set, he\r\nis totally healthy. Otherwise, we can use a segment tree to store such\r\nindex that there is a query and store it in the -th slot of our segment\r\ntree. We can update it when we get a new query. When we understand that\r\nthe -th person might be ill, we can find the first elements to the left\r\n() and to the right () of , which might be ill using our set. The -th\r\nperson is ill when the minimal element on segment is .The solution works\r\nin .\r\n",
    "hint": []
}