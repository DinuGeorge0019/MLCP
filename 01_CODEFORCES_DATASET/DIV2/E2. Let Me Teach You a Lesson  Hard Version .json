{
    "link": "https://codeforces.com//contest/1995/problem/E2",
    "problemId": "2772830",
    "problem_idx": "E2",
    "shortId": "1995E2",
    "contest_number": "1995",
    "problem_submissions": {
        "D": [
            272131872,
            272130569,
            272133863,
            272134415,
            272137449,
            272131543,
            272154573,
            272151706,
            272151276,
            272141813,
            272139057,
            272151246,
            272151986,
            272153217,
            272157571,
            272148679,
            272149814,
            272486180,
            272157625
        ],
        "C": [
            272114157,
            272113319,
            272111654,
            272121111,
            272111819,
            272119019,
            272113803,
            272118860,
            272116736,
            272123439,
            272121989,
            272122933,
            272112629,
            272120005,
            272111612,
            272116249,
            272108377,
            272486053,
            272120187
        ],
        "B2": [
            272102449,
            272103267,
            272100652,
            272099671,
            272128930,
            272108225,
            272104913,
            272104116,
            272101309,
            272106328,
            272112408,
            272104562,
            272129604,
            272109901,
            272102807,
            272107257,
            272115397,
            272485973,
            272104395
        ],
        "B1": [
            272096864,
            272101887,
            272104047,
            272103720,
            272094726,
            272108617,
            272105391,
            272104979,
            272103341,
            272103459,
            272111706,
            272103650,
            272098283,
            272103066,
            272101216,
            272107954,
            272116416,
            272485941,
            272098022
        ],
        "A": [
            272090620,
            272090574,
            272092410,
            272090882,
            272090527,
            272090716,
            272091404,
            272090846,
            272090748,
            272091332,
            272090661,
            272091173,
            272091300,
            272090978,
            272091057,
            272091479,
            272092003,
            272485907,
            272092660
        ],
        "E1": [
            272173791,
            272497229,
            272245140
        ],
        "E2": [
            272497185,
            272274307
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131851",
    "editorial": "Solution(Read the hints.) Assign a boolean matrix to each of the desks.\r\nRows correspond to the first knight at the desk (two rows for each of\r\nthe events \"the knight was swapped\" / \"the knight was not swapped\"),\r\ncolumns correspond to the second one. The value in the intersection is\r\ntrue if under current restrictions (minimum and maximum) both events can\r\nhappen, i.e. the result on the desk is between minimum and maximum.What\r\nis a (boolean) multiplication of matrices from to ? AnswerThe matrix\r\nwhere the rows correspond to the knight and the columns correspond to\r\nthe knight .To determine whether it\u00e2\u0080\u0099s possible to swap the knights under\r\ncurrent restrictions you can just multiply all the matrices and check if\r\nthere are ones on the main diagonal. Now using two pointers and a\r\nsegment tree on these matrices you can solve the problem (basically,\r\nwhen you leave some option for a desk in the sorted array of options,\r\nyou change one of the values of this matrix from to , and vice versa).\r\n",
    "name": "E2. Let Me Teach You a Lesson  Hard Version ",
    "statement": "Arthur is giving a lesson to his famous 2 n knights. Like any other\r\nstudents, they\u2019re sitting at the desks in pairs, but out of habit in a\r\ncircle. The knight 2 i - 1 is sitting at the desk with the knight 2\r\ni.Each knight has , which can be measured by an integer. Let\u2019s denote\r\nthe intelligence of the i-th knight as a_i. Arthur wants the maximal\r\ndifference in total intelligence over all pairs of desks to be as small\r\nas possible. More formally, he wants to minimize\r\nmax\r\nlimits_{1\r\nle i\r\nle n} (a_{2 i - 1} + a_{2 i}) -\r\nmin\r\nlimits_{1\r\nle i\r\nle n} (a_{2 i - 1} + a_{2 i}).However, the Code of Chivalry only allows\r\nswapping the opposite knights in the circle, i.e., Arthur can\r\nsimultaneously perform a_i := a_{i + n}, a_{i + n} := a_i for any 1\r\nle i\r\nle n. Arthur can make any number of such swaps. What is the best result\r\nhe can achieve?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define file_in(x) (freopen(#x\".in\", \"r\", stdin))#define file_out(x) (freopen(#x\".out\", \"w\", stdout))#define ll long long#define vi vector#define pb push_back#define db double#define pr pair <int, int>#define mk make_pair#define fi first#define se second#define lb(x) (x & (-x))#define ls(p) (p << 1)#define rs(p) ((p << 1) | 1)\u00a0using namespace std;\u00a0char _c; bool _f; template <class T> void IN(T &x) {  _f = x = 0; while (_c = getchar(), !isdigit(_c)) {if (_c == '-') _f = 1;}  while (isdigit(_c)) {x = x * 10 + _c - '0', _c = getchar();} if (_f) x = -x;}\u00a0template <class T> void _write(T x) {  if (x < 0) return putchar('-'), _write(-x), void();  if (x > 9) _write(x / 10);  putchar('0' + x % 10);}template <class T> void write(T x) {_write(x), putchar('\\n');}template <class T> void write_s(T x) {_write(x), putchar(' ');}template <class first, class... rest> void write(first fir, rest... res) {  write_s(fir), write(res...);}\u00a0#define debug(...) (_debug(#__VA_ARGS__, __VA_ARGS__))template <class T> void _debug(const char *format, T x) {  cerr << format << \" = \" << x << endl;}template <class first, class... rest>void _debug(const char *format, first fir, rest... res) {  while (*format != ',') cerr << *format++;  cerr << \" = \" << fir << ',', _debug(format + 1, res...);}\u00a0bool START;\u00a0const int N = 2e5 + 5, inf = 2e9 + 5;\u00a0int t_c, n, a[N], b[N], tot;\u00a0struct mat {  bool a[2][2];\u00a0  void init() {a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0;}\u00a0  mat operator * (const mat & o) const {    mat b; b.init();    for (int i = 0; i < 2; ++i)      for (int j = 0; j < 2; ++j)\tfor (int k = 0; k < 2; ++k)\t  b.a[i][j] |= (a[i][k] & o.a[k][j]);    return b;  }};\u00a0namespace smt {  mat d[N << 2];\u00a0  void bld(int l, int r, int p) {    d[p].init();    if (l == r) return;    int mid = (l + r) >> 1; bld(l, mid, ls(p)), bld(mid + 1, r, rs(p));  }\u00a0  void psu(int p) {d[p] = d[ls(p)] * d[rs(p)];}\u00a0  void mdf(int l, int r, int ps, bool w, bool e, bool k, int p) {    if (l == r) return d[p].a[w][e] = k, void();    int mid = (l + r) >> 1;    return (ps <= mid) ? mdf(l, mid, ps, w, e, k, ls(p)) : mdf(mid + 1, r, ps, w, e, k, rs(p)), psu(p);  }\u00a0  bool chk() {return d[1].a[0][0] | d[1].a[1][1];}}\u00a0struct node {  int p, w, e, v;  bool operator < (const node & o) const {return v < o.v;}} f[N << 2];\u00a0using namespace smt;\u00a0bool END;\u00a0void sol() {  bld(1, n, 1);  int x = b[1];  for (int i = 2; i <= 2 * n; ++i) b[i - 1] = b[i];  b[2 * n] = x;  int len = 0;  for (int i = 1; i <= n; ++i) {    int a1 = (i > 1) ? b[2 * i - 2] : b[2 * n];    int a2 = b[2 * i - 1], a3 = b[2 * i];    int a4 = (i < n) ? b[2 * i + 1] : b[1];    f[++len] = (node) {i, 0, 0, a2 + a3};    f[++len] = (node) {i, 0, 1, a2 + a4};    f[++len] = (node) {i, 1, 0, a1 + a3};    f[++len] = (node) {i, 1, 1, a1 + a4};  }  sort(f + 1, f + 1 + len);  int ans = inf;  for (int i = 1, j = 0; i <= len; ++i) {    while (j < len && !chk()) ++j, mdf(1, n, f[j].p, f[j].w, f[j].e, 1, 1);    if (chk()) ans = min(ans, f[j].v - f[i].v);    mdf(1, n, f[i].p, f[i].w, f[i].e, 0, 1);  }  write(ans);}\u00a0signed main() {  IN(t_c);  while (t_c--) {    IN(n); for (int i = 1; i <= 2 * n; ++i) IN(a[i]);    if (n & 1) {      b[1] = a[1], b[2] = a[1 + n], tot = 2;      int x = 1 + n;      while (x != 2) {\tif (x & 1) x++, b[++tot] = a[x];\telse x--, b[++tot] = a[x];\tif (x > n) x -= n;\telse x += n;\tb[++tot] = a[x];      }      sol();    }    else {      int l = inf, r = 0;      for (int i = 1; i <= n; i += 2) {\tint b = max(a[i], a[i + n]), c = min(a[i], a[i + n]);\tint d = max(a[i + 1], a[i + n + 1]), e = min(a[i + 1], a[i + n + 1]);\tl = min(l, min(b + e, c + d)), r = max(r, max(b + e, c + d));      }      write(r - l);    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "matrices",
        "two pointers"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Let Me Teach You a Lesson  Hard Version .json"
}