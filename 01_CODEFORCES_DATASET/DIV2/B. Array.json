{
    "link": "https://codeforces.com//contest/224/problem/B",
    "problemId": "1792",
    "problem_idx": "B",
    "shortId": "224B",
    "contest_number": "224",
    "problem_submissions": {
        "E": [
            2198165,
            2196819,
            2198259,
            2236128,
            2197194,
            2200952,
            2199765,
            2195540,
            2194183,
            2196229
        ],
        "C": [
            2195830,
            2191477,
            2193694,
            2193617,
            2194313,
            2194223,
            2191815,
            2195143,
            2193986,
            2195829,
            2195362
        ],
        "D": [
            2194352,
            2195373,
            2196141,
            2197876,
            2197375,
            2196987,
            2196590,
            2197417,
            2196810,
            2194187
        ],
        "B": [
            2190018,
            2189879,
            2191189,
            2191665,
            2190694,
            2191086,
            2195134,
            2190875,
            2194168,
            2191594,
            2190136,
            2191734,
            2190832,
            2194600,
            2190752,
            2190993
        ],
        "A": [
            2189231,
            2189100,
            2189357,
            2190553,
            2189190,
            2189439,
            2189115,
            2189932,
            2190812,
            2189456,
            2189202,
            2189505,
            2195692,
            2189110,
            2189926,
            2189167
        ]
    },
    "name": "B. Array",
    "statement": "You\u2019ve got an array , consisting of integers: . Your task is to find a\r\nminimal by inclusion segment such, that among numbers there are exactly\r\ndistinct numbers.Segment ( are integers) of length , satisfying the\r\ngiven property, is called , if there is no segment satisfying the\r\nproperty and less then in length, such that . Note that the segment\r\ndoesn\u2019t have to be minimal in length among all segments, satisfying the\r\ngiven property.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#define Eo(x) {cerr << #x << \" = \" << (x) << endl;}\n#define E(x) {cerr << #x << \" = \" << (x) << ' ';}\n\nusing namespace std;\nmap<int,int> cnt;\nconst int N = 100005;\nint ar[N];\n\nint main(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i=0; i<n; ++i) scanf(\"%d\", ar+i);\n\n\tint l, r;\n\tfor (r = 0; r<n; ++r){\n\t\t++cnt[ar[r]];\n\t\tif (cnt.size() >= k) break;\n\t}\n\tif (cnt.size() < k){\n\t\tprintf(\"%d %d\\n\", -1, -1);\n\t\treturn 0;\n\t}\n\tfor (l = 0; l<r; ++l){\n\t\tif (cnt[ar[l]] == 1) break;\n\t\t--cnt[ar[l]];\n\t}\n\tprintf(\"%d %d\\n\", l+1, r+1);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/5301",
    "editorial": "You were given an array a consisting of n integers. Its elements ai were positive and not greater than 105 for each 1???i???n. Also you were given positive integer k. You had to find minimal by inclusion segment [l,?r] such that there were exactly k different numbers among al,?...,?ar. The definition of the \"minimal by inclusion\" you can read in the statement.\n\nLet us make a new array cnt. In the beginning its element cnti is equal to number of occurencies of number i in array a. It is possible to make this array because elements of a are not very large. Amount of nonzero elements in cnt is equal to amount of different elements in a. There is no solution if this number is less then k.\n\nIf it is not true, we have to find the answer segment [l,?r]. In the beginning let [l,?r]?=?[1,?n]. We decrease its right end r by 1 until amount of different elements on the segment [l,?r] is less than k. We can keep the amount of different numbers in following way: we decrease cntar by 1 if we delete element number r. Then we have to decrease current number of different elements by 1 if cntar becomes zero. After this we return the last deleted element back to the segment in order to make amount of different elements equal to k. Then we have to do the same with the left end l, but we have not to decrease but to increase its value by 1 on each step. Finally, we get a segment [l,?r]. The amount of different numbers on it is equal to k and on every its subsegment is less than k. Therefore, this segment is an answer. The complexity is O(n)."
}