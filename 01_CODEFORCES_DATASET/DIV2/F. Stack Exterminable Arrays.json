{
    "link": "https://codeforces.com//contest/1241/problem/F",
    "problemId": "432405",
    "problem_idx": "F",
    "shortId": "1241F",
    "contest_number": "1241",
    "problem_submissions": {
        "E": [
            62017723,
            62019409,
            62018200,
            62020890,
            62022198,
            62018184,
            62021033,
            62020810,
            62022366,
            62022018,
            62022186,
            62021471,
            62021371,
            62020672,
            62022999,
            62022406,
            62016955,
            62022463,
            62022706,
            62018405,
            62014119,
            62012786,
            62036219,
            62036172
        ],
        "D": [
            62010080,
            62011089,
            62012710,
            62015665,
            62013685,
            62015042,
            62017074,
            62014653,
            62016089,
            62016067,
            62016695,
            62018252,
            62004607,
            62017834,
            62022945,
            62013525,
            62016654,
            62010850
        ],
        "C": [
            62004603,
            62005338,
            62005296,
            62004772,
            62006686,
            62010899,
            62008239,
            62007637,
            62010590,
            62007408,
            62005219,
            62010085,
            62022342,
            62013089,
            62017420,
            62007106,
            62020505,
            62005890
        ],
        "B": [
            61994170,
            61994162,
            61996183,
            61997011,
            61995689,
            61998479,
            61995514,
            62010312,
            62000592,
            62001007,
            61994716,
            62003432,
            62019757,
            61994257,
            62008550,
            61993346,
            61995543
        ],
        "A": [
            61990704,
            61991494,
            61990694,
            61992108,
            61991136,
            61994902,
            61991699,
            62016279,
            61993098,
            61990610,
            61990976,
            61990737,
            62017926,
            61990827,
            62001039,
            61991341,
            61991174
        ],
        "F": [
            62114157,
            62033465,
            62031915
        ]
    },
    "name": "F. Stack Exterminable Arrays",
    "statement": "Let’s look at the following process: initially you have an empty stack\r\nand an array s of the length l. You are trying to push array elements to\r\nthe stack in the order s_1, s_2, s_3,\r\ndots s_{l}. Moreover, if the stack is empty or the element at the top of\r\nthis stack is not equal to the current element, then you just push the\r\ncurrent element to the top of the stack. Otherwise, you don’t push the\r\ncurrent element to the stack and, moreover, pop the top element of the\r\nstack. If after this process the stack remains empty, the array s is\r\nconsidered .There are samples of stack exterminable arrays: [1, 1]; [2,\r\n1, 1, 2]; [1, 1, 2, 2]; [1, 3, 3, 1, 2, 2]; [3, 1, 3, 3, 1, 3]; [3, 3,\r\n3, 3, 3, 3]; [5, 1, 2, 2, 1, 4, 4, 5]; Let’s consider the changing of\r\nstack more details if s = [5, 1, 2, 2, 1, 4, 4, 5] (the top of stack is\r\nhighlighted). after pushing s_1 = 5 the stack turn into [\r\ntextbf{5}]; after pushing s_2 = 1 the stack turn into [5,\r\ntextbf{1}]; after pushing s_3 = 2 the stack turn into [5, 1,\r\ntextbf{2}]; after pushing s_4 = 2 the stack turn into [5,\r\ntextbf{1}]; after pushing s_5 = 1 the stack turn into [\r\ntextbf{5}]; after pushing s_6 = 4 the stack turn into [5,\r\ntextbf{4}]; after pushing s_7 = 4 the stack turn into [\r\ntextbf{5}]; after pushing s_8 = 5 the stack is empty. You are given an\r\narray a_1, a_2,\r\nldots, a_n. You have to calculate the number of its subarrays which are\r\nstack exterminable.Note, that you have to answer q independent queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define gc getchar()\n#define pc(x) putchar(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing namespace std;\ntypedef long long ll;\nconst ll b1 = 31, b2 = 131, m1 = 1e9+9, m2 = 1494318097;\nconst int MM = 3e5+5;\n\nint q, n, a, ptr;\nll h1[MM], h2[MM], ans;\nmap<pair<ll, ll>, ll> cnt;\nstack<int> st;\n\nint main(){\n    \n    scan(q);\n    \n    while(q--){\n        \n        while(!st.empty())\n            st.pop();\n        cnt.clear();\n        cnt[{0, 0}] = 1;\n        ptr = 1;\n        ans = 0;\n        \n        scan(n);\n        \n        while(n--){\n            scan(a);\n            if(!st.empty() && a == st.top()){\n                st.pop();\n                ptr--;\n            }\n            else{\n                st.push(a);\n                ptr++;\n                h1[ptr] = (h1[ptr-1]*b1 + a)%m1;\n                h2[ptr] = (h2[ptr-1]*b2 + a)%m2;\n            }\n            ans += cnt[{h1[ptr], h2[ptr]}]++;\n        }\n        \n        print(ans);\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Stack Exterminable Arrays.json",
    "editorial_link": "https://codeforces.com/blog/entry/70358",
    "editorial": "Let's understand how calculate the array nxt\n, such that nxtl\n is equal to the minimum index r>l\n such that subarray alr\n is stack exterminable. If there is no such index, then nxtl=?1\n.\n\nIf we calculate this array then we solve this task by simple dynamic programming.\n\nLet's calculate it in order nxtn,nxtn?1,,nxt1\n by dynamic programming. At first consider simple case. If ai=ai+1\n, then nxti=i+1\n. Otherwise we have to \"add\" the block ai+1anxti+1\n (of course, nxti+1\n should be not equal to ?1\n) and check that ai=a1+nxti+1\n. If this (ai=a1+nxti+1\n) also is not true, then you have to add a new block a1+nxti+1anxt1+nxti+1\n and check the condition ai=a1+nxt1+nxti+1\n. If this condition also is not try, then you have to add a new block and so on.\n\nIt is correct solution, but it can be too slowly. Let's understand, that we add blocks to ai\n until condition ai=a1+nxt\n is holds. Let's assume, that we have an array nxtX\n (this array contains a hashMaps, for example you can use map in C++), such that nxtXi,x\n is is equal to the minimum index r>l\n such that subarray alr\n is stack exterminable and x=ar+1\n. Then we can easily calculate the value nxti=nxtXi+1,ai+1\n. Remains to understand, how to calculate nxtXi\n. For this we just can make an assignment nxtXi=nxtXnxti+1\n. And then update nxtXi,anxti+1=nxti+1\n.\n\nBut I deceived you a little. We can't make an assignment nxtXi=nxtXnxti+1\n because it is to slow. Instead that you need to swap elements nxtXi\n and nxtXnxti+1\n, this can be done using the function swap\n in C++ or Java (time complexity of swap\n if O(1)\n).",
    "hint": []
}