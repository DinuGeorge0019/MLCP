{"link": "https://codeforces.com//contest/1493/problem/A", "problemId": "916228", "problem_idx": "A", "shortId": "1493A", "contest_number": "1493", "problem_submissions": {"E": [109300691, 109266485, 109271539, 109262971, 109276076, 109269136, 109397471, 109327948, 109273809, 109280460, 109407951, 109291144], "B": [109260545, 109239746, 109254991, 109270234, 109241243, 109242522, 109253609, 109252334, 109327832, 109233296, 109238405, 109249942, 109232284, 109235737, 109235442, 109237822, 109237430, 109234756, 109237333, 109236735], "C": [109257705, 109251136, 109251134, 109246054, 109250920, 109266513, 109273162, 109327814, 109245427, 109240048, 109234896, 109238348, 109245265, 109246216, 109245882, 109254906, 109244489, 109256285, 109246006], "F": [109251446, 109300451, 109300023, 109263743, 109278727, 109492473, 109395367, 109755119], "D": [109250583, 109257293, 109245697, 109282268, 109255131, 109236733, 109257985, 109245022, 109241096, 109327857, 109262894, 109249582, 109243883, 109253883, 109249816, 109255048, 109252679, 109247391, 109256541, 109248836, 109257345], "A": [109228407, 109230343, 109243099, 109232737, 109227629, 109231368, 109228074, 109228388, 109327785, 109227973, 109230330, 109252518, 109227990, 109230461, 109228220, 109228782, 109229679, 109227822, 109229042, 109229707]}, "name": "A. Anti-knapsack", "statement": "You are given two integers n and k. You are asked to choose maximum\r\nnumber of distinct integers from 1 to n so that there is no subset of\r\nchosen numbers with sum equal to k.A subset of a set is a set that can\r\nbe obtained from initial one by removing some (possibly all or none)\r\nelements of it.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,\"r\",stdin)\n#define Fout(s) freopen(s,\"w\",stdout)\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\n#define INF ((1<<30)-1)\n#define int long long\nconst int P=998244353; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\ninline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline void fprint(const vector<int> &f) {for(int i=0;i<f.size();i++) fprintf(stderr,\"%d \",f[i]); fprintf(stderr,\"\\n\");}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\nconst int MN=5e5+5;\nint n,a[MN],k;\n\nsigned main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"pro.in\",\"r\",stdin);\n\t\tfreopen(\"pro.out\",\"w\",stdout);\n\t#endif\n\tint T=read();\n\twhile(T--) {\n\t\tn=read(),k=read();\n\t\tvector<int>ans;\n\t\tfor(int i=n;i>k;i--) {\n\t\t\tans.push_back(i);\n\t\t}\n\t\tfor(int i=k-1;i>=0;i--) {\n\t\t\tif(i+i<k) break;\n\t\t\tans.push_back(i);\t\n\t\t}\n\t\tprintf(\"%d\\n\",(int)ans.size());\n\t\tfor(auto it:ans) {\n\t\t\tprintf(\"%d \",it);\t\n\t\t}\n\t\tprintf(\"\\n\");\n//\t\tFor(i,1,n) a[i]=read();\n\t\t\n\t}\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "800", "interactive": false}