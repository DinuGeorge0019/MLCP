{
    "link": "https://codeforces.com//contest/122/problem/E",
    "problemId": "640",
    "problem_idx": "E",
    "shortId": "122E",
    "contest_number": "122",
    "problem_submissions": {
        "E": [
            804119,
            810208,
            803742,
            804906,
            805053,
            805535,
            805395,
            806278,
            806048,
            805630,
            806062,
            806110,
            807439,
            805646,
            806935,
            805348,
            805292,
            807148,
            803308
        ],
        "D": [
            802482,
            810206,
            802395,
            802956,
            803158,
            802902,
            802962,
            803118,
            803510,
            803885,
            803728,
            803980,
            803776,
            806452,
            804671,
            807608,
            806313,
            807465,
            804059,
            807952
        ],
        "C": [
            800923,
            810203,
            801356,
            801235,
            801284,
            802077,
            801764,
            801779,
            801639,
            801891,
            801899,
            801697,
            801979,
            801645,
            801654,
            802889,
            808508,
            803366,
            802586,
            801728
        ],
        "B": [
            799762,
            810199,
            799636,
            800167,
            799922,
            800682,
            800298,
            799652,
            799602,
            800265,
            800137,
            800018,
            800096,
            799947,
            799741,
            801185,
            801074,
            799786,
            801520
        ],
        "A": [
            799077,
            810197,
            799191,
            799050,
            799146,
            799438,
            799389,
            799108,
            799052,
            799014,
            799373,
            799207,
            799220,
            799284,
            799168,
            799106,
            799481,
            799192,
            799054
        ]
    },
    "name": "E. Lucky Permutation",
    "statement": "One day Petya dreamt of a lexicographically -th permutation of integers\r\nfrom to . Determine how many lucky numbers in the permutation are\r\nlocated on the positions whose indexes are also lucky numbers.\r\n",
    "solutions": [
        "#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <string> vs;\ntypedef istringstream iss;\ntypedef ostringstream oss;\n\nconst int INF = (int) 1E9 + 5;\nconst ll LINF = (ll) 4E18 + 5;\n\nconst ld PI = acos(-1.0);\nconst ld E = 2.718281828459045L;\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define REPD(i, a) for (int i = ((a) - 1); i >= 0; i--)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); ++it)\n#define FITD(it, v) for (typeof((v).rbegin())it = (v).rbegin(); it != (v).rend(); ++it)\n\n#define VAR(a, b) typeof(b) a(b)\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SIZE(a) ((int)(a).size())\n\n#define EXIST(a, b) (find(ALL(a), (b)) != (a).end())\n#define SORT(x) sort(ALL(x))\n#define GSORT(x) sort(ALL(x), greater<typeof(*((x).begin()))>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n#define ENUM(v) FIT(it, (v)) cout << *it << \" \"; cout << endl\n\n#define PF push_front\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntemplate<typename T> T gcd(T a, T b) { return (b == 0) ? abs(a) : gcd(b, a % b); }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> inline T mod(T a, T b) { return (a % b + b) % b; }\ntemplate<typename T> inline T sqr(T x) { return x * x; }\n\ntemplate<typename T> inline string toString(const T& x) { oss os; os << x; return os.str(); }\ninline ll toInt(const string& s) { iss is(s); ll x; is >> x; return x; }\ninline ld toDouble(const string& s) { iss is(s); ld x; is >> x; return x; }\ninline string toLower(string s) { FIT(it, s) *it = tolower(*it); return s; }\ninline string toUpper(string s) { FIT(it, s) *it = toupper(*it); return s; }\n\nconst char DEBUG_PARAM[] = \"__LOCAL_TESTING\";\n\nconst char IN[] = \"_.in\";\nconst char OUT[] = \"_.out\";\n\ninline void init();\ninline void run();\n\nint ntest = 0, test;\n\nint main(int argc, char* argv[]) {\n\tif (argc > 1 && strcmp(argv[1], DEBUG_PARAM) == 0) {\n\t\tfreopen(IN, \"r\", stdin);\n\t\t//freopen(OUT, \"w\", stdout);\n\t}\n\tinit();\n\tif (ntest == 0) { puts(\"ntest = ?\"); return 0; }\n\tfor (test = 1; test <= ntest; test++) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\ninline void stop() {\n\tntest = test - 1;\n}\n\n/* IMPLEMENTATION */\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\nconst ld EPS = 1E-9;\nconst ll MODULE = 1000000007LL;\n\nvector<ll> v;\n\nvoid dfs(ll x) {\n\tif (x > INF * 10LL) {\n\t\treturn;\n\t}\n\tv.PB(x);\n\tdfs(x * 10 + 4);\n\tdfs(x * 10 + 7);\n}\n\ninline void init() {\n\tntest = 1;\n\tdfs(4LL), dfs(7LL);\n\tSORT(v);\n}\n\nint n, k;\n\nbool isLucky(int x) {\n\tstring s = toString(x);\n\tFIT(it, s) {\n\t\tif (*it != '4' && *it != '7') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint find(int x) {\n\tint cnt = 0;\n\tFIT(it, v) {\n\t\tif (*it <= x) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nbool check[15];\nll frac[15], tail[15];\n\ninline void run() {\n\tscanf(\"%d%d\\n\", &n, &k);\n\tll t = 1;\n\tint w = 0;\n\tFOR(i, 1, n) {\n\t\tt = t * i;\n\t\tif (t >= k) {\n\t\t\tw = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!w) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\n\tfrac[0] = 1;\n\tFOR(i, 1, w) {\n\t\tfrac[i] = frac[i - 1] * i;\n\t}\n\n\tvector<pii> u;\n\tSET(check, true);\n\tFOR(i, 1, w) {\n\t\tint j = 1;\n\t\twhile (1) {\n\t\t\twhile (!check[j]) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (k <= frac[w - i]) {\n\t\t\t\tcheck[j] = false;\n\t\t\t\tu.PB(MP(n - w + j, n - w + i));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tk -= frac[w - i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\tFIT(it, u) {\n\t\tif (isLucky(it->F) && isLucky(it->S)) {\n\t\t\tret++;\n\t\t}\n\t}\n\n\tint x = n - w;\n\tret += find(x);\n\n\tcout << ret << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Lucky Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/2956",
    "editorial": null
}