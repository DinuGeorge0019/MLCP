{
    "link": "https://codeforces.com//contest/1042/problem/D",
    "problemId": "220708",
    "problem_idx": "D",
    "shortId": "1042D",
    "contest_number": "1042",
    "problem_submissions": {
        "F": [
            42987714,
            42984651,
            42989319,
            42983649,
            42989168,
            42989334,
            42988495,
            42988621,
            42990991,
            42984782,
            42991318,
            42984734,
            42989762,
            42989508,
            42989199,
            42985445,
            42984262,
            42986731
        ],
        "A": [
            42984167,
            42973725,
            42974031,
            42973482,
            42973429,
            42973632,
            42973538,
            42974330,
            42975529,
            42973708,
            42993729,
            42975026,
            42986836,
            42989940,
            42973749,
            42992518,
            42973915,
            42973554,
            42973556,
            42973468
        ],
        "E": [
            42983656,
            42983448,
            42981915,
            42988922,
            42984518,
            42985483,
            42983668,
            42985621,
            42980250,
            42987926,
            42982614,
            42990994,
            42986527,
            42985364,
            42983020,
            42986197,
            42989170,
            42987817,
            42982499
        ],
        "C": [
            42982112,
            42977810,
            42976676,
            42978400,
            42979933,
            42981591,
            42978723,
            42979152,
            42981616,
            43020286,
            42983391,
            42977530,
            42987879,
            42980102,
            42982752,
            42979907,
            42979506,
            42982122,
            42993016,
            42980948,
            42977178
        ],
        "B": [
            42975906,
            42974331,
            42974910,
            42974847,
            42974321,
            42975176,
            42975023,
            42975453,
            42976952,
            42975043,
            42975357,
            42976939,
            42975515,
            42976516,
            42974965,
            42975963,
            42975276,
            42974792,
            42974885,
            42974787
        ],
        "D": [
            42975097,
            42975491,
            42978165,
            42980511,
            42976657,
            42978683,
            42980559,
            42982541,
            42983622,
            43020160,
            42982284,
            42979330,
            42979227,
            42983154,
            42978119,
            42977687,
            42982730,
            42983764,
            42980017,
            42976894,
            42978512
        ]
    },
    "name": "D. Petya and Array",
    "statement": "Petya has an array a consisting of n integers. He has learned partial\r\nsums recently, and now he can calculate the sum of elements on any\r\nsegment of the array really fast. The segment is a non-empty sequence of\r\nelements standing one next to another in the array.Now he wonders what\r\nis the number of segments in his array with the sum less than t. Help\r\nPetya to calculate this number.More formally, you are required to\r\ncalculate the number of pairs l, r (l\r\nle r) such that a_l + a_{l+1} +\r\ndots + a_{r-1} + a_r < t.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who’s Kobe? \n// Fisherman can’t stop us\n// Average ABCDE on a good day\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 400005;\nint N;\nll T;\nll A[MAXN];\nll pre[MAXN];\nmap<ll, int> mp;\nint BIT[MAXN];\n\nvoid add(int idx)\n{\n    for (; idx < MAXN; idx += idx&-idx)\n        BIT[idx]++;\n}\n\nint get(int idx)\n{\n    int ret = 0;\n    for (; idx > 0; idx -= idx&-idx)\n        ret += BIT[idx];\n    return ret;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n\n    cin >> N >> T;\n    mp[-T] = 1;\n    mp[0] = 1;\n    for (int i = 1; i <= N; i++)\n    {\n        cin >> A[i];\n        pre[i] = pre[i - 1] + A[i];\n        mp[pre[i] - T] = 1;\n        mp[pre[i]] = 1;\n    }\n    \n    int ind = 0;\n    for (map<ll, int>::iterator it = mp.begin(); it != mp.end(); it++)\n        it->second = ++ind;\n\n    ll ans = 0;\n    add(mp[0]);\n    for (int i = 1; i <= N; i++)\n    {\n        ans += i - get(mp[pre[i] - T]);\n        add(mp[pre[i]]);\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Petya and Array.json",
    "editorial_link": "https://codeforces.com/blog/entry/61891",
    "editorial": "Letâs reformulate the problem. Now the problem is to calculate the\r\ndifference between the prefix sums to the right border and to the left\r\nborder instead of the sum on the segment.Let , a .Then the answer to the\r\nproblem is . Itâs easy to see that the answer for the fixed is . We can\r\ncalculate this formula using some data structure which allows us to get\r\nthe number of elements less than given and set the value at some\r\nposition. For example, segment tree or BIT (Fenwick tree).\r\n",
    "hint": []
}