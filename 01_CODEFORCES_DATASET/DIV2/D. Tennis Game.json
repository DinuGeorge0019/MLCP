{
    "link": "https://codeforces.com//contest/496/problem/D",
    "problemId": "19579",
    "problem_idx": "D",
    "shortId": "496D",
    "contest_number": "496",
    "problem_submissions": {
        "D": [
            9176843,
            9169490,
            9172648,
            9169938,
            9173192,
            9179837,
            9174502,
            9174977,
            9172607,
            9170640,
            9175019,
            9174412,
            9173755,
            9175240,
            9175102,
            9175021,
            9194689,
            9175370
        ],
        "E": [
            9173226,
            9193133,
            9174734,
            14339417,
            9237849,
            9178765,
            9188533,
            9194680
        ],
        "C": [
            9169367,
            9166605,
            9167404,
            9165048,
            9168057,
            9167727,
            9166806,
            9167081,
            9169029,
            9167067,
            9167500,
            9168857,
            9168096,
            9168403,
            9167842,
            9167765,
            9194690,
            9167905
        ],
        "B": [
            9165977,
            9165371,
            9165516,
            9171586,
            9164457,
            9164520,
            9165537,
            9165229,
            9167890,
            9173609,
            9166677,
            9165999,
            9166755,
            9166602,
            9165952,
            9165871,
            9194688,
            9168604
        ],
        "A": [
            9164610,
            9164035,
            9164187,
            9170696,
            9163931,
            9163962,
            9163896,
            9164249,
            9166611,
            9174109,
            9164186,
            9164233,
            9164281,
            9163978,
            9164264,
            9163934,
            9194687,
            9165603
        ]
    },
    "name": "D. Tennis Game",
    "statement": "Petya and Gena love playing table tennis. A single match is played\r\naccording to the following rules: a match consists of multiple sets,\r\neach set consists of multiple serves. Each serve is won by one of the\r\nplayers, this player scores one point. As soon as one of the players\r\nscores points, he wins the set; then the next set starts and scores of\r\nboth players are being set to 0. As soon as one of the players wins the\r\ntotal of sets, he wins the match and the match is over. Here and are\r\nsome positive integer numbers.To spice it up, Petya and Gena choose new\r\nnumbers and before every match. Besides, for the sake of history they\r\nkeep a record of each match: that is, for each serve they write down the\r\nwinner. Serve winners are recorded in the chronological order. In a\r\nrecord the set is over as soon as one of the players scores points and\r\nthe match is over as soon as one of the players wins sets.Petya and Gena\r\nhave found a record of an old match. Unfortunately, the sequence of\r\nserves in the record isn’t divided into sets and numbers and for the\r\ngiven match are also lost. The players now wonder what values of and\r\nmight be. Can you determine all the possible options?\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n\twhile (1)\n\t{\n\t\ta = a % b;\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\tb = b % a;\n\n\t\tif (b == 0)\n\t\t\treturn a;\n\t}\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nint a1[1000 * 1000 + 100];\nint a2[1000 * 1000 + 100];\nint b1[1000 * 1000 + 100], b2[1000 * 1000 + 100];\nset<pair<int, int> > ans;\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"a.txt\", \"w\", stdout);\n\tint n;\n\tcin >> n;\n\tint b;\n\tfor (int i = 0; i < 1000 * 1000; i++)\n\t{\n\t\ta1[i] = inf;\n\t\ta2[i] = inf;\n\t}\n\tmemset(b1, 0, sizeof b1);\n\tmemset(b2, 0, sizeof b2);\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> b;\n\t\tif (b == 1)\n\t\t{\n\t\t\tx++;\n\t\t\ta1[x] = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty++;\n\t\t\ta2[y] = i;\n\t\t}\n\t\tb1[i] = x;\n\t\tb2[i] = y;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tbool cor = true;\n\t\tint p1 = 0, p2 = 0;\n\t\tint s1 = 0, s2 = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (a1[p1 + i] == inf && a2[p2 + i] == inf)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a1[p1 + i] < a2[p2 + i])\n\t\t\t{\n\t\t\t\ts1++;\n\t\t\t\tp1 += i;\n\t\t\t\tp2 = b2[a1[p1]];\n\t\t\t}\n\t\t\telse if (a1[p1 + i] > a2[p2 + i])\n\t\t\t{\n\t\t\t\ts2++;\n\t\t\t\tp2 += i;\n\t\t\t\tp1 = b1[a2[p2]];\n\t\t\t}\n\t\t}\n\t\tif (p1+p2==n)\n\t\t{\n\t\t\tif (s1 > s2 && b == 1)\n\t\t\t{\n\t\t\t\tans.insert(make_pair(s1, i));\n\t\t\t}\n\t\t\telse if (s1 < s2 && b == 2)\n\t\t\t{\n\t\t\t\tans.insert(make_pair(s2, i));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.size() << endl;\n\tint tmp = ans.size();\n\tfor (int i = 0; i < tmp; i++)\n\t{\n\t\tcout << ans.begin()->first << \" \" << ans.begin()->second << endl;\n\t\tans.erase(ans.begin());\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tennis Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/15208",
    "editorial": "Choose some ; now emulate how the match will go, ensure that the record\r\nis valid for this and by the way find the corresponding value of . Print\r\nall valid options for and . This solution works in time, which is not\r\ngood enough, but we will try to optimize it. Suppose the current set if\r\nfinished and we have processed serves by now. Let us process the next\r\nset as follows: find -th and -th after position . If -th occurs earlier,\r\nthen the first player wins the set, and the set concludes right after\r\nthe -th ; the other case is handled symmetrically. If the match is not\r\nover yet, and in the rest of the record there are no ones nor twos, then\r\nthe record is clearly invalid. This way, every single set in the record\r\ncan be processed in time using binary search, or time using precomputed\r\narrays of positions for each player. Now observe that for any a match of\r\nserves can not contain more than sets, as each set contains at least\r\nserves. If we sum up the upper limits for the number of sets for each ,\r\nwe obtain the total upper limit for the number of sets we may need to\r\nprocess: (which is the famous harmonic sum). Using one of the approaches\r\ndiscussed above, one obtains a solution with complexity of or ; each of\r\nthese solutions fits the limit nicely. Obviously, for every there is no\r\nmore than one valid choice for ; however, maybe a bit unexpected, for a\r\ngiven there may exist more than one valid choice of . The first test\r\nwhere this takes place is pretest 12. The statement requires that the\r\npairs are printed lexicographically ordered; it is possible to make a\r\nmistake here and print the pairs with equal by descending (if we fill\r\nthe array by increasing and then simply reverse the array). Challenge:\r\nwhile preparing this problem I discovered that itâs quite hard to find a\r\ntest such that the number of pairs in the answer is large; in the actual\r\ntests the maximal number is 128, which is the number of divisors of the\r\nnumber 83160. Can you beat this record? If you have a test with that has\r\nlarger number of pairs in the answer, feel free to brag in the comments;\r\nalso donât hesitate to share any insights on how one could bound the\r\nmaximal number analytically.\r\n",
    "hint": []
}