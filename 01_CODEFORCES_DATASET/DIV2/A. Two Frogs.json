{
    "link": "https://codeforces.com//contest/2055/problem/A",
    "problemId": "3141114",
    "problem_idx": "A",
    "shortId": "2055A",
    "contest_number": "2055",
    "problem_submissions": {
        "E": [
            300746486,
            300849536,
            300761124
        ],
        "D": [
            300696033,
            300705238,
            300701008,
            300702007,
            300702452,
            300703784,
            300699187,
            300704114,
            300709175,
            300707029,
            300707549,
            300710969,
            300708967,
            300711888,
            300708148,
            300708052,
            300708173,
            300705738
        ],
        "C": [
            300672652,
            300668358,
            300677522,
            300677196,
            300683675,
            300681011,
            300678376,
            300681393,
            300678777,
            300680600,
            300678839,
            300677980,
            300671004,
            300679220,
            300687159,
            300684321,
            300687531,
            300683543
        ],
        "B": [
            300657881,
            300656820,
            300666935,
            300663382,
            300655553,
            300662689,
            300671074,
            300665092,
            300657486,
            300665581,
            300668563,
            300655341,
            300661161,
            300658795,
            300659826,
            300665475,
            300658513,
            300662771
        ],
        "A": [
            300651053,
            300651601,
            300652364,
            300654430,
            300651022,
            300652195,
            300652888,
            300655299,
            300650941,
            300654319,
            300652932,
            300651006,
            300651149,
            300651992,
            300652147,
            300652006,
            300652172,
            300650990
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/138343",
    "editorial": "SolutionNotice that regardless of how the players move, the difference\r\nbetween the numbers of the lilypads the two players are standing on\r\nalways alternates even and odd, depending on the starting configuration.\r\nThen, the key observation is that exactly one player has the following\r\nwinning strategy: Walk towards the other player, and do not stop until\r\nthey are forced onto lilypad or . For instance, if Alice and Bob start\r\non lilypads with the same parity, Bob cannot stop Alice from advancing\r\ntowards him. This is because at the start of Alice’s turn, she will\r\nalways be able to move towards Bob due to their distance being even and\r\ntherefore at least , implying that there is a free lilypad for her to\r\njump to. This eventually forces Bob into one of the lilypads , causing\r\nhim to lose.In the case that they start on lilypads with different\r\nparity, analogous logic shows that Bob wins. Therefore, for each case,\r\nwe only need to check the parity of the lilypads for a constant time\r\nsolution.\r\n",
    "name": "A. Two Frogs",
    "statement": "There are n lilypads arranged in a row, numbered from 1 to n from left\r\nto right. Alice and Bob are frogs initially positioned on distinct\r\nlilypads, a and b, respectively. They take turns jumping, starting with\r\nAlice. During a frog’s turn, it can jump either one space to the left or\r\none space to the right, as long as the destination lilypad exists. For\r\nexample, on Alice’s first turn, she can jump to either lilypad a-1 or\r\na+1, provided these lilypads are within bounds. It is important to note\r\nthat each frog during its turn and cannot remain on the same\r\nlilypad.However, there are some restrictions: The two frogs cannot\r\noccupy the same lilypad. This means that Alice cannot jump to a lilypad\r\nthat Bob is currently occupying, and vice versa. If a frog cannot make a\r\nvalid jump on its turn, it loses the game. As a result, the other frog\r\nwins. Determine whether Alice can guarantee a win, assuming that both\r\nplayers play optimally. It can be proven that the game will end after a\r\nfinite number of moves if both players play optimally.\r\n",
    "solutions": [
        "#include <algorithm>#include <array>#include <bitset>#include <cassert>#include <chrono>#include <cmath>#include <complex>#include <cstring>#include <functional>#include <iomanip>#include <iostream>#include <map>#include <numeric>#include <queue>#include <random>#include <set>#include <vector>#include <climits>using namespace std;using ll=long long;using db=long double;using pi=pair<int,int>;using pl=pair<ll,ll>;using vi=vector<int>;using vl=vector<ll>;using vpi=vector<pi>;using vpl=vector<pl>;#define mp make_pair#define eb emplace_back#define pb push_back#define x first#define y second#define sz(x)int((x).size())#define bg(x) begin(x)#define all(x)(x).begin(),(x).end()#define rall(x) x.rbegin(), x.rend() #define rep(i,a,b)for(int i=(a);i<(b);i++)#define per(i,a,b)for(int i=(b)-1;i>=(a);i--)#define ft front()#define bk back()#define rsz resize#define ins insert#define each(a,x)for(auto&a:x)bool ckmin(auto&a,auto b){return b<a?a=b,1:0;}bool ckmax(auto&a,auto b){return b>a?a=b,1:0;}#ifdef LOCALtemplate<class A, class B>ostream&operator<<(ostream&o,pair<A,B>p){return o<<\"(\"<<p.x<<\", \"<<p.y<<\")\";}template<class A, class B, class C>ostream&operator<<(ostream&o,tuple<A,B,C>t){    return o<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\", \"<<\")\";}auto operator<<(auto&o,auto x)->decltype(x.end(),o){    o<<\"{\";int i=0;for(auto&e:x)o<<\",\"+!i++<<e;return o<<\"}\";}#define debug(X...)cerr<<\"[\"#X\"]: \",[](auto...$){((cerr<<$<<\"; \"),...)<<endl;}(X);#else#define debug(...){}#endif const pi MOVES[] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}}; // #include <ext/pb_ds/assoc_container.hpp>// #include <ext/pb_ds/tree_policy.hpp>// using namespace __gnu_pbds;// template<class T>// using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; template<int MOD, int RT> struct mint {    static const int mod = MOD;    static constexpr mint rt() { return RT; }    int v; explicit operator int() const { return v; }    mint() : v(0) {}    mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);        if (v < 0) v += MOD; }    bool operator==(const mint& o) const {        return v == o.v; }    friend bool operator!=(const mint& a, const mint& b) {         return !(a == b); }    friend bool operator<(const mint& a, const mint& b) {         return a.v < b.v; }     mint& operator+=(const mint& o) {         if ((v += o.v) >= MOD) v -= MOD;         return *this; }    mint& operator-=(const mint& o) {         if ((v -= o.v) < 0) v += MOD;         return *this; }    mint& operator*=(const mint& o) {         v = int((ll)v*o.v%MOD); return *this; }    mint& operator/=(const mint& o) { return (*this) *= inv(o); }    friend mint pow(mint a, ll p) {        mint ans = 1; assert(p >= 0);        for (; p; p /= 2, a *= a) if (p&1) ans *= a;        return ans; }    friend mint inv(const mint& a) { assert(a.v != 0);         return pow(a,MOD-2); }            mint operator-() const { return mint(-v); }    mint& operator++() { return *this += 1; }    mint& operator--() { return *this -= 1; }    friend mint operator+(mint a, const mint& b) { return a += b; }    friend mint operator-(mint a, const mint& b) { return a -= b; }    friend mint operator*(mint a, const mint& b) { return a *= b; }    friend mint operator/(mint a, const mint& b) { return a /= b; }    friend ostream& operator<<(ostream& o, const mint& a) { return o << a.v; }    friend istream& operator>>(istream& i, mint& a) {        ll x; i >> x; a = x;        return i;    }}; const int MOD = 998244353;using mi = mint<MOD,5>;using vmi = vector<mi>;using pmi = pair<mi,mi>;using vpmi = vector<pmi>; void solve() {    int n;    cin >> n;    // vi a(n);    // rep(i,0,n) cin >> a[i];    int a, b;    cin >> a >> b;    if ((a - b) % 2 == 0) cout << \"YES\\n\";    else cout << \"NO\\n\";} signed main() {    cin.tie(0)->sync_with_stdio(0);     int t;    cin >> t;    while (t--) solve();     return 0;} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "greedy",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Two Frogs.json",
    "hint": [
        "Hint 1 Look at the distance between the frogs."
    ]
}