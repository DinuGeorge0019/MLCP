{
    "link": "https://codeforces.com//contest/2064/problem/F",
    "problemId": "3209698",
    "problem_idx": "F",
    "shortId": "2064F",
    "contest_number": "2064",
    "problem_submissions": {
        "F": [
            306407892,
            306425196,
            306377965,
            306528822,
            306420583,
            306436938,
            306464619,
            306464611,
            306464596,
            306421840,
            306436020,
            306431617
        ],
        "E": [
            306390714,
            306398471,
            306384310,
            306394422,
            306398127,
            306399878,
            306406503,
            306383184,
            306400855,
            306401726,
            306402720,
            306406500,
            306407308,
            306407643
        ],
        "D": [
            306371870,
            306386641,
            306395969,
            306366170,
            306368905,
            306376156,
            306376541,
            306371606,
            306373885,
            306397500,
            306381946,
            306383232,
            306376685,
            306374721,
            306378738,
            306378728,
            306379129
        ],
        "C": [
            306354396,
            306362052,
            306353937,
            306355169,
            306355714,
            306353717,
            306358223,
            306359445,
            306355168,
            306369168,
            306356490,
            306351942,
            306356412,
            306355663,
            306365036,
            306361215,
            306362138
        ],
        "B": [
            306350175,
            306351645,
            306349804,
            306350391,
            306352487,
            306349346,
            306350952,
            306351840,
            306351364,
            306350764,
            306349120,
            306348178,
            306353114,
            306350171,
            306353103,
            306355161,
            306356448
        ],
        "A": [
            306345365,
            306345586,
            306346094,
            306345382,
            306344838,
            306344890,
            306345366,
            306345254,
            306346099,
            306344812,
            306345138,
            306344813,
            306347979,
            306345325,
            306346230,
            306349362
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138912",
    "editorial": "SolutionFor an arbitrary array first notice that and is both\r\nnon-increasing as we increase . This means that if an array is epic then\r\nthere exists a unique pair of integers such that and there exists such\r\nthat and .Lets call an array -epic if it is epic due to the pair .\r\nBecause the pair is unique, the answer will be equivalent to the sum of\r\nall -epic subarrays of . So lets try to find this sum.Lets say we are\r\ntrying to find the sum of all epic subarrays for a given and let .\r\nFirstly the subarray must obviously contain both and , so lets try to\r\nfind for each the number of subarrays that are epic where is the first\r\ninstance of in the subarray. Notice that it must be true that the first\r\nelement smaller than must come after the last element bigger than .\r\nNotice also that there cannot be an element bigger than after the last\r\ninstance of .So we should store for each index such that the length of\r\nthe longest consecutive sequence of elements strictly less than , which\r\ncontains as its leftmost element. Then for each where we should binary\r\nsearch for the last time where first element smaller than after the last\r\nelement bigger than . Once we can use prefix sums to find the number of\r\npossible right positions of the subarray. To find the number of possible\r\nleft positions of the subarray it is just the length of the longest\r\nconsecutive interval which only contains element strictly larger than\r\nand contain as its right most element. Now we know the number of\r\npossible left endpoints of the subarray and right endpoints, so we can\r\njust add their product to the answer.After doing this across all we will\r\nhave the answer.\r\n",
    "name": "F. We Be Summing",
    "statement": "You are given an array a of length n and an integer k.Call a non-empty\r\narray b of length m if there exists an integer i where 1\r\nle i < m and\r\nmin(b_1,\r\nldots,b_i) +\r\nmax(b_{i + 1},\r\nldots,b_m) = k.Count the number of subarrays^{\r\ntext{ }} of a.^{\r\ntext{ }}An array a is a subarray of an array b if a can be obtained from\r\nb by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. We Be Summing.json",
    "hint": []
}