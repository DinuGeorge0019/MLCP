{"link": "https://codeforces.com//contest/672/problem/E", "problemId": "60101", "problem_idx": "E", "shortId": "672E", "contest_number": "672", "problem_submissions": {"C": [17856476, 17853425, 17852741, 17852810, 17852764, 17854543, 17856540, 17854000, 17853586, 17855118, 17853759, 17853554, 17853180, 17854462, 17853629, 17853161, 17853214, 17865502, 17859793, 17859514], "D": [17852118, 17858174, 17856012, 17857596, 17856195, 17857363, 17858832, 17857387, 17858587, 17857119, 17858225, 17860087, 17858562, 17857585, 17859522, 17859339, 17860159, 17854799, 17856775], "B": [17848405, 17848346, 17848631, 17848242, 17849000, 17847344, 17849580, 17849023, 17847521, 17848536, 17848862, 17849481, 17847879, 17848731, 17848257, 17848469, 17848411, 17847104, 17848038], "A": [17847684, 17846273, 17846879, 17847114, 17846719, 17846366, 17848073, 17846594, 17847473, 17847264, 17847568, 17846784, 17846882, 17847074, 17847356, 17846915, 17846201, 17846769], "E": [17933035]}, "name": "E. Ultimate Weirdness of an Array", "statement": "Yasin has an array containing integers. Yasin is a 5 year old, so he\r\nloves ultimate weird things.Yasin denotes of an array as maximum value\r\namong all . For weirdness is equal to , is the greatest common divisor\r\nof integers and .He also defines the of an array. Ultimate weirdness is\r\nwhere is weirdness of the new array obtained by removing all elements\r\nbetween and inclusive, so new array is .Since 5 year old boys can\u2019t\r\ncode, Yasin asks for your help to find the value of ultimate weirdness\r\nof the given array !\r\n", "solutions": ["#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <memory.h>\n#include <sstream>\n#include <assert.h>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <string>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <set>\n#include <map>\n#include <map>\n\nusing namespace std;\n\nconst int N = 200002;\nconst int sizeTree = (1 << 20);\n\nint tAdd[sizeTree], mn[sizeTree], mx[sizeTree];\nlong long tSum[sizeTree];\nint n;\nint a[N];\npair < int, int > b[N], c[N];\nlong long ans[N];\n\nvoid push(int v, int tl, int tr)\n{\n\tif (tAdd[v] != 0)\n\t{\n\t\tint tm = (tl + tr) / 2;\n\t\ttAdd[2 * v] = mn[2 * v] = mx[2 * v] = tAdd[v];\n\t\ttAdd[2 * v + 1] = mn[2 * v + 1] = mx[2 * v + 1] = tAdd[v];\n\t\ttSum[2 * v] = 1ll * (tm - tl + 1) * tAdd[v];\n\t\ttSum[2 * v + 1] = 1ll * (tr - tm) * tAdd[v];\n\t\ttAdd[v] = 0;\n\t}\n}\n\nvoid build(int v, int tl, int tr)\n{\n\tif (tl == tr)\n\t{\n\t\ttAdd[v] = 0;\n\t\ttSum[v] = tl;\n\t\tmn[v] = mx[v] = tl;\n\t\treturn;\n\t}\n\tint tm = (tl + tr) / 2;\n\tbuild(2 * v, tl, tm);\n\tbuild(2 * v + 1, tm + 1, tr);\n\ttSum[v] = tSum[2 * v] + tSum[2 * v + 1];\n\tmn[v] = min(mn[2 * v], mn[2 * v + 1]);\n\tmx[v] = max(mx[2 * v], mx[2 * v + 1]);\n}\n\nvoid assign(int v, int tl, int tr, int l, int r, int value)\n{\n\tif (l > r || mn[v] >= value)\n\t\treturn;\n\tif (tl == l && tr == r && mx[v] <= value)\n\t{\n\t\tmx[v] = mn[v] = tAdd[v] = value;\n\t\ttSum[v] = 1ll * (tr - tl + 1) * value;\n\t\treturn;\n\t}\n\tpush(v, tl, tr);\n\tint tm = (tl + tr) / 2;\n\tassign(2 * v, tl, tm, l, min(r, tm), value);\n\tassign(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, value);\n\ttSum[v] = tSum[2 * v] + tSum[2 * v + 1];\n\tmn[v] = min(mn[2 * v], mn[2 * v + 1]);\n\tmx[v] = max(mx[2 * v], mx[2 * v + 1]);\n}\n\nvoid update(int j, int pos)\n{\n\tif (b[j].first == -1)\n\t\tb[j].first = pos;\n\telse if (b[j].second == -1)\n\t\tb[j].second = pos;\n\tc[j].first = c[j].second;\n\tc[j].second = pos;\n}\n\n\nint main()\n{\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\tmemset(b, -1, sizeof(b));\n\tmemset(c, -1, sizeof(c));\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tbuild(1, 0, n - 1);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 1; j * j <= a[i]; ++j)\n\t\t{\n\t\t\tif (a[i] % j == 0)\n\t\t\t{\n\t\t\t\tupdate(j, i);\n\t\t\t\tif (a[i] / j != j)\n\t\t\t\t\tupdate(a[i] / j, i);\n\t\t\t}\n\t\t}\n\t}\n\tans[0] = (n == 1 ? 1 : 3);\n\tfor (int i = N - 1; i >= 1; --i)\n\t{\n\t\tans[i] = 1ll * n * n - tSum[1];\n\t\tif (b[i].first != c[i].second)\n\t\t{\n\t\t\tassign(1, 0, n - 1, b[i].second + 1, n - 1, n);\n\t\t\tassign(1, 0, n - 1, b[i].first + 1, b[i].second, c[i].second);\n\t\t\tassign(1, 0, n - 1, 0, b[i].first, c[i].first);\n\t\t}\n\t\t\n\t}\n\tlong long res = 0;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tres += 1ll * (ans[i] - ans[i - 1]) * i;\n\t}\n\tcout << res << endl;\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "number theory"], "dificulty": "2800", "interactive": false}