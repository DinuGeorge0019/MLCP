{
    "link": "https://codeforces.com//contest/1646/problem/F",
    "problemId": "1316357",
    "problem_idx": "F",
    "shortId": "1646F",
    "contest_number": "1646",
    "problem_submissions": {
        "F": [
            148377331,
            148376552,
            148380191,
            148408003,
            148407985,
            148407958,
            148625107,
            148397512,
            148614447,
            148385636
        ],
        "E": [
            148347130,
            148358632,
            148360488,
            148333996,
            148354021,
            148353992,
            148359437,
            148353904,
            148361106,
            148406239,
            148363543,
            148355954,
            148360552,
            148359820,
            148358320,
            148361452,
            148368263,
            148351309,
            148353801,
            148370230,
            148352778
        ],
        "D": [
            148336483,
            148341281,
            148366316,
            148319892,
            148345041,
            148346482,
            148342901,
            148349102,
            148343090,
            148339630,
            148343423,
            148345651,
            148350280,
            148350345,
            148349930,
            148341422,
            148364204,
            148362633,
            148344691,
            148349044
        ],
        "C": [
            148310953,
            148326110,
            148330270,
            148306601,
            148323665,
            148325840,
            148321586,
            148311486,
            148322407,
            148317336,
            148321327,
            148327478,
            148321394,
            148325846,
            148315684,
            148317105,
            148328227,
            148404981,
            148319824,
            148313542,
            148332408
        ],
        "B": [
            148304866,
            148306819,
            148315665,
            148302178,
            148310613,
            148314947,
            148310473,
            148304347,
            148306865,
            148309180,
            148307122,
            148311855,
            148309145,
            148315243,
            148304621,
            148305987,
            148317489,
            148404248,
            148306430,
            148304810,
            148327258
        ],
        "A": [
            148300689,
            148300631,
            148308492,
            148300540,
            148301834,
            148303727,
            148301684,
            148300721,
            148300698,
            148302427,
            148311861,
            148301382,
            148301011,
            148301721,
            148300651,
            148301177,
            148301822,
            148404175,
            148300747,
            148300552,
            148302531
        ]
    },
    "name": "F. Playing Around the Table",
    "statement": "There are n players, numbered from 1 to n sitting around a round table.\r\nThe (i+1)-th player sits to the right of the i-th player for 1\r\nle i < n, and the 1-st player sits to the right of the n-th player.There\r\nare n^2 cards, each of which has an integer between 1 and n written on\r\nit. For each integer from 1 to n, there are exactly n cards having this\r\nnumber.Initially, all these cards are distributed among all the players,\r\nin such a way that each of them has exactly n cards. In one operation,\r\neach player chooses one of his cards and passes it to the player to his\r\nright. All these actions are performed . Player i is called if all his\r\ncards have the integer i written on them. Their objective is to reach a\r\nconfiguration in which everyone is solid. Find a way to do it using at\r\nmost (n^2-n) operations. You do need to minimize the number of\r\noperations.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    vector c(n, vector<int>(n));\n    vector<vector<int>> ans;\n    for (int i = 0; i < n; i += 1)\n        for (int j = 0; j < n; j += 1) {\n            cin >> c[i][j];\n            c[i][j] -= 1;\n        }\n    while (true) {\n        int ready = 1;\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) {\n                if (p[j]) ready = 0;\n                p[j] = 1;\n            }\n        }\n        if (ready) break;\n        vector<int> d(n);\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) p[j] += 1;\n            while (d[i] < n and p[d[i]] <= 1) d[i] += 1;\n        }\n        for (int k = 0; k < 2; k += 1)\n            for (int i = 0; i < n; i += 1)\n                if (d[(i + 1) % n] == n)\n                    d[(i + 1) % n] = d[i];\n        ans.push_back(d);\n        for (int i = 0; i < n; i += 1) {\n            for (int& j : c[i])\n                if (j == d[i]) {\n                    j = d[(i + n - 1) % n];\n                    break;\n                }\n        }\n    }\n    for (int i = 1; i < n; i += 1)\n        for (int j = 0; j < i; j += 1) {\n            vector<int> d(n);\n            for (int k = 0; k < n; k += 1) d[k] = (k + i + n - j) % n;\n            ans.push_back(d);\n            for (int i = 0; i < n; i += 1) {\n                for (int& j : c[i])\n                    if (j == d[i]) {\n                        j = d[(i + n - 1) % n];\n                        break;\n                    }\n            }\n        }\n    for (int i = 0; i < n; i += 1)\n        for (int j : c[i])\n            assert(i == j);\n    cout << ans.size() << \"\\n\";\n    for (auto ansi : ans) {\n        for (int ansij : ansi) cout << ansij + 1 << \" \";\n        cout << \"\\n\";\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Playing Around the Table.json",
    "editorial_link": "https://codeforces.com//blog/entry/100584",
    "editorial": "For each player, we say it is if all his cards have different numbers.\r\nFor each player, we will call a card if this player has two or more\r\ncards with that number. Observe that a player is diverse if and only if\r\nhe has no repeated cards.To construct the answer we are going to divide\r\nthe process into two parts, each of them using at most operations. In\r\nthe first part, we are going to reach a configuration where everyone is\r\ndiverse. In the second one, we will reach the desired configuration.To\r\ndo the first part, in each operation we will choose for each player a\r\nrepeated card to pass. We will repeat this until all players are\r\ndiverse. If some player is already diverse, he will pass a card with the\r\nsame number as the card he will receive in that operation. This way, if\r\na player was diverse before the operation, he will still be diverse\r\nafter the operation.We will prove that the above algorithm ends. If it\r\ndoes not end, at some point some non-diverse player will pass a card he\r\nalready passed (not a card with the same number, the exact same card).\r\nAt this point, all other players have at least one card with this number\r\nand this player has at least two (because it is non-diverse), but this\r\nimplies that there are at least cards with this number, which cannot\r\nhappen. Now, we will prove that this algorithm ends in at most\r\noperations. Consider all cards having the number , and for each of them\r\nconsider the distance it moved, but when a player is diverse, we will\r\nconsider his cards as static and that the card he received (or a\r\nprevious one, if there are multiple diverse players before him) moved\r\nmore than once in a single operation. For each , such that , consider\r\nall cards having the number that moved a distance of or more, and look\r\nat the one that reaches its final destination first. The first players\r\nthat passed this card already had a card with the number on it, and for\r\neach of them, one of these cards will not move anymore (remember that\r\nonce the player is diverse, his cards are static) and it moved less than\r\n, as we are considering the first card. So, there are at most cards that\r\nmoved a distance of or more. Thus, the maximum sum of distances of all\r\ncards containing the number is and the maximum sum of distances of all\r\ncards is . In each operation, the sum of all distances is increased by\r\nso there will be at most operations in this part.To do the second part,\r\nfor each (in this order) the -th player will pass a card with the number\r\na total of times. It is easy to see that after operations, all players\r\nare solid.Implementing the first part naively will result in an\r\nalgorithm, which is enough to solve the problem. However, it is possible\r\nto divide the complexity by maintaining a stack of repeated cards for\r\neach player.Intended complexity:\r\n"
}