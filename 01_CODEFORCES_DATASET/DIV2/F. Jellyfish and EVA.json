{"link": "https://codeforces.com//contest/1875/problem/F", "problemId": "2236823", "problem_idx": "F", "shortId": "1875F", "contest_number": "1875", "problem_submissions": {"E": [226007719, 225981502, 225997077, 226024812, 226185388], "G": [225993602, 226090450], "F": [225971818, 226006439, 226020128, 226050711, 225991779, 225996607, 226001082, 226008955, 226036106, 226011936, 226022791, 225995919, 226047877, 226038835, 226042165, 226041500, 226073814, 226044458, 226057628, 226055233], "D": [225942990, 225945406, 225967656, 225971005, 225948214, 225965867, 225965428, 226166990, 225970035, 225966878, 225985894, 225988437, 225968095, 225971454, 225977691, 226097811, 225987379, 225979524, 225966823, 225974445, 225980563], "C": [225939447, 225939555, 225947158, 225965943, 225943124, 225946690, 225948786, 226166742, 225977924, 225959112, 225979842, 225969180, 225983960, 225947912, 225967709, 226097802, 225947425, 225963735, 225961969, 225959306, 225971328], "B": [225926540, 225961576, 225976303, 226005705, 225926794, 225939253, 225942474, 225938657, 225940294, 225948707, 225962038, 225978973, 225941566, 225960227, 225968949, 225945531, 225926701, 225941384, 225964167], "A": [225922227, 225921742, 225921601, 225922250, 225922542, 225921535, 225921818, 225921875, 225922229, 225922177, 225923351, 225970588, 225921694, 225925214, 226097785, 225924482, 225921598, 225921501, 225922602, 225947031]}, "name": "F. Jellyfish and EVA", "statement": "Monsters have invaded the town again! Asuka invites her good friend,\r\nJellyfish, to drive EVA with her.There are n cities in the town. All the\r\nmonsters are in city n. Jellyfish and Asuka are currently in city 1 and\r\nneed to move to city n to defeat the monsters.There are m roads. The\r\ni-th road allows one to travel from city a_i to city b_i. All the roads\r\nare . That is, one cannot travel from city b_i to a_i using the i-th\r\nroad. Interestingly, all roads satisfy a_i<b_i.Driving EVA requires two\r\npeople to work together. However, Asuka and Jellyfish have not done any\r\ntraining together before.Suppose that EVA is currently in city u.\r\nJellyfish and Asuka will both choose an undestroyed road that starts at\r\ncity u. Suppose Jellyfish and Asuka choose roads that end at cities v_1\r\nand v_2 respectively. If v_1 = v_2, EVA moves to city v_1 successfully.\r\nOtherwise, EVA stays in city u and both roads that they have chosen will\r\nbe destroyed.It is possible that EVA is currently in city u (u\r\nneq n) and there are no undestroyed roads that start at city u. In that\r\ncase, the mission will be a failure. Otherwise, if they reach city n in\r\nthe end, the mission is considered a success.Every time they choose the\r\nroads, Jellyfish knows that Asuka will choose a road randomly. Now,\r\nJellyfish wants to know, if she chooses the roads optimally, what is the\r\nmaximum probability of the mission being successful.\r\n", "solutions": ["#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int P = 0x3f3f3f3f;\nconst ll inff = 1e18 + 10;\nvector<vector<double> >pmt;\nvoid precal()//even only(ave if odd)\n{\n    int P = 5000; pmt.resize(P + 1, vector<double>(P + 1, 0));\n    pmt[2] = { 0.5,0,0.5 };//last:failure\n    for (int i = 4; i <= P; i += 2)\n    {\n        pmt[i][0] = 1;\n        for (int j = 0; j <= i - 2; j++)\n        {\n            pmt[i][j + 2] += pmt[i - 2][j] * (j + 1);\n            pmt[i][j + 1] += pmt[i - 2][j] * (i - j - 2);\n        }\n        for (int j = 0; j <= i; j++)pmt[i][j] /= i;\n    }\n    // 2:101(/2)\n    // 4:A*101\n    // 4:A1*01\n    // 4:A10*1\n    //->4:22103...  \n}\nvoid solve()\n{\n    int n, m; cin >> n >> m;\n    vector<vector<int> >es(n); vector<double>res(n + 1, 0); res[n] = 1;\n    while (m--) { int u, v; cin >> u >> v; es[u].push_back(v); }\n    for (int i = n - 1; i; i--)\n    {\n        vector<double>vals; int siz = es[i].size(); if (!siz)continue;\n        for (auto k : es[i])vals.push_back(res[k]);\n        sort(vals.begin(), vals.end(), greater<double>());\n        if (siz & 1)for (auto k : vals)res[i] += k / siz;\n        else for (int j = 0; j < siz; j++)res[i] += vals[j] * pmt[siz][j];\n    }\n    printf(\"%.12lf\\n\", res[1]);\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0); precal();\n    int t = 1; cin >> t;\n    while (t--)solve();\n}"], "input": "", "output": "", "tags": ["dp", "graphs", "greedy", "math", "probabilities"], "dificulty": "2300", "interactive": false}