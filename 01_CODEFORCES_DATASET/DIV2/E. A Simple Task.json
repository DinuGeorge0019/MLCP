{
    "link": "https://codeforces.com//contest/558/problem/E",
    "problemId": "31490",
    "problem_idx": "E",
    "shortId": "558E",
    "contest_number": "558",
    "problem_submissions": {
        "D": [
            12060370,
            12056527,
            12059090,
            12059491,
            12059065,
            12054778,
            12056387,
            12055925,
            12063869,
            12072214
        ],
        "C": [
            12053633,
            12055512,
            12048548,
            12064102,
            12052329,
            12052749,
            12048409,
            12055315,
            12050109,
            12052282,
            12069418,
            12069387,
            12050188,
            12050328,
            12050475,
            12050277
        ],
        "B": [
            12048746,
            12050659,
            12043934,
            12044434,
            12044575,
            12045422,
            12043956,
            12057039,
            12045386,
            12043738,
            12048369,
            12046762,
            12054080,
            12044823,
            12046619,
            12044825,
            12045463,
            12046006,
            12046134
        ],
        "A": [
            12047744,
            12049996,
            12057160,
            12043771,
            12049018,
            12043976,
            12045019,
            12057924,
            12043847,
            12045136,
            12045173,
            12044161,
            12052769,
            12050459,
            12044438,
            12043911,
            12044045,
            12043813,
            12044484
        ],
        "E": [
            12046569,
            12048494,
            12053809,
            12056713,
            12054492,
            12054844,
            12048063,
            12064379,
            12046497,
            12054488,
            12050859,
            12055637,
            12056916,
            12071603
        ]
    },
    "name": "E. A Simple Task",
    "statement": "This task is very simple. Given a string of length and queries each\r\nquery is on the format which means sort the substring consisting of the\r\ncharacters from to in non-decreasing order if or in non-increasing order\r\nif .Output the final string after applying the queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << \" --> \" << (x) << ' '\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl '\\n'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 1e5+5;\n\nint i, j, k, n, m, x, y, t, q, z;\n\nstring str;\n\nclass node {\n\tpublic:\n\tint cnt[26], L;\n\tnode() { memset(cnt, 0, sizeof cnt); L = -1; }\t\n} ST[N << 2], emp;\n\nnode merge(node x, node y) {\n\tnode temp;\n\tFOR(i,0,25) temp.cnt[i] = x.cnt[i] + y.cnt[i];\n\treturn temp;\n}\n\nvoid upd(int k,int x,int y, int t) {\n\tmemset(ST[k].cnt, 0, sizeof ST[k].cnt);\n\tST[k].cnt[t] = y - x + 1;\n\tST[k].L = t;\n}\n\nvoid push(int k,int bas, int son) {\n\tif(ST[k].L == -1) return ;\n\tupd(sol,bas,orta,ST[k].L);\t\n\tupd(sag,orta+1,son,ST[k].L);\t\n\tST[k].L = -1;\n}\n\nnode init(int k,int bas,int son) {\n\tST[k].L = -1;\n\tif(bas == son) { ST[k].cnt[str[bas]-'a']++; return ST[k]; }\n\treturn ST[k] = merge(init(sol, bas, orta), init(sag, orta + 1, son));\n}\n\nnode query(int k,int bas,int son,int x,int y) {\n\tif(bas > y || son < x) return emp;\n\tif(x <= bas && son <= y) return ST[k];\n\tpush(k,bas,son);\n\treturn merge(query(sol, bas, orta, x, y), query(sag, orta+1, son, x, y));\t\n}\n\nnode update(int k,int bas,int son,int x,int y,int t) {\n\tif(bas > y || son < x) return ST[k];\n\tif(x <= bas && son <= y) {\n\t\tupd(k,bas,son,t);\n\t\treturn ST[k];\n\t}\n\tpush(k,bas,son);\n\treturn ST[k] = merge(update(sol, bas, orta, x, y, t), update(sag, orta + 1, son, x, y, t));\t\n}\n\nint main(){\n\t\n\tios_base::sync_with_stdio(false);\n\n\tcin >> n >> q >> str; str = '0' + str;\n\n\tinit(1,1,n);\n\n\tFOR(i,1,q) {\n\t\t\n\t\tcin >> x >> y >> z;\n\n\t\tnode t = query(1,1,n,x,y);\n\t\n\t\tif(z == 1) {\n\t\t\tint last = x;\n\t\t\tFOR(i,0,25) {  update(1,1,n,last,last+t.cnt[i]-1,i); last += t.cnt[i]; }\n\t\t}\n\t\t\n\t\telse {\n\t\t\tint last = x;\n\t\t\tROF(i,25,0) {  update(1,1,n,last,last+t.cnt[i]-1,i); last += t.cnt[i]; }\n\t\t}\n\t\t\n\t}\n\n\tFOR(i,1,n) {\n\t\t\n\t\tnode temp = query(1,1,n,i,i);\n\n\t\tFOR(i,0,25) if(temp.cnt[i]) cout << (char)(i+'a'); \n\t\t\n\t} cout << endl;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. A Simple Task.json",
    "editorial_link": "https://codeforces.com//blog/entry/19212",
    "editorial": "In this problem we will be using counting sort. So for each query we\r\nwill count the number of occurrences for each character, and then update\r\nthe range like this But this is too slow. We want a data structure that\r\ncan support the above operations in appropriate time. Let s make 26\r\nsegment trees each one for each character. Now for each query let s get\r\nthe count of every character in the range, and then arrange them and\r\nupdate each segment tree with the new values. We will have to use lazy\r\npropagation technique for updating ranges. Time complexity: where sz is\r\nthe size of the alphabet (i.e. = 26). Implementation\r\n",
    "hint": []
}