{
    "link": "https://codeforces.com//contest/1937/problem/F",
    "problemId": "2503244",
    "problem_idx": "F",
    "shortId": "1937F",
    "contest_number": "1937",
    "problem_submissions": {
        "E": [
            250576191,
            250576177,
            248956893,
            248968788,
            248957297,
            248966672,
            249441680,
            249396118,
            248946403,
            248968676,
            250133778
        ],
        "D": [
            248945664,
            248934669,
            248940205,
            248942769,
            248942389,
            248945370,
            250100307,
            248949877,
            248955428,
            248958358,
            248955920,
            248959000,
            248953793,
            248954441,
            248955304,
            248954744,
            248950479,
            248956622
        ],
        "C": [
            248925723,
            248918003,
            248945269,
            248925093,
            248927475,
            248916202,
            248925097,
            248924482,
            248928585,
            248926397,
            248923906,
            248930862,
            248927119,
            248930899,
            248930534,
            249020336,
            248929752,
            248931403,
            248935918,
            248933256
        ],
        "B": [
            248910702,
            248909576,
            248913624,
            248915352,
            248915231,
            248904510,
            248914972,
            248915980,
            248915024,
            248914144,
            248910066,
            248915252,
            248914074,
            248914693,
            248914679,
            249015802,
            248915248,
            248914394,
            248908476,
            248910261
        ],
        "A": [
            248903051,
            248903069,
            248903106,
            248903549,
            248904708,
            248903046,
            248903582,
            248903569,
            248903261,
            248903372,
            248905387,
            248903521,
            248905435,
            248904180,
            248904557,
            248904753,
            248904311,
            248904712,
            248903327
        ],
        "F": [
            250203263
        ]
    },
    "name": "F. Bitwise Paradox",
    "statement": "You are given two arrays a and b of size n along with a fixed integer\r\nv.An interval [l, r] is called a interval if (b_l\r\nmid b_{l+1}\r\nmid\r\nldots\r\nmid b_r)\r\nge v, where | denotes the bitwise OR operation. The of a good interval\r\nis defined as\r\nmax(a_l, a_{l+1},\r\nldots, a_r).You are given q queries of two types: \"\": assign b_i := x;\r\n\"\": find the beauty among all intervals [l_0,r_0] satisfying l\r\nle l_0\r\nle r_0\r\nle r. If there is no suitable good interval, output -1 instead. Please\r\nprocess all queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define sz(v) (int) v.size()\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\nconst int MAX_N = 2e5 + 5;\nconst int MAX_C = 31;\n\nint n, m;\nint a[MAX_N], b[MAX_N];\n\nconst int LOG = 18;\n\nint lenfor[MAX_N];\nint sp[LOG][MAX_N];\n\ninline void build_sparse() {\n    for (int i = 0; i < LOG; ++i) {\n        for (int j = 1; j + (1 << i) - 1 <= n; ++j) {\n            if (i == 0) sp[i][j] = a[j];\n            else sp[i][j] = max(sp[i - 1][j], sp[i - 1][j + (1 << (i - 1))]);\n        }\n    }\n}\n\ninline int get_max(int l, int r) {\n    int len = lenfor[r - l + 1];\n    return max(sp[len][l], sp[len][r - (1 << len) + 1]);\n}\n\nconst int inf = 2e9;\n\nstruct Node {\n    vector<pii> pos;\n    int ans{};\n    int tl{}, tr{};\n\n    Node() {\n        pos.resize(MAX_C, mp(inf, -inf));\n        ans = inf;\n        tl = tr = 0;\n    }\n\n    explicit Node(int x, int p) {\n        pos.resize(MAX_C, mp(inf, -inf));\n        for (int i = 0; i < MAX_C; ++i) {\n            pos[i] = ((x >> i) & 1) ? mp(p, p) : mp(inf, -inf);\n        }\n        ans = inf;\n        if (x >= m) ans = a[p];\n        tl = p, tr = p + 1;\n    }\n\n    Node(Node &A, Node &B) {\n        pos.resize(MAX_C, mp(inf, -inf));\n        for (int i = 0; i < MAX_C; ++i) {\n            pos[i] = mp(min(A.pos[i].fi, B.pos[i].fi),\n                        max(A.pos[i].se, B.pos[i].se));\n        }\n        ans = min(A.ans, B.ans);\n        tl = A.tl, tr = B.tr;\n        int L = inf, R = -inf;\n        bool has_bits = true;\n        for (int i = MAX_C - 1; i >= 0; --i) {\n            if (pos[i] == mp(inf, -inf)) {\n                if ((m >> i) & 1) {\n                    has_bits = false;\n                    break;\n                }\n                continue;\n            }\n            int p = A.pos[i].se, q = B.pos[i].fi;\n            // [p != -inf or q != inf] because pos[i] != mp(inf, -inf)\n            int l, r;\n            if (p == -inf) {\n                l = B.tl, r = q;\n            } else if (q == inf) {\n                l = p, r = A.tr - 1;\n            } else {\n                // [p != -inf and q != inf]\n                int x = get_max(p, A.tr - 1), y = get_max(B.tl, q);\n                if (x <= y) {\n                    l = p, r = A.tr - 1;\n                } else {\n                    l = B.tl, r = q;\n                }\n            }\n            l = min(l, L), r = max(r, R);\n            if ((m >> i) & 1) L = l, R = r;\n            else ans = min(ans, get_max(l, r));\n        }\n        if (has_bits) ans = min(ans, get_max(L, R));\n    }\n};\n\nNode tree[4 * MAX_N];\n\nvoid build(int v, int tl, int tr) {\n    if (tl + 1 == tr) {\n        tree[v] = Node(b[tl], tl);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    build(v * 2 + 1, tl, tm);\n    build(v * 2 + 2, tm, tr);\n    tree[v] = Node(tree[v * 2 + 1], tree[v * 2 + 2]);\n}\n\nvoid update(int v, int tl, int tr, int pos, int value) {\n    if (tl + 1 == tr) {\n        b[tl] = value;\n        tree[v] = Node(b[tl], tl);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    if (pos < tm) update(v * 2 + 1, tl, tm, pos, value);\n    else update(v * 2 + 2, tm, tr, pos, value);\n    tree[v] = Node(tree[v * 2 + 1], tree[v * 2 + 2]);\n}\n\nvoid calc_ans(int v, int tl, int tr, int l, int r, Node &res) {\n    if (tl >= r || l >= tr) return;\n    if (l <= tl && tr <= r) {\n        res = Node(res, tree[v]);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    calc_ans(v * 2 + 1, tl, tm, l, r, res);\n    calc_ans(v * 2 + 2, tm, tr, l, r, res);\n}\n\nvoid solve() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    build_sparse();\n    for (int i = 1; i <= n; ++i) cin >> b[i];\n    build(0, 1, n + 1);\n    int q;\n    cin >> q;\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int pos, value;\n            cin >> pos >> value;\n            update(0, 1, n + 1, pos, value);\n        } else {\n            int l, r;\n            cin >> l >> r;\n            Node res;\n            calc_ans(0, 1, n + 1, l, r + 1, res);\n            cout << (res.ans == inf ? -1 : res.ans) << \" \";\n        }\n    }\n    cout << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    for (int i = 2; i < MAX_N; ++i) {\n        lenfor[i] = lenfor[i >> 1] + 1;\n    }\n\n    int t;\n    cin >> t;\n    while (t--) solve();\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "two pointers"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Bitwise Paradox.json",
    "editorial_link": "https://codeforces.com//blog/entry/126513",
    "editorial": "First we use the line segment tree to maintain sequence b\n. For the nodes [l,r]\n on each line segment tree, we maintain the first and last occurrence positions of each binary bit in the interval.\n\nWe need to merge the two intervals, whether it is modification or query. Suppose you want to use the information of [l,mid],[mid+1,r]\n to merge the information of [l,r]\n. Consider the answer that spans two intervals. If we want to make the i\n-th position of the interval OR 1\n, then there are two possibilities\n\nSelect the last occurrence position P\n of the i\n-th bit in [l,mid].\n\nSelect the first occurrence position Q\n of the i\n-th bit in [mid+1,r].\n\nLet x=max(a[P],a[P+1],,a[mid]),y=max(a[mid+1],a[mid+2],,a[Q]).\n\nIf x<=y,\n we can choose the position P\n greedily, because his price is smaller. If you choose Q,\n then you must also choose P,\n because choosing P\n does not increase max a.\n Otherwise, select Q\n on the contrary.\n\nWith the above greedy, then you can enumerate the first binary bit i\n that is larger than v\n. The i\n-th bit of the interval OR must be 1\n, and the i\n-th bit of v\n is 0\n. For the j\n-th (j>i)\n bit, if the j\n-th bit of v\n is 1\n, then the j\n-th bit must also be 1\n. The rest of the bits can be regarded as 0\n or 1\n, you only need to deal with these bits that must be selected 1\n greedily, and expand the interval.\n\nYou can use the st table O(1)\n to find the interval max of a\n, so you can merge the information of the two intervals in the time of O(logV)\n. With the line segment tree, O(qlognlogV+nlogV)\n can be done.",
    "hint": []
}