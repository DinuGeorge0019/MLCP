{"link": "https://codeforces.com//contest/129/problem/D", "problemId": "680", "problem_idx": "D", "shortId": "129D", "contest_number": "129", "problem_submissions": {"D": [870060, 869793, 868329, 868490, 871604, 869018, 869569], "E": [867711, 868998, 867271, 866024, 867668, 866384, 868771, 868972, 869787, 869113, 869182, 869294, 869358], "C": [866691, 866148, 865711, 868095, 866773, 867004, 867491, 867351, 866936, 866349, 867158, 866312, 867092, 867601, 867201, 867450, 867706, 867793], "B": [865720, 865280, 865180, 865582, 865310, 866211, 868127, 865744, 865731, 866928, 865788, 865528, 865521, 866153, 866294, 865110, 865388, 865554], "A": [864668, 864600, 864704, 864708, 864607, 864653, 868290, 864785, 864784, 867045, 864843, 864624, 864640, 865218, 864855, 865276, 864658, 864664]}, "name": "D. String", "statement": "One day in the IT lesson Anna and Maria learned about the lexicographic\r\norder.String is lexicographically less than string , if either is a\r\nprefix of (and ), or there exists such (), that , and for any () . Here\r\ndenotes the length of the string . The lexicographic comparison of\r\nstrings is implemented by operator < in modern programming languages\r\n.The teacher gave Anna and Maria homework. She gave them a string of\r\nlength . They should write out all substrings of the given string,\r\nincluding the whole initial string, and the equal substrings (for\r\nexample, one should write out the following substrings from the string\r\n\"\": \"\", \"\", \"\", \"\", \"\", \"\"). The resulting strings should be sorted in\r\nthe lexicographical order. The cunning teacher doesn\u2019t want to check all\r\nthese strings. That\u2019s why she said to find only the -th string from the\r\nlist. Help Anna and Maria do the homework.\r\n", "solutions": ["#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <sstream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <iterator>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair< int, int > PRII;\ntypedef pair< double, double > PRDD;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\n\n#define x first\n#define y second\n#define p_b push_back\n#define m_p make_pair\n#define oo 1000000000\n\n#define sqr(x) ((x)*(x))\n#define Size(a) ((int)a.size())\n#define forn(i,n) for( i = 0 ; i < n ; ++i )\n\nconst double pi = acos(-1);\n#define maxn 1000000 + 10\n\nint n,k;\nchar str[maxn];\nint rank[maxn],sa[maxn],height[maxn],h[maxn];\n\nint s[maxn],a[maxn];\n\nvoid get_rank()\n{\n    int k,i,j,t;\n    \n    for( i = 1 ; i <= n ; ++i )\n        ++s[str[i]-'a'+1];\n    for( i = 1 ; i <= 26 ; ++i )\n        s[i] += s[i-1];\n    for( i = 1 ; i <= n ; ++i )\n        sa[s[str[i]-'a'+1]--] = i;\n    t = 0;\n    for( i = 1 ; i <= n ; i = j )\n        {\n            ++t;\n            for( j = i ; j <= n && str[sa[j]] == str[sa[i]] ; ++j )\n                rank[sa[j]] = t;\n        }\n    \n    for( k = 0 ; rank[sa[n]] < n ; ++k )\n        {\n            memset(s,0,sizeof s);\n            for( i = 1 ; i <= n ; ++i )\n                ++s[rank[i+(1<<k)]];\n            for( i = 1 ; i <= n ; ++i )\n                s[i] += s[i-1];\n            for( i = 1 ; i <= n ; ++i )\n                a[s[rank[i+(1<<k)]]--] = i;\n            memset(s,0,sizeof s);\n            for( i = 1 ; i <= n ; ++i )\n                ++s[rank[i]];\n            for( i = 1 ; i <= n ; ++i )\n                s[i] += s[i-1];\n            for( i = n ; i >= 1 ; --i )\n                sa[s[rank[a[i]]]--] = a[i];\n            t = 0;\n            for( i = 1 ; i <= n ; i = j )\n                {\n                    ++t;\n                    for( j = i ; j <= n && rank[sa[j]] == rank[sa[i]] && rank[sa[j]+(1<<k)] == rank[sa[i]+(1<<k)] ; ++j )\n                        a[sa[j]] = t;\n                }\n            memcpy(rank,a,sizeof rank);\n        }\n}\n\nvoid get_height()\n{\n    for( int i = 1 ; i <= n ; ++i )\n        {\n            if( rank[i] > 1 )\n                for( h[i] = max(h[i-1]-1,0) ; str[i+h[i]] == str[sa[rank[i]-1]+h[i]] ; ++h[i] );\n            height[rank[i]] = h[i];\n        }\n}\n\nint main()\n{\n    int i,j;\n    \n    scanf(\"%s\",str+1);\n    scanf(\"%d\",&k);\n    n = strlen(str+1);\n    get_rank();\n    get_height();\n    \n    if( k > (LL)n*(n+1)/2 )\n        printf(\"No such line.\\n\");\n    else\n        {\n            memset(a,0,sizeof a);\n            i = 1;\n            while(k)\n                {\n                    ++a[i];\n                    if( a[i] > n-sa[i]+1 )\n                        {\n                            ++i;\n                            continue;\n                        }\n                    --k;\n                    for( j = i+1 ; j <= n && height[j] >= a[i] && k ; ++j )\n                        {\n                            ++a[j];\n                            if( a[j] <= n-sa[j]+1 )\n                                --k;\n                        }\n                }\n            for( j = 0 ; j < a[i] ; ++j )\n                printf(\"%c\",str[sa[i]+j]);\n            printf(\"\\n\");\n        }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["implementation", "string suffix structures", "strings"], "dificulty": "2100", "interactive": false}