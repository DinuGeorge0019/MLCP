{
    "link": "https://codeforces.com//contest/610/problem/E",
    "problemId": "44290",
    "problem_idx": "E",
    "shortId": "610E",
    "contest_number": "610",
    "problem_submissions": {
        "E": [
            15053499,
            15051695,
            15055517,
            15468537,
            15054746,
            15092595
        ],
        "B": [
            15050877,
            15053921,
            27182434,
            15047165,
            15045211,
            15044820,
            15045928,
            15046116,
            15045542,
            15045130,
            15046665,
            15047371,
            15044370,
            15046773,
            15045049,
            15044516,
            15052695,
            15046983,
            15047646,
            15044510,
            15045948
        ],
        "D": [
            15049809,
            15046533,
            15053385,
            15053873,
            15049276,
            15049759,
            15052914,
            15052461,
            15053191,
            15053905,
            15053030,
            15054321,
            15054255,
            15054811,
            15051818,
            15053392,
            15053677,
            15054046,
            15054704
        ],
        "A": [
            15049788,
            15052508,
            15043466,
            15042823,
            15042879,
            15042700,
            15043682,
            15043766,
            15042783,
            15042798,
            15043007,
            15042601,
            15043336,
            15042897,
            15042861,
            15043393,
            15043051,
            15042935,
            15042657,
            15043356
        ],
        "C": [
            15043384,
            15054209,
            15050445,
            15052911,
            15053221,
            15051863,
            15048319,
            15049540,
            15049193,
            15049080,
            15050593,
            15048004,
            15048429,
            15051082,
            15049084,
            15050509,
            15050531,
            15050981,
            15051132,
            15048269
        ]
    },
    "name": "E. Alphabet Permutations",
    "statement": "You are given a string of length , consisting of first lowercase English\r\nletters.We define a of some string as a string, consisting of copies of\r\nthe string . For example, string \"\" is a -repeat of the string \"\".Let’s\r\nsay that string contains string as a subsequence, if string can be\r\nobtained from by erasing some symbols.Let be a string that represents\r\nsome permutation of the first lowercase English letters. We define\r\nfunction as the smallest integer such that a -repeat of the string\r\ncontains string as a subsequence.There are operations of one of two\r\ntypes that can be applied to string : Replace all characters at\r\npositions from to by a character . For the given , that is a permutation\r\nof first lowercase English letters, find the value of function . All\r\noperations are performed sequentially, in the order they appear in the\r\ninput. Your task is to determine the values of function for all\r\noperations of the second type.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cassert>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\n\nint cnt[15][15];\nint n,m,k;\nchar str[222222];\nint a[222222];// start of a interval\nset<int>se;\n\nchar ss[15];\n\nint lis[222222];\n\nset<int>::iterator brea(int i){//i-1 and i\n    if(se.count(i))return se.find(i);\n    set<int>::iterator it=se.insert(i).first,it2=it;\n    it2--;\n    a[i]=a[*it2];\n    return it;\n}\nint main()\n{\n    gn(n);gn(m);gn(k);\n    scanf(\"%s\",str+1);\n    for (int i=1;i<=n;i++)a[i]=str[i]-'a'+1;\n    for (int i=1;i<=n;i++)se.insert(i);\n    a[0]=a[n+1]=k+1;\n    se.insert(0);se.insert(n+1);\n    for (int i=1;i<=n;i++)cnt[a[i]][a[i+1]]++;\n    while(m--){\n        int opt;\n        gn(opt);\n        if(opt==1){\n            int l,r;char cc;\n            gn(l);gn(r);\n            while((cc=getchar())<'a' || cc>'z');\n            int c=cc-'a'+1;\n\n            set<int>::iterator it1=brea(l),it3=it1;it3--;\n            set<int>::iterator it2=brea(r+1);\n\n            int tot=0;\n            while(1){\n                lis[++tot]=*it3;\n                if(lis[tot]==r+1)break;\n                it3++;\n            }\n\n            for (int i=1;i<tot;i++)cnt[a[lis[i]]][a[lis[i+1]]]--;\n            it1++;se.erase(it1,it2);\n            a[l]=c;\n            cnt[a[lis[1]]][c]++;\n            cnt[c][a[lis[tot]]]++;\n        }else{\n            scanf(\"%s\",ss+1);\n            int an=0;\n            for (int i=1;i<=k;i++)\n                for (int j=i+1;j<=k;j++)an+=cnt[ss[i]-'a'+1][ss[j]-'a'+1];\n            printf(\"%d\\n\",n-an);\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Alphabet Permutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/22341",
    "editorial": "Consider slow solution: for operations of the first type reassign all letters, for operations of the second type let's iterate over the symbols in s from left to right and maintain the pointer to the current position in alphabet permutation. Let's move the pointer cyclically in permutation until finding the current symbol from s. And move it one more time after that. Easy to see that the answer is one plus the number of cyclic movements. Actually the answer is also the number of pairs of adjacent symbols in s that the first one is not righter than the second one in permutation. So the answer depends only on values of cntij - the number of adjacent symbols i and j.\n\nTo make solution faster let's maintain the segment tree with matrix cnt in each node. Also we need to store in vertex the symbol in the left end of segment and in the right end. To merge two vertices in the segment tree we should simply add the values in the left and in the right sons in the tree, and update the value for the right end of the left segment and the left end of the right segment.",
    "hint": []
}