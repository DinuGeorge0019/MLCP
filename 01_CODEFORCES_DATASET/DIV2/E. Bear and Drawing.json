{
    "link": "https://codeforces.com//contest/574/problem/E",
    "problemId": "34319",
    "problem_idx": "E",
    "shortId": "574E",
    "contest_number": "574",
    "problem_submissions": {
        "E": [
            12777654,
            12761905,
            12761141,
            12767794,
            12812186,
            12765590,
            12765583,
            12795832
        ],
        "D": [
            12753243,
            12754709,
            12749273,
            12752316,
            12751860,
            34986711,
            12751794,
            12753633,
            12752636,
            12753482,
            12752444,
            12753915,
            12754683,
            12753066,
            12754887,
            12755381,
            12754991,
            12754068,
            12756274,
            12755316,
            12755471
        ],
        "C": [
            12751208,
            12750732,
            12747796,
            12748107,
            12749130,
            34986465,
            12750242,
            12746917,
            12765952,
            12749775,
            12747265,
            12751486,
            12748422,
            12748315,
            12751012,
            12748270,
            12746927,
            12748796,
            12751828,
            12748701,
            12751210,
            12751267
        ],
        "B": [
            12749719,
            12749612,
            12747301,
            12747302,
            12748361,
            34986352,
            12748979,
            12749853,
            23873486,
            12748845,
            12751204,
            12749303,
            12751151,
            12749688,
            12749272,
            12749406,
            12751674,
            12752041,
            12750218,
            12747923,
            12747922,
            12748657
        ],
        "A": [
            12746925,
            12747156,
            12746306,
            12746196,
            12746305,
            34986203,
            34986199,
            12746356,
            12747131,
            12746281,
            12748351,
            12747087,
            12746932,
            12747573,
            12747386,
            12747413,
            12748055,
            12746903,
            12747183,
            12746649,
            12749265,
            12747493
        ]
    },
    "name": "E. Bear and Drawing",
    "statement": "Limak is a little bear who learns to draw. People usually start with\r\nhouses, fences and flowers but why would bears do it? Limak lives in the\r\nforest and he decides to draw a tree.Recall that is a connected graph\r\nconsisting of vertices and edges.Limak chose a tree with vertices. He\r\nhas infinite strip of paper with two parallel rows of dots. Little bear\r\nwants to assign vertices of a tree to some distinct dots on a paper so\r\nthat edges would intersect only at their endpoints drawn tree must be\r\nplanar. Below you can see one of correct drawings for the first sample\r\ntest. Is it possible for Limak to draw chosen tree?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vpi> vvpi;\ntypedef priority_queue<pi> pqi;\n\nint main(){\n  int n,m;\n  cin>>n;\n  vvi G(n);\n  vi P(n,0);\n  vvi k(n,vi(5,0));\n  pqi Q;\n  for(int i = 1;i < n;++i){\n    int x,y;\n    cin>>x>>y;\n    --x;\n    --y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n    ++P[x];\n    ++P[y];\n  }\n  for(int i = 0;i < n;++i){\n    if(P[i] == 1){\n      Q.push(pi(-1,i));\n    }\n  }\n  vi T = P;\n  bool xec = true;\n  while(!Q.empty()){\n    int x = Q.top().Y;\n    Q.pop();\n    if(k[x][1] > 0 or k[x][2] > 2){ \n      xec = false;\n      k[x][0] = 1;\n    }\n    else if(k[x][2] == 1) k[x][0] = 2;\n    else if(k[x][2] == 2) k[x][0] = 1;\n    else if(k[x][3] > 0 or k[x][4] > 2) k[x][0] = 2;\n    else if(k[x][4] == 2) k[x][0] = 3;\n    else k[x][0] = 4;\n    int count = 0;\n    for(int i = 0;i <G[x].size();++i){\n      int y = G[x][i];\n      if(P[y] > 1){\n\t--P[y];\n\tk[y][k[x][0]]++;\n\tif(P[y] == 1) Q.push(pi(-T[y],y));\n\t++count;\n      }\n    }\n    if(count == 0 and k[x][0] == 1){\n      for(int i = 0;i < G[x].size();++i){\n\tint y = G[x][i];\n\tif(k[y][0] == 2) ++count;\n      }\n      if(count > 2) xec = false;\n    }\n    else if(count == 0 and k[x][0] == 2){\n      for(int i = 0;i < G[x].size();++i){\n\tint y = G[x][i];\n\tif(k[y][0] == 1) xec = false;\n      }\n    }\n  }\n  int count = 0;\n  /*\n  for(int i = 0;i < n;++i){\n    if(k[i][0] == 1) ++count;\n    cout<<i<<\" \"<<k[i][0]<<endl;\n  }\n  */\n  if(count > 1) xec = false;\n  if(xec) cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Bear and Drawing.json",
    "editorial_link": "https://codeforces.com//blog/entry/20040",
    "editorial": "What is wrong with the solution in the image? Sorry for asking very\r\nbasic questions but Iâm trying to understand it from last couple of\r\nhours.\r\n",
    "hint": []
}