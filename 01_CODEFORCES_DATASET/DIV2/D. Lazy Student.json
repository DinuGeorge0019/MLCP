{
    "link": "https://codeforces.com//contest/606/problem/D",
    "problemId": "42715",
    "problem_idx": "D",
    "shortId": "606D",
    "contest_number": "606",
    "problem_submissions": {
        "E": [
            14725950,
            14727210,
            14727285,
            14729262,
            14730116,
            14751808,
            14744112
        ],
        "D": [
            14723234,
            14720930,
            14722869,
            14722527,
            14721927,
            14721746,
            14724535,
            14726175,
            14725267,
            14727123,
            14723529,
            14723141,
            14723054,
            14723150,
            14724111,
            14724621,
            14724261,
            14729733,
            14726510,
            14723588
        ],
        "C": [
            14720687,
            14718170,
            14720169,
            14719390,
            14718531,
            14725447,
            14722596,
            14730393,
            14718042,
            14720969,
            14719927,
            14719309,
            14718761,
            14720872,
            14720282,
            14719898,
            14721458,
            14724065,
            14721907,
            14718844
        ],
        "B": [
            14719527,
            14727489,
            14717796,
            14718524,
            14717743,
            14717859,
            14719198,
            14721650,
            14720720,
            14718805,
            14718705,
            14720039,
            14720141,
            14718565,
            14718498,
            14718858,
            14720719,
            14719695,
            14729480
        ],
        "A": [
            14716101,
            14721455,
            14715984,
            14715809,
            14716134,
            14715791,
            14715975,
            14739251,
            14715905,
            14717499,
            14716801,
            14716057,
            14715921,
            14715914,
            14715981,
            14716162,
            14716237,
            14717038,
            14716311,
            14716156
        ]
    },
    "name": "D. Lazy Student",
    "statement": "Student Vladislav came to his programming exam completely unprepared as\r\nusual. He got a question about some strange algorithm on a graph\r\nsomething that will definitely never be useful in real life. He asked a\r\ngirl sitting next to him to lend him some cheat papers for this\r\nquestions and found there the following definition: of graph is such a\r\ntree that it contains all the vertices of the original graph , and the\r\nsum of the weights of its edges is the minimum possible among all such\r\ntrees.Vladislav drew a graph with vertices and edges containing no loops\r\nand multiple edges. He found one of its minimum spanning trees and then\r\nwrote for each edge its weight and whether it is included in the found\r\ntree or not. Unfortunately, the piece of paper where the graph was\r\npainted is gone and the teacher is getting very angry and demands to see\r\nthe original graph. Help Vladislav come up with a graph so that the\r\ninformation about the minimum spanning tree remains correct.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\npair<int, int> ki[100001];\nvector<pair<pair<int, int>, int> > el;\n\nint csucsjon=1;\nint kov[100001];\nint keszcsucs=1;\n\nint main()\n{\n    //freopen(\"D.txt\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin >> n>>m;\n    for (int i=1;i<=n;i++) kov[i]=1;\n\n    for (int i=1;i<=m;i++) {\n        int x, y;\n        cin >> x>>y;\n        el.push_back(make_pair(make_pair(x, 0-y), i));\n    }\n    sort(el.begin(), el.end());\n\n    for (auto ell:el) {\n        auto e=ell.first;\n        if (e.second!=0) {\n            keszcsucs++;\n            kov[keszcsucs]++;\n            ki[ell.second]= make_pair(keszcsucs, 1);\n        } else {\n            while (kov[csucsjon]>=csucsjon) csucsjon++;\n            if (csucsjon>keszcsucs) {\n                cout <<-1<<endl;\n                return 0;\n            } else {\n                ki[ell.second]= make_pair(csucsjon, kov[csucsjon]);\n                kov[csucsjon]++;\n            }\n        }\n    }\n\n    for (int i=1;i<=m;i++) {\n        auto e=ki[i];\n        cout << e.first <<\" \"<<e.second<<endl;\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Lazy Student.json",
    "editorial_link": "https://codeforces.com//blog/entry/22019",
    "editorial": "Lets order edges of ascending length, in case of a tie placing earlier edges we were asked to include to MST. Lets start adding them to the graph in this order. If we asked to include the current edge to MST, use this edge to llink 1st vertex with the least currently isolated vertex. If we asked NOT to include the current edge to MST, use this edge to link some vertices that are already linked but have no edges between them. To do this its convenient to have two pointer on vertices (lets call them FROM and TO). At the beginning, FROM=2, TO=3. When we are to link two already linked vertices, we add new edge (FROM, TO) and increment FROM. If FROM becomes equal to TO, we can assume we already added all possible edges to TO, so we increment TO and set FROM to 2. This means from this moment we will use non-MST edges to connect TO with all previous vertices starting from 2. If it appears that TO looks at currently isolated vertex, we can assume there are no place for non-MST edge it the graph, so the answer is Impossible. Keep doing in the described way, well be adding MST edges as (1,2), , (1,n) and non-MST edges as (2,3), (2,4), (3,4), (2,5), (3,5), (4,5), ...",
    "hint": []
}