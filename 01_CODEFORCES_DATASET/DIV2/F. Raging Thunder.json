{
    "link": "https://codeforces.com//contest/1371/problem/F",
    "problemId": "658034",
    "problem_idx": "F",
    "shortId": "1371F",
    "contest_number": "1371",
    "problem_submissions": {
        "F": [
            85724126,
            85680245,
            85681350,
            85699885
        ],
        "E2": [
            85657442,
            85655168,
            85656290,
            85748587,
            85748232,
            85708674,
            85665045,
            85668857,
            85658632,
            85666166,
            85670120,
            85660293,
            85663781,
            85670954,
            85668210,
            85680055,
            85669661,
            85682351,
            85669454,
            85672846,
            85682060,
            85671106
        ],
        "E1": [
            85647787,
            85655311,
            85656202,
            85709850,
            85654362,
            85651600,
            85658237,
            85658032,
            85654262,
            85660541,
            85663528,
            85656065,
            85668083,
            85661660,
            85665638,
            85654459,
            85668563,
            85663741,
            85657234,
            85666469
        ],
        "D": [
            85643050,
            85667344,
            85644091,
            85642391,
            85641068,
            85648738,
            85648076,
            85650769,
            85650684,
            85651359,
            85649126,
            85650672,
            85644656,
            85652003,
            85647555,
            85653607,
            85654186,
            85646247,
            85653171
        ],
        "C": [
            85639893,
            85664644,
            85640509,
            85637217,
            85637662,
            85643069,
            85643313,
            85639582,
            85644962,
            85641558,
            85643750,
            85642402,
            85635916,
            85643555,
            85643224,
            85639831,
            85646794,
            85639649,
            85640565
        ],
        "B": [
            85637385,
            85659549,
            85636246,
            85634765,
            85643737,
            85638003,
            85639540,
            85641465,
            85641062,
            85638464,
            85641050,
            85638539,
            85645723,
            85639381,
            85639446,
            85646495,
            85640832,
            85636683,
            85636740
        ],
        "A": [
            85625335,
            85659712,
            85625054,
            85624966,
            85631182,
            85625230,
            85625986,
            85627166,
            85626824,
            85627013,
            85638725,
            85626600,
            85625210,
            85625324,
            85628198,
            85626246,
            85627731,
            85625426,
            85631949
        ]
    },
    "name": "F. Raging Thunder",
    "statement": "You are a warrior fighting against the machine god Thor.Thor challenge\r\nyou to solve the following problem:There are n conveyors arranged in a\r\nline numbered with integers from 1 to n from left to right. Each\r\nconveyor has a symbol \"\" or \"\". The initial state of the conveyor i is\r\nequal to the i-th character of the string s. There are n+1 holes\r\nnumbered with integers from 0 to n. The hole 0 is on the left side of\r\nthe conveyor 1, and for all i\r\ngeq 1 the hole i is on the right side of the conveyor i.When a ball is\r\non the conveyor i, the ball moves by the next rules:If the symbol \"\" is\r\non the conveyor i, then: If i=1, the ball falls into the hole 0. If the\r\nsymbol \"\" is on the conveyor i-1, the ball moves to the conveyor i-1. If\r\nthe symbol \"\" is on the conveyor i-1, the ball falls into the hole i-1.\r\nIf the symbol \"\" is on the conveyor i, then: If i=n, the ball falls into\r\nthe hole n. If the symbol \"\" is on the conveyor i+1, the ball moves to\r\nthe conveyor i+1. If the symbol \"\" is on the conveyor i+1, the ball\r\nfalls into the hole i. You should answer next q queries, each query is\r\ndefined by the pair of integers l, r (1\r\nleq l\r\nleq r\r\nleq n): First, for all conveyors l,l+1,...,r, the symbol \"\" changes to\r\n\"\" and vice versa. After that, put on each conveyor l,l+1,...,r. Then,\r\neach ball falls into some hole. Find the maximum number of balls in one\r\nhole.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 1000005;\nint n, m;\nstring str;\nstruct Tree\n{\n\tint lt, rt, ll, lr, rl, rr, lmaxi1, lmaxi2, rmaxi1, rmaxi2, maxi1, maxi2;\n\t/*\n\t\tll : Left '<'\n\t\tlr : Left '>'\n\t\trl : Right '<'\n\t\trr : Right '>'\n\t\tlmaxi1 : Left max{a + b} (a * '>' + b * '<', a, b may be 0)\n\t\trmaxi1 : Right max.....\n\t\tlmaxi2 : Left max{a + b} (a * '<' + b * '>')\n\t\trmaxi2 : Right max.....\n\t\tmaxi1 : max{a + b} (a * '>' + b * '<')\n\t\tmaxi2 : max{a + b} (a * '<' + b * '>')\n\t*/\n\tbool tag;\n} tree[4 * Maxn];\nTree Swap(Tree x)\n{\n\tswap(x.ll, x.lr), swap(x.rr, x.rl), swap(x.lmaxi1, x.lmaxi2), swap(x.rmaxi1, x.rmaxi2), swap(x.maxi1, x.maxi2);\n\treturn x;\n}\nTree merge(Tree x, Tree y)\n{\n\tif (x.tag) x.tag = false, x = Swap(x);\n\tif (y.tag) y.tag = false, y = Swap(y);\n\tTree ans;\n\tans.tag = false;\n\tans.lt = x.lt, ans.rt = y.rt;\n\tif (x.ll == x.rt - x.lt) ans.ll = x.ll + y.ll;\n\telse ans.ll = x.ll;\n\tif (y.rr == y.rt - y.lt) ans.rr = y.rr + x.rr;\n\telse ans.rr = y.rr;\n\tif (x.lr == x.rt - x.lt) ans.lr = x.lr + y.lr;\n\telse ans.lr = x.lr;\n\tif (y.rl == y.rt - y.lt) ans.rl = y.rl + x.rl;\n\telse ans.rl = y.rl;\n\tans.maxi1 = max(x.maxi1, y.maxi1);\n\tans.maxi1 = max(ans.maxi1, max(x.rr + y.lmaxi1, x.rmaxi1 + y.ll));\n\tans.maxi2 = max(x.maxi2, y.maxi2);\n\tans.maxi2 = max(ans.maxi2, max(x.rl + y.lmaxi2, x.rmaxi2 + y.lr));\n\tans.lmaxi1 = max(x.lmaxi1 + (x.lmaxi1 == x.rt - x.lt) * y.ll, (x.lr == x.rt - x.lt) ? x.lr + y.lmaxi1 : 0);\n\tans.rmaxi1 = max(y.rmaxi1 + (y.rmaxi1 == y.rt - y.lt) * x.rr, (y.rl == y.rt - y.lt) ? y.rl + x.rmaxi1 : 0);\n\tans.lmaxi2 = max(x.lmaxi2 + (x.lmaxi2 == x.rt - x.lt) * y.lr, (x.ll == x.rt - x.lt) ? x.ll + y.lmaxi2 : 0);\n\tans.rmaxi2 = max(y.rmaxi2 + (y.rmaxi2 == y.rt - y.lt) * x.rl, (y.rr == y.rt - y.lt) ? y.rr + x.rmaxi2 : 0);\n\treturn ans;\n}\nvoid pushdown(int root)\n{\n\tif (tree[root].tag)\n\t{\n\t\ttree[root].tag = 0;\n\t\ttree[root << 1].tag ^= 1, tree[root << 1 | 1].tag ^= 1;\n\t\ttree[root] = Swap(tree[root]);\n\t}\n}\nvoid build(int root, int lt, int rt)\n{\n\ttree[root] = (Tree){lt, rt};\n\tif (lt + 1 == rt)\n\t{\n\t\tif (str[lt - 1] == '<') tree[root].ll = tree[root].rl = tree[root].maxi1 = tree[root].maxi2 = tree[root].lmaxi1 = tree[root].rmaxi2 = tree[root].rmaxi1 = tree[root].lmaxi2 = 1;\n\t\telse tree[root].lr = tree[root].rr = tree[root].maxi1 = tree[root].maxi2 = tree[root].lmaxi1 = tree[root].rmaxi2 = tree[root].rmaxi1 = tree[root].lmaxi2 = 1;\n\t}\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tbuild(root << 1, lt, mid);\n\t\tbuild(root << 1 | 1, mid, rt);\n\t\ttree[root] = merge(tree[root << 1], tree[root << 1 | 1]);\n\t}\n}\nvoid modify(int root, int lt, int rt)\n{\n\tif (lt == tree[root].lt && rt == tree[root].rt)\n\t\ttree[root].tag ^= 1;\n\telse\n\t{\n\t\tpushdown(root);\n\t\tint mid = (tree[root].lt + tree[root].rt) >> 1;\n\t\tif (lt >= mid) modify(root << 1 | 1, lt, rt);\n\t\telse if (rt <= mid) modify(root << 1, lt, rt);\n\t\telse modify(root << 1, lt, mid), modify(root << 1 | 1, mid, rt);\n\t\ttree[root] = merge(tree[root << 1], tree[root << 1 | 1]);\n\t}\n}\nTree ask(int root, int lt, int rt)\n{\n\tif (lt == tree[root].lt && rt == tree[root].rt)\n\t{\n\t\tpushdown(root);\n\t\treturn tree[root];\n\t}\n\telse\n\t{\n\t\tpushdown(root);\n\t\tint mid = (tree[root].lt + tree[root].rt) >> 1;\n\t\tif (lt >= mid) return ask(root << 1 | 1, lt, rt);\n\t\telse if (rt <= mid) return ask(root << 1, lt, rt);\n\t\telse return merge(ask(root << 1, lt, mid), ask(root << 1 | 1, mid, rt));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tcin >> str;\n\tbuild(1, 1, n + 1);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tmodify(1, l, r + 1);\n\t\tTree res = ask(1, l, r + 1);\n\t\tprintf(\"%d\\n\", res.tag ? res.maxi2 : res.maxi1);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Raging Thunder.json",
    "editorial_link": "https://codeforces.com//blog/entry/79624",
    "editorial": "First, observe where the balls fall. When there is a \"\" structure, the\r\nballs on there will fall into one hole. So, our goal is handling this\r\nstructure.Each query is asking about a segment. Then, to solve this\r\nproblem, we can use segment tree.Each node maintains following: Prefix\r\nstructure Suffix structure The answer for between above structures For\r\nexample, a string \"\" will be converted to the following data: Prefix\r\nstructure : \"\" Suffix structure : \"\" The answer for between above\r\nstructures : take the answer of \"\" or \"\". the largest answer is . And we\r\nneed to implement that combining two data ( [left data] + [right data]\r\n). Mainly we should merge left suffix and right prefix, and calculate\r\nthe answer for the segment, but notice that there are some exceptions.\r\nThe exceptions are in case of there are only one structure in the merged\r\nnode, like \"\" or \"\". (You may maintain other flags for your\r\nimplement.)Then, how to handling each queries? We also keep above data\r\nfor when \u00e2\u0080\u009d are changed into \u00e2\u0080\u009d and vice versa on each node of the segment\r\ntree. And when a change query actually comes to some nodes, swap these\r\ndata. Apply lazy propagation for handling this. When calculate the\r\nanswer for a query, don\u00e2\u0080\u0099t forget to consider about the prefix(or the\r\nsuffix).Total complexity :\r\n"
}