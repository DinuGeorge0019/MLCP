{"link": "https://codeforces.com//contest/88/problem/D", "problemId": "465", "problem_idx": "D", "shortId": "88D", "contest_number": "88", "problem_submissions": {"C": [479214, 477433, 478480, 479134, 478757, 479137, 478197, 479335, 478450, 478394, 479058, 479099, 479046, 479022, 479366, 479334], "E": [478957, 479559, 480051, 480963, 480059, 480346], "D": [478514, 480342, 480973, 480128, 481356, 478837, 479383, 479878, 480300, 479915, 479925, 479918, 479873, 479951, 480276, 480590], "B": [477549, 478068, 479072, 478755, 478307, 477476, 477775, 478506, 478046, 478017, 478075, 478148, 478475, 478281, 478490, 478605], "A": [477248, 478721, 477778, 478222, 477506, 477190, 477214, 477921, 477275, 477376, 477294, 477359, 477333, 477383, 477417, 477451, 477678]}, "name": "D. Vasya and Types", "statement": "Programmer Vasya is studying a new programming language &K*. The &K*\r\nlanguage resembles the languages of the C family in its syntax. However,\r\nit is more powerful, which is why the rules of the actual C-like\r\nlanguages are unapplicable to it. To fully understand the statement,\r\nplease read the language\u2019s description below carefully and follow it and\r\nnot the similar rules in real programming languages.There is a very\r\npowerful system of pointers on &K* you can add an asterisk to the right\r\nof the existing type that will result in new type . That is called\r\npointer-definition operation. Also, there is the operation that does the\r\nopposite to any type of , which is a pointer, you can add an ampersand\r\nthat will result in a type , to which refers . That is called a\r\ndereference operation.The &K* language has only two basic data types and\r\n. Also, the language has operators and . The operator \"\" defines a new\r\ndata type , which is equivalent to . can have asterisks and ampersands,\r\nand cannot have them. For example, the operator will create a new type ,\r\nthat can be used as . The operator \"\" returns type of , brought to ,\r\nthat is, returns the type , equivalent to it with the necessary number\r\nof asterisks (the number can possibly be zero). That is, having defined\r\nthe type, as shown above, the operator will return .An attempt of\r\ndereferencing of the type will lead to an error: to a special data type\r\n. For the following equation holds true: . An attempt to use the data\r\ntype that hasn\u2019t been defined before that will also lead to the .Using ,\r\nwe can define one type several times. Of all the definitions only the\r\nlast one is valid. However, all the types that have been defined earlier\r\nusing this type do not change.Let us also note that the dereference\r\noperation has the lower priority that the pointer operation, in other\r\nwords is always equal to .Note, that the operators are executed\r\nconsecutively one by one. If we have two operators \"\" and \"\", then at\r\nfirst becomes , and after that becomes , but (see sample 2).Vasya does\r\nnot yet fully understand this powerful technology, that\u2019s why he asked\r\nyou to help him. Write a program that analyzes these operators.\r\n", "solutions": ["#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<map>\nusing namespace std;\nmap<string,int> XD;\nvoid print(int x){\n    if(x==-1)puts(\"errtype\");\n    else{\n\tprintf(\"void\");\n\twhile(x--)printf(\"*\");\n\tputs(\"\");\n    }\n}\nint resolve(string s){\n    int i;\n    for(i=0;s[i]=='&';i++);\n    int dc=i;\n    for(i=s.size()-1;s[i]=='*';i--);\n    int cc=(s.size()-1-i);\n    string tmp=s.substr(dc,i-dc+1);\n    cc-=dc;\n    if(XD.find(tmp)==XD.end())return -1;\n    if(XD[tmp]==-1)return -1;\n    return max(XD[tmp]+cc,-1);\n}\nchar a[1000],b[1000];\nint main(){\n    int q;\n    scanf(\"%d\",&q);\n    XD[\"void\"]=0;\n    XD[\"errtype\"]=-1;\n    while(q--){\n\tchar cmd[10];\n\tscanf(\"%s\",cmd);\n\tif(strcmp(cmd,\"typedef\")==0){\n\t    scanf(\"%s%s\",a,b);\n\t    XD[b]=resolve(a);\n\t}else{\n\t    scanf(\"%s\",a);\n\t    print(resolve(a));\n\t}\n    }\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1800", "interactive": false}