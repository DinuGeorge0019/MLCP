{
    "link": "https://codeforces.com//contest/1255/problem/C",
    "problemId": "475555",
    "problem_idx": "C",
    "shortId": "1255C",
    "contest_number": "1255",
    "problem_submissions": {
        "E1": [
            65376345,
            65362349,
            65379019,
            65379231,
            65381365,
            65366418,
            65380019,
            65372166,
            65377390,
            65381751,
            65383634,
            65381490,
            65380093,
            65389225,
            65369401,
            65379688,
            65378584,
            65380932,
            65379653,
            65385144
        ],
        "E2": [
            65376264,
            65385821,
            65381572,
            65386523,
            65384540,
            65381279,
            65389375,
            65384984,
            65389091,
            65691059,
            65704614,
            65451948
        ],
        "F": [
            65375779,
            65385211,
            65388490,
            65389131,
            65387550,
            65391223,
            65696815,
            65727810,
            65496537
        ],
        "D": [
            65370945,
            65376492,
            65370356,
            65373732,
            65376315,
            65359238,
            65370229,
            65377454,
            65373608,
            65377110,
            65372789,
            65372691,
            65369056,
            65377955,
            65368879,
            65372201,
            65375025,
            65360545,
            65373196
        ],
        "C": [
            65364209,
            65367561,
            65365185,
            65370379,
            65369180,
            65375282,
            65364624,
            65368566,
            65367696,
            65368791,
            65366250,
            65385810,
            65363445,
            65364504,
            65364341,
            65366891,
            65364298,
            65372266,
            65367337
        ],
        "B": [
            65357074,
            65365610,
            65356532,
            65359436,
            65360660,
            65362219,
            65358616,
            65357121,
            65358490,
            65360944,
            65360793,
            65359110,
            65357689,
            65359084,
            65357670,
            65361106,
            65357886,
            65367149,
            65358881
        ],
        "A": [
            65352414,
            65792669,
            65360046,
            65351993,
            65354820,
            65353062,
            65354583,
            65352997,
            65351826,
            65353043,
            65356292,
            65352153,
            65352035,
            65353191,
            65353105,
            65351942,
            65353378,
            65352978,
            65362432,
            65354867
        ]
    },
    "name": "C. League of Leesins",
    "statement": "Bob is an avid fan of the video game \"\", and today he celebrates as the\r\nLeague of Leesins World Championship comes to an end! The tournament\r\nconsisted of n (n\r\nge 5) teams around the world. Before the tournament starts, Bob has made\r\na prediction of the rankings of each team, from 1-st to n-th. After the\r\nfinal, he compared the prediction with the actual result and found out\r\nthat the i-th team according to his prediction ended up at the p_i-th\r\nposition (1\r\nle p_i\r\nle n, all p_i are unique). In other words, p is a permutation of 1, 2,\r\ndots, n.As Bob’s favorite League player is the famous \"\", he decided to\r\nwrite down every 3 consecutive elements of the permutation p. Formally,\r\nBob created an array q of n-2 triples, where q_i = (p_i, p_{i+1},\r\np_{i+2}) for each 1\r\nle i\r\nle n-2. Bob was very proud of his array, so he showed it to his friend\r\nAlice.After learning of Bob’s array, Alice declared that she could\r\nretrieve the permutation p even if Bob rearranges the elements of q and\r\nthe elements within each triple. Of course, Bob did not believe in such\r\nmagic, so he did just the same as above to see Alice’s respond.For\r\nexample, if n = 5 and p = [1, 4, 2, 3, 5], then the original array q\r\nwill be [(1, 4, 2), (4, 2, 3), (2, 3, 5)]. Bob can then rearrange the\r\nnumbers within each triple and the positions of the triples to get [(4,\r\n3, 2), (2, 3, 5), (4, 1, 2)]. Note that [(1, 4, 2), (4, 2, 2), (3, 3,\r\n5)] is not a valid rearrangement of q, as Bob is not allowed to swap\r\nnumbers belong to different triples.As Alice’s friend, you know for sure\r\nthat Alice was just trying to show off, so you decided to save her some\r\nface by giving her p that is consistent with the array q she was given.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nll n, a[101010][4],sudah[101010],ban[101010],jaw[101010],awal,kedua,ketiga;\nvector<ll> v[101010];\nll ada(ll aa, ll bb)\n{\n\treturn (a[aa][1] == bb || a[aa][2] == bb || a[aa][3] == bb);\n}\nll vld(ll aa)\n{\n\tll jum = sudah[a[aa][1]] + sudah[a[aa][2]] + sudah[a[aa][3]];\n\t// cout << jum << \"AB\\n\";\t\n\treturn (jum == 2);\n}\nll cari(ll aa)\n{\n\tif(!sudah[a[aa][1]])return a[aa][1];\n\tif(!sudah[a[aa][2]])return a[aa][2];\n\tif(!sudah[a[aa][3]])return a[aa][3];\n}\nvoid dfs(ll p1, ll p2, ll idx)\n{\n\t// cout << p1 << \" \" << p2 << \" \" << idx << \"\\n\" ;\n\tll nx = 0;\n\tfor(ll i = 0; i < v[p2].size(); i++)\n\t{\n\t\t// if(ada(v[p2][i],p1))\n\t\t\t// cout << v[p2][i] << \" \" << i << \"___\\n\";\n\t\t// if(vld(v[p2][i]))\n\t\t\t// cout << v[p2][i] << \" \" << i << \"_o_\\n\";\n\t\tif(ada(v[p2][i],p1) && vld(v[p2][i]))\n\t\t\tnx = cari(v[p2][i]);\n\t}\n\tsudah[nx] = 1;\n\tjaw[idx] = nx;\n\tif(nx != 0)\n\t\tdfs(p2, nx, idx + 1);\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(ll i = 1; i <= n - 2; i++)\n\t{\n\t\tcin >> a[i][1] >> a[i][2] >> a[i][3];\n\t\tfor(ll j = 1; j <= 3; j++)\n\t\t{\n\t\t\tv[a[i][j]].pb(i);\n\t\t\tban[a[i][j]]++;\n\t\t}\n\t}\t\n\tfor(ll i = 1; i <= n; i++)\n\t\tif(ban[i] == 1)\n\t\t\tawal = i;\n\tll posisi = v[awal][0];\n\t// cout << awal << \"_\\n\";\n\t// cout << posisi << \"_\\n\";\n\tfor(ll i = 1; i <= 3; i++)\n\t\tif(ban[a[posisi][i]] == 2)\n\t\t\tkedua = a[posisi][i];\n\t\telse\n\t\tif(ban[a[posisi][i]] == 3)\n\t\t\tketiga = a[posisi][i];\n\t// cout << kedua << \" \" << ketiga << \"\\n\";\n\tjaw[1] = awal;\n\tjaw[2] = kedua;\n\tjaw[3] = ketiga;\n\tsudah[awal] = 1;\n\tsudah[kedua] = 1;\n\tsudah[ketiga] = 1;\n\t// return 0;\n\tdfs(kedua, ketiga, 4);\n\tfor(ll i = 1; i <= n; i++)\n\t\tcout << jaw[i] << \" \";\n\tcout << \"\\n\";\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. League of Leesins.json",
    "editorial_link": "https://codeforces.com//blog/entry/71594",
    "editorial": "There will be exactly numbers that appear only once in the input and\r\nthey are the first and the last element of the permutation. Let be any\r\nof them and start with the only triple that contains . If are the other\r\nmembers of the mentioned triple, there exists a unique triple that\r\ncontains but not . We can easily find that triple by searching through\r\nevery triple that contains (and there are at most such triples). By\r\nrepeating doing this, we can get a list that .From , we can construct a\r\npermutation that satisfies the problem. Assume we know and , then we can\r\nfind the rest of the permutation easily. To determine which number is ,\r\nwe can use the fact is the only number that only appears in and .\r\n",
    "hint": []
}