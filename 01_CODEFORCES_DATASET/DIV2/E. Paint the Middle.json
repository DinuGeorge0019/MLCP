{
    "link": "https://codeforces.com//contest/1631/problem/E",
    "problemId": "1276006",
    "problem_idx": "E",
    "shortId": "1631E",
    "contest_number": "1631",
    "problem_submissions": {
        "F": [
            144209452,
            144235790,
            144244278,
            144220136,
            144245962,
            145961629,
            144259733,
            144269650
        ],
        "D": [
            144194791,
            144225252,
            144201688,
            144230474,
            144203435,
            144220058,
            144203552,
            144209046,
            144207936,
            144210282,
            144212647,
            144207429,
            144217330,
            144216217,
            144206811,
            144214985,
            144213401,
            144219446,
            144231089,
            144231916
        ],
        "E": [
            144190789,
            144201204,
            144214332,
            144232961,
            144227054,
            144208434,
            144222982,
            144216993,
            144218442,
            144221273,
            144225660,
            144224625,
            144225131,
            144219664,
            144229917,
            144231977,
            144227225,
            144219457,
            144201695
        ],
        "C": [
            144179964,
            144189456,
            144189516,
            144215627,
            144187648,
            144180182,
            144189612,
            144193307,
            144194463,
            144187270,
            144199486,
            144195809,
            144197876,
            144203729,
            144230691,
            144197772,
            144204964,
            144199522,
            144195296,
            144214390
        ],
        "B": [
            144170872,
            144177011,
            144174808,
            144176288,
            144176678,
            144177243,
            144171384,
            144176878,
            144177419,
            144171993,
            144172891,
            144174155,
            144177241,
            144177261,
            144179565,
            144182240,
            144180906,
            144179159,
            144177073,
            144204981
        ],
        "A": [
            144168895,
            144168971,
            144169136,
            144169033,
            144169966,
            144169112,
            144168711,
            144173549,
            144170320,
            144168841,
            144168910,
            144168908,
            144169573,
            144170205,
            144173130,
            144169980,
            144175969,
            144173232,
            144169253,
            144169017
        ]
    },
    "name": "E. Paint the Middle",
    "statement": "You are given n elements numbered from 1 to n, the element i has value\r\na_i and color c_i, initially, c_i = 0 for all i.The following operation\r\ncan be applied: Select three elements i, j and k (1\r\nleq i < j < k\r\nleq n), such that c_i, c_j and c_k are all equal to 0 and a_i = a_k,\r\nthen set c_j = 1. Find the maximum value of\r\nsum\r\nlimits_{i=1}^n{c_i} that can be obtained after applying the given\r\noperation any number of times.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_n = 2e5 + 5;\n\nint a[max_n];\nint last_occurence[max_n];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n; cin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tlast_occurence[a[i]] = i;\n\t}\n\tint latest_occurence = 0, covered = 0, answer = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tlatest_occurence = max(latest_occurence, last_occurence[a[i]]);\n\t\tif (covered > i) answer++;\n\t\telse covered = latest_occurence;\n\t}\n\t\n\tcout << answer << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Paint the Middle.json",
    "editorial_link": "https://codeforces.com//blog/entry/99384",
    "editorial": "For each x\n such that all the elements a1,a2,...,ax\n are different from ax+1,ax+2,...,an\n it is impossible to apply an operation with some indices from the first part, and some other from the second one.\n\nThen it is possible to split the array in subarrays for each x\n such that the previous condition holds, and sum the answers from all of them.\n\nLet's solve the problem independently for one of those subarrays, let's denote its length as m\n, the values of its elements as a1,...,am\n and their colors as c1,...,cm\n:\n\nFor every tuple (x,y,z)\n such that 1?x<y<z?m\n and ax=ay=az\n it is possible to apply an operation with indices x,y\n and z\n. Then only the first and last occurrences of each element are important.\n\nFor all pairs (x,y)\n such that 1?x<y?m\n, ax=ay\n, ax\n is the first occurrence and ay\n the last occurrence of that value, a segment [x,y]\n will be created.\n\nLet's denote the left border of a segment i\n as li\n and the right border as ri\n.\n\nLet's say that a set of segments S\n is connected if the union of its segments is the segment [min(li,?i?S),max(ri,?i?S)]\n.\n\nInstead of maximizing ?i=1mci\n, it is possible to focus on minimizing ?i=1m[ci=0]\n.\n\nLemma 1: If we have a connected set S\n, it is possible to apply some operations to its induced array to end up with at most |S|+1\n elements with ci=0\n.\n\nProof\nLet X\n be a subarray that can be obtained by applying the given operation to the initial subarray any number of times.\n\nLet S(X)\n be the set of segments that includes all segments i\n such that c[li]=0\n or c[ri]=0\n (or both), where c[i]\n is the color of the i\n-th segment of the subarray X\n.\n\nLemma 2: There is always an optimal solution in which S(X)\n is connected.\n\nProof\nFinally, the problem in each subarray can be reduced to find the smallest set (in number of segments), such that the union of its segments is the whole subarray. This can be computed with dp or sweep line."
}