{
    "link": "https://codeforces.com//contest/1828/problem/E",
    "problemId": "1922407",
    "problem_idx": "E",
    "shortId": "1828E",
    "contest_number": "1828",
    "problem_submissions": {
        "E": [
            205928976,
            205900019,
            205882115,
            205895924,
            205892096,
            205891436,
            205893344
        ],
        "F": [
            205895469
        ],
        "D2": [
            205889438,
            205883240,
            205883734,
            205896618,
            206159170,
            205894825,
            205895793,
            205893893,
            205897477,
            227549028,
            205896300
        ],
        "D1": [
            205878026,
            205883337,
            205866040,
            205882122,
            205875506,
            205886552,
            205886122,
            205895740,
            205872312,
            205897439,
            227549130,
            205896247,
            205864334,
            205871289,
            205871040,
            205870968,
            205880756,
            205879364
        ],
        "C": [
            205856261,
            205854711,
            205855088,
            205857693,
            205852246,
            205857010,
            205863890,
            205863938,
            205866888,
            205861344,
            205875792,
            205859789,
            205857545,
            205862873,
            205854617,
            205857622,
            205861133,
            205854364,
            205855992,
            205858999
        ],
        "B": [
            205851848,
            205854227,
            205848826,
            205865189,
            205847163,
            205851029,
            205851540,
            205857305,
            205865622,
            205851306,
            205878139,
            205854556,
            205860197,
            205853496,
            205849725,
            205848581,
            205854845,
            205849749,
            205849027,
            205848392
        ],
        "A": [
            205844206,
            205843332,
            205843301,
            205858624,
            205843073,
            205843188,
            205845089,
            205849854,
            205854254,
            205843004,
            205878944,
            205844207,
            205862200,
            205845877,
            205843927,
            205843783,
            205843659,
            205846739,
            205843197,
            205843308
        ]
    },
    "name": "E. Palindrome Partition",
    "statement": "A is a continuous and non-empty segment of letters from a given string,\r\nwithout any reorders.An is a string that reads the same backward as\r\nforward and has an even length. For example, strings \"\", \"\", \"\" are even\r\npalindromes, but strings \"\", \"\", \"\", \"\" are not.A is an even palindrome\r\nor a string that can be partitioned into some smaller even\r\npalindromes.You are given a string s, consisting of n lowercase Latin\r\nletters. Count the number of of s.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, d, u) for(int i = d; i <= u; ++i)\n#define dep(i, u, d) for(int i = u; i >= d; --i)\n#define cep(n) while(n--)\n#define gep(i, a) for(int i = firs[a]; i; i = neig[i])\nint ured() {\n\tint re = 0;\n\tchar ch;\n\tdo {\n\t\tch = getchar();\n\t} while('9' < ch || ch < '0');\n\tdo {\n\t\tre = re * 10 + (ch ^ '0');\n\t} while('0' <= (ch = getchar()) && ch <= '9');\n\treturn re;\n}\nint sred(char *st) {\n\tint re = 0;\n\tchar ch;\n\tdo {\n\t\tch = getchar();\n\t} while('z' < ch || ch < 'a');\n\tdo {\n\t\tst[++re] = ch;\n\t} while('a' <= (ch = getchar()) && ch <= 'z');\n\treturn re;\n}\nvoid lwit(long long da) {\n\tint ch[21], cn = 0;\n\tdo {\n\t\tch[++cn] = da - da / 10 * 10;\n\t} while(da /= 10);\n\tdo {\n\t\tputchar('0' ^ ch[cn]);\n\t} while(--cn);\n}\nconst int _maxn = 500011, _maxb = 31;\nint t, n, sons[_maxn][_maxb], fail[_maxn], lens[_maxn], coun, latn, mina[_maxn], atpo[_maxn], dpot[_maxn];\nchar s[_maxn];\nlong long rans;\nvoid adds(int at) {\n\twhile(s[at] != s[at - lens[latn] - 1]) {\n\t\tlatn = fail[latn];\n\t}\n\tif(!sons[latn][s[at] - 'a']) {\n\t\tint tn = fail[latn];\n\t\tlens[sons[latn][s[at] - 'a'] = ++coun] = lens[latn] + 2;\n\t\twhile(tn && s[at] != s[at - lens[tn] - 1]) {\n\t\t\ttn = fail[tn];\n\t\t}\n\t\tif(tn) {\n\t\t\tfail[coun] = sons[tn][s[at] - 'a'];\n\t\t} else {\n\t\t\tfail[coun] = 2;\n\t\t}\n\t\trep(i, 0, _maxb - 1) {\n\t\t\tsons[coun][i] = 0;\n\t\t}\n\t}\n\tatpo[at] = latn = sons[latn][s[at] - 'a'];\n}\nint main() {\n\tt = ured();\n\tcep(t) {\n\t\tn = sred(s), lens[fail[coun = 2] = latn = 1] = -1;\n\t\trep(i, 0, _maxb - 1) {\n\t\t\tsons[1][i] = sons[2][i] = 0;\n\t\t}\n\t\trep(i, 1, n) {\n\t\t\tadds(i);\n\t\t}\n\t\tmina[1] = mina[2] = n + 1;\n\t\trep(i, 3, coun) {\n\t\t\tif(lens[i] & 1) {\n\t\t\t\tmina[i] = mina[fail[i]];\n\t\t\t} else {\n\t\t\t\tmina[i] = min(mina[fail[i]], lens[i]);\n\t\t\t}\n\t\t}\n\t\trans = 0;\n\t\trep(i, 1, n) {\n\t\t\tif(mina[atpo[i]] <= i) {\n\t\t\t\trans += dpot[i] = dpot[i - mina[atpo[i]]] + 1;\n\t\t\t} else {\n\t\t\t\tdpot[i] = 0;\n\t\t\t}\n\t\t}\n\t\tlwit(rans), putchar('\\n');\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "hashing",
        "strings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Palindrome Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "For the simplicity of the solution, we will abbreviate even palindrome as evp.\n\nLemma: Consider a beautiful string t\n, we can find the unique maximal partition for it by greedily choosing the smallest possible evp in each step from the left. Here maximal means maximum number of parts.\n\nProof: Suppose t[0..l)\n is smallest prefix which is an evp and t[0..r)\n is the first part in the partition of t\n, here t[l..r)\n mean substring tltl+1Â…tr?1\n. We consider two cases:\n\n2l?r\n: In this case, it is clear that t[0..l)\n, t[l..r?l)\n and t[r?l..r)\n are evps, so we can replace t[0..r)\n with them.\n \n\n2l>r\n: In this case, due to the fact that t[r?l..l)\n and t[0..l)\n are evps, t[0..2l?r)\n is also an evp, which contradicts to above assumption that t[0..l)\n is the smallest.\n \n\nWe can use dynamic programming to solve this problem. Let dpi\n be the number of beautiful substrings starting at i\n. For all i\n from n?1\n to 0\n, if there are such nexti\n satisfying s[i..nexti)\n is the smallest evp beginning at i\n, then dpi=dpnexti+1\n, otherwise dpi=0\n. The answer will be the sum of dpi\n from 0\n to n?1\n.\n\nTo calculate the next\n array, first, we use Manacher algorithm or hashing to find the maximum pali\n satisfying s[i?pali..i+pali)\n is an evp for each i\n. Then for all 0?i<n\n, nexti=2j?i\n where j\n is smallest position such that i<j\n and j?palj?i\n. The time complexity is O(nlogn)\n.",
    "hint": []
}