{"link": "https://codeforces.com//contest/368/problem/E", "problemId": "4095", "problem_idx": "E", "shortId": "368E", "contest_number": "368", "problem_submissions": {"D": [5252865, 5252426, 5251665, 5334474, 5251585, 5252777, 5260757, 5252335, 5253583, 5259466, 5254347, 5253523, 5255767, 5253671], "E": [5252053, 5255848, 5256978, 5251909, 5252817, 5254036, 5288513, 5256603, 5255656, 5255581, 5274020, 5255256, 5253009, 8683220], "C": [5248909, 5248135, 5249034, 5249370, 5251555, 5249219, 5248138, 5249838, 5249117, 5249525, 5247968, 5250778, 5248847, 5251244, 5256331, 5249291, 5250627, 5249292, 5250708], "B": [5245485, 5249539, 5246018, 5245633, 5246363, 24706340, 5245701, 5245338, 5246216, 5244793, 5246247, 5248558, 5245595, 5245649, 5246214, 5247030, 8050443, 5245746, 5247442, 5244992, 5245986], "A": [5244993, 5248655, 5245274, 5244633, 5244658, 5244643, 5244532, 5244844, 5244440, 5244748, 5249113, 5244491, 5246304, 5244770, 5245043, 5244540, 5246183, 6659233, 5244879]}, "name": "E. Sereja and the Arrangement of Numbers", "statement": "Let\u2019s call an array consisting of integer numbers , , , , if it has the\r\nfollowing property: consider all pairs of numbers , such that number\r\noccurs in the array and number occurs in the array ; for each pair must\r\nexist some position , such that at least one of the two conditions are\r\nmet, either , or . Sereja wants to build a beautiful array , consisting\r\nof integers. But not everything is so easy, Sereja\u2019s friend Dima has\r\ncoupons, each contains two integers . Coupon costs and allows you to use\r\nas many numbers as you want when constructing the array . Values are\r\ndistinct. Sereja has no coupons, so Dima and Sereja have made the\r\nfollowing deal. Dima builds some beautiful array of elements. After that\r\nhe takes rubles from Sereja for each , which occurs in the array .\r\nSereja believed his friend and agreed to the contract, and now he is\r\nwondering, what is the maximum amount of money he can pay.Help Sereja,\r\nfind the maximum amount of money he can pay to Dima.\r\n", "solutions": ["/*\n * Package: StandardCodeLibrary.Core\n * */\n//\u5f15\u8fdb\u5e38\u7528\u7684\u5934\u6587\u4ef6\u5e76\u4f7f\u7528std\u540d\u5b57\u7a7a\u95f4;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//\u7528\u4e8e\u51cf\u5c11\u4ee3\u7801\u91cf\u7684\u5b8f;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//\u8c03\u8bd5\u76f8\u5173\u7684\u5b8f;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"\u7b2c\"<<__LINE__<<\"\u884c\\t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//\u5e38\u7528\u6570\u636e\u7c7b\u578b;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//\u5e38\u7528\u5e38\u91cf:int\u7684\u6700\u5927\u503c;lli\u7684\u6700\u5927\u503c;db\u7684\u8bef\u5dee\u76f8\u5173\u5e38\u6570;\u6b27\u62c9\u5e38\u6570;\u5706\u5468\u7387;\u79fb\u52a8\u5411\u91cf;\u53d6\u6a21\u4f7f\u7528\u7684\u9664\u6570;\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//\u5e38\u7528\u51fd\u6570:\u6700\u5927\u6700\u5c0f\u503c\u66f4\u65b0;\u6570\u5b66\u76f8\u5173\u51fd\u6570;\u8f93\u5165\u548c\u8f93\u51fa;\u6811\u72b6\u6570\u7ec4;\u5e76\u67e5\u96c6;\u53ef\u5408\u5e76\u5806;\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ninline lli bin_pow(lli x,lli y){lli z=1;whl(y){if(y&1)z=mod(z*x);x=mod(sqr(x)),y>>=1;}rtn z;}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<\" \"<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?\"\":\" \");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));rrep(i,y){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ninline void make_set(vpii& st){rep(i,sz(st))st[i]=mp(i,1);}\ninline int find_set(vpii& st,int x){int y=x,z;whl(y!=st[y].x)y=st[y].x;whl(x!=st[x].x)z=st[x].x,st[x].x=y,x=z;rtn y;}\ninline bool union_set(vpii& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?(st[a].y>st[b].y?st[a].x=b,st[a].y+=st[b].y:st[b].x=a,st[b].y+=st[a].y),true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//\u521d\u59cb\u5316;\nstruct Initializer{\n#ifndef DEBUG\nInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n~Initializer(){runtime();}\n#endif\n}initializer;\n\n//\u975e\u6807\u51c6;\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx::rope<char> rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tvpii qw(m);\n\tcin>>qw;\n\tvi w(m);\n\trep(i,m) w[i]=qw[i].y;\n\tsrt(w);\n\trev(w);\n\tvl sum(m);\n\trep(i,m)\n\t{\n\t\tif (i) sum[i]=sum[i-1];\n\t\tsum[i]+=w[i];\n\t}\n\tlli ans=0;\n\tft(x,1,m)\n\t{\n\t\tif (x%2==1)\n\t\t{\n\t\t\tif (lli(x)*lli(x-1)/2+1<=n)\n\t\t\t\tans=sum[x-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (lli(x)*lli(x-1)/2+lli(x)/2<=n)\n\t\t\t\tans=sum[x-1];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "graphs", "implementation"], "dificulty": "2000", "interactive": false}