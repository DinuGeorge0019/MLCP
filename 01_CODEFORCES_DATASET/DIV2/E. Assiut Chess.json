{"link": "https://codeforces.com//contest/1557/problem/E", "problemId": "1072436", "problem_idx": "E", "shortId": "1557E", "contest_number": "1557", "problem_submissions": {"E": [125390553, 125390734, 125392343, 125392686, 125431451, 125435877, 125406211, 125406056, 125414773, 125406063], "D": [125366097, 125368312, 125364331, 125365749, 125357934, 125344874, 125362312, 125363710, 125360139, 125365438, 125352274, 125365421, 125369984, 125368368, 125366161, 125468355, 125462031, 125368493, 125372723, 125367940, 125373215, 125366128], "B": [125339476, 125330912, 125327019, 125342138, 125325903, 125329268, 125324623, 125326695, 125334429, 125327128, 125335125, 125326339, 125327891, 125331045, 125330449, 125461492, 125334099, 125330283, 125340978, 125329869, 125325192], "A": [125335099, 125321865, 125321562, 125320952, 125321336, 125323901, 125320479, 125327602, 125322088, 125320782, 125336065, 125321115, 125321768, 125324090, 125325059, 125320563, 125324049, 125322314, 125322780, 125320582], "C": [125325238, 125355338, 125335147, 125349230, 125339333, 125363322, 125341948, 125346131, 125341447, 125343360, 125338074, 125338930, 125334666, 125347698, 125346618, 125348911, 125346966, 125353644, 125345876, 125344725]}, "name": "E. Assiut Chess", "statement": "ICPC Assiut Community decided to hold a unique chess contest, and you\r\nwere chosen to control a queen and hunt down the hidden king, while a\r\nmember of ICPC Assiut Community controls this king.You compete on an 8\r\ntimes8 chessboard, the rows are numerated from top to bottom, and the\r\ncolumns are numerated left to right, and the cell in row x and column y\r\nis denoted as (x, y).In one turn you can move the queen to any of the\r\nsquares on the same horizontal line, vertical line, or any of the\r\ndiagonals. For example, if the queen was on square (4, 5), you can move\r\nto (q_1, 5), (4, q_1), (q_1, 9-q_1), or (q_2, q_2+1) where (1\r\nle q_1\r\nle 8, q_1\r\nne 4, 1\r\nle q_2\r\nle 7, q_2\r\nne 4). Note that the queen stay on its current cell. In one turn, the\r\nking can move \"Right\", \"Left\", \"Up\", \"Down\", \"Down-Right\", \"Down-Left\",\r\n\"Up-Left\", or \"Up-Right\" such that he doesn\u2019t get out of the board. The\r\nking move into a cell that is on the same row, column or diagonal with\r\nthe queen (including the position of the queen itself). For example, if\r\nthe king was on square (4, 5), he can move to (4+k_1, 5+k_2) where (-1\r\nle k_1,k_2\r\nle 1, (k_1, k_2)\r\nne (0, 0)). At the start of the game, you should place the queen at any\r\nlocation on the board, and this is done once per game. After that the\r\nking is secretly placed at any cell different from the queen\u2019s location.\r\nYou do not know the position of the king. Then, the king and the queen\r\ntake turns with the king moving first. The king moves to one of the\r\npossible directions (\"Right\", \"Down\", \"Up-Left\", etc.), and you are only\r\ngiven the direction it moves to. After that, you should move your queen\r\nby declaring the square to which your queen will move. The game follows\r\nlike this until you win the game or run out of moves.You win if the king\r\nhas no valid moves. You lose if after 130 moves of the queen the king\r\nstill has valid moves.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nint cx,cy,is[10][10],cnt,F=0;\nstring res;\nvoid Move(int dx,int dy){\n\tint tmp[10][10]={0};\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)tmp[i+dx][j+dy]=is[i][j];\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=tmp[i][j];\n}\nvoid Make(int x,int y){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)if(i==x||j==y||i+j==x+y||i-j==x-y)is[i][j]=0;\n}\nvoid MoveKing(){\n\tcin>>res;\n\tif(res==\"Left\")Move(0,-1);\n\tif(res==\"Right\")Move(0,1);\n\tif(res==\"Up\")Move(-1,0);\n\tif(res==\"Down\")Move(1,0);\n\tif(res==\"Down-Right\")Move(1,1);\n\tif(res==\"Down-Left\")Move(1,-1);\n\tif(res==\"Up-Right\")Move(-1,1);\n\tif(res==\"Up-Left\")Move(-1,-1);\n\tif(res==\"Done\")F=1;\n}\nvoid Min(int &x,int &y,int tox,int toy){\n\tint mn=1e9;\n\tfor(int i=1;i<=8;i++)\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tif(i==cx||j==cy||i+j==cx+cy||i-j==cx-cy){\n\t\t\t\tif(!(i==cx&&j==cy)){\n\t\t\t\t\tif(abs(i-tox)+abs(j-toy)<mn)mn=abs(i-tox)+abs(j-toy),x=i,y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nvoid Solve(){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=(i-1)*8+j;\n\tcx=1,cy=1,cnt=0,F=0;\n\tcout<<cx<<' '<<cy<<endl,cnt++,MoveKing();\n\tif(F)return ;\n\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<' ';\n//\t\t\t\t}\n//\t\t\t\tputs(\"\");\n//\t\t\t}\n\twhile(1){\n\t\tint w=0;\n\t\tfor(int i=1;i<=8;i++){\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tif(is[i][j])w=is[i][j];\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint p=0,q=0;\n\t\t\tfor(int i=1;i<=8;i++){\n\t\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\t\tif(is[i][j]==w)p=i,q=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!p)break;\n\t\t\tint tx,ty;\n\t\t\tMin(tx,ty,p,q);\n\t\t\tcx=tx,cy=ty;\n\t\t\t//cout<<\"w:\"<<w<<endl;\n\t\t\tcout<<cx<<' '<<cy<<endl,cnt++,assert(cnt<=130),MoveKing();\n\t\t\tif(F)return ;\n\t\t\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<' ';\n//\t\t\t\t}\n//\t\t\t\tputs(\"\");\n//\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--)Solve();\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "interactive"], "dificulty": "2800", "interactive": false}