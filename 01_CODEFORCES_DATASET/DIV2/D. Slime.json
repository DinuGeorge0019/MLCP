{"link": "https://codeforces.com//contest/1038/problem/D", "problemId": "216024", "problem_idx": "D", "shortId": "1038D", "contest_number": "1038", "problem_submissions": {"F": [42582709, 42588924], "E": [42575080, 42578573, 42575208, 42576431, 42577789, 42580719, 42575666, 42580571, 42583311, 42581396, 42582088, 42580954, 42583334, 42579643, 42582008, 42580920, 42583129, 42582580, 42583754], "D": [42573485, 42569896, 42569634, 42567012, 42572149, 42570113, 42576120, 42571013, 42565752, 42571052, 42574327, 42570312, 42567294, 42575127, 42575057, 42572394, 42574539, 42573852, 42573051], "C": [42566710, 42563399, 42564810, 42563947, 42567501, 42564966, 42562683, 42566829, 42562396, 42564608, 42563976, 42565121, 42570852, 42564983, 42565516, 42568404, 42566048, 42568514, 42566544], "B": [42560979, 42561635, 42561921, 42561073, 42563881, 42561586, 42565172, 42563091, 42560475, 42561602, 42561362, 42562336, 42564791, 42568121, 42563027, 42564081, 42563007, 42563149, 42562895], "A": [42559251, 42559046, 42559189, 42559233, 42563411, 42559174, 42559467, 42559825, 42558982, 42559283, 42559010, 42559078, 42560087, 42561636, 42561187, 42559807, 42559670, 42559820, 42559436]}, "name": "D. Slime", "statement": "There are n slimes in a row. Each slime has an integer value (possibly\r\nnegative or zero) associated with it.Any slime can eat its adjacent\r\nslime (the closest slime to its left or to its right, assuming that this\r\nslime exists). When a slime with a value x eats a slime with a value y,\r\nthe eaten slime disappears, and the value of the remaining slime changes\r\nto x - y.The slimes will eat each other until there is only one slime\r\nleft. Find the maximum possible value of the last slime.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nLL read(){LL x; scanf(\"%lld\", &x); return x;}\nvoid read(char *s){scanf(\"%s\", s);}\nvoid no(){printf(\"No\"); exit(0);}\n\n#define maxn 540000\n#define maxm\n\nLL a[maxn];\nint main(){\n\tLL ans = 0, mx = 1E10;\n\tint flag = 0;\n\tint n = read();\n\tfor(int i = 0; i < n; i += 1){\n\t\ta[i] = read();\n\t\tans += abs(a[i]);\n\t\tmx = min(mx, abs(a[i]));\n\t\tif(a[i] <= 0) flag |= 1;\n\t\tif(a[i] >= 0) flag |= 2;\n\t}\n\tif(n == 1) printf(\"%lld\", a[0]);\n\telse printf(\"%lld\", flag == 3 ? ans : ans - 2 * mx);\n}"], "input": "", "output": "", "tags": ["dp", "greedy", "implementation"], "dificulty": "1800", "interactive": false}