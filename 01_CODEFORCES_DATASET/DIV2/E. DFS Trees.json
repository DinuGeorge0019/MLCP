{
    "link": "https://codeforces.com//contest/1708/problem/E",
    "problemId": "1465651",
    "problem_idx": "E",
    "shortId": "1708E",
    "contest_number": "1708",
    "problem_submissions": {
        "E": [
            164526365,
            164509978,
            164525791,
            164525144,
            164515105,
            164526880,
            164565405
        ],
        "D": [
            164483082,
            164475794,
            164498322,
            164502919,
            164500499,
            164493036,
            164483535,
            164489653,
            164492932,
            164487483,
            164496395,
            164492041,
            164496037,
            164494420,
            164494528,
            164500816,
            164498429,
            164498353,
            164501077
        ],
        "C": [
            164476151,
            164486488,
            164480189,
            164506917,
            164526449,
            164483780,
            164470946,
            164474613,
            164471073,
            164464598,
            164477489,
            164480460,
            164478377,
            164479833,
            164476392,
            164474668,
            164479091,
            164477458,
            164469257
        ],
        "B": [
            164463973,
            164514329,
            164488244,
            164465324,
            164492077,
            164499834,
            164464194,
            164460225,
            164462182,
            164458987,
            164462805,
            164471454,
            164467808,
            164468216,
            164463689,
            164461529,
            164464211,
            164467907,
            164461028
        ],
        "A": [
            164463865,
            164513385,
            164484667,
            164457212,
            164489629,
            164494393,
            164457849,
            164457193,
            164457578,
            164456205,
            164457572,
            164457666,
            164458662,
            164460280,
            164458147,
            164456758,
            164456563,
            164456719,
            164456652
        ]
    },
    "name": "E. DFS Trees",
    "statement": "You are given a connected undirected graph consisting of n vertices and\r\nm edges. The weight of the i-th edge is i.Here is a wrong algorithm of\r\nfinding a minimum spanning tree (MST) of a graph:vis := an array of\r\nlength ns := a set of edgesfunction dfs(u): vis[u] := true iterate\r\nthrough each edge (u, v) in the order from smallest to largest edge\r\nweight if vis[v] = false add edge (u, v) into the set (s) dfs(v)function\r\nfindMST(u): reset all elements of (vis) to false reset the edge set (s)\r\nto empty dfs(u) return the edge set (s)Each of the calls , , ..., gives\r\nyou a spanning tree of the graph. Determine which of these trees are\r\nminimum spanning trees.\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 2e5 + 5)\n\nint n, m;\npii ee[N]; bool b[N];\nvector<pii > e[N];\nint dfn[N], sz[N], tot;\nint fa[N], dep[N], f[N][21];\nint dif[N];\n\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n\nvoid dfs(int u, int Fa) {\n\tdfn[u] = ++tot;\n\tsz[u] = 1;\n\tdep[u] = dep[Fa] + 1;\n\tf[u][0] = Fa;\n\trep(i, 1, 20) f[u][i] = f[f[u][i - 1]][i - 1];\n\tfor(pii x : e[u]) if(!x.se && x.fi != Fa) {\n\t\tdfs(x.fi, u);\n\t\tsz[u] += sz[x.fi];\n\t}\n}\n\nint LCA(int x, int y) {\n\tif(dep[x] < dep[y]) swap(x, y);\n\tint t = dep[x] - dep[y];\n\trep(i, 0, 20) if(t & (1 << i)) x = f[x][i];\n\tif(x == y) return x;\n\tper(i, 20, 0) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];\n\treturn f[x][0];\n}\n\nint get(int x, int d) {\n\tper(i, 20, 0) if(dep[f[x][i]] > d) x = f[x][i];\n\treturn x;\n}\n\nint main() {\n\tqread(n, m);\n\trep(i, 1, n) fa[i] = i;\n\trep(i, 1, m) {\n\t\tint u, v;\n\t\tqread(u, v);\n\t\tee[i] = mp(u, v);\n\t\tint fx = find(u), fy = find(v);\n\t\tif(fx != fy) {\n\t\t\tfa[fy] = fx;\n\t\t\te[u].pb(mp(v, 0)), e[v].pb(mp(u, 0));\n\t\t\tb[i] = 1;\n\t\t}\n\t\telse e[u].pb(mp(v, 1)), e[v].pb(mp(u, 1));\n\t}\n\tdfs(1, 0);\n\trep(i, 1, m) if(!b[i]) {\n\t\tint u = ee[i].fi, v = ee[i].se, l = LCA(u, v);\n\t\tif(u != l && v != l) {\n\t\t\t++dif[dfn[u]], --dif[dfn[u] + sz[u]];\n\t\t\t++dif[dfn[v]], --dif[dfn[v] + sz[v]];\n\t\t}\n\t\telse {\n\t\t\tif(v == l) swap(u, v);\n\t\t\t++dif[dfn[v]], --dif[dfn[v] + sz[v]];\n\t\t\tint t = get(v, dep[u]);\n\t\t\t++dif[1], --dif[dfn[t]];\n\t\t\t++dif[dfn[t] + sz[t]];\n\t\t}\n\t}\n\trep(i, 1, n) dif[i] += dif[i - 1];\n\trep(i, 1, n) cout << (dif[dfn[i]] == m - n + 1);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. DFS Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/104930",
    "editorial": "Minimum spanning tree is unique in the given graph.\n\nIf findMST\n(x) creates an MST, there is no cross edge in the graph. So if you can determine whether there is a cross edge starting DFS from every node, the problem is solved.\n\nPay attention to every edge that is not in the MST. Let's focus on one single edge (u,v)\n and see starting DFS from which node, (u,v)\n is a cross edge. Take the following graph as an example.\n\n\n\nIf we start from nodes a\n, b\n, c\n, d\n, e\n or f\n, (u,v)\n is a cross edge. If we start from nodes t\n, u\n, o\n or v\n, (u,v)\n is not a cross edge. We can find that when considering u\n as the root of the tree, o\n and v\n are on the subtree of v\n. When considering v\n as the root of the tree, t\n and u\n are on the subtree of u\n.\n\nSo if an edge (u,v)\n is not in the MST, only the subtree of u\n(u\n included, when considering v\n as the root) and the subtree of v\n(v\n included, when considering u\n as the root) can be answers. We just need to do this process for each edge not in the MST. After that we can get the answers.\n\nWe can finish the process in O(nlogn)\n with bin-up on tree and BIT or in O(n)\n with some case work while dfs."
}