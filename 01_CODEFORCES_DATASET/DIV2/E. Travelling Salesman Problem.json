{
    "link": "https://codeforces.com//contest/1504/problem/E",
    "problemId": "945467",
    "problem_idx": "E",
    "shortId": "1504E",
    "contest_number": "1504",
    "problem_submissions": {
        "F": [
            111935045
        ],
        "E": [
            111919537,
            111908818,
            111915476,
            111922174,
            111919354,
            111912277,
            111926667,
            111933626,
            111923368,
            111927972,
            111922895,
            111929837,
            111918921,
            111930705,
            111931199,
            111927831,
            111933167,
            111936231,
            111927723
        ],
        "D": [
            111903831,
            111898035,
            111906622,
            111906753,
            111900341,
            111920726,
            111905882,
            111889202,
            111908288,
            111906401,
            111899954,
            111909419,
            111914558,
            111906091,
            111907496,
            111910516,
            111906791,
            111899242,
            111913796
        ],
        "C": [
            111894612,
            111888998,
            111897074,
            111891045,
            111894960,
            111894678,
            111893967,
            111898677,
            111898779,
            111894676,
            111891710,
            111887088,
            111899272,
            111894062,
            111898183,
            111901135,
            111896065,
            111907589,
            111899883
        ],
        "B": [
            111886123,
            111877937,
            111882311,
            111876691,
            111883851,
            111877415,
            111875995,
            111877870,
            111879515,
            111885430,
            111904265,
            111879266,
            111878112,
            111883768,
            111877486,
            111882773,
            111887115,
            111878394,
            111891154
        ],
        "A": [
            111877837,
            111872895,
            111873662,
            111872585,
            111875452,
            111883020,
            111872169,
            111872988,
            111873021,
            111873751,
            111907400,
            111872188,
            111872713,
            111872621,
            111882814,
            111875730,
            111872954,
            111872953,
            111883462
        ]
    },
    "name": "E. Travelling Salesman Problem",
    "statement": "There are n cities numbered from 1 to n, and city i has beauty a_i.A\r\nsalesman wants to start at city 1, visit every city exactly once, and\r\nreturn to city 1.For all i\r\nne j, a flight from city i to city j costs\r\nmax(c_i,a_j-a_i) dollars, where c_i is the price floor enforced by city\r\ni. Note that there is no absolute value. Find the minimum total cost for\r\nthe salesman to complete his trip.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n    char ch;\n    while(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n    if (ch=='-'){\n        int s=0;\n        while(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n        return -s;\n    }\n    int s=ch-'0';\n    while(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n    return s;\n}\n\nconst int N = 2e5+5;\n\nint n;\nint a[N],c[N];\nint num[N];\n\nbool cmp(int x,int y){return a[x]<a[y];}\n\nstruct point{\n    int x,tag;\n    point(const int x_=0,const int tag_=0){x=x_;tag=tag_;}\n    friend bool operator <(point a, point b){\n        return a.x!=b.x?a.x<b.x:a.tag<b.tag;\n    }\n}u[N];\nint k;\n\nint main(){\n    n=get();\n    fo(i,1,n){\n        a[i]=get();\n        c[i]=get();\n        num[i]=i;\n    }\n    sort(num+1,num+1+n,cmp);\n    LL ans=0;\n    fo(i,1,n)ans=ans+c[i];\n    k=0;\n    fo(i,1,n){\n        u[++k]=point(a[i],0);\n        u[++k]=point(a[i]+c[i],1);\n    }\n    int cnt=0;\n    sort(u+1,u+1+k);\n    fo(i,1,k-1)\n    if (u[i].tag){\n        cnt--;\n        if (cnt==0)ans=ans+u[i+1].x-u[i].x;\n    }\n    else cnt++;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "graphs",
        "greedy",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Travelling Salesman Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/89319",
    "editorial": "Letâs reindex the cities so they are in increasing order of beauty. Note\r\nthat it doesnât matter which city we call the start: the trip will be a\r\ncycle visiting every city exactly once.Letâs rewrite the cost of a\r\nflight as Since we always need to leave each city exactly once, we can\r\nignore the term from all flights and only try to minimize the sum of\r\nNote that a flight to a city of smaller beauty is always free in the\r\nadjusted cost. So all we need is a path from to , and the rest of the\r\ntrip can be done for free. Also, any valid trip will contain a path from\r\nto , so the shortest path is optimal.All we have to do is encode the\r\ngraph without storing all edges explicitly, and we can simply run\r\nDijkstraâs algorithm to find the shortest path. Add the following edges:\r\nwith weight . with weight , where is the largest index with . The index\r\ncan be found with binary search. with weight where is the same as\r\nbefore. Every edge in this new graph corresponds to an edge in the\r\noriginal graph, and every edge in the original graph corresponds to a\r\npath in the new graph with at most the same cost. So the distance from\r\nto is preserved.A simpler solution is to compute for all , the minimum\r\npossible cost of the first trip reaching or larger. Itâs easy to see\r\nthat any path must have at least this cost, and we can construct a path\r\nof this cost since moving to smaller is free. It corresponds to the\r\nfollowing summation.Complexity is .\r\n",
    "hint": []
}