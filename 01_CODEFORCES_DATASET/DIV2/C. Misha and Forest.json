{
    "link": "https://codeforces.com//contest/501/problem/C",
    "problemId": "20654",
    "problem_idx": "C",
    "shortId": "501C",
    "contest_number": "501",
    "problem_submissions": {
        "D": [
            9410957,
            9411339,
            9411793,
            9412714,
            9412830,
            9413378,
            9413495,
            9413859,
            9416597,
            9414226,
            9414777,
            9414880,
            9414082,
            9414871,
            9413282,
            9414476,
            9414234,
            9413065,
            9413605,
            9413446,
            9414020
        ],
        "C": [
            9409710,
            9412812,
            9409915,
            9410635,
            9411145,
            9410890,
            9410381,
            9411803,
            9411723,
            9411491,
            9410908,
            9413785,
            9412825,
            9408972,
            9410063,
            9413464,
            9416221,
            9416007
        ],
        "B": [
            9408651,
            9408711,
            9412680,
            9409222,
            9408915,
            9408969,
            9409184,
            9409368,
            9409570,
            9409614,
            9412592,
            9408622,
            9409821,
            9442325,
            9413740,
            9410394,
            9410355,
            9410485
        ],
        "A": [
            9407105,
            9407522,
            9412385,
            9407579,
            9407165,
            9407296,
            9407604,
            9407397,
            9407151,
            9407485,
            9407144,
            9407155,
            9408421,
            9441866,
            9414917,
            9414709,
            9407354,
            9407430,
            9407583,
            9409049
        ],
        "E": [
            9423665,
            9415217
        ]
    },
    "name": "C. Misha and Forest",
    "statement": "Let’s define a forest as a non-directed acyclic graph (also without\r\nloops and parallel edges). One day Misha played with the forest\r\nconsisting of vertices. For each vertex from to he wrote down two\r\nintegers, and , were the first integer is the number of vertices\r\nadjacent to vertex , and the second integer is the XOR sum of the\r\nnumbers of vertices adjacent to (if there were no adjacent vertices, he\r\nwrote down ). Next day Misha couldn’t remember what graph he initially\r\nhad. Misha has values and left, though. Help him find the number of\r\nedges and the edges of the initial graph. It is guaranteed that there\r\nexists a forest that corresponds to the numbers written by Misha.\r\n",
    "solutions": [
        "/*\n    Look at me!\n    Look at me!\n    Look at how large the monster inside me has become!\n*/\n\n#include<fstream>\n#include<iostream>\n#include<cstdio>\n#include<map>\n#include<set>\n#define FIT(a,b) for(vector<int >::iterator a=b.begin();a!=b.end();a++)\n#define FITP(a,b) for(vector<pair<int,int> >::iterator a=b.begin();a!=b.end();a++)\n#define RIT(a,b) for(vector<int>::reverse_iterator a=b.end();a!=b.begin();++a)\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#define REP(a,b) for(register int a=0;a<b;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<ctime>\n#define f cin\n#define g cout\n#include<queue>\n#define debug cerr<<\"OK\";\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define ull unsigned long long\n#define mod 666013\n#define inf 1<<30\n#define N 2000100\n#define DIM 10000000\nusing namespace std;\n/*int dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};*/\n\nqueue<int> q;\nvector<pii > ed;\nint n,a,b,viz[N],x,gr[N],val[N];\n\nint main ()\n{\n\n    #ifndef ONLINE_JUDGE\n    freopen(\"a.in\",\"r\",stdin);\n    freopen(\"a.out\",\"w\",stdout);\n    #endif\n\n    f>>n;\n    REP(i,n)\n    {\n        f>>a>>b;\n        gr[i]=a;\n        val[i]=b;\n    }\n    REP(i,n)\n    if(gr[i]==1)\n    {\n        q.push(i);\n        viz[i]=1;\n    }\n    while(!q.empty())\n    {\n        x=q.front();\n        q.pop();\n        if(!gr[x])\n        {\n            continue;\n        }\n        ed.pb(mp(x,val[x]));\n        val[val[x]]^=x;\n        gr[val[x]]--;\n        if(gr[val[x]]==1&&!viz[val[x]])\n        {\n            viz[val[x]]=1;\n            q.push(val[x]);\n        }\n\n    }\n    g<<ed.size()<<\"\\n\";\n    FITP(it,ed)\n    g<<it->fi<<\" \"<<it->se<<\"\\n\";\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Misha and Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/15743",
    "editorial": "Note that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev,?sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v,?sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.\n\nWhen dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.",
    "hint": []
}