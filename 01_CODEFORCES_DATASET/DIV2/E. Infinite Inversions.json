{"link": "https://codeforces.com//contest/540/problem/E", "problemId": "26990", "problem_idx": "E", "shortId": "540E", "contest_number": "540", "problem_submissions": {"E": [10950082, 10942556, 10951035, 10952383, 10951664, 10948964, 10952277, 10951669, 10951944, 10983800, 10953155, 11577591, 10950708, 10959502, 10959369, 10949750, 10950320, 10951075, 10955881, 10955706, 10948813], "D": [10947922, 10944160, 10947124, 10947070, 10947798, 10941308, 10948944, 10944336, 10946886, 10946947, 10949570, 10959819, 10950615, 10948080, 10945713, 10950893, 10948099, 10946895, 10951818], "C": [10944700, 10945032, 10944296, 10945350, 10951612, 10946322, 10949663, 10954145, 10962540, 10944690, 10944805, 10959319, 10950587, 10948967, 10953843, 10947752, 10960817, 10948058, 10945550], "B": [10942652, 10942383, 10948312, 10942705, 10949878, 10942945, 10950444, 10942965, 10962010, 10943162, 10942463, 10958996, 10943265, 10953368, 10944155, 10957408, 10953391, 10944270, 10952996], "A": [10940515, 10940359, 10941183, 10940296, 10949371, 10940424, 10950781, 10940505, 10961698, 10940642, 10940766, 10947479, 10940747, 10940350, 10941583, 10943114, 10940385, 10940561, 10940442]}, "name": "E. Infinite Inversions", "statement": "There is an infinite sequence consisting of all positive integers in the\r\nincreasing order: . We performed operations with this sequence. A is an\r\noperation of swapping the elements of the sequence on positions and .\r\nYour task is to find the number of inversions in the resulting sequence,\r\ni.e. the number of such index pairs , that and .\r\n", "solutions": ["#include<bits/stdc++.h>\n#define sz(x) int((x).size())\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> PII;\ntypedef std::pair<ll,ll> PLL;\n\ntemplate<class T> inline T pr(T x) { return --x; }\ntemplate<class T> inline T nx(T x) { return ++x; }\n\nconst int maxn = 200010;\nint n,a[maxn],b[maxn];\nvector<int> x,y;\nunordered_map<int,int> id;\n\nconst int T_maxn = maxn*2;\nstruct Trray {\n\tint c[T_maxn+10];\n\tinline int bit(int x) { return x&(-x); }\n\tinline void clr() { memset(c,0,sizeof(c)); }\n\tint add(int i,int k) {\n\t\tfor (; i<=T_maxn; i+=bit(i)) c[i] += k;\n\t}\n\tint pf(int i) {\n\t\tif (i<=0) return 0;\n\t\tint r = 0;\n\t\tfor (; i; i-=bit(i)) r += c[i];\n\t\treturn r;\n\t}\n\tinline int get(int i,int j) { return i>j?0:pf(j)-pf(i-1); }\n}ta;\n\nint main() {\n    int i,j,k,t,tt,T,Test;\n    scanf(\"%d\",&n);\n    for (i=1; i<=n; ++i) {\n        scanf(\"%d%d\",a+i,b+i);\n        x.push_back(a[i]); x.push_back(b[i]);\n    }\n    sort(x.begin(),x.end());\n    x.resize( unique(x.begin(),x.end()) - x.begin() );\n    for (i=0; i<sz(x); ++i) y.push_back(i);\n    for (i=1; i<=n; ++i) {\n        a[i] = lower_bound(x.begin(),x.end(),a[i]) - x.begin();\n        b[i] = lower_bound(x.begin(),x.end(),b[i]) - x.begin();\n        swap(y[a[i]],y[b[i]]);\n    }\n    ll ans = 0;\n    for (int e:y) {\n        ans += (ll)ta.get(e+2,sz(y));\n        ta.add(e+1,1);\n    }\n    for (i=0; i<sz(x); ++i) {\n        if (y[i]<i) {\n            t = x[i]-1-x[y[i]]-(i-y[i]-1);\n            ans += (ll)t;\n        }\n        else if (y[i]>i) {\n            ans += (ll)(t=x[y[i]]-x[i]-1-(y[i]-i-1));\n        }\n    }\n    printf(\"%I64d\\n\",ans);\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "implementation", "sortings", "trees"], "dificulty": "2100", "interactive": false}