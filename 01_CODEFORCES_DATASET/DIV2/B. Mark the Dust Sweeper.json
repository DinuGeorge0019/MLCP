{
    "link": "https://codeforces.com//contest/1705/problem/B",
    "problemId": "1463489",
    "problem_idx": "B",
    "shortId": "1705B",
    "contest_number": "1705",
    "problem_submissions": {
        "E": [
            164313678,
            164283877,
            164322922,
            164296635,
            164328190,
            164330200,
            182244316,
            164662858,
            164301911,
            164382357,
            164307832,
            164311215,
            164877717,
            164877334,
            164877248,
            164876250,
            164876123,
            164311471,
            164312217,
            164309954,
            164307210,
            164313972,
            164313748
        ],
        "F": [
            164297533,
            164313413,
            164317453,
            164328892,
            164293393,
            164327045,
            164284621,
            164284133,
            164291743,
            164302194,
            165132539,
            164348710,
            164323281,
            164391921
        ],
        "D": [
            164286707,
            164304717,
            164280506,
            164282817,
            164306344,
            164300946,
            164312628,
            164317244,
            164662848,
            164319640,
            164284384,
            164325926,
            164285658,
            164285757,
            164290551,
            164293318,
            164291394,
            164299908,
            164293093,
            164301425,
            164291705
        ],
        "C": [
            164281860,
            164296877,
            164275420,
            164273360,
            164295006,
            164295319,
            164301269,
            164662833,
            164288918,
            164274715,
            164280149,
            164277014,
            164275688,
            165102447,
            164283971,
            164282615,
            164282594,
            164274835,
            164277444,
            164285515,
            164285435
        ],
        "B": [
            164273413,
            164289760,
            164270705,
            164266717,
            164276123,
            164275997,
            164276303,
            164274236,
            164662822,
            164269128,
            164268180,
            164273865,
            164270610,
            164270505,
            164271837,
            164271931,
            164276822,
            164279085,
            164272358,
            164272892,
            164272828
        ],
        "A": [
            164266986,
            164279867,
            164266709,
            164265172,
            164267444,
            164266906,
            164267475,
            164265741,
            164662806,
            164278230,
            164265167,
            164265698,
            164265336,
            164266101,
            164266312,
            164265878,
            164265963,
            164265319,
            164267659,
            164267039,
            164266626
        ]
    },
    "name": "B. Mark the Dust Sweeper",
    "statement": "Mark is cleaning a row of n rooms. The i-th room has a nonnegative dust\r\nlevel a_i. He has a magical cleaning machine that can do the following\r\nthree-step operation. Select two indices i<j such that the dust levels\r\na_i, a_{i+1},\r\ndots, a_{j-1} are all strictly greater than 0. Set a_i to a_i-1. Set a_j\r\nto a_j+1. Mark’s goal is to make a_1 = a_2 =\r\nldots = a_{n-1} = 0 so that he can nicely sweep the n-th room. Determine\r\nthe minimum number of operations needed to reach his goal.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200020\ntypedef long long ll;\nint n,a[N];\nvoid Solve(){\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t}\n\tll ans=0;\n\tbool jb=0;\n\tfor(int i=1;i<n;++i){\n\t\tif(a[i]>0){\n\t\t\tjb=1;\n\t\t\tans+=a[i];\n\t\t}\n\t\telse{\n\t\t\tif(jb)++ans;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T--)Solve();\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Mark the Dust Sweeper.json",
    "editorial_link": "https://codeforces.com//blog/entry/104881",
    "editorial": "TutorialDelete the leading zeroes in the array (i.e., the first numbers\r\nof that are zero) so that now . Let be the number of âs in . The answer\r\nis To see why, let Mark keep filling the holes (rooms with dust level )\r\nfirst by subtracting the first nonzero index and changing the first zero\r\nindex to . This takes moves to fill all zeroes in . Then, we can start\r\nmoving, from left to right, all dust to the -th room, taking\r\nmoves.Finally, we argue that this is the minimum number of moves. To\r\nthat end, we prove that each move decreases the answer by at most . We\r\nconsider two cases. If a move has , then it decreases by but does not\r\ndecrease . If , then the move doesnât decrease and decreases by at most\r\n. Thus, we are done. The time complexity is .\r\n",
    "hint": [
        "Hint The optimal way is to fill all the zero entries first."
    ]
}