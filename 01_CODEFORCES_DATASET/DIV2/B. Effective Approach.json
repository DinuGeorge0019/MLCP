{"link": "https://codeforces.com//contest/227/problem/B", "problemId": "1846", "problem_idx": "B", "shortId": "227B", "contest_number": "227", "problem_submissions": {"E": [2244819], "D": [2241285, 2242789, 2243651, 2244494, 2243976, 2245494, 2243333, 2241816, 2243438, 2243253, 2243591, 2242751, 2243506, 2242179, 2244374, 2241750, 2242474], "C": [2239263, 2240482, 2239762, 2242318, 2239042, 2240039, 2244041, 2239823, 2241928, 2239774, 2240494, 2241415, 2240378, 2239721, 2241369, 2239346, 2243306, 2238534], "B": [2238261, 2239265, 2238668, 2237700, 2237709, 2238241, 2238220, 2238145, 2238505, 2238087, 2238895, 2238677, 2239004, 2238928, 2237401, 2238043, 2239611, 2237944], "A": [2237402, 2238048, 2237808, 2237346, 2237343, 2240757, 2237508, 2237496, 2237858, 2237476, 2237431, 2237540, 2237592, 2241472, 2243917, 2237478, 2237575]}, "name": "B. Effective Approach", "statement": "Once at a team training Vasya, Petya and Sasha got a problem on\r\nimplementing linear search in an array.According to the boys, linear\r\nsearch works as follows. The array elements in a pre-selected order are\r\nin turn compared with the number that you need to find. Once you find\r\nthe array element that is equal to the required one, the search ends.\r\nThe efficiency of the algorithm is the number of performed comparisons.\r\nThe fewer comparisons the linear search has made, the more effective it\r\nis.Vasya believes that a linear search would work better if it\r\nsequentially iterates through the elements, starting with the -st one\r\n(in this problem we consider the elements of the array indexed from to )\r\nand ending with the -th one. And Petya says that Vasya is wrong: the\r\nsearch will need less comparisons if it sequentially iterates the\r\nelements starting from the -th and ending with the -st one. Sasha argues\r\nthat the two approaches are equivalent.To finally begin the task, the\r\nteammates decided to settle the debate and compare the two approaches on\r\nan example. For this, they took an array that is a permutation of\r\nintegers from to , and generated queries of the form: find element with\r\nvalue in the array. They want to calculate for both approaches how many\r\ncomparisons in total the linear search will need to respond to all\r\nqueries. If the first search needs fewer comparisons, then the winner of\r\nthe dispute is Vasya. If the second one does, then the winner is Petya.\r\nIf both approaches make the same number of comparisons, then Sasha\u2019s got\r\nthe upper hand.But the problem is, linear search is too slow. That\u2019s why\r\nthe boys aren\u2019t going to find out who is right before the end of the\r\ntraining, unless you come in here. Help them to determine who will win\r\nthe dispute.\r\n", "solutions": ["#include<iostream>\n\nusing namespace std;\n\nlong long n,m,s1,s2,i,a[100021],b[100021],pos[100021];\n\nint main()\n{\n    cin>>n;\n    for (i=0;i<n;i++)\n    {\n        cin>>a[i];\n        pos[a[i]]=i;\n    }\n    cin>>m;\n    for (i=0;i<m;i++) cin>>b[i];\n    s1=0;s2=0;\n    for (i=0;i<m;i++)\n    {\n        s1+=pos[b[i]]+1;\n        s2+=n-pos[b[i]];\n    }\n    cout<<s1<<\" \"<<s2<<endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1100", "interactive": false}