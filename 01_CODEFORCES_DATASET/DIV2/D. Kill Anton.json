{
    "link": "https://codeforces.com//contest/1526/problem/D",
    "problemId": "998298",
    "problem_idx": "D",
    "shortId": "1526D",
    "contest_number": "1526",
    "problem_submissions": {
        "F": [
            117674501,
            117718090
        ],
        "E": [
            117641265,
            117622832,
            117632917,
            117655078,
            117650360,
            117639127,
            117655021,
            117622676,
            117655327,
            117632538,
            117657710,
            117639481,
            117666815,
            117667694,
            117675419,
            117641336,
            117667368,
            117663164,
            117676666,
            117665783
        ],
        "D": [
            117632533,
            117637660,
            117642436,
            117623173,
            117637988,
            117639630,
            117639808,
            117654338,
            117642482,
            117656737,
            117641555,
            117661726,
            117632865,
            117643854,
            117639700,
            117671596,
            117639266,
            117649770,
            117640101,
            117649235
        ],
        "C2": [
            117607723,
            117607154,
            117602271,
            117601746,
            117613546,
            117613022,
            117607432,
            117606655,
            117614092,
            117605064,
            117613264,
            117601205,
            117618975,
            117612210,
            117617886,
            117613492,
            117619366,
            117636680,
            117605737,
            117632479
        ],
        "C1": [
            117607362,
            117607834,
            117601722,
            117602159,
            117613090,
            117613322,
            117607889,
            117607044,
            117614454,
            117603816,
            117613790,
            117601639,
            117616576,
            117603874,
            117618238,
            117612867,
            117619659,
            117635895,
            117606026,
            117617120
        ],
        "B": [
            117601602,
            117610780,
            117595803,
            117598275,
            117596391,
            117609017,
            117598567,
            117600812,
            117600764,
            117618105,
            117599167,
            117612003,
            117600763,
            117595368,
            117595660,
            117608430,
            117600516,
            117617181,
            117613055,
            117606766
        ],
        "A": [
            117595740,
            117594587,
            117593757,
            117594246,
            117593849,
            117594075,
            117595264,
            117593810,
            117605058,
            117594287,
            117594338,
            117603759,
            117594059,
            117594193,
            117593995,
            117604884,
            117594125,
            117594212,
            117608105,
            117606903
        ]
    },
    "name": "D. Kill Anton",
    "statement": "After rejecting 10^{100} data structure problems, Errorgorn is very\r\nangry at Anton and decided to kill him.Anton\u2019s DNA can be represented as\r\na string a which only contains the characters \"\" (there are only 4\r\ndistinct characters). Errorgorn can change Anton\u2019s DNA into string b\r\nwhich must be a of a. However, Anton\u2019s body can defend against this\r\nattack. In 1 second, his body can swap 2 characters of his DNA to\r\ntransform it back to a. Anton\u2019s body is smart and will use the minimum\r\nnumber of moves.To maximize the chance of Anton dying, Errorgorn wants\r\nto change Anton\u2019s DNA the string that maximizes the time for Anton\u2019s\r\nbody to revert his DNA. But since Errorgorn is busy making more data\r\nstructure problems, he needs your help to find the best string B. Can\r\nyou help him?\r\n",
    "solutions": [
        "//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar('-') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + '0' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\nll n,res;\nchar s[114514];\nstack<int>sta[200];\nint temp[114514];\nint c[114514];\nstring s1,s2,s3,s4,ans;\ninline void add(int pos) {\n\twhile(pos<=n) {\n\t\t++c[pos];\n\t\tpos+=(-pos&pos);\n\t}\n}\ninline int query(int pos) {\n\tint rt=0;\n\twhile(pos) {\n\t\trt+=c[pos];\n\t\tpos-=(-pos&pos);\n\t}\n\treturn rt;\n}\ninline ll ak() {\n\tF(i,1,n)c[i]=0;\n\tll rt=0;\n\tUF(i,n,1) {\n\t\trt+=query(temp[i]);\n\t\tadd(temp[i]);\n\t}\n\treturn rt;\n}\ninline ll check(string b) {\n\tb.insert(0,\"#\");\n\tUF(i,n,1) {\n\t\tsta[s[i]].push(i);\n\t}\n\tF(i,1,n) {\n\t\ttemp[i]=sta[b[i]].top();\n\t\tsta[b[i]].pop();\n\t}\n\treturn ak();\n}\nint main() {\n\tF(fdafdas,1,read()) {\n\t\tscanf(\"%s\",s+1);\n\t\tn=strlen(s+1);\n\t\tres=-1;\n\t\ts1.clear();\n\t\ts2.clear();\n\t\ts3.clear();\n\t\ts4.clear();\n\t\tF(i,1,n) {\n\t\t\tif(s[i]=='A')s1.push_back('A');\n\t\t\tif(s[i]=='N')s2.push_back('N');\n\t\t\tif(s[i]=='O')s3.push_back('O');\n\t\t\tif(s[i]=='T')s4.push_back('T');\n\t\t}\nll sss=check(s1+s2+s3+s4);if(sss>res){res=sss;ans=s1+s2+s3+s4;}\nsss=check(s1+s2+s4+s3);if(sss>res){res=sss;ans=s1+s2+s4+s3;}\nsss=check(s1+s3+s2+s4);if(sss>res){res=sss;ans=s1+s3+s2+s4;}\nsss=check(s1+s3+s4+s2);if(sss>res){res=sss;ans=s1+s3+s4+s2;}\nsss=check(s1+s4+s2+s3);if(sss>res){res=sss;ans=s1+s4+s2+s3;}\nsss=check(s1+s4+s3+s2);if(sss>res){res=sss;ans=s1+s4+s3+s2;}\nsss=check(s2+s1+s3+s4);if(sss>res){res=sss;ans=s2+s1+s3+s4;}\nsss=check(s2+s1+s4+s3);if(sss>res){res=sss;ans=s2+s1+s4+s3;}\nsss=check(s2+s3+s1+s4);if(sss>res){res=sss;ans=s2+s3+s1+s4;}\nsss=check(s2+s3+s4+s1);if(sss>res){res=sss;ans=s2+s3+s4+s1;}\nsss=check(s2+s4+s1+s3);if(sss>res){res=sss;ans=s2+s4+s1+s3;}\nsss=check(s2+s4+s3+s1);if(sss>res){res=sss;ans=s2+s4+s3+s1;}\nsss=check(s3+s1+s2+s4);if(sss>res){res=sss;ans=s3+s1+s2+s4;}\nsss=check(s3+s1+s4+s2);if(sss>res){res=sss;ans=s3+s1+s4+s2;}\nsss=check(s3+s2+s1+s4);if(sss>res){res=sss;ans=s3+s2+s1+s4;}\nsss=check(s3+s2+s4+s1);if(sss>res){res=sss;ans=s3+s2+s4+s1;}\nsss=check(s3+s4+s1+s2);if(sss>res){res=sss;ans=s3+s4+s1+s2;}\nsss=check(s3+s4+s2+s1);if(sss>res){res=sss;ans=s3+s4+s2+s1;}\nsss=check(s4+s1+s2+s3);if(sss>res){res=sss;ans=s4+s1+s2+s3;}\nsss=check(s4+s1+s3+s2);if(sss>res){res=sss;ans=s4+s1+s3+s2;}\nsss=check(s4+s2+s1+s3);if(sss>res){res=sss;ans=s4+s2+s1+s3;}\nsss=check(s4+s2+s3+s1);if(sss>res){res=sss;ans=s4+s2+s3+s1;}\nsss=check(s4+s3+s1+s2);if(sss>res){res=sss;ans=s4+s3+s1+s2;}\nsss=check(s4+s3+s2+s1);if(sss>res){res=sss;ans=s4+s3+s2+s1;}\n\t\tputs(ans.c_str());\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "math",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Kill Anton.json",
    "editorial_link": "https://codeforces.com//blog/entry/91195",
    "editorial": "We claim that in the\noptimal answer all characters of some type will appear consecutively.\nProofConsider the character at position in string . We define as the\nposition in which that character will be in string . For and , . Then\nthe minimum number of moves to transformed to is given by the inversion\nindex of .Suppose we find a substring of where it is , where characters\ncan be either one of . The square brackets are just for clarity of\nexplanation. We will show that it our solution will not be worse if we\nmerge these contiguous segments of .Consider transforming the string\ninto and . Let the difference in the number of moves be and\nrespectively. And let the index of s be and respectively.Then and ,\nwhere , or rather is the sign function.I claim that . Suppose that ,\nthen there exist such that which implies and . However, this implies\nthat which is clearly a contradiction.Since , either or . WLOG, . This\nimplies that we turn into without decreasing the number of moves to\ntransform into . Now, consider the rest of the on the left segment of .\nWe can move it too the right also. Recall that . In this case, we know\nthat as it is the cost to move the left back to its original position.\nSo . Therefore, we have merged different segments of without decreasing\nthe number of moves to transform into .So, we can try all possible\nstrings and check the number of moves Anton\u00e2\u0080\u0099s body needs to transform\neach string. The time limit is relaxed enough for a similar to 1430E -\nString Reversal.But there is a solution, the number of moves Anton\u00e2\u0080\u0099s\nbody needs to transform each string is given by the number of inversions\nin the string. But since we know that we only care about strings that\nhave all the same characters appear consecutively, we can just keep a\ncount of the number of inversions for each pair of characters.\n"
}