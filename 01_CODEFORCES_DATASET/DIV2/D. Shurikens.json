{
    "link": "https://codeforces.com//contest/1435/problem/D",
    "problemId": "773406",
    "problem_idx": "D",
    "shortId": "1435D",
    "contest_number": "1435",
    "problem_submissions": {
        "E": [
            96673338,
            96681148,
            96682797,
            96685288,
            96847098,
            96685903,
            96675878,
            96687224,
            96687243,
            96686976,
            96689725,
            96692435,
            96691487,
            96692658,
            96691299,
            96690805,
            96693692,
            96679915,
            96692643,
            96687850
        ],
        "D": [
            96666232,
            96664904,
            96669284,
            96672253,
            96669314,
            96662222,
            96670668,
            96669409,
            96677310,
            96678148,
            96672549,
            96673104,
            96674256,
            96678523,
            96677726,
            96675716,
            96674961,
            96679765,
            96674688
        ],
        "C": [
            96659129,
            96657575,
            96664731,
            96660163,
            96661902,
            96686570,
            96658550,
            96663667,
            96669546,
            96664295,
            96666298,
            96669749,
            96666819,
            96667412,
            96671053,
            96669495,
            96685954,
            96666507,
            96668496,
            96674329
        ],
        "B": [
            96653882,
            96659883,
            96653749,
            96652475,
            96653199,
            96659428,
            96653053,
            96655781,
            96654431,
            96655376,
            96655587,
            96653268,
            96655657,
            96658338,
            96657193,
            96656576,
            96657563,
            96655601,
            96656271
        ],
        "A": [
            96648730,
            96649969,
            96649216,
            96648637,
            96648957,
            96653721,
            96648796,
            96663309,
            96649948,
            96651571,
            96648683,
            96648672,
            96658175,
            96649723,
            96648927,
            96651329,
            96649879,
            96649976,
            96675513
        ]
    },
    "name": "D. Shurikens",
    "statement": "Tenten runs a weapon shop for ninjas. Today she is willing to sell n\r\nshurikens which cost 1, 2, ..., n ryo (local currency). During a day,\r\nTenten will place the shurikens onto the showcase, which is empty at the\r\nbeginning of the day. Her job is fairly simple: sometimes Tenten places\r\nanother shuriken (from the available shurikens) on the showcase, and\r\nsometimes a ninja comes in and buys a shuriken from the showcase. Since\r\nninjas are thrifty, they always buy the shuriken from the\r\nshowcase.Tenten keeps a record for all events, and she ends up with a\r\nlist of the following types of records: means that she placed another\r\nshuriken on the showcase; means that the shuriken of price x was bought.\r\nToday was a lucky day, and all shurikens were bought. Now Tenten wonders\r\nif her list is consistent, and what could be a possible order of placing\r\nthe shurikens on the showcase. Help her to find this out!\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nconst int N = 2e5 + 20;\nint n, a[N];\nchar c[N];\nstack <int> st;\n\nint main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    for (int i = 0; i < 2 * n; i++) {\n        cin >> c[i];\n        if (c[i] == '-') cin >> a[i];\n    }\n\n    for (int i = 0; i < 2 * n; i++) {\n        if (c[i] == '+') st.push(i);\n        else {\n            if (st.empty()) return cout << \"NO\\n\", 0;\n            \n            a[st.top()] = a[i];\n            st.pop();\n        }\n    }\n\n    if (!st.empty()) return cout << \"NO\\n\", 0;\n\n    set <int> S;\n\n    for (int i = 0; i < 2 * n; i++) {\n        if (c[i] == '+') S.insert(a[i]);\n        else {\n            if (S.empty() || *S.begin() != a[i]) return cout << \"NO\\n\", 0;\n            S.erase(S.begin());\n        }\n    }\n\n    cout << \"YES\\n\";\n    for (int i = 0; i < 2 * n; i++)\n        if (c[i] == '+') cout << a[i] << ' ';\n\n    cout << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "schedules"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Shurikens.json",
    "editorial_link": "https://codeforces.com//blog/entry/84056",
    "editorial": "Let's note that if a shuriken of price x\n is being bought right now, then the only information we obtain about all the remaining shurikens is that they are of prices ?x\n. It's also clear that if we consider two shurikens on the showcase then the one which was placed earlier has the stronger constraints (as written above).\n\nNow consider all events that can happen when the shuriken of price x\n is bought. If for all shurikens that are currently on the showcase we know that they must have prices >x\n, then the answer is negative. Otherwise, for all shurikens that had a lower bound of something less than x\n we increase it to x\n, and remove any one of them, because we cannot remove any other shuriken, and these are indistinguishable. However, since we know that the last placed shuriken has the weakest constraint, we can just remove the last placed shuriken each time and check the consistency in the end. This verification can be done using any min-heap. The final time complexity is O(n?logn)\n.",
    "hint": []
}