{
    "link": "https://codeforces.com//contest/1075/problem/D",
    "problemId": "249095",
    "problem_idx": "D",
    "shortId": "1075D",
    "contest_number": "1075",
    "problem_submissions": {
        "E": [
            45299888,
            45297843,
            45298056,
            45296633,
            45301081,
            45300957,
            45302422,
            45302929,
            45304409,
            45302659,
            45300790,
            45303365,
            45303877,
            45302733
        ],
        "F": [
            45298415,
            45299656,
            45299363,
            45302076,
            45302275,
            45461749,
            45308311
        ],
        "D": [
            45294336,
            45295894,
            45295657,
            45296846,
            45300767,
            45296827,
            45297943,
            45298533,
            45298945,
            45296351,
            45298646,
            45300089,
            45299323,
            45303594,
            45300962,
            45300486,
            45300898
        ],
        "C": [
            45292132,
            45292865,
            45293959,
            45292758,
            45292492,
            45294033,
            45294912,
            45294846,
            45293224,
            45293567,
            45294312,
            45292544,
            45295364,
            45296384,
            45295997,
            45298611,
            45297798
        ],
        "B": [
            45290077,
            45290576,
            45289458,
            45290287,
            45290460,
            106466381,
            45291592,
            45291593,
            45291426,
            45290169,
            45291447,
            45291908,
            45290506,
            45291957,
            45290127,
            45292064,
            45294213,
            45290472
        ],
        "A": [
            45288469,
            45288515,
            45288420,
            45288453,
            45288440,
            45288973,
            45289044,
            45288964,
            45288524,
            45289234,
            45289586,
            45288591,
            45289499,
            45288557,
            45289581,
            45288705,
            45288541
        ]
    },
    "name": "D. Intersecting Subtrees",
    "statement": "You are playing a strange game with Li Chen. You have a tree with n\r\nnodes drawn on a piece of paper. All nodes are unlabeled and\r\ndistinguishable. Each of you labeled the vertices from 1 to n. Neither\r\nof you know the other’s labelling of the tree.You and Li Chen each chose\r\na subtree (i.e., a connected subgraph) in that tree. Your subtree\r\nconsists of the vertices labeled x_1, x_2,\r\nldots, x_{k_1} in , Li Chen’s subtree consists of the vertices labeled\r\ny_1, y_2,\r\nldots, y_{k_2} in . The values of x_1, x_2,\r\nldots, x_{k_1} and y_1, y_2,\r\nldots, y_{k_2} are known to both of you. You want to determine whether\r\nyour subtrees have at least one common vertex. Luckily, your friend\r\nAndrew knows both labelings of the tree. You can ask Andrew at most 5\r\nquestions, each of which is in one of the following two forms: : Andrew\r\nwill look at vertex x in your labeling and tell you the number of this\r\nvertex in Li Chen’s labeling. : Andrew will look at vertex y in Li\r\nChen’s labeling and tell you the number of this vertex in your labeling.\r\nDetermine whether the two subtrees have at least one common vertex after\r\nasking some questions. If there is at least one common vertex, determine\r\none of your labels for any of the common vertices.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define szv(V) ((int)(V).size())\n#define allv(V) (V).begin(), (V).end()\n#define sortv(V) sort(allv(V))\n#define uniquev(V) (V).erase(unique(allv(V)), (V).end())\n#define compv(V) sortv(V), uniquev(V)\n#define fs first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int mod = 1e9 + 7;\nconst ll inf = 4e18 + 5;\n\nll gcd(ll x, ll y) { while (y) x %= y, swap(x, y); return x; }\npll operator+(pll a, pll b) { return pll(a.fs + b.fs, a.se + b.se); }\npll operator-(pll a, pll b) { return pll(a.fs - b.fs, a.se - b.se); }\nll operator*(pll a, pll b) { return a.fs * b.se - a.se * b.fs; }\ntemplate <class T> int sign(T x) { return x < 0 ? -1 : x > 0 ? 1 : 0; }\nint ccw(pll a, pll b, pll c) { return sign((b - a) * (c - b)); }\ntemplate <class T> void setmin(T &x, T y) { if (x > y) x = y; }\ntemplate <class T> void setmax(T &x, T y) { if (x < y) x = y; }\ntemplate <class T> void addval(T &x, T y) { x += y; x %= mod; }\n\nvector<int> edge[1005];\nint chx[1005], chy[1005];\n\nint dfs(int x, int p) {\n    if (chx[x]) return x;\n    for (int i : edge[x]) {\n        if (i == p) continue;\n        int ret = dfs(i, x);\n        if (ret != -1) return ret;\n    }\n    return -1;\n}\n\nvoid solve() {\n    int n, k1, k2;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        edge[i].clear();\n        chx[i] = chy[i] = 0;\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        edge[x].pb(y);\n        edge[y].pb(x);\n    }\n    cin >> k1;\n    int xn, yn;\n    for (int i = 0; i < k1; i++) {\n        int x;\n        cin >> x;\n        xn = x;\n        chx[x] = 1;\n    }\n    cin >> k2;\n    for (int i = 0; i < k2; i++) {\n        int x;\n        cin >> x;\n        yn = x;\n        chy[x] = 1;\n    }\n    cout << \"B \" << yn << endl;\n    int ynx;\n    cin >> ynx;\n    if (chx[ynx]) cout << \"C \" << ynx << endl;\n    else {\n        int ret = dfs(ynx, 0);\n        cout << \"A \" << ret << endl;\n        int lst;\n        cin >> lst;\n        if (chy[lst]) cout << \"C \" << ret << endl;\n        else cout << \"C -1\" << endl;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int T;\n    cin >> T;\n    while (T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "interactive",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Intersecting Subtrees.json",
    "editorial_link": "https://codeforces.com/blog/entry/62985",
    "editorial": "I'll split this into two parts, first is the solution, second is why it works.\n\nThe intended solution only uses two questions.\n\nChoose an arbitrary yj\n, and ask \"B y_j\". Let the response be R\n.\nFind a node xi\n that is the closest to node R\n. This can be done with a BFS or DFS.\nAsk \"A x_i\". Let the response be Q\n.\nIf Q\n is one of y1,y2,,yk2\n, print \"C x_i\", otherwise, print \"C -1\".\nHere is why it works. Let's use the fact that if the two subtrees don't intersect, there is an edge in the tree such that if we cut the tree on this edge, it will split it into two components, each containing one of the subtrees.\n\nSuppose we did step 1 and we have R\n. Let's root our tree at R\n. There is a unique node xi\n that has lowest depth in this tree which we can find (given that x1,x2,,xk1\n form a subtree).\n\nNow, we claim that the two subtrees intersect if and only if Li Chen owns a node that lies in the subtree rooted by xi\n (and in particular, we will show it is sufficient to only check node xi\n).\n\nIf none of Li Chen's nodes lie in the subtree rooted by xi\n, then the edge xi\n to its parent cuts the tree into two components with one subtree completely lying in one component and the other in the second, so the two subtrees are disjoint.\n\nOtherwise, there is a node W\n that is in Li Chen's subtree that lies in the subtree rooted by xi\n. All nodes in the path of R\n to W\n must also belong to Li Chen's subtree, and in particular this includes node xi\n, so the two trees intersect. This also shows we can just check if xi\n belongs in Li Chen's subtree by asking a question about it.",
    "hint": []
}