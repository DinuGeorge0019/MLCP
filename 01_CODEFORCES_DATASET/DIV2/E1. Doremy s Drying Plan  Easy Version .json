{
    "link": "https://codeforces.com//contest/1890/problem/E1",
    "problemId": "2253930",
    "problem_idx": "E1",
    "shortId": "1890E1",
    "contest_number": "1890",
    "problem_submissions": {
        "E2": [
            230243672,
            230240480,
            230297470,
            230254767,
            230258587,
            230244180,
            230254845,
            230249864,
            230263075,
            230246186
        ],
        "E1": [
            230239375,
            230240649,
            230254904,
            230258446,
            230244551,
            230252707,
            230254758,
            230249708,
            230262781,
            230215711,
            230246708,
            230241675,
            230236999,
            230227194,
            230225604,
            230238862,
            230234772,
            230232052,
            230239219
        ],
        "C": [
            230215281,
            230206393,
            230208934,
            230208092,
            230206406,
            230204020,
            230204003,
            230208271,
            230220692,
            230199138,
            230200556,
            230196035,
            230205630,
            230204581,
            230205712,
            230207645,
            230206074,
            230200943
        ],
        "D": [
            230200794,
            230211914,
            230214420,
            230213956,
            230250838,
            230215130,
            230243357,
            230434274,
            230253613,
            230238740,
            230207739,
            230228283,
            230207522,
            230211617,
            230214234,
            230212438,
            230213769,
            230217205,
            230221587,
            230210557
        ],
        "B": [
            230187228,
            230188639,
            230191975,
            230193314,
            230189140,
            230192487,
            230190081,
            230430791,
            230190255,
            230203446,
            230188113,
            230219697,
            230186542,
            230187036,
            230191039,
            230188308,
            230187745,
            230188740,
            230190731,
            230189120
        ],
        "A": [
            230183445,
            230183838,
            230195995,
            230187748,
            230183292,
            230186367,
            230183250,
            230430735,
            230183529,
            230188990,
            230184115,
            230213790,
            230183853,
            230183272,
            230185989,
            230183632,
            230183856,
            230183304,
            230184663,
            230511197,
            230183134
        ],
        "F": [
            230416243,
            230223460,
            232061512,
            232061382,
            232061156,
            230258558,
            230434262,
            230438215
        ]
    },
    "name": "E1. Doremy s Drying Plan  Easy Version ",
    "statement": "Doremy lives in a rainy country consisting of n cities numbered from 1\r\nto n.The weather broadcast predicted the distribution of rain in the\r\nnext m days. In the i-th day, it will rain in the cities in the interval\r\n[l_i, r_i]. A city is called dry if it will never rain in that city in\r\nthe next m days.It turns out that Doremy has a special power. She can\r\nchoose k days (in the easy version, k = 2), and during these days it\r\nwill not rain. Doremy wants to calculate the maximum number of dry\r\ncities after using the special power.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define mp make_pair\n#define ll long long\n#define il inline\nusing namespace std;\nconst int maxn=200010;\nconst int MAXN=maxn<<2;\nconst int inf=1<<30;\nconst int maxk=5;\nil int read(){\n\tint x=0;\n\tchar c=getchar();\n\tfor(;!(c>='0'&&c<='9');c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\treturn x;\n}\nil void chkmax(int &x,int y){if(y>x)x=y;}\nstruct seg{\n\tint l,r;\n}a[maxn];\nstruct info{\n\tint st[maxk],top;\n\tint op;\n}b[maxn];\nset<pair<int,int> >s;\nbool cmp(seg a,seg b){return a.l<b.l;}\nbool cmpp(int x,int y){return a[x].l>a[y].l;}\nint T,n,m,k;\nint f[maxk][maxn];\nint g[maxk][maxn];\nint d[maxk][MAXN];\nvoid build(int t,int i,int l,int r){\n\td[t][i]=-inf;\n\tif(l==r) return ;\n\tint mid=l+r>>1;\n\tbuild(t,i<<1,l,mid);\n\tbuild(t,i<<1|1,mid+1,r);\n}\nvoid Add(int t,int i,int l,int r,int x,int k){\n\tif(l==r){\n\t\td[t][i]=k;\n\t\treturn ;\n\t}int mid=l+r>>1;\n\tif(mid>=x) Add(t,i<<1,l,mid,x,k);\n\telse Add(t,i<<1|1,mid+1,r,x,k);\n\td[t][i]=max(d[t][i<<1],d[t][i<<1|1]);\n}\nint Q(int t,int i,int l,int r,int L,int R){\n\tif(L>R) return -inf;\n\tif(l>=L&&r<=R) return d[t][i];\n\tif(l>R||r<L) return -inf;\n\tint mid=l+r>>1;\n\treturn max(Q(t,i<<1,l,mid,L,R),Q(t,i<<1|1,mid+1,r,L,R));\n}\nint Mx(int t,int l,int r){\n\treturn Q(t,1,0,n,l,r);\n}\nvoid renew(int t,int x,int k){\n\tAdd(t,1,0,n,x,k);\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\ts.clear();\n\t\tn=read(),m=read(),k=read();\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tfor(int j=0;j<=n;j++) \n\t\t\t\tf[i][j]=g[i][j]=-inf;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\ta[i].l=read(),a[i].r=read();\n\t\t}sort(a+1,a+1+m,cmp);\n\t\tfor(int i=1,j=1;i<=n;i++){\n\t\t\twhile(j<=m&&a[j].l<=i)\n\t\t\t\ts.insert(mp(a[j].r,j)),j++;\n\t\t\twhile(!s.empty()&&s.begin()->first<i)\n\t\t\t\ts.erase(s.begin());\n\t\t\tif(s.size()<=k){\n\t\t\t\tb[i].op=1,b[i].top=0;\n\t\t\t\tfor(auto it=s.begin();it!=s.end();it++)\n\t\t\t\t\tb[i].st[++b[i].top]=it->second;\n\t\t\t\tsort(b[i].st+1,b[i].st+1+b[i].top,cmpp);\n\t\t\t}\n\t\t\telse b[i].op=0;\n\t\t}\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tbuild(i,1,0,n);\n\t\tf[0][0]=0,renew(0,0,f[0][0]);\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tfor(int j=1;j<=n;renew(i,j,f[i][j]),j++){\n\t\t\t\tif(!b[j].op)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(!b[j].top){\n\t\t\t\t\tf[i][j]=Mx(i,0,j-1)+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i>=b[j].top) chkmax(f[i][j],Mx(i-b[j].top,0,j-1)+1);\n\t\t\t\tfor(int u=0;u<b[j].top;u++)\n\t\t\t\t\tif(i>=u) chkmax(f[i][j],Mx(i-u,a[b[j].st[u+1]].l,j-1)+1);\n\t\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tans=max(ans,f[i][j]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Doremy s Drying Plan  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/121813",
    "editorial": "We can construct a new directed graph, where we can consider each edge in T1\n and T2\n as a node. Let the node representing the edge (u,v)\n in tree Ti\n be N(u,v,Ti)\n.\n\nFor each node N(u,v,T1)\n, let the simple path between u\n and v\n in T2\n be (u1,v1),\u0085,(um,vm)\n, and for all 1?i?m\n we add an edge from N(T1,u,v)\n to N(T2,ui,vi)\n in the new graph. And for each node N(u,v,T2)\n, let the simple path between u\n and v\n in T1\n be (u1,v1),\u0085,(um,vm)\n, and for all 1?i?m\n we add an edge from N(T2,u,v)\n to N(T1,ui,vi)\n in the new graph.\n\nThen we calculate the number of strongly connected components with the size bigger than 2\n in the new graph. If it is t\n, the answer is 2t\n.\n\nTo reduce the time complexity to O(nlogn)\n, we need to build the new graph with binary lifting or heavy-light decomposition or centroid decomposition or something like those. More specifically, we just build the data structure as normal, but replace the \"modify\" operation with \"add edge\" operation, which allows us to add edges from one node to a range of nodes with low time complexity.\n\nProof: it is obviously that the edge set we choose in each operation must be a closed subgraph in the new graph. And at the same time, it can be easily proved that every closed subgraph in the new graph is a valid edge set. The another thing we need to prove is that the set of valid closed subgraph won't change after an operation. We can easily prove this by the relationship between the number of edges and the number of nodes in a tree."
}