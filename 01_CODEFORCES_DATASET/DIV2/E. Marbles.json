{
    "link": "https://codeforces.com//contest/1215/problem/E",
    "problemId": "412395",
    "problem_idx": "E",
    "shortId": "1215E",
    "contest_number": "1215",
    "problem_submissions": {
        "F": [
            60620224,
            60633144,
            60628796,
            62102987,
            60657759
        ],
        "E": [
            60614830,
            60620100,
            60624259,
            60618193,
            60620939,
            60619722,
            60618555,
            60619211,
            60623129,
            60624049,
            60623962,
            60621062,
            60625235,
            60625015,
            60623138,
            60622255,
            60623519,
            60627768,
            60628419,
            60622708
        ],
        "D": [
            60613485,
            60617335,
            60619535,
            60616864,
            60615351,
            60616017,
            60622796,
            60619079,
            60617400,
            60616935,
            60621165,
            60617806,
            60616391,
            60616135,
            60618699,
            60620021,
            60619257,
            60623666,
            60614165,
            60618490
        ],
        "C": [
            60611883,
            60614880,
            60616986,
            60613872,
            60612356,
            60613808,
            60613237,
            60615096,
            60615058,
            60613116,
            60615948,
            60615995,
            60614183,
            60613610,
            60614082,
            60612548,
            60614439,
            60618385,
            60611650,
            60615653
        ],
        "B": [
            60609609,
            60611892,
            60614411,
            60610320,
            60609887,
            60611712,
            60610288,
            60610941,
            60611470,
            60610159,
            60611942,
            60611586,
            60611453,
            60611164,
            60611443,
            60609621,
            60611512,
            60611710,
            60609773,
            60612774
        ],
        "A": [
            60609389,
            60610541,
            60610424,
            60609620,
            60609428,
            60610648,
            60609442,
            60611977,
            60609576,
            60609429,
            60610464,
            60609932,
            60609744,
            60609643,
            60609965,
            60616895,
            60610358,
            60609768,
            60609404,
            60611551
        ]
    },
    "name": "E. Marbles",
    "statement": "Monocarp has arranged n colored marbles in a row. The color of the i-th\r\nmarble is a_i. Monocarp likes ordered things, so he wants to rearrange\r\nmarbles in such a way that all marbles of the same color form a\r\ncontiguos segment (and there is only one such segment for each color).\r\nIn other words, Monocarp wants to rearrange marbles so that, for every\r\ncolor j, if the leftmost marble of color j is l-th in the row, and the\r\nrightmost marble of this color has position r in the row, then every\r\nmarble from l to r has color j.To achieve his goal, Monocarp can do the\r\nfollowing operation any number of times: choose two neighbouring\r\nmarbles, and swap them.You have to calculate the minimum number of\r\noperations Monocarp has to perform to rearrange the marbles. Note that\r\nthe order of segments of marbles having equal color does not matter, it\r\nis only required that, for every color, all the marbles of this color\r\nform exactly one contiguous segment.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,x,S[25];\nll pr[25][25],f[(1<<20)];\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%d\",&x); --x;\n\t\tFor(j,0,19) if (x!=j) pr[j][x]+=S[j];\n\t\t++S[x];\n\t}\n\t//printf(\"%d\\n\",pr[2][3]);\n\tmemset(f,60,sizeof(f));\n\tf[0]=0;\n\tFor(i,0,(1<<20)-1)\n\t\tFor(j,0,19) if (!(i&(1<<j))){\n\t\t\tll s=f[i];\n\t\t\tFor(k,0,19) if (i&(1<<k))\n\t\t\t\ts+=pr[j][k];\n\t\t\tf[i|(1<<j)]=min(f[i|(1<<j)],s);\n\t\t}\n\tprintf(\"%lld\\n\",f[(1<<20)-1]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Marbles.json",
    "editorial_link": "https://codeforces.com//blog/entry/69815",
    "editorial": "The main fact is that the number of colors is less than , which allows\r\nus to use exponential solutions. For each pair of colors , we can\r\ncalculate the number of swaps required to place all marbles of color\r\nbefore all marbles of color (if we consider only marbles of these two\r\ncolors). We can store a sorted vector for each color, and calculate this\r\ninformation for a fixed pair with two pointers.Then letâs use subset DP\r\nto fix the order of colors. Let be the minimum number of operations to\r\ncorrectly order all marbles from the of colors. Letâs iterate on the\r\nnext color we consider it should be a position in binary representation\r\nof with in it. We will place all marbles of this color after all marbles\r\nwe already placed. If we fix a new color , letâs calculate the (the\r\nadditional number of swaps we have to make) by iterating on the bit\r\nequal to in the , and increasing by for every such bit. The new state of\r\nDP can be calculated as . So the transition can be implemented as .The\r\nanswer is the minimum number of swaps required to place all the colors,\r\nand that is .\r\n",
    "hint": []
}