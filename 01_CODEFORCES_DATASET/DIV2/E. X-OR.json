{
    "link": "https://codeforces.com//contest/1364/problem/E",
    "problemId": "647246",
    "problem_idx": "E",
    "shortId": "1364E",
    "contest_number": "1364",
    "problem_submissions": {
        "E": [
            83685190,
            83684728,
            83670044,
            83708391,
            86874545,
            83727888,
            94916861,
            83733626,
            83892588
        ],
        "D": [
            83674039,
            83643909,
            83643324,
            83650173,
            83654530,
            83655343,
            83656667,
            83658116,
            83652702,
            83655398,
            83657128,
            83655879,
            83656798,
            83659303,
            83654673,
            83652945,
            83654032,
            83654691,
            83660980,
            84168459,
            83653853
        ],
        "C": [
            83641956,
            83631075,
            83632825,
            83637025,
            83635932,
            83634309,
            83632050,
            83634741,
            83637967,
            83633786,
            83640244,
            83634458,
            83638454,
            83638371,
            83638980,
            83647774,
            83644474,
            83643505,
            83634306,
            83639352
        ],
        "B": [
            83634593,
            83624903,
            83627972,
            83631302,
            83628554,
            83625631,
            83625293,
            83627339,
            83628623,
            83628644,
            83625351,
            83628184,
            83628428,
            83624769,
            83633106,
            83628572,
            83637716,
            83626469,
            83630293
        ],
        "A": [
            83629697,
            83628427,
            83623168,
            83625873,
            83624275,
            83623298,
            83623685,
            83623482,
            83625309,
            83624536,
            83623274,
            83624381,
            83624214,
            83623297,
            83623701,
            83625943,
            83623507,
            83625742
        ]
    },
    "name": "E. X-OR",
    "statement": "Ehab has a hidden permutation p of length n consisting of the elements\r\nfrom 0 to n-1. You, for some reason, want to figure out the permutation.\r\nTo do that, you can give Ehab 2 indices i and j, and he\u2019ll reply with\r\n(p_i|p_j) where | is the bitwise-or operation.Ehab has just enough free\r\ntime to answer 4269 questions, and while he\u2019s OK with answering that\r\nmany questions, he\u2019s too lazy to play your silly games, so he\u2019ll fix the\r\npermutation beforehand and will change it depending on your queries. Can\r\nyou guess the permutation?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nint n;\nbool bad[2050];\nint val[2050];\nint main() {\n    srand(time(NULL));\n    cin >> n;\n    int base = rand() % n;\n    for (int i = 0; i < n; i++) {\n        val[i] = -1;\n    }\n    while (true) {\n        int samples_cnt = 0;\n        int min_sample_val = 5000;\n        int min_sample_ind = 0;\n        int andd = (1 << 11) - 1;\n        std::vector<pair<int, int>> samples;\n        for (int i = 0; i < n; i++) {\n            if (i != base && !bad[i]) {\n                cout << \"? \" << base + 1 << \" \" << i + 1 << std::endl;\n                int res;\n                cin >> res;\n                samples_cnt++;\n                samples.push_back({i, res});\n                if (res < min_sample_val) {\n                    min_sample_val = res;\n                    min_sample_ind = i;\n                }\n                andd &= res;\n                if (samples_cnt >= 20) {\n                    if (min_sample_val == andd) {\n                        base = min_sample_ind;\n                        for (auto pr : samples) {\n                            if (pr.second != min_sample_val) {\n                                bad[pr.first] = true;\n                            }\n                        }\n                        goto m1;\n                    }\n                }\n            }\n        }\n        while (samples.size() < 20) {\n            int sample = rand() % n;\n            while (sample == base) {\n                sample = rand() % n;\n            }\n            cout << \"? \" << base + 1 << \" \" << sample + 1 << std::endl;\n            int res;\n            cin >> res;\n            if (res < min_sample_val) {\n                min_sample_val = res;\n                min_sample_ind = sample;\n            }\n            andd &= res;\n            samples.push_back({sample, res});\n        }\n        if (andd == 0) {\n            val[base] = 0;\n            for (auto pr : samples) {\n                val[pr.first] = pr.second;\n            }\n            for (int i = 0; i < n; i++) {\n                if (val[i] == -1) {\n                    cout << \"? \" << base + 1 << \" \" << i + 1 << std::endl;\n                    cin >> val[i];\n                }\n            }\n            cout << \"! \";\n            for (int i = 0; i < n - 1; i++) {\n                cout << val[i] << \" \";\n            }\n            cout << val[n - 1] << std::endl;\n            break;\n        } else {\n            // cout << min_sample_val << \" \" << andd << \"\\n\";\n            assert(min_sample_val == andd);\n            base = min_sample_ind;\n            for (auto pr : samples) {\n                if (pr.second != min_sample_val) {\n                    bad[pr.first] = true;\n                }\n            }\n            goto m1;\n        }\n        m1:;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "divide and conquer",
        "interactive",
        "probabilities"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. X-OR.json",
    "editorial_link": "https://codeforces.com//blog/entry/78781",
    "editorial": "The common idea is: if we find the index that contains , we can query it\r\nwith every element in and finish in queries (if you didn\u00e2\u0080\u0099t do that,\r\npleaaase share your solution.) How to get this index?\r\n"
}