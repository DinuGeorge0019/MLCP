{
    "link": "https://codeforces.com//contest/1474/problem/B",
    "problemId": "870481",
    "problem_idx": "B",
    "shortId": "1474B",
    "contest_number": "1474",
    "problem_submissions": {
        "E": [
            104828368,
            104825250,
            104827801,
            104822469,
            104822968,
            104825131,
            104832974,
            104811012,
            104834815,
            104836057,
            104786622,
            104834179,
            104835602,
            104835107,
            104819950,
            104895130,
            104882601,
            104882491,
            104822858
        ],
        "D": [
            104803255,
            104806609,
            104803024,
            104811001,
            104809350,
            104807802,
            104813937,
            104829181,
            104824996,
            104821358,
            104809387,
            104820702,
            104821421,
            104825040,
            104833883,
            104796190,
            104794553,
            104806036,
            104805452,
            104811623
        ],
        "C": [
            104789142,
            104791190,
            104786189,
            104802722,
            104796149,
            104800127,
            104797483,
            104805966,
            104792346,
            104794052,
            104822570,
            104797300,
            104791406,
            104805588,
            104813805,
            104788832,
            104801037,
            104795624,
            104794599,
            104838458
        ],
        "B": [
            104775373,
            104776212,
            104776559,
            104780629,
            104776012,
            104787737,
            104785829,
            104784413,
            104779863,
            104778330,
            104827451,
            104777621,
            104780062,
            104783179,
            104774681,
            104778495,
            104779543,
            104781042,
            104777052,
            104790738
        ],
        "A": [
            104773322,
            104773959,
            104773453,
            104773717,
            104779601,
            104775931,
            104776918,
            104778778,
            104773943,
            104773918,
            104829555,
            104773504,
            104773695,
            104774435,
            104774622,
            104773540,
            104774168,
            104774408,
            104773478,
            104781204
        ]
    },
    "name": "B. Different Divisors",
    "statement": "Positive integer x is called of positive integer y, if y is divisible by\r\nx without remainder. For example, 1 is a divisor of 7 and 3 is not\r\ndivisor of 8.We gave you an integer d and asked you to find positive\r\ninteger a, such that a has at least 4 divisors; difference between any\r\ntwo divisors of a is at least d.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nlong long d[30007]={0};\nvector<long long> p;\nvoid solve(){\n\tlong long d;\n\tcin>>d;\n\tlong long a=*lower_bound(p.begin(),p.end(),d+1);\n\tlong long b=*lower_bound(p.begin(),p.end(),d+a);\n\tcout<<1LL*a*b<<endl;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlong long i,j;\n\tfor(i=2;i<30007;i++){\n\t\tif(!d[i]){ \n\t\t\tp.emplace_back(i);\n\t\t}\n\t\telse{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=i+i;j<30007;j+=i){\n\t\t\td[j]=1;\n\t\t}\n\t}\n\tlong long t=1;\n\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Different Divisors.json",
    "editorial_link": "https://codeforces.com//blog/entry/86933",
    "editorial": "Hint : Integer have exactly divisors, if it is of form or for some\r\nprimes and . In the first case it have divisors , , , . In the second\r\ncase it have divisors , , , .Hint : Instead of finding integer with at\r\nleast divisors, find integer with exactly divisors.Hint : Let be the\r\nsmallest prime factor of . Then, .Solution:Suppose, we have integer with\r\nmore than divisors (and satisfies the other condition). If has at least\r\ntwo different prime factors, we can throw out all other prime factors\r\nand get a smaller number with at least divisors. Otherwise, for some .\r\nwill also have divisors and it will be smaller than . When we throw out\r\na prime factor, no new divisors will appear, so the difference between\r\nany two of them will be at least .Let\u00e2\u0080\u0099s find smallest integers of form\r\nand independently.In the first case, , because . If we will find the\r\nsmallest all conditions will be satisfied.In the second case, . Let\u00e2\u0080\u0099s\r\nfind the smallest and the smallest . In this case it is easy to see that\r\nand . Also, since . It is enough to get even without checking case .Also\r\nwe should prove that there cannot exist and such that . It is true\r\nbecause should be at least and it should be prime, but is the smallest\r\nprime greater than , so . And should be at least and we can prove that\r\nin the same way.Time complexity is , where is difference between primes\r\nand in average and is complexity of your prime check and usually is\r\n.Answer for is near to , so naive solution with factorization of each\r\nnumber shouldn\u00e2\u0080\u0099t pass, but it is possible to precompute answers for all\r\nvalues of by that solution (in this case, you should run solution once\r\nfor all values of , not once for each value of ).\r\n"
}