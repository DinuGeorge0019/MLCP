{
    "link": "https://codeforces.com//contest/1131/problem/C",
    "problemId": "302310",
    "problem_idx": "C",
    "shortId": "1131C",
    "contest_number": "1131",
    "problem_submissions": {
        "G": [
            50392574,
            50483553,
            50483191,
            50597351
        ],
        "E": [
            50370230,
            50377398,
            50376874,
            50374805,
            50370023,
            50374639,
            50376085,
            50370141,
            59337133,
            50372624,
            50376988,
            50380444,
            51393637,
            50379092,
            50379324,
            50375235,
            50378370,
            50376960,
            50378218,
            50375618,
            50380739,
            50377794
        ],
        "D": [
            50363533,
            50363627,
            50365255,
            50374692,
            50360365,
            50367830,
            50371553,
            50364690,
            59336364,
            50377671,
            50371391,
            50369645,
            51393629,
            50371580,
            50368694,
            50364122,
            50370641,
            50367474,
            50370633,
            50364697,
            50370324,
            50391827,
            50367431
        ],
        "F": [
            50359710,
            50366576,
            50362359,
            50363609,
            50372028,
            50364108,
            54391189,
            54391158,
            54391141,
            50775614,
            50775596,
            50775586,
            50775566,
            50775556,
            50366322,
            50374409,
            59338739,
            50364318,
            50366547,
            50364869,
            51393655,
            50365763,
            50362358,
            50366172,
            50366229,
            50370184,
            50365915,
            50363686,
            50365490,
            50370524
        ],
        "C": [
            50357039,
            50359567,
            50360582,
            50355123,
            50364439,
            50361693,
            50361183,
            50360745,
            50361372,
            50363542,
            50360374,
            50363293,
            50355730,
            50368491,
            50363309,
            50362385,
            50362421,
            50365348,
            50362731,
            50360623
        ],
        "B": [
            50355578,
            50356862,
            50357573,
            50357717,
            50364015,
            50361039,
            50356264,
            50358549,
            50359269,
            50359561,
            50357291,
            50358021,
            50372318,
            50359218,
            50357829,
            50359757,
            50364553,
            50364635,
            50358492,
            50357639
        ],
        "A": [
            50354897,
            50355112,
            50355078,
            50360224,
            50354946,
            50354851,
            50362936,
            50355762,
            50355563,
            50355186,
            50355036,
            50355259,
            50369979,
            50355032,
            50355231,
            50355565,
            50355478,
            50359515,
            50355346,
            50355260
        ]
    },
    "name": "C. Birthday",
    "statement": "Cowboy Vlad has a birthday today! There are n children who came to the\r\ncelebration. In order to greet Vlad, the children decided to form a\r\ncircle around him. Among the children who came, there are both tall and\r\nlow, so if they stand in a circle arbitrarily, it may turn out, that\r\nthere is a tall and low child standing next to each other, and it will\r\nbe difficult for them to hold hands. Therefore, children want to stand\r\nin a circle so that the maximum difference between the growth of two\r\nneighboring children would be minimal possible.Formally, let\u2019s number\r\nchildren from 1 to n in a circle order, that is, for every i child with\r\nnumber i will stand next to the child with number i+1, also the child\r\nwith number 1 stands next to the child with number n. Then we will call\r\nthe discomfort of the circle the maximum absolute difference of heights\r\nof the children, who stand next to each other.Please help children to\r\nfind out how they should reorder themselves, so that the resulting\r\ndiscomfort is smallest possible.\r\n",
    "solutions": [
        "/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,\"r\",stdin);\n#define fpo(x) freopen(x,\"w\",stdout);\n#define fprio fpi(\"in.txt\");fpo(\"out.txt\");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==' ');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes(\"\");}\ninline void writei(int x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<\"NO\";return 0;}\n#define YES {cout<<\"YES\";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nll n,m,i,j,k,a[100005],b[100005];\nstring st;\nint main()\n{\n\tread(n);\n\trep(i,n) read(a[i]);\n\tsort(a+1,a+n+1);\n\tj=1;k=n;\n\trep(i,n)\n\t{\n\t\tif (i&1) b[j++]=a[i]; else b[k--]=a[i];\n\t}\n\trep(i,n) printf(\"%I64d \",b[i]); \n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Birthday.json",
    "editorial_link": "https://codeforces.com//blog/entry/65487",
    "editorial": "The solution is greedy one.Suppose we have reordered , so that .Then I\r\nclaim that the answer can be built as follows:First write all elements\r\nwith even indices and then all elements with odd indices in reversed\r\norder.For example, if : we get and if : .One can \"check on many tests\"\r\nthat it works in practice, but here goes the proof:Note, that the\r\nsolution provides answer which is at most .Let\u00e2\u0080\u0099s show that for every ,\r\nanswer must be at least . To do this, draw all \u00e2\u0080\u0099s as a graph. Then the\r\nsolution to the problem is some Hamiltonian cycle.Let\u00e2\u0080\u0099s suppose that is\r\nprohibited to us (and all jumps containing this one). Red denotes the\r\nforbidden jumps. One can easily see, that is a cut point, and no\r\nhamiltonian cycle is possible. This concludes our proof!\r\n"
}