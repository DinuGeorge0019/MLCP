{
    "link": "https://codeforces.com//contest/2067/problem/E",
    "problemId": "3199299",
    "problem_idx": "E",
    "shortId": "2067E",
    "contest_number": "2067",
    "problem_submissions": {
        "F": [
            305685907,
            305692347,
            305698935,
            305692774,
            305676497,
            305698856,
            306077498,
            305705678,
            305756151,
            305704889
        ],
        "E": [
            305658599,
            305672236,
            305683533,
            305683773,
            305656801,
            305645614,
            305696470,
            305667416,
            305664383,
            305673487,
            305670822,
            305677487,
            305670853,
            305673781,
            305671527,
            305669540,
            305677992,
            305669569
        ],
        "D": [
            305649366,
            305681166,
            305653626,
            305674453,
            305643643,
            305729660,
            305688166,
            305650701,
            305653886,
            305650207,
            305654910,
            305651908,
            305655288,
            305746455,
            305655141,
            305660113,
            305659896,
            305656329,
            305714910,
            305658443
        ],
        "C": [
            305636369,
            305648878,
            305666557,
            305665235,
            305625887,
            305647363,
            305654112,
            305631231,
            305632643,
            305629967,
            305634943,
            305636497,
            305638128,
            305637135,
            305643511,
            305643488,
            305640674,
            305635570
        ],
        "B": [
            305619994,
            305628659,
            305625583,
            305654171,
            305618751,
            305619632,
            305656230,
            305622837,
            305619493,
            305623632,
            305626730,
            305624964,
            305625007,
            305622467,
            305622926,
            305630860,
            305620471,
            305624035
        ],
        "A": [
            305614513,
            305615491,
            305614195,
            305613169,
            305612940,
            305612785,
            305651426,
            305615731,
            305613408,
            305616051,
            305615564,
            305614161,
            305613236,
            305614353,
            305613295,
            305614069,
            305612838,
            305613240
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139415?locale=en",
    "editorial": "Note that for those suffixes where there is no number , will be equal to\r\n, and thus the condition will be satisfied, since at least on the left\r\nside it is definitely . That is, any array without zeros is\r\nmagical.However, if there are two zeros in the array, it can no longer\r\nbe magical, since we can consider a prefix containing one zero but not\r\ncontaining the second: the minimum on such a prefix is equal to , while\r\non the corresponding suffix will definitely be , and the condition will\r\nnot be satisfied.Thus, we know for sure that the answer is either or ,\r\nwhere is the number of . Since we can choose a subsequence without zeros\r\nof length , it will definitely be magical. However, any subsequence of\r\nlength must contain at least two zeros and cannot be magical.Therefore,\r\nwe only need to determine when the answer is equal to . In this case, we\r\nmust take a subsequence with exactly one zero, since again, sequences\r\nwith at least two zeros are definitely not magical. It is not difficult\r\nto understand that it is optimal to take the leftmost zero in the\r\nsubsequence, as the condition will be guaranteed to be satisfied for\r\nprefixes containing a single zero.Thus, the solution looks as follows:\r\nIf there are no zeros in the array, the answer is . Otherwise, we need\r\nto choose a subsequence consisting of the leftmost zero and all non-zero\r\nelements of the sequence. Explicitly check whether it is magical (this\r\ncan be easily done in , calculating prefix and suffix is a well-known\r\nproblem). If yes, the answer is: . Otherwise, the answer is , and a\r\nsubsequence of all non-zero elements will suffice.\r\n",
    "name": "E. White Magic",
    "statement": "We call a sequence a_1, a_2,\r\nldots, a_n if for all 1\r\nleq i\r\nleq n-1 it holds that:\r\noperatorname{min}(a_1,\r\nldots, a_i)\r\ngeq\r\noperatorname{mex}(a_{i+1},\r\nldots, a_n). In particular, any sequence of length 1 is considered .The\r\nminimum excluded (MEX) of a collection of integers a_1, a_2,\r\nldots, a_k is defined as the smallest non-negative integer t which does\r\nnot occur in the collection a. You are given a sequence a of n\r\nnon-negative integers. Find the maximum possible length of a\r\nsubsequence^{\r\ntext{ }} of the sequence a.^{\r\ntext{ }}A sequence a is a subsequence of a sequence b if a can be\r\nobtained from b by the deletion of several (possibly, zero or all)\r\nelement from arbitrary positions.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. White Magic.json",
    "hint": []
}