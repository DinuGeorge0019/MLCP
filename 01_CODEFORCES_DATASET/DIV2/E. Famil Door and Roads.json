{
    "link": "https://codeforces.com//contest/629/problem/E",
    "problemId": "48980",
    "problem_idx": "E",
    "shortId": "629E",
    "contest_number": "629",
    "problem_submissions": {
        "E": [
            16243210,
            16242894,
            16246160,
            16254693,
            16246007,
            16245862,
            16244672,
            16242439,
            16242471,
            16258760,
            16243275,
            16248006
        ],
        "C": [
            16240352,
            16245370,
            16241705,
            16242440,
            16239928,
            16244882,
            16239964,
            16237682,
            16237279,
            16238555,
            16240653,
            16241020,
            16238564,
            16239658,
            16239634
        ],
        "D": [
            16239018,
            16239572,
            16235953,
            16238851,
            16241535,
            16240168,
            16238831,
            16236923,
            16236354,
            16239430,
            16240177,
            16240027,
            16239268,
            16236114,
            16247725,
            16240713,
            16264201,
            16261091,
            16260254,
            16241789
        ],
        "B": [
            16234677,
            16235476,
            16237727,
            16234525,
            16235367,
            16236730,
            16234379,
            16237767,
            16237135,
            16233315,
            16234172,
            16233262,
            16234095,
            16233764,
            16235011,
            16233668
        ],
        "A": [
            16232727,
            16233109,
            16236608,
            16232783,
            16233137,
            16233465,
            16232870,
            16238509,
            16232645,
            16232640,
            16233626,
            16232665,
            16232698,
            16232767,
            16233370,
            16232800
        ]
    },
    "name": "E. Famil Door and Roads",
    "statement": "Famil Door s City map looks like a tree (undirected connected acyclic\r\ngraph) so other people call it Treeland. There are intersections in the\r\ncity connected by bidirectional roads.There are friends of Famil Door\r\nliving in the city. The -th friend lives at the intersection and works\r\nat the intersection . Everyone in the city is unhappy because there is\r\nexactly one simple path between their home and work.Famil Door plans to\r\nconstruct exactly one new road and he will randomly choose one among\r\npossibilities. Note, that he may even build a new road between two\r\ncities that are already connected by one.He knows, that each of his\r\nfriends will become happy, if after Famil Door constructs a new road\r\nthere is a path from this friend home to work and back that doesn’t\r\nvisit the same road twice. Formally, there is a simple cycle containing\r\nboth and . Moreover, if the friend becomes happy, his pleasure is equal\r\nto the length of such path (it’s easy to see that it’s unique). For each\r\nof his friends Famil Door wants to know his expected pleasure, that is\r\nthe expected length of the cycle containing both and if we consider only\r\ncases when such a cycle exists.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n#define fi \"input.txt\"\n#define fo \"output.txt\"\n#define fileopen freopen(fi,\"r\",stdin);freopen(fo,\"w\",stdout)\n#define FOR(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define FORD(i,l,r) for(int i=(int)(l);i>=(int)(r);i--)\n#define xy pair<int,int>\n#define int64 long long\n#define X first\n#define Y second\n#define pb push_back\n#define init(a,v) memset(a,v,sizeof(a))\n#define Sz(s) (int)(s.size())\n#define EL printf(\"\\n\")\n#define digit(x) ('0'<=x&&x<='9')\n#define forever while (true)\n#define ld long double\n\nconst int OO = (int) 2e9;\nconst int MOD = (int) 1e9+7;\nconst double Pi = 3.141592653589793;\nconst int N = (int) 1e5+5;\n\nint64 all[N],sub[N],all1=0;\nint s[N],h[N],P[N][18],n,q;\nvector<int> g[N];\n\nvoid dfs(int u,int p) {\n    int v=0;h[u]=h[p]+1;s[u]=1;P[u][0]=p;\n    FOR(i,0,Sz(g[u])-1) {\n        v=g[u][i];if (v==p) continue;\n        dfs(v,u);s[u]+=s[v];\n        sub[u]+=sub[v]+s[v];\n    }\n}\n\nvoid dfs2(int u,int p,int64 x) {\n    int v=0;all[u]=x;\n    FOR(i,0,Sz(g[u])-1) {\n        v=g[u][i];if (v==p) continue;\n        dfs2(v,u,x-s[v]+n-s[v]);\n    }\n}\n\nint LCA(int u,int v) {\n    if (h[u]<h[v]) swap(u,v);\n    FORD(i,17,0) if (h[P[u][i]]>=h[v]) u=P[u][i];\n    if (u==v) return u;\n    FORD(i,17,0) if (P[u][i]!=P[v][i]) u=P[u][i],v=P[v][i];\n    return P[u][0];\n}\n\nint dis(int u,int v,int p) {return h[u]+h[v]-2*h[p];}\n\nint child(int u,int p) {\n    FORD(i,17,0) if (h[P[u][i]]>h[p]) u=P[u][i];\n    return u;\n}\n\ndouble query(int u,int v) {\n    int64 sum,num;int p=LCA(u,v),ch;\n    if (h[u]<h[v]) swap(u,v);\n    if (p!=v) {\n        num=1LL*s[u]*s[v];\n        sum=sub[u]*s[v]+sub[v]*s[u]+1LL*num*(dis(u,v,p)+1);\n    } else {\n        ch=child(u,v);\n        num=1LL*s[u]*(n-s[ch]);\n        sum=sub[u]*(n-s[ch])+(all[v]-sub[ch]-s[ch])*s[u]+1LL*num*(dis(u,v,p)+1);\n    }\n    return 1.0*sum/num;\n}\n\nint main() {\n    cin>>n>>q;\n    int u,v;\n    FOR(i,1,n-1) {\n        cin>>u>>v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1,0);\n    FOR(i,2,n) all1+=h[i]-h[1];\n    dfs2(1,0,all1);\n    FOR(j,1,17) FOR(i,1,n) P[i][j]=P[P[i][j-1]][j-1];\n    while (q--) {\n        cin>>u>>v;\n        double db=query(u,v);\n        printf(\"%.8lf\\n\",db);\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dfs and similar",
        "dp",
        "probabilities",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Famil Door and Roads.json",
    "editorial_link": "https://codeforces.com//blog/entry/43227",
    "editorial": "First of all, we assume that the tree is rooted! For this problem, first\r\nwe need to compute some values for each vertex : and , , and . equals to\r\nthe expected value of length of paths which start from vertex , and ends\r\nin s subtree and also has length at least 1. equals to the expected\r\nvalue of length of paths which start from vertex , and not ends in s\r\nsubtree and also has length at least 1. to calculate this values we can\r\nuse one dfs for , and one other dfs for .\r\nis the number of vertices in s subtree except , is the th ancestor of\r\nand finally is the height of the vertex .\r\nin first dfs (lets call it dfsdown) we can calculate , and array with\r\nthis formulas: for ecah v as child of and = in second dfs (lets call it\r\ndfsup) we calculate using this formula (for clearer formula, I may\r\ndefine some extra variables): there are two cases: is the only child of\r\nits parent: let then\r\nis not the only child of its parent: let then now we should process the\r\nqueries. For each query and , we have to cases: one of the vertices is\r\neither one of the ancestors of the other one or not! In the first case,\r\nif we define the vertex before ( is assumed to be the vertex with lower\r\nheight). In the path from to , the answer is . In the second case, if we\r\nassume , then answer is To check if is one of ancestors of , you can\r\ncheck if their equals to or you can use dfs to find out their starting\r\nand finishing time. is an ancestor of if the interval of starting and\r\nfinishing time of is completely inside starting and finishing time of\r\nThe time complexity for the whole solution is ( for dfs and for each\r\nquery so for queries!). C++ Solution\r\n",
    "hint": []
}