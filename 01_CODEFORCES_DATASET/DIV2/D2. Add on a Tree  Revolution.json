{"link": "https://codeforces.com//contest/1189/problem/D2", "problemId": "366816", "problem_idx": "D2", "shortId": "1189D2", "contest_number": "1189", "problem_submissions": {"F": [56579282, 56588782], "E": [56573729, 56581060, 56587807, 56582721, 56573316, 56576668, 56574574, 56574253, 56578675, 56569961, 56571979, 56580045, 56581830, 56582305, 56578680, 56579770, 56574900, 56580107, 56581322, 56581737], "D2": [56570743, 56583951, 56590479], "D1": [56566287, 56577941, 56576232, 56577551, 56577147, 56570210, 56577116, 56576238, 56575115, 56582247, 56573204, 56575137, 56576626, 56575444, 56576506, 56574493, 56579444, 56574000, 56578325, 56573475], "C": [56564288, 56574952, 56571400, 56573424, 56567619, 56566699, 56569018, 56568449, 56569895, 56577759, 56579059, 56569406, 56571224, 56569610, 56573567, 56600577, 56571447, 56582169, 56576771, 56570411, 56571321], "B": [56562679, 56568440, 56565277, 56565965, 56565753, 56564877, 56565902, 56566168, 56565507, 56574431, 56576380, 56566755, 56565186, 56567011, 56566710, 56600572, 56577002, 56568448, 56570059, 56563578, 56569221], "A": [56561345, 56562783, 56561869, 56561808, 56562857, 56561895, 56562128, 56561757, 56561830, 56571793, 56568111, 56561276, 56563011, 56562623, 56562477, 56600568, 56563950, 56562575, 56563861, 56594597, 56561346, 56563282]}, "name": "D2. Add on a Tree  Revolution", "statement": "You are given a tree with n nodes. In the beginning, 0 is written on all\r\nedges. In one operation, you can choose any 2 distinct u, v and any\r\nnumber x and add x to values written on all edges on the simple path\r\nbetween u and v. .For example, on the picture below you can see the\r\nresult of applying two operations to the graph: adding 2 on the path\r\nfrom 7 to 6, and then adding -1 on the path from 4 to 5. You are given\r\nsome configuration of numbers, written on the edges. For a given\r\nconfiguration determine if it is possible to achieve it with these\r\noperations, and, if it is possible, output the sequence of operations\r\nthat leads to the given configuration. Constraints on the operations are\r\nlisted in the output format section.Leave is a node of a tree of\r\ndegree 1. Simple path is a path that doesn\u2019t contain any node twice.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\nvector<int> adj[101010];\npair<pii,int> E[101010];\nvector<pair<pii,int>> ans;\nint get(int u,int p){\n\tif(adj[u].size()==1)return u;\n\tfor(auto &x:adj[u]){\n\t\tif(x==p)continue;\n\t\telse return get(x,u);\n\t}\n}\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,c;scanf(\"%d%d%d\",&u,&v,&c);u--;v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t\tE[i]={{u,v},c};\n\t}\n\tfor(int i=0;i<n;i++)if(adj[i].size()==2)return puts(\"NO\"),0;\n\tputs(\"YES\");\n\tfor(int i=1;i<n;i++){\n\t\tpii X={-1,-1};\n\t\tint u,v;tie(u,v)=E[i].first;\n\t\tfor(auto &x:adj[u]){\n\t\t\tif(x==v)continue;\n\t\t\tint lf=get(x,u);\n\t\t\tif(X.first==-1)X.first=lf;\n\t\t\telse if(X.second==-1){\n\t\t\t\tX.second=lf;break;\n\t\t\t}\n\t\t}\n\t\tif(adj[u].size()==1)X={u,u};\n\t\tpii Y={-1,-1};\n\t\tswap(u,v);\n\t\tfor(auto &x:adj[u]){\n\t\t\tif(x==v)continue;\n\t\t\tint lf=get(x,u);\n\t\t\tif(Y.first==-1)Y.first=lf;\n\t\t\telse if(Y.second==-1){\n\t\t\t\tY.second=lf;break;\n\t\t\t}\n\t\t}\n\t\tif(adj[u].size()==1)Y={u,u};\n\t\tint V=E[i].second/2;\n\t\tans.push_back({{X.first,Y.first},V});\n\t\tans.push_back({{X.second,Y.second},V});\n\t\tif(X.first!=X.second)ans.push_back({{X.first,X.second},-V});\n\t\tif(Y.first!=Y.second)ans.push_back({{Y.first,Y.second},-V});\n\t}\n\tprintf(\"%d\\n\",(int)ans.size());\n\tfor(auto &x:ans)printf(\"%d %d %d\\n\",x.first.first+1,x.first.second+1,x.second);\n}"], "input": "", "output": "", "tags": ["dfs and similar", "implementation", "trees"], "dificulty": "2500", "interactive": false}