{
    "link": "https://codeforces.com//contest/1754/problem/C1",
    "problemId": "1601070",
    "problem_idx": "C1",
    "shortId": "1754C1",
    "contest_number": "1754",
    "problem_submissions": {
        "F": [
            177585023,
            177595292,
            177589725,
            177595672,
            177592227,
            177594371,
            177600616,
            177598864,
            177604397,
            177602614,
            177600745,
            177650521
        ],
        "E": [
            177569689,
            177567357,
            177579016,
            177575748,
            177578227,
            177581574,
            177582284,
            177718437,
            177559205,
            177578841,
            177592467,
            177571365,
            177604409,
            177574278,
            177575358,
            177581672,
            177580864,
            177577975,
            177576690,
            177577060,
            177575788
        ],
        "D": [
            177558843,
            177556402,
            177557867,
            177557341,
            177566023,
            177561555,
            177537301,
            177563632,
            177569625,
            177568630,
            177559753,
            177582529,
            177556010,
            177555670,
            177565457,
            177546662,
            177548683,
            177569461,
            177558389,
            177564007
        ],
        "C2": [
            177551655,
            177558288,
            177573497,
            177569544,
            177555242,
            177556994,
            177560273,
            177574456,
            177565363,
            177565266,
            177553021,
            177580177,
            177562940,
            177559475,
            177572826,
            177570567,
            177562030,
            177570649,
            177565206
        ],
        "C1": [
            177547310,
            177553157,
            177573631,
            177554026,
            177551066,
            177557135,
            177560766,
            177574531,
            177555999,
            177565804,
            177552312,
            177567879,
            177563083,
            177549386,
            177558755,
            177554824,
            177557780,
            177570332,
            177559045
        ],
        "B": [
            177536928,
            177540939,
            177544434,
            177539979,
            177546063,
            177755484,
            177551911,
            177569215,
            177582864,
            177540989,
            177550638,
            177541452,
            177561666,
            177543484,
            177541411,
            177704318,
            177536796,
            177542739,
            177547137,
            178632445,
            177550998,
            177541636
        ],
        "A": [
            177533931,
            177534875,
            177539057,
            177534599,
            177534878,
            177755451,
            177538378,
            177573057,
            177577215,
            177534289,
            177537921,
            177534413,
            177539691,
            177533195,
            177532916,
            177535356,
            177704314,
            177533258,
            177538336,
            177537857,
            178632436,
            177537629,
            177532986
        ]
    },
    "name": "C1. Make Nonzero Sum  easy version ",
    "statement": "You are given an array [a_1, a_2,\r\nldots a_n] consisting of integers -1 and 1. You have to build a\r\npartition of this array into the set of segments [l_1, r_1], [l_2, r_2],\r\nldots, [l_k, r_k] with the following property: Denote the alternating\r\nsum of all elements of the i-th segment as s_i: s_i = a_{l_i} -\r\na_{l_i+1} + a_{l_i+2} - a_{l_i+3} +\r\nldots\r\npm a_{r_i}. For example, the alternating sum of elements of segment [2,\r\n4] in array [1, 0, -1, 1, 1] equals to 0 - (-1) + 1 = 2. The sum of s_i\r\nover all segments of partition should be equal to zero. Note that each\r\ns_i does have to be equal to zero, this property is about sum of s_i\r\nover all segments of partition.The set of segments [l_1, r_1], [l_2,\r\nr_2],\r\nldots, [l_k, r_k] is called a of the array a of length n if 1 = l_1\r\nle r_1, l_2\r\nle r_2,\r\nldots, l_k\r\nle r_k = n and r_i + 1 = l_{i+1} for all i = 1, 2,\r\nldots k-1. In other words, each element of the array must belong to\r\nexactly one segment.You have to build a partition of the given array\r\nwith properties described above or determine that such partition does\r\nnot exist.Note that it is required to minimize the number of segments in\r\nthe partition.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define ln cout<<'\\n'\n#define ll long long\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}\ntemplate<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?\" \":\"\");pr(b...);}\ntemplate<class A>void PR(A a,ll n){rep(i,n)cout<<(i?\" \":\"\")<<a[i];ln;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={-1,0,1,0,-1,-1,1,1},dy[8]={0,1,0,-1,-1,1,1,-1};\ntypedef pair<ll,ll> P;\n\nvoid Main() {\n  ll T;\n  R T;\n  while(T--) {\n    ll n;\n    R n;\n    ll a[n];\n    rep(i,n) R a[i];\n    ll sum=0;\n    rep(i,n) sum+=a[i];\n    vector<P> ans;\n    for(ll i=0; i<n; i++) {\n      if(i+1<n&&sum<0) {\n        if(a[i+1]==-1) {\n          ans.pb(P(i+1,i+2));\n          sum+=2;\n          i++;\n        } else ans.pb(P(i+1,i+1));\n      } else if(i+1<n&&sum>0) {\n        if(a[i+1]==1) {\n          ans.pb(P(i+1,i+2));\n          sum-=2;\n          i++;\n        } else ans.pb(P(i+1,i+1));\n      } else ans.pb(P(i+1,i+1));\n    }\n    if(!sum) {\n      pr(ans.size());\n      rep(i,ans.size()) pr(ans[i].F,ans[i].S);\n    } else pr(-1);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C1. Make Nonzero Sum  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108336",
    "editorial": "If the sum of all elements of the array is odd, the partitions does not exist because the partition does not affect the parity of the sum. Otherwise the answer exists.\n\nLet's build such construction. As the sum of all elements is even, n\n is even too. Consider pairs of elements with indices (1,2)\n, (3,4)\n, ..., (n?1,n)\n. Consider the pair (2i?1,2i)\n. If a2i?1=a2i\n, add the segment [2i?1,2i]\n to the answer. In this case the alternating sum of elements of this segment will be equal to a2i?1?a2i=0\n. Otherwise we will add two segments to the answer: [2i?1,2i?1]\n and [2i,2i]\n. The sum of the first segment is a2i?1\n, and the sum of the second segment is a2i\n. The sum of two sums will be equal to zero. So the sum of all alternating sums will be equal to zero.",
    "hint": []
}