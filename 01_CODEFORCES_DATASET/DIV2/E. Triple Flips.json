{
    "link": "https://codeforces.com//contest/1072/problem/E",
    "problemId": "240873",
    "problem_idx": "E",
    "shortId": "1072E",
    "contest_number": "1072",
    "problem_submissions": {
        "E": [
            44644399,
            44650543,
            44734034
        ],
        "D": [
            44632605,
            44632447,
            44632175,
            44637652,
            44635628,
            44637006,
            44633885,
            151267020,
            44638964,
            44635045,
            44638115,
            44637529,
            44637972,
            44638624,
            44636915,
            44640412,
            44642212,
            44637605,
            44638663,
            44639668,
            44680075,
            44642131
        ],
        "C": [
            44629439,
            44628133,
            44629672,
            44628147,
            44630750,
            44631571,
            44630332,
            44631317,
            44630520,
            44628174,
            44630246,
            44632020,
            44630576,
            44632772,
            44630621,
            44630463,
            44631591,
            44634217,
            44633521,
            44631795
        ],
        "B": [
            44628286,
            44626280,
            44627642,
            44625837,
            44627706,
            44628961,
            44626684,
            44627105,
            44628089,
            44633570,
            44627458,
            44628288,
            44627756,
            44630738,
            44627790,
            44627828,
            44631462,
            44628114,
            44627946,
            44628620
        ],
        "A": [
            44624145,
            44624123,
            44661469,
            44624742,
            44624134,
            44625024,
            44624914,
            44624126,
            44624358,
            44624143,
            44630174,
            44624249,
            44625453,
            44624220,
            44625169,
            44624173,
            44624200,
            44631557,
            44625268,
            44624520,
            44624259
        ],
        "F": [
            44725275
        ]
    },
    "name": "E. Triple Flips",
    "statement": "You are given an array a of length n that consists of zeros and ones.You\r\ncan perform the following operation multiple times. The operation\r\nconsists of two steps: Choose three integers 1\r\nle x < y < z\r\nle n, that form an arithmetic progression (y - x = z - y). Flip the\r\nvalues a_x, a_y, a_z (i.e. change 1 to 0, change 0 to 1). Determine if\r\nit is possible to make all elements of the array equal to zero. If yes,\r\nprint the operations that lead the the all-zero state. Your solution\r\nshould not contain more than (\r\nlfloor\r\nfrac{n}{3}\r\nrfloor + 12) operations. Here\r\nlfloor q\r\nrfloor denotes the number q rounded down. We can show that it is\r\npossible to make all elements equal to zero in no more than this number\r\nof operations whenever it is possible to do so at all.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nvector <int> x, y, z;\nnamespace force {\n\tconst int MAXN = 13;\n\tunordered_map <bitset <MAXN>, bitset <MAXN> > from;\n\tbitset <MAXN> q[1 << MAXN], dest;\n\tvoid work(int *a, int n, int delta) {\n\t\tdest.reset();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tdest[i] = a[i];\n\t\tif (dest == 0) return;\n\t\tint l = 0, r = 0;\n\t\tq[0] = 0, from[0] = 0;\n\t\twhile (l <= r) {\n\t\t\tbitset <MAXN> now = q[l++];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = i + 2; j <= n; j += 2) {\n\t\t\t\tint k = (i + j) / 2;\n\t\t\t\tbitset <MAXN> tmp = now;\n\t\t\t\ttmp.flip(i), tmp.flip(j), tmp.flip(k);\n\t\t\t\tif (from.count(tmp) == 0) {\n\t\t\t\t\tfrom[tmp] = now;\n\t\t\t\t\tq[++r] = tmp;\n\t\t\t\t\tif (tmp == dest) {\n\t\t\t\t\t\tbitset <MAXN> pos = tmp;\n\t\t\t\t\t\twhile (pos != 0) {\n\t\t\t\t\t\t\tbitset <MAXN> tnp = pos ^ from[pos];\n\t\t\t\t\t\t\tint val = 0;\n\t\t\t\t\t\t\tx.push_back((val = tnp._Find_first()) + delta);\n\t\t\t\t\t\t\ty.push_back((val = tnp._Find_next(val)) + delta);\n\t\t\t\t\t\t\tz.push_back((val = tnp._Find_next(val)) + delta);\n\t\t\t\t\t\t\tpos = from[pos];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"NO\\n\");\n\t\texit(0);\n\t}\n}\nint n, a[MAXN];\nint main() {\n\t//freopen(\"problem.in\", \"r\", stdin);\n\t//freopen(\"problem.out\", \"w\", stdout);\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tif (n <= 12) force :: work(a, n, 0);\n\telse {\n\t\tint head = 1, back = n;\n\t\twhile (back - head >= 12 && a[head] == 0) head++;\n\t\twhile (back - head >= 12 && a[back] == 0) back--;\n\t\twhile (back - head >= 12) {\n\t\t\tif (a[head] + a[head + 1] + a[head + 2] == 3) {\n\t\t\t\ta[head] = a[head + 1] = a[head + 2] = 0;\n\t\t\t\tx.push_back(head);\n\t\t\t\ty.push_back(head + 1);\n\t\t\t\tz.push_back(head + 2);\n\t\t\t} else if (a[back] + a[back - 1] + a[back - 2] == 3) {\n\t\t\t\ta[back] = a[back - 1] = a[back - 2] = 0;\n\t\t\t\tx.push_back(back);\n\t\t\t\ty.push_back(back - 1);\n\t\t\t\tz.push_back(back - 2);\n\t\t\t} else if ((head + back) % 2 == 0) {\n\t\t\t\ta[head] = a[back] = 0;\n\t\t\t\tint mid = (head + back) / 2;\n\t\t\t\ta[mid] = 1 - a[mid];\n\t\t\t\tx.push_back(head);\n\t\t\t\ty.push_back(back);\n\t\t\t\tz.push_back(mid);\n\t\t\t} else if (a[head + 1] == 1) {\n\t\t\t\ta[head + 1] = a[back] = 0;\n\t\t\t\tint mid = (head + 1 + back) / 2;\n\t\t\t\ta[mid] = 1 - a[mid];\n\t\t\t\tx.push_back(head + 1);\n\t\t\t\ty.push_back(back);\n\t\t\t\tz.push_back(mid);\n\t\t\t} else if (a[back - 1] == 1) {\n\t\t\t\ta[head] = a[back - 1] = 0;\n\t\t\t\tint mid = (head + back - 1) / 2;\n\t\t\t\ta[mid] = 1 - a[mid];\n\t\t\t\tx.push_back(head);\n\t\t\t\ty.push_back(back - 1);\n\t\t\t\tz.push_back(mid);\n\t\t\t} else if (a[head + 2] == 1) {\n\t\t\t\ta[head + 2] = a[head] = 0;\n\t\t\t\ta[head + 4] = 1 - a[head + 4];\n\t\t\t\tx.push_back(head);\n\t\t\t\ty.push_back(head + 2);\n\t\t\t\tz.push_back(head + 4);\n\t\t\t} else if (a[back - 2] == 1) {\n\t\t\t\ta[back - 2] = a[back] = 0;\n\t\t\t\ta[back - 4] = 1 - a[back - 4];\n\t\t\t\tx.push_back(back);\n\t\t\t\ty.push_back(back - 2);\n\t\t\t\tz.push_back(back - 4);\n\t\t\t} else {\n\t\t\t\tint tmp = back - 3;\n\t\t\t\ta[head] = 1 - a[head];\n\t\t\t\ta[tmp] = 1 - a[tmp];\n\t\t\t\tint mid = (head + tmp) / 2;\n\t\t\t\ta[mid] = 1 - a[mid];\n\t\t\t\tx.push_back(head);\n\t\t\t\ty.push_back(tmp);\n\t\t\t\tz.push_back(mid);\n\t\t\t}\n\t\t\twhile (back - head >= 12 && a[head] == 0) head++;\n\t\t\twhile (back - head >= 12 && a[back] == 0) back--;\n\t\t}\n\t\tforce :: work(a + head - 1, back - head + 1, head - 1);\n\t}\n\tprintf(\"YES\\n\");\n\tassert((int) x.size() <= n / 3 + 12);\n\twriteln(x.size());\n\tfor (unsigned i = 0; i < x.size(); i++)\n\t\tprintf(\"%d %d %d\\n\", x[i], y[i], z[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Triple Flips.json",
    "editorial_link": "https://codeforces.com//blog/entry/62612",
    "editorial": "This problem has a lot of solutions including those ones which are difficult to prove. Let's describe one of the author's solutions.\n\nWe can find answer with bruteforce if size of array is rather small. For example we can check all combinations of arithmetic progressions with length equals to three.\n\nWe can find by hand or bruteforce that for 3?n?7\n arrays with no solution exists but for n=8\n (and consequently for n?8\n) we always can make all elements be equal to zero.\n\nWe want solution with such steps:\n\nIf n\n is small just run bruteforce\nElse try to make all elements besides the first k\n (k?8\n) be equal to zero\nRun bruteforce on the first k\n elements.\nHow to make the second step? Let's try to make three last elements of array be equal to zero with only one operation. We can use previous elements. So if we have array \u0085,0,0,1\n we can change values of the first, the fourth and the seventh elements from the end. But \u0085,0,1,1\n is counter-example.\n\nOk, let's try to make six last elements of array be equal to zero with two operations. We can check by hand or bruteforce that it can be done and n?11\n is enough.\n\nSo we have such solution:\n\nLet k\n is the number of first elements of array which we didn't try to make be equal to zero. In the start k=n\nWhile k?11\n make k\n-th, (k?1)\n-th,.., (k?5)\n-th elements be equal to zero. Subtract 6 from k\n.\nIf k?10\n run bruteforce on the first 10\n elements or on the whole array if n<10\n.\nHow many operations will be done?\n\nIn the second item the number of operations is less or equal than 2??n6???n3?\nIn the third item the number of operations is less or equal than 6 (can be checked by hand or bruteforce)\nSo the total number of operations is less or equal than ?n3?+6\n, what is good enough."
}