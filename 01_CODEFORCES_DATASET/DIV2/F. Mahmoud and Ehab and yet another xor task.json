{
    "link": "https://codeforces.com//contest/959/problem/F",
    "problemId": "170883",
    "problem_idx": "F",
    "shortId": "959F",
    "contest_number": "959",
    "problem_submissions": {
        "F": [
            36922958,
            36921545,
            36916491,
            36923329,
            36927067,
            36929072,
            36922529,
            36949027,
            36923867
        ],
        "D": [
            36916641,
            36918902,
            36913950,
            36921936,
            36920649,
            36922086,
            36938795,
            36921202,
            36919547,
            36921230,
            36920592,
            36944605,
            36921671,
            36921791,
            36916069,
            36920555,
            36925905,
            36924207,
            36923247
        ],
        "E": [
            36914501,
            36913015,
            36925858,
            36917118,
            36923111,
            36917652,
            36920424,
            36917502,
            36915031,
            36915660,
            36915376,
            36919671,
            36917632,
            36917697,
            36920779,
            36924711,
            36918716,
            36918302,
            36918515
        ],
        "C": [
            36911904,
            36911030,
            36920972,
            36913089,
            36913595,
            36913140,
            36914345,
            36913057,
            36911886,
            36913682,
            36913398,
            36917432,
            36913393,
            36914727,
            36913492,
            36914481,
            36914594,
            36913357,
            36914333
        ],
        "B": [
            36910571,
            36909536,
            36910083,
            36911621,
            36910450,
            36910777,
            36911891,
            36911461,
            36909624,
            36911118,
            36910588,
            36915553,
            36910516,
            36911975,
            36910706,
            36910209,
            36911346,
            36910873,
            36911805
        ],
        "A": [
            36909207,
            36907273,
            36907351,
            36907609,
            36907481,
            36907506,
            36907642,
            36908528,
            36907595,
            36907279,
            36907604,
            36911260,
            36907582,
            36908413,
            36907465,
            36907398,
            36907769,
            36907688,
            36907674
        ]
    },
    "name": "F. Mahmoud and Ehab and yet another xor task",
    "statement": "Ehab has an array of integers. He likes the bitwise-xor operation and he\r\nlikes to bother Mahmoud so he came up with a problem. He gave Mahmoud\r\nqueries. In each of them, he gave Mahmoud 2 integers and , and asked him\r\nto find the number of subsequences of the first elements of the array\r\nsuch that their bitwise-xor sum is . Can you help Mahmoud answer the\r\nqueries?A subsequence can contain elements that are not neighboring.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = (1<<20) + 10;\nconst int MOD = 1e9 + 7;\n\nint n, q, a[MAXN], l[MAXN], x[MAXN], sec[MAXN];\nint par[MAXN], tt[MAXN], t2 = 1;\nint save[MAXN];\nvector<int> bases;\nint ans[MAXN];\n\nint getPar(int v){return par[v]==v?v:par[v]=getPar(par[v]);}\n\nbool cmp(int q1, int q2){return l[q1] < l[q2];}\n\nvoid addBase(int base){\n\tbases.push_back(base);\n\tfor (int i = 0; i < 1<<20; i++) tt[i] = 1ll*tt[i]*t2%MOD;\n\tt2 = 1;\n\tfor (int i = 0; i < 1<<20; i++){\n\t\tint pu = getPar(i), pv = getPar(i^base);\n\t\tif (pu == pv) continue;\n\t\tpar[pu] = pv;\n\t\ttt[pv] += tt[pu];\n\t\tif (tt[pv] >= MOD) tt[pv] -= MOD;\n\t}\n}\n\nvoid addVec(int ind){\n\tint v = a[ind];\n\tfor (int u:bases)\n\t\tif (v>>save[u]&1)\n\t\t\tv ^= u;\n\n\tif (v)\n\t\taddBase(v);\n\telse{\n\t\tt2 += t2;\n\t\tif (t2 >= MOD) t2 -= MOD;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor (int i = 0; i < MAXN; i++) save[i] = 31 - __builtin_clz(i);\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tfor (int i = 0; i < q; i++) cin >> l[i] >> x[i];\n\tiota(sec, sec + q, 0);\n\tsort(sec, sec + q, cmp);\n\n\tiota(par, par + MAXN, 0);\n\ttt[0] = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < q; i++){\n\t\tint id = sec[i];\n\t\twhile (cur < l[id]) addVec(cur++);\n\t\tans[id] = 1ll*tt[getPar(x[id])]*t2%MOD;\n\t}\n\tfor (int i = 0; i < q; i++)\n\t\tcout << ans[i] << \"\\n\";\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "math",
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mahmoud and Ehab and yet another xor task.json",
    "editorial_link": "https://codeforces.com//blog/entry/58712",
    "editorial": "Let\u00e2\u0080\u0099s solve a simpler version of the problem. Assume the queries only\r\nask you to see whether the answer is 0 or positive instead of the exact\r\nanswer. We can answer all the queries offline. We can keep a set\r\ncontaining all the possible xors of subsequences and update it for each\r\nprefix. Initially, the set contains only 0 (the xor of the empty\r\nsubsequence). For each index in the array, we can update the set by\r\nadding to the set for all in the set. The intuition behind it is that\r\nthere\u00e2\u0080\u0099s a subsequence with xor equal to (as is in the set) and if we add\r\nto it, its xor will be , so we should add it to the set. That\u00e2\u0080\u0099s a slow\r\nsolution to update the set, but we have some observations:- Basically,\r\nif is already in the set, we do nothing because updating the set would\r\ndo nothing but extra operations according to the first observation, and\r\nif isn\u00e2\u0080\u0099t in the set, we don\u00e2\u0080\u0099t even waste a single operation without\r\nextending the set! That makes the total complexity or depending on\r\nimplementation because each element is added to the set exactly once. To\r\nsolve our problem, let\u00e2\u0080\u0099s see the naiive dynamic programming solution.\r\nLet be the number of subsequences of the first elements with xor . . The\r\nintuition behind it is exactly the same as the intuition behind the set\r\nconstruction. Let\u00e2\u0080\u0099s prove that is equal for all belonging to the set!\r\nLet\u00e2\u0080\u0099s assume this holds true for and see what happens in the transition\r\nto . Notice that it holds true for . Let be the value that is equal to\r\nfor all belonging to the set. If is in the set, and is in the set, is in\r\nthe set (observation 1). Therefore, and which makes for all in the set.\r\nNotice that the set doesn\u00e2\u0080\u0099t change so for all that aren\u00e2\u0080\u0099t in the set. If\r\nisn\u00e2\u0080\u0099t in the set, we have 3 cases for . If is in the set, isn\u00e2\u0080\u0099t in the\r\nset. Therefore, . If is to be added to the set in this step, is in the\r\nset. Therefore, . Otherwise, . To summarize, we\u00e2\u0080\u0099ll maintain the set. For\r\neach integer, if it\u00e2\u0080\u0099s in the set, we\u00e2\u0080\u0099ll just multiply by 2. Otherwise,\r\nwe\u00e2\u0080\u0099ll update the set. We\u00e2\u0080\u0099ll then answer all the queries for that prefix\r\n(saying 0 or ) depending on whether is in the set. Code link (me) :\r\nhttps://pastebin.com/Kfi0NWTi Time complexity : if you implement the\r\n\"set\" with a vector and an array. Bonus task : Can you make this\r\nsolution work online? Can you do that with ? SolutionLet\u00e2\u0080\u0099s consider each\r\nnumber as a vector in a 30-dimensional space. The coordinate will be 1\r\nif the bit is 1 and 0 otherwise. The bitwise-xor operation of 2 integers\r\nis equivalent to adding the 2 vectors modulo 2. Therefore, ordinary\r\nmethods of linear algebra work! A linear combination of some vectors is\r\nachieved by multiplying each vector by 0 or 1 and summing them up\r\n(modulo 2). Let\u00e2\u0080\u0099s find the basis (the vectors such that any vector can\r\nbe formed as a linear combination of them). To do that, we\u00e2\u0080\u0099ll just use\r\ngaussian elimination. There can\u00e2\u0080\u0099t be more than 30 basis vectors. In each\r\nquery, we\u00e2\u0080\u0099ll find the basis vectors with index less than or equal to and\r\ncheck that can be formed by a linear combination of them with gaussian\r\nelimination. If it can\u00e2\u0080\u0099t, the answer is of course 0. Otherwise, let the\r\nnumber of basis vectors be . The answer is . The reason is that for each\r\nsubsequence of the vectors that aren\u00e2\u0080\u0099t basis vectors, we can add a\r\nlinear combination of the basis vectors to it and achieve . Their count\r\nis . I strongly recommend this linear algebra tutorial to understand the\r\nintuitions.\r\n"
}