{"link": "https://codeforces.com//contest/959/problem/F", "problemId": "170883", "problem_idx": "F", "shortId": "959F", "contest_number": "959", "problem_submissions": {"F": [36922958, 36921545, 36916491, 36923329, 36927067, 36929072, 36922529, 36949027, 36923867], "D": [36916641, 36918902, 36913950, 36921936, 36920649, 36922086, 36938795, 36921202, 36919547, 36921230, 36920592, 36944605, 36921671, 36921791, 36916069, 36920555, 36925905, 36924207, 36923247], "E": [36914501, 36913015, 36925858, 36917118, 36923111, 36917652, 36920424, 36917502, 36915031, 36915660, 36915376, 36919671, 36917632, 36917697, 36920779, 36924711, 36918716, 36918302, 36918515], "C": [36911904, 36911030, 36920972, 36913089, 36913595, 36913140, 36914345, 36913057, 36911886, 36913682, 36913398, 36917432, 36913393, 36914727, 36913492, 36914481, 36914594, 36913357, 36914333], "B": [36910571, 36909536, 36910083, 36911621, 36910450, 36910777, 36911891, 36911461, 36909624, 36911118, 36910588, 36915553, 36910516, 36911975, 36910706, 36910209, 36911346, 36910873, 36911805], "A": [36909207, 36907273, 36907351, 36907609, 36907481, 36907506, 36907642, 36908528, 36907595, 36907279, 36907604, 36911260, 36907582, 36908413, 36907465, 36907398, 36907769, 36907688, 36907674]}, "name": "F. Mahmoud and Ehab and yet another xor task", "statement": "Ehab has an array of integers. He likes the bitwise-xor operation and he\r\nlikes to bother Mahmoud so he came up with a problem. He gave Mahmoud\r\nqueries. In each of them, he gave Mahmoud 2 integers and , and asked him\r\nto find the number of subsequences of the first elements of the array\r\nsuch that their bitwise-xor sum is . Can you help Mahmoud answer the\r\nqueries?A subsequence can contain elements that are not neighboring.\r\n", "solutions": ["#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = (1<<20) + 10;\nconst int MOD = 1e9 + 7;\n\nint n, q, a[MAXN], l[MAXN], x[MAXN], sec[MAXN];\nint par[MAXN], tt[MAXN], t2 = 1;\nint save[MAXN];\nvector<int> bases;\nint ans[MAXN];\n\nint getPar(int v){return par[v]==v?v:par[v]=getPar(par[v]);}\n\nbool cmp(int q1, int q2){return l[q1] < l[q2];}\n\nvoid addBase(int base){\n\tbases.push_back(base);\n\tfor (int i = 0; i < 1<<20; i++) tt[i] = 1ll*tt[i]*t2%MOD;\n\tt2 = 1;\n\tfor (int i = 0; i < 1<<20; i++){\n\t\tint pu = getPar(i), pv = getPar(i^base);\n\t\tif (pu == pv) continue;\n\t\tpar[pu] = pv;\n\t\ttt[pv] += tt[pu];\n\t\tif (tt[pv] >= MOD) tt[pv] -= MOD;\n\t}\n}\n\nvoid addVec(int ind){\n\tint v = a[ind];\n\tfor (int u:bases)\n\t\tif (v>>save[u]&1)\n\t\t\tv ^= u;\n\n\tif (v)\n\t\taddBase(v);\n\telse{\n\t\tt2 += t2;\n\t\tif (t2 >= MOD) t2 -= MOD;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor (int i = 0; i < MAXN; i++) save[i] = 31 - __builtin_clz(i);\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tfor (int i = 0; i < q; i++) cin >> l[i] >> x[i];\n\tiota(sec, sec + q, 0);\n\tsort(sec, sec + q, cmp);\n\n\tiota(par, par + MAXN, 0);\n\ttt[0] = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < q; i++){\n\t\tint id = sec[i];\n\t\twhile (cur < l[id]) addVec(cur++);\n\t\tans[id] = 1ll*tt[getPar(x[id])]*t2%MOD;\n\t}\n\tfor (int i = 0; i < q; i++)\n\t\tcout << ans[i] << \"\\n\";\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp", "math", "matrices"], "dificulty": "2400", "interactive": false}