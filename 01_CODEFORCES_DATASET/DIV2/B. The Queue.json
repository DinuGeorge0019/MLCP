{
    "link": "https://codeforces.com//contest/767/problem/B",
    "problemId": "94681",
    "problem_idx": "B",
    "shortId": "767B",
    "contest_number": "767",
    "problem_submissions": {
        "E": [
            24773688,
            24758593,
            24766542,
            24771366,
            24781051,
            24771141,
            24779799,
            24793086,
            24815876,
            24813453,
            24777026
        ],
        "D": [
            24763626,
            24761005,
            24762891,
            24764024,
            24762582,
            24766354,
            24757953,
            24768943,
            24767743,
            24772654,
            24771704,
            24762285,
            24776438,
            24769130,
            24767445,
            24768099,
            24766844,
            24758983,
            24768020,
            24763075,
            24760035
        ],
        "C": [
            24761320,
            24765332,
            24760448,
            24761283,
            24759373,
            24763235,
            24759987,
            24766222,
            24769355,
            24767653,
            24765828,
            24761673,
            24774191,
            24769625,
            24760821,
            24762590,
            24762307,
            24759906,
            24765569
        ],
        "B": [
            24759162,
            24783957,
            24766261,
            24758310,
            24773199,
            24761589,
            24765216,
            24759680,
            24761807,
            24765169,
            24760359,
            24760779,
            24771356,
            24771320,
            24788532
        ],
        "A": [
            24756659,
            24769945,
            24755736,
            24756082,
            24755178,
            24755290,
            24755126,
            24755429,
            24755320,
            24755950,
            24755426,
            24755130,
            24770401,
            24755414,
            24755517,
            24761778,
            24755322,
            24757132,
            24755145,
            24761825
        ]
    },
    "name": "B. The Queue",
    "statement": "Finally! Vasya have come of age and that means he can finally get a\r\npassport! To do it, he needs to visit the passport office, but it\u2019s not\r\nthat simple. There\u2019s only one receptionist at the passport office and\r\npeople can queue up long before it actually opens. Vasya wants to visit\r\nthe passport office tomorrow.He knows that the receptionist starts\r\nworking after minutes have passed after midnight and closes after\r\nminutes have passed after midnight (so that is the last minute when the\r\nreceptionist is still working). The receptionist spends exactly minutes\r\non each person in the queue. If the receptionist would stop working\r\nwithin minutes, he stops serving visitors (other than the one he already\r\nserves). Vasya also knows that exactly visitors would come tomorrow. For\r\neach visitor Vasya knows the point of time when he would come to the\r\npassport office. Each visitor queues up and doesn\u2019t leave until he was\r\nserved. If the receptionist is free when a visitor comes (in particular,\r\nif the previous visitor was just served and the queue is empty), the\r\nreceptionist begins to serve the newcomer immediately. For each visitor,\r\nthe point of time when he would come to the passport office is positive.\r\nVasya can come to the office at the time zero (that is, at midnight) if\r\nhe needs so, but he can come to the office only at integer points of\r\ntime. If Vasya arrives at the passport office at the same time with\r\nseveral other visitors, he yields to them and stand in the queue after\r\nthe last of them.Vasya wants to come at such point of time that he will\r\nbe served by the receptionist, and he would spend the minimum possible\r\ntime in the queue. Help him!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nlong long int S,E,L,res,bes;\nint n;\nvoid upd(long long int wait, long long int tt){\n\tif(bes == -1 || bes > wait)\n\t\tbes = wait, res = tt;\n}\nint main(){\n\tscanf(\"%I64d%I64d%I64d\",&S,&E,&L);\n\tscanf(\"%d\",&n);\n\tbes = -1;\n\tres = -1;\n\tlong long int now = S;\n\tfor(int i=0; i<n; i++){\n\t\tlong long int tt;\n\t\tscanf(\"%I64d\",&tt);\n\t\tif(now >= tt){\n\t\t\tif(now + L > E)break;\n\t\t\tlong long int wait = now - (tt-1);\n\t\t\tupd(wait, tt-1);\n\t\t\tnow += L;\n\t\t}else{\n\t\t\tupd(0, now);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(now + L <= E)\n\t\tupd(0, now);\n\tprintf(\"%I64d\\n\",res);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The Queue.json",
    "editorial_link": "https://codeforces.com//blog/entry/50498",
    "editorial": "Let\u00e2\u0080\u0099s calculate the point of time when each visitor would be served. Let\r\narray contain the points of time when visitors arrive. The receptionist\r\nwould begin to serve the first visitor at the point of time when the\r\nreceptionist begins to work , if the first visitor came to the passport\r\noffice before it, or when he comes to the office, if he didn\u00e2\u0080\u0099t. We can\r\ncalculate the point of time when the receptionist would begin to serve\r\nthe -th visitor in the same way if we know when the receptionist began\r\nto serve the -th visitor. Let\u00e2\u0080\u0099s suppose that the receptionist began to\r\nserve the -th visitor at minute. It means that receptionist would begin\r\nto serve the -th visitor no sooner than minutes later, that is minute.\r\nThe receptionist would begin to serve him at this point of time if -th\r\nvisitor came before (). If he came later, his serving would begin when\r\nhe comes. This way we will find the time when the receptionist would\r\nbegin to serve him.If any visitor came later than the previous visitor\r\nwas served (), the receptionist was free. It means that Vasya can be\r\nserved immediately if he arrives at the proper time, for example, at\r\nminute. If there are no such visitors, to be the -th person served this\r\nday, Vasya has to arrive at the passport office no later than and he\r\nwould have to wait a minimum of minutes. From all of these options we\r\nhave to find a point of time with the minimal waiting time.There are\r\nseveral special cases we have to consider: If - and - visitors arrived\r\nat the same time, Vasya can\u00e2\u0080\u0099t arrive between them. Some visitors\r\nwouldn\u00e2\u0080\u0099t be served this day if the time the receptionist would begin to\r\nserve them is more or equal to and that means we shouldn\u00e2\u0080\u0099t attive to the\r\npassport office after them. Vasya can be the last person served this day\r\nif there are at least minutes between the point of time receptionist\r\nserves the last customer and the point of time he stops working. Vasya\r\ncan be the first person served only if he comes before every other\r\nvisitor. Considering the bound, all calculations should use the 64-bit\r\ndata.To conclude, this task is reduced to careful calculation of the\r\nvisitors\u00e2\u0080\u0099 serving times ( time), considering the aforementioned edge\r\ncases.\r\n"
}