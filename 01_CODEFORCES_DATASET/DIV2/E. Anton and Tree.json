{
    "link": "https://codeforces.com//contest/734/problem/E",
    "problemId": "80477",
    "problem_idx": "E",
    "shortId": "734E",
    "contest_number": "734",
    "problem_submissions": {
        "F": [
            22242677,
            22263963
        ],
        "D": [
            22237702,
            22238671,
            22238436,
            22238926,
            22238773,
            22237833,
            22241230,
            22239041,
            22239616,
            22240014,
            22239208,
            22240034,
            22240178,
            22236173,
            22238427,
            22246118,
            22238956,
            22239478,
            22239903,
            22238000
        ],
        "C": [
            22234888,
            22234918,
            22235409,
            22236073,
            22235114,
            22235451,
            22235615,
            22235516,
            22234702,
            22235336,
            22234636,
            22235118,
            22237525,
            22238970,
            22235561,
            22239159,
            22235440,
            22236588,
            22236772,
            22235639
        ],
        "B": [
            22228951,
            22228069,
            22228596,
            22229294,
            22228497,
            22229303,
            22229501,
            22229322,
            22228369,
            22229545,
            22228175,
            22229688,
            22229766,
            22229538,
            22230326,
            22233850,
            22229247,
            22231472,
            22229353,
            22228678
        ],
        "A": [
            22226500,
            22226334,
            22226410,
            22226760,
            22226352,
            22226714,
            22226436,
            22226603,
            22226585,
            22226921,
            22226580,
            22226632,
            22227401,
            22227664,
            22229822,
            22226975,
            22228813,
            22226738,
            22226445
        ],
        "E": [
            22241795,
            22241633,
            22241388,
            22240916,
            22242495,
            22246165,
            22242439,
            22243868,
            22243102,
            22245799,
            22245135,
            22244767,
            22245998,
            22247226,
            22236319,
            22244870,
            22244604,
            22244885,
            22244356
        ]
    },
    "name": "E. Anton and Tree",
    "statement": "Anton is growing a tree in his garden. In case you forgot, the tree is a\r\nconnected acyclic undirected graph.There are vertices in the tree, each\r\nof them is painted black or white. Anton doesn\u2019t like multicolored\r\ntrees, so he wants to change the tree such that all vertices have the\r\nsame color (black or white).To change the colors Anton can use only\r\noperations of one type. We denote it as , where is some vertex of the\r\ntree. This operation changes the color of all vertices such that all\r\nvertices on the shortest path from to have the same color (including and\r\n). For example, consider the tree and apply operation to get the\r\nfollowing: Anton is interested in the minimum number of operation he\r\nneeds to perform in order to make the colors of all vertices equal.\r\n",
    "solutions": [
        "//Daniel Grzegorzewski\n#include <bits/stdc++.h>\n\n#define MP make_pair\n#define PB push_back\n#define ST first\n#define ND second\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef long long LL;\n\nvoid init_ios()\n{\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n}\n\nconst int N = 2*(int)1e5 + 10;\n\nint n, c[N], p[N];\nVI child[N];\nbool vis[N];\nVI now[N];\nmap<PII, bool> ist;\n\nint Find(int x)\n{\n\tif (x == p[x])\n\t\treturn x;\n\treturn p[x] = Find(p[x]);\n}\n\nvoid Union(int x, int y)\n{\n\tx = Find(x);\n\ty = Find(y);\n\tp[x] = y;\n}\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\tfor (auto dz: child[v]) \n\t\tif (!vis[dz]) {\n\t\t\tif (c[dz] == c[v])\n\t\t\t\tUnion(dz, v);\n\t\t\tdfs(dz);\n\t\t}\n}\n\nvoid dfs2(int v)\n{\n\tvis[v] = true;\n\tfor (auto dz: child[v])\n\t\tif (!vis[dz]) {\n\t\t\tif (c[Find(dz)] != c[Find(v)] && ist.find({Find(dz), Find(v)}) == ist.end()) {\n\t\t\t\tint x = Find(v);\n\t\t\t\tint y = Find(dz);\n\t\t\t\tnow[x].PB(y);\n\t\t\t\tnow[y].PB(x);\n\t\t\t\tist[{x, y}] = ist[{y, x}] = true;\n\t\t\t}\n\t\t\tdfs2(dz);\n\t\t}\n}\n\nint v1, wys = -1;\nint odl = 0;\n\nvoid dfs3(int v, int h)\n{\n\tvis[v] = true;\n\tif (h > wys) {\n\t\tv1 = v;\n\t\twys = h;\n\t}\n\tfor (auto dz: now[v]) {\n\t\tif (!vis[dz])\n\t\t\tdfs3(dz, h+1);\n\t}\n}\n\nvoid dfs4(int v, int h)\n{\n\tvis[v] = true;\n\todl = max(odl, h);\n\tfor (auto dz: now[v]) {\n\t\tif (!vis[dz])\n\t\t\tdfs4(dz, h+1);\n\t}\n}\n\nint main()\n{\n    init_ios();\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n    \tp[i] = i;\n    \tcin >> c[i];\n    }\n    for (int i = 1; i < n; ++i) {\n    \tint x, y;\n    \tcin >> x >> y;\n    \tchild[x].PB(y);\n    \tchild[y].PB(x);\n    }\n    dfs(1);\n    for (int i = 1; i <= n; ++i)\n    \tvis[i] = false;\n    dfs2(1);\n    for (int i = 1; i <= n; ++i)\n    \tvis[i] = false;\n    for (int i = 1; i <= n; ++i) {\n    \tif (now[i].size() > 0) {\n    \t\tdfs3(i, 0);\n    \t\tfor (int i = 1; i <= n; ++i)\n    \t\t\tvis[i] = false;\n    \t\tdfs4(v1, 0);\n    \t\tcout<<(odl+1)/2<<\"\\n\";\n    \t\treturn 0;\n    \t}\n    }\n    cout<<\"0\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Anton and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/48397",
    "editorial": "At first, let\u00e2\u0080\u0099s observe that if we unite some two vertices connected by\r\nan edge, that are the same color, in one vertex, the answer will not\r\nchange. Let\u00e2\u0080\u0099s do this. Then, for instance, the tree will look in this\r\nway: We\u00e2\u0080\u0099ll also do such tree \"compression\" after every painting\r\noperation. Then, for instance, the tree will change after operation and\r\nthe tree \"compression\" in this way: It\u00e2\u0080\u0099s obvious that the tree will be\r\npainted in one color if and only if, when after such painting operations\r\nwith the \"compression\" only one vertex remains.Let\u00e2\u0080\u0099s call the tree\r\ndiameter maximal possible shortest path between two vertices of the\r\ntree. It\u00e2\u0080\u0099s not hard to observe that the tree will be painted in one\r\ncolor if and only if, when the tree diameter becomes equal to , because\r\nthe diameter is only in the tree with one vertex.Then, we\u00e2\u0080\u0099ll see the\r\nfollowing fact: the tree diameter can\u00e2\u0080\u0099t be decreased more than by two\r\nper one painting operation with the \"compression\". So the answer cannot\r\nbe less than , where is the tree diameter.Now, we\u00e2\u0080\u0099ll prove that it\u00e2\u0080\u0099s\r\nalways possible to paint the tree in operations. Find such vertex that\r\nthe shortest path from it to any other vertex doesn\u00e2\u0080\u0099t exceed . Such\r\nvertex can always be found, because otherwise the tree diameter won\u00e2\u0080\u0099t be\r\nless that , which is impossible. Now see that if we paint this vertex\r\ntimes, we will paint the tree in one color.Time complexity is .\r\n"
}