{
    "link": "https://codeforces.com//contest/1323/problem/D",
    "problemId": "555653",
    "problem_idx": "D",
    "shortId": "1323D",
    "contest_number": "1323",
    "problem_submissions": {
        "E": [
            72646123,
            72653285,
            72643665,
            72638538,
            72651824,
            72641452,
            73215564,
            74923998,
            74923708,
            73375083
        ],
        "D": [
            72641565,
            72643228,
            72648719,
            72647003,
            72657000,
            72637909,
            72646207,
            72643501,
            72637563,
            72646014,
            72647579,
            72648996,
            72648307,
            72652014,
            72649186,
            72646691,
            72649030,
            72650695,
            72651530
        ],
        "B": [
            72636401,
            72633103,
            72651379,
            72658721,
            72640042,
            72636596,
            72635014,
            72632358,
            72634390,
            72641816,
            72634710,
            72636519,
            72636057,
            72635279,
            72633123,
            72635193,
            72638653,
            72635061,
            72634039,
            72635382
        ],
        "A": [
            72633163,
            72628485,
            72649551,
            72644013,
            72634218,
            72632880,
            72629084,
            72628191,
            72629890,
            72628412,
            72628653,
            72634993,
            72629129,
            72628869,
            72628314,
            72629285,
            72631475,
            72629827,
            72628727,
            72629930
        ],
        "C": [
            72632322,
            72637080,
            72632032,
            72656932,
            72642708,
            72635949,
            72629179,
            72635274,
            72637583,
            72643824,
            72637576,
            72633880,
            72637844,
            72637960,
            72635809,
            72640203,
            72642430,
            72637773,
            72640096,
            72637917
        ],
        "F": [
            72957747
        ]
    },
    "name": "D. Present",
    "statement": "Catherine received an array of integers as a gift for March 8.\r\nEventually she grew bored with it, and she started calculated various\r\nuseless characteristics for it. She succeeded to do it for each one she\r\ncame up with. But when she came up with another one of all pairwise sums\r\nof elements in the array, she realized that she couldn\u2019t compute it for\r\na very large array, thus she asked for your help. Can you do it?\r\nFormally, you need to compute (a_1 + a_2)\r\noplus (a_1 + a_3)\r\noplus\r\nldots\r\noplus (a_1 + a_n)\r\noplus (a_2 + a_3)\r\noplus\r\nldots\r\noplus (a_2 + a_n)\r\nldots\r\noplus (a_{n-1} + a_n)\r\nHere x\r\noplus y is a bitwise XOR operation (i.e. x y in many modern programming\r\nlanguages). You can read about it in Wikipedia:\r\nhttps://en.wikipedia.org/wiki/Exclusive_orBitwise_operation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 1e7 + 5;\n\ntypedef pair<int,int>   ii;\n\nint t[N];\n\nint upd(int p,int v)    {\n    for(; p > 0 ; p -= p & -p)\n        t[p] += v;\n    return  1;\n}\nint get(int p)  {\n    if (p < 1)\n        p = 1;\n    int ans = 0;\n    for(; p < N ; p += p & -p)\n        ans += t[p];\n\n    return  ans;\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    vector<int> a(n);\n\n    for(int&x : a)\n        cin >> x;\n\n    int ans = 0;\n\n    for(int i = 28 ; i >= 0 ; --i)  {\n        int cnt = 0;\n\n        vector<int> v0;\n        vector<int> v1;\n\n        for(int x : a)  {\n            if (x >> i & 1)\n                v1.pb(x & ((2 << i) - 1));\n            else\n                v0.pb(x & ((2 << i) - 1));\n        }\n        for(int x : v1) upd(x,1);\n        for(int x : v0) {\n            int c = get((1 << i) - x) - get((2 << i) - x);\n            if (c & 1)\n                cnt ^= 1;\n\n            upd(x,1);\n        }\n        for(int x : v1) upd(x,-1);\n        for(int x : v0) upd(x,-1);\n\n        for(int&x : v1) {\n            x &= ((1 << i) - 1);\n\n            if (get((1 << i) - x) & 1)\n                cnt ^= 1;\n\n            upd(x,1);\n        }\n        for(int x : v1) upd(x,-1);\n\n        if (cnt)\n            ans ^= (1 << i);\n    }\n    cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "math",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Present.json",
    "editorial_link": "https://codeforces.com//blog/entry/74148",
    "editorial": "Let's calculate each bit in the answer separately. Suppose we want to know the value of k\n-th (in 0-indexation) bit in the answer. Then we can notice that we are only interested in bits from 0\n-th to k\n-th, which means that we can take all numbers modulo 2k+1\n. After that, the sum of the two numbers can't exceed 2k+2?2\n. k\n-th bit is 1 if and only if sum belongs to [2k;2k+1)\n or [2k+1+2k;2k+2?2]\n.\n\nSo, we have to count the number of pairs of numbers that give a sum that belongs to these segments. Let's sort all numbers (taken by modulo) and make a pass with two pointers or do binary searches for each number."
}