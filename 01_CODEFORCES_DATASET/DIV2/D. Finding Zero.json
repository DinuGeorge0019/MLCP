{"link": "https://codeforces.com//contest/1634/problem/D", "problemId": "1285096", "problem_idx": "D", "shortId": "1634D", "contest_number": "1634", "problem_submissions": {"D": [145448060, 145421218, 145416745, 145423344, 145443205, 145427784, 145443409, 145431341, 145433882, 145423790, 145432676, 145425041, 145425515, 145428134, 145433736, 145425560, 145429012, 145409353, 145450134], "F": [145433416, 145453477, 145451269, 145460505, 145460962, 145457398, 145463150, 146209818, 145424500, 146353080, 145461554], "E": [145417696, 145430773, 145437025, 145445326, 145418577, 145442374, 145429197, 145419121, 145409285, 145435196, 145437792, 145441628, 145453390, 145439700, 145444612, 145443262, 145449756, 145425032], "C": [145412708, 145407591, 145405856, 145408804, 145405037, 145408252, 145414142, 145411742, 145412561, 145404073, 145409362, 145407564, 145408646, 145418751, 145411128, 145416814, 145410703, 145419625, 145409764], "B": [145407070, 145396453, 145401718, 145400856, 145397249, 145398450, 145410765, 145408191, 145401469, 145397310, 145403868, 145398596, 145400216, 145410152, 145399502, 145397772, 145402171, 145398736, 145404461], "A": [145397151, 145395090, 145396464, 145396099, 145395149, 145395150, 145396024, 145395848, 145396137, 145395189, 159142248, 145403722, 145395766, 145395501, 145399119, 145395603, 145395368, 145397257, 145397479]}, "name": "D. Finding Zero", "statement": "We picked an array of whole numbers a_1, a_2,\r\nldots, a_n (0\r\nle a_i\r\nle 10^9) and concealed zero in it! Your goal is to find the location of\r\nthis zero, that is, to find i such that a_i = 0.You are allowed to make\r\nseveral queries to guess the answer. For each query, you can think up\r\nthree distinct indices i, j, k, and we will tell you the value of\r\nmax(a_i, a_j, a_k) -\r\nmin(a_i, a_j, a_k). In other words, we will tell you the difference\r\nbetween the maximum and the minimum number among a_i, a_j and a_k.You\r\nare allowed to make no more than 2\r\ncdot n - 2 queries, and after that you have two tries to guess where the\r\nzero is. That is, you have to tell us two numbers i and j and you win if\r\na_i = 0 or a_j = 0.Can you guess where we hid the zero?Note that the\r\narray in each test case is fixed beforehand and will not change during\r\nthe game. In other words, the interactor is not adaptive.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;\n    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;\n    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;\n    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nconst int mxn=1e3+3;\nint n;\nint a[mxn],b[mxn];\ninline int ask(int x,int y,int z){\n\tcout<<\"? \"<<x<<' '<<y<<' '<<z<<endl;\n\tfflush(stdout);\n\tint rt;cin>>rt;\n\treturn rt;\n}\ninline void print(int x,int y){\n\tcout<<\"! \"<<x<<' '<<y<<endl;\n\tfflush(stdout);\n\treturn;\n}\ninline void solve(){\n\tcin>>n;\n\tmemset(a,0,sizeof(a));\n\tmemset(b,0,sizeof(b));\n\tint pos1=1;\n\tint allsame=1;\n\tint lst=-1;\n\tfor(int i=3;i<=n;++i){\n\t\ta[i]=ask(1,2,i);\n\t\tif(a[i]>a[pos1])pos1=i;\n\t\tif(lst==-1)lst=a[i];\n\t\telse{\n\t\t\tif(a[i]!=lst){\n\t\t\t\tlst=a[i];\n\t\t\t\tallsame=0;\n\t\t\t}\n\t\t}\n\t}\n\tint allsame2=1,lst2=-1;\n\tint pos2=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(i==pos1)continue;\n\t\tb[i]=ask(1,i,pos1);\n\t\tif(b[i]>=b[pos2])pos2=i;\n\t\tif(lst2==-1)lst2=b[i];\n\t\telse if(lst2!=b[i])allsame2=0;\n\t}\n\tif(pos2==2)++pos2;\n\tif(pos2==pos1)++pos2;\n\n\tif(allsame==1){//this can all be x[1]-x[2]\n\t\tint t=ask(1,pos1,pos2);\n\t\tif(t<lst){\n\t\t\tprint(1,2);\n\t\t\treturn;\n\t\t}\n\t}\n//\tcerr<<\"! wtf \"<<pos1<<' '<<pos2<<'\\n';\n\t//now if both x[1] and x[2] isn't 0 this is okay\n\t//if x[2] is 0? what will happen?\n\t//a[i] will be x[i]. How to ensure it?\n\t//we can ask(2,pos1,pos2) to check\n\t//if x[1] is 0: it is smaller than either a[pos1] or a[pos2] we can return [1,1]\n\t//if x[2] is 0: this returns a[pos1 or pos2] then we can return [2,pos1 or pos2]\n\t//otherwise we can return [pos1,pos2]\n\t//oops,there still can be x[1] is max and pos1 is zero\n\tif(allsame2==1){\n\t\tprint(1,pos1);\n\t\treturn;\n\t}\n\tint t=ask(2,pos1,pos2);\n\tif((t<a[pos1] and t<=a[pos2]) or (t<=a[pos1] and t<a[pos2])){\n\t\tprint(1,2);\n\t\treturn;\n\t}\n\tif(t==a[pos1]){\n\t\tprint(2,pos1);\n\t\treturn;\n\t}\n\tif(t==a[pos2]){\n\t\tprint(2,pos2);\n\t\treturn;\n\t}\n\n\tprint(pos1,pos2);\n\treturn;\n}\nint main(){\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "interactive", "math"], "dificulty": "2000", "interactive": false}