{
    "link": "https://codeforces.com//contest/1333/problem/B",
    "problemId": "586754",
    "problem_idx": "B",
    "shortId": "1333B",
    "contest_number": "1333",
    "problem_submissions": {
        "E": [
            75896339,
            75896565,
            75977605,
            75896691,
            75897517,
            75909706,
            75903789,
            75909595,
            75887158,
            75892751,
            75911705,
            75893605,
            75903871,
            75907577,
            75907287,
            75905980,
            75911364,
            102357635
        ],
        "F": [
            75886038,
            75883944,
            75977662,
            75881660,
            75879950,
            75880078,
            75883983,
            75889261,
            75893323,
            75897108,
            75891281,
            75909072,
            75894697,
            75898619,
            75885706,
            75889606,
            75886207,
            75876954,
            75881193
        ],
        "D": [
            75864744,
            75869369,
            75977526,
            75869421,
            75870061,
            75872281,
            75875027,
            75874985,
            75876429,
            75882167,
            75873219,
            75876350,
            75881516,
            75880068,
            75879600,
            75883836,
            75901469,
            75865548,
            75870511
        ],
        "C": [
            75852521,
            75859230,
            75977465,
            75850790,
            75858133,
            75853774,
            75862591,
            75860649,
            75860611,
            75873215,
            75852933,
            75864634,
            75853173,
            75865167,
            75868921,
            75862158,
            75875332,
            75854728,
            75853080
        ],
        "B": [
            75848076,
            75848553,
            75977412,
            75847691,
            75848476,
            75846675,
            75848813,
            75851794,
            75895723,
            75859034,
            75846157,
            75848508,
            75884037,
            75854691,
            75852331,
            75853099,
            75848989,
            75850255,
            75846775
        ],
        "A": [
            75845195,
            75845040,
            75977221,
            75844826,
            75845093,
            75844889,
            75845001,
            75846626,
            75847661,
            75851327,
            75844724,
            75845218,
            75845746,
            75850998,
            75847105,
            75848789,
            75855160,
            75846223,
            75844893
        ]
    },
    "name": "B. Kind Anton",
    "statement": "Once again, Boris needs the help of Anton in creating a task. This time\r\nAnton needs to solve the following problem:There are two arrays of\r\nintegers a and b of length n. It turned out that array a contains only\r\nelements from the set\r\n{-1, 0, 1\r\n}.Anton can perform the following sequence of operations any number of\r\ntimes: Choose any pair of indexes (i, j) such that 1\r\nle i < j\r\nle n. It is possible to choose the same pair (i, j) more than once. Add\r\na_i to a_j. In other words, j-th element of the array becomes equal to\r\na_i + a_j. For example, if you are given array [1, -1, 0], you can\r\ntransform it only to [1, -1, -1], [1, 0, 0] and [1, -1, 1] by one\r\noperation.Anton wants to predict if it is possible to apply some number\r\n(zero or more) of these operations to the array a so that it becomes\r\nequal to array b. Can you help him?\r\n",
    "solutions": [
        "#include <iostream>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\n\nint const nmax = 100000;\nint v[1 + nmax], sol[1 + nmax];\n\nvoid solve(){\n  int n;\n  cin >> n;\n  for(int i = 1;i <= n; i++)\n    cin >> v[i];\n  for(int i = 1;i <= n; i++)\n    cin >> sol[i];\n  int y1 = 0, n1 = 0;\n  for(int i = 1;i <= n; i++){\n    if(v[i] < sol[i] && y1 == 0) {\n      cout << \"NO\\n\";\n      return ;\n    }\n    if(sol[i] < v[i] && n1 == 0){\n      cout << \"NO\\n\";\n      return ;\n    }\n    if(v[i] == 1)\n      y1 = 1;\n    else if(v[i] == -1)\n      n1 = 1;\n  }\n  cout << \"YES\\n\";\n}\n\nint main()\n{\n  int t;\n  cin >> t;\n  for(int testcase = 1; testcase <= t; testcase++)\n    solve();\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Kind Anton.json",
    "editorial_link": "https://codeforces.com//blog/entry/75802",
    "editorial": "First of all, note that we can add an element with index to an element\r\nwith index iff . This means that the element cannot be added to any\r\nother element because there is no index in the array. This is why we can\r\nfirst equalize the elements and . If , they are already equal. If , then\r\nwe need to have element equal to along the elements with indexes . For ,\r\nwe need to have along these elements. After the elements with index\r\nbecome equal, we can go to the element with index and do the same. Then\r\nindexes , , ..., . You can implement this idea yourself!Final time\r\ncomplexity:\r\n",
    "hint": []
}