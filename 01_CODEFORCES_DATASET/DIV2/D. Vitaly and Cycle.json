{
    "link": "https://codeforces.com//contest/557/problem/D",
    "problemId": "30556",
    "problem_idx": "D",
    "shortId": "557D",
    "contest_number": "557",
    "problem_submissions": {
        "E": [
            11869387,
            11865728,
            11877714,
            11864888,
            11889151,
            11866470
        ],
        "D": [
            11859147,
            11860748,
            11861182,
            11862277,
            11863181,
            11865161,
            11863844,
            11864866,
            11861291,
            11865190,
            11866413,
            11860722,
            11865833,
            11866312,
            11923092,
            11859036,
            11864665,
            11862418,
            11864374
        ],
        "C": [
            11856407,
            11858913,
            11855729,
            11859389,
            11860110,
            11858947,
            11859067,
            11857533,
            11865562,
            11859501,
            11860468,
            11865942,
            11862380,
            11854539,
            11861657,
            11909827,
            11857135,
            11858056,
            11856524
        ],
        "B": [
            11852804,
            11852275,
            11853400,
            11856628,
            11854078,
            11854825,
            11852839,
            11853621,
            11854966,
            11854901,
            11855996,
            11862048,
            11854417,
            11862769,
            11867200,
            11867503
        ],
        "A": [
            11852067,
            11853135,
            11852127,
            11855787,
            11852575,
            11852315,
            11854321,
            11852415,
            11852433,
            11853058,
            11852340,
            11861439,
            11852247,
            11857225,
            11853713,
            11864195,
            11852181,
            11852458,
            11852065
        ]
    },
    "name": "D. Vitaly and Cycle",
    "statement": "After Vitaly was expelled from the university, he became interested in\r\nthe graph theory.Vitaly especially liked the cycles of an odd length in\r\nwhich each vertex occurs at most once.Vitaly was wondering how to solve\r\nthe following problem. You are given an undirected graph consisting of\r\nvertices and edges, not necessarily connected, without parallel edges\r\nand loops. You need to find the minimum number of edges that must be\r\nadded to the given graph in order to form a simple cycle of an odd\r\nlength, consisting of more than one vertex. Moreover, he must find the\r\nnumber of ways to add edges in order to form a cycle of an odd length\r\n(consisting of more than one vertex). It is prohibited to add loops or\r\nparallel edges.Two ways to add edges to the graph are considered equal\r\nif they have the same sets of added edges.Since Vitaly does not study at\r\nthe university, he asked you to help him with this task.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair <long long, long long> \nvector <long long> edges [100005]; \nlong long vis [100005]; \nlong long color [100005]; \nvector <long long> nodes;\nlong long sz = 0, col1=0, col2=0; \nvoid dfs (long long node, long long col)\n{\n    color[node]=col; \n    nodes.push_back(node); \n    vis[node]=1;\n    if (col) col1++; else col2++; \n    sz++; \n    for (long long g=0; g<edges[node].size(); g++)\n    {\n        if (vis[edges[node][g]]) continue;\n        dfs(edges[node][g], 1-col); \n    }\n}\nbool check ()\n{\n    for (long long g=0; g<nodes.size(); g++)\n    {\n        long long node = nodes[g]; \n        for (long long y=0; y<edges[node].size(); y++)\n        {\n            if (color[node]==color[edges[node][y]]) return false;\n        }\n    }\n    return true;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0); \n    long long ans = 1; \n    long long n, m; cin >> n >> m; \n    if (m==0)\n    {\n        ans*=n*(n-1)*(n-2); \n        ans/=6; \n        cout << 3 << ' ' << ans; return 0; \n    }\n    if (m==1)\n    {\n        cout << 2 << ' ' << n-2; return 0; \n    }\n    for (long long g=0; g<m; g++)\n    {\n        long long a, b; cin >> a >> b;\n        edges[a].push_back(b);\n        edges[b].push_back(a); \n    }\n    long long flag=0; \n    long long answer=0; \n    for (long long g=1; g<=n; g++)\n    {\n        if (vis[g]) continue; \n        nodes.clear(); \n        dfs(g, 0); \n        if (sz<=2)\n        {\n            sz=0, col1=0, col2=0; continue; \n        }\n        flag=1; \n        if (!check())\n        {\n            cout << 0 << ' ' << 1; return 0; \n        }\n        answer+=((col1)*(col1-1))/2+((col2)*(col2-1))/2; \n        sz=0, col1=0, col2=0; \n    }\n    if (!flag)\n    {\n        cout <<2 << ' ' << 1LL*m*(n-2); \n        return 0;\n    }\n    cout << 1 << ' ' << answer; \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "graphs",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Vitaly and Cycle.json",
    "editorial_link": "https://codeforces.com//blog/entry/18943",
    "editorial": "To solve this problem we can use dfs which will check every connected component of graph on bipartite. It is clearly that count of edges which we need to add in graph to get the odd cycle is no more than three.\n\nAnswer to this problem is three if count of edges in graph is zero. Then the number of ways to add three edges in graph to make odd cycle is equals to n?*?(n?-?1)?*?(n?-?2)?/?6 where n \u0097 count of vertices in graph.\n\nAnswer to this problem is two if there is no connected component with number of vertices more than two. Then the number of ways to add two edges in graph to make odd cycle is equals to m?*?(n?-?2) where m \u0097 number of edges in graph.\n\nNow we have one case when there is at least one connected component with number of vertices more than two. Now we need to use dfs and try to split every component in two part. If for some component we can't do it that means that graph already has odd cycle and we need to print \"0 1\" and we can now finish our algorithm.\n\nIf all connected components in graph are bipartite then we need to iterate on them. Let cnt1 is the count of vertices in one part of current component and cnt2 \u0097 count of vertices in the other part. If number of vertices in this component more than two we need to add to answer cnt1?*?(cnt1?-?1)?/?2 and cnt2?*?(cnt2?-?1)?/?2.\n\nAsymptotic behavior of this solution \u0097 O(n?+?m), where n \u0097 number of vertices in graph and m \u0097 number of edges."
}