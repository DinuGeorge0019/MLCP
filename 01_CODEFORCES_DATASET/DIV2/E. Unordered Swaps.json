{
    "link": "https://codeforces.com//contest/1682/problem/E",
    "problemId": "1407923",
    "problem_idx": "E",
    "shortId": "1682E",
    "contest_number": "1682",
    "problem_submissions": {
        "F": [
            158050798,
            158077786,
            158086685,
            158039286,
            158069961,
            158110252,
            158078476,
            158248901
        ],
        "D": [
            158028363,
            158027200,
            158028814,
            158069864,
            158039569,
            158036346,
            158030046,
            158050282,
            158037974,
            158041123,
            158041068,
            158036998,
            158042298,
            158032953,
            158041526,
            158029661,
            158056637,
            158029667
        ],
        "C": [
            158015824,
            158013904,
            158013129,
            158070941,
            158017154,
            158019512,
            158011476,
            158017137,
            158021257,
            158018627,
            158020682,
            158022180,
            158021471,
            158039652,
            158019776,
            158037446,
            158028182
        ],
        "B": [
            158006894,
            158007821,
            158007318,
            158071816,
            158008119,
            158009978,
            158007984,
            158008572,
            158013225,
            158009923,
            158010666,
            158009973,
            158013386,
            158010013,
            158016214,
            158026210,
            158017588,
            158010270
        ],
        "A": [
            158004280,
            158004512,
            158004427,
            158072894,
            158004570,
            158007124,
            158005591,
            158005462,
            158005647,
            158004983,
            158006433,
            158004812,
            158012816,
            158004216,
            158013837,
            158039471,
            158008517,
            158004710
        ],
        "E": [
            158050246,
            158056393,
            158060063,
            158060073,
            158067774,
            158059309,
            158065396,
            158067467,
            158070762,
            158068042,
            158070815,
            158073429,
            158070617,
            158069678,
            158075426,
            158064743
        ]
    },
    "name": "E. Unordered Swaps",
    "statement": "Alice had a permutation p of numbers from 1 to n. Alice can swap a pair\r\n(x, y) which means swapping elements at positions x and y in p (i.e.\r\nswap p_x and p_y). Alice recently learned her first sorting algorithm,\r\nso she decided to sort her permutation in the number of swaps possible.\r\nShe wrote down all the swaps in the order in which she performed them to\r\nsort the permutation on a piece of paper. For example, [(2, 3), (1, 3)]\r\nis a valid swap sequence by Alice for permutation p = [3, 1, 2] whereas\r\n[(1, 3), (2, 3)] is not because it doesn\u2019t sort the permutation. Note\r\nthat we cannot sort the permutation in less than 2 swaps. [(1, 2), (2,\r\n3), (2, 4), (2, 3)] cannot be a sequence of swaps by Alice for p = [2,\r\n1, 4, 3] even if it sorts the permutation because p can be sorted in 2\r\nswaps, for example using the sequence [(4, 3), (1, 2)]. Unfortunately,\r\nBob shuffled the sequence of swaps written by Alice.You are given\r\nAlice\u2019s permutation p and the swaps performed by Alice in arbitrary\r\norder. Can you restore the correct sequence of swaps that sorts the\r\npermutation p? Since Alice wrote correct swaps before Bob shuffled them\r\nup, it is guaranteed that there exists some order of swaps that sorts\r\nthe permutation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[200005];\nint hson[200005],fa[200005],dep[200005],sz[200005],top[200005],dfn[200005],fin[200005],dfc,rnk[200005];\n\nint hldprec(int x,int p,int d){\n    dep[x]=d;\n    sz[x]=1;\n    for(int& y:g[x])if(y!=p){\n        sz[x]+=hldprec(y,x,d+1);\n        fa[y]=x;\n        if(sz[y]>sz[hson[x]]){\n            hson[x]=y;\n        }\n    }\n    return sz[x];\n}\n\nvoid hlddec(int x,int head){\n    top[x]=head;\n    dfn[x]=++dfc;\n    rnk[dfc]=x;\n    if(hson[x]){\n        hlddec(hson[x],head);\n        for(int &y:g[x])if(y!=fa[x]&&y!=hson[x]){\n            hlddec(y,y);\n        }\n    }\n    fin[x]=dfc;\n}\n\nint lca(int u,int v){\n    while(top[u]!=top[v]){\n        if(dep[top[u]]>dep[top[v]]){\n            u=fa[top[u]];\n        }else{\n            v=fa[top[v]];\n        }\n    }\n    return dep[u]<dep[v]?u:v;\n}\n\nint n,m,p[200005],u[200005],v[200005];\nmap<pair<int,int>,int> id;\n\nint nxt(int u){\n    if(p[u]==u)return u;\n    else if(lca(p[u],u)!=u)return fa[u];\n    else{\n        int v=p[u];\n        while(true){\n            if(top[v]==top[u])return rnk[dfn[u]+1];\n            if(fa[top[v]]==u)return top[v];\n            v=fa[top[v]];\n        }\n    }\n}\n\nstruct UnionFind{\n    int n;\n    vector<int> fa;\n\n    UnionFind(int _n=0){\n        fa.resize((n=_n)+1);\n        iota(fa.begin(),fa.end(),0);\n    }\n\n    int find(int x){\n        return fa[x]==x?x:fa[x]=find(fa[x]);\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        fa[x]=y;\n    }\n};\n\nint main(){\n\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)cin>>p[i];\n    queue<int> q;\n    UnionFind uf(n);\n    for(int i=1;i<=m;i++){\n        cin>>u[i]>>v[i];\n        id[{u[i],v[i]}]=i;\n        id[{v[i],u[i]}]=i;\n        g[u[i]].emplace_back(v[i]);\n        g[v[i]].emplace_back(u[i]);\n        uf.unite(u[i],v[i]);\n    }\n    for(int i=1;i<=n;i++)if(uf.find(i)!=uf.find(1)){\n        g[i].emplace_back(1);\n        g[1].emplace_back(i);\n        uf.unite(1,i);\n    }\n    hldprec(1,-1,0);\n    hlddec(1,1);\n    for(int i=1;i<=m;i++){\n        if(nxt(u[i])==v[i]&&nxt(v[i])==u[i]){\n            q.emplace(i);\n        }\n    }\n    while(!q.empty()){\n        int i=q.front();\n        q.pop();\n        cout<<i<<' ';\n        swap(p[u[i]],p[v[i]]);\n        int nu=nxt(u[i]),nv=nxt(v[i]);\n        if(nu!=u[i]&&nxt(nu)==u[i]){\n            q.emplace(id[{nu,u[i]}]);\n        }\n        if(nv!=v[i]&&nxt(nv)==v[i]){\n            q.emplace(id[{nv,v[i]}]);\n        }\n    }\n    cout<<'\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "math",
        "sortings",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Unordered Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/103097",
    "editorial": "TutorialOne way of solving permutation problems is to look at\r\npermutation cycles. Let\u00e2\u0080\u0099s decompose our permutation into cycles, then\r\nit\u00e2\u0080\u0099s easy to see that each cycle can be solved independently because we\r\nhave to sort the permutation in a minimum number of moves which isn\u00e2\u0080\u0099t\r\npossible if two cycles are merged at any instant.Let\u00e2\u0080\u0099s look at one cycle\r\nonly, whose vertices are numbered from to in the orientation of cycle\r\ni.e the cycle is . Also assume that we only have swaps that are relevant\r\nto this cycle.It is known that we can sort a cycle of size in moves and\r\nit is the minimum number of required moves.Claim 1: The set of swaps if\r\nconsidered as edges form a tree on the vertices of the cycle.\r\nProofAssume that the edges don\u00e2\u0080\u0099t form a tree, then there exist at least\r\ntwo disjoint components let\u00e2\u0080\u0099s say and . Now we must be able to make\r\nswaps inside only, to sort elements in which needs that the set {} is\r\nsame as set {} which is not possible by property of permutation cycles.\r\nAny cycle of permutation, say , can\u00e2\u0080\u0099t be split further into two sets and\r\nsuch that both of them can be sorted independently among themselves.So\r\nwe must use all the edges of the tree in some order to get cycles each\r\nof size .Let\u00e2\u0080\u0099s consider any element having adjacency list as in the\r\norder they appear on the cycle if we start moving from in the\r\norientation of cycle i.e .Claim 2: We can never make the swap before\r\nswap if . ProofIf we make the swap first, then and will go in different\r\ncycles for subsequent operations and we will never be able to use edge\r\nbecause it will merge the two different cycles which isn\u00e2\u0080\u0099t possible\r\nbecause we are constrained to break a cycle into smaller cycles only.And\r\nif are not able to use edge then we will never be able to sort the\r\npermutation because we had edges all of which were to be used and we\r\nwasted of them.Using above claim, for every element the order of edges\r\nis fixed i.e , then , ..., and finally .Let\u00e2\u0080\u0099s build a directed graph on\r\nvertices (representing the swaps) where for every element we add\r\ndirected edges , ..., .Since it is guaranteed that the answer will exist\r\ni.e a valid sequence of moves exist, hence the topological sorting of\r\nthe above graph must exist, any of which represents a correct sequence\r\nof swaps.Note that whenever we make a swap that is not violating claim\r\nfor any element , then there will be no cross edge in two smaller cycles\r\nthat are going to be formed and those smaller cycles can be further\r\nsolved independently. Also the order of edges i.e is not going to change\r\nfor any element which ensures that the directed graph we built remains\r\ncorrect even if we remove some appropriate edge.Hence the answer is\r\nsimply the topological sort of the graph we built.Overall Complexity: ,\r\nfor sorting the edges according to cycle\u00e2\u0080\u0099s orientation to get the order\r\nfor every vertex. Some other interesting things about this problemClaim:\r\nThe given swaps considered as edges forms a non-intersecting tree on\r\nvertices on the circle i.e no two edges intersect internally. Motivation\r\nfor problem D ProofLet\u00e2\u0080\u0099s say edges and intersect internally in the\r\ncircle.WLOG, let\u00e2\u0080\u0099s suppose we make swap before swap , then and will go\r\nin different cycles as in Claim above.What if you were given any tree on\r\nvertices and asked to solve the problem with \"YES/NO\"? If the given\r\nedges intersect internally in the circle then the answer is \"NO\"\r\notherwise it\u00e2\u0080\u0099s always possible to construct a valid sequence of swaps.\r\nThis is what the validator of E and checker of D do, try this one, and\r\nfeel free to discuss in the comments section. ValidatorLet\u00e2\u0080\u0099s make every\r\nedge such that , clearly the order of , doesn\u00e2\u0080\u0099t matter.Consider each\r\nedge as a segment , then the edges of the tree intersect internally if\r\nand only if any two segments say and satisfies any of the below\r\nconditions- In the original problem, it was mentioned that there is\r\nalways a correct sequence of swaps so we claimed that topological\r\nsorting must exist and indeed any topological sorting suffices. What if\r\nwe were given a non-intersecting spanning tree? Can we still claim that\r\nthere exists a correct move at every step?Claim: Yes, we can ProofWe\r\nneed to show that there there is always some edge that can be removed\r\nwithout breaking claim above which is the only required condition.Cycles\r\nof length are trivial.Let\u00e2\u0080\u0099s represent by the first element of the list\r\nfor i.e the closest vertex having an edge with in cycle\u00e2\u0080\u0099s\r\norientation.Now, let\u00e2\u0080\u0099s start an iteration, start moving from and jump to\r\nevery time when you are at vertex . Continue this process until you\r\nagain reach or cross over .Let the sequence obtained be i.e where on\r\nmoving further from we cross/reach . For simplicity assume , is\r\ntrivial.It can be shown that is the required edge. Proof lies between\r\nand . There are three cases other that this: lies between and , which is\r\nnot possible because we would have moved further and would not be the\r\nlast element of sequence . = which is not possible because it will\r\ncreate a cycle and we are given a tree. lies between and for , this is\r\nalso not possible because then the edges and will intersect and we are\r\ngiven a non-intersecting tree. is first element of adjacency list of by\r\nthe definition of and is the first element of adjacency list of by above\r\n3 points.Hence it is safe to make the swap .So the topological sort\r\nstill works.This might not be the only proof, if you have some other\r\nproofs feel free to discuss them in the comments.Hope you liked the\r\ndetails!! GeneratorAny ideas on how to write a generator for this\r\nproblem? My ApproachRandomly partition the permutation into cycles, so\r\ngenerating swaps for a particular cycle is the main issue.Let\u00e2\u0080\u0099s\r\nrepresent the cycle by an array of size with cycle as Now let\u00e2\u0080\u0099s start\r\nmaking random swaps say to break the cycle, then this generates two\r\nsmaller cycles - . . This can be easily done using treaps :) and then we\r\ncan use recursion to solve them independently. Review by Anton SirIt\u00e2\u0080\u0099s\r\nvery rare!! Atleast first time for us.\r\n"
}