{"link": "https://codeforces.com//contest/1682/problem/E", "problemId": "1407923", "problem_idx": "E", "shortId": "1682E", "contest_number": "1682", "problem_submissions": {"F": [158050798, 158077786, 158086685, 158039286, 158069961, 158110252, 158078476, 158248901], "D": [158028363, 158027200, 158028814, 158069864, 158039569, 158036346, 158030046, 158050282, 158037974, 158041123, 158041068, 158036998, 158042298, 158032953, 158041526, 158029661, 158056637, 158029667], "C": [158015824, 158013904, 158013129, 158070941, 158017154, 158019512, 158011476, 158017137, 158021257, 158018627, 158020682, 158022180, 158021471, 158039652, 158019776, 158037446, 158028182], "B": [158006894, 158007821, 158007318, 158071816, 158008119, 158009978, 158007984, 158008572, 158013225, 158009923, 158010666, 158009973, 158013386, 158010013, 158016214, 158026210, 158017588, 158010270], "A": [158004280, 158004512, 158004427, 158072894, 158004570, 158007124, 158005591, 158005462, 158005647, 158004983, 158006433, 158004812, 158012816, 158004216, 158013837, 158039471, 158008517, 158004710], "E": [158050246, 158056393, 158060063, 158060073, 158067774, 158059309, 158065396, 158067467, 158070762, 158068042, 158070815, 158073429, 158070617, 158069678, 158075426, 158064743]}, "name": "E. Unordered Swaps", "statement": "Alice had a permutation p of numbers from 1 to n. Alice can swap a pair\r\n(x, y) which means swapping elements at positions x and y in p (i.e.\r\nswap p_x and p_y). Alice recently learned her first sorting algorithm,\r\nso she decided to sort her permutation in the number of swaps possible.\r\nShe wrote down all the swaps in the order in which she performed them to\r\nsort the permutation on a piece of paper. For example, [(2, 3), (1, 3)]\r\nis a valid swap sequence by Alice for permutation p = [3, 1, 2] whereas\r\n[(1, 3), (2, 3)] is not because it doesn\u2019t sort the permutation. Note\r\nthat we cannot sort the permutation in less than 2 swaps. [(1, 2), (2,\r\n3), (2, 4), (2, 3)] cannot be a sequence of swaps by Alice for p = [2,\r\n1, 4, 3] even if it sorts the permutation because p can be sorted in 2\r\nswaps, for example using the sequence [(4, 3), (1, 2)]. Unfortunately,\r\nBob shuffled the sequence of swaps written by Alice.You are given\r\nAlice\u2019s permutation p and the swaps performed by Alice in arbitrary\r\norder. Can you restore the correct sequence of swaps that sorts the\r\npermutation p? Since Alice wrote correct swaps before Bob shuffled them\r\nup, it is guaranteed that there exists some order of swaps that sorts\r\nthe permutation.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[200005];\nint hson[200005],fa[200005],dep[200005],sz[200005],top[200005],dfn[200005],fin[200005],dfc,rnk[200005];\n\nint hldprec(int x,int p,int d){\n    dep[x]=d;\n    sz[x]=1;\n    for(int& y:g[x])if(y!=p){\n        sz[x]+=hldprec(y,x,d+1);\n        fa[y]=x;\n        if(sz[y]>sz[hson[x]]){\n            hson[x]=y;\n        }\n    }\n    return sz[x];\n}\n\nvoid hlddec(int x,int head){\n    top[x]=head;\n    dfn[x]=++dfc;\n    rnk[dfc]=x;\n    if(hson[x]){\n        hlddec(hson[x],head);\n        for(int &y:g[x])if(y!=fa[x]&&y!=hson[x]){\n            hlddec(y,y);\n        }\n    }\n    fin[x]=dfc;\n}\n\nint lca(int u,int v){\n    while(top[u]!=top[v]){\n        if(dep[top[u]]>dep[top[v]]){\n            u=fa[top[u]];\n        }else{\n            v=fa[top[v]];\n        }\n    }\n    return dep[u]<dep[v]?u:v;\n}\n\nint n,m,p[200005],u[200005],v[200005];\nmap<pair<int,int>,int> id;\n\nint nxt(int u){\n    if(p[u]==u)return u;\n    else if(lca(p[u],u)!=u)return fa[u];\n    else{\n        int v=p[u];\n        while(true){\n            if(top[v]==top[u])return rnk[dfn[u]+1];\n            if(fa[top[v]]==u)return top[v];\n            v=fa[top[v]];\n        }\n    }\n}\n\nstruct UnionFind{\n    int n;\n    vector<int> fa;\n\n    UnionFind(int _n=0){\n        fa.resize((n=_n)+1);\n        iota(fa.begin(),fa.end(),0);\n    }\n\n    int find(int x){\n        return fa[x]==x?x:fa[x]=find(fa[x]);\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        fa[x]=y;\n    }\n};\n\nint main(){\n\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)cin>>p[i];\n    queue<int> q;\n    UnionFind uf(n);\n    for(int i=1;i<=m;i++){\n        cin>>u[i]>>v[i];\n        id[{u[i],v[i]}]=i;\n        id[{v[i],u[i]}]=i;\n        g[u[i]].emplace_back(v[i]);\n        g[v[i]].emplace_back(u[i]);\n        uf.unite(u[i],v[i]);\n    }\n    for(int i=1;i<=n;i++)if(uf.find(i)!=uf.find(1)){\n        g[i].emplace_back(1);\n        g[1].emplace_back(i);\n        uf.unite(1,i);\n    }\n    hldprec(1,-1,0);\n    hlddec(1,1);\n    for(int i=1;i<=m;i++){\n        if(nxt(u[i])==v[i]&&nxt(v[i])==u[i]){\n            q.emplace(i);\n        }\n    }\n    while(!q.empty()){\n        int i=q.front();\n        q.pop();\n        cout<<i<<' ';\n        swap(p[u[i]],p[v[i]]);\n        int nu=nxt(u[i]),nv=nxt(v[i]);\n        if(nu!=u[i]&&nxt(nu)==u[i]){\n            q.emplace(id[{nu,u[i]}]);\n        }\n        if(nv!=v[i]&&nxt(nv)==v[i]){\n            q.emplace(id[{nv,v[i]}]);\n        }\n    }\n    cout<<'\\n';\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "greedy", "math", "sortings", "trees"], "dificulty": "2700", "interactive": false}