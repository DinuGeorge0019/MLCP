{
    "link": "https://codeforces.com//contest/546/problem/E",
    "problemId": "28219",
    "problem_idx": "E",
    "shortId": "546E",
    "contest_number": "546",
    "problem_submissions": {
        "B": [
            11232801,
            11217801,
            11208207,
            15820713,
            11208988,
            11208163,
            11214179,
            11208024,
            11209235,
            11209062,
            11213108,
            11222587,
            11239965,
            11217308,
            11219421,
            11209692,
            11207894,
            11206528,
            11223244,
            11207437
        ],
        "E": [
            11215556,
            11217224,
            11218687,
            15820839,
            11219998,
            11219690,
            11217920,
            11221959,
            11219074,
            11220044,
            11233270,
            11220684,
            11220215,
            11213115,
            11219305,
            11221891,
            11216762
        ],
        "D": [
            11212652,
            11212575,
            11214113,
            15820823,
            11215486,
            11214182,
            11210539,
            11224701,
            11215757,
            11216672,
            11219688,
            11216346,
            11219045,
            11223515,
            11214913,
            11225307,
            11215385,
            11211036,
            11216929,
            11224645
        ],
        "C": [
            11210837,
            11219636,
            11212924,
            15820760,
            11214060,
            11211479,
            11223248,
            11214103,
            11217677,
            11214503,
            11218679,
            11212971,
            11216434,
            11218455,
            11225176,
            11213620,
            11212347,
            11214814,
            11211103
        ],
        "A": [
            11204918,
            11205173,
            11205306,
            15820687,
            11205477,
            11205623,
            11214865,
            11205868,
            11206683,
            11224290,
            11206459,
            11205182,
            11205880,
            11207069,
            11206553,
            11204997,
            11204938,
            11207566,
            11205034
        ]
    },
    "name": "E. Soldier and Traveling",
    "statement": "In the country there are cities and bidirectional roads between them.\r\nEach city has an army. Army of the -th city consists of soldiers. Now\r\nsoldiers roam. After roaming each soldier has to either stay in his city\r\nor to go to the one of neighboring cities by at .Check if is it possible\r\nthat after roaming there will be exactly soldiers in the -th city.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\n#define INF 10000000\nint n,m;\n//vector<int>edge[105];\nint a[105],b[105],c[105];\n\nstruct edgee\n{\n\tint to,cap,rev;\n};\nvector<edgee>G[505];\nbool used[505];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edgee){to,cap,G[to].size()});\n\tG[to].push_back((edgee){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedgee &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\n\nint main(){\n\tcin >> n >> m;\n\tint sum = 0,sum2 = 0;\n\trep2(i,n){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\trep2(i,n){\n\t\tcin >> b[i];\n\t\tsum2 += b[i];\n\t}\n\trep2(i,n) add_edge(0,i,a[i]);\n\trep2(i,n) add_edge(200+i,500,b[i]);\n\trep2(i,n) add_edge(i,200+i,200);\n\trep(i,m){\n\t\tint u,v; cin >> u >> v;\n\t\tadd_edge(u,200+v,200);\n\t\tadd_edge(v,200+u,200);\n\t}\n\tint f = max_flow(0,500);\n\tif(f != sum || f != sum2){\n\t\tcout << \"NO\" << endl;\n\t}\n\telse{\n\t\tcout << \"YES\" << endl; int r[105][105]={};\n\t\trep2(i,n){\n\t\t\trep(j,G[i].size()){\n\t\t\t\tif(200<=G[i][j].to && G[i][j].to<=400){\n\t\t\t\t\tr[i][G[i][j].to-200] = 200-G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep2(i,n){\n\t\t\trep2(j,n){\n\t\t\t\tcout << r[i][j] << (j==n?'\\n':' ');\n\t\t\t}\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graphs",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Soldier and Traveling.json",
    "editorial_link": "https://codeforces.com//blog/entry/18034",
    "editorial": "There are few ways to solve this task, but I'll describe the simplest (in my opinion) one.\n\nLet's build a flow network in following way:\n\nMake a source.\n\nMake a first group of vertices consisting of n vertices, each of them for one city.\n\nConnect a source with ith vertex in first group with edge that has capacity ai.\n\nMake a sink and second group of vertices in the same way, but use bi except for ai.\n\nIf there is a road between cities i and j or i?=?j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.\n\nThen find a maxflow, in any complexity.\n\nIf maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.\n\nI told about many solutions, because every solution, which doesn't use greedy strategy, can undo it's previous pushes, and does it in reasonable complexity should pass.",
    "hint": []
}