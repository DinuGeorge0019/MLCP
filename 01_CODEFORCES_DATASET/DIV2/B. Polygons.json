{
    "link": "https://codeforces.com//contest/166/problem/B",
    "problemId": "1040",
    "problem_idx": "B",
    "shortId": "166B",
    "contest_number": "166",
    "problem_submissions": {
        "D": [
            1396659,
            1395820,
            1401592,
            1396051,
            1397210
        ],
        "B": [
            1395005,
            1394804,
            1392115,
            1394417,
            1395521,
            1396164,
            1392917,
            1395627,
            1396717,
            1394631,
            1395100,
            1394589,
            1396975,
            1397293
        ],
        "C": [
            1392257,
            1391396,
            1392030,
            1393877,
            1393945,
            1392242,
            1390459,
            1391422,
            1391954,
            1395935,
            1394755,
            1392498,
            1394730,
            1392841,
            1393241,
            1392725
        ],
        "E": [
            1390755,
            1392062,
            1391036,
            1395303,
            1394970,
            1391365,
            1391505,
            1392099,
            1390858,
            1394891,
            1391571,
            1391330,
            1391965,
            1393022,
            1397588,
            1391462,
            1390747
        ],
        "A": [
            1389902,
            1389901,
            1390096,
            1390092,
            1390420,
            1390228,
            1392273,
            1389894,
            1390237,
            1390485,
            1391136,
            1389957,
            1390738,
            1389907,
            1389972,
            1389815,
            1389969
        ]
    },
    "name": "B. Polygons",
    "statement": "You’ve got another geometrical task. You are given two non-degenerate\r\npolygons and as vertex coordinates. Polygon is strictly convex. Polygon\r\nis an arbitrary polygon without any self-intersections and self-touches.\r\nThe vertices of both polygons are given in the clockwise order. For each\r\npolygon no three consecutively following vertices are located on the\r\nsame straight line.Your task is to check whether polygon is positioned\r\nstrictly inside polygon . It means that any point of polygon should be\r\nstrictly inside polygon . \"Strictly\" means that the vertex of polygon\r\ncannot lie on the side of the polygon .\r\n",
    "solutions": [
        "#pragma comment(linker, \"/stack:64000000\")\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <utility>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <memory.h>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <deque>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <map>\n#include <deque>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define for1(i, n) for (int i = 1; i <= int(n); i++)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb push_back\n#define pii pair <int, int>\n#define vi vector <int>\n#define mp make_pair\n\ntemplate <typename X> inline X abs (const X &a) {return a < 0? -a: a;}\ntemplate <typename X> inline X sqr (const X &a) {return a * a;}\n\nconst int INF = INT_MAX / 2;\nconst ll INF64 = LLONG_MAX / 2LL;\nconst ld EPS = 1E-9, PI = 3.1415926535897932384626433832795;\n\nconst int N = 100 * 1000 + 13;\n\nstruct pt\n{\n    ld x, y;\n    pt() {}\n    pt (ld x, ld y): x(x), y(y) {}\n};\n\nbool operator < (const pt &a, const pt &b)\n{\n    if (abs (a.x - b.x) > EPS)\n        return a.x + EPS < b.x;\n\n    return a.y + EPS < b.y;\n}\n\nbool operator == (const pt &a, const pt &b)\n{\n    return !(a < b) && !(b < a);\n}\n\ninline ld getAngle (const pt &c, const pt &a)\n{\n    ld res = atan2 (a.y - c.y, a.x - c.x);\n    if (res + EPS < 0.0)\n        res += 2.0 * PI;\n\n    return res;\n}\n\ninline bool on (const pt &a, const pt &b, const pt &c)\n{\n    ld A = b.y - a.y;\n    ld B = a.x - b.x;\n    \n    ld d = sqrt (sqr (A) + sqr (B));\n\n    A /= d;\n    B /= d;\n\n    ld C = -(A * a.x + B * a.y);\n\n    ld res = A * c.x + B * c.y + C;\n\n    return res <= EPS;  \n}\n\ninline ld dist (const pt &a, const pt &b)\n{\n    return sqr (a.x - b.x) + sqr (a.y - b.y);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n#endif\n\n    int n, m;\n    pt a[N];\n    pt b[N];\n    \n    cin >> n;\n    pt center = pt (0, 0);\n\n    forn (i, n)\n    {\n        int x, y;\n        scanf (\"%d%d\", &x, &y);\n\n        a[i].x = x;\n        a[i].y = y;\n    \n        center.x += a[i].x;\n        center.y += a[i].y;\n    }\n\n    center.x /= ld (n);\n    center.y /= ld (n);\n\n    cin >> m;\n    forn (i, n)\n    {\n        int x, y;\n        scanf (\"%d%d\", &x, &y);\n\n        b[i].x = x;\n        b[i].y = y;\n    }\n\n    vector <pair <ld, int> > v;\n\n    forn (i, n)\n        v.pb (mp (getAngle (center, a[i]), i));\n\n    sort (all (v));\n\n    bool in = true;\n\n    forn (i, m)\n    {\n        if (b[i] == center)\n            continue;\n\n        ld cur = getAngle (center, b[i]);\n\n        pair <ld, int> val = v[int (lower_bound (all (v), mp (cur, -1)) - v.begin()) % n];\n\n        ld ang = val.first;\n\n        if (abs (ang - cur) < EPS)\n        {\n            if (dist (center, b[i]) + EPS >= dist (center, a[val.second]))\n            {\n                in = false;\n                break;\n            }\n        }\n        else\n        {\n            int idx = val.second;\n            int next = (idx + 1) % n;\n\n            if (on (a[idx], a[next], b[i]))\n            {\n                in = false;\n                break;\n            }\n        }\n    }\n\n    if (in)\n        puts (\"YES\");\n    else\n        puts (\"NO\");\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Polygons.json",
    "editorial_link": "https://codeforces.com//blog/entry/4173",
    "editorial": "Polygon A is convex, so it is sufficient to check only that every vertex\r\nof polygon B is strictly inside polygon A. In theory the simplest\r\nsolution is building common convex hull of both polygons. You need to\r\ncheck that no vertex of polygon B belongs to this hull. But there is a\r\ntricky detail: if there are many points lying on the same side of convex\r\nhull than your convex hull must contain all these points as vertices. So\r\nthis solution is harder to implement and has some corner case. Another\r\nsolution: cut polygon A into triangles (by vertex numbers): . The\r\nsequences of angles is increasing. It means that you can find for each\r\nvertex of B to which triangle of A it can belong using binsearch by\r\nangle. Similarly you can cut polygon A into trapezoids (with vertical\r\ncuts). In this case youâll need a binsearch by -coordinate.\r\n",
    "hint": []
}