{"link": "https://codeforces.com//contest/194/problem/C", "problemId": "1411", "problem_idx": "C", "shortId": "194C", "contest_number": "194", "problem_submissions": {"B": [1764935, 1755068, 1937285, 1754608, 1754131, 1755380, 1755240, 1754857, 1755369, 1755173, 1755703, 1755481, 1755578, 1755103, 1755650, 1756121, 1755226, 1755274, 1755017], "A": [1764930, 1754050, 1937280, 1937278, 1753889, 1753888, 1754404, 1754253, 1753991, 1754353, 1753971, 1753959, 1753901, 1754292, 1754000, 1754355, 1754106, 1754010, 1754049, 1753941], "E": [1760518, 1763067, 1760520], "D": [1758849, 1757587, 1845330, 1759194, 1759982, 1763977, 1760187, 1760559, 1765401, 1768899, 1759233], "C": [1756942, 1756172, 1756826, 1757346, 1758198, 1758195, 1758670, 3530327, 1758792, 1757336, 1757355, 1757313, 1758027, 1757904, 1757515, 1756672]}, "name": "C. Cutting Figure", "statement": "You\u2019ve gotten an sheet of squared paper. Some of its squares are\r\npainted. Let\u2019s mark the set of all painted squares as . Set is\r\nconnected. Your task is to find the minimum number of squares that we\r\ncan delete from set to make it not connected.A set of painted squares is\r\ncalled , if for every two squares and from this set there is a sequence\r\nof squares from the set, beginning in and ending in , such that in this\r\nsequence any square, except for the last one, shares a common side with\r\nthe square that follows next in the sequence. An empty set and a set\r\nconsisting of exactly one square are connected by definition.\r\n", "solutions": ["#include<cassert>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint dr[] = {-1, 1, 0, 0};\nint dc[] = {0, 0, 1, -1};\n\nint main() {\n  int R, C;\n  cin >> R >> C;\n  vector<string> paper(R);\n  for(int r = 0; r < R; ++r)\n    cin >> paper[r];\n  int mini = 5;\n  int size_paper = 0;\n  \n  for(int r = 0; r < R; ++r)\n    for(int c = 0; c < C; ++c)\n      {\n        if(paper[r][c] == '.')\n          continue;\n        ++size_paper;\n        \n        int num_neighbours = 0;\n        for(int i = 0; i < 4; ++i)\n          {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if(nr >= R || nr < 0 || nc >= C || nc < 0)\n              continue;\n            num_neighbours += paper[nr][nc] == '#';\n          }\n        mini = min(mini, num_neighbours);\n      }\n  if(size_paper <= 2)\n    {\n      cout << -1 << endl;\n      return 0;\n    }\n\n  if(mini == 1)\n    {\n      cout << 1 << endl;\n      return 0;\n    }\n\n  for(int del_r = 0; del_r < R; ++del_r)\n    for(int del_c = 0; del_c < C; ++del_c)\n      {\n        if(paper[del_r][del_c] == '.')\n          continue;\n        \n        paper[del_r][del_c] = '.';\n\n        queue<pii> q;\n        vector<vector<bool>> visited(R, vector<bool>(C));\n        \n        int i = 0, nr, nc;\n\n        for(; i < 4; ++i)\n          {\n            nr = del_r + dr[i];\n            nc = del_c + dc[i];\n            if(nr >= R || nr < 0 || nc >= C || nc < 0)\n              continue;\n            if(paper[nr][nc] == '.')\n              continue;\n            break;\n          }\n        assert(i < 4);\n\n        int v = 1;\n        q.push(pii(nr, nc));\n        visited[nr][nc] = true;\n        while(!q.empty()) {\n          pii cur = q.front();\n          q.pop();\n          ++v;\n          int r = cur.first;\n          int c = cur.second; \n\n          for(int i = 0; i < 4; ++i)\n            {\n              nr = r + dr[i];\n              nc = c + dc[i];\n            \n              if(nr >= R || nr < 0 || nc >= C || nc < 0)\n                continue;\n              if(paper[nr][nc] == '.')\n                continue;\n              if(visited[nr][nc])\n                continue;\n\n              visited[nr][nc] = true;\n              q.push(pii(nr, nc));\n            }\n        }\n\n        if(v < size_paper - 1)\n          {\n            cout << 1 << endl;\n            return 0;\n          }\n\n        paper[del_r][del_c] = '#';\n      }\n\n  cout << 2 << endl;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "implementation", "matrices", "strings"], "dificulty": "1700", "interactive": false}