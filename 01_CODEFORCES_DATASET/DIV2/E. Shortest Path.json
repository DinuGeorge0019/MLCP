{"link": "https://codeforces.com//contest/59/problem/E", "problemId": "311", "problem_idx": "E", "shortId": "59E", "contest_number": "59", "problem_submissions": {"E": [280965, 279581, 281138, 281387, 280873, 283124, 283115, 283111, 283109, 283100, 283096, 283092, 283085, 283084, 281969, 7020454], "D": [280391, 284138, 281502, 281236, 281590, 282219, 282005, 282011, 281002], "C": [279741, 280383, 280157, 280215, 279940, 280089, 280651, 282540, 280526, 280047, 280179, 280617, 280421], "B": [279223, 280161, 279355, 279326, 279379, 279486, 283681, 280066, 279671, 279598, 279324, 279470, 279615, 279517, 280028], "A": [278986, 280065, 279027, 279062, 279003, 279074, 283673, 279299, 279346, 279565, 279059, 279097, 279211, 279043, 279837]}, "name": "E. Shortest Path", "statement": "In Ancient Berland there were cities and two-way roads of equal length.\r\nThe cities are numbered with integers from to inclusively. According to\r\nan ancient superstition, if a traveller visits three cities , , in row,\r\nwithout visiting other cities between them, a great disaster awaits him.\r\nOverall there are such city triplets. Each triplet is ordered, which\r\nmeans that, for example, you are allowed to visit the cities in the\r\nfollowing order: , , . Vasya wants to get from the city to the city and\r\nnot fulfil the superstition. Find out which minimal number of roads he\r\nshould take. Also you are required to find one of his possible path\r\nroutes.\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <tr1/unordered_set>\n#include <queue>\nusing namespace std;\nint N,M,K;\ntypedef pair<int,int> P;\nconst int MN = 50*1000 + 50;\ntr1::unordered_set<int> fails[MN];\nmap<P,int> ens;\nint to[MN];\nint ES=0;\nvector<int> e[MN];\nbool used[MN];\nint from[MN];\n\nstruct E {\n\tint c;\n\tint e;\n\tint f;\n\tbool operator<(const E& e) const {\n\t\treturn c>e.c;\n\t}\n};\n\nint main()\n{\n\tcin>>N>>M>>K;\n\tfor(int i=0; i<M; ++i) {\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tto[ES] = b;\n\t\tens[P(a,b)] = ES;\n\t\te[a].push_back(ES++);\n\t\tto[ES] = a;\n\t\tens[P(b,a)] = ES;\n\t\te[b].push_back(ES++);\n\t}\n\tfor(int i=0; i<K; ++i) {\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tP p(a,b);\n\t\tif (!ens.count(p)) continue;\n\t\tint e = ens[p];\n\t\tfails[e].insert(c);\n//\t\tcout<<\"setting fail @ \"<<e<<' '<<c<<'\\n';\n\t}\n\n\tpriority_queue<E> q;\n\tfor(size_t i=0; i<e[1].size(); ++i) {\n\t\tE z = {1, e[1][i], -1};\n\t\tq.push(z);\n\t}\n\twhile(!q.empty()) {\n\t\tE p = q.top();\n\t\tq.pop();\n\n\t\tint ee = p.e;\n\t\tif (used[ee]) continue;\n\t\tfrom[ee] = p.f;\n\t\tint n = to[ee];\n//\t\tcout<<\"setting from \"<<ee<<' '<<n<<\" : \"<<p.f<<\" ; \"<<p.c<<'\\n';\n\t\tused[ee] = 1;\n\t\tif (n==N) {\n\t\t\tint c = ee;\n\t\t\tvector<int> res;\n\t\t\twhile(c >= 0) {\n\t\t\t\tres.push_back(to[c]);\n\t\t\t\tc = from[c];\n\t\t\t}\n\t\t\tres.push_back(1);\n\t\t\treverse(res.begin(),res.end());\n\t\t\tcout<<p.c<<'\\n';\n\t\t\tfor(size_t i=0; i<res.size(); ++i) {\n\t\t\t\tif (i>0) cout<<' ';\n\t\t\t\tcout<<res[i];\n\t\t\t}\n\t\t\tcout<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(size_t i=0; i<e[n].size(); ++i) {\n\t\t\tint f = e[n][i];\n\t\t\tif (used[f]) continue;\n\t\t\tint t = to[f];\n\t\t\tif (fails[ee].count(t)) continue;\n\t\t\tE z = {p.c+1, f, ee};\n//\t\t\tcout<<\"going @ \"<<ee<<' '<<n<<' '<<t<<'\\n';\n\t\t\tq.push(z);\n\t\t}\n\t}\n\tcout<<-1<<'\\n';\n}\n"], "input": "", "output": "", "tags": ["graphs", "shortest paths"], "dificulty": "2000", "interactive": false}