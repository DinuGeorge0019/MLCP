{
    "link": "https://codeforces.com//contest/149/problem/E",
    "problemId": "897",
    "problem_idx": "E",
    "shortId": "149E",
    "contest_number": "149",
    "problem_submissions": {
        "E": [
            1166748,
            1167898,
            1167706,
            1167062,
            1168119,
            1166122,
            1166620,
            1180098,
            1166477,
            1174675,
            1168703
        ],
        "D": [
            1164419,
            1165531,
            1165306,
            1167884,
            1166269,
            1165035,
            1166389,
            1166109,
            1170884,
            1168057,
            1168286,
            1168301,
            1166381,
            1167820,
            1166746,
            1167254
        ],
        "C": [
            1163610,
            1164091,
            1166729,
            1163074,
            1164324,
            1166838,
            1164648,
            1163955,
            1163257,
            1164156,
            1165163,
            1165364,
            1163684,
            1164576,
            1163848,
            1164438,
            1163813
        ],
        "A": [
            1161525,
            1161700,
            1161485,
            1162080,
            1161445,
            1161719,
            1162271,
            1161578,
            1161605,
            1161624,
            1162068,
            1161422,
            1170499,
            1161442,
            1161589,
            1162328
        ],
        "B": [
            1163315,
            1165673,
            1163493,
            1165775,
            1163479,
            1163666,
            1163250,
            1164374,
            1163398,
            1163280,
            1164630,
            1168461,
            1163446,
            1163638
        ]
    },
    "name": "E. Martian Strings",
    "statement": "During the study of the Martians Petya clearly understood that the\r\nMartians are absolutely lazy. They like to sleep and don’t like to wake\r\nup. Imagine a Martian who has exactly eyes located in a row and numbered\r\nfrom the left to the right from to . When a Martian sleeps, he puts a\r\npatch on each eye (so that the Martian morning doesn’t wake him up). The\r\ninner side of each patch has an uppercase Latin letter. So, when a\r\nMartian wakes up and opens all his eyes he sees a string consisting of\r\nuppercase Latin letters. The string’s length is . \"Ding dong!\" the alarm\r\ngoes off. A Martian has already woken up but he hasn’t opened any of his\r\neyes. He feels that today is going to be a hard day, so he wants to open\r\nhis eyes and see something good. The Martian considers only Martian\r\nwords beautiful. Besides, it is hard for him to open all eyes at once so\r\nearly in the morning. So he opens two non-overlapping segments of\r\nconsecutive eyes. After the Martian opens the eyes he needs, he reads\r\nall the visible characters from the left to the right and thus, he sees\r\nsome word.Let’s consider all different words the Martian can see in the\r\nmorning. Your task is to find out how many beautiful words are among\r\nthem.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MM 1024\n#define MAX 131072\n\n#define BASE1 29\n#define BASE2 31\n#define BASE3 37\n\n#define MOD1 10000019\n#define MOD2 10000079\n#define MOD3 10000103\n\nusing namespace std;\nFILE *in; FILE *out;\n\nint n, m;\nchar a[MAX], r[MAX];\nint fwd[MM], bck[MM];\nchar w[128][MM]; int len[128];\nint pwr1[MM], pwr2[MM], pwr3[MM];\n\nvoid eval(char* word, int wlen, char* arr, int* res)\n{\n\tint size = 1;\n\tint hash1 = arr[0] - 'A' + 1;\n\tint hash2 = arr[0] - 'A' + 1;\n\tint hash3 = arr[0] - 'A' + 1;\n\tint shash1 = word[0] - 'A' + 1;\n\tint shash2 = word[0] - 'A' + 1;\n\tint shash3 = word[0] - 'A' + 1;\n\t\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (hash1 == shash1 && hash2 == shash2 && hash3 == shash3)\n\t\t{\n\t\t\tres[size] = i - size;\n\t\t\tif (size == wlen) break;\n\t\t\tif (i >= n) break;\n\t\t\thash1 = (hash1 * BASE1 + arr[i] - 'A' + 1) % MOD1;\n\t\t\thash2 = (hash2 * BASE2 + arr[i] - 'A' + 1) % MOD2;\n\t\t\thash3 = (hash3 * BASE3 + arr[i] - 'A' + 1) % MOD3;\n\t\t\tshash1 = (shash1 * BASE1 + word[size] - 'A' + 1) % MOD1;\n\t\t\tshash2 = (shash2 * BASE2 + word[size] - 'A' + 1) % MOD2;\n\t\t\tshash3 = (shash3 * BASE3 + word[size] - 'A' + 1) % MOD3;\n\t\t\tsize++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (i >= n) break;\n\t\t\thash1 = (hash1 - (pwr1[size - 1] * (arr[i - size] - 'A' + 1)) % MOD1 + MOD1) % MOD1;\n\t\t\thash1 = (hash1 * BASE1 + arr[i] - 'A' + 1) % MOD1;\n\t\t\thash2 = (hash2 - (pwr2[size - 1] * (arr[i - size] - 'A' + 1)) % MOD2 + MOD2) % MOD2;\n\t\t\thash2 = (hash2 * BASE2 + arr[i] - 'A' + 1) % MOD2;\n\t\t\thash3 = (hash3 - (pwr3[size - 1] * (arr[i - size] - 'A' + 1)) % MOD3 + MOD3) % MOD3;\n\t\t\thash3 = (hash3 * BASE3 + arr[i] - 'A' + 1) % MOD3;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(\"E.in\", \"rt\"); out = fopen(\"E.out\", \"wt\");\n\t\n\tpwr1[0] = 1; pwr2[0] = 1; pwr3[0] = 1;\n\tfor (int i = 1; i < MM; i++)\n\t{\n\t\tpwr1[i] = (pwr1[i - 1] * BASE1) % MOD1;\n\t\tpwr2[i] = (pwr2[i - 1] * BASE2) % MOD2;\n\t\tpwr3[i] = (pwr3[i - 1] * BASE3) % MOD3;\n\t}\n\t\n\tfscanf(in, \"%s\", a);\n\tn = (int)strlen(a);\n\tstrcpy(r, a);\n\treverse(r, r + n);\n\t\n\tfscanf(in, \"%d\", &m);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfscanf(in, \"%s\", w[i]);\n\t\tlen[i] = (int)strlen(w[i]);\n\t}\n\t\n//\tfprintf(out, \"%d\\n\", n);\n//\tfprintf(out, \"%s\\n\", a);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tmemset(fwd, -1, sizeof(fwd));\n\t\tmemset(bck, -1, sizeof(bck));\n\t\teval(w[i], len[i], a, fwd);\n\t\treverse(w[i], w[i] + len[i]);\n\t\teval(w[i], len[i], r, bck);\n\t\treverse(w[i], w[i] + len[i]);\n\n\t\tint flag = 0;\n\t\tfor (int c = 1; c < len[i]; c++)\n\t\t{\n\t\t\tif (fwd[c] == -1) break;\n\t\t\tif (bck[len[i] - c] == -1) continue;\n\t\t\tint l1 = fwd[c];\n\t\t\tint r1 = fwd[c] + c - 1;\n\t\t\tint r2 = n - bck[len[i] - c] - 1;\n\t\t\tint l2 = r2 - len[i] + c + 1;\n//\t\t\tfprintf(out, \"(%d, %d) -> (%d, %d)\\n\", l1, r1, l2, r2);\n//\t\t\tif (r1 < l2)\n//\t\t\t\tfprintf(out, \"Found word \\\"%s\\\" with segments (%d, %d) and (%d, %d)\\n\", w[i], l1, r1, l2, r2);\n\t\t\tif (r1 < l2) {flag = 1; break;}\n\t\t}\n\t\tans += flag;\n\t}\n\tfprintf(out, \"%d\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Martian Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/3864",
    "editorial": "We will solve the problem separately for each strings. Thus, suppose we\r\nhave a string , its length is , and we need to check whether the Martian\r\nbe seen. We introduce additional arrays: let is minimal position in the\r\nof the begin of occurrence with length exactly , and let is the maximum\r\nposition in the of the end of occurrence with length exactly It is easy\r\nto understand that a Martian could see the , if there exists an , that .\r\nHow to calculate the arrays? For array is sufficient to find Z-function\r\nps, but for an array of Z-function r(p)r(s), where means the reversed\r\nstring . Using an array of Z-functions calcing of arrays and is trivial.\r\n",
    "hint": []
}