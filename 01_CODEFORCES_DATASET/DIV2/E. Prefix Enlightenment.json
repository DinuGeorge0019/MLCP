{
    "link": "https://codeforces.com//contest/1291/problem/E",
    "problemId": "529286",
    "problem_idx": "E",
    "shortId": "1291E",
    "contest_number": "1291",
    "problem_submissions": {
        "C": [
            70078816,
            70050816,
            70042724,
            70053069,
            70052206,
            70072135,
            70047080,
            70047671,
            70049982,
            70049792,
            70044975,
            70045731,
            70049590,
            70046807,
            70050141,
            70048797,
            70051840,
            70043410,
            70051189
        ],
        "A": [
            70076588,
            70035649,
            70051615,
            70038788,
            71191554,
            70042526,
            70040855,
            70040409,
            70037322,
            70324047,
            70036128,
            70035755,
            70036486,
            70036001,
            70040165,
            70037128,
            70036301,
            70037522,
            70037345,
            70036992,
            70038646
        ],
        "B": [
            70075656,
            70037850,
            70048322,
            70046041,
            71191579,
            70045451,
            70044084,
            70040507,
            70041207,
            70039061,
            70042662,
            70039800,
            70040502,
            70042950,
            70040497,
            70040646,
            70041566,
            70042682,
            70047909,
            70043816
        ],
        "D": [
            70074507,
            70056625,
            70066825,
            70066273,
            70065758,
            70080888,
            70054873,
            70061627,
            70061405,
            70061792,
            70060518,
            70061003,
            70060842,
            70058946,
            70066151,
            70062202,
            70062779,
            70063466,
            70066431
        ],
        "E": [
            70059567,
            70078936,
            70081396,
            70066368,
            70109259,
            144418642,
            70793684
        ],
        "F": [
            70045991,
            70079097,
            70083257,
            150010321,
            70714928
        ]
    },
    "name": "E. Prefix Enlightenment",
    "statement": "There are n lamps on a line, numbered from 1 to n. Each one has an\r\ninitial state off (0) or on (1).You’re given k subsets A_1,\r\nldots, A_k of\r\n{1, 2,\r\ndots, n\r\n}, such that the intersection of any three subsets is empty. In other\r\nwords, for all 1\r\nle i_1 < i_2 < i_3\r\nle k, A_{i_1}\r\ncap A_{i_2}\r\ncap A_{i_3} =\r\nvarnothing.In one operation, you can choose one of these k subsets and\r\nswitch the state of all lamps in it. It is guaranteed that, with the\r\ngiven subsets, it’s possible to make all lamps be simultaneously on\r\nusing this type of operation.Let m_i be the minimum number of operations\r\nyou have to do in order to make the i first lamps be simultaneously on.\r\nNote that there is no condition upon the state of other lamps (between\r\ni+1 and n), they can be either off or on.You have to compute m_i for all\r\n1\r\nle i\r\nle n.\r\n",
    "solutions": [
        "/*\nIZ*ONE\n\nLa vie en Rose\n2018.10.29\n\nVioleta\n2019.04.01\n\nFiesta\n2020.02.17\n*/\n\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nint n, K, p[301000], tot, UF[301000], UP[301000], C[301000][2], T[301000];\n\nchar s[301000];\nvector<int> g[301000], u[301000];\n\nint Find(int a) {\n\tint x = a, s = 0;\n\twhile (x != UF[x]) {\n\t\ts ^= UP[x];\n\t\tx = UF[x];\n\t}\n\tint t = 0, root = x;\n\tx = a;\n\twhile (x != UF[x]) {\n\t\tint y = UF[x];\n\t\tint z = UP[x];\n\t\tUP[x] = t ^ s;\n\t\tUF[x] = root;\n\t\tt ^= z;\n\t\tx = y;\n\t}\n\treturn root;\n}\n\nint Get(int a) {\n\tif (!T[a]) return min(C[a][0], C[a][1]);\n\treturn C[a][!(T[a] - 2)];\n}\n\nvoid Minus(int a) {\n\ttot -= Get(a);\n}\nvoid Plus(int a) {\n\ttot += Get(a);\n\n}\nvoid f1(int a, int c) {\n\tint x = Find(a);\n\tint d = UP[a];\n\tint ck = d ^ c;\n\tMinus(x);\n\tT[x] = ck + 2;\n\tPlus(x);\n}\n\n\nvoid f2(int a, int b, int c) {\n\tint r1 = Find(a), r2 = Find(b);\n\tint d1 = UP[a], d2 = UP[b];\n\tint d = d1 ^ d2 ^ c;\n\tif (r1 == r2)return;\n\tMinus(r1);\n\tMinus(r2);\n\tC[r1][0] += C[r2][d];\n\tC[r1][1] += C[r2][d ^ 1];\n\tif (!T[r1] && T[r2]) {\n\t\tT[r1] = ((T[r2] - 2) ^ d) + 2;\n\t}\n\tUF[r2] = r1;\n\tUP[r2] = d;\n\tPlus(r1);\n}\n\nvoid Process() {\n\tint i, j;\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", s + 1);\n\tfor (i = 1; i <= K; i++) {\n\t\tint sz;\n\t\tscanf(\"%d\", &sz);\n\t\tg[i].resize(sz);\n\t\tfor (j = 0; j < sz; j++) {\n\t\t\tscanf(\"%d\", &g[i][j]);\n\t\t\tu[g[i][j]].push_back(i);\n\t\t}\n\t}\n\tfor (i = 1; i <= K; i++)UF[i] = i, C[i][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tint c = '1' - s[i];\n\t\tif (u[i].empty()) {\n\t\t}\n\t\telse if(u[i].size() == 1){\n\t\t\tf1(u[i][0], c);\n\t\t}\n\t\telse {\n\t\t\tint a = u[i][0], b = u[i][1];\n\t\t\tf2(a, b, c);\n\t\t}\n\t\tprintf(\"%d\\n\", tot);\n\t}\n}\n\nint main() {\n\tint Tcase = 1;\n\twhile (Tcase--) {\n\t\tProcess();\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Prefix Enlightenment.json",
    "editorial_link": "https://codeforces.com//blog/entry/73563",
    "editorial": "The condition \"the intersection of any three subsets is empty\" can be easily rephrased in a more useful way: each element appears in at most two subsets.\n\nLet's suppose for the moment that each elements appears in exactly two subsets. We can think of each element as an edge between the subsets, it's a classical point of view. If we see subsets as nodes, we can model the subsets choice by coloring nodes into two colors, \"taken\" or \"non-taken\".\n\nIf an element is initially off, we need to take exactly one of the subsets containing it. The corresponding edge should have endpoints with different color. If an element is initially on, we must take none or both subsets : endpoints with same color.\n\nWe recognize a sort of bipartition, obviously there are at most two correct colorings for each connected component: fixing the color of a node fix the color of all connected nodes.\n\nHence, the final answer is the sum for each component, of the size of the smaller side of the partition.\n\nSince the answer exists for i=n\n, there exists a such partition of the graph (into \"red\" and \"blue\" nodes). We can find it with usual dfs, and keep it for lower values of i\n.\n\nIn order to compute all mi\n efficiently, we start from a graph with no edges (i=0\n), and we add edges with DSU, maintaining in each connected component the count of nodes in red side, and the count of nodes in blue side.\n\nNow, how to deal with elements that appears in exactly one subset? They don't add any edge in the graph, but they force to take one of the sides of the connected component. To simulate this, we can use a special forced flag, or just fix the count of the other side to +?\n (but be careful about overflow if you do that).",
    "hint": []
}