{
    "link": "https://codeforces.com//contest/1592/problem/F1",
    "problemId": "1129224",
    "problem_idx": "F1",
    "shortId": "1592F1",
    "contest_number": "1592",
    "problem_submissions": {
        "F2": [
            130713058,
            130745405,
            130752812,
            130700115,
            130719186,
            130720967,
            130722508,
            130857743,
            130747284
        ],
        "F1": [
            130708913,
            130716472,
            130712966,
            130690640,
            130721286,
            130704100,
            130714549,
            130712433,
            130713697,
            130851358,
            130725206,
            130716184
        ],
        "E": [
            130702698,
            130695073,
            130712585,
            130690161,
            130713929,
            130713176,
            130705621,
            130689937,
            130710720,
            130851028,
            130710139,
            130712353,
            130705313,
            130701661,
            130698871,
            130698929,
            130696498
        ],
        "D": [
            130686766,
            130712124,
            130687989,
            130703162,
            130719297,
            130699331,
            130692683,
            130699442,
            130699159,
            130850999,
            130702540,
            130701084,
            130699463,
            130712566,
            130716938,
            130713876,
            130700116
        ],
        "C": [
            130673756,
            130678234,
            130691078,
            130722241,
            130692718,
            130685086,
            130684627,
            130684454,
            130695547,
            130686901,
            130682234,
            130850976,
            130687343,
            130686079,
            130680261,
            130693322,
            130682408,
            130683213,
            130708723,
            130704235
        ],
        "B": [
            130668341,
            130668419,
            130669045,
            130704250,
            130680256,
            130671878,
            130678194,
            130668270,
            130665664,
            130670263,
            130668846,
            130676770,
            130673397,
            130708534,
            130677615,
            130673769,
            130685667,
            130666906
        ],
        "A": [
            130663321,
            130663779,
            130671236,
            130667562,
            130676197,
            130664558,
            130674304,
            130663697,
            130663364,
            130664358,
            130664439,
            130664164,
            130666634,
            130663540,
            130663720,
            130665536,
            130664639,
            130664321,
            130671799
        ]
    },
    "name": "F1. Alice and Recoloring 1",
    "statement": "Alice has a grid of size n\r\ntimes m, . The cell on the intersection of i-th row and j-th column is\r\ndenoted as (i, j). Alice can do the following operations with this\r\ngrid:Choose any subrectangle containing cell (1, 1), and flip the colors\r\nof all its cells. (Flipping means changing its color from white to black\r\nor from black to white). Choose any subrectangle containing cell (n, 1),\r\nand flip the colors of all its cells. Choose any subrectangle containing\r\ncell (1, m), and flip the colors of all its cells. Choose any\r\nsubrectangle containing cell (n, m), and flip the colors of all its\r\ncells. .Alice wants to obtain her favorite coloring with these\r\noperations. What’s the smallest number of coins that she would have to\r\nspend? It can be shown that it’s always possible to transform the\r\ninitial grid into any other.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,m;\nint sum,ans;\nint a[505][505],b[505][505];\nvoid solve()\n{\n\tcin>>n>>m;rep(i,n)rep(j,m){char c;cin>>c;a[i][j]=(c=='B');}\n\trep(i,n+1)rep(j,m+1)b[i][j]=a[i-1][j-1]^a[i-1][j]^a[i][j-1]^a[i][j];\n\tfor(int i=2;i<=n+1;i++)for(int j=2;j<=m+1;j++) sum+=b[i][j];\n\tans=sum;\n\tif(b[n+1][m+1])\n\t{\n\t\tfor(int i=2;i<=n;i++)for(int j=2;j<=m;j++)\n\t\t{\n\t\t\tint tmp=sum-b[i][j]-b[i][m+1]-b[n+1][j]-b[n+1][m+1];\n\t\t\ttmp+=4-b[i][j]-b[i][m+1]-b[n+1][j]-b[n+1][m+1];\n\t\t\tans=min(ans,tmp+3); \n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nint main()\n{\n\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Alice and Recoloring 1.json",
    "editorial_link": "https://codeforces.com//blog/entry/95583",
    "editorial": "We will transform favorite coloring to the all-white coloring\r\ninstead.Letâs denote by and by .First observation is that it doesnât\r\nmake sense to do operations of type and at all. Indeed, each of them can\r\nbe replaced with operations of type :Instead of flipping subrectangle ,\r\nwe can flip subrectangles and , and similarly for . So, from now on we\r\nonly consider first and last operations.Letâs create a grid of rows and\r\ncolumns, where denotes the parity of the sum of numbers in those of\r\ncells of favorite coloring, which are present on the grid. Clearly, all\r\nnumbers in are if and only if current coloring is all , so we will want\r\nto just make the grid all .Letâs look at how first and last operations\r\naffect the grid . If we flip the subrectangle with the operation of the\r\nfirst type, in grid the only value that changes is . If we flip the\r\nsubrectangle , clearly (otherwise we could have instead used operations\r\nof the first type). Then, itâs easy to see that the only cells that will\r\nchange are .So, now we have the following problem: we have a binary grid\r\n. In one operation, we can change some to , with cost of coin, or to\r\nselect some , and flip the numbers in cells with cost of coins. Whatâs\r\nthe smallest cost to make all numbers ?Now, itâs easy to see that it\r\ndoesnât make sense to apply second operation more than once, as instead\r\nof doing it twice, we can apply the operation of the first type at most\r\ntimes (as cell will be flipped twice). Moreover, it only makes sense to\r\napply the second operation if there exist such for which all cells are .\r\nSo, the algorithm would be to calculate the grid , to calculate the\r\ntotal number of ones in it , and substract from if there exists such for\r\nwhich all cells are . Complexity .\r\n",
    "hint": []
}