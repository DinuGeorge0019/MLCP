{
    "link": "https://codeforces.com//contest/378/problem/D",
    "problemId": "4959",
    "problem_idx": "D",
    "shortId": "378D",
    "contest_number": "378",
    "problem_submissions": {
        "E": [
            5563219,
            5595791,
            8179323,
            5559860,
            20070615,
            5562227
        ],
        "D": [
            5556813,
            5557228,
            5557861,
            5557995,
            5559128,
            5559510,
            5560131,
            5559854,
            5564039,
            5558835,
            5562214,
            5559720,
            5555845,
            5561731,
            5562171,
            5561606,
            5562261,
            5561403,
            8216379
        ],
        "C": [
            5554238,
            5554337,
            5554949,
            5554592,
            5554549,
            5556387,
            5557557,
            5554236,
            5556931,
            5559205,
            5555878,
            5557269,
            5561573,
            5555439,
            5557184,
            5557477,
            5558631,
            5558088,
            5558866
        ],
        "B": [
            5553450,
            5553574,
            5553632,
            5553677,
            5555408,
            5554569,
            5553596,
            5556019,
            5554338,
            5553306,
            5553948,
            5560235,
            5560773,
            5557562,
            5554753,
            5556550,
            5557175,
            5558723,
            5557766
        ],
        "A": [
            5551839,
            5552020,
            5551945,
            5551789,
            5552122,
            5552095,
            5551986,
            5551831,
            5552492,
            5551800,
            5551769,
            5551863,
            5552473,
            5552326,
            5555120,
            5553391,
            5552249,
            5552366
        ]
    },
    "name": "D. Preparing for the Contest",
    "statement": "Soon there will be held the world’s largest programming contest, but the\r\ntesting system still has bugs. The contest organizer, a well-known\r\nuniversity, has no choice but to attract university students to fix all\r\nthe bugs. The university has students able to perform such work. The\r\nstudents realize that they are the only hope of the organizers, so they\r\ndon’t want to work for free: the -th student wants to get ’passes’ in\r\nhis subjects (regardless of the volume of his work).Bugs, like students,\r\nare not the same: every bug is characterized by complexity , and every\r\nstudent has the level of his abilities . Student can fix a bug only if\r\nthe level of his abilities is not less than the complexity of the bug: ,\r\nand he does it in one day. Otherwise, the bug will have to be fixed by\r\nanother student. Of course, no student can work on a few bugs in one\r\nday. All bugs are not dependent on each other, so they can be corrected\r\nin any order, and different students can work simultaneously.The\r\nuniversity wants to fix all the bugs as quickly as possible, but giving\r\nthe students the total of not more than passes. Determine which students\r\nto use for that and come up with the schedule of work saying which\r\nstudent should fix which bug.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint n, m, s;\n\npair<int, int> A[200000];\npair<pair<int, int>, int> B[200000];\nset<pair<pair<int, int>, int> > candidates;\npair<int, int> q[200000];\nint sp, st;\nint answer[200000];\n\nbool check(int days) {\n  int j = n - 1;\n  sp = st = 0;\n  int used = 0;\n  candidates.clear();\n  for (int i = m - 1; i >= 0; --i) {\n    while (j >= 0 && B[j].first.first >= A[i].first) {\n      candidates.insert(make_pair(make_pair(B[j].first.second, B[j].first.first), B[j].second));\n      --j;\n    }\n    if (st < sp) {\n      answer[A[i].second] = q[st].second + 1;\n      --q[st].first;\n      if (q[st].first == 0) ++st;\n    } else {\n      if (candidates.size() == 0) return false;\n      pair<pair<int, int>, int> best = *candidates.begin();\n      candidates.erase(candidates.begin());\n      used += best.first.first;\n      if (used > s) return false;\n      answer[A[i].second] = best.second + 1;\n      if (days > 1) q[sp++] = make_pair(days - 1, best.second); \n    }\n  }\n  return true;\n}\n\nint main() {\n  scanf(\"%d %d %d\", &n, &m, &s);\n  for (int i = 0; i < m; ++i) { scanf(\"%d\", &A[i].first); A[i].second = i; }\n  for (int i = 0; i < n; ++i) { scanf(\"%d\", &B[i].first.first); B[i].second = i; }\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &B[i].first.second);\n\n  sort(A, A + m);\n  sort(B, B + n);\n\n  int left = 1, right = m;\n  while (left < right) {\n    int middle = (left + right) / 2;\n    if (check(middle)) right = middle;\n    else left = middle + 1;\n  }\n\n  if (check(left)) {\n    printf(\"YES\\n%d\", answer[0]);\n    for (int i = 1; i < m; ++i) printf(\" %d\", answer[i]);\n    printf(\"\\n\");\n  } else {\n    printf(\"NO\\n\");\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Preparing for the Contest.json",
    "editorial_link": "https://codeforces.com//blog/entry/10157",
    "editorial": "It's obvious that the time needed to fix all bugs is the monotonic function: if we can do it for some time, we can do it for greater time. So we can use binary search in these problem. We should learn how to check if some time t is enough.\n\nAt first sort all bugs by their complexity and all students by their skills. Let's consider the hardest bug. Who can fix it? It can be fixed by student whose skills is not less that this bug's complexity. Push all such students into the priority queue (sorted by students' price) and pop the cheapest student. As we check time t, this student must fix t hardest bugs (he definitely can do it). Save that information and go to the next bug which has not been fixed yet. Again push all students which can fix it to the priority queue and pop the cheapest one. And so on. If at some moment priority queue is empty, time t is not enough. If we spent too much 'money'  it's not enough as well. Otherwise we get the correct schedule.",
    "hint": []
}