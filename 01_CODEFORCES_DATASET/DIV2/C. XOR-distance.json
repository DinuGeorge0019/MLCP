{
    "link": "https://codeforces.com//contest/1918/problem/C",
    "problemId": "2452573",
    "problem_idx": "C",
    "shortId": "1918C",
    "contest_number": "1918",
    "problem_submissions": {
        "G": [
            244132893,
            245985475,
            244948797,
            244948670
        ],
        "F": [
            244120772,
            244125092,
            244126848,
            244126771,
            244130168,
            244131697,
            244138260,
            244138344,
            244139263,
            244138435,
            244141669,
            244144124,
            244142227,
            244122678,
            244157073,
            244156595,
            244332251,
            244124771,
            244360495,
            244129898
        ],
        "D": [
            244109167,
            244099156,
            244092966,
            244101787,
            244100881,
            244108481,
            244101721,
            244106486,
            244109529,
            244104916,
            244106995,
            244113590,
            244113865,
            244099423,
            244110295,
            244096244,
            244108027,
            244103663,
            244360463,
            244108155
        ],
        "E": [
            244103507,
            244108050,
            244110113,
            244110472,
            244112287,
            244124161,
            244125655,
            244123391,
            244119446,
            244125406,
            244135128,
            244134725,
            244128795,
            244112679,
            244118320,
            244116217,
            244928601,
            244928561
        ],
        "C": [
            244091247,
            244087599,
            244079342,
            244087694,
            244092782,
            244089213,
            244094187,
            244089808,
            244094684,
            244096501,
            244097023,
            244099017,
            244107490,
            244085730,
            244089866,
            244086764,
            244094953,
            244095107,
            244360406,
            244091142
        ],
        "B": [
            244083801,
            244076050,
            244075794,
            244073267,
            244075602,
            244075619,
            244082026,
            244079074,
            244080512,
            244082819,
            244079063,
            244082004,
            244078089,
            244075054,
            244078156,
            244075906,
            244081851,
            244083244,
            244360342,
            244080338
        ],
        "A": [
            244083099,
            244071431,
            244072186,
            244071210,
            244070855,
            244071315,
            244075506,
            244071630,
            244072257,
            244074358,
            244071939,
            244071253,
            244071114,
            244071560,
            244071154,
            244071990,
            244074495,
            244089579,
            244360312,
            244073174
        ]
    },
    "name": "C. XOR-distance",
    "statement": "You are given integers a, b, r. Find the smallest value of |({a\r\noplus x}) - ({b\r\noplus x})| among all 0\r\nleq x\r\nleq r.\r\noplus is the operation of bitwise XOR, and |y| is absolute value of y.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace SOL {\n\nusing i64 = long long;\nvoid debug(const char *msg, ...) {\n#ifdef CLESIP\n    va_list arg;\n    static char pbString[512];\n    va_start(arg,msg);\n    vsprintf(pbString,msg,arg);\n    cerr << \"[DEBUG] \" << pbString << \"\\n\";\n    va_end(arg);\n#endif    \n}\ntemplate<typename T, typename L>\nbool chkmax(T &x, L y) { if (x < y) return x = y, true; return false; }\ntemplate<typename T, typename L>\nbool chkmin(T &x, L y) { if (y < x) return x = y, true; return false; }\n\nconst i64 inf = 1e18;\n\nvoid solve() {\n\ti64 a, b, r; cin >> a >> b >> r;\n\n\ti64 ans = 0;\n\tbool flag = false;\n\n\tif (a < b)\n\t\tswap(a, b);\n\n\tfor (int i = 59; i >= 0; i --) {\n\t\tint x = (a >> i & 1);\n\t\tint y = (b >> i & 1);\n\t\ti64 pw = (1LL << i);\n\n\t\tif (x != y) {\n\t\t\tif (pw <= r && flag && x == 1) {\n\t\t\t\tans -= pw;\n\t\t\t\tr -= pw;\n\t\t\t} else {\n\t\t\t\tflag = true;\n\t\t\t\tans += pw * (x - y);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\n}\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tint tt; cin >> tt;\n\twhile (tt --)\n\t\tSOL::solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. XOR-distance.json",
    "editorial_link": "https://codeforces.com//blog/entry/125300",
    "editorial": "TutorialLet\u00e2\u0080\u0099s consider the bitwise representation of numbers , , . Let\u00e2\u0080\u0099s\r\nlook at any bits at the same position in and , if they are the same,\r\nthen regardless of what is in on this position, the number will have a\r\nat this position. Therefore, it is advantageous to set at all such\r\npositions in (since we want , and the answer does not depend on the\r\nbit). If the bits in and at the same position are different, then at\r\nthis position there will be a either in or in depending on what is at\r\nthis position in .Let < , if not, then we will swap them. Then at the\r\nhighest position, where the bits differ, there is a in and a in . There\r\nare options, either to set a at this position in (and then there will be\r\na in ), or to set a in (and then there will be a in ).Suppose we set in\r\n, then will definitely be less than (because in the highest differing\r\nbit, has , and has ). Therefore, it is advantageous to set in on all\r\nnext positions, as this will make their difference smaller. Therefore,\r\nwe can go through the positions in descending order, and if the position\r\nis differing, then we will set a in at this position if possible (if\r\nafter this does not exceed ).The second case (when we set in at the\r\nposition of the first differing bit) is analyzed similarly, but in fact\r\nit is not needed, because the answer will not be smaller, and will\r\nbecome larger.Time complexity: per test case.\r\n"
}