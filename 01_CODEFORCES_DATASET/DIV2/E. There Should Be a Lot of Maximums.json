{
    "link": "https://codeforces.com//contest/1805/problem/E",
    "problemId": "1861355",
    "problem_idx": "E",
    "shortId": "1805E",
    "contest_number": "1805",
    "problem_submissions": {
        "F1": [
            200439106,
            200443524,
            200424069,
            200446588,
            200467490,
            200437348,
            200464508,
            200464351,
            200463340,
            209038123,
            200557576,
            200463298
        ],
        "C": [
            200413348,
            200408313,
            200430286,
            200414727,
            200402344,
            200408784,
            200395896,
            200428904,
            200404720,
            200402863,
            200404086,
            200425916,
            200413389,
            200409508,
            200408670,
            200409948,
            200401611,
            200399297,
            200403669
        ],
        "B": [
            200409525,
            200389992,
            200432442,
            200395023,
            200391231,
            200403848,
            200389421,
            200391233,
            200390818,
            200392560,
            200392816,
            200391784,
            200391655,
            200392657,
            200391007,
            200395691,
            200393122,
            200390776,
            200392459
        ],
        "A": [
            200408080,
            200387988,
            200433504,
            200390983,
            200388843,
            200402551,
            200387906,
            200388117,
            200387935,
            200388566,
            200388387,
            200388650,
            200388558,
            200388007,
            200388011,
            200389948,
            200389103,
            200388194,
            200388689
        ],
        "D": [
            200406761,
            200528793,
            200401484,
            200399149,
            200420505,
            200419712,
            200416986,
            200406203,
            200414310,
            200416697,
            200410720,
            200413945,
            200420475,
            200409512,
            200419982,
            200414162,
            200411839,
            200411433,
            200405601,
            200415016
        ],
        "E": [
            200397032,
            200427084,
            200411961,
            200433750,
            200593267,
            200592726,
            200467387,
            200400294,
            200428962,
            200409350,
            200426292,
            200428409,
            200434434,
            200414709,
            200432234,
            214976359,
            200427846,
            200430477,
            200431439,
            200435575,
            200437915,
            200434896
        ],
        "F2": [
            200479147,
            200478731,
            200478432,
            200478085,
            200477991,
            200477963,
            200476470,
            200447442,
            209038798
        ]
    },
    "name": "E. There Should Be a Lot of Maximums",
    "statement": "You are given a tree (a connected graph without cycles). Each vertex of\r\nthe tree contains an integer. Let’s define the\r\nmathrm{MAD} (maximum double) parameter of the tree as the maximum\r\ninteger that occurs in the vertices of the tree 2 times. If no number\r\noccurs in the tree more than once, then we assume\r\nmathrm{MAD}=0.Note that if you remove an edge from the tree, it splits\r\ninto two trees. Let’s compute the\r\nmathrm{MAD} parameters of the two trees and take the maximum of the two\r\nvalues. Let the result be the of the deleted edge.For each edge, find\r\nits value. Note that we don’t actually delete any edges from the tree,\r\nthe values are to be found independently.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"yes\");\n\telse\n\t\tputs(\"no\");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"Yes\");\n\telse\n\t\tputs(\"No\");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tif(c=='-')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar('-'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+'0');\n//\tputchar('\\n');\n}\ninline void fre()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n}\nbasic_string<int>g[100005];\nint b[100005],ans[100005];\nint n,u[100005],v[100005],fa[100005],a[100005],siz[100005],hson[100005],dfn[100005],rnk[100005],B[100005],buc[100005],cnt;\nset<int>st,st2;\nvoid dfs(int x,int f)\n{\n\tfa[x]=f;\n\tsiz[x]=1;\n\tdfn[x]=++cnt,rnk[cnt]=x;\n\tfor(int y:g[x])\n\t\tif(y!=f)\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tsiz[x]+=siz[y];\n\t\t\tif(siz[y]>siz[hson[x]])\n\t\t\t\thson[x]=y;\n\t\t}\n}\nvoid solve(int x)\n{\n\tfor(int y:g[x])\n\t\tif(y!=fa[x]&&y!=hson[x])\n\t\t{\n\t\t\tsolve(y);\n\t\t\tfor(int i=dfn[y];i<dfn[y]+siz[y];i++)\n\t\t\t{\n\t\t\t\tint Y=rnk[i];\n\t\t\t\tif(buc[a[Y]]==2)\n\t\t\t\t\tst2.erase(st2.find(a[Y]));\n\t\t\t\tbuc[a[Y]]--;\n\t\t\t\tif(B[a[Y]]-buc[a[Y]]==2)\n\t\t\t\t\tst.insert(a[Y]);\n\t\t\t}\n\t\t}\n\tif(hson[x])\n\t\tsolve(hson[x]);\n\tbuc[a[x]]++;\n\tif(buc[a[x]]==2)\n\t\tst2.insert(a[x]);\n\tif(B[a[x]]-buc[a[x]]==1)\n\t\tst.erase(st.find(a[x]));\n\tfor(int y:g[x])\n\t\tif(y!=fa[x]&&y!=hson[x])\n\t\t{\n\t\t\tfor(int i=dfn[y];i<dfn[y]+siz[y];i++)\n\t\t\t{\n\t\t\t\tint Y=rnk[i];\n\t\t\t\tbuc[a[Y]]++;\n\t\t\t\tif(buc[a[Y]]==2)\n\t\t\t\t\tst2.insert(a[Y]);\n\t\t\t\tif(B[a[Y]]-buc[a[Y]]==1)\n\t\t\t\t\tst.erase(st.find(a[Y]));\n\t\t\t}\n\t\t}\n\tif(st.size())\n\t\tans[x]=*st.rbegin();\n\tif(st2.size())\n\t\tans[x]=max(ans[x],*st2.rbegin());\n}\nvoid work()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tcin>>u[i]>>v[i];\n\t\tg[u[i]]+=v[i],g[v[i]]+=u[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i],b[i]=a[i];\n\tsort(b+1,b+n+1);\n\tint m=unique(b+1,b+n+1)-b;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tB[a[i]=lower_bound(b+1,b+m,a[i])-b]++;\n\t\tif(B[a[i]]==2)\n\t\t\tst.insert(a[i]);\n\t}\n\tdfs(1,0);\n\tsolve(1);\n\tfor(int i=1;i<n;i++)\n\t\tif(fa[u[i]]==v[i])\n\t\t\tcout<<b[ans[u[i]]]<<'\\n';\n\t\telse\n\t\t\tcout<<b[ans[v[i]]]<<'\\n';\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n//\tcases();\n\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dp",
        "trees",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. There Should Be a Lot of Maximums.json",
    "editorial_link": "https://codeforces.com//blog/entry/114644",
    "editorial": "First, find of the initial tree. If each number in the tree occurs no\r\nmore than once, then for each query the answer is . Then, if occurs at\r\nleast times in the tree, then for each query the answer will be ,\r\nbecause by pigeonhole principle there will be at least in one of the two\r\ntrees.At last, in the case where occurs exactly times in the tree: if\r\nthe deleted edge is not on the path between two occurrences of , then\r\nthe answer of the whole tree. And for edges between entries, you need to\r\nmaintain sets of values in each tree and traverse the edges, changing\r\nthe sets accordingly.\r\n",
    "hint": [
        "Hint 1 Let — of the whole tree. What is the answer if there are many vertices with value in the tree?",
        "Hint 2 Note that for many edges the answer is . And for which edges is it not so?",
        "Hint 3 Let the tree have only two vertices with value . Then for the edges not on the path between them we know the answer. What about the path between two vertices of ? Can we walk along it by calculating the answer for all vertices?"
    ]
}