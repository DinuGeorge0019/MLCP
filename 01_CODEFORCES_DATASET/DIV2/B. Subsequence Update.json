{
    "link": "https://codeforces.com//contest/2063/problem/B",
    "problemId": "3154903",
    "problem_idx": "B",
    "shortId": "2063B",
    "contest_number": "2063",
    "problem_submissions": {
        "F2": [
            302425610,
            302451940,
            302442929,
            302441504,
            302438014,
            302448830,
            302447651,
            302449239,
            302451441,
            302441520,
            302449441,
            302462040,
            302527079
        ],
        "C": [
            302417331,
            302388966,
            302380666,
            302386796,
            302391515,
            302388488,
            302384390,
            302383854,
            302392461,
            302390039,
            302389493,
            302385787,
            302379767,
            302392628,
            302382228,
            302388334,
            302383676,
            302394839,
            302388632,
            302391072
        ],
        "D": [
            302412152,
            302402949,
            302396428,
            302402633,
            302409161,
            302404535,
            302411549,
            302409325,
            302409501,
            302412675,
            302403620,
            302420625,
            302411254,
            302422339,
            302414704,
            302406132,
            302417532,
            302411171,
            302418058,
            302418384
        ],
        "E": [
            302404720,
            302395352,
            302418668,
            302414791,
            302422680,
            302426848,
            302421742,
            302427528,
            302428407,
            302458083,
            302451720,
            302434097,
            302422758,
            302403323,
            302431883,
            302433354,
            302432981,
            302436125,
            302427678,
            302431985
        ],
        "F1": [
            302388355,
            302424887,
            302442481,
            302433761,
            302438421,
            302445686,
            302447198,
            302443757,
            302450796,
            302427723,
            302449982,
            302451319,
            302436505,
            302455100,
            302448501,
            302454721,
            302454623,
            302448067,
            302454995,
            302448498
        ],
        "B": [
            302385897,
            302389386,
            302371425,
            302391237,
            302379321,
            302378690,
            302373741,
            302377026,
            302378459,
            302385735,
            302370221,
            302376737,
            302372000,
            302386149,
            302374530,
            302374437,
            302376025,
            302383492,
            302381557,
            302378496
        ],
        "A": [
            302374954,
            302366962,
            302363313,
            302365021,
            302366134,
            302366042,
            302365897,
            302366966,
            302363934,
            302362493,
            302362600,
            302366245,
            302365093,
            302367784,
            302363061,
            302365428,
            302365621,
            302368569,
            302369401,
            302377605
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138593",
    "editorial": "To solve this problem, it is important to observe and prove the\r\nfollowing claim: : It is not beneficial to choose indices and at the\r\nsame time. Notice that we only care about values that end up on indices\r\nin .If we choose such that and , and will be swapped with each other and\r\nnot change the values that end up on . This means we can exchange it for\r\na shorter sequence of indices , preserving the values ending up on . If\r\nwe repeat this exchange until it is no longer possible, it will satisfy\r\neither: Every index is in ; or every index is in . We can solve for both\r\ncases separately. For either case, we can constructively show that we\r\ncan get the minimum values in the subsegment into . The proof is as\r\nfollows:WLOG assume we are solving for , and the indices of the minimum\r\nvalues are . Then: If we select every index in the minimum values, there\r\nwill be of them. If we select every index outside which is one of the\r\nminimum values, there will be also of them. Thus, we end up with a\r\nsubsequence of length , that gets the minimum values into the subsegment\r\n. As a result, we only have to find the minimum values of the\r\nsubsegment. This can be done easily with sorting. Do this for both and ,\r\nand we get the answer.The problem has been solved with time complexity\r\nper test case, due to sorting.\r\n",
    "name": "B. Subsequence Update",
    "statement": "You are given an integer sequence a_1, a_2,\r\nldots, a_n, and a segment [l,r] (1\r\nle l\r\nle r\r\nle n).You must perform the following operation on the sequence . Choose\r\nany ^{\r\ntext{ }} of the sequence a, and reverse it. Note that the subsequence\r\ndoes not have to be contiguous. Formally, choose any number of indices\r\ni_1,i_2,\r\nldots,i_k such that 1\r\nle i_1 < i_2 <\r\nldots < i_k\r\nle n. Then, change the i_x-th element to the original value of the\r\ni_{k-x+1}-th element simultaneously for all 1\r\nle x\r\nle k.Find the of a_l+a_{l+1}+\r\nldots+a_{r-1}+a_r after performing the operation.^{\r\ntext{ }}A sequence b is a subsequence of a sequence a if b can be\r\nobtained from a by the deletion of several (possibly, zero or all)\r\nelement from arbitrary positions.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;const int N=110000;#define int long longint t;int n,l,r;int a[N],s[N];bool cmp(int a,int b){\treturn a>b;}bool cmp2(int a,int b){\treturn a<b;}signed main(){\tios::sync_with_stdio(false);\tcin.tie(0);cout.tie(0); \tcin>>t;\twhile(t--){\t\tcin>>n>>l>>r;\t\tfor(int i=1;i<=n;++i)cin>>a[i];\t\tint top=0;\t\tfor(int i=1;i<l;++i){\t\t\ts[++top]=a[i];\t\t}\t\tsort(a+l,a+r+1,cmp);\t\tsort(s+1,s+top+1,cmp2);\t\tint ans=0,now=1;\t\tfor(int i=l;i<=r;++i){\t\t\tif(a[i]>s[now] and now<=top){\t\t\t\tans+=s[now];\t\t\t\t++now; \t\t\t}\t\t\telse{\t\t\t\tans+=a[i];\t\t\t}\t\t}\t\tint ans2=0;\t\ttop=0;\t\tfor(int i=r+1;i<=n;++i){\t\t\ts[++top]=a[i];\t\t}\t\tsort(a+l,a+r+1,cmp);\t\tsort(s+1,s+top+1,cmp2);\t\tnow=1;\t\tfor(int i=l;i<=r;++i){\t\t\tif(a[i]>s[now] and now<=top){\t\t\t\tans2+=s[now];\t\t\t\t++now; \t\t\t}\t\t\telse{\t\t\t\tans2+=a[i];\t\t\t}\t\t}\t\tcout<<min(ans,ans2)<<'\\n'; \t}\t}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Subsequence Update.json",
    "hint": [
        "Hint Assume that you chose some two indices and included in the subsequence, such that and . Does this actually help decrease the answer in any way?"
    ]
}