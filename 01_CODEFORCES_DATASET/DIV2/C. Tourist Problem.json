{
    "link": "https://codeforces.com//contest/340/problem/C",
    "problemId": "3419",
    "problem_idx": "C",
    "shortId": "340C",
    "contest_number": "340",
    "problem_submissions": {
        "E": [
            4380220,
            4380834,
            4380126,
            4391968,
            4382367,
            4376164,
            4380005,
            4381859,
            4379851,
            4381825,
            4380671,
            4377641,
            4381576,
            4383755
        ],
        "D": [
            4377289,
            4376595,
            4378029,
            4372963,
            4376785,
            4377666,
            4373992,
            4376684,
            4376514,
            4377010,
            4380983,
            4375663,
            4376643,
            4377274,
            4373081,
            4406324,
            4378181,
            4380917,
            4377354,
            4383338
        ],
        "C": [
            4375809,
            4375002,
            4377603,
            4374632,
            4375617,
            4376250,
            4378682,
            4380136,
            4373891,
            4375990,
            4378082,
            4377910,
            4377314,
            4378457,
            4375078,
            4376703,
            4378516,
            4378506,
            4374797
        ],
        "B": [
            4372293,
            4378644,
            4376876,
            4375385,
            4378732,
            4374049,
            4386232,
            4373253,
            4380096,
            4376212,
            4383111,
            4383087,
            4379013,
            4399484,
            4382621,
            4372666
        ],
        "A": [
            4371264,
            4371296,
            4372303,
            4375873,
            4371313,
            4371976,
            4371443,
            4371936,
            4378560,
            4371824,
            4374190,
            4371558,
            4371435,
            4371343,
            4371370,
            4371365,
            4371526,
            4371376,
            4371280
        ]
    },
    "name": "C. Tourist Problem",
    "statement": "Iahub is a big fan of tourists. He wants to become a tourist himself, so\r\nhe planned a trip. There are destinations on a straight road that Iahub\r\nwants to visit. Iahub starts the excursion from kilometer 0. The\r\ndestinations are described by a non-negative integers sequence , , ...,\r\n. The number represents that the th destination is at distance\r\nkilometers from the starting point. No two destinations are located in\r\nthe same place. Iahub wants to visit each destination only once. Note\r\nthat, crossing through a destination is not considered visiting, unless\r\nIahub explicitly wants to visit it at that point. Also, after Iahub\r\nvisits his last destination, he doesn\u2019t come back to kilometer 0, as he\r\nstops his trip at the last destination. The distance between destination\r\nlocated at kilometer and next destination, located at kilometer , is\r\nkilometers. We call a \"route\" an order of visiting the destinations.\r\nIahub can visit destinations in any order he wants, as long as he visits\r\nall destinations and he doesn\u2019t visit a destination more than once.\r\nIahub starts writing out on a paper all possible routes and for each of\r\nthem, he notes the total distance he would walk. He\u2019s interested in the\r\naverage number of kilometers he would walk by choosing a route. As he\r\ngot bored of writing out all the routes, he asks you to help him.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define FR(i,a) for(int i = 0; i < (a); i++)\nusing namespace std;\nint n;\nint a[100300];\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    FOR(i,1,n) cin >> a[i];\n    sort(a+1,a+n+1);\n    a[0] = 0;\n    long long res = 0;\n    FOR(i,0,n-1) {\n        res += (long long)(n-i) * (2 * i + 1) * (a[i+1] - a[i]);\n    }\n    long long D = __gcd(res,(long long)n);\n    res/=D;\n    n/=D;\n    cout << res << \" \" << n << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Tourist Problem.json",
    "editorial_link": "https://codeforces.com/blog/entry/8755",
    "editorial": "Despite this is a math task, the only math formula we\u00e2\u0080\u0099ll use is that\r\nnumber of permutations with elements is . From this one, we can deduce\r\nthe whole task. The average formula is sum_of_all_routes /\r\nnumber_of_routes. As each route is a permutation with n elements,\r\nnumber_of_routes is . Next suppose you have a permutation of a: p1, p2,\r\n, pn. The sum for it will be p1 + |p2 p1| + + |pn pn-1|. The sum of\r\nroutes will be the sum for each possible permutation. We can calculate\r\nsum_of_all routes in two steps: first time we calculate sums like p1 and\r\nthen we calculate sums like |p2 p1| + + |pn pn-1| for every existing\r\npermutation. First step Each element of , , , can appear on the first\r\nposition on the routes and needs to be added as much as it appears.\r\nSuppose I fixed an element X for the first position. I can fill\r\npositions 2, 3, .., n 1 in (n 1)! ways. Why? It is equivalent to\r\npermuting n 1 elements (all elements except X). So sum_of_all = * (n\r\n1)! + * (n 1)! + * * (n 1)! = (n 1)! * ( + + + ). Second step For each\r\npermutation, for each position j between 1 and n 1 we need to compute |\r\n|. Similarly to first step, we observe that only elements from can\r\nappear on consecutive positions. We fix 2 indices i and j. We re\r\ninterested in how many permutations do appear before . We fix k such as\r\non a permutation p, appears on position k and appears on a position\r\nk + 1. In how many ways can we fix this? n 1 ways (1, 2, , n 1). What s\r\nleft? A sequence of (n 2) elements which can be permuted independently.\r\nSo the sum of second step is || * (n 1) * (n 2)!, for each i != j. If I\r\nnote ( + + + ) by S1 and || for each i != j by S2, the answer is (N\r\n1)! * S1 + (N 1)! * S2 / N!. By a simplification, the answer is (S1 +\r\nS2) / N. The only problem remained is how to calculate S2. Simple\r\niteration won t enter in time limit. Let s think different. For each\r\nelement, I need to make sum of differences between it and all smaller\r\nelements in the array a. As well, I need to make sum of all different\r\nbetween bigger elements than it and it. I ll focus on the first part. I\r\nsort increasing array a. Suppose I m at position . I know that (i 1)\r\nelements are smaller than . The difference is simply (i 1) *\r\nsum_of_elements_before_position_i. Sum of elements before position i can\r\nbe computed when iterating i. Let s call the obtained sum Sleft. I need\r\nto calculate now sum of all differences between an element and bigger\r\nelements than it. This sum is equal to Sleft. As a proof, for an element\r\n, calculating the difference when > is equivalent to calculating\r\ndifferences between and a smaller element of it (in this case ). That s\r\nwhy Sleft = Sright. As a conclusion, the answer is (S1 + 2 * Sleft) / N.\r\nFor make fraction irreducible, you can use Euclid\u00e2\u0080\u0099s algorithm. The\r\ncomplexity of the presented algorithm is , necessary due of sorting.\r\nSorting can be implemented by count sort as well, having a complexity of\r\nO(maximalValue), but this is not necessary. Official solution: 4383420\r\n"
}