{"link": "https://codeforces.com//contest/1828/problem/D1", "problemId": "1922405", "problem_idx": "D1", "shortId": "1828D1", "contest_number": "1828", "problem_submissions": {"E": [205928976, 205900019, 205882115, 205895924, 205892096, 205891436, 205893344], "F": [205895469], "D2": [205889438, 205883240, 205883734, 205896618, 206159170, 205894825, 205895793, 205893893, 205897477, 227549028, 205896300], "D1": [205878026, 205883337, 205866040, 205882122, 205875506, 205886552, 205886122, 205895740, 205872312, 205897439, 227549130, 205896247, 205864334, 205871289, 205871040, 205870968, 205880756, 205879364], "C": [205856261, 205854711, 205855088, 205857693, 205852246, 205857010, 205863890, 205863938, 205866888, 205861344, 205875792, 205859789, 205857545, 205862873, 205854617, 205857622, 205861133, 205854364, 205855992, 205858999], "B": [205851848, 205854227, 205848826, 205865189, 205847163, 205851029, 205851540, 205857305, 205865622, 205851306, 205878139, 205854556, 205860197, 205853496, 205849725, 205848581, 205854845, 205849749, 205849027, 205848392], "A": [205844206, 205843332, 205843301, 205858624, 205843073, 205843188, 205845089, 205849854, 205854254, 205843004, 205878944, 205844207, 205862200, 205845877, 205843927, 205843783, 205843659, 205846739, 205843197, 205843308]}, "name": "D1. Range Sorting  Easy Version ", "statement": "You are given an array a, consisting of n distinct integers a_1, a_2,\r\nldots, a_n. Define the of an array p_1, p_2,\r\nldots p_k as the minimum amount of time needed to sort this array using\r\nan arbitrary number of operations. In each range-sort operation, you\r\nwill do the following: Choose two integers l and r (1\r\nle l < r\r\nle k). Sort the subarray p_l, p_{l + 1},\r\nldots, p_r in r - l seconds. Please calculate the sum of beauty over all\r\nsubarrays of array a.A subarray of an array is defined as a sequence of\r\nconsecutive elements of the array.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, d, u) for(int i = d; i <= u; ++i)\n#define dep(i, u, d) for(int i = u; i >= d; --i)\n#define cep(n) while(n--)\n#define gep(i, a) for(int i = firs[a]; i; i = neig[i])\nint ured() {\n\tint re = 0;\n\tchar ch;\n\tdo {\n\t\tch = getchar();\n\t} while('9' < ch || ch < '0');\n\tdo {\n\t\tre = re * 10 + (ch ^ '0');\n\t} while('0' <= (ch = getchar()) && ch <= '9');\n\treturn re;\n}\nvoid lwit(long long da) {\n\tint ch[21], cn = 0;\n\tdo {\n\t\tch[++cn] = da - da / 10 * 10;\n\t} while(da /= 10);\n\tdo {\n\t\tputchar('0' ^ ch[cn]);\n\t} while(--cn);\n}\nconst int _maxn = 300011;\nint t, n, a[_maxn], sran[_maxn], stak[_maxn], stau[_maxn], dans, tops;\nlong long rans;\nint main() {\n\tt = ured();\n\tcep(t) {\n\t\tn = ured(), rans = 0;\n\t\trep(i, 1, n) {\n\t\t\ta[sran[i] = i] = ured();\n\t\t}\n\t\tsort(sran + 1, sran + n + 1, [](int le, int ri) {\n\t\t\treturn a[le] < a[ri];\n\t\t});\n\t\trep(i, 1, n) {\n\t\t\ta[sran[i]] = i;\n\t\t}\n\t\trep(i, 1, n) {\n\t\t\ttops = dans = 0;\n\t\t\trep(j, i, n) {\n\t\t\t\tif(dans < a[j]) {\n\t\t\t\t\tstak[++tops] = dans = a[j], stau[tops] = a[j];\n\t\t\t\t} else {\n\t\t\t\t\twhile(tops && stak[tops] > a[j]) {\n\t\t\t\t\t\t--tops;\n\t\t\t\t\t}\n\t\t\t\t\tif(!tops || a[j] > stau[tops]) {\n\t\t\t\t\t\tstak[++tops] = a[j];\n\t\t\t\t\t}\n\t\t\t\t\tstau[tops] = dans;\n\t\t\t\t}\n\t\t\t\trans += j - i + 1 - tops;\n\t\t\t}\n\t\t}\n\t\tlwit(rans), putchar('\\n');\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures", "dp", "dsu", "greedy"], "dificulty": "2000", "interactive": false}