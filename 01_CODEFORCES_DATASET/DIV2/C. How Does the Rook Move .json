{
    "link": "https://codeforces.com//contest/1957/problem/C",
    "problemId": "2603601",
    "problem_idx": "C",
    "shortId": "1957C",
    "contest_number": "1957",
    "problem_submissions": {
        "F2": [
            257624433,
            257624489,
            257628560,
            257621420,
            257758223,
            257757604,
            257757158,
            257717832,
            257717730,
            257717258,
            257717094,
            257702987,
            257702893,
            257653582,
            257653503,
            257653382,
            257648260,
            257648200,
            257641190,
            257634868,
            258552083,
            257634246,
            257634091,
            257829923,
            257637903,
            257630367,
            257637563,
            257640902,
            257704441,
            257700658,
            257703241,
            257675512
        ],
        "F1": [
            257621694,
            257624482,
            257625658,
            257622086,
            257648013,
            257642139,
            257635215,
            257625683,
            257633642,
            258551844,
            257633990,
            257634721,
            257829841,
            257638057,
            257627166,
            257647697,
            257636396,
            257640746,
            257705007,
            257704891,
            257704777,
            257704536,
            257700768,
            257627958
        ],
        "E": [
            257613753,
            257614244,
            257616954,
            257640621,
            257621102,
            257640619,
            257640273,
            257640555,
            259401179,
            257624465,
            258075127,
            258075029,
            257758887,
            257629108,
            257623748,
            257629560,
            257710288,
            257703200,
            257629906
        ],
        "D": [
            257596630,
            257598457,
            257598487,
            257603992,
            257647200,
            257596253,
            257607704,
            257604728,
            257613557,
            257603006,
            257615450,
            257603399,
            257750188,
            257750155,
            257615591,
            257640469,
            257600270,
            257625077,
            257609428,
            257606452,
            257699780,
            257597686,
            257607920
        ],
        "C": [
            257588829,
            257601875,
            257591094,
            257606559,
            257647316,
            257588836,
            257594613,
            257599149,
            257595684,
            257596544,
            257603207,
            257596444,
            257750051,
            257601967,
            257593914,
            257592224,
            257605529,
            257595109,
            257707171,
            257596812,
            257597956
        ],
        "B": [
            257581790,
            257579250,
            257586196,
            257583617,
            257579912,
            257584731,
            257593706,
            257593301,
            257585131,
            257584270,
            257581125,
            257750016,
            257588415,
            257583409,
            257582823,
            257585712,
            257597823,
            257594421,
            257595763,
            257581837
        ],
        "A": [
            257576275,
            257575809,
            257577678,
            257575791,
            257575498,
            257575836,
            257579145,
            257575454,
            257576815,
            257575470,
            257575437,
            257749968,
            257582519,
            257575927,
            257575935,
            257576650,
            257596800,
            257590104,
            257582071,
            257575937
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128716",
    "editorial": "There are essentially two types of moves: Placing a rook at some : This\r\nreduces the number of free rows and columns available by . Placing a\r\nrook at some , where : The computer now mirrors this by placing a rook\r\nat , blocking rows and along with columns and . So the number of free\r\nrows and columns is reduced by . First, we account for the moves played\r\nearlier and count the number of free columns/rows remaining to place\r\nrooks in, and call it .Notice that the order of removing rows/columns\r\ndoesn\u00e2\u0080\u0099t affect the final configuration of rooks, and hence only the\r\ncount of rows matters, to determine the number of final\r\nconfigurations.We can use a dynamic programming approach where\r\nrepresents the number of final configurations when rows and columns are\r\nleft.Since the order of removing rows/columns is unimportant, let\u00e2\u0080\u0099s\r\nstart by removing the last row or column.When removing the last row or\r\ncolumn in an grid, we have two options: We place a rook , resulting in\r\nthe deletion of only the last row and column leaving an grid. The number\r\nof final configurations in this case are given by . Alternatively, we\r\ncan place a rook at or for any . After this move, both the -th and the\r\n-th rows and columns are deleted, leaving an grid. This contributes to .\r\nOverall, we compute for all , with the base case of .Our final answer is\r\n.\r\n",
    "name": "C. How Does the Rook Move ",
    "statement": "You are given an n\r\ntimes n chessboard where you and the computer take turns alternatingly\r\nto place white rooks & black rooks on the board respectively. While\r\nplacing rooks, you have to ensure that no two rooks attack each other.\r\nTwo rooks attack each other if they share the same row or column .A\r\nvalid move is placing a rook on a position (r, c) such that it doesn\u2019t\r\nattack any other rook.You start first, and when you make a valid move in\r\nyour turn, placing a white rook at position (r, c), the computer will\r\nmirror you and place a black rook at position (c, r) in its turn. If r =\r\nc, then the computer can\u2019t mirror your move, and skips its turn.You have\r\nalready played k moves with the computer (the computer tries to mirror\r\nthese moves too), and you must continue playing the game until there are\r\nno valid moves remaining. How many different final configurations are\r\npossible when you continue the game after the k moves? It is guaranteed\r\nthat the k moves and the implied computer moves are valid. Since the\r\nanswer may be large, print it modulo 10^9+7.Two configurations are\r\nconsidered different if there exists a coordinate (r, c) which has a\r\nrook in one configuration, but not in the other the color of the rook on\r\nthe coordinate is different.\r\n",
    "solutions": [
        "/*\u5728\u53d1\u89c9\u90a3\u4e00\u5929 \u5728\u90a3\u4e00\u5929\u6f6e\u6c5b\u6cdb\u4e0a\u9ad8\u7b51\u57ce\u5899\u65f6\u95f4\u8bf7\u5c06\u4e00\u5207\u8bc1\u660e*/#include<bits/stdc++.h>using namespace std;const int maxn=500005,mod=1000000007;int n,m,T,ans,flg,tot;int a[maxn],fac[maxn],nfac[maxn],inv[maxn],mul[maxn];inline int C(int a,int b){\treturn a<b? 0:1ll*fac[a]*nfac[b]%mod*nfac[a-b]%mod;}int main(){\tmul[0]=1;\tfor(int i=1;i<maxn;i++)\t\tmul[i]=(mul[i-1]+mul[i-1])%mod;\tfac[0]=fac[1]=inv[1]=nfac[0]=nfac[1]=1;\tfor(int i=2;i<maxn;i++)\t\tfac[i]=1ll*fac[i-1]*i%mod,inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod,nfac[i]=1ll*nfac[i-1]*inv[i]%mod;\tscanf(\"%d\",&T);\twhile(T--){\t\tans=flg=0;\t\tscanf(\"%d%d\",&n,&m),tot=n;\t\tfor(int i=1,x,y;i<=m;i++)\t\t\tscanf(\"%d%d\",&x,&y),tot-=(x!=y),tot--;\t\tans=0;\t\tfor(int i=0;i*2<=tot;i++)\t\t\tans=(ans+1ll*C(tot,i+i)*C(i+i,i)%mod*fac[i])%mod;\t\tprintf(\"%d\\n\",ans);\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. How Does the Rook Move .json"
}