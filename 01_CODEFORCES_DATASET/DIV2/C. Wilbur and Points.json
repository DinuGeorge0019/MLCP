{
    "link": "https://codeforces.com//contest/596/problem/C",
    "problemId": "40907",
    "problem_idx": "C",
    "shortId": "596C",
    "contest_number": "596",
    "problem_submissions": {
        "E": [
            14284902,
            14410276,
            14285890,
            14836358
        ],
        "A": [
            14282529,
            14272331,
            14272408,
            14272249,
            14272247,
            14272132,
            14272036,
            14272062,
            14273974,
            14272466,
            14272094,
            14272742,
            14272840,
            14272048,
            14272087,
            14272349,
            14272225,
            14272447,
            14273354,
            14273114
        ],
        "D": [
            14280833,
            14284455,
            14282588,
            14285386,
            14285067,
            14284298,
            14286251,
            14285939,
            14284050,
            14285941,
            14286108,
            14293470,
            14284179
        ],
        "C": [
            14276112,
            14278736,
            14278325,
            14279291,
            14278970,
            14277576,
            14282655,
            14280088,
            14281778,
            14280140,
            14281205,
            14281281,
            14279114,
            14277665,
            14278438,
            14279354,
            14285136,
            14283954,
            14281786
        ],
        "B": [
            14272947,
            14272778,
            14273548,
            14272930,
            14272933,
            14273058,
            14272243,
            14272568,
            14274807,
            14272965,
            14272538,
            14274186,
            14273926,
            14272409,
            14272384,
            14272994,
            14273180,
            14273634,
            14274094,
            14274290
        ]
    },
    "name": "C. Wilbur and Points",
    "statement": "Wilbur is playing with a set of points on the coordinate plane. All\r\npoints have non-negative integer coordinates. Moreover, if some point (,\r\n) belongs to the set, then all points (, ), such that and also belong to\r\nthis set.Now Wilbur wants to number the points in the set he has, that\r\nis assign them distinct integer numbers from to . In order to make the\r\nnumbering , Wilbur imposes the condition that if some point (, ) gets\r\nnumber , then all (,) from the set, such that and must be assigned a\r\nnumber not less than . For example, for a set of four points (, ), (, ),\r\n(, ) and (, ), there are two aesthetically pleasing numberings. One is ,\r\n, , and another one is , , , .Wilbur’s friend comes along and challenges\r\nWilbur. For any point he defines it’s as . Now he gives Wilbur some ,\r\n,..., , and asks him to find an aesthetically pleasing numbering of the\r\npoints in the set, such that the point that gets number has it’s special\r\nvalue equal to , that is .Now Wilbur asks you to help him with this\r\nchallenge.\r\n",
    "solutions": [
        "//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 1e5 + 49;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nint sz, w[maxN], m, sx[maxN], sy[maxN];\nint ans[maxN];\nset<pii> st;\nmap<pii, int> ind;\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tint ii = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> sx[i] >> sy[i];\n\t\tind[pii(sx[i], sy[i])] = i;\t\n\t\tif (!sx[i] && !sy[i]) ii = i;\t\n\t}\n\tst.insert({0, ii});\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tauto it = st.lower_bound(make_pair(w[i], -1));\n\t\tif (it != st.end() && (*it).x == w[i]) {\n\t\t\tans[m++] = (*it).second;\n\t\t\tint id = (*it).second;\n\t\t\tfor (int xadd = 0; xadd < 2; xadd++) {\n\t\t\t\tint nx = sx[id] + xadd, ny = sy[id] + (xadd ^ 1);\n\t\t\t\tif (ind.find(make_pair(nx, ny)) != ind.end()) {\n\t\t\t\t\tst.insert({ny - nx, ind[make_pair(nx, ny)]});\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.erase(it);\n\t\t} else {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\t\n\t\t}\n\t}\n\tcout << \"YES\\n\";\n\tfor (int i = 0; i < n; i++)\n\t\tcout << sx[ans[i]] << ' ' << sy[ans[i]] << '\\n';\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Wilbur and Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/21599",
    "editorial": "Note that if there is an integer so that the number of equal to differs\r\nfrom the number of the given squares whose weight equals , then the\r\nanswer is automatically \"NO\". This can be easily checked by using a map\r\nfor the and the weights of the squares and checking if the maps are the\r\nsame. This step takes time. Let be an integer, and let be the set of all\r\nso that . Let be the set of all special points so that the weight of is\r\n. Note that and have the same number of elements. Suppose that are the\r\nelements of . Let if or and . Suppose that are the elements of . Note\r\nthat the point has to be labeled by for . Now, each special point is\r\nlabeled. It remains to check if this is a valid labeling. This can be\r\ndone by taking an array of vectors. The vector will denote the points\r\nwith -coordinate . This vector can be easily made from the points given\r\nin time, and since the points are already labeled, will denote the label\r\nfor the point . Now, for all points , the point (if it is special) and\r\nthe point (if it is special) must have a greater number than . This step\r\ntakes a total of time. Complexity: Code: Solution Bonus: Can you do this\r\nproblem in time? Comments: This problem was inspired by the\r\nrepresentation theory of the group of permutations (Representation\r\ntheory of the Symmetric Group). Essential objects in the study of are\r\nYoung diagrams and standard Young tableau (Young Tableau). The weight of\r\na point as defined by the problem is basically the same thing as the\r\ncontent of a square in a standard Young tableaux. If you have questions,\r\nfeel free to message me. Let us solve this problem using dynamic\r\nprogramming. First let us reindex the trees by sorting them by\r\n-coordinate. Let where we would like to consider the problem of if we\r\nonly have trees standing where indicates that tree falls right and if it\r\nfalls left and indicates that tree falls right and if it falls left. We\r\nstart with the case that Wilbur chooses the left tree and it falls\r\nright. The plan is to calculate the expected length in this scenario and\r\nmultiply by the chance of this case occurring, which is . We can easily\r\ncalculate what is the farthest right tree that falls as a result of this\r\nand call it . Then if this means the entire segment falls, from which\r\nthe length of the ground covered by trees in can be calculated. However,\r\nbe careful when , as there may be overlapping covered regions when the\r\ntree falls right but the tree falls left. If only , then we just\r\nconsider adding the length of ground covered by trees falling right and\r\nadd to the value of the subproblem . There is another interesting case\r\nwhere Wilbur chooses the left tree and it falls left. In this case we\r\ncalculate the expected length and multiply by the chance of this\r\noccurring, which is . The expected length of ground covered by the trees\r\nhere is just the length contributed by tree falling left, which we must\r\nbe careful calculating as there might be overlapping covered regions\r\nwith the th tree falling left and the th tree falling right. Then we\r\nalso add the value of subproblem . Doing this naively would take time,\r\nbut this can be lowered to by precalculating what happens when tree\r\nfalls left or right. We should also consider the cases that Wilbur\r\nchooses the right tree, but these cases are analogous by symmetry.\r\nComplexity: Code: Solution Solution 1: Suppose that is a string in the\r\nquery. Reverse and the direction of all the moves that can be made on\r\nthe table. Note that starting at any point that is part of a cycle,\r\nthere is a loop and then edges that go out of the loop. So, for every\r\npoint, it can be checked by dfs whether the can be made by starting at\r\nthat point by storing what is in the cycle. Moreover, note that in the\r\nreversed graph, each point can only be a part of one cycle. Therefore,\r\nthe total time for the dfs in a query is . This is good enough for\r\nqueries to run in time. Complexity: where is the number of distinct\r\ncharacters in the table, and is the query string for the th query. Code:\r\nSolution Solution 2 (Actually too slow, see comment by waterfalls below\r\nfor more details): For each string , dfs from every node that has in\r\ndegree equal to in the original graph. There will be a path which leads\r\ninto a cycle after which anything in the cycle can be used any number of\r\ntimes in . Only every node with in degree equal to has to be checked\r\nbecause every path which leads to a cycle is part of a larger path which\r\nstarts with a vertex of in degree that leads into a cycle. This solution\r\nis slower, but it works in practice since it is really hard for a string\r\nto match so many times in the table. Each query will take time, but it\r\nis much faster in practice. Complexity: where is the number of distinct\r\ncharacters in the table, and is the query string of the th query.\r\n",
    "hint": []
}