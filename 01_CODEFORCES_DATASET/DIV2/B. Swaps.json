{
    "link": "https://codeforces.com//contest/1573/problem/B",
    "problemId": "1113070",
    "problem_idx": "B",
    "shortId": "1573B",
    "contest_number": "1573",
    "problem_submissions": {
        "D": [
            129211729,
            129206759,
            129197164,
            129194726,
            129186807,
            129296553,
            129201143,
            129198553,
            129200951,
            129204017,
            129203484,
            129203960,
            129200720,
            129203477,
            129203437,
            129205853
        ],
        "E": [
            129195381,
            129194363,
            129199429,
            129179637,
            129197397,
            129196652
        ],
        "C": [
            129184190,
            129188576,
            129188704,
            129201501,
            129185674,
            129198766,
            129196140,
            129200201,
            129228180,
            129201620,
            129186651,
            129189132,
            129188899,
            129187320,
            129192678,
            129192241,
            129184572,
            129199512,
            129191618,
            129190718
        ],
        "B": [
            129172862,
            129196906,
            129176190,
            129203844,
            129172298,
            129171523,
            129174991,
            129187627,
            129183320,
            129178269,
            129185994,
            129182784,
            129179822,
            129174918,
            129183834,
            129199069,
            129172947,
            129197456,
            129180823
        ],
        "A": [
            129167486,
            129167526,
            129168431,
            129168344,
            129167107,
            129167895,
            129167756,
            129167152,
            129174946,
            129168601,
            129168318,
            129169357,
            129170825,
            129173901,
            129168162,
            129170465,
            129167770,
            129167307,
            129177822,
            129167367
        ],
        "F": [
            132459885
        ]
    },
    "name": "B. Swaps",
    "statement": "You are given two arrays a and b of length n. Array a contains each\r\ninteger from 1 to 2n in an arbitrary order, and array b contains each\r\ninteger from 1 to 2n in an arbitrary order.You can perform the following\r\noperation on those arrays: choose one of the two arrays pick an index i\r\nfrom 1 to n-1 swap the i-th and the (i+1)-th elements of the chosen\r\narray Compute the minimum number of operations needed to make array a\r\nlexicographically smaller than array b.For two different arrays x and y\r\nof the same length n, we say that x is lexicographically smaller than y\r\nif in the first position where x and y differ, the array x has a smaller\r\nelement than the corresponding element in y.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint i,j,k,n,m,t,res,pos[200500],mx[200500],it;\n\nint main(){\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%d\",&n);res=11451491;\n\t\tit=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tpos[k]=++it;\n\t\t}\n\t\tit=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tpos[k]=++it;\n\t\t}\n\t\tmx[n+n+2]=11451419;\n\t\tfor(i=n+n;i>=2;i-=2){\n\t\t\tmx[i]=min(mx[i+2],pos[i]);\n\t\t\t//cout<<mx[i]<<endl;\n\t\t}\n\t\tfor(i=n+n-1;i>=1;i-=2){\n\t\t\tres=min(res,pos[i]-1+mx[i+1]-1);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "Since the array has odd numbers and array has even numbers, then they\r\nwill differ at the first position no matter how we perform the\r\noperations. It follows that in order to make the first array\r\nlexicographically smaller than the second one we need to make the first\r\nelement of smaller than the first element of . To move the -th element\r\nof an array to the first position we can perform the operation on\r\nelements , , ..., , , which is optimal. The answer is then the minimum\r\nof over all , such that .Now we will think how to calculate this\r\neffectively. Let be the position of number in its respective sequence (\r\nfor odd and for even). We will go through the numbers from biggest to\r\nsmallest. Let be the position of the leftmost number in sequence that\r\nwas already considered. If is even we will set to . If is odd we will\r\nset to .Our total time complexity is then .\r\n"
}