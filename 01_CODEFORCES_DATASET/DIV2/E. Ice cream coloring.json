{
    "link": "https://codeforces.com//contest/805/problem/E",
    "problemId": "105170",
    "problem_idx": "E",
    "shortId": "805E",
    "contest_number": "805",
    "problem_submissions": {
        "E": [
            26857780,
            26856750,
            26858111,
            26857063,
            26859139,
            26856888,
            26859899,
            26860928,
            26861436,
            26860967,
            26859459,
            26858902,
            26861950,
            26859019,
            26862819,
            26861493
        ],
        "D": [
            26844331,
            26843852,
            26846709,
            26847271,
            26843712,
            26849970,
            26845256,
            26850183,
            26849852,
            26846814,
            26846907,
            26847537,
            26851958,
            26850830,
            26850561,
            26852120,
            26848761,
            26850340,
            26852553,
            26854400
        ],
        "C": [
            26841586,
            26841442,
            26843378,
            26841793,
            26849729,
            26843226,
            26842851,
            26847163,
            26844593,
            26844046,
            26842105,
            26844673,
            26843379,
            26843951,
            26848871,
            26841493,
            26842855,
            26845699,
            26846895,
            26847872
        ],
        "B": [
            26839792,
            26840934,
            26840059,
            26841075,
            26840279,
            26839383,
            26840491,
            26847999,
            26841324,
            26839809,
            26839811,
            26839925,
            26840626,
            26839840,
            26840234,
            26839411,
            26840270,
            26846558,
            26843910,
            26843501
        ],
        "A": [
            26837425,
            26838400,
            26837402,
            26838568,
            26837965,
            26837187,
            26849788,
            26839799,
            26839327,
            26837458,
            26837278,
            26846404,
            26837755,
            26840946,
            26838306,
            26837294,
            26837665,
            26859742,
            26839927,
            26841184
        ],
        "F": [
            26862002,
            26862152,
            27206248,
            35743638,
            26862813,
            26870973,
            26870602
        ]
    },
    "name": "E. Ice cream coloring",
    "statement": "Isart and Modsart were trying to solve an interesting problem when\r\nsuddenly Kasra arrived. Breathless, he asked: \"Can you solve a problem\r\nI\u2019m stuck at all day?\"We have a tree with vertices and types of ice\r\ncream numerated from to . Each vertex has a set of types of ice cream.\r\nVertices which have the -th () type of ice cream form a connected\r\nsubgraph. We build a new graph with vertices. We put an edge between the\r\n-th and the -th (, ) vertices in if and only if there exists a vertex in\r\nthat has both the -th and the -th types of ice cream in its set. The\r\nproblem is to paint the vertices of with minimum possible number of\r\ncolors in a way that no adjacent vertices have the same color.Please\r\nnote that we consider that empty set of vertices form a connected\r\nsubgraph in this problem.As usual, Modsart don\u2019t like to abandon the\r\nprevious problem, so Isart wants you to solve the new problem.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <bitset>\n#define fi first\n#define se second\n#define mkp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define per(i,b,a) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,a,b) for (int i=(a);i<=(b);i++)\n#define PER(i,b,a) for (int i=(b);i>=(a);i--)\nusing namespace std;\ntypedef long long LL;\n\nconst int INF = 0x3f3f3f3f;\n\nconst int MAXN = 1000005; // 1e6;\nint n,m;\nvector<int>G[MAXN];\nset<int> S[MAXN];\nint ans;\nint c[MAXN];\nvoid dfs(int i, int fa)\n{\n        vector<int> used;\n        if (fa==-1)\n        {\n                for (int x:S[i])\n                {\n                        c[x] = ++ans;\n                }\n        }\n        else\n        {\n                for (int x:S[i])\n                {\n                        if (c[x] != 0) used.pb(c[x]);\n                }\n                sort(used.begin(), used.end());\n                int now = 1,ite = 0;\n                for (int x:S[i])\n                {\n                        if (c[x] == 0)\n                        {\n                                while(ite < used.size())\n                                {\n                                        if (now == used[ite]) ite++, now ++;\n                                        else break;\n                                }\n                                c[x]=now;\n                                now++;\n                        }\n                }\n                ans = max(ans,now-1);\n        }\n        rep(j,0,G[i].size())\n        {\n                int v = G[i][j];\n                if (v==fa) continue;\n                dfs(v,i);\n        }\n}\n\nint main()\n{\n        scanf(\"%d%d\",&n,&m);\n        rep(i,1,n+1)\n        {\n                int si;\n                scanf(\"%d\",&si);\n                rep(j,0,si)\n                {\n                        int c;\n                        scanf(\"%d\",&c); S[i].insert(c);\n                }\n        }\n        rep(i,1,n)\n        {\n                int u,v;\n                scanf(\"%d%d\",&u,&v);G[u].pb(v);G[v].pb(u);\n        }\n        dfs(1,-1);\n\n        if (ans == 0) ans = 1;\n        printf(\"%d\\n\",ans);\n\n        rep(i,1,m+1)\n        {\n                if (c[i]==0) c[i]=1;\n                printf(\"%d%c\",c[i],\" \\n\"[i==m]);\n        }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ice cream coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/51846",
    "editorial": "Let\u00e2\u0080\u0099s guess as obvious as possible. We can get the answer is at least\r\n.We\u00e2\u0080\u0099ll just use a dfs to paint the graph with this answer.Run dfs and in\r\neach step, when we are in vertex with parent , for each ice cream, if it\r\nis in the set of , then its color is given in the par\u00e2\u0080\u0099s set. If not,\r\nwe\u00e2\u0080\u0099ll paint it with a color that isn\u00e2\u0080\u0099t used in this set. To prove the\r\nalgorithm works, assume the first step we paint an ice cream by -th\r\ncolor, you know the number of ice creams is at last equal to answer,\r\nsome of these ice creams was painted in the par\u00e2\u0080\u0099s set and obviously we\r\ndon\u00e2\u0080\u0099t need to more than color to paint them.\r\n"
}