{
    "link": "https://codeforces.com//contest/231/problem/B",
    "problemId": "1907",
    "problem_idx": "B",
    "shortId": "231B",
    "contest_number": "231",
    "problem_submissions": {
        "E": [
            2315623,
            2318030,
            2317938,
            2318674,
            2318779,
            2317611,
            2320585,
            2319865,
            2321228,
            2699180
        ],
        "B": [
            2314265,
            2313607,
            2314034,
            2314278,
            2314068,
            2314153,
            2313828,
            2314473,
            2314118,
            2313793,
            2314083,
            2313846,
            2315002,
            2315695,
            2314096,
            2316200,
            2314037,
            2313902
        ],
        "C": [
            2313829,
            2314125,
            2314733,
            2315243,
            2315319,
            2313875,
            2315066,
            2315078,
            2314341,
            2315041,
            2314618,
            2314471,
            2313703,
            2314701,
            2313945,
            2315683,
            2314609
        ],
        "A": [
            2312031,
            2312037,
            2312506,
            2312986,
            2312060,
            2312377,
            2312848,
            2312030,
            2312702,
            2312166,
            2312096,
            2312665,
            2315132,
            2312576,
            2312184,
            2312109,
            2312683,
            2312307
        ],
        "D": [
            2315039,
            2315337,
            2315944,
            2316047,
            2314614,
            2314405,
            2315592,
            2316024,
            2314917,
            2314554,
            2314992,
            2313590,
            2314889,
            2315003,
            2314692,
            2314435,
            2315454
        ]
    },
    "name": "B. Magic, Wizardry and Wonders",
    "statement": "Vasya the Great Magician and Conjurer loves all kinds of miracles and\r\nwizardry. In one wave of a magic wand he can turn an object into\r\nsomething else. But, as you all know, there is no better magic in the\r\nUniverse than the magic of numbers. That\u2019s why Vasya adores math and\r\nspends a lot of time turning some numbers into some other ones.This\r\nmorning he has cards with integers lined up in front of him. Each\r\ninteger is not less than 1, but not greater than . When Vasya waves his\r\nmagic wand, two rightmost cards vanish from the line and a new card\r\nmagically appears in their place. It contains the difference between the\r\nleft and the right numbers on the two vanished cards. Vasya was very\r\ninterested to know what would happen next, and so he waved with his\r\nmagic wand on and on, until the table had a single card left.Suppose\r\nthat Vasya originally had the following cards: 4, 1, 1, 3 (listed from\r\nleft to right). Then after the first wave the line would be: 4, 1, -2,\r\nand after the second one: 4, 3, and after the third one the table would\r\nhave a single card with number 1.Please note that in spite of the fact\r\nthat initially all the numbers on the cards were not less than 1 and not\r\ngreater than , the numbers on the appearing cards can be anything, no\r\nrestrictions are imposed on them.It is now evening. Vasya is very tired\r\nand wants to return everything back, but does not remember which cards\r\nhe had in the morning. He only remembers that there were cards, they\r\ncontained integers from 1 to , and after all magical actions he was left\r\nwith a single card containing number .Help Vasya to recover the initial\r\nset of cards with numbers.\r\n",
    "solutions": [
        "#include<vector> \n#include<list> \n#include<map> \n#include<set> \n#include<deque> \n#include<queue> \n#include<stack> \n#include<bitset> \n#include<algorithm> \n#include<functional> \n#include<numeric> \n#include<utility> \n#include<iostream> \n#include<sstream> \n#include<iomanip> \n#include<cmath> \n#include<cstdlib> \n#include<cctype> \n#include<string> \n#include<cstring> \n#include<cstdio> \n#include<ctime> \n#include<climits> \n#include<complex> \n#define sz(x) (int)((x).size()) \n#define rep(i,n) for (int i=0;i<n;i++) \n#define mp make_pair \n#define pb push_back\n#define fi first\n#define se second \n#define all(x) x.begin(),x.end() \n#define clr(x) memset((x),0,sizeof(x)) \n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e) \nusing namespace std; \nconst double eps=1e-8; \nconst double pi=acos(-1.0); \nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;} \ntypedef long long ll; \ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<string> vs; \ntypedef pair<int,int> pii; \ntypedef vector<pii> vpi; \nint n,d,l;\nint main()\n{\n    int i,j,k;\n    cin>>n>>d>>l;\n    int ad=(n+1)/2;\n    int su=n-ad;\n    //[ad,ad*l]\n    //[su,su*l]\n    //[ad-su*l,ad*l-su]\n    if (d<ad-su*l||d>ad*l-su)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    vi a;\n    for (i=0;i<ad;i++)a.pb(l);\n    for (i=0;i<su;i++)a.pb(1);\n    int now=ad*l-su;\n    while (now>d)\n    {\n        k=0;\n        for (i=0;i<ad;i++)\n        {\n            if (a[i]>1)\n            {\n                a[i]--;\n                k=1;\n                break;\n            }\n        }\n        if (k)\n        {\n            now--;\n            continue;\n        }\n        for (i=ad;i<ad+su;i++)\n        {\n            if (a[i]<l)\n            {\n                a[i]++;\n                k=1;\n                break;\n            }\n        }\n        if (k)\n        {\n            now--;\n            continue;\n        }\n    }\n    i=0;j=ad;k=0;\n    while (i<ad||j<n)\n    {\n        if (k==0)\n        {\n            printf(\"%d\\n\",a[i++]);\n        }\n        else \n        {\n            printf(\"%d\\n\",a[j++]);\n        }\n        k^=1;\n    }\n    return 0;\n}\n        "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Magic, Wizardry and Wonders.json",
    "editorial_link": "https://codeforces.com/blog/entry/5486",
    "editorial": "Let\u00e2\u0080\u0099s see, what will be the last number of array after iterations. After\r\nthe first iteration it will be (and total number of elements will be\r\ndecreased by one). After the second iteration the last number will be .\r\nIt is not hard to see, that after iterations remain . In a such way, our\r\ntask is to put numbers from to in array so, that sum of numbers in odd\r\npositions minus sum of numbers in even positions will equal to given .\r\nThis means sum of numbers in odd positions must be equal . But the\r\nminimal sum can be , and the maximal . Because of this we should choose\r\nso, that fits the boundaries. Constrains allow to do it in a such\r\nmanner. Firstly, put ones on the even positions. If after that, the\r\nanswer is . Otherwise, let\u00e2\u0080\u0099s increase each by one until . If we put in\r\nall even positions and , than answer is too. After we put numbers on\r\neven positions, let\u00e2\u0080\u0099s write in all odd positions, and while sum of this\r\nelements is less than increase each one by fitting value.\r\n"
}