{"link": "https://codeforces.com//contest/1384/problem/F", "problemId": "681339", "problem_idx": "F", "shortId": "1384F", "contest_number": "1384", "problem_submissions": {"D": [87920747, 87898550, 87899799, 87904419, 87905595, 87900804, 87885567, 87904258, 87914433, 87915245, 87916166, 87919718, 87915464, 87919225, 87915479, 87921886, 87920890, 87922578, 87921368, 87920046], "F": [87913933], "B1": [87894001, 87885002, 87901113, 87888080, 87892689, 87910843, 87920006, 87917285, 87898927, 87884228, 87892152, 87886631, 87893715, 87908879, 87900239, 87907063, 87892421, 87898971, 87917937, 87897854], "B2": [87893926, 87884835, 87901230, 87887888, 87903446, 87910900, 87919888, 87917176, 87906127, 87884007, 87892285, 87886523, 87893549, 87908713, 87900384, 87907601, 87892328, 87898841, 87917847, 87897690], "C": [87885628, 87894004, 87882731, 87893702, 87872158, 87889498, 87895035, 87884029, 87889346, 87904942, 87896617, 87893149, 87904403, 87889926, 87909570, 87895224, 87907611, 87906036, 87884342, 87911186], "A": [87871418, 87873285, 87873996, 87872062, 87871221, 87872543, 87898590, 87873955, 87871869, 87871615, 87875627, 87876144, 87877768, 87875116, 87878214, 87873342, 87873019, 87876431, 87871586, 87881479], "E": []}, "name": "F. Rearrange", "statement": "Koa the Koala has a matrix A of n rows and m columns. Elements of this\r\nmatrix are distinct integers from 1 to n\r\ncdot m (each number from 1 to n\r\ncdot m appears exactly once in the matrix).For any matrix M of n rows\r\nand m columns let\u2019s define the following: The i-th row of M is defined\r\nas R_i(M) = [ M_{i1}, M_{i2},\r\nldots, M_{im} ] for all i (1\r\nle i\r\nle n). The j-th column of M is defined as C_j(M) = [ M_{1j}, M_{2j},\r\nldots, M_{nj} ] for all j (1\r\nle j\r\nle m). Koa defines S(A) = (X, Y) as the spectrum of A, where X is the\r\nset of the maximum values in rows of A and Y is the set of the maximum\r\nvalues in columns of A.More formally: X =\r\n{\r\nmax(R_1(A)),\r\nmax(R_2(A)),\r\nldots,\r\nmax(R_n(A))\r\n} Y =\r\n{\r\nmax(C_1(A)),\r\nmax(C_2(A)),\r\nldots,\r\nmax(C_m(A))\r\n}Koa asks you to find some matrix A\u2019 of n rows and m columns, such that\r\neach number from 1 to n\r\ncdot m appears exactly once in the matrix, and the following conditions\r\nhold: S(A\u2019) = S(A) R_i(A\u2019) is bitonic for all i (1\r\nle i\r\nle n) C_j(A\u2019) is bitonic for all j (1\r\nle j\r\nle m) An array t (t_1, t_2,\r\nldots, t_k) is called bitonic if it first increases and then decreases.\r\nMore formally: t is bitonic if there exists some position p (1\r\nle p\r\nle k) such that: t_1 < t_2 <\r\nldots < t_p > t_{p+1} >\r\nldots > t_k.Help Koa to find such matrix or to determine that it doesn\u2019t\r\nexist.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf=(int)(2e9);\nconst ll INF=(ll)(5e18);\nconst int N=305;\ntypedef pair<int,int> pii;\n#define mk make_pair\n\nset<pii> st;//1:hang -1lie\nint n,m;\nint bl[N*N],a[N][N],vis[N][N];\nint ans[N][N];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mx=0;\n\t\tfor(int j=1;j<=m;j++) mx=max(mx,a[i][j]);\n\t\tst.insert(mk(mx,1));\n\t\tbl[mx]=1;\n\t}\n\tfor(int j=1;j<=m;j++)\n\t{\n\t\tint mx=0;\n\t\tfor(int i=1;i<=n;i++) mx=max(mx,a[i][j]);\n\t\tst.insert(mk(mx,-1));\n\t\tbl[mx]=1;\n\t}\n\tint hang=1,lie=1,now=1;\n\twhile(!st.empty())\n\t{\n\t\tpii u=*st.begin(); st.erase(u);\n\t\t//cout<<u.first<<\" \"<<u.second<<endl;\n\t\tpii tmp=*st.begin(); \n\t\tif(tmp.first==u.first)\n\t\t{\n\t\t\tst.erase(tmp);\n\t\t\tu.second=2;\n\t\t}\n\t\tvector<int> v;\n\t\tans[hang][lie]=u.first;\n\t\tif(u.second==1)//hang\n\t\t{\n\t\t\tv.clear();\n\t\t\tfor(int i=lie+1;i<=m;i++) \n\t\t\t{\n\t\t\t\twhile(bl[now]) now++;\n\t\t\t\tv.push_back(now); now++;\n\t\t\t}\n\t\t\tfor(int i=m,j=0;i>=lie+1;i--)\n\t\t\t{\n\t\t\t\tans[hang][i]=v[j]; j++;\n\t\t\t}\n\t\t\thang++;\n\t\t}\n\t\telse if(u.second==-1)//lie\n\t\t{\n\t\t\tv.clear();\n\t\t\tfor(int i=hang+1;i<=n;i++)\n\t\t\t{\n\t\t\t\twhile(bl[now]) now++;\n\t\t\t\tv.push_back(now); now++;\n\t\t\t}\n\t\t\tfor(int i=n,j=0;i>=hang+1;i--)\n\t\t\t{\n\t\t\t\tans[i][lie]=v[j]; j++;\n\t\t\t}\n\t\t\tlie++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.clear();\n\t\t\tfor(int i=lie+1;i<=m;i++) \n\t\t\t{\n\t\t\t\twhile(bl[now]) now++;\n\t\t\t\tv.push_back(now); now++;\n\t\t\t}\n\t\t\tfor(int i=m,j=0;i>=lie+1;i--)\n\t\t\t{\n\t\t\t\tans[hang][i]=v[j]; j++;\n\t\t\t}\n\t\t\tv.clear();\n\t\t\tfor(int i=hang+1;i<=n;i++)\n\t\t\t{\n\t\t\t\twhile(bl[now]) now++;\n\t\t\t\tv.push_back(now); now++;\n\t\t\t}\n\t\t\tfor(int i=n,j=0;i>=hang+1;i--)\n\t\t\t{\n\t\t\t\tans[i][lie]=v[j]; j++;\n\t\t\t}\n\t\t\tlie++; hang++;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++) printf(\"%d \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "2800", "interactive": false}