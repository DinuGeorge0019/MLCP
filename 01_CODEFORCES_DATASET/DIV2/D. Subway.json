{"link": "https://codeforces.com//contest/131/problem/D", "problemId": "695", "problem_idx": "D", "shortId": "131D", "contest_number": "131", "problem_submissions": {"F": [904424, 898451, 898852, 898665, 899656, 42410750, 900665, 900877, 900384, 899648, 900915, 901359, 897034, 901848, 900975, 901375, 897608, 902336, 895558, 901701], "E": [904422, 896838, 895727, 896630, 897281, 42410343, 898660, 899049, 899074, 898552, 899102, 899404, 899253, 899170, 899607, 899696, 899911, 897321, 900186, 897365], "D": [904420, 894775, 894348, 894881, 894791, 896588, 897021, 897370, 896846, 897407, 896897, 908176, 904628, 901525, 897622, 897737, 898418, 894267, 898476, 898021, 898664, 894931], "C": [904417, 892960, 891836, 893412, 892695, 893493, 894746, 897077, 895187, 893806, 894995, 895988, 896203, 894856, 902951, 896937, 892903], "B": [904413, 892343, 898130, 892434, 891977, 893039, 892628, 893632, 891827, 892784, 894062, 892290, 894254, 895376, 891900, 893592, 894329, 896307, 891485], "A": [904410, 891551, 891494, 891758, 891408, 891725, 892258, 891411, 891856, 891608, 892187, 891595, 893365, 893186, 891415, 891922, 891657, 895179, 892042]}, "name": "D. Subway", "statement": "A subway scheme, classic for all Berland cities is represented by a set\r\nof stations connected by passages, each of which connects exactly two\r\nstations and does not pass through any others. Besides, in the classic\r\nscheme one can get from any station to any other one along the passages.\r\nThe passages can be used to move in both directions. Between each pair\r\nof stations there is no more than one passage.Berland mathematicians\r\nhave recently proved a theorem that states that any classic scheme has a\r\nringroad. There can be only one ringroad. In other words, in any classic\r\nscheme one can find the only scheme consisting of stations (where any\r\ntwo neighbouring ones are linked by a passage) and this cycle doesn\u2019t\r\ncontain any station more than once.This invention had a powerful social\r\nimpact as now the stations could be compared according to their distance\r\nfrom the ringroad. For example, a citizen could say \"I live in three\r\npassages from the ringroad\" and another one could reply \"you loser, I\r\nlive in one passage from the ringroad\". The Internet soon got filled\r\nwith applications that promised to count the distance from the station\r\nto the ringroad (send a text message to a short number...).The Berland\r\ngovernment decided to put an end to these disturbances and start to\r\ncontrol the situation. You are requested to write a program that can\r\ndetermine the remoteness from the ringroad for each station by the city\r\nsubway scheme.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\nint fa[3010],dep[3010],b[3010],a[6010][2];\nbool cycle[3010];\nbool dfs(int x,int father)\n{\n    fa[x]=father;\n    for (int i=b[x];i;i=a[i][1])\n    {\n        int y=a[i][0];\n        if (y==father)\n            continue;\n        if (fa[y]!=-1)\n        {\n            for (int j=x;j!=y;j=fa[j])\n                cycle[j]=true;\n            cycle[y]=true;\n            return(true);\n        }\n        fa[y]=x;\n        if (dfs(y,x))\n            return(true);\n    }\n    return(false);\n}\nvoid dfs2(int x,int father)\n{\n    for (int i=b[x];i;i=a[i][1])\n    {\n        int y=a[i][0];\n        if (cycle[y] || y==father)\n            continue;\n        dep[y]=dep[x]+1;\n        dfs2(y,x);\n    }\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        a[i][0]=y,a[i][1]=b[x],b[x]=i;\n        a[i+n][0]=x,a[i+n][1]=b[y],b[y]=i+n;\n    }\n    memset(fa,-1,sizeof(fa));\n    dfs(1,0);\n    memset(dep,-1,sizeof(dep));\n    for (int i=1;i<=n;i++)\n        if (cycle[i])\n        {\n            dep[i]=0;\n            dfs2(i,0);\n        }\n    for (int i=1;i<=n;i++)\n        printf(\"%d%c\",dep[i],i==n?'\\n':' ');\n    return(0);\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "1600", "interactive": false}