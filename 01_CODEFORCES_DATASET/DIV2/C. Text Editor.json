{
    "link": "https://codeforces.com//contest/253/problem/C",
    "problemId": "2357",
    "problem_idx": "C",
    "shortId": "253C",
    "contest_number": "253",
    "problem_submissions": {
        "E": [
            2726944,
            2726770,
            2723241,
            2726790,
            2727978,
            2727471,
            2730692,
            2727089,
            2733327
        ],
        "D": [
            2723881,
            2724571,
            2724941,
            2724183,
            2724072,
            2730055,
            2725910,
            2724288,
            2727979,
            2726091,
            2724937,
            2724056,
            2724791,
            2726548,
            2727374,
            2727845,
            2724772,
            2727700,
            2727671
        ],
        "C": [
            2722572,
            2722281,
            2724549,
            2722354,
            2728524,
            2725077,
            2722977,
            2724138,
            2725868,
            2723657,
            2726470,
            2725360,
            2723760,
            2725532,
            2724133,
            2723644,
            2723308,
            2726933,
            2724303,
            2722964
        ],
        "B": [
            2721049,
            2720520,
            2723865,
            2720653,
            2721139,
            2720528,
            2729702,
            2729645,
            2721283,
            2721143,
            2722792,
            2721898,
            2721343,
            2721641,
            2721718,
            2723762,
            2722392,
            2721474,
            2721728,
            2725310,
            2722068,
            2720627
        ],
        "A": [
            2719721,
            2719583,
            2723434,
            2725505,
            2726928,
            2719479,
            2719939,
            2719790,
            2720497,
            2719471,
            2719992,
            2720388,
            2727234,
            2723792,
            2722012,
            2720226,
            2719749,
            2721562,
            2720002,
            2728636
        ]
    },
    "name": "C. Text Editor",
    "statement": "Vasya is pressing the keys on the keyboard reluctantly, squeezing out\r\nhis ideas on the classical epos depicted in Homer\u2019s Odysseus... How can\r\nhe explain to his literature teacher that he isn\u2019t going to become a\r\nwriter? In fact, he is going to become a programmer. So, he would take\r\ngreat pleasure in writing a program, but none in writing a\r\ncomposition.As Vasya was fishing for a sentence in the dark pond of his\r\nimagination, he suddenly wondered: what is the least number of times he\r\nshould push a key to shift the cursor from one position to another\r\none?Let\u2019s describe his question more formally: to type a text, Vasya is\r\nusing the text editor. He has already written lines, the -th line\r\ncontains characters (including spaces). If some line contains\r\ncharacters, then this line overall contains positions where the cursor\r\ncan stand: before some character or after all characters (at the end of\r\nthe line). Thus, the cursor\u2019s position is determined by a pair of\r\nintegers , where is the number of the line and is the cursor\u2019s position\r\nin the line (the positions are indexed starting from one from the\r\nbeginning of the line).Vasya doesn\u2019t use the mouse to move the cursor.\r\nHe uses keys \"Up\", \"Down\", \"Right\" and \"Left\". When he pushes each of\r\nthese keys, the cursor shifts in the needed direction. Let\u2019s assume that\r\nbefore the corresponding key is pressed, the cursor was located in the\r\nposition , then Vasya pushed key: \"Up\": if the cursor was located in the\r\nfirst line (), then it does not move. Otherwise, it moves to the\r\nprevious line (with number ), to the same position. At that, if the\r\nprevious line was short, that is, the cursor couldn\u2019t occupy position\r\nthere, the cursor moves to the last position of the line with number ;\r\n\"Down\": if the cursor was located in the last line (), then it does not\r\nmove. Otherwise, it moves to the next line (with number ), to the same\r\nposition. At that, if the next line was short, that is, the cursor\r\ncouldn\u2019t occupy position there, the cursor moves to the last position of\r\nthe line with number ; \"Right\": if the cursor can move to the right in\r\nthis line (), then it moves to the right (to position ). Otherwise, it\r\nis located at the end of the line and doesn\u2019t move anywhere when Vasya\r\npresses the \"Right\" key; \"Left\": if the cursor can move to the left in\r\nthis line (), then it moves to the left (to position ). Otherwise, it is\r\nlocated at the beginning of the line and doesn\u2019t move anywhere when\r\nVasya presses the \"Left\" key.You\u2019ve got the number of lines in the text\r\nfile and the number of characters, written in each line of this file.\r\nFind the least number of times Vasya should push the keys, described\r\nabove, to shift the cursor from position to position .\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint op[100][100010];\nint queue[10000010];\n\nint main(void)\n{\n    freopen(\"input.txt\",\"rt\",stdin);\n    freopen(\"output.txt\",\"wt\",stdout);\n    int n = 0;\n    int chars[111] = {0};\n    scanf(\"%d\",&n);\n    for(int i = 0;i < n;i++) scanf(\"%d\",&chars[i]);\n    int r1 = 0;\n    int c1 = 0;\n    int r2 = 0;\n    int c2 = 0;\n    scanf(\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n    int ans = 0;\n    r1--; c1--; r2--; c2--;\n    memset(op,0x3F,sizeof(op));\n    int front = 0;\n    int end = 0;\n    op[r1][c1] = 0;\n    queue[end++] = r1*100010+c1;\n    while(front < end)\n    {\n        int tx = queue[front]/100010;\n        int ty = queue[front++]%100010;\n        if(tx == r2 && ty == c2) break;\n        int ta = op[tx][ty];\n        int nx = 0;\n        int ny = 0;\n        if(tx < n-1)\n        {\n            nx = tx+1;\n            ny = min(ty,chars[nx]);\n            if(op[nx][ny] > ta+1)\n            {\n                op[nx][ny] = ta+1;\n                queue[end++] = nx*100010+ny;\n            }\n        }\n        if(tx > 0)\n        {\n            nx = tx-1;\n            ny = min(ty,chars[nx]);\n            if(op[nx][ny] > ta+1)\n            {\n                op[nx][ny] = ta+1;\n                queue[end++] = nx*100010+ny;\n            }\n        }\n        if(ty < chars[tx])\n        {\n            nx = tx;\n            ny = ty+1;\n            if(op[nx][ny] > ta+1)\n            {\n                op[nx][ny] = ta+1;\n                queue[end++] = nx*100010+ny;\n            }\n        }\n        if(ty > 0)\n        {\n            nx = tx;\n            ny = ty-1;\n            if(op[nx][ny] > ta+1)\n            {\n                op[nx][ny] = ta+1;\n                queue[end++] = nx*100010+ny;\n            }\n        }\n    }\n    printf(\"%d\\n\",op[r2][c2]);\n    while(getchar() != EOF);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Text Editor.json",
    "editorial_link": "https://codeforces.com//blog/entry/6073",
    "editorial": "One of the solutions to the problem is breadth-first-search (BFS).\r\nVertices of the graph correspond to all possible pairs (), denoting the\r\nrow and the position of the cursor. Each vertex has at most four arcs\r\nleaving it (these arcs correspond to pressing the buttons). So we need\r\nto find the shortest path from one vertex to the other. There are at\r\nmost vertices and at most arcs. This problem can also be solved with\r\nsome greedy observations.\r\n"
}