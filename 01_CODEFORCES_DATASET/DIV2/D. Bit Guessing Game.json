{
    "link": "https://codeforces.com//contest/1780/problem/D",
    "problemId": "1751018",
    "problem_idx": "D",
    "shortId": "1780D",
    "contest_number": "1780",
    "problem_submissions": {
        "B": [
            190535258,
            190498086,
            190497202,
            190504885,
            190496777,
            190498615,
            190498275,
            190497689,
            190505348,
            190506760,
            190497685,
            190497528,
            190501759,
            190525276,
            190496999,
            190500082,
            190500545,
            190502064,
            190519356,
            190503567
        ],
        "D": [
            190533820,
            190533379,
            190523919,
            190522645,
            190511882,
            190524576,
            190524419,
            190528918,
            190542496,
            190522478,
            190522893,
            190531155,
            190529105,
            190551665,
            190525303,
            190533171,
            190519573,
            190527940,
            190532781
        ],
        "A": [
            190529026,
            190496355,
            190496107,
            190513521,
            190496187,
            190496359,
            190496570,
            190496143,
            190505208,
            190497564,
            190496513,
            190499602,
            190498096,
            190517182,
            190496208,
            190496566,
            190497285,
            190498375,
            190517649,
            190499548
        ],
        "E": [
            190527049,
            190548713,
            190543230,
            190508008,
            190529273,
            190540087,
            190536127,
            190560235,
            190552095,
            190550324,
            190520594,
            190570059,
            190569996,
            190559193,
            190547102,
            190544599,
            190538906,
            190514425,
            190551048
        ],
        "F": [
            190517191,
            190517201,
            190529995,
            190532767,
            190538925,
            190546993,
            190547096,
            190541658,
            190557282,
            190555255,
            190536356,
            190536733,
            190551167,
            190514623,
            190538687,
            190557956,
            191454311,
            190563201,
            190556137,
            190561572
        ],
        "G": [
            190503495,
            190523768,
            190518506,
            190545041,
            190560974,
            190562076,
            190559215,
            190552122,
            190532760,
            190564681,
            190527891,
            190541029,
            190559585,
            190602710,
            190635446,
            190533062
        ]
    },
    "name": "D. Bit Guessing Game",
    "statement": "Kira has a hidden positive integer n, and Hayato needs to guess\r\nit.Initially, Kira gives Hayato the value\r\nmathrm{cnt} the number of unit bits in the binary notation of n. To\r\nguess n, Hayato can only do operations of one kind: choose an integer x\r\nand subtract it from n. Note that after each operation, the number n .\r\nKira doesn\u2019t like bad requests, so if Hayato tries to subtract a number\r\nx greater than n, he will lose to Kira. After each operation, Kira gives\r\nHayato the updated value\r\nmathrm{cnt} the number of unit bits in the binary notation of the\r\nupdated value of n.Kira doesn\u2019t have much patience, so Hayato must guess\r\nthe value of n after no more than 30 operations.Since Hayato is in\r\nelementary school, he asks for your help. Write a program that guesses\r\nthe number n. Kira is an honest person, so he chooses the initial number\r\nn before all operations and change it afterward.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int cnt;\n    cin >> cnt;\n    int n = 0, pw = 1, inc = 0;\n    while (cnt) {\n        cout << \"- \" << pw + inc << endl;\n        int ncnt;\n        cin >> ncnt;\n        if (ncnt == cnt - 1) {\n            n += pw;\n            pw *= 2;\n        } else {\n            int b = ncnt - cnt + 1;\n            n += (1 << b) * pw;\n            ncnt = cnt - 1;\n            inc = ((1 << b) - 1) * pw;\n        }\n        cnt = ncnt;\n    }\n    cout << \"! \" << n << endl;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Bit Guessing Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/111841",
    "editorial": "TutorialThere are two similar solutions to this problem, we will tell\r\nyou both. Tutorial (AndreyPavlov)Subtract . What can we say now about\r\nthe number of units at the beginning of the binary notation of a number?\r\nThere are exactly , where is the number of unit bits after subtracting\r\nthe unit, and is before subtracting. Now we subtract them, for this we\r\nneed to subtract the number and continue the algorithm. But such an\r\nalgorithm makes at worst requests. To save queries, note that we know\r\nthe number of units after we remove the units from the beginning,\r\ntherefore it is useless to make another request for this. Then at the\r\nsame time, as we remove the units from the beginning, we will\r\nimmediately subtract the unit. As a result, there will be absolutely no\r\nmore than operations, where is the initial number of single bits in the\r\nrecord of the number . This number does not exceed , in turn, does not\r\nexceed 30, which fits into the restrictions. Tutorial (qualdoom)Let be\r\nthe desired number , and be the initial number of bits in the number .\r\nLet\u00e2\u0080\u0099s subtract the powers of two : , while it will not become 0. We will\r\nsupport the flag whether there was a bit transfer to when subtracting\r\nany power of two. Suppose we subtracted at the th step and the number of\r\nbits became equal to , and before the subtraction was , then consider\r\ntwo cases.1) , then bit was included in at the th step, and if , then we\r\nadd to , since there was no bit transfer, which means bit k is also in\r\nthe original number, and subtract from . If , then we added this bit\r\nduring previous operations, and it does not need to be taken into\r\naccount.2) , then we know that the number of bits has not decreased,\r\nalso that in the number there was such a bit that , and at the same time\r\nthe bit is in . Moreover, . So . Let\u00e2\u0080\u0099s add to the answer, subtract from\r\nand assign the flag the value , since there was a bit transfer.Thus, we\r\nfound the initial number , which is equal to , and also made no more\r\nthan queries, since . Thus, the solution spends no more than 30\r\nrequests, which fits into the limitations of the task.\r\n"
}