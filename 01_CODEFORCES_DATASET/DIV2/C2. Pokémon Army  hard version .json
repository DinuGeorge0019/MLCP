{"link": "https://codeforces.com//contest/1420/problem/C2", "problemId": "735852", "problem_idx": "C2", "shortId": "1420C2", "contest_number": "1420", "problem_submissions": {"E": [93699813, 93707260, 93695968, 93707648, 93705681, 93709151, 93715432, 93730964, 93708580, 93714548, 93716147, 93715550, 93736542, 93717442, 93710855, 93715981, 93697763, 93711132, 93762507], "D": [93676952, 93680084, 93692950, 93670877, 93690670, 93693136, 93730971, 93710781, 93702357, 93681953, 93695104, 93691378, 93699248, 93698024, 93665582, 93680861, 93671056, 93667892, 93675623], "C2": [93674880, 93671167, 93692067, 93741708, 93681627, 93659881, 93679255, 93686831, 93676610, 93670869, 93669089, 93684016, 93707465, 93690589, 93710188, 93716769, 93662876, 93683514, 93665601], "C1": [93658399, 93663408, 93681461, 93660059, 93679792, 93666232, 93663489, 93671318, 93669597, 93684191, 93665522, 93690460, 93659663, 93716842, 93670252, 93662639, 93658224, 93665421], "B": [93652358, 93659482, 93658665, 93669626, 93664158, 93660524, 93657692, 93655021, 93655235, 93677044, 93656189, 93674995, 93653603, 93704106, 93656350, 93653174, 93653888, 93653561], "A": [93651966, 93651886, 93654562, 93660205, 93652727, 93651674, 93651632, 93674907, 93652710, 93659767, 93651617, 93706046, 93651985, 93651435, 93651489, 93651367]}, "name": "C2. Pok\u00e9mon Army  hard version ", "statement": "Pikachu is a cute and friendly pok mon living in the wild pikachu\r\nherd.But it has become known recently that infamous team R wanted to\r\nsteal all these pok mon! Pok mon trainer Andrew decided to help Pikachu\r\nto build a pok mon army to resist.First, Andrew counted all the pok mon\r\nthere were exactly n pikachu. The strength of the i-th pok mon is equal\r\nto a_i, and all these numbers are distinct.As an army, Andrew can choose\r\nany non-empty subsequence of pokemons. In other words, Andrew chooses\r\nsome array b from k indices such that 1\r\nle b_1 < b_2 <\r\ndots < b_k\r\nle n, and his army will consist of pok mons with forces a_{b_1},\r\na_{b_2},\r\ndots, a_{b_k}.The strength of the army is equal to the alternating sum\r\nof elements of the subsequence; that is, a_{b_1} - a_{b_2} + a_{b_3} -\r\na_{b_4} +\r\ndots.Andrew is experimenting with pok mon order. He performs q\r\noperations. In i-th operation Andrew swaps l_i-th and r_i-th pok\r\nmon.Andrew wants to know the maximal stregth of the army he can achieve\r\nwith the initial pok mon placement. He also needs to know the maximal\r\nstrength after each operation.Help Andrew and the pok mon, or team R\r\nwill realize their tricky plan!\r\n", "solutions": ["#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 3e5;\nint a[mxN+3];\nint n,q;\n\nstruct SgTNode\n{\n\tllong f[2],g[2];\n} sgt[mxN*4+3];\nvoid pushup(int u)\n{\n\tsgt[u].f[0] = max(sgt[u<<1].f[0]+sgt[u<<1|1].f[0],sgt[u<<1].f[1]-sgt[u<<1|1].g[1]);\n\tsgt[u].f[1] = max(sgt[u<<1].f[0]+sgt[u<<1|1].f[1],sgt[u<<1].f[1]-sgt[u<<1|1].g[0]);\n\tsgt[u].g[0] = min(sgt[u<<1].g[0]+sgt[u<<1|1].g[0],sgt[u<<1].g[1]-sgt[u<<1|1].f[1]);\n\tsgt[u].g[1] = min(sgt[u<<1].g[0]+sgt[u<<1|1].g[1],sgt[u<<1].g[1]-sgt[u<<1|1].f[0]);\n}\nvoid build(int u,int le,int ri)\n{\n\tif(le==ri) {sgt[u].f[0] = 0ll,sgt[u].f[1] = a[le],sgt[u].g[0] = 0ll,sgt[u].g[1] = a[le]; return;}\n\tint mid = (le+ri)>>1;\n\tbuild(u<<1,le,mid); build(u<<1|1,mid+1,ri);\n\tpushup(u);\n}\nvoid modify(int u,int le,int ri,int pos,llong x)\n{\n\tif(le==ri) {sgt[u].f[0] = 0ll,sgt[u].f[1] = x,sgt[u].g[0] = 0ll,sgt[u].g[1] = x; return;}\n\tint mid = (le+ri)>>1;\n\tif(pos<=mid) {modify(u<<1,le,mid,pos,x);} else {modify(u<<1|1,mid+1,ri,pos,x);}\n\tpushup(u);\n}\n\nint main()\n{\n\tint T = read(); while(T--)\n\t{\n\t\tn = read(),q = read(); for(int i=1; i<=n; i++) a[i] = read();\n\t\tbuild(1,1,n);\n\t\tprintf(\"%lld\\n\",max(sgt[1].f[0],sgt[1].f[1]));\n\t\twhile(q--)\n\t\t{\n\t\t\tint l = read(),r = read(); swap(a[l],a[r]);\n\t\t\tmodify(1,1,n,l,a[l]); modify(1,1,n,r,a[r]);\n\t\t\tprintf(\"%lld\\n\",max(sgt[1].f[0],sgt[1].f[1]));\n\t\t}\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dp", "greedy", "implementation"], "dificulty": "2100", "interactive": false}