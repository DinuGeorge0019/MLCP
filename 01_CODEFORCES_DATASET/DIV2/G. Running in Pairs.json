{
    "link": "https://codeforces.com//contest/1244/problem/G",
    "problemId": "438886",
    "problem_idx": "G",
    "shortId": "1244G",
    "contest_number": "1244",
    "problem_submissions": {
        "E": [
            62487832,
            62480584,
            62471612,
            62475861,
            62486535,
            62479379,
            62488595,
            62479897,
            62486004,
            62494290,
            62482838,
            62489756,
            62484611,
            62499649,
            62484119,
            62485010,
            62484457,
            62485159,
            62483197
        ],
        "D": [
            62485326,
            62477683,
            62472795,
            62474275,
            62479070,
            62488986,
            62484645,
            62476151,
            62481028,
            62481710,
            62472497,
            62492732,
            62480440,
            62477599,
            62480225,
            62481677,
            62477177,
            62480820,
            62477275
        ],
        "G": [
            62480107,
            62491796,
            62483655,
            62495208,
            62499859,
            62498484,
            62497339,
            62483129,
            62500589,
            62490894,
            62499284,
            62480915,
            62501144,
            62496112,
            62574872,
            62510517
        ],
        "F": [
            62476907,
            62486766,
            62497660,
            62497231,
            62492999,
            62493234,
            62492928,
            62488841,
            62496876,
            62489625,
            62495061,
            62486153,
            62494792,
            62489424,
            62493134,
            62492962,
            62496077,
            62497856,
            62496551
        ],
        "C": [
            62471680,
            62473970,
            62477877,
            62474334,
            62473816,
            62473208,
            62512963,
            62473668,
            62477041,
            62495125,
            62513108,
            62474572,
            62476360,
            62471677,
            62473875,
            62478860
        ],
        "B": [
            62467959,
            62468158,
            62464148,
            62469867,
            62471265,
            62468289,
            62470934,
            62468364,
            62468024,
            62466207,
            62466240,
            62496223,
            62469290,
            62471104,
            62469292,
            62469059,
            62467915,
            62469090,
            62470225
        ],
        "A": [
            62466123,
            62464793,
            62464086,
            62466602,
            62465923,
            62464447,
            62464989,
            62659829,
            62464905,
            62464254,
            62465585,
            62464807,
            62497112,
            62464806,
            62468732,
            62464268,
            62464707,
            62464160,
            62464768,
            62464533
        ]
    },
    "name": "G. Running in Pairs",
    "statement": "Demonstrative competitions will be held in the run-up to the 20NN\r\nBerlatov Olympic Games. Today is the day for the running\r\ncompetition!Berlatov team consists of 2n runners which are placed on two\r\nrunning tracks; n runners are placed on each track. The runners are\r\nnumbered from 1 to n on each track. The runner with number i runs\r\nthrough the entire track in i seconds.The competition is held as\r\nfollows: first runners on both tracks start running at the same time;\r\nwhen the slower of them arrives at the end of the track, second runners\r\non both tracks start running, and everyone waits until the slower of\r\nthem finishes running, and so on, until all n pairs run through the\r\ntrack.The organizers want the run to be as long as possible, but if it\r\nlasts for more than k seconds, the crowd will get bored. As the coach of\r\nthe team, you may choose any order in which the runners are arranged on\r\neach track (but you can\u2019t change the number of runners on each track or\r\nswap runners between different tracks).You have to choose the order of\r\nrunners on each track so that the duration of the competition is as long\r\nas possible, but does not exceed k seconds.Formally, you want to find\r\ntwo permutations p and q (both consisting of n elements) such that sum =\r\nsum\r\nlimits_{i=1}^{n} max(p_i, q_i) is maximum possible, but does not exceed\r\nk. If there is no such pair, report about it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1000010], n;\nlong long k;\nint main() {\n    cin >> n >> k;\n    if(1ll * n * (n + 1) / 2 > k) return puts(\"-1\"), 0;\n    long long _max = 0;\n    for(int i = 1; i <= n; i++) _max += max(i, n - i + 1);\n    if(_max < k) k = _max;\n    cout << k << endl;\n    for(int i = 1; i <= n; i++) ans[i] = i, printf(\"%d%c\", i, \" \\n\"[i == n]);\n    k -= 1ll * n * (n + 1) / 2;\n    for(int i = 1; ; i++) {\n        int now = n - 2 * i + 1;\n        if(k <= now || k == 0) {\n            swap(ans[i], ans[i + k]);\n            for(int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n            return 0;\n        }\n        else k -= now, swap(ans[i], ans[n - i + 1]);\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Running in Pairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/70553",
    "editorial": "First of all, let\u00e2\u0080\u0099s understand which values of we can obtain at all.\r\nObviously, the minimum possible value of is . The maximum possible value\r\nof is . We can obtain possible value of between and and we will show how\r\nto do it below.If then the answer is (and this is the only such case).\r\nOtherwise, the answer exists and we need to construct it somehow.\r\nFirstly, suppose that the first permutation is identic permutation ()\r\nand the only permutation we change is the second one. Initially, the\r\nsecond permutation is also identic. Now we have and we need to change it\r\nto or to the maximum possible number not greater than . To do that,\r\nlet\u00e2\u0080\u0099s learn how to increase by one. Let\u00e2\u0080\u0099s see what will happen if we\r\nswap and . Then the value of will increase by one. If we swap and then\r\nthe value of will increase by , and so on. If we swap and then the value\r\nof will increase by . So, the following constructive algorithm comes to\r\nmind: let\u00e2\u0080\u0099s carry the current segment of permutation we can change (it\r\nis always segment because after some swaps some leftmost and rightmost\r\nelements cannot increase our answer because they\u00e2\u0080\u0099re will be already\r\nplaced optimally) and the value we need to add to to obtain the maximum\r\npossible sum not greater than . Initially . Now let\u00e2\u0080\u0099s understand the\r\nmaximum value by which we can increase the value of . Now it is . If\r\nthis value is greater than then let\u00e2\u0080\u0099s swap and , and break the cycle (\r\nis the second permutation). Otherwise, let\u00e2\u0080\u0099s swap and , decrease by and\r\nset . If at some moment becomes greater than or equal to then break the\r\ncycle.Now we got the second permutation with the maximum possible value\r\nof not greater than , we can calculate the numeric answer (or print ),\r\nprint identic permutation and the permutation .\r\n"
}