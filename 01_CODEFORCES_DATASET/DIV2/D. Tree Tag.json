{
    "link": "https://codeforces.com//contest/1405/problem/D",
    "problemId": "718469",
    "problem_idx": "D",
    "shortId": "1405D",
    "contest_number": "1405",
    "problem_submissions": {
        "E": [
            92059741,
            92058133,
            92062156,
            92060968,
            92062924,
            92067408,
            92066292,
            92068112,
            92062237,
            92066773,
            92068775,
            92072009,
            92069079,
            92061737,
            92074033,
            92066427,
            92074374,
            92065015
        ],
        "D": [
            92042902,
            92049954,
            92043014,
            92049578,
            92048487,
            92047077,
            92051858,
            92049539,
            92053114,
            92052985,
            92055807,
            92047137,
            92054061,
            92071019,
            92059215,
            92073091,
            92059129,
            92044558,
            92094648,
            92049569
        ],
        "C": [
            92035786,
            92037182,
            92033713,
            92034576,
            92036286,
            92037578,
            92036561,
            92039390,
            92037184,
            92039374,
            92039602,
            92033076,
            92045285,
            92037821,
            92043997,
            92035004,
            92050607,
            92038515,
            92037672,
            92034975
        ],
        "B": [
            92025229,
            92029135,
            92026910,
            92025507,
            92028947,
            92031236,
            92029110,
            92028870,
            92041377,
            92032881,
            92030734,
            92026455,
            92038256,
            92044134,
            92038934,
            92028794,
            92045596,
            92031141,
            92026747,
            92029131
        ],
        "A": [
            92023093,
            92025469,
            92023871,
            92023042,
            92024363,
            92027769,
            92023712,
            92023043,
            92039754,
            92024522,
            92027108,
            92023087,
            92026674,
            92024071,
            92047223,
            92036791,
            92039497,
            92023146,
            92023754
        ]
    },
    "name": "D. Tree Tag",
    "statement": "Alice and Bob are playing a fun game of tree tag.The game is played on a\r\ntree of n vertices numbered from 1 to n. Recall that a tree on n\r\nvertices is an undirected, connected graph with n-1 edges.Initially,\r\nAlice is located at vertex a, and Bob at vertex b. They take turns\r\nalternately, and Alice makes the first move. In a move, Alice can jump\r\nto a vertex with distance da from the current vertex. And in a move, Bob\r\ncan jump to a vertex with distance db from the current vertex. The\r\ndistance between two vertices is defined as the number of edges on the\r\nunique simple path between them. In particular, either player is allowed\r\nto stay at the same vertex in a move. Note that when performing a move,\r\na player only occupies the starting and ending vertices of their move,\r\nnot the vertices between them.If after at most 10^{100} moves, Alice and\r\nBob occupy the same vertex, then Alice is declared the winner.\r\nOtherwise, Bob wins.Determine the winner if both players play optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define fef(i,a,b) for(ll i=a;i<=b;i++)\n#define rer(i,a,b) for(ll i=b;i>=a;i--)\n#define wew while(true)\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define FILE_IN \"cseq.inp\"\n#define FILE_OUT \"cseq.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n#define fio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define nfio cin.tie(0);cout.tie(0)\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define ord(a,b,c) ((a>=b)and(b>=c))\n#define MOD (ll(1000000007))\n#define MAX 300001\n#define mag 320\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define X first\n#define Y second\n#define pow2(x) (ll(1)<<x)\n#define pii pair<int,int>\n#define piii pair<int,pii>\n#define For(i,__,___) for(int i=__;i<=___;i++)\n#define Rep(i,__,___) for(int i=__;i>=___;i--)\n#define ordered_set tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update>\n#define endl \"\\n\"\n#define bi BigInt\ntypedef long long ll;\n//---------END-------//\nconst int maxn = 1e5 + 17;\n\nint n;\nvector <int> adj[maxn];\nint height[maxn];\n\nvoid dfs(int x, int par = 0){\n    if (par != 0){\n        height[x] = height[par] + 1;\n    }\n    for (auto y: adj[x]){\n        if (y != par){\n            dfs(y, x);\n        }\n    }\n}\n\nint main(){\n    nfio;\n    int t;\n    cin >> t;\n    while (t--){\n        int a, b, da, db;\n        cin >> n >> a >> b >> da >> db;\n        For(i, 1, n){\n            adj[i].clear();\n            height[i] = 0;\n        }\n        For(i, 1, n - 1){\n            int x, y;\n            cin >> x >> y;\n            adj[x].push_back(y);\n            adj[y].push_back(x);\n        }\n        int maxval, idxmaxval;\n        For(i, 1, n){\n            height[i] = 0;\n        }\n        dfs(1);\n        maxval = -1;\n        For(i, 1, n){\n            if (height[i] > maxval){\n                maxval = height[i];\n                idxmaxval = i;\n            }\n        }\n        For(i, 1, n){\n            height[i] = 0;\n        }\n        dfs(idxmaxval);\n        maxval = -1;\n        For(i, 1, n){\n            if (height[i] > maxval){\n                maxval = height[i];\n                idxmaxval = i;\n            }\n        }\n        if (da * 2 >= min(db, maxval)){\n            cout << \"Alice\\n\";\n            continue;\n        }\n        For(i, 1, n){\n            height[i] = 0;\n        }\n        dfs(a);\n        if (height[b] <= da){\n            cout << \"Alice\\n\";\n        }\n        else{\n            cout << \"Bob\\n\";\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "games",
        "strings",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tree Tag.json",
    "editorial_link": "https://codeforces.com//blog/entry/82366",
    "editorial": "Letâs consider several cases independently.Unsurprisingly, Alice wins in\r\nthis case by tagging Bob on the first move.Here, the diameter of a tree\r\nis defined as the length of the longest simple path.In this case, Alice\r\ncan move to a center of the tree. Once Alice is there, it doesnât matter\r\nwhere Bob is, since Alice can reach any vertex in the tree in just one\r\nmove, winning the game.In this case, letâs describe a strategy for Bob\r\nto win. Because we are not in case 1, Bob will not lose before his first\r\nmove. Then it is sufficient to show that Bob can always end his turn\r\nwith distance greater than from Alice.Since we are not in case 2, there\r\nis at least one vertex with distance at least from Alice. If Bob is at\r\nsuch a vertex at the start of his turn, he should simply stay there.\r\nOtherwise, there is some vertex with . Then , so Bob can jump to on his\r\nturn.In this case, Aliceâs strategy will be to capture Bob whenever\r\npossible or move one vertex closer to Bob otherwise. Letâs prove that\r\nAlice will win in a finite number of moves with this strategy.Letâs root\r\nthe tree at . Bob is located in some subtree of , say with vertices.\r\nAlice moves one vertex deeper, decreasing Bobâs subtree size by at least\r\none vertex. Since , Bob cannot move to another subtree without being\r\nimmediately captured, so Bob must stay in this shrinking subtree until\r\nhe meets his inevitable defeat.The only non-trivial part in the\r\nimplementation is checking for cases and . Case is simply checked with\r\nDFS. Case 2 only requires computing the diameter of the tree, which is a\r\nstandard problem.Complexity is .\r\n",
    "hint": []
}