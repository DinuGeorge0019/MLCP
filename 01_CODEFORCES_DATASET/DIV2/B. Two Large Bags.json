{
    "link": "https://codeforces.com//contest/2067/problem/B",
    "problemId": "3199296",
    "problem_idx": "B",
    "shortId": "2067B",
    "contest_number": "2067",
    "problem_submissions": {
        "F": [
            305685907,
            305692347,
            305698935,
            305692774,
            305676497,
            305698856,
            306077498,
            305705678,
            305756151,
            305704889
        ],
        "E": [
            305658599,
            305672236,
            305683533,
            305683773,
            305656801,
            305645614,
            305696470,
            305667416,
            305664383,
            305673487,
            305670822,
            305677487,
            305670853,
            305673781,
            305671527,
            305669540,
            305677992,
            305669569
        ],
        "D": [
            305649366,
            305681166,
            305653626,
            305674453,
            305643643,
            305729660,
            305688166,
            305650701,
            305653886,
            305650207,
            305654910,
            305651908,
            305655288,
            305746455,
            305655141,
            305660113,
            305659896,
            305656329,
            305714910,
            305658443
        ],
        "C": [
            305636369,
            305648878,
            305666557,
            305665235,
            305625887,
            305647363,
            305654112,
            305631231,
            305632643,
            305629967,
            305634943,
            305636497,
            305638128,
            305637135,
            305643511,
            305643488,
            305640674,
            305635570
        ],
        "B": [
            305619994,
            305628659,
            305625583,
            305654171,
            305618751,
            305619632,
            305656230,
            305622837,
            305619493,
            305623632,
            305626730,
            305624964,
            305625007,
            305622467,
            305622926,
            305630860,
            305620471,
            305624035
        ],
        "A": [
            305614513,
            305615491,
            305614195,
            305613169,
            305612940,
            305612785,
            305651426,
            305615731,
            305613408,
            305616051,
            305615564,
            305614161,
            305613236,
            305614353,
            305613295,
            305614069,
            305612838,
            305613240
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139415?locale=en",
    "editorial": "Note that when a number goes into the second bag, it remains unchanged\r\nthere until the end of the entire process: our operations cannot\r\ninteract with this number in any way.Therefore, every time we send a\r\nnumber to the second bag, we must keep in mind that an equal number must\r\nremain in the first bag by the end of the operations if we want to\r\nequalize the contents of the bags. We will call this equal number in the\r\nfirst bag \"blocked\": as no operations should be performed with it\r\nanymore.Letâ€™s sort the array: .The first action we will take: sending\r\none of the numbers to the second bag, since the second bag is empty at\r\nthe beginning of the operations, which means the second operation is not\r\navailable.We will prove that at some point we will definitely want to\r\nsend a number equal to to the second bag. Proof by contradiction.\r\nSuppose we never do this. Then all the numbers in the second bag, at the\r\nend of the operations, will be . And the number will remain in the first\r\nbag, which cannot be increased if we never sent to the second bag. Thus,\r\nthe contents of the bags will never be equal if we do not send the\r\nnumber to the second bag. Therefore, during the operations, we must do\r\nthis. And we can do this as the first operation since operations with\r\nnumbers do not interact with in any case.Alright, our first move:\r\ntransfer to the second bag. Now we need to \"block\" one copy of the\r\nnumber in the first bag and not use it in further operations. Therefore,\r\nif , we instantly lose. Otherwise, we fix in the first bag and in the\r\nsecond bag.And we return to the original problem, but now with the\r\nnumbers . However, now we have the number in the second bag. This means\r\nthat now, perhaps, the first action should not be to transfer the\r\nminimum to the second bag, but to somehow use the second operation.It\r\nturns out that it is always optimal to use the second operation when\r\npossible, not counting the \"blocked\" numbers. That is, to increase all\r\nequal numbers in the first bag by one. And then proceed to the same\r\nproblem, but with a reduced .Why is this so? Suppose we leave some equal\r\nnumbers in the first bag without increasing them. Then, by the same\r\nlogic, we must transfer one of them to the second bag, blocking the\r\nequal number in the first bag. But the same could be done if we\r\nincreased both numbers by , they would still be equal, and there would\r\nstill be the option to transfer one of them to the second bag and block\r\nthe equal one in the first. Moreover, the number equal to is already in\r\nthe second bag, so adding a second copy does not expand the arsenal of\r\npossible operations in any way. Therefore, it is never worse to add one\r\nto all remaining numbers. And proceed to the problem with the array ,\r\nwhere all numbers are , which can already be solved similarly.A naive\r\nsimulation of this process takes , but, of course, it can be handled in\r\nwithout much effort, and if we sort the array using counting sort, it\r\ncan be done in altogether.\r\n",
    "name": "B. Two Large Bags",
    "statement": "You have two large bags of numbers. Initially, the first bag contains n\r\nnumbers: a_1, a_2,\r\nldots, a_n, while the second bag is empty. You are allowed to perform\r\nthe following operations: Choose any number from the first bag and move\r\nit to the second bag. Choose a number from the first bag that is also\r\npresent in the second bag and increase it by one.You can perform an\r\nunlimited number of operations of both types, in any order. Is it\r\npossible to make the contents of the first and second bags identical?\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Two Large Bags.json",
    "hint": []
}