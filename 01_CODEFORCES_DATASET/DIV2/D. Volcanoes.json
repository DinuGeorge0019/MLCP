{"link": "https://codeforces.com//contest/384/problem/D", "problemId": "5720", "problem_idx": "D", "shortId": "384D", "contest_number": "384", "problem_submissions": {"E": [5754820, 5756457, 5757218, 5768768, 5754973, 5757082, 5757773, 5753824, 5757669, 5759993, 5759984, 5759937], "C": [5752253, 5751497, 5752881, 5756887, 5754090, 5753464, 5757534, 5753590, 5750204, 5750062, 5751623, 5750722, 5749880, 5751415, 5751385, 5750837, 5751269, 5751529, 5751672, 5751983], "B": [5748010, 5749890, 5748064, 5751405, 5751229, 5751814, 5754578, 5753247, 5749239, 5750952, 5748962, 5749250, 5750859, 5749807, 5750164, 5749512, 5750591, 5750157, 5750184, 5749558], "A": [5747255, 5747392, 5747271, 5747721, 5748251, 5749148, 5747297, 5749334, 5748038, 5747882, 5747312, 5747613, 5747325, 5747593, 5747897, 5747709, 5747419, 5747633, 5747362, 5747257], "D": [5759668, 5766263]}, "name": "D. Volcanoes", "statement": "Iahub got lost in a very big desert. The desert can be represented as a\r\nsquare matrix, where each cell is a zone of the desert. The cell\r\nrepresents the cell at row and column . Iahub can go from one cell only\r\ndown or right, that is to cells or . Also, there are cells that are\r\noccupied by volcanoes, which Iahub cannot enter. Iahub is initially at\r\ncell and he needs to travel to cell . Knowing that Iahub needs second to\r\ntravel from one cell to another, find the minimum time in which he can\r\narrive in cell .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> inline void checkMin(T &a, T b) { if(b<a) a=b; }\ntemplate<typename T> inline void checkMax(T &a, T b) { if(a<b) a=b; }\n#define X first\n#define Y second\n#define MP make_pair\n#define PB push_back\n#define SZ(c) int((c).size())\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for (int i=0;i<int(n);++i)\ntypedef long long lint;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nint n, m, x, y;\nmap<int, set<int>> row, col;\nqueue<PII> q;\n\ninline void relax_col(int x, int y) {\n  if (!col.count(y)) return;\n  auto iter = col[y].upper_bound(x);\n  if (iter == col[y].begin()) return;\n  --iter;\n  while (true) {\n    q.push(MP(*iter, y));\n    if (iter == col[y].begin()) {\n      col[y].erase(iter);\n      break;\n    }\n    auto jter = iter;\n    --jter;\n    if (row.count(*iter)) row[*iter].erase(y);\n    col[y].erase(iter);\n    iter = jter;\n  }\n  if (col[y].empty()) col.erase(y);\n}\n\ninline void relax_row(int x, int y) {\n  if (!row.count(x)) return;\n  auto iter = row[x].lower_bound(y);\n  for (; iter != row[x].end(); iter = row[x].erase(iter)) {\n    q.push(MP(x, *iter));\n    if (col.count(*iter)) col[*iter].erase(x);\n  }\n  if (row[x].empty()) row.erase(x);\n}\n\nbool check() {\n  REP (i, m) {\n    scanf(\"%d%d\", &x, &y);\n    if (x == 1 || y == n) {\n      q.push(MP(x, y));\n    } else {\n      row[x].insert(y);\n      col[y].insert(x);\n    }\n  }\n\n  while (!q.empty()) {\n    int x = q.front().X, y = q.front().Y;\n    if (x == n || y == 1) return false;\n    q.pop();\n    relax_row(x + 1, y - 1);\n    relax_col(x + 1, y - 1);\n  }\n  return true;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  cout << (check() ? 2LL * (n - 1) : -1) << \"\\n\";\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "2500", "interactive": false}