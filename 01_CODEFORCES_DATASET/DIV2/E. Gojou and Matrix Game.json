{
    "link": "https://codeforces.com//contest/1658/problem/E",
    "problemId": "1344627",
    "problem_idx": "E",
    "shortId": "1658E",
    "contest_number": "1658",
    "problem_submissions": {
        "E": [
            151138530,
            151146869,
            151142274,
            151156891,
            151144475,
            151131245,
            151198774,
            151154302,
            151144731,
            151157692,
            151159508,
            151140462,
            151148647,
            151219181,
            151219025,
            151218886,
            151218748,
            151155148,
            152719328,
            151158378,
            151155247,
            151203772,
            151170614,
            151170291,
            151155048
        ],
        "F": [
            151130100,
            151137469,
            151160433,
            151144944,
            151156580,
            151159798,
            151232291,
            151153413,
            151160992,
            151158393,
            151217808,
            152719401,
            151235290,
            152865004
        ],
        "D2": [
            151123118,
            151134040,
            151133854,
            151166091,
            151125130,
            151122133,
            151139222,
            151137227,
            151134065,
            151132282,
            151133698,
            151133407,
            151162997,
            151131356,
            151134494,
            151138728,
            151139132,
            151136153,
            151141865
        ],
        "D1": [
            151120822,
            151134118,
            151121251,
            151137456,
            151136457,
            151124968,
            151116539,
            151125380,
            151137042,
            151133981,
            151132184,
            151133795,
            151129157,
            151129385,
            151111426,
            151134591,
            151138886,
            151137815,
            151136213,
            151141775
        ],
        "C": [
            151112073,
            151128253,
            151116864,
            151133478,
            151123922,
            151138412,
            151133817,
            151115900,
            151129938,
            151123515,
            151127137,
            151121616,
            151119175,
            151124585,
            151140674,
            151128907,
            151118670,
            151122285,
            151130110,
            151124708
        ],
        "A": [
            151108745,
            151108766,
            151108093,
            151108539,
            151109707,
            151108138,
            151108257,
            151108228,
            151115578,
            151108352,
            151109887,
            151109318,
            151108285,
            151118389,
            151117355,
            151113770,
            151108678,
            151108356,
            151114275,
            151108304
        ],
        "B": [
            151108090,
            151111195,
            151109084,
            151117990,
            151113182,
            151110666,
            151109661,
            151112815,
            151110325,
            151119421,
            151112382,
            151112621,
            151125884,
            151123923,
            151121603,
            151111889,
            151111865,
            151121448,
            151110901
        ]
    },
    "name": "E. Gojou and Matrix Game",
    "statement": "Marin feels exhausted after a long day of cosplay, so Gojou invites her\r\nto play a game!Marin and Gojou take turns to place one of their tokens\r\non an n\r\ntimes n grid with Marin starting first. There are some restrictions and\r\nallowances on where to place tokens: Apart from the first move, the\r\ntoken placed by a player must be more than Manhattan distance k away\r\nfrom the previous token placed on the matrix. In other words, if a\r\nplayer places a token at (x_1, y_1), then the token placed in the next\r\nmove must be in a cell (x_2, y_2) satisfying |x_2 - x_1| + |y_2 - y_1| >\r\nk. Apart from the previous restriction, a token can be placed anywhere\r\non the matrix, . Whenever a player places a token on cell (x, y), that\r\nplayer gets v_{x,\r\ny} points. All values of v on the grid are . You still get points from a\r\ncell even if tokens were already placed onto the cell. The game finishes\r\nwhen each player makes 10^{100} moves.Marin and Gojou will play n^2\r\ngames. For each cell of the grid, there will be exactly one game where\r\nMarin places a token on that cell on her first move. Please answer for\r\neach game, if Marin and Gojou play optimally (after Marin\u2019s first move),\r\nwho will have more points at the end? Or will the game end in a draw\r\n(both players have the same points at the end)?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nvector <pair<int,int> > v;\nint c[2005][2005];\npair <int,int> a[4000005];\nchar ans[2005][2005];\ninline int D(int x,int y)\n{\n\treturn max(x,y)-min(x,y);\n}\ninline int dis(pair<int,int> a,pair<int,int> b)\n{\n\treturn D(a.first,b.first)+D(a.second,b.second);\n}\ninline void rebuild()\n{\n\tvector <pair<int,int> > V;\n\tpair <int,int> mx;\n\tfor(auto t:v) if(t.first+t.second>mx.first+mx.second) mx=t;\n\tV.push_back(mx);\n\tfor(auto t:v) if(t.first-t.second>mx.first-mx.second) mx=t;\n\tV.push_back(mx);\n\tfor(auto t:v) if(-t.first+t.second>-mx.first+mx.second) mx=t;\n\tV.push_back(mx);\n\tfor(auto t:v) if(-t.first-t.second>-mx.first-mx.second) mx=t;\n\tV.push_back(mx);\n\tswap(v,V);\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n,k;\n\tcin >> n >> k;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcin >> c[i][j];\n\t\t\ta[c[i][j]]={i,j};\n\t\t}\n\t}\n\tfor(int i=n*n;i>=1;i--)\n\t{\n\t\tint flag=1;\n\t\tfor(auto t:v)\n\t\t\tif(dis(t,a[i])>k) flag=0;\n\t\tif(flag)\n\t\t{\n\t\t\tans[a[i].first][a[i].second]='M';\n\t\t\tv.push_back(a[i]),rebuild();\n\t\t}\n\t\telse ans[a[i].first][a[i].second]='G';\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout << ans[i][j];\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "games",
        "hashing",
        "implementation",
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Gojou and Matrix Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/101302",
    "editorial": "TutorialSuppose that Marin places a token at . If Gojou places a token\r\nat where , then Gojou would not have any advantage as Marin can play at\r\nagain. After a very huge number of turns, Marin will have more points\r\nthan Gojou. Generally, if a player is forced to play in a cell where\r\nthey get fewer points than the previous move, they would instantly\r\nlose.Therefore, we can rephrase the problem as such: Apart from the\r\nfirst move, the token placed by a player must be more than Manhattan\r\ndistance k away from the previous token placed on the matrix. Apart from\r\nthe first move, the token placed by a player must be on a cell with more\r\npoints than the cell with the token placed by the previous player. The\r\nplayer who plays the last token is the winner. This turns out to be a\r\nstandard dynamic programming.Let return if the player who places a token\r\nat wins.Let , then we have as a base case.Then we will fill the values\r\nof in decreasing values of . if for all such that , we have . Note that\r\nby taking the contrapositive, this is equivalent to for all such that ,\r\nwe have .Let us maintain a set that stores the pairs such that , then\r\nour operations are: adding point to given , check if for all in , Notice\r\nthat .Checking is very simple as we only need to store the minimum and\r\nmaximum of all and .\r\n"
}