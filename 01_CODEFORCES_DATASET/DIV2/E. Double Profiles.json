{
    "link": "https://codeforces.com//contest/155/problem/E",
    "problemId": "953",
    "problem_idx": "E",
    "shortId": "155E",
    "contest_number": "155",
    "problem_submissions": {
        "C": [
            1225243,
            1226717,
            1224971,
            1224506,
            1224768,
            1224444,
            1224336,
            1226178,
            1224907,
            1224916,
            1224811,
            1224924,
            1224662,
            1223975,
            1226905,
            1227456,
            1225902,
            1228923,
            4141949,
            1225351
        ],
        "D": [
            1224117,
            1227696,
            1226383,
            1225863,
            1228335,
            1226351,
            1226456,
            1225394,
            1226266,
            1226950,
            1226772,
            1227105,
            1227425,
            1226475,
            1226136,
            1224942,
            1227473,
            1225325,
            1227301
        ],
        "B": [
            1221607,
            1221762,
            1222099,
            1223177,
            1225270,
            1222150,
            1223376,
            1222553,
            1222471,
            1222167,
            1223151,
            1222830,
            1222882,
            1224581,
            1222789,
            1222810,
            1222778,
            1222687,
            1222965
        ],
        "A": [
            1221146,
            1221148,
            1221169,
            1221961,
            1222044,
            1221349,
            1221696,
            1221640,
            1221515,
            1221343,
            1221470,
            1221634,
            1221617,
            17013899,
            1224871,
            1221409,
            1221848,
            1221716,
            1221534,
            1221252
        ],
        "E": [
            1239607,
            1239595,
            1239584,
            1231448,
            1239840,
            1243072
        ]
    },
    "name": "E. Double Profiles",
    "statement": "You have been offered a job in a company developing a large social\r\nnetwork. Your first task is connected with searching profiles that most\r\nprobably belong to the same user.The social network contains registered\r\nprofiles, numbered from to . Some pairs there are friends (the\r\n\"friendship\" relationship is mutual, that is, if is friends with , then\r\nis also friends with ). Let\u2019s say that profiles and () are , if for any\r\nprofile (, ) one of the two statements is true: either is friends with\r\nand , or isn\u2019t friends with either of them. Also, and can be friends or\r\nnot be friends.Your task is to count the number of different unordered\r\npairs (), such that the profiles and are doubles. Note that the pairs\r\nare unordered, that is, pairs () and () are considered identical.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:65777216\")\n#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <string>\n#include <memory.h>\n#include <iterator>\n#define y1 trololoy1\n#define y0 trololoy0\n#define mem(A,X) memset(A,X,sizeof(A))\n#define memo(A) memset(A,0,sizeof(A))\n#define forn(I,B) for (int I=1;I<=(B);I++)\n#define forg(H,V) for (int H=first[V];h;h=next[H])\n#define rep(I,B) for (int I=0;I<(B);I++) \n#define labs(X) (((X)>0)?(X):(-(X)))\n#define ropen(X) freopen(X,\"r\",stdin)\n#define wopen(X) freopen(X,\"w\",stdout)\n#define rwopen(X) freopen(X\".in\",\"r\",stdin);freopen(X\".out\",\"w\",stdout)\n#define pb push_back\n#define mp make_pair\n#define all(X) (X).begin(),(X).end()\n#define sqr(X) ((X)*(X))\n\nusing namespace std;\n\ntypedef pair <int,int> pii;\ntypedef double ld;\ntypedef unsigned long long ll;\ntypedef pair <ll,ll> pll;\ntypedef vector<int> vi;\nconst int N=1111111;\nconst int M=2222222;\nconst int INF=111111111;\nconst ll P1=1000000007;\nconst ll P2=1000000007;\nconst ll P3=1000000007;\nconst double eps=1e-9;\nconst double pi=3.14159265358979;\n\nll q[N],t[N];\nlong long ans;\nint es[M],first[N],next[M],c,n,m;\n\ninline void add(int x,int y){\n\tnext[++c]=first[x];first[x]=c;\n\tes[c]=y;\n}\n\nvoid init(){\n//\tropen(\"input.txt\");\n\tscanf(\"%d%d\",&n,&m);\n\tq[0]=1;\n\tforn(i,n) q[i]=q[i-1]*P1;\n\tforn(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);add(b,a);\n\t}\n}\n\nint main(){\n\tinit();\n\tforn(i,n) forg(h,i) t[i]+=q[es[h]];\n\tsort(t+1,t+n+1);\n\tll c=1;\n\tforn(i,n) if (t[i]==t[i+1] && i!=n) ++c;\n\t\telse{\n\t\t\tans+=c*(c-1)/2;\n\t\t\tc=1;\n\t\t}\n\tforn(i,n) t[i]=0;\n\tforn(i,n) forg(h,i) t[i]+=q[es[h]];\n\tforn(i,n) t[i]+=q[i];\n\tsort(t+1,t+n+1);\n\tc=1;\n\tforn(i,n) if (t[i]==t[i+1]) ++c;\n\t\telse{\n\t\t\tans+=c*(c-1)/2;\n\t\t\tc=1;\n\t\t}\n\tprintf(\"%I64u\\n\",ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Double Profiles.json",
    "editorial_link": "https://codeforces.com//blog/entry/3969",
    "editorial": "We want to count the number of pairs of vertices in a undirected graph which neighbours' sets are equal up to these vertices. To count the pairs which sets of neighbours are equal we can hash these sets (for instance, count the polynomial hash of adjacency matrix row) and sort the hashes. Than we have to add the pairs of doubles which have an edge between them.\n\nWe can note that there are no more such pairs than there are edges in the graph. So we can iterate through edges and check hashes for equivalence considering the presence of the edge (in case of polynomial hash we just add some degrees to them and then compare them). Other solution was to count another version of the previous hash, now adding a loop to each vertex, and to count the number of pairs just like in the previous case.\n\nMoreover, we could try and sort the whole lists of adjacencies (which previuosly should be sorted too). As their total size is 2M, this works fine too, but needs an accurate realization. Hash solution complexity \u0097 O(N log N + M)."
}