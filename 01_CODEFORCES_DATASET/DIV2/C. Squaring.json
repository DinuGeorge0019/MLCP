{
    "link": "https://codeforces.com//contest/1995/problem/C",
    "problemId": "2772827",
    "problem_idx": "C",
    "shortId": "1995C",
    "contest_number": "1995",
    "problem_submissions": {
        "D": [
            272131872,
            272130569,
            272133863,
            272134415,
            272137449,
            272131543,
            272154573,
            272151706,
            272151276,
            272141813,
            272139057,
            272151246,
            272151986,
            272153217,
            272157571,
            272148679,
            272149814,
            272486180,
            272157625
        ],
        "C": [
            272114157,
            272113319,
            272111654,
            272121111,
            272111819,
            272119019,
            272113803,
            272118860,
            272116736,
            272123439,
            272121989,
            272122933,
            272112629,
            272120005,
            272111612,
            272116249,
            272108377,
            272486053,
            272120187
        ],
        "B2": [
            272102449,
            272103267,
            272100652,
            272099671,
            272128930,
            272108225,
            272104913,
            272104116,
            272101309,
            272106328,
            272112408,
            272104562,
            272129604,
            272109901,
            272102807,
            272107257,
            272115397,
            272485973,
            272104395
        ],
        "B1": [
            272096864,
            272101887,
            272104047,
            272103720,
            272094726,
            272108617,
            272105391,
            272104979,
            272103341,
            272103459,
            272111706,
            272103650,
            272098283,
            272103066,
            272101216,
            272107954,
            272116416,
            272485941,
            272098022
        ],
        "A": [
            272090620,
            272090574,
            272092410,
            272090882,
            272090527,
            272090716,
            272091404,
            272090846,
            272090748,
            272091332,
            272090661,
            272091173,
            272091300,
            272090978,
            272091057,
            272091479,
            272092003,
            272485907,
            272092660
        ],
        "E1": [
            272173791,
            272497229,
            272245140
        ],
        "E2": [
            272497185,
            272274307
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131851",
    "editorial": "Solution IntegerLetâs set to the number of operation we need to apply to\r\nindex so that .But, if , letâs set it to the negative number of times\r\nthat we can apply the operation to so that still holds.Now letâs just\r\ncalculate the prefix sum , donât forget to do . The sum of values in is\r\nthe answer.\r\n",
    "name": "C. Squaring",
    "statement": "found an array a consisting of integers. He likes justice, so he wants\r\nto make a fair that is, make it non-decreasing. To do that, he can\r\nperform an on an index 1\r\nle i\r\nle n of the array, which will replace a_i with a_i ^ 2 (the element at\r\nposition i with its square). For example, if a = [2,4,3,3,5,3] and\r\nchooses to perform an act of justice on i = 4, a becomes\r\n[2,4,3,9,5,3].What is the minimum number of acts of justice needed to\r\nmake the array non-decreasing?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/trie_policy.hpp>using namespace std;using namespace __gnu_pbds;typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;#ifndef ONLINE_JUDGE    #include \"debug.h\"#else    #define dbg(...) 42    template<typename T>ostream&operator<<(ostream&os,vector<T>&vec){for(signed i=0;i+1<vec.size();++i){os<<vec[i]<<\" \";}if(vec.size()>0)os<<vec.back();return os;}#endif #define all(x) x.begin(), x.end()#define rall(x) x.rbegin(), x.rend() template<typename T>istream&operator>>(istream&is,vector<T>&vec){for(T&element:vec){is>>element;}return is;}template<typename T>void chmin(T&x,T y){x=min(x,y);}template<typename T>void chmax(T&x,T y){x=max(x,y);} #define int int64_t void test_case(signed ___) {    int n;    cin >> n;    vector<int> ar(n);    cin >> ar;     int sq = 0;     auto diff = [&] (int a, int b) {        int mult = 1;        if (a > b) {            swap(a, b);            mult = -1;        }        int res = 0;        while (a < b) {            a *= a;            ++res;        }        return res;    };     int ans = 0;     for (int i = 1; i < n; ++i) {        if (ar[i] == 1 && ar[i-1] != 1) {            cout << \"-1\\n\";            return;        }        if (ar[i-1] == 1) continue;        if (ar[i] > ar[i-1]) {            if (sq != 0) {                int d = diff(ar[i-1], ar[i]+1);                sq -= d-1;                sq = max(sq, int64_t(0));            }        }        else {            sq += diff(ar[i-1], ar[i]);        }        ans += sq;    }    cout << ans << \"\\n\";} signed main(void) {    cin.tie(0)->sync_with_stdio(false);     signed tt = 1;    cin >> tt;    while (tt--)     test_case(69420);}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Squaring.json",
    "hint": [
        "Hint How many times we need to apply the operation to index , so that ? Let's call it It's easy to calculate these values in no time. Can we just accumulate them?"
    ]
}