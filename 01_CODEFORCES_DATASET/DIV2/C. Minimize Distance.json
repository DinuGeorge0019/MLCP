{
    "link": "https://codeforces.com//contest/1591/problem/C",
    "problemId": "1225715",
    "problem_idx": "C",
    "shortId": "1591C",
    "contest_number": "1591",
    "problem_submissions": {
        "E": [
            138939759,
            138896286,
            138892087,
            138904906,
            138899099,
            138912542,
            138905319,
            138942968,
            138922159,
            138917295,
            138909678,
            138916267,
            138912773,
            142180374,
            138919614,
            138909983,
            141705495,
            138930168,
            138928555,
            138925316,
            138913022,
            138892012,
            138926540,
            138931077,
            138931064,
            138930963,
            138930485,
            138930038,
            138902474,
            138912155
        ],
        "F": [
            138896881,
            138908816,
            138884874,
            138909478,
            138884427,
            138908517,
            138891044,
            138904560,
            138893395,
            138899285,
            138915632,
            142180394,
            138899469,
            138921469,
            138919710,
            138905703,
            138891520,
            138877610,
            138877802,
            138894139
        ],
        "D": [
            138884909,
            138887502,
            138910689,
            138885286,
            138904549,
            138890635,
            138896357,
            138890254,
            138899856,
            138910347,
            138894967,
            142180350,
            138908889,
            138894185,
            138899015,
            138918606,
            138885986,
            138899645,
            138900772
        ],
        "C": [
            138879406,
            138882062,
            138878466,
            138879202,
            138893756,
            138887313,
            138887413,
            138881365,
            138897506,
            138896182,
            138887184,
            142180334,
            138892648,
            138885173,
            138883573,
            138910386,
            138882034,
            138887438,
            138893006,
            138887255
        ],
        "B": [
            138872954,
            138874823,
            138871917,
            138872565,
            138874131,
            138872675,
            138878614,
            138874098,
            138894802,
            138876267,
            138881546,
            142180302,
            138877235,
            138875059,
            138878573,
            138912046,
            138876941,
            138876177,
            138883593,
            138876483
        ],
        "A": [
            138869941,
            138869454,
            138869620,
            138869532,
            138871744,
            138869648,
            138874054,
            138870679,
            138872074,
            138872428,
            138873158,
            142180273,
            138870902,
            138870272,
            138873798,
            138910683,
            138871332,
            138872992,
            138880205,
            138869700
        ]
    },
    "name": "C. Minimize Distance",
    "statement": "A total of n depots are located on a number line. Depot i lies at the\r\npoint x_i for 1\r\nle i\r\nle n.You are a salesman with n bags of goods, attempting to deliver one\r\nbag to each of the n depots. You and the n bags are initially at the\r\norigin 0. You can carry up to k bags at a time. You must collect the\r\nrequired number of goods from the origin, deliver them to the respective\r\ndepots, and then return to the origin to collect your next batch of\r\ngoods.Calculate the minimum distance you need to cover to deliver all\r\nthe bags of goods to the depots. You do have to return to the origin\r\nafter you have delivered all the bags.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nconst int N=500005;\nll a[N],b[N];int lena,lenb;\nint n,k;\nll ans;\n\nvoid solve(){\n    lena=lenb=ans=0;\n    n=read(),k=read();\n    rep(i,1,n){\n        int x=read();\n        if(x>0)a[++lena]=x;\n        else b[++lenb]=-x;\n    }\n    sort(a+1,a+lena+1);\n    sort(b+1,b+lenb+1);\n    for(int i=lena;i>=1;i-=k){\n//        int j=max(i-k+1,1);\n        ans+=a[i]*2;\n    }\n    for(int i=lenb;i>=1;i-=k){\n//        int j=min(i+k-1,lenb);\n        ans+=b[i]*2;\n    }\n    if(lena&&lenb)ans-=max(a[lena],b[lenb]);\n    else if(lena)ans-=a[lena];\n    else if(lenb)ans-=b[lenb];\n    print(ans,'\\n');\n}\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Minimize Distance.json",
    "editorial_link": "https://codeforces.com//blog/entry/97845",
    "editorial": "This problem can be solved with a greedy approach. First, we note that it makes sense to solve positive points xp\n and negative points xn\n separately since we would like the minimize the number of times we move across the origin. Second, when we move to the farthest depot to which we haven't delivered a bag yet, we can cover k?1\n other depots. Thus we can also deliver bags to the k?1\n next farthest depots from the origin. Thus to solve the positive set, we can just sort the positive points and take the sum of the distance of points starting from the farthest point, jumping k points at each step. Thus we can sort xp\n and xn\n and find the answer through the following equations:\n\nsumpos=?i=0|pos|?ki>=0xp|pos|?ki\n\nsumneg=?i=0|neg|?ki>=0xn|neg|?ki\n\nThe final answer will be 2(sumpos+sumneg)\n minus the maximum distance of a positive or negative depot since we do not have to return to the origin in the end."
}