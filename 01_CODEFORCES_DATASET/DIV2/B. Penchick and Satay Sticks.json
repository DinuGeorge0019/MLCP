{
    "link": "https://codeforces.com//contest/2031/problem/B",
    "problemId": "3027237",
    "problem_idx": "B",
    "shortId": "2031B",
    "contest_number": "2031",
    "problem_submissions": {
        "C": [
            291615019,
            291592980,
            291598103,
            291592617,
            291601230,
            291594950,
            291596641,
            291598534,
            291598910,
            291597697,
            291596223,
            291592587,
            291599058,
            291603323,
            291602165,
            291609856,
            291600956,
            291601564,
            291598721,
            291601153
        ],
        "D": [
            291602113,
            291609031,
            291609392,
            291605650,
            291611553,
            291605807,
            291612841,
            291607554,
            291614197,
            291610351,
            291605780,
            291607652,
            291614506,
            291615932,
            291614172,
            291618154,
            291620240,
            291618088,
            291615701,
            291630608
        ],
        "E": [
            291599657,
            291623637,
            291622329,
            291627631,
            291620639,
            291620840,
            291625147,
            291625195,
            291625152,
            291625051,
            291667607,
            291632299,
            291624695,
            291626446,
            291625617,
            291626579,
            291626557,
            291630022,
            291630615,
            291634752,
            291621869
        ],
        "B": [
            291587323,
            291583487,
            291585012,
            291579964,
            291587433,
            291597180,
            291587403,
            291588846,
            291583266,
            291585887,
            291584391,
            291583688,
            291590002,
            291589009,
            291588475,
            291585693,
            291585389,
            291589773,
            291580876,
            291584490
        ],
        "A": [
            291582945,
            291577851,
            291577771,
            291577094,
            291581134,
            291579202,
            291579167,
            291588540,
            291578293,
            291580690,
            291578230,
            291580416,
            291578795,
            291578495,
            291588315,
            291578514,
            291578370,
            291580482,
            291577265,
            291581164
        ],
        "F": [
            291668053
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136260",
    "editorial": "SolutionSuppose we begin with the identity permutation. Consider what\r\nhappens after swapping and . After this swap, elements to will consist\r\nof to , and to will consist of to . Thus, it is impossible for to swap\r\nwith , or for to swap with .Therefore, the swaps made must be\r\nindependent of each other; in other words, the indices chosen in the\r\nprocess must differ from each other than at least . These permutations\r\nsatisfy the following: for each index , , or and , or and . One way to\r\ncheck for this is to iterate for from to . If then continue, and if then\r\ncheck if , then swap and . Otherwise, the permutation cannot be\r\nsorted.Time complexity: Implementation: (by AlperenT) 291676758\r\n",
    "name": "B. Penchick and Satay Sticks",
    "statement": "Penchick and his friend Kohane are touring Indonesia, and their next\r\nstop is in Surabaya!In the bustling food stalls of Surabaya, Kohane\r\nbought n satay sticks and arranged them in a line, with the i-th satay\r\nstick having length p_i. It is given that p is a permutation^{\r\ntext{ }} of length n.Penchick wants to sort the satay sticks in\r\nincreasing order of length, so that p_i=i for each 1\r\nle i\r\nle n. For fun, they created a rule: they can only swap neighboring satay\r\nsticks whose lengths differ by exactly 1. Formally, they can perform the\r\nfollowing operation any number of times (including zero): Select an\r\nindex i (1\r\nle i\r\nle n-1) such that |p_{i+1}-p_i|=1; Swap p_i and p_{i+1}. Determine\r\nwhether it is possible to sort the permutation p, thus the satay sticks,\r\nby performing the above operation.^{\r\ntext{ }}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());ll rint(ll l,ll r){return uniform_int_distribution<ll>(l,r)(rnd);}//const int maxn=;int T,n;int p[200005];bool ck;int main(){    scanf(\"%d\",&T);    while(T--)    {        scanf(\"%d\",&n);        for(int i=1;i<=n;i++)        {            scanf(\"%d\",&p[i]);            if(p[i]!=i&abs(p[i]-p[i-1])==1) swap(p[i],p[i-1]);        }        ck=1;        for(int i=1;i<=n;i++) ck&=(p[i]==i);        puts(ck?\"YES\":\"NO\");    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Penchick and Satay Sticks.json",
    "hint": [
        "Hint 1 Consider which permutations you can get by reversing the operations and starting from the identity permutation",
        "Hint 2 After and have been swapped, i.e. and , neither of them can then be involved in another different swap."
    ]
}