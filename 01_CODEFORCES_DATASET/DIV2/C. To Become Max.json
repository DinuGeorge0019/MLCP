{
    "link": "https://codeforces.com//contest/1856/problem/C",
    "problemId": "2145354",
    "problem_idx": "C",
    "shortId": "1856C",
    "contest_number": "1856",
    "problem_submissions": {
        "E2": [
            217327108,
            217341724,
            217337731,
            217337437,
            217412216,
            217338400,
            217336393,
            217345459,
            217391033,
            217321012,
            217492472,
            217488570,
            217325278,
            217439292,
            217437989,
            217363475,
            217446369,
            217445127,
            217406790
        ],
        "D": [
            217299783,
            217294842,
            217318244,
            217319013,
            217306383,
            217302272,
            217316304,
            217332681,
            217344634,
            217306374,
            217314009,
            217314765,
            217312837,
            217302425,
            217303810,
            217314415,
            217312870,
            217318456,
            217300443,
            217400494,
            217316669
        ],
        "E1": [
            217289515,
            217306137,
            217300615,
            217308752,
            217314014,
            217319703,
            217297854,
            217321288,
            217321307,
            217290094,
            217290570,
            217296889,
            217296429,
            217312238,
            217311348,
            217286339,
            217297816,
            217298120,
            217312665,
            217400516,
            217300470
        ],
        "C": [
            217279950,
            217281231,
            217291934,
            217287003,
            217296034,
            217283292,
            217292390,
            217290232,
            217308894,
            217275596,
            217275048,
            217281202,
            217279491,
            217289317,
            217288630,
            217298170,
            217285184,
            217287913,
            217284586,
            217400474,
            217290893
        ],
        "B": [
            217269320,
            217271397,
            217269501,
            217272164,
            217281399,
            217274759,
            217266730,
            217267264,
            217269590,
            217284481,
            217268556,
            217268444,
            217267764,
            217270460,
            217268264,
            217272318,
            217272448,
            217269161,
            217271865,
            217400507,
            217272774
        ],
        "A": [
            217264730,
            217266241,
            217264910,
            217266955,
            217265330,
            217267424,
            217264736,
            217264718,
            217265900,
            217267758,
            217264795,
            217265478,
            217264842,
            217265458,
            217264741,
            217264735,
            217265053,
            217264661,
            217265267,
            217400456,
            217266136
        ]
    },
    "name": "C. To Become Max",
    "statement": "You are given an array of integers a of length n.In one operation you:\r\nChoose an index i such that 1\r\nle i\r\nle n - 1 and a_i\r\nle a_{i + 1}. Increase a_i by 1. Find the maximum possible value of\r\nmax(a_1, a_2,\r\nldots a_n) that you can get after performing this operation at most k\r\ntimes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\n\nconst int N = 1005;\nint n, k;\nll a[N];\n\nbool can(int id, ll what, int ops){\n    if(id > n) return false;\n    if(ops < 0) return false;\n    ll used = max(0LL, what - a[id]);\n    if(a[id] >= what) return true;\n    return can(id + 1, what - 1, ops - used);\n}\n\nvoid solve(){\n    cin >> n >> k;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        ll lo = 0;\n        ll hi = 1e9;\n        while(lo < hi){\n            ll mid = (lo + hi + 1) / 2;\n            if(can(i, mid, k)) lo = mid;\n            else hi = mid - 1;\n        }\n        ans = max(ans, lo);\n    }\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. To Become Max.json",
    "editorial_link": "https://codeforces.com//blog/entry/119058",
    "editorial": "We will do binary search on the answer. The lower bound can be set to ,\r\nwhile is clearly enough for the upper bound.Let be some resulting array\r\nafter performing at most operations.Suppose for some we want to check if\r\nwe can get in at most operations. That is, there must exist some index\r\nsuch that . So, letâs iterate from to and check if it possible to have\r\nin at most operations.Let be the minimum number of operations needed to\r\nmake . Then: for all , for all and , for and all . It is easy to see\r\nthat calculating takes time for one call in the worst case.Thus, our\r\ncheck consists of comparing and for all from to . If at least one of the\r\nvalues is , it is possible to have some in at most operations and we\r\nincrease the lower bound in the binary search after updating the current\r\nanswer. Otherwise, it is impossible and we decrease the upper\r\nbound.Complexity: , where A is the maximum possible value of and .Notes:\r\nYou can get a solution by setting the lower bound in the binary search\r\nto and the upper bound to . There exists a dp solution that relies on\r\nthe fact that the answer lies in the range\r\n",
    "hint": [
        "Hint 1 Binary search on the answer. Hint 1.1 Check if it is possible to have for some .",
        "Hint 1.1 Check if it is possible to have for some .",
        "Hint 2 Fix some possible index that will be the position of the maximum in the final array."
    ]
}