{
    "link": "https://codeforces.com//contest/2063/problem/E",
    "problemId": "3154906",
    "problem_idx": "E",
    "shortId": "2063E",
    "contest_number": "2063",
    "problem_submissions": {
        "F2": [
            302425610,
            302451940,
            302442929,
            302441504,
            302438014,
            302448830,
            302447651,
            302449239,
            302451441,
            302441520,
            302449441,
            302462040,
            302527079
        ],
        "C": [
            302417331,
            302388966,
            302380666,
            302386796,
            302391515,
            302388488,
            302384390,
            302383854,
            302392461,
            302390039,
            302389493,
            302385787,
            302379767,
            302392628,
            302382228,
            302388334,
            302383676,
            302394839,
            302388632,
            302391072
        ],
        "D": [
            302412152,
            302402949,
            302396428,
            302402633,
            302409161,
            302404535,
            302411549,
            302409325,
            302409501,
            302412675,
            302403620,
            302420625,
            302411254,
            302422339,
            302414704,
            302406132,
            302417532,
            302411171,
            302418058,
            302418384
        ],
        "E": [
            302404720,
            302395352,
            302418668,
            302414791,
            302422680,
            302426848,
            302421742,
            302427528,
            302428407,
            302458083,
            302451720,
            302434097,
            302422758,
            302403323,
            302431883,
            302433354,
            302432981,
            302436125,
            302427678,
            302431985
        ],
        "F1": [
            302388355,
            302424887,
            302442481,
            302433761,
            302438421,
            302445686,
            302447198,
            302443757,
            302450796,
            302427723,
            302449982,
            302451319,
            302436505,
            302455100,
            302448501,
            302454721,
            302454623,
            302448067,
            302454995,
            302448498
        ],
        "B": [
            302385897,
            302389386,
            302371425,
            302391237,
            302379321,
            302378690,
            302373741,
            302377026,
            302378459,
            302385735,
            302370221,
            302376737,
            302372000,
            302386149,
            302374530,
            302374437,
            302376025,
            302383492,
            302381557,
            302378496
        ],
        "A": [
            302374954,
            302366962,
            302363313,
            302365021,
            302366134,
            302366042,
            302365897,
            302366966,
            302363934,
            302362493,
            302362600,
            302366245,
            302365093,
            302367784,
            302363061,
            302365428,
            302365621,
            302368569,
            302369401,
            302377605
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138593",
    "editorial": "In this editorial, we will denote the depth of vertex as , and the\r\nsubtree size of vertex as . They can be easily calculated using DFS.Let\r\nus try to first understand what means. If the two edge lengths are and\r\n(WLOG ), the third edge length must satisfy and . This results in the\r\ninequality . There are exactly values that satisfy this, from to . This\r\nmeans, if is a good pair, the following holds.And of course, if is not a\r\ngood pair, by definition.Naively summing this up for all pairs takes at\r\nleast time. We will simplify the function into a form that can be\r\ncomputed in batches easily, and provide a different summation that finds\r\nthe same answer using a double counting proof. The simplified version of\r\nis as follows:So now we can consider summing up and separately.For the\r\nformer, consider the condition for vertex to decide the value of . For\r\nthis, must be no less than , and must not be a descendant of (because\r\nthen it will not be a good pair). Therefore, vertex decides for\r\ndifferent vertices. can be computed using a suffix sum of frequency\r\nvalues of . Thus, we will sum up for all vertices.This only has a very\r\nsmall issue; it counts pairs where twice. But thankfully, all of these\r\npairs are good pairs (otherwise they would be the same vertex), and we\r\ncan simply subtract the sum of over all from the last value.For the\r\nlatter, consider the condition for vertex to be the LCA of and . and\r\nshould be descendants of not equal to , and they should not be in the\r\nsame subtree under (because then there will be a lower common ancestor).\r\nThus, given that the number of possible descendants is , we can get the\r\nfollowing value for one vertex in . Counting for all vertices thus takes\r\ntime.This also has a very slight issue; it counts and separately, so we\r\nonly have to divide this value by to get the number of good pairs with\r\nvertex as LCA. Multiplying during the summation, we get the sum of the\r\nlatter value.Thus, we have proved that the following sum yields the very\r\nsame value that we need:Everything in this summation is in a form that\r\ncan be computed in total time. Therefore, we have solved the problem\r\nwith time complexity .\r\n",
    "name": "E. Triangle Tree",
    "statement": "You are given a rooted tree^{\r\ntext{ }} containing n vertices rooted at vertex 1. A pair of vertices\r\n(u,v) is called a if u is not an ancestor^{\r\ntext{ }} of v and v is not an ancestor of u. For any two vertices,\r\ntext{dist}(u,v) is defined as the number of edges on the unique simple\r\npath from u to v, and\r\ntext{lca}(u,v) is defined as their lowest common ancestor.A function\r\nf(u,v) is defined as follows. If (u,v) is a good pair, f(u,v) is the\r\nnumber of distinct integer values x such that there exists a ^{\r\ntext{ }} formed by side lengths\r\ntext{dist}(u,\r\ntext{lca}(u,v)),\r\ntext{dist}(v,\r\ntext{lca}(u,v)), and x. Otherwise, f(u,v) is 0. You need to find the\r\nfollowing value:\r\nsum_{i = 1}^{n-1}\r\nsum_{j = i+1}^n f(i,j).^{\r\ntext{ }}A tree is a connected graph without cycles. A rooted tree is a\r\ntree where one vertex is special and called the root. ^{\r\ntext{ }}An ancestor of vertex v is any vertex on the simple path from v\r\nto the root, including the root, but not including v. The root has no\r\nancestors. ^{\r\ntext{ }}A triangle with side lengths a, b, c is non-degenerate when\r\na+b > c, a+c > b, b+c > a.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());ll rint(ll l,ll r){return uniform_int_distribution<ll>(l,r)(rnd);}const int maxn=3e5+10;template<class T> void read(T &X){    X=0;    bool fu=0;    char cr=getchar();    while((cr<'0'||cr>'9')&&cr!='-') cr=getchar();    if(cr=='-') cr=getchar(),fu=1;    while(cr>='0'&&cr<='9') X=(X<<3)+(X<<1)+(cr^48),cr=getchar();    X=(fu?-X:X);}ll ans;int T,n,cnt,g[maxn];vector<int> e[maxn],f[maxn];void dfs(int now,int fa){    g[now]=++cnt;    for(int i:e[now])    {        if(i==fa) continue;        dfs(i,now);        if(f[g[i]].size()>f[g[now]].size()) swap(g[i],g[now]);        for(int j=0;j<f[g[i]].size();j++) ans+=1ll*((j<<1)|1)*(f[g[i]][f[g[i]].size()-j-1]-((j+1!=f[g[i]].size())?f[g[i]][f[g[i]].size()-j-2]:0))*f[g[now]][f[g[now]].size()-j-1];        for(int j=0;j+1<f[g[i]].size();j++) ans+=1ll*((j<<1)|1)*(f[g[now]][f[g[now]].size()-j-1]-f[g[now]][f[g[now]].size()-j-2])*f[g[i]][f[g[i]].size()-j-2];        for(int j=0;j<f[g[i]].size();j++) f[g[now]][f[g[now]].size()-j-1]+=f[g[i]][f[g[i]].size()-j-1];    }    f[g[now]].pb(1);    if(f[g[now]].size()>=2) f[g[now]][f[g[now]].size()-1]+=f[g[now]][f[g[now]].size()-2];//    cerr<<now<<\":\";//    for(int i:f[g[now]]) cerr<<i<<\",\";//    cerr<<endl;}int main(){//    freopen(\".in\",\"r\",stdin);//    freopen(\".out\",\"w\",stdout);    read(T);    while(T--)    {        read(n),ans=cnt=0;        for(int i=1;i<=n;i++) e[i].clear(),f[i].clear();        for(int i=1,x,y;i<n;i++) read(x),read(y),e[x].pb(y),e[y].pb(x);        dfs(1,0),printf(\"%lld\\n\",ans);    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "greedy",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Triangle Tree.json",
    "hint": [
        "Hint When is a good pair, is actually simply represented as follows. Naively calculating this for all good pairs takes time. Can you find a different representation where we can count wiser?"
    ]
}