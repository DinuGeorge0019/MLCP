{
    "link": "https://codeforces.com//contest/2040/problem/D",
    "problemId": "3075498",
    "problem_idx": "D",
    "shortId": "2040D",
    "contest_number": "2040",
    "problem_submissions": {
        "E": [
            295634858,
            295598220,
            295603659,
            295602852,
            295609062,
            295608956,
            295609438,
            295613265,
            295617536,
            295622256,
            295615426,
            295623087,
            295613034,
            295632243,
            295615757,
            295623729,
            295822197,
            295614576,
            295629623,
            295677087,
            295677053,
            295616459,
            295615739
        ],
        "F": [
            295625297,
            295602948,
            295765575,
            295764437,
            295628810,
            295613638,
            295772184
        ],
        "C": [
            295613817,
            295578002,
            295582361,
            295582510,
            295585319,
            295585121,
            295589541,
            295584238,
            295583765,
            295584198,
            295582424,
            295585127,
            295590138,
            295581996,
            295587456,
            295580712,
            295586116,
            295581622,
            295590178,
            295583863
        ],
        "D": [
            295602955,
            295588244,
            295593423,
            295591690,
            295596226,
            295661257,
            295596632,
            295595711,
            295594858,
            295602270,
            295597697,
            295602059,
            295598368,
            295600419,
            295605426,
            295590011,
            295601199,
            295607620
        ],
        "B": [
            295586789,
            295590381,
            295574073,
            295576257,
            295574329,
            295574189,
            295580781,
            295572257,
            295573109,
            295573299,
            295575453,
            295572099,
            295577165,
            295593436,
            295571846,
            295572279,
            295571755,
            295574449,
            295577717,
            295572094
        ],
        "A": [
            295581636,
            295569030,
            295573127,
            295568276,
            295571294,
            295574905,
            295568027,
            295568114,
            295567840,
            295567999,
            295568293,
            295568412,
            295569901,
            295568913,
            295567935,
            295568054,
            295568783,
            295570941,
            295568578
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137074",
    "editorial": "There are many array construction tactics that can be devised here. We\r\nwill show two of them. We will perform a depth-first traversal of the\r\ngraph and write a number greater than the previous one in the traversal\r\norder into each subsequent vertex. If the next vertex is not a leaf,\r\nthen some number has already been written into its parent, which may\r\nviolate the condition \" is prime\". If the difference is even and not\r\nequal to , then the condition is satisfied. Otherwise, the condition may\r\nbe satisfied, but we will still achieve an even difference not equal to\r\n. If the difference is odd, first add the number . If the difference\r\nbecomes , add another . It can be shown that if we added this additional\r\n, then we did not add them to the previous two vertices in the traversal\r\norder. We will write the values to the vertices with even depth in\r\nbreadth-first order. We will write the values to the vertices with odd\r\ndepth in breadth-first order. In such a traversal, the condition \" is\r\nprime\" can be violated only for one pair, and one of the vertices of\r\nthis pair will be a leaf. We will change the value of this leaf to the\r\nvalue of the parent minus .\r\n",
    "name": "D. Non Prime Tree",
    "statement": "You are given a tree with n vertices.You need to construct an array a_1,\r\na_2,\r\nldots, a_n of length n, consisting of integers from 1 to 2\r\ncdot n, and such that for each edge u_i\r\nleftrightarrow v_i of the tree, the value |a_{u_i} - a_{v_i}| is not a\r\nprime number.Find any array that satisfies these conditions, or report\r\nthat there is no such array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; using ll = long long;using ld = long double;using pii = pair<int,int>;using pll = pair<ll,ll>;using vi = vector<int>;using vll = vector<ll>; constexpr int MOD = 1000000007;constexpr int INF = 1000000000;constexpr ll LINF = 1000000000000000000LL;constexpr ld EPS = 1e-9;constexpr int MAXN = 200000;constexpr int MAXVAL = 400000; #define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define pb push_back#define eb emplace_back#define fi first#define se second#define sz(x) ((int)(x).size()) bool isPrime[MAXVAL+1]; void sievePrimes(int limit) {    for (int i=2; i<=limit; i++) isPrime[i] = true;    isPrime[0] = false; isPrime[1] = false;    for (int i=2; i*i<=limit; i++) {        if (isPrime[i]) {            for (int j=i*i; j<=limit; j+=i) {                isPrime[j] = false;            }        }    }} void solve() {    int n; cin >> n;    vector<vi> adj(n+1);    for (int i=0; i<n-1; i++){        int u,v; cin >> u >> v;        adj[u].pb(v);        adj[v].pb(u);    }    vi dist(n+1,-1), parent(n+1,-1), A(n+1,0);    dist[1]=0;    queue<int>q; q.push(1);    vi order; order.pb(1);    while(!q.empty()){        int u=q.front();q.pop();        for(auto &w: adj[u]){            if(dist[w]<0){                dist[w]=dist[u]+1;                parent[w]=u;                q.push(w);                order.pb(w);            }        }    }    A[1]=1;    vector<bool> used(2*n+1,false); used[1]=true;    int sl1=2; bool possible=true;    for (int i=1; i<sz(order); i++){        int u=order[i], p=parent[u], parentVal=A[p], assigned=0;        while(sl1<=2*n && !assigned){            if(!used[sl1] && !isPrime[abs(sl1-parentVal)]){                assigned=sl1;                used[sl1]=true;            }            sl1++;        }        if(!assigned){            possible=false; break;        }        A[u]=assigned;    }    if(!possible) cout << -1 << \"\\n\";    else {        for (int i=1; i<=n; i++) cout<<A[i]<<(i==n?'\\n':' ');    }} int main(){    fast_io();    int t; cin>>t;    sievePrimes(MAXVAL);    while(t--) solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "number theory",
        "trees",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Non Prime Tree.json",
    "hint": []
}