{
    "link": "https://codeforces.com//contest/1604/problem/C",
    "problemId": "1163964",
    "problem_idx": "C",
    "shortId": "1604C",
    "contest_number": "1604",
    "problem_submissions": {
        "E": [
            133665266,
            133665330,
            133659495,
            133662698,
            133665754,
            133665695,
            133667913,
            133670360,
            133670641,
            133670753,
            133676806,
            133672911,
            133673104,
            133674991,
            133676775,
            133679158,
            133677605,
            133683514,
            133682221,
            133683564
        ],
        "D": [
            133632914,
            133634675,
            133646997,
            133640774,
            133645923,
            133643402,
            133646411,
            133639935,
            133645645,
            133646807,
            133649571,
            133658060,
            133654131,
            133649231,
            133663364,
            133653039,
            133654438,
            133653052,
            133653688,
            133661097
        ],
        "C": [
            133630411,
            133638085,
            133632064,
            133625685,
            133635045,
            133633934,
            133631657,
            133625520,
            133634475,
            133635072,
            133633002,
            133634939,
            133644373,
            133640982,
            133632402,
            133642673,
            133644331,
            133633661,
            133631330,
            133642353
        ],
        "B": [
            133625396,
            133621698,
            133626014,
            133619603,
            134090905,
            133624581,
            133623770,
            133621459,
            133634337,
            133628885,
            133630875,
            133627020,
            133622232,
            133627089,
            133635361,
            133623364,
            133634078,
            133623924,
            133625391,
            133624417,
            133621609
        ],
        "A": [
            133617599,
            133618208,
            133617413,
            133617141,
            134090791,
            133617364,
            133617444,
            133617618,
            133619480,
            133619710,
            133620324,
            133618064,
            133617109,
            133626724,
            133628136,
            133617925,
            133618078,
            133619587,
            133619073,
            133618066,
            133617633
        ],
        "F": [
            133735630,
            133826813
        ]
    },
    "name": "C. Di-visible Confusion",
    "statement": "YouKn0wWho has an integer sequence a_1, a_2,\r\nldots, a_n. He will perform the following operation until the sequence\r\nbecomes empty: select an index i such that 1\r\nle i\r\nle |a| and a_i is divisible by (i + 1), and erase this element from the\r\nsequence. Here |a| is the length of sequence a at the moment of\r\noperation. Note that the sequence a changes and the next operation is\r\nperformed on this changed sequence.For example, if a=[3,5,4,5], then he\r\ncan select i = 2, because a_2 = 5 is not divisible by i+1 = 3. After\r\nthis operation the sequence is [3,4,5].Help YouKn0wWho determine if it\r\nis possible to erase the whole sequence using the aforementioned\r\noperation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 100009\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    ll x=0,f=1;int c=getchar();\n    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}\n    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    return x*f;\n}\nll t,n,flag,a[N];\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n    t=read();\n    while(t--){\n        n=read();\n        if(n==0) break;\n        ll ff=1;\n        for(int i=1;i<=n;i++) a[i]=read();\n        for(int i=1;i<=n;i++){\n            flag=0;\n            for(int j=2;j<=i+1;j++)\n                if(a[i]%j){flag=1;break;}\n            if(!flag){printf(\"NO\\n\"),ff=0;break;}\n        }\n        if(ff) printf(\"YES\\n\");\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Di-visible Confusion.json",
    "editorial_link": "https://codeforces.com//blog/entry/96460",
    "editorial": "Notice that we can erase ai\n at positions from 1\n to i\n. So for each i\n, there should be at least one integer from 2\n to i+1\n such that ai\n is not divisible by that integer. If it is not satisfied for some integer i\n, then there is no solution for sure. Otherwise, it turns out that a solution always exists.\n\nWhy?\n\nWe can prove it by induction. Let's say it is possible to erase the prefix containing n?1\n elements. As an\n can be erased at some position from 1\n to n\n(let's say k\n), then while erasing the prefix of n?1\n elements, when the prefix contains k?1\n elements, then an\n is at the k\n-th position, so we can erase it at that position and erase the rest of the sequence accordingly.\n\nSo we just have to check for all integers i\n from 1\n to n\n, if ai\n is not divisible by at least one integer from 2\n to i+1\n. Notice that if ai\n is divisible by all integers from 2\n to i+1\n, then it means that ai\n is divisible by LCM(2,3,\u0085,(i+1))\n. But when i=22\n, LCM(2,3,\u0085,23)>109>ai\n. So for i?22\n, there will always be an integer from 2\n to i+1\n which doesn't divide ai\n. So we don't have to check for them. For i<22\n, use bruteforce.\n\nComplexity: O(n+212)\n."
}