{
    "link": "https://codeforces.com//contest/1068/problem/C",
    "problemId": "242823",
    "problem_idx": "C",
    "shortId": "1068C",
    "contest_number": "1068",
    "problem_submissions": {
        "C": [
            44804609,
            44787225,
            44783973,
            44791722,
            44788969,
            44795395,
            44788534,
            44796839,
            44794223,
            44802675,
            44793149,
            44791347,
            44791718,
            44799632,
            45919927,
            44995670,
            44792807,
            44787914,
            45131859,
            45131819,
            44809435,
            44799658
        ],
        "E": [
            44798389,
            44796278,
            44796319,
            44792474,
            44806152,
            44807222,
            44805314,
            44809246,
            44805901,
            44806685,
            44806349,
            44805897,
            44809417,
            44803952,
            44807694,
            44809008,
            44809472,
            44805216,
            44807724
        ],
        "D": [
            44791215,
            44806495,
            44806429,
            44801917,
            44799230,
            44796871,
            44798866,
            44798712,
            44802512,
            44801974,
            44797087,
            44801487,
            44802268,
            44817888,
            44808939,
            44797764,
            44805243,
            44807172,
            44799620,
            44790945
        ],
        "B": [
            44783822,
            44782929,
            44781389,
            44784465,
            44783047,
            44783627,
            44784192,
            44786901,
            44784629,
            44784410,
            44789258,
            44784311,
            44783736,
            44784363,
            44781413,
            44782490,
            44787464,
            44794535
        ],
        "A": [
            44781781,
            44781589,
            44813303,
            44781338,
            44782084,
            44782565,
            44782183,
            44785669,
            44781504,
            44803190,
            44787315,
            44781691,
            44781558,
            44782973,
            44787832,
            44781454,
            44783541,
            44813482
        ],
        "F": [
            44823303,
            44827702,
            44826052
        ]
    },
    "name": "C. Colored Rooks",
    "statement": "Ivan is a novice painter. He has n dyes of different colors. He also\r\nknows exactly m pairs of colors which harmonize with each other.Ivan\r\nalso enjoy playing chess. He has 5000 rooks. He wants to take k rooks,\r\npaint each of them in one of n colors and then place this k rooks on a\r\nchessboard of size 10^{9}\r\ntimes 10^{9}.Let\u2019s call the set of rooks on the board if from any rook\r\nwe can get to any other rook in this set moving only through cells with\r\nrooks from this set. Assume that rooks can jump over other rooks, in\r\nother words a rook can go to any cell which shares vertical and to any\r\ncell which shares horizontal.Ivan wants his arrangement of rooks to have\r\nfollowing properties: For any color there is a rook of this color on a\r\nboard; For any color the set of rooks of this color is connected; For\r\nany two different colors a b union of set of rooks of color a and set of\r\nrooks of color b is connected if and only if this two colors harmonize\r\nwith each other.Please help Ivan find such an arrangement.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<pair<int,int>> pos[105];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) pos[i].push_back({i, i});\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tpos[u].push_back({u, n + i});\n\t\tpos[v].push_back({v, n + i});\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcout << pos[i].size() << '\\n';\n\t\tfor (auto p : pos[i]) cout << p.first << ' ' << p.second << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Colored Rooks.json",
    "editorial_link": "https://codeforces.com/blog/entry/62688",
    "editorial": "Let\u00e2\u0080\u0099s put rooks with color just on line number . Then, obviously, for\r\nany color the set of rooks of this color would be connected. Let\u00e2\u0080\u0099s put\r\nrooks on positions for from to . After that for any color there is a\r\nrook of this color on a board and for any two different colors union of\r\nset of rooks of color and set of rooks of color wouldn\u00e2\u0080\u0099t be connected.\r\nAnd for final step we can do the following for every pair of harmonizing\r\ncolors : let be index of first column without rooks, put rooks on cells\r\n() and (). After that for colors union of set of rooks of color and set\r\nof rooks of color would become connected and for other pairs the\r\nconnectedness doesn\u00e2\u0080\u0099t change.Total number of rooks is .\r\n"
}