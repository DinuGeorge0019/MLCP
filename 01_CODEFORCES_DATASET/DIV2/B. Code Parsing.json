{
    "link": "https://codeforces.com//contest/255/problem/B",
    "problemId": "2396",
    "problem_idx": "B",
    "shortId": "255B",
    "contest_number": "255",
    "problem_submissions": {
        "E": [
            2781064,
            2782909,
            2779985,
            2800669,
            2783123
        ],
        "D": [
            2779503,
            2780531,
            2779855,
            7301531,
            2779527,
            2780996,
            2780563,
            2778460,
            2780405,
            2781582,
            2779013,
            2778273,
            2780817,
            2782180,
            2778681,
            2781974,
            2781214,
            2779597
        ],
        "C": [
            2777137,
            2775883,
            2776972,
            2778713,
            2776597,
            2777246,
            2780722,
            2776279,
            2776811,
            2784598,
            2781515,
            2781103,
            2782432,
            2778575,
            2778477,
            2781231,
            2777192,
            2777224,
            2777892
        ],
        "B": [
            2774906,
            2775664,
            2774618,
            2774745,
            2774652,
            2775712,
            2774692,
            2774662,
            2775040,
            2776057,
            2774786,
            2775382,
            2774585,
            2775601,
            2774197,
            2775299,
            2777977,
            2781298
        ],
        "A": [
            2773818,
            2774831,
            2773771,
            2774023,
            2773753,
            2773918,
            2773887,
            2773828,
            2774266,
            2774889,
            2773857,
            2774596,
            2773892,
            2774053,
            2773684,
            2774322,
            2773855,
            2773670
        ]
    },
    "name": "B. Code Parsing",
    "statement": "Little Vitaly loves different algorithms. Today he has invented a new\r\nalgorithm just for you. Vitaly’s algorithm works with string ,\r\nconsisting of characters \"\" and \"\", and uses two following operations at\r\nruntime: Find two consecutive characters in the string, such that the\r\nfirst of them equals \"\", and the second one equals \"\" and swap them. If\r\nthere are several suitable pairs of characters, we choose the pair of\r\ncharacters that is located closer to the beginning of the string. Find\r\nin the string two consecutive characters, such that the first of them\r\nequals \"\" and the second one equals \"\". Remove these characters from the\r\nstring. If there are several suitable pairs of characters, we choose the\r\npair of characters that is located closer to the beginning of the\r\nstring. The input for the new algorithm is string , and the algorithm\r\nworks as follows: If you can apply at least one of the described\r\noperations to the string, go to step 2 of the algorithm. Otherwise, stop\r\nexecuting the algorithm and print the current string. If you can apply\r\noperation 1, then apply it. Otherwise, apply operation 2. After you\r\napply the operation, go to step 1 of the algorithm. Now Vitaly wonders,\r\nwhat is going to be printed as the result of the algorithm’s work, if\r\nthe input receives string .\r\n",
    "solutions": [
        "#include<cstdio>\n\nchar s[1010101];\nint x,y;\n\nint main(){\n    scanf(\"%s\",s);\n    x=y=0;\n    for(int i=0;s[i];i++)\n        if(s[i]=='x') x++;\n        else y++;\n    if(x<y)\n        for(int i=0;i<y-x;i++)\n            printf(\"y\");\n    else\n        for(int i=0;i<x-y;i++)\n            printf(\"x\");\n    printf(\"\\n\");\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Code Parsing.json",
    "editorial_link": "https://codeforces.com//blog/entry/6161",
    "editorial": "Not hard to see that after few operations of first type string will\r\nbecome: x..xy..y. After fer operations of second type, there will be\r\nonly letters of one type, count of this letters will be: |count(x)\r\ncount(y)|\r\n",
    "hint": []
}