{
    "link": "https://codeforces.com//contest/2049/problem/D",
    "problemId": "3095888",
    "problem_idx": "D",
    "shortId": "2049D",
    "contest_number": "2049",
    "problem_submissions": {
        "E": [
            297497545,
            297506248,
            297513363,
            297497215,
            297513754,
            297518565,
            297506722,
            297520708,
            297488887,
            297517677,
            297529325,
            297517116,
            297526566,
            297525983,
            297522466,
            297519909,
            297520752
        ],
        "D": [
            297483631,
            297479906,
            297485869,
            297513484,
            297488988,
            297486425,
            297485532,
            297485220,
            297484984,
            297500489,
            297482945,
            297486674,
            297499534,
            297487140,
            297494415,
            297499648,
            297503839,
            297506419
        ],
        "C": [
            297476672,
            297469506,
            297476237,
            297468134,
            297474308,
            297470523,
            297476380,
            297473582,
            297506923,
            297485541,
            297473126,
            297478801,
            297475763,
            297482532,
            297481819,
            297486746,
            297475914
        ],
        "B": [
            297470859,
            297460761,
            297460293,
            297459118,
            297463641,
            297461216,
            297463086,
            297463837,
            297473641,
            297462725,
            297462885,
            297469778,
            297465587,
            297460737,
            297466206,
            297472797,
            297465768
        ],
        "A": [
            297458727,
            297456975,
            297457057,
            297457132,
            297458401,
            297457465,
            297458903,
            297458352,
            297460231,
            297458345,
            297457970,
            297457220,
            297457772,
            297457523,
            297459233,
            297459057,
            297457136
        ],
        "F": [
            299863982,
            297606792
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137273",
    "editorial": "Let be the minimum cost to move to cell after shifting and be the\r\nminimum cost to move to assuming row is shifted to the left by . For\r\nsimplicity sake, we will add a row with all zeros above the first row.\r\nAlso note that the operations with states denoting columns are all under\r\nmodulo , I am omitting the notation to avoid clutter. The transitions\r\nare as follows: Base cases: From row to row : In , the term is from the\r\ncase where you move from to . Similarly the term is from the case where\r\nyou move from to . The final answer is . The overall complexity is .\r\nSolution\r\n",
    "name": "D. Shift + Esc",
    "statement": "You are given a grid with n rows and m columns of non-negative integers\r\nand an integer k. Let (i, j) denote the cell in the i-th row from the\r\ntop and j-th column from the left (1\r\nle i\r\nle n, 1\r\nle j\r\nle m). For every cell (i, j), the integer a_{i, j} is written on the\r\ncell (i, j).You are initially at (1, 1) and want to go to (n, m). You\r\nmay only move down or right. That is, if you are at (i, j), you can only\r\nmove to (i+1, j) or (i, j+1) (if the corresponding cell exists). Before\r\nyou begin moving, you may do the following operation any number of\r\ntimes: Choose an integer i between 1 and n and cyclically shift row i to\r\nthe left by 1. Formally, simultaneously set a_{i,j} to a_{i,(j\r\nbmod m) + 1} for all integers j (1\r\nle j\r\nle m). Note that you may not do any operation after you start\r\nmoving.After moving from (1, 1) to (n, m), let x be the number of\r\noperations you have performed before moving, and let y be the sum of the\r\nintegers written on visited cells (including (1, 1) and (n, m)). Then\r\nthe is defined as kx + y.Find the minimum cost to move from (1, 1) to\r\n(n, m).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ent '\\n'#define int long long typedef long long ll;using namespace std; const int mod = 998'244'353;const int maxn = 200 + 12; int dp[maxn][maxn][maxn];int mn[maxn][maxn];int a[maxn][maxn * 2];int n, m, k; void solve() {    cin >> n >> m >> k;    for(int i = 1; i <= n; i++) {        for(int j = 1; j <= m; j++) {            cin >> a[i][j];            a[i][j + m] = a[i][j];        }    }    for(int i = 0; i <= n + 1; i++) {        for(int j = 0; j <= m + 1; j++) {            mn[i][j] = 1e18;            for(int x = 0; x <= m + 1; x++) {                dp[i][j][x] = 1e18;            }        }    }    mn[0][1] = 0;    for(int i = 1; i <= n; i++) {        for(int j = 1; j <= m; j++) {            for(int x = 0; x < m; x++) {                dp[i][j][x] = mn[i - 1][j] + a[i][j + x] + x * k;                if(j > 1) dp[i][j][x] = min(dp[i][j][x], dp[i][j - 1][x] + a[i][j + x]);                mn[i][j] = min(mn[i][j], dp[i][j][x]);            }        }    }    cout << mn[n][m] << ent;} int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int t = 1;     cin >> t;    while(t--){        solve();    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Shift + Esc.json",
    "hint": []
}