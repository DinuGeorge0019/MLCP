{"link": "https://codeforces.com//contest/66/problem/C", "problemId": "348", "problem_idx": "C", "shortId": "66C", "contest_number": "66", "problem_submissions": {"C": [325739, 327571, 324946, 325140, 326366, 326847, 325519, 325350, 326429, 326396, 326853, 325915, 529168, 325585], "E": [325379, 326033, 326058, 325948, 325798, 325317, 326222, 326357, 326861, 326864, 325631, 326306, 325725, 326990, 326457], "D": [324481, 325094, 324874, 325266, 325314, 325879, 326421, 325060, 326079, 324758], "B": [323886, 323924, 323929, 324358, 324393, 324432, 324043, 324939, 324073, 324145, 324109, 323877, 324237, 325527, 324082, 324195], "A": [323693, 324098, 323993, 323752, 323774, 327293, 323660, 323863, 323917]}, "name": "C. Petya and File System", "statement": "Recently, on a programming lesson little Petya showed how quickly he can\r\ncreate files and folders on the computer. But he got soon fed up with\r\nthis activity, and he decided to do a much more useful thing. He decided\r\nto calculate what folder contains most subfolders (including nested\r\nfolders, nested folders of nested folders, and so on) and what folder\r\ncontains most files (including the files in the subfolders).More\r\nformally, the subfolders of the folder are all its directly nested\r\nfolders and the subfolders of these nested folders. The given folder is\r\nnot considered the subfolder of itself. A file is regarded as lying in a\r\nfolder, if and only if it either lies directly in this folder, or lies\r\nin some subfolder of the folder.For a better understanding of how to\r\ncount subfolders and files for calculating the answer, see notes and\r\nanswers to the samples.You are given a few files that Petya has managed\r\nto create. The path to each file looks as follows:: is single capital\r\nletter from the set {}. , ..., are folder names. Each folder name is\r\nnonempty sequence of lowercase Latin letters and digits from 0 to 9. ()\r\nis a file name in the form of ., where the and the are nonempty\r\nsequences of lowercase Latin letters and digits from 0 to 9. It is also\r\nknown that there is no file whose path looks like :. That is, each file\r\nis stored in some folder, but there are no files directly in the root.\r\nAlso let us assume that the disk root is not a folder.Help Petya to find\r\nthe largest number of subfolders, which can be in some folder, and the\r\nlargest number of files that can be in some folder, counting all its\r\nsubfolders.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file \"c\"\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nstring s;\n\nmap <string, int> mp;\n\nint res1[100005], res2[100005], cnt = 0;\n\nvoid Load ()\n{\n}\n\nvoid Solve ()\n{\n    int ans1 = 0, ans2 = 0;\n    string s;\n\n    while (cin >> s)\n    {\n        int i = 0;\n        while (s[i] != char(92) || s[i - 1] == ':') i++;\n\n        string cur = s.substr (0, i);\n        if (mp.find (cur) == mp.end()) mp[cur] = cnt++;\n\n        int f = mp[cur];\n\n        while (i < s.size())\n        {\n            while (i < s.size() && s[i] != char(92))\n                cur += s[i++];\n\n            if (i == s.size()) break;\n            if (mp.find (cur) == mp.end())\n            {\n                res1[f]++;\n                if (res1[f] > ans1) ans1 = res1[f];\n                mp[cur] = cnt++;\n            }\n            cur += s[i++];\n        }\n        res2[f]++;\n        if (res2[f] > ans2) ans2 = res2[f];\n    }\n\n    cout << ans1 << \" \" << ans2;\n}\n\nint main ()\n{\n    //freopen (file\".in\", \"r\", stdin);\n    //freopen (file\".out\", \"w\", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "1800", "interactive": false}