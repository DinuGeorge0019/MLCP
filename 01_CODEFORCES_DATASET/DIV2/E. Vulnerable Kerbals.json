{"link": "https://codeforces.com//contest/801/problem/E", "problemId": "103104", "problem_idx": "E", "shortId": "801E", "contest_number": "801", "problem_submissions": {"E": [26431268, 26432380, 26476783, 26433724, 26434229, 26480642, 26480548, 26480348, 26494890, 26761813, 26448700, 26891853], "D": [26425044, 26425418, 26424442, 26425844, 26427999, 26423648, 26424386, 26426466, 26425527, 26426325, 26426061, 26426569, 26423135, 26426063, 26426145, 26426707, 26427444, 26427659, 26427813, 26428417], "C": [26421077, 26426753, 26422126, 26422964, 26424591, 26421294, 26422383, 26423910, 26421299, 26422965, 26423300, 26464547, 26464488, 26464472, 26462113, 26461839, 26423489, 26427796, 26421258, 26423212, 26423423, 26423078, 26423800, 26424484, 26424083], "B": [26417032, 26418855, 26417051, 26418098, 26418064, 26417323, 26417757, 26418046, 26417670, 26419595, 26417736, 26418294, 26418039, 26417940, 26419935, 26419134, 26418085, 26419132, 26418680, 26417887], "A": [26416465, 26416667, 26416492, 26416663, 26416642, 26416740, 26416470, 26416681, 26416514, 26418065, 26416666, 26417060, 26416564, 26416805, 26418618, 26417312, 26416869, 26417305, 26416921, 26416811]}, "name": "E. Vulnerable Kerbals", "statement": "You are given an integer , and a list of distinct integers between and\r\n.You would like to construct a sequence satisfying the properties: Each\r\nelement is an integer between and , inclusive. All prefix products of\r\nthe sequence modulo are distinct. No prefix product modulo appears as an\r\nelement of the input list. The length of the sequence is maximized.\r\nConstruct any sequence satisfying the properties above.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nset <ll> s[200005];\nll dp[200005], trace[200005];\nlong long mod_inverse(long long a,long long mod){\n    // gcd(a,m) must equal to 1\n    // calucate a^(-1) % mod\n    // khung hon fermat\n    long long r1 = a, r2 = mod, x1 = 1,x2 = 0, q, tmp;\n    while(r2 != 0){\n        q = r1 / r2;\n        tmp = x1 -  q * x2;\n        x1 = x2;\n        x2 = tmp;\n        tmp = r1 % r2;\n        r1 = r2;\n        r2 = tmp;\n    }\n    return (x1+mod+mod)%mod;\n}\nll n,m;\nbool ban[200005];\nvector <ll> ans1;\nvector <ll> ans2;\nint main(){\n   scanf(\"%lld %lld\",&n,&m);\n   for(ll i=1;i<m;i++)\n      s[__gcd(i,m)].insert(i);\n   while(n--){\n      ll x;\n      scanf(\"%lld\",&x);\n      s[__gcd(x,m)].erase(x);\n      ban[x] = 1;\n   }\n   for(set<ll>::iterator it=s[1].begin();it!=s[1].end();it++){\n      ans1.push_back(*it);\n   }\n   for(int i=m-1;i>=2;i--){\n      trace[i] = -1;\n      dp[i] = s[i].size();\n      for(int j=2*i;j<m;j+=i){\n         if (dp[j] + s[i].size() > dp[i])\n            dp[i] = dp[j] + s[i].size(),\n            trace[i] = j;\n      }\n   }\n\n   int id = 0;\n   for(int i=2;i<m;i++) if (dp[i] > dp[id]) id = i;\n   while(id != 0 && id != -1){\n      for(set<ll>::iterator it=s[id].begin();it!=s[id].end();it++){\n         ans1.push_back(*it);\n      }\n      id = trace[id];\n   }\n   if (ans1.size()) ans2.push_back(ans1[0]);\n   for(int i=1;i<ans1.size();i++){\n      ll a = ans1[i-1];\n      ll b = ans1[i];\n      ll M = m;\n      ll zz = __gcd(a,M);\n      assert(b%zz==0);\n      a /= zz;\n      b /= zz;\n      M /= zz;\n      ans2.push_back(1ll * b * mod_inverse(a,M) % M);\n   }\n   if (!ban[0]) ans2.push_back(0);\n   cout << ans2.size() << endl;\n   //for(int i=0;i<ans1.size();i++) cout << ans1[i] << ' '; cout << endl;\n   for(int i=0;i<ans2.size();i++) cout << ans2[i] << ' ';\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "2300", "interactive": false}