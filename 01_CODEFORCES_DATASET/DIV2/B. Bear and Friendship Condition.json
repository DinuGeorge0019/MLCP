{
    "link": "https://codeforces.com//contest/791/problem/B",
    "problemId": "98945",
    "problem_idx": "B",
    "shortId": "791B",
    "contest_number": "791",
    "problem_submissions": {
        "E": [
            25623822,
            25707525,
            25637756,
            25686811
        ],
        "D": [
            25619687,
            25615888,
            25616164,
            25617170,
            25877940,
            25623254,
            25619752,
            25619476,
            25621260,
            25621091,
            25621698,
            25621432,
            25634938,
            25621485,
            25620131,
            25687920,
            25622200,
            25621928,
            25620558,
            25624599,
            25620325,
            25621555
        ],
        "C": [
            25614829,
            25610721,
            25612354,
            25611470,
            25609920,
            25609700,
            25612129,
            25612423,
            25609930,
            25611851,
            25612109,
            25634522,
            25612617,
            25613540,
            25612121,
            25613013,
            25613533,
            25611359,
            25612919,
            25614171
        ],
        "B": [
            25607382,
            25608951,
            25608908,
            25606986,
            25611482,
            25608509,
            25609856,
            25607620,
            25608196,
            25608851,
            25634368,
            25608159,
            25610124,
            25608652,
            25608764,
            25608051,
            25608470,
            25615071,
            25609116
        ],
        "A": [
            25604642,
            25605072,
            25605943,
            25604441,
            25605687,
            25604865,
            25604575,
            25604516,
            25605765,
            25605230,
            25634308,
            25604731,
            25605413,
            25604932,
            25605388,
            25604873,
            25604460,
            25606109,
            25605955
        ]
    },
    "name": "B. Bear and Friendship Condition",
    "statement": "Bear Limak examines a social network. Its main functionality is that two\r\nmembers can become friends (then they can talk with each other and share\r\nfunny pictures).There are members, numbered through . pairs of members\r\nare friends. Of course, a member can’t be a friend with themselves.Let\r\ndenote that members and are friends. Limak thinks that a network is if\r\nand only if the following condition is satisfied: For every three\r\nmembers (, , ), if and then also .For example: if Alan and Bob are\r\nfriends, and Bob and Ciri are friends, then Alan and Ciri should be\r\nfriends as well.Can you help Limak and check if the network is\r\nreasonable? Print \"\" or \"\" accordingly, without the quotes.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n\n#define inf 0x3f3f3f3f\n#define Inf 0x3FFFFFFFFFFFFFFFLL\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define Rep(i, n) for (int i = 1; i <= (n); ++i)\n#define clr(x, a) memset(x, (a), sizeof x)\nusing namespace std;\ntypedef long long ll;\nint const N = 202020;\nint parents[N];\nint deg[N];\nint Find(int a) {\n\treturn parents[a] < 0 ? a : parents[a] = Find(parents[a]);\n}\nvoid Union(int a,int b) {\n\tif (parents[a] < parents[b]) parents[a] += parents[b], parents[b] = a;\n\telse parents[b] += parents[a], parents[a] = b;\n}\nvoid init() { clr(parents, 0xff); }\n\nint main() {\n\tinit(); int n, m; scanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint a, b; scanf(\"%d %d\", &a, &b);\n\t\tint ra = Find(a), rb = Find(b);\n\t\t++deg[a], ++deg[b];\n\t\tif (ra != rb) {\n\t\t\tUnion(ra, rb);\n\t\t}\n\t}\n\tbool ok = 1;\n\tRep(i, n) {\n\t\tint t = Find(i);\n\t\tint c = -parents[t];\n\t\tif (deg[i] < c - 1) {\n\t\t\tok = 0; break;\n\t\t}\n\t}\n\tif (ok) puts(\"YES\"); else puts(\"NO\");\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Bear and Friendship Condition.json",
    "editorial_link": "https://codeforces.com//blog/entry/51068",
    "editorial": "The main observation is that you should print \"YES\" if the graph is a set of disjoint cliques (in each connected non-clique there is a triple of vertices X,Y,Z that X-Y and Y-Z but not X-Z). To check if each connected component is a clique, you can run dfs and count vertices and edges in the connected component  it's a clique if and only if .",
    "hint": []
}