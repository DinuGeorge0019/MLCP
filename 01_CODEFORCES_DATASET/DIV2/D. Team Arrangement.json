{
    "link": "https://codeforces.com//contest/59/problem/D",
    "problemId": "310",
    "problem_idx": "D",
    "shortId": "59D",
    "contest_number": "59",
    "problem_submissions": {
        "E": [
            280965,
            279581,
            281138,
            281387,
            280873,
            283124,
            283115,
            283111,
            283109,
            283100,
            283096,
            283092,
            283085,
            283084,
            281969,
            7020454
        ],
        "D": [
            280391,
            284138,
            281502,
            281236,
            281590,
            282219,
            282005,
            282011,
            281002
        ],
        "C": [
            279741,
            280383,
            280157,
            280215,
            279940,
            280089,
            280651,
            282540,
            280526,
            280047,
            280179,
            280617,
            280421
        ],
        "B": [
            279223,
            280161,
            279355,
            279326,
            279379,
            279486,
            283681,
            280066,
            279671,
            279598,
            279324,
            279470,
            279615,
            279517,
            280028
        ],
        "A": [
            278986,
            280065,
            279027,
            279062,
            279003,
            279074,
            283673,
            279299,
            279346,
            279565,
            279059,
            279097,
            279211,
            279043,
            279837
        ]
    },
    "name": "D. Team Arrangement",
    "statement": "Recently personal training sessions have finished in the Berland State\r\nUniversity Olympiad Programmer Training Centre. By the results of these\r\ntraining sessions teams are composed for the oncoming team contest\r\nseason. Each team consists of three people. All the students of the\r\nCentre possess numbers from to , and all the teams possess numbers from\r\nto . The splitting of students into teams is performed in the following\r\nmanner: while there are people who are not part of a team, a person with\r\nthe best total score is chosen among them (the captain of a new team),\r\nthis person chooses for himself two teammates from those who is left\r\naccording to his list of priorities. The list of every person\u2019s\r\npriorities is represented as a permutation from students who attend the\r\ncentre, besides himself.You are given the results of personal training\r\nsessions which are a permutation of numbers from to , where the -th\r\nnumber is the number of student who has won the -th place. No two\r\nstudents share a place. You are also given the arrangement of the\r\nalready formed teams in the order in which they has been created. Your\r\ntask is to determine the list of priorities for the student number . If\r\nthere are several priority lists, choose the lexicographically minimal\r\none.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint n;\nint k;\nconst int MN = 300*1000+50;\nint arr[MN];\nint perm[MN];\nint pos[MN];\nbool cmp(int a, int b) {\n\treturn pos[a] < pos[b];\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<3*n; ++i) cin>>perm[i];\n\tfor(int i=0; i<3*n; ++i) pos[perm[i]] = i;\n\tfor(int i=0; i<3*n; ++i) cin>>arr[i];\n\tcin>>k;\n\tint a=0;\n\twhile(arr[a]!=k) ++a;\n\tvector<int> pre,cur,post;\n\tfor(int i=0; i<a/3*3; ++i) pre.push_back(arr[i]);\n\tfor(int i=0; i<3; ++i) {\n\t\tint x = a/3*3+i;\n\t\tif (arr[x]==k) continue;\n\t\tcur.push_back(arr[x]);\n\t\tint xx = arr[x];\n\t\tif (pos[xx] < pos[k]) {\n\t\t\tbool sp=0;\n\t\t\tfor(int i=1; i<=3*n; ++i) {\n\t\t\t\tif (i!=k) {\n\t\t\t\t\tif (sp) cout<<' ';\n\t\t\t\t\tcout<<i;\n\t\t\t\t\tsp=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=a/3*3+3; i<3*n; ++i) post.push_back(arr[i]);\n\tsort(pre.begin(),pre.end());\n\tsort(cur.begin(),cur.end());\n\tsort(post.begin(),post.end());\n\tvector<int> res;\n\n\tsize_t p=0, c=0, o=0;\n\tfor(int i=0; i<3*n-1; ++i) {\n\t\tint x = p<pre.size() ? pre[p] : (int)1e8;\n\t\tint y = c<cur.size() ? cur[c] : (int)1e8;\n\t\tint z = o<post.size() && c==cur.size() ? post[o] : (int)1e8;\n\t\tint m = min(x,min(y,z));\n\t\tif (x==m) ++p;\n\t\tif (y==m) ++c;\n\t\tif (z==m) ++o;\n\t\tres.push_back(m);\n\t}\n\n\tfor(int i=0; i<3*n-1; ++i) {\n\t\tif (i>0) cout<<' ';\n\t\tcout<<res[i];\n\t}\n\tcout<<'\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Team Arrangement.json",
    "editorial_link": "https://codeforces.com//blog/entry/1276",
    "editorial": "This was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.\n\nThe basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:\nCase 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.\n\nTo get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.\n\nThe second list will contain all the left over members.\n\nThe separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!\n\nComplexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).\n\nCase 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.\n\nAs for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.\n\nPlease point out any optimizations to the above or mistakes which I might have made in the above."
}