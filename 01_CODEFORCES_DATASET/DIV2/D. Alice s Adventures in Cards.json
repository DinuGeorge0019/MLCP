{
    "link": "https://codeforces.com//contest/2028/problem/D",
    "problemId": "3015768",
    "problem_idx": "D",
    "shortId": "2028D",
    "contest_number": "2028",
    "problem_submissions": {
        "F": [
            290935691,
            290949712,
            290955148,
            290955187,
            290957184,
            292391424
        ],
        "E": [
            290922245,
            290922480,
            290920424,
            290927233,
            290924245,
            290933073,
            290931752,
            290929839,
            290930222,
            290933477,
            290938776,
            290925205,
            290935230,
            290939685,
            290935948,
            290940043,
            290940956,
            290939742,
            290941596
        ],
        "D": [
            290914114,
            290910753,
            290911155,
            290918762,
            290914432,
            290916818,
            290919264,
            290917594,
            290919639,
            290918811,
            290925900,
            290936103,
            290915690,
            290926820,
            290971789,
            290922189,
            290916679,
            290927684,
            290928018,
            290925322
        ],
        "C": [
            290904384,
            290896368,
            290900564,
            290905625,
            290896283,
            290906809,
            290893283,
            290905680,
            290908077,
            290905220,
            290900117,
            290902591,
            290910230,
            290901329,
            290904962,
            290902731,
            290903557,
            290906063,
            290905134
        ],
        "B": [
            290895606,
            290891907,
            290894947,
            290900151,
            290892659,
            290894607,
            290903522,
            290896362,
            290901510,
            290898064,
            290894885,
            290895319,
            290897887,
            290896070,
            290896548,
            290895196,
            290898108,
            290896215
        ],
        "A": [
            290889080,
            290888110,
            290888845,
            290888449,
            290888344,
            290888834,
            290895010,
            290888416,
            290888296,
            290888948,
            290888415,
            290888738,
            290892035,
            290889212,
            290888467,
            290903576,
            290888326,
            290888321,
            290889167
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136096",
    "editorial": "We will use DP to answer the following question for each from down to :\r\nis it possible to trade up from card to card ?To answer this question\r\nefficiently, we need to determine for each of the three players whether\r\nthere exists some such that and it is possible to trade up from card to\r\ncard . We can do this efficiently by keeping track for each player the\r\nminimum value over all that can reach : then, for a given we can check\r\nfor each player if exceeds . If it does for some player, we can then\r\nupdate the values for each of the three players. Alongside these minimum\r\nvalues we can keep track of the achieving them to be able to reconstruct\r\na solution.This takes time since each iteration takes time .\r\n",
    "name": "D. Alice s Adventures in Cards",
    "statement": "Alice is playing cards with the Queen of Hearts, King of Hearts, and\r\nJack of Hearts. There are n different types of cards in their card game.\r\nAlice currently has a card of type 1 and needs a card of type n to\r\nescape Wonderland. The other players have one of each kind of card.In\r\nthis card game, Alice can trade cards with the three other players. Each\r\nplayer has different preferences for the n types of cards, which can be\r\ndescribed by permutations^{\r\ntext{ }} q, k, and j for the Queen, King, and Jack, respectively. A\r\nplayer values card a more than card b if for their permutation p, p_a >\r\np_b. Then, this player is willing to trade card b to Alice in exchange\r\nfor card a. Aliceâ€™s preferences are straightforward: she values card a\r\nmore than card b if a > b, and she will also only trade according to\r\nthese preferences.Determine if Alice can trade up from card 1 to card n\r\nsubject to these preferences, and if it is possible, give a possible set\r\nof trades to do it.^{\r\ntext{ }}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define ll long longusing namespace std;long long read(){    long long x=0,f=1;char ch=getchar();    while(!isdigit(ch))    {if(ch=='-') f=-1;ch=getchar();}    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}    return x*f;}void write(long long x){    if(x<0) putchar('-'),x=-x;    if(x>9) write(x/10);    putchar(x%10+'0');}const int N=2e5+10;int T,n;int a[4][N],rp[4][N];int b[N],c[4][N],nxt1[N],nxt2[N];int z1[N],z2[N],tp;int op(int p,int x,int y){    if(b[a[p][x]]<b[a[p][y]]||(b[a[p][x]]==b[a[p][y]]&&x<y))return y;    return x;}void add(int p,int x,int v){    for(;x<=n;x+=x&-x){        c[p][x]=op(p,c[p][x],v);    }}int ask(int p,int x){    int ans=0;    for(;x;x-=x&-x){        ans=op(p,ans,c[p][x]);    }    return ans;}int main(){    //freopen(\".in\",\"r\",stdin);    //freopen(\".out\",\"w\",stdout);    T=read();    while(T--){        n=read();tp=0;        for(int i=1;i<=3;i++){            for(int j=1;j<=n;j++){                int x=read();                a[i][x]=j;                rp[i][a[i][j]]=j;                b[j]=c[i][j]=0;nxt1[j]=nxt2[j]=0;            }        }        for(int i=1;i<=3;i++){            for(int j=1;j<=n;j++){                rp[i][a[i][j]]=j;            }        }        b[n]=n;        for(int i=1;i<=3;i++)add(i,rp[i][n],rp[i][n]);        for(int i=n-1;i>=1;i--){            int pos=0,p=0,u;            for(int j=1;j<=3;j++){                u=ask(j,rp[j][i]);                if(b[a[j][u]]==n/*&&u==rp[j][i]-1*/){                    pos=a[j][u];p=j;                }            }            if(!pos){                nxt1[i]=nxt2[i]=0;            }            else{                nxt1[i]=pos;                nxt2[i]=p;                b[i]=n;                for(int j=1;j<=3;j++){                    add(j,rp[j][i],rp[j][i]);                }            }        }        if(!nxt1[1]){            puts(\"NO\");continue;        }        puts(\"YES\");        int cnt=0;        for(int i=1;i!=n;i=nxt1[i]){            cnt++;        }        printf(\"%d\\n\",cnt);        for(int i=1;i!=n;i=nxt1[i]){            if(nxt2[i]==1)cout<<\"q \";            if(nxt2[i]==2)cout<<\"k \";            if(nxt2[i]==3)cout<<\"j \";            printf(\"%d\\n\",nxt1[i]);        }    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "graphs",
        "greedy",
        "implementation",
        "ternary search"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Alice s Adventures in Cards.json",
    "hint": [
        "Hint This is not a graph problem. Try to think about for each card whether Alice can ever trade up from to ."
    ]
}