{
    "link": "https://codeforces.com//contest/1762/problem/E",
    "problemId": "1695274",
    "problem_idx": "E",
    "shortId": "1762E",
    "contest_number": "1762",
    "problem_submissions": {
        "F": [
            185360973,
            185364441,
            185372202,
            185395910,
            185621065,
            185354232,
            185332491,
            185348264,
            185360759,
            197448951,
            197448921
        ],
        "E": [
            185344507,
            185353525,
            185341937,
            185339289,
            185344504,
            185352316,
            185360035,
            185362208,
            185365484,
            185404755,
            185370016,
            185351528,
            185364233,
            185367555,
            191848003,
            185329145
        ],
        "D": [
            185337625,
            185342301,
            185324406,
            185313736,
            185320476,
            185336684,
            185335575,
            185333725,
            185325437,
            185329719,
            185355407,
            185334757,
            185358794,
            185354685,
            185353510,
            203219751,
            203219727,
            185328017,
            185332700,
            185327767
        ],
        "C": [
            185322060,
            185321446,
            185314988,
            185324570,
            185312857,
            185315091,
            185320564,
            185320295,
            185330972,
            185319388,
            185342558,
            185326201,
            185316184,
            185309915,
            185362472,
            185315926,
            185312437,
            185310609,
            185320776
        ],
        "B": [
            185304175,
            185312988,
            185302843,
            185317620,
            185309312,
            185304849,
            185311399,
            185308703,
            185304961,
            185310615,
            185338037,
            185310014,
            185310646,
            185303730,
            185343806,
            185303744,
            185303718,
            185304581,
            185309640
        ],
        "A": [
            185300504,
            185304250,
            185300255,
            185302050,
            185306620,
            185300445,
            185302307,
            185307731,
            185300743,
            185301230,
            185335246,
            185301137,
            185300437,
            185300430,
            185322563,
            185300790,
            185300333,
            185302002,
            185301784
        ],
        "G": [
            185409628,
            185346613
        ]
    },
    "name": "E. Tree Sum",
    "statement": "Let us call an edge-weighted tree with n vertices numbered from 1 to n\r\nif the weight of each edge is either 1 or -1 and for each vertex i, the\r\nproduct of the edge weights of all edges having i as one endpoint is\r\n-1.You are given a positive integer n. There are n^{n-2}\r\ncdot 2^{n-1} distinct^\r\ndagger edge-weighted trees with n vertices numbered from 1 to n such\r\nthat each edge is either 1 or -1. Your task is to find the sum of\r\nd(1,n)^\r\nddagger of all such trees that are good. Since the answer can be quite\r\nlarge, you only need to find it modulo 998\r\n,244\r\n,353.^\r\ndagger Two trees are considered to be distinct if either: there exists\r\ntwo vertices such that there is an edge between them in one of the\r\ntrees, and not in the other. there exists two vertices such that there\r\nis an edge between them in both trees but the weight of the edge between\r\nthem in one tree is different from the one in the other tree. Note that\r\nby Cayley\u2019s formula, the number of trees on n labeled vertices is\r\nn^{n-2}. Since we have n-1 edges, there are 2^{n-1} possible assignment\r\nof weights(weight can either be 1 or -1). That is why total number of\r\ndistinct edge-weighted tree is n^{n-2}\r\ncdot 2^{n-1}.^\r\nddagger d(u,v) denotes the sum of the weight of all edges on the unique\r\nsimple path from u to v.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int mod = 998244353;\nint fpow(int a,int b)\n{\n    if(b < 0) return 1;\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = 1LL*ans*a%mod;a = 1LL*a*a%mod ; b >>= 1;\n    }\n    return ans;\n}\nint t[500005] , rt[500005];\nint C(int a,int b)\n{\n    return 1LL*t[a]*rt[b] % mod * rt[a -b] % mod;\n}\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    if(n % 2 == 1) {\n        puts(\"0\");return 0;\n    }\n    int ans = 0;\n    t[0] = rt[0] = 1;\n    for(int i = 1;i <= n;i++) t[i] = 1LL*t[i - 1] * i % mod , rt[i] = fpow(t[i] , mod - 2);\n    for(int i = 1;i <= n - i;i++) {\n        int d = 1LL*C(n , i)*fpow(i , i - 2) % mod;\n        d = 1LL*d*fpow(n-i , n-i-2) % mod;\n        d = 1LL*d*i%mod*(n - i) % mod;\n        d = 1LL*d*i%mod*(n - i) % mod;\n        if(i == n - i) d = 1LL*d*fpow(2 , mod - 2) % mod;\n        if(i & 1) ans = (ans - d +mod) % mod;\n        else ans = (ans + d) % mod;\n    }\n    int d = (1LL*n*(n - 1) / 2) % mod;\n    ans = 1LL*ans*fpow(d , mod - 2) % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/110169",
    "editorial": "SolutionTime for one more interesting claim. The weight of edge is if\r\nthere are nodes on one side and nodes on other side of , irrespective of\r\nthe structure of tree.We can prove this claim by induction, similar to\r\nwhat we did in hint .To find answer we will look at contribution of each\r\nedge. Here\u00e2\u0080\u0099s detailed explanation on how to dot it.In total, we have\r\nedges. Suppose for some edge(say ), we have nodes(including node ) on\r\nleft side and nodes(including node ) on right side. Among edges, how\r\nmany possibilities do we have for ? It is . Why? First we select\r\nnodes(as node is fixed to be on left side) to be on left side, we get\r\nfor this.Now we have nodes on left side and nodes on right side. Edge\r\nwill connect one among nodes on left and one among nodes on right. So\r\nedge will exist between pairs. We know that number of distinct trees\r\nhaving nodes is .Now on selecting one node from left and one from right,\r\nwe have fixed the root of subtree on left side, and have also fixed the\r\nroot of subtree on right side. So, number of distinct subtrees on left\r\nside is , and number of distinct subtrees on right side is . Thus, on\r\nmutliplying all(since they are independent), we get possibilities for\r\n.Now this edge lies on the path from to as both lie on opposite sides of\r\nthis node.So this edge contributes to answer.Hence where . Note that we\r\nassumed that we are always going from left subtree to right subtree\r\nwhile calculating contribution. As we have tried all possibilties for l,\r\nall cases get covered. We used left and right subtrees just for our own\r\nconvention.Time complexity is .\r\n"
}