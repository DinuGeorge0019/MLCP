{
    "link": "https://codeforces.com//contest/1762/problem/E",
    "problemId": "1695274",
    "problem_idx": "E",
    "shortId": "1762E",
    "contest_number": "1762",
    "problem_submissions": {
        "F": [
            185360973,
            185364441,
            185372202,
            185395910,
            185621065,
            185354232,
            185332491,
            185348264,
            185360759,
            197448951,
            197448921
        ],
        "E": [
            185344507,
            185353525,
            185341937,
            185339289,
            185344504,
            185352316,
            185360035,
            185362208,
            185365484,
            185404755,
            185370016,
            185351528,
            185364233,
            185367555,
            191848003,
            185329145
        ],
        "D": [
            185337625,
            185342301,
            185324406,
            185313736,
            185320476,
            185336684,
            185335575,
            185333725,
            185325437,
            185329719,
            185355407,
            185334757,
            185358794,
            185354685,
            185353510,
            203219751,
            203219727,
            185328017,
            185332700,
            185327767
        ],
        "C": [
            185322060,
            185321446,
            185314988,
            185324570,
            185312857,
            185315091,
            185320564,
            185320295,
            185330972,
            185319388,
            185342558,
            185326201,
            185316184,
            185309915,
            185362472,
            185315926,
            185312437,
            185310609,
            185320776
        ],
        "B": [
            185304175,
            185312988,
            185302843,
            185317620,
            185309312,
            185304849,
            185311399,
            185308703,
            185304961,
            185310615,
            185338037,
            185310014,
            185310646,
            185303730,
            185343806,
            185303744,
            185303718,
            185304581,
            185309640
        ],
        "A": [
            185300504,
            185304250,
            185300255,
            185302050,
            185306620,
            185300445,
            185302307,
            185307731,
            185300743,
            185301230,
            185335246,
            185301137,
            185300437,
            185300430,
            185322563,
            185300790,
            185300333,
            185302002,
            185301784
        ],
        "G": [
            185409628,
            185346613
        ]
    },
    "name": "E. Tree Sum",
    "statement": "Let us call an edge-weighted tree with n vertices numbered from 1 to n\r\nif the weight of each edge is either 1 or -1 and for each vertex i, the\r\nproduct of the edge weights of all edges having i as one endpoint is\r\n-1.You are given a positive integer n. There are n^{n-2}\r\ncdot 2^{n-1} distinct^\r\ndagger edge-weighted trees with n vertices numbered from 1 to n such\r\nthat each edge is either 1 or -1. Your task is to find the sum of\r\nd(1,n)^\r\nddagger of all such trees that are good. Since the answer can be quite\r\nlarge, you only need to find it modulo 998\r\n,244\r\n,353.^\r\ndagger Two trees are considered to be distinct if either: there exists\r\ntwo vertices such that there is an edge between them in one of the\r\ntrees, and not in the other. there exists two vertices such that there\r\nis an edge between them in both trees but the weight of the edge between\r\nthem in one tree is different from the one in the other tree. Note that\r\nby Cayley’s formula, the number of trees on n labeled vertices is\r\nn^{n-2}. Since we have n-1 edges, there are 2^{n-1} possible assignment\r\nof weights(weight can either be 1 or -1). That is why total number of\r\ndistinct edge-weighted tree is n^{n-2}\r\ncdot 2^{n-1}.^\r\nddagger d(u,v) denotes the sum of the weight of all edges on the unique\r\nsimple path from u to v.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int mod = 998244353;\nint fpow(int a,int b)\n{\n    if(b < 0) return 1;\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = 1LL*ans*a%mod;a = 1LL*a*a%mod ; b >>= 1;\n    }\n    return ans;\n}\nint t[500005] , rt[500005];\nint C(int a,int b)\n{\n    return 1LL*t[a]*rt[b] % mod * rt[a -b] % mod;\n}\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    if(n % 2 == 1) {\n        puts(\"0\");return 0;\n    }\n    int ans = 0;\n    t[0] = rt[0] = 1;\n    for(int i = 1;i <= n;i++) t[i] = 1LL*t[i - 1] * i % mod , rt[i] = fpow(t[i] , mod - 2);\n    for(int i = 1;i <= n - i;i++) {\n        int d = 1LL*C(n , i)*fpow(i , i - 2) % mod;\n        d = 1LL*d*fpow(n-i , n-i-2) % mod;\n        d = 1LL*d*i%mod*(n - i) % mod;\n        d = 1LL*d*i%mod*(n - i) % mod;\n        if(i == n - i) d = 1LL*d*fpow(2 , mod - 2) % mod;\n        if(i & 1) ans = (ans - d +mod) % mod;\n        else ans = (ans + d) % mod;\n    }\n    int d = (1LL*n*(n - 1) / 2) % mod;\n    ans = 1LL*ans*fpow(d , mod - 2) % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/110169",
    "editorial": "SolutionTime for one more interesting claim. The weight of edge is if\r\nthere are nodes on one side and nodes on other side of , irrespective of\r\nthe structure of tree.We can prove this claim by induction, similar to\r\nwhat we did in hint .To find answer we will look at contribution of each\r\nedge. Hereâs detailed explanation on how to dot it.In total, we have\r\nedges. Suppose for some edge(say ), we have nodes(including node ) on\r\nleft side and nodes(including node ) on right side. Among edges, how\r\nmany possibilities do we have for ? It is . Why? First we select\r\nnodes(as node is fixed to be on left side) to be on left side, we get\r\nfor this.Now we have nodes on left side and nodes on right side. Edge\r\nwill connect one among nodes on left and one among nodes on right. So\r\nedge will exist between pairs. We know that number of distinct trees\r\nhaving nodes is .Now on selecting one node from left and one from right,\r\nwe have fixed the root of subtree on left side, and have also fixed the\r\nroot of subtree on right side. So, number of distinct subtrees on left\r\nside is , and number of distinct subtrees on right side is . Thus, on\r\nmutliplying all(since they are independent), we get possibilities for\r\n.Now this edge lies on the path from to as both lie on opposite sides of\r\nthis node.So this edge contributes to answer.Hence where . Note that we\r\nassumed that we are always going from left subtree to right subtree\r\nwhile calculating contribution. As we have tried all possibilties for l,\r\nall cases get covered. We used left and right subtrees just for our own\r\nconvention.Time complexity is .\r\n",
    "hint": [
        "Hint 1 There does not exist any good tree of size if is odd. How to prove it? Suppose gives the product of weight of edges incident to node in a good tree. We know that as if tree is good. Now if is odd. There is another way to find . Look at contribution of each edge. Each edge contribitues to , no matter what the weight of this edge is, as it gets multiplied twice. Thus we get . We got contradiction. Thus no good tree of size exists.",
        "Hint 2 Now assume is even. Here is an interesting claim. For any unweighted tree,there exists exactly one assignment of weight of edges which makes it good. Thus there are distinct edge-weighted trees.",
        "Hint 3 How to prove the claim in hint ? Arbitrarily root the tree at node . Now start from leaves and move towards root and assign the weight of edges in the path. First of all the edge incident to any leaf node will have as the weight. While moving towards root, it can be observed that weight of edge between and parent of depends on the product of weight of edges between and its children. As we are moving from leaves towards root, weight of edges between and its children are already fixed. Weight of edge between and parent is , where gives the weight of edge between and its parent, and denotes the set of children of ."
    ]
}