{
    "link": "https://codeforces.com//contest/1407/problem/E",
    "problemId": "718475",
    "problem_idx": "E",
    "shortId": "1407E",
    "contest_number": "1407",
    "problem_submissions": {
        "D": [
            92297631,
            92239112,
            92260381,
            92252806,
            92252049,
            92262520,
            92228234,
            92259211,
            92260360,
            92261376,
            92261918,
            92266899,
            92256587,
            92266172,
            92260274,
            92262912,
            92303878,
            92302623,
            92256275,
            92270984,
            92272252,
            92271510,
            92282349
        ],
        "E": [
            92256636,
            92233407,
            92267510,
            92279480,
            92272807,
            92274460,
            92269480,
            92269259,
            92273514,
            92279715,
            92278350,
            92279867,
            92282565,
            92283409,
            92274020,
            92304060,
            92282786,
            92228831,
            92283331,
            92283427,
            92278831
        ],
        "C": [
            92232599,
            92248324,
            92233479,
            92234268,
            92236468,
            92249353,
            92246953,
            92244705,
            92238987,
            92236719,
            92240957,
            92237611,
            92237282,
            92240234,
            92248416,
            92302688,
            92246152,
            92275036,
            92246613,
            92261035,
            92227354
        ],
        "B": [
            92224272,
            92243377,
            92224493,
            92224273,
            92227246,
            92253319,
            92237934,
            92228855,
            92225988,
            92227692,
            92222986,
            92232613,
            92224373,
            92228873,
            92234801,
            92303526,
            92302715,
            92233774,
            92277941,
            92232453,
            92246726,
            92238191
        ],
        "A": [
            92221741,
            92238499,
            92221489,
            92220356,
            92223704,
            92240968,
            92227717,
            92262213,
            92222693,
            92221930,
            92220180,
            92226337,
            92220737,
            92223399,
            92226099,
            92303272,
            92302746,
            92224681,
            92281196,
            92221648,
            92239991,
            92220826
        ]
    },
    "name": "E. Egor in the Republic of Dagestan",
    "statement": "Egor is a famous Russian singer, rapper, actor and blogger, and finally\r\nhe decided to give a concert in the sunny Republic of Dagestan.There are\r\nn cities in the republic, some of them are connected by m directed roads\r\nwithout any additional conditions. In other words, road system of\r\nDagestan represents . Egor will arrive to the city 1, travel to the city\r\nn by roads along some path, give a concert and fly away.As any famous\r\nartist, Egor has lots of haters and too annoying fans, so he can travel\r\nonly by safe roads. There are two types of the roads in Dagestan, black\r\nand white: black roads are safe at night only, and white roads in the\r\nmorning. Before the trip Egor\u2019s manager\u2019s going to make a schedule: for\r\neach city he\u2019ll specify it\u2019s color, black or white, and then if during\r\nthe trip they visit some city, the only time they can leave it is\r\ndetermined by the city\u2019s color: night, if it\u2019s black, and morning, if\r\nit\u2019s white. After creating the schedule Egor chooses an available path\r\nfrom 1 to n, and for security reasons it has to be the shortest\r\npossible.Egor\u2019s manager likes Dagestan very much and wants to stay here\r\nas long as possible, so he asks you to make such schedule that there\r\nwould be no path from 1 to n or the shortest path\u2019s length would be\r\ngreatest possible.A is one city or a sequence of roads such that for\r\nevery road (excluding the first one) the city this road goes from is\r\nequal to the city previous road goes into. Egor can move only along\r\npaths consisting of safe roads only. The path length is equal to the\r\nnumber of roads in it. The shortest path in a graph is a path with\r\nsmallest length.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 500005;\n\nint n, m, u, v, x, dst[N], ans[N];\nbool chk[N];\nvector<pair<int, int>> adj[N];\n\nvoid BFS() {\n    fill(dst + 1, dst + n + 1, -1);\n    queue<int> q;\n    for (dst[n] = 0, q.push(n); !q.empty(); q.pop()) {\n        int u = q.front();\n        for (auto [v, x] : adj[u]) {\n            if (v == u) {\n                continue;\n            }\n            if (chk[v] && ans[v] == x) {\n                if (dst[v] == -1) {\n                    dst[v] = dst[u] + 1;\n                    q.push(v);\n                }\n            } else {\n                chk[v] = true;\n                ans[v] = x ^ 1;\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m;\n    while (m--) {\n        cin >> u >> v >> x;\n        adj[v].push_back({u, x});\n    }\n    BFS();\n    cout << dst[1] << '\\n';\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i];\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Egor in the Republic of Dagestan.json",
    "editorial_link": "https://codeforces.com//blog/entry/82417",
    "editorial": "**This task has a simple intuitive proof, but I wanted to describe it\r\nformally so it\u00e2\u0080\u0099s pretty complicated.**We\u00e2\u0080\u0099ll show a constructive\r\nalgorithm for this task and proof it\u00e2\u0080\u0099s correctness. We also provide a\r\nrealisation with time complexity. Let\u00e2\u0080\u0099s change each edge\u00e2\u0080\u0099s direction to\r\nthe opposite. Then for vertex of color all incoming edges of color and\r\nonly they are safe. We call a schedule optimal for if the shortest path\r\n(from ) to along the safe edges is the longest possible. We call a path\r\n(from ) to optimal if it\u00e2\u0080\u0099s the shortest path for any optimal schedule\r\nfor . So we have to find an optimal schedule for and the length of\r\noptimal path for .Let\u00e2\u0080\u0099s make four parameters for each vertex : - the\r\nlength of optimal path to , if is black, - the length of optimal path to\r\n, if is white, - the length of optimal path to among all possible\r\nschedules, - the color of . The algorithm is following: Initially , for\r\nall . All vertices are unpainted. If there is no unpainted vertex such\r\nthat (including the case when all vertices are painted) - go to point\r\nAmong all unpainted vertices choose vertex with the smallest possible\r\nvalue of . If set .If set .If then can be either or . Watch each edge\r\noutgoing from . Let an edge\u00e2\u0080\u0099s color be .If (black edge) - set .If (white\r\nedge) - set .Then set . Go to point . For each unpainted vertex set the\r\ncolor just as in point . The value of is equal to the desired answer\r\n(excluding case: that means there\u00e2\u0080\u0099s no way from to for the constructed\r\nschedule, and the answer is ), and the values of form the optimal\r\nschedule.Let , and be the real optimal values of , and . We\u00e2\u0080\u0099ll show that\r\nthe parameters found by the algorithm are optimal. Let\u00e2\u0080\u0099s proof some\r\nstatements: This statement is obvious, because the shortest path in any\r\ngraph doesn\u00e2\u0080\u0099t contain repeating vertices. For any schedule the length of\r\nthe shortest path from to is not greater than , and the color of is\r\nfixed, so the length of the shortest path from to is not greater than .\r\nFor white edges and correspondingly the analogous statement is correct.\r\nBefore the first iteration the statement is correct. Let be selected in\r\nthe beginning of some iteration, and we update the parameters of for a\r\nblack edge . Let the statement be correct before the update. Then due to\r\nthe statement . and , so , and . After the update the value of can stay\r\nthe same or be changed to , but since as , the final value of is not\r\nless than , so the statement remains correct after the update.\r\nAnalogously we can show that for white edges it\u00e2\u0080\u0099s correct, too. By\r\ninduction we have that the statement is invariant, i.e. it\u00e2\u0080\u0099s always\r\ncorrect.We can notice that for each painted vertex it\u00e2\u0080\u0099s value of is not\r\nsmaller than the value of for any vertex painted before the . Also, the\r\nvalues of , and remain constant after the iteration when is painted.\r\nThese facts are easy-to-proof, but for shortness we won\u00e2\u0080\u0099t do it here.\r\nwe\u00e2\u0080\u0099ll show it by induction on the number of iterations. It\u00e2\u0080\u0099s easy to see\r\nthat after the first iteration the Lemma remains correct.Let the Lemma\r\nbe correct after the first iterations. Let be painted during the -th\r\niteration. Then and are already equal to the lengths of shortest paths\r\nto , passing through painted vertices only and ending by black and white\r\nedges, correspondingly (it\u00e2\u0080\u0099s obvious, proof it yourself if you don\u00e2\u0080\u0099t\r\nbelieve). The length of the shortest path for already painted vertices\r\nwon\u00e2\u0080\u0099t change, because is not smaller than the values of of previously\r\npainted vertices.Thus, at the end of the algorithm we get the desired\r\nschedule, where for each is equal to the length of the shortest path to\r\n, and ; then from these two statements follows the fact that for all\r\nvertices , what means that the constructed schedule is optimal. This\r\nalgorithm can be realised as a modified BFS, where the vertex is added\r\nto the queue just as it\u00e2\u0080\u0099s value becomes smaller than infinity (in the\r\ncode the value of infinity can be just ). It\u00e2\u0080\u0099s easy to proof that such\r\nrealisation is equivalent to the algorithm.\r\n"
}