{
    "link": "https://codeforces.com//contest/2085/problem/F1",
    "problemId": "3284101",
    "problem_idx": "F1",
    "shortId": "2085F1",
    "contest_number": "2085",
    "problem_submissions": {
        "F2": [
            311878898,
            311854121,
            312547828,
            313180465,
            312715525
        ],
        "F1": [
            311866129,
            311884163,
            311888744,
            311865797,
            311890721,
            311853454,
            311870055,
            311856458,
            311889685,
            312547788,
            312535060,
            311920736,
            311883283
        ],
        "D": [
            311854269,
            311840149,
            311846898,
            311849836,
            311841369,
            311813594,
            311831715,
            311864844,
            311834411,
            311845527,
            311845487,
            311842115,
            311851940
        ],
        "E": [
            311849828,
            311869915,
            311859328,
            311874708,
            311857458,
            311844963,
            311880401,
            311844941,
            311849085,
            311875928,
            311862172,
            311856416,
            311861319,
            311872692,
            311863088,
            311848201
        ],
        "B": [
            311824052,
            311815589,
            311817146,
            311836083,
            311819326,
            311808366,
            311842734,
            311823405,
            311881846,
            311854059,
            311819894,
            311821673,
            311824308,
            311814219,
            311816794,
            311819160
        ],
        "A": [
            311810733,
            311807971,
            311807466,
            311816690,
            311808218,
            311807487,
            311888447,
            311833731,
            311808956,
            311822473,
            311811561,
            311808040,
            311808284,
            311807791,
            311816294
        ],
        "C": [
            311807884,
            311821315,
            311839190,
            311828017,
            311827320,
            311810326,
            311887204,
            311816120,
            311830323,
            311880309,
            311851607,
            311814111,
            311825484,
            311838153,
            311826627,
            311836598,
            311830943
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140933",
    "editorial": "SolutionConsider the elements in the colorful subarray after swapping.\r\nThe first observation is as follows.Observation. Mark the elements in\r\nthe colorful subarray. Before swapping, to make these marked elements\r\ncontinuous, gathering them toward the middle one among them minimizes\r\nthe number of swaps.Proof. It is not optimal to swap two marked\r\nelements. Thus, the leftmost elements will move to their right, and the\r\nrightmost elements will move to their left. They will meet at some point\r\nbetween the -th element and the -th element. If , adjusting the meeting\r\npoint to its right reduces swaps. If , we can adjust it to its left and\r\nreduce the number of swaps similarly. Therefore, one can show that\r\nsetting the meeting point to the middle of them is optimal through\r\nadjustments. From the observation we can also conclude that, the minimum\r\nnumber of swaps required to make the marked elements continuous is the\r\ndifference between the sum of the distances from each marked element to\r\nthe middle position before swapping and that sum after swapping, if the\r\nmarked elements are swapped toward the middle position. Notice that the\r\nlatter sum is a fixed constant only related to .Focusing on the middle\r\nposition of the colorful subarray, we enumerate all the positions in the\r\narray as possible middle positions. For each possible middle position ,\r\nto form the colorful subarray whose middle position is , we should\r\nchoose distinct integers from its left and the other from its right. The\r\nrounding of will not affect the correctness as long as the sum of the\r\nrounded numbers is .For each , we should determine whether should be\r\nchosen from the left side of or the right side of . Let the distance\r\nfrom to the rightmost integer on its left be , and the distance for the\r\nright side be . We should choose either or for each under the constraint\r\nthat both the number of chosen and that of are , minimizing the sum of\r\nthe distances we choose. This can be done by first forcing to choose all\r\nthe , and then choosing the smallest elements of greedily.In\r\nimplementation, when enumerating the middle position , both and can be\r\nsimply calculated in time, and then sort in time. The total complexity\r\nis .\r\n",
    "name": "F1. Serval and Colorful Array  Easy Version ",
    "statement": "Serval has a magic number k (k\r\nge 2). We call an array r if and only if: The length of r is k, and Each\r\ninteger between 1 and k appears in r. You are given an array a\r\nconsisting of n integers between 1 and k. It is guaranteed that each\r\ninteger between 1 and k appears in a at least once. You can perform the\r\nfollowing operation on a: Choose an index i (1\r\nle i < n), then swap a_i and a_{i+1}.Find the minimum number of\r\noperations needed to make at least one subarray^{\r\ntext{ }} of a . It can be shown that this is always possible under the\r\nconstraints of the problem.^{\r\ntext{ }}An array b is a subarray of an array a if b can be obtained from\r\na by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Serval and Colorful Array  Easy Version .json",
    "hint": [
        "Hint 1 Consider the integers in the colorful subarray after swapping.",
        "Hint 2 How to gather these integers together, forming a colorful subarray, with the minimum number of swaps?",
        "Hint 3 Consider the middle one among all the the elements in the colorful subarray."
    ]
}