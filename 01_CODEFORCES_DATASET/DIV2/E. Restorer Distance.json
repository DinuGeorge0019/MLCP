{
    "link": "https://codeforces.com//contest/1355/problem/E",
    "problemId": "621795",
    "problem_idx": "E",
    "shortId": "1355E",
    "contest_number": "1355",
    "problem_submissions": {
        "F": [
            80362643,
            80361142,
            80371199,
            80375388,
            80371644,
            80361246,
            80376315,
            80364923,
            80451552,
            80451301,
            82486662,
            80381916,
            80385112,
            80379306
        ],
        "E": [
            80342772,
            80347661,
            80342876,
            80352205,
            80343534,
            80366285,
            80351380,
            80344639,
            80337870,
            80337107,
            80341941,
            80338367,
            80340360,
            80336736,
            80314570,
            80337962,
            80336156,
            80334884,
            80344718
        ],
        "D": [
            80330173,
            80325918,
            80331675,
            80332445,
            80331125,
            80343460,
            80342008,
            80323259,
            80328043,
            80317161,
            80320497,
            80327650,
            80330129,
            80331474,
            80325643,
            80327968,
            80338287,
            80328760
        ],
        "C": [
            80320115,
            80322649,
            80326557,
            80321616,
            80325868,
            80336946,
            80347623,
            80329416,
            80318213,
            80323733,
            80324197,
            80332049,
            80321990,
            80325577,
            80334728,
            80333064,
            80322766,
            80319462,
            80324120
        ],
        "B": [
            80313084,
            80311263,
            80314204,
            80313526,
            80315674,
            80318605,
            80310517,
            80315225,
            80313004,
            80311116,
            80311816,
            80310369,
            80314982,
            80317625,
            80337817,
            80312634,
            80317719,
            80311591,
            80311875
        ],
        "A": [
            80310641,
            80315080,
            80310450,
            80310461,
            80311650,
            80314001,
            80355749,
            80319520,
            80310211,
            80310180,
            80310418,
            80311667,
            80311224,
            80310372,
            80321351,
            80310345,
            80316111,
            80324974,
            80310515
        ]
    },
    "name": "E. Restorer Distance",
    "statement": "You have to restore the wall. The wall consists of N pillars of bricks,\r\nthe height of the i-th pillar is initially equal to h_{i}, the height is\r\nmeasured in number of bricks. After the restoration all the N pillars\r\nshould have equal heights.You are allowed the following operations: put\r\na brick on top of one pillar, the cost of this operation is A; remove a\r\nbrick from the top of one non-empty pillar, the cost of this operation\r\nis R; move a brick from the top of one non-empty pillar to the top of\r\nanother pillar, the cost of this operation is M.You cannot create\r\nadditional pillars or ignore some of pre-existing pillars even if their\r\nheight becomes 0.What is the minimal total cost of restoration, in other\r\nwords, what is the minimal total cost to make all the pillars of equal\r\nheight?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define endl \"\\n\"\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define ms(v,x) memset(v,x,sizeof(v))\n#define all(v) v.begin(),v.end()\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n//#define per(i, a, b) for(int i = b-1; i>=a ; i--)\n#define trav(a, x) for(auto& a : x)\n#define allin(a , x) for(auto a : x)\n#define td(v) v.begin(),v.end()\n#define sz(v) (int)v.size()\n//#define M   1000000007 // 1e9 + 7\n#define int long long\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ninline ll mod(ll n, ll m ){ ll ret = n%m; if(ret < 0) ret += m; return ret; }\nll gcd(ll a, ll b){return (b == 0LL ? a : gcd(b, a%b));}\n\nll exp(ll a,ll b,ll m){\n    if(b==0LL) return 1LL;\n    if(b==1LL) return mod(a,m);\n    ll k = mod(exp(a,b/2,m),m);\n    if(b&1LL){\n        return mod(a*mod(k*k,m),m);\n    }\n    else return mod(k*k,m);\n}\n\nconst int N = 100100;\n\nll h[N];\nll pre[N];\n\nstruct BIT{\n int n;\n int MAX;\n vector<ll> bit;\n BIT(){}\n BIT(int _n){\n   n = _n;\n   MAX = n +2;\n   bit.resize(n+10,0);\n }\n \n ll query(int x){\n   ll r=0;\n   while(x>0){\n     r+=bit[x];\n     x-=(x&-x);\n   }\n   return r;\n }\n \n ll query(int l,int r){\n   return query(r) - query(l-1);\n }\n \n void update(int x,int val){\n   while(x<MAX){\n     bit[x]+=val;\n     x+=(x&-x);\n   }\n }\n\n  \n};\n\n\nBIT freq,soma;\n\nint K;  ll a,r,m;\n\nll testa(int id,ll val){\n   int maior = freq.query(id+1,K);\n   int menor = freq.query(1,id-1);\n\n     \n    ll smx = soma.query(id+1,K);\n    ll smn = soma.query(1,id-1);\n\n    smn = menor * val - smn;\n    smx = smx - maior*val;\n\n   // cout << val<<\" \"<<smn<<\" \"<<smx << endl;\n    ll cost = 0;\n    if(m < a + r){\n      ll go = min(smx,smn);\n      cost+=m*(go);\n      smx-=go;\n      smn-=go;\n    }\n    cost+=smx*r;\n    cost+=smn*a;\n\n    return cost;\n}\n\n\n\nint32_t main(){\n  fastio;\n  int n;\n\n  cin >> n >> a >> r >> m;\n  map<int,int> mp;\n  ll tot=0;\n  for(int i=1;i<=n;i++){\n    cin >> h[i];\n    mp[h[i]];\n    tot+=h[i];\n  }\n  sort(h+1,h + 1 + n);\n\n  int media = tot/n;\n  for(int i=max(1LL,media-100);i<=min(h[n],media + 100);i++){\n    mp[i];\n  }\n\n\n   K=0;\n\n  for(auto&it : mp){\n    it.ss = ++K;\n  }\n\n  freq = BIT(K+10),soma = BIT(K+10);\n\n  ll best = 1e18;\n  for(int i=1;i<=n;i++){\n    int id = mp[h[i]];\n    freq.update(id,1);\n    soma.update(id,h[i]);\n  }\n\n  for(auto it : mp){\n    best = min(best,testa(it.ss,it.ff));\n  }\n  cout << best << endl;\n\n  // Math -> gcd it all\n  // Did u check N=1? Did you switch N,M?\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "sortings",
        "ternary search"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Restorer Distance.json",
    "editorial_link": "https://codeforces.com//blog/entry/77491",
    "editorial": "First of all let\u00e2\u0080\u0099s do M =\r\nmin(M, A + R) this is true since we can emulate moving by\r\nadding+removing. After that it is never profitable to add and remove in\r\none solution, since we can always move instead.Suppose we have fixed H\r\nthe resulting height for all pillars. How can we calculate the minimal\r\ncost for given H? Some pillars have no more than H bricks, let the total\r\nnumber of missing bricks in these pillars be P. Other pillars have no\r\nless than H bricks, let the total number of extra bricks in these\r\npillars be Q. If P\r\nge Q then we are missing (P - Q) bricks in total, so we have to make\r\n(P - Q) additions. There won\u00e2\u0080\u0099t be any more additions or removals, and we\r\nhave to do at least Q moves since we have to somehow get rid of extra\r\nbricks from those pillars which have more than H bricks initially. It is\r\nclear that Q moves is enough. Therefore the total cost will be C = A(P -\r\nQ) + MQ. Similarly, if Q\r\nge P then the total cost will be C = R(Q - P) + MP.Let\u00e2\u0080\u0099s now assume that\r\nP\r\nge Q, we have exactly X pillars with no more than H bricks and exactly\r\nN - X pillars with strictly more than H bricks. Let\u00e2\u0080\u0099s try to increase H\r\nby 1 and see how the total cost will change. P\u00e2\u0080\u0099 = P + X, Q\u00e2\u0080\u0099 = Q - (N -\r\nX) = Q - N + X. C\u00e2\u0080\u0099 = A(P\u00e2\u0080\u0099 - Q\u00e2\u0080\u0099) + MQ\u00e2\u0080\u0099 = A(P + X - Q + N - X) + M(Q - N +\r\nX) = A(P - Q) + MQ + AN - M(N - X). We can see that the total cost has\r\nchanged by AN - M(N - X). While X is constant the cost change will be\r\nconstant. What are the moments when X changes? When H is equal to the\r\ninitial height of some pillar. Therefore the cost as a function of H is\r\npiecewise linear with breakpoints in points corresponding to initial\r\nheights.There is a nuance we have assumed P\r\nge Q. The same thing will be true for P\r\nle Q but there can be additional breakpoints when we change between\r\nthese two states. This change will happen only once for H\r\napprox\r\nfrac{\r\nsum h_{i}}{N} (approximate equality here means that this point can be\r\nnon-integral so we should add both\r\nlfloor\r\nfrac{\r\nsum h_{i}}{N}\r\nrfloor and\r\nlceil\r\nfrac{\r\nsum h_{i}}{N}\r\nrceil as breakpoints).The minima of piecewise linear function are in\r\nbreakpoints so it is enough to calculate the cost for breakpoints\r\n(initial heights and H\r\napprox\r\nfrac{\r\nsum h_{i}}{N}) and choose minimal of them.To calculate the cost for\r\ngiven H fast we can sort the initial heights and calculate prefix sums\r\nof heights. Then using binary search we can determine which pillars have\r\nheight less than H and greater than H and then calculate P and Q using\r\nprefix sums. We can use two pointers instead of binary searches but it\r\nwill not improve the total complexity which is O(N\r\nlog N) due to sorting (and binary searches if we are using them).\r\n"
}