{
    "link": "https://codeforces.com//contest/1818/problem/C",
    "problemId": "1897385",
    "problem_idx": "C",
    "shortId": "1818C",
    "contest_number": "1818",
    "problem_submissions": {
        "F": [
            203954465,
            203930910,
            203989728,
            203950170
        ],
        "E": [
            203940713,
            203952207,
            203954969,
            203955944,
            204078536,
            203944339,
            203943920,
            203965332,
            203957684,
            203924512
        ],
        "D": [
            203935580,
            203930131,
            203939536,
            203937747,
            203926993,
            203932798,
            203948151,
            203919017,
            203933133,
            203930283,
            203939418,
            203978791,
            203937294,
            203949049,
            203940699,
            203938945,
            203937604,
            203937271
        ],
        "C": [
            203927589,
            203919798,
            203928628,
            203925534,
            203931513,
            203921512,
            203927085,
            203928001,
            203926317,
            203916672,
            203923862,
            203933925,
            203926373,
            203934292,
            203922244,
            203928248,
            203928037,
            203928918
        ],
        "B": [
            203922412,
            203918213,
            203919638,
            203920216,
            203917691,
            203917420,
            203954835,
            203921335,
            203916143,
            203918490,
            203937550,
            203919150,
            203922597,
            203918604,
            203921444,
            203917928,
            203921361,
            203920046,
            203919333
        ],
        "A": [
            203919670,
            203917474,
            203915999,
            203915969,
            203915149,
            203915496,
            203915115,
            203915794,
            203934868,
            203916606,
            203917417,
            203915457,
            203960905,
            203915626,
            203915203,
            203915634,
            203917495
        ]
    },
    "name": "C. Almost Increasing Subsequence",
    "statement": "A sequence is if it does not contain three elements x, y, z such that x\r\nge y\r\nge z.You are given an array a_1, a_2,\r\ndots, a_n and q queries.Each query consists of two integers 1\r\nle l\r\nle r\r\nle n. For each query, find the length of the longest subsequence of the\r\nsubarray a_l, a_{l+1},\r\ndots, a_r. A subsequence is a sequence that can be derived from the\r\ngiven sequence by deleting zero or more elements without changing the\r\norder of the remaining elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define endl '\\n'\n\nusing namespace std;\n\ntemplate<typename hd, typename tl> void chkmin(hd& a, tl b) { if(b < a) a = b; }\ntemplate<typename hd, typename tl> void chkmax(hd& a, tl b) { if(a < b) a = b; }\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MX = 200005;\nconst int MOD = 1e9 + 7;\n\nint n, q;\nint a[MX];\nint b[MX], c[MX];\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i ++) cin >> a[i];\n\tfor (int j = 0; j < n - 1; j ++) {\n\t\tif (a[j + 1] <= a[j]) b[j] = 0;\n\t\telse b[j] = 1;\n\t}\n\tfor (int i = n - 2; i > 0; i --) {\n\t\tif (b[i - 1]) b[i] = 1;\n\t}\n\tb[0] = 1;\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i ++) {\n\t\tc[i] = c[i - 1] + b[i - 1];\n\t}\n\twhile (q --) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tr --; l --;\n\t\tint res = c[r] - c[l];\n\t\tif (res == 0) {\n\t\t\tif (r == l) cout << 1 << endl;\n\t\t\telse cout << 2 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b[l] == 0) res ++;\n\t\tcout << res + 1 << endl;\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Almost Increasing Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": "It is not obvious how the condition in the statement for an almost-increasing subsequence can be turned into a fast data structure that can support queries. So instead of tackling the problem head on, let's try to make an upperbound for how many elements can be in the maximum length almost-increasing subsequence.\n\nAssume you're given a query about the subarray of the original array [al,al+1,Â…,ar]\n. Let's partition this array into decreasing subarrays. This means everytime when ai<ai+1\n we place a cut between ai\n and ai+1\n. For example, consider the array [4,6,7,2,2,3]\n, it will be cut into [4],[6],[7,2,2],[3]\n. All these small subarrays are non-increasing, which means that any subsequence of such a subarray is non-increasing. Because an almost-increasing subsequence cannot have three consecutive elements x?y?z\n, in each of the subarrays of our partition at most 2\n elements can be chosen to insert into our almost-increasing subsequence.\n\nActually we can put exactly min(|subarray|,2)\n elements of each subarray into the increasing subsequence, by taking the first and the last element of each subarray. This is valid, because the cuts for the partition were made at places where ai<ai+1\n, so every bi?bi+1\n in our candidate subsequence is preceded and followed by a bj<bj+1\n. By our upperbound, this construction is optimal.\n\nThe sum, ?partitionmin(|subarray|,2)\n can be calculated for one query in linear time, giving a O(nq)\n solution.\n\nTo optimize this, the sum ?partitionmin(|subarray|,2)\n can be rewritten to ?partition|subarray|?|inner elements|\n, where inner elements of a subarray are all the elements that are not the first or last element. For such elements ai\n, we know that ai?1?ai?ai+1\n. The sum of lengths over the partition sums to r?l+1\n. So we're left with counting the number of special indices l<i<r\n such that ai?1?ai?ai+1\n. This can be done with O(n)\n preprocessing and O(1)\n queries using prefix sums. For a query we can output r?l+1?|special indices|\n. There are some literal edgecases, where some care in the implementation is needed.\n\nThe total time complexity is O(n+q)\n.",
    "hint": []
}