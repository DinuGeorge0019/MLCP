{"link": "https://codeforces.com//contest/1717/problem/F", "problemId": "1527574", "problem_idx": "F", "shortId": "1717F", "contest_number": "1717", "problem_submissions": {"F": [170628195, 170631297, 170636621, 170638786, 170642998, 170642114, 170636113, 170640846, 170643077, 170643996, 170641292, 170639769, 170690219, 170646621, 170646461, 170679476, 170679133, 170639635], "E": [170609804, 170616589, 170615870, 170622633, 170610853, 170628228, 170623924, 170617172, 170622667, 170627714, 170627468, 170624918, 170630751, 170634625, 170598060, 170611863, 170622101, 170626877, 170623213, 170615426], "D": [170607171, 170605005, 170609922, 170610949, 170622497, 170609050, 170615733, 170627107, 170617123, 170612935, 170623602, 170628949, 170618958, 170628847, 170611626, 170607221, 170605022, 170607463, 170648316, 170620005], "C": [170601766, 170595872, 170600515, 170604005, 170603370, 170603689, 170597455, 170603675, 170604089, 170603783, 170612791, 170614880, 170609148, 170602273, 170598587, 170598491, 170604850, 170597420], "B": [170595706, 170594734, 170596230, 170601030, 170598846, 170599230, 170600372, 170596828, 170597841, 170615090, 170608022, 170603542, 170597876, 170599659, 170595411, 170595780, 170599224, 170595920], "A": [170594341, 170594250, 170594713, 170598166, 170594912, 170595202, 170594533, 170594589, 170594840, 170594292, 170596316, 170595526, 170594805, 170598577, 170594243, 170594388, 170596942, 170594653]}, "name": "F. Madoka and The First Session", "statement": "Oh no, on the first exam Madoka got this hard problem:Given integer n\r\nand m pairs of integers (v_i, u_i). Also there is an array b_1, b_2,\r\nldots, b_n, .Then for each index i, where 1\r\nleq i\r\nleq m, perform either b_{v_i} := b_{v_i} - 1 and b_{u_i} := b_{u_i} + 1,\r\nor b_{v_i} := b_{v_i} + 1 and b_{u_i} := b_{u_i} - 1. Note that exactly\r\none of these operations should be performed for every i.Also there is an\r\narray s of length n consisting of 0 and 1. And there is an array a_1,\r\na_2,\r\nldots, a_n, where it is guaranteed, that if s_i = 0 holds, then a_i =\r\n0.Help Madoka and determine whenever it is possible to perform\r\noperations in such way that for every i, where s_i = 1 it holds that a_i\r\n= b_i. If it possible you should also provide Madoka with a way to\r\nperform operations.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace flow {\n\tconst int inf = INT_MAX;\n\tconst int NN = 40005, MM = 222222;\n\tint n, m, s, t, d[NN], qu[NN];\n\tint cnt = 1, head[NN], cur[NN], to[MM], nxt[MM], val[MM];\n\tinline void addedge(int u, int v, int w) {\n\t\tto[++cnt] = v;\n\t\tval[cnt] = w;\n\t\tnxt[cnt] = head[u];\n\t\thead[u] = cnt;\n\t}\n\tinline void add(int u, int v, int w) {\n\t\taddedge(u, v, w);\n\t\taddedge(v, u, 0); \n\t}\n\tinline bool bfs() {\n\t\tint l = 1, r = 0;\n\t\tfor(int i = 0; i <= n; ++i) cur[i] = head[i], d[i] = 0;\n\t\tqu[++r] = s, d[s] = 1;\n\t\twhile(l <= r) {\n\t\t\tint u = qu[l++];\n\t\t\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\t\t\tint v = to[i], w = val[i];\n\t\t\t\tif(d[v] || !w) continue;\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tqu[++r] = v;\n\t\t\t}\n\t\t} \n\t\treturn d[t];\n\t}\n\tint dfs(int u, int flow) {\n\t\tif(u == t) return flow;\n\t\tint rest = flow;\n\t\tfor(int &i = cur[u]; i; i = nxt[i]) {\n\t\t\tint v = to[i], w = val[i];\n\t\t\tif(d[v] != d[u] + 1 || !w) continue;\n\t\t\tint k = dfs(v, min(flow, w));\n\t\t\tif(!k) d[v] = 0;\n\t\t\trest -= k;\n\t\t\tval[i] -= k, val[i ^ 1] += k; \n\t\t\tif(!rest) break;\n\t\t}\n\t\treturn flow - rest;\n\t}\n\tinline int dinic() {\n\t\tint res = 0;\n\t\twhile(bfs()) res += dfs(s, inf); \n\t\treturn res;\n\t}\n\tint find(int u) {\n\t\tfor (int i = head[u]; i; i = nxt[i]) {\n\t\t\tif (!val[i] && to[i]) {\n\t\t\t\treturn to[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nconst int N = 10005;\nint n, m, s[N], a[N], d[N], u[N], v[N];\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> s[i];\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcin >> u[i] >> v[i];\n\t\t++d[u[i]];\n\t\t++d[v[i]];\t\n\t}\n\n\tint cnt = 0;\n\tflow::n = flow::t = n + m + 1;\n    for (int i = 1; i <= m; ++i) {\n\t\tflow::add(flow::s, i, 1);\n\t\tif (s[u[i]] && s[v[i]]) {\n\t\t\tflow::add(i, u[i] + m, 1);\n\t\t\tflow::add(i, v[i] + m, 1);\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tint sum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (s[i]) {\n\t\t\tint x = a[i] + d[i];\n\t\t\tif (x % 2 || x < 0) {\n\t\t\t\tcout << \"NO\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[i] = x / 2;\n\t\t\tflow::add(i + m, flow::t, a[i]);\n\t\t\tsum += a[i];\n\t\t}\n\t}\n\n\tint res = flow::dinic();\n\tif (res != cnt) {\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (!(s[u[i]] && s[v[i]])) {\n\t\t\tif (s[u[i]]) {\n\t\t\t\tflow::add(i, u[i] + m, 1);\n\t\t\t}\n\t\t\tif (s[v[i]]) {\n\t\t\t\tflow::add(i, v[i] + m, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tres += flow::dinic();\n\tif (res != sum) {\n\t\tcout << \"NO\\n\";\n\t\treturn 0;\n\t}\n\n\tcout << \"YES\\n\";\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint x = flow::find(i);\n\t\tif (x > 0) {\n\t\t\tx -= m;\n\t\t}\n\n\t\tif (s[u[i]] && s[v[i]]) {\n\t\t\tif (x == u[i]) {\n\t\t\t\tswap(u[i], v[i]);\n\t\t\t}\n\t\t\tcout << u[i] << \" \" << v[i] << \"\\n\";\n\t\t} else if (s[u[i]] && !s[v[i]]) {\n\t\t\tif (x) {\n\t\t\t\tswap(u[i], v[i]);\n\t\t\t}\n\t\t\tcout << u[i] << \" \" << v[i] << \"\\n\";\n\t\t} else if (!s[u[i]] && s[v[i]]) {\n\t\t\tif (!x) {\n\t\t\t\tswap(u[i], v[i]);\n\t\t\t}\n\t\t\tcout << u[i] << \" \" << v[i] << \"\\n\";\n\t\t} else {\n\t\t\tcout << u[i] << \" \" << v[i] << \"\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "flows", "graph matchings", "graphs", "implementation"], "dificulty": "2500", "interactive": false}