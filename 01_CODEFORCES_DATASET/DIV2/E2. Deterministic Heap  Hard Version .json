{
    "link": "https://codeforces.com//contest/2001/problem/E2",
    "problemId": "2825895",
    "problem_idx": "E2",
    "shortId": "2001E2",
    "contest_number": "2001",
    "problem_submissions": {
        "B": [
            277398710,
            277337688,
            277333922,
            277337722,
            277337555,
            277331647,
            277331395,
            277333468,
            277348528,
            277341588,
            277340363,
            277333951,
            277333359,
            277338651,
            277333253,
            277332470,
            277333025,
            277335874,
            277338084,
            277338047
        ],
        "A": [
            277396358,
            277332606,
            277324069,
            277328881,
            277324101,
            277323710,
            277325572,
            277324708,
            277342273,
            277324601,
            277327125,
            277324363,
            277324076,
            277325983,
            277324668,
            277323640,
            277324308,
            277324085,
            277329437,
            277324734
        ],
        "C": [
            277393929,
            277349647,
            277343837,
            277347819,
            277349047,
            277345424,
            277478575,
            277341657,
            277342745,
            277358874,
            277352973,
            277356317,
            277345054,
            277358657,
            277349482,
            277354577,
            277354478,
            277341600,
            277373032,
            277357702,
            277354144
        ],
        "D": [
            277386516,
            277362274,
            277363417,
            277423990,
            277364589,
            277362182,
            277363264,
            277481384,
            277378655,
            277372682,
            277373441,
            277372083,
            277373799,
            277371029,
            277376602,
            277374746,
            277374825,
            277383133,
            277374017,
            277362123,
            277383713,
            277376041
        ],
        "E2": [
            277373545,
            283086293,
            277423307,
            278251315,
            278253470
        ],
        "E1": [
            277335505,
            277376073,
            277395747,
            277388497,
            277391499,
            277398952,
            277393530,
            277401516,
            277389370,
            277393752,
            277394666,
            277405095,
            277396023,
            277402006,
            277399147,
            277397663,
            277407033,
            278257931,
            277717643,
            277717625,
            277717605,
            277717578,
            277403586,
            277396025,
            277402066
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132942",
    "editorial": "Make use of symmetry:For convenience,\nlet\ntext{det_heap}() denote twice-deterministic heap,\ntext{det_heap}(v) denote twice-deterministic heap where the first pop\ncome from leaf v,\ntext{det_heap}(v, u) denote twice-deterministic heap where the first pop\ncome from leaf v, second pop come from leaf u.Similar to easier version,\nwe have\ntext{det_heap}() = 2^{n - 1}\ncdot\ntext{det_heap}(2^{n - 1}) because of symmetry.Then consider enumerate u,\nthe second leaf being popped, we have\ntext{det_heap}(2^{n - 1}) =\nsum\nlimits_{u = 2^{n - 1} + 1}^{2^n - 1}\ntext{det_heap}(2^{n - 1}, u)because of symmetry, again, for any u_1\nneq u_2, LCA(2^{n - 1}, u_1) = LCA(2^{n - 1}, u_2), we have\ntext{det_heap}(2^{n - 1}, u_1) =\ntext{det_heap}(2^{n - 1}, u_2), so for each LCA, we only need to\nenumerate leftmost leaf under it as second popped leaf and multiply\nanswer with leaves in such subtree.Rephrase of Problem:then consider the\nrelation of values between vertices, we havewhere black edge from x to y\nmeans a_x\nle a_y, which comes from the nature of\ntext{add} operation red edge from x to y means a_x < a_y, which come\nfrom the fact that v should be first leaf being pulled blue edge from x\nto y means a_x < a_y, which come from the fact that u should be second\nleaf being pulled Eliminate Useless Conditions:Then observe if we have\nsome directed triangle consist of edges (x, y), (y, z), (x, z), edge (x,\nz) didn\u00e2\u0080\u0099t bring extra relation so we can delete it, after that, we would\nhaveApplying Counting:Then we can use pair of value of vertices from\nsame depth as the state of dp, and enumerate such pair in increasing\norder of height while not breaking the relations, then we would have\ndp[h][l][r] = twice-deterministic heap when the left vertex have value l\nand right vertex have value r and the current height is h.First, to\nhandle the relation of Z shape formed by red/blue arrows and enumerate\nvalue of (L, R, R\u00e2\u0080\u0099), consider the following picture(The red subtree is\none-time deterministic heap, while the other can be any heap.)Also let\nf(h, k) denote deterministic heap for one time pop with height h after\ndoing operation k times where the leftmost leaf being pulled, g(h, k)\ndenote max heap with height h after doing operation k times (We already\nknow how to compute them in easier version of this problem)Let\u00e2\u0080\u0099s fix the\nvalue L and R, and push it to some dp[h][L\u00e2\u0080\u0099][R\u00e2\u0080\u0099], we need to satisfy\nL\u00e2\u0080\u0099 > R\u00e2\u0080\u0099 > L > R L\u00e2\u0080\u0099\nge L + R in such case, enumerate all pair (L, R), (L > R) and for all L\u00e2\u0080\u0099\nge L + R, R\u00e2\u0080\u0099\nge L + 1, add f(h - 1, L)\ncdot g(h - 1, R) to dp[h][L\u00e2\u0080\u0099][R\u00e2\u0080\u0099]. After that, for every L\u00e2\u0080\u0099\nle R\u00e2\u0080\u0099, eliminate its contribution, while for every L\u00e2\u0080\u0099 > R\u00e2\u0080\u0099, multiply its\ncontribution with f(h, R\u00e2\u0080\u0099)\ncdot 2^h. which can be done in O(k^2) with the help of prefix\nsum.Second, to handle the relation formed by black/blue edges and\nenumerate value R\u00e2\u0080\u0099, consider the following pictureFor each L, R, we need\nto push it some some dp[h][L\u00e2\u0080\u0099][R\u00e2\u0080\u0099] where the following conditions hold\nL\u00e2\u0080\u0099\nge L > R\u00e2\u0080\u0099 L\u00e2\u0080\u0099\nge L + R we can handle it by first adding dp[h - 1][L][R] to dp[L\u00e2\u0080\u0099][R\u00e2\u0080\u0099]\nfor all L\u00e2\u0080\u0099\nge L + R, R\u00e2\u0080\u0099\nle L - 1. Then for all L\u00e2\u0080\u0099\nle R\u00e2\u0080\u0099, eliminate its contribution, while for the other, multiply the\ncontribution with g(h, R\u00e2\u0080\u0099), which can also be done by prefix sum in\nO(k^2).Then the answer would be 2^{n - 1}\ncdot\nsum\nlimits_{L + R\nle k}dp[h - 2][L][R] and the problem has been solved in O(nk^2).\n",
    "name": "E2. Deterministic Heap  Hard Version ",
    "statement": "Consider a perfect binary tree with size 2^n - 1, with nodes numbered\r\nfrom 1 to 2^n-1 and rooted at 1. For each vertex v (1\r\nle v\r\nle 2^{n - 1} - 1), vertex 2v is its left child and vertex 2v + 1 is its\r\nright child. Each node v also has a value a_v assigned to it.Define the\r\noperation\r\nmathrm{pop} as follows: initialize variable v as 1; repeat the following\r\nprocess until vertex v is a leaf (i.e. until 2^{n - 1}\r\nle v\r\nle 2^n - 1); among the children of v, choose the one with the larger\r\nvalue on it and denote such vertex as x; if the values on them are equal\r\n(i.e. a_{2v} = a_{2v + 1}), you can choose any of them; assign a_x to\r\na_v (i.e. a_v := a_x); assign x to v (i.e. v := x); assign -1 to a_v\r\n(i.e. a_v := -1). Then we say the\r\nmathrm{pop} operation is deterministic if there is a unique way to do\r\nsuch operation. In other words, a_{2v}\r\nneq a_{2v + 1} would hold whenever choosing between them.A binary tree\r\nis called a max-heap if for every vertex v (1\r\nle v\r\nle 2^{n - 1} - 1), both a_v\r\nge a_{2v} and a_v\r\nge a_{2v + 1} hold.A max-heap is deterministic if the\r\nmathrm{pop} operation is deterministic to the heap when we do it\r\n.Initially, a_v := 0 for every vertex v (1\r\nle v\r\nle 2^n - 1), and your goal is to count the number of different\r\ndeterministic max-heaps produced by applying the following operation\r\nmathrm{add} exactly k times: Choose an integer v (1\r\nle v\r\nle 2^n - 1) and, for every vertex x on the path between 1 and v, add 1\r\nto a_x. Two heaps are considered different if there is a node which has\r\ndifferent values in the heaps. Since the answer might be large, print it\r\nmodulo p.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}const int N=505;int n,k,p;int f[N][N],g[N][N],h[N];int ff[N][N],gg[N][N],hh[N];void run(){\tcin>>n>>k>>p;\trep(i,k+1)rep(j,k+2)f[i][j]=ff[i][j]=g[i][j]=gg[i][j]=0;\trep(i,k+1)h[i]=hh[i]=0;\trep(i,k+1)rep(j,k+2)f[i][j]=g[i][j]=1;\trep(i,k+1)h[i]=1;\trep(i,n-1){\t\trep(j,k+1)rep(l,k+1)if(j+l<=k){\t\t\tif(j<l){\t\t\t\t(ff[j+l][l+1]+=h[j]*(f[l][k+1]-f[l][j+1]))%=p;\t\t\t\t(ff[j+l][l+1]+=g[j][k+1]*g[l][j])%=p; \t\t\t}\t\t\tif(j>l){\t\t\t\t(ff[j+l][j+1]+=(f[j][k+1]-f[j][l+1])*h[l])%=p;\t\t\t\t(ff[j+l][j+1]+=g[j][l]*g[l][k+1])%=p;\t\t\t}\t\t\tif(j<l)(gg[j+l][l+1]+=h[j]*g[l][k+1])%=p;\t\t\tif(j>l)(gg[j+l][j+1]+=g[j][k+1]*h[l])%=p;\t\t\t(hh[j+l]+=h[j]*h[l])%=p;\t\t}\t\trep(j,k)rep(l,k+2)(ff[j+1][l]+=ff[j][l])%=p;\t\trep(j,k+1)rep(l,k+1)(ff[j][l+1]+=ff[j][l])%=p;\t\trep(j,k)rep(l,k+2)(gg[j+1][l]+=gg[j][l])%=p;\t\trep(j,k+1)rep(l,k+1)(gg[j][l+1]+=gg[j][l])%=p;\t\trep(j,k)(hh[j+1]+=hh[j])%=p;\t\trep(j,k+1)rep(l,k+2)f[j][l]=ff[j][l],ff[j][l]=0;\t\trep(j,k+1)rep(l,k+2)g[j][l]=gg[j][l],gg[j][l]=0;\t\trep(j,k+1)h[j]=hh[j],hh[j]=0;//\t\trep(j,k+1)rep(l,k+2)if(f[j][l])cout<<\"f \"<<i+2<<\" \"<<j<<\" \"<<l-1<<\" \"<<f[j][l]<<\"\\n\";//\t\trep(j,k+1)rep(l,k+2)if(g[j][l])cout<<\"g \"<<i+2<<\" \"<<j<<\" \"<<l-1<<\" \"<<g[j][l]<<\"\\n\";//\t\trep(j,k+1)if(h[j])cout<<\"h \"<<i+2<<\" \"<<j<<\" \"<<h[j]<<\"\\n\";\t}\tcout<<(f[k][k+1]%p+p)%p<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Deterministic Heap  Hard Version .json"
}