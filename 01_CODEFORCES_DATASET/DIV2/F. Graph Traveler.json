{
    "link": "https://codeforces.com//contest/1200/problem/F",
    "problemId": "387086",
    "problem_idx": "F",
    "shortId": "1200F",
    "contest_number": "1200",
    "problem_submissions": {
        "F": [
            58597034,
            58604274,
            58603801,
            58604261,
            58606296,
            58609347,
            58606628,
            58603882,
            58611421,
            58614224,
            58612143,
            58659085,
            58617947,
            58615235,
            58614922,
            58618563,
            58618410,
            58819839,
            58819733,
            58614658,
            58617967,
            58616220,
            58617480
        ],
        "E": [
            58590453,
            58591974,
            58589669,
            58582754,
            58593262,
            58593765,
            58594950,
            58609042,
            58590807,
            58600501,
            58598133,
            58655621,
            58603439,
            58602117,
            58595933,
            58604924,
            58702004,
            58608728,
            58607700,
            58606886,
            58608547,
            58595823
        ],
        "D": [
            58585183,
            58587196,
            58595741,
            58592331,
            58597422,
            58600351,
            58598831,
            58588698,
            58604146,
            58596632,
            58604059,
            58594391,
            58596161,
            58605981,
            58592911,
            58594958,
            58601895,
            58602011,
            58595454,
            58607933
        ],
        "C": [
            58581348,
            58578761,
            58581508,
            58598446,
            58584753,
            58585227,
            58584309,
            58590893,
            58582665,
            58580776,
            58585592,
            58580638,
            58583883,
            58586342,
            58585762,
            58586591,
            58578435,
            58584027,
            58584223,
            58583648
        ],
        "B": [
            58580222,
            58581800,
            58579349,
            58596443,
            58582220,
            58582093,
            58584008,
            58593306,
            58580382,
            58578318,
            58581197,
            58578343,
            58580875,
            58583711,
            58582188,
            58581441,
            58581810,
            58580259,
            58599702,
            58580893
        ],
        "A": [
            58576391,
            58576584,
            58577266,
            58594056,
            58576879,
            58576717,
            58577509,
            58578116,
            58576412,
            58576423,
            58577739,
            58576429,
            58576681,
            58580309,
            58578442,
            58576553,
            58583309,
            58576504,
            58576736,
            58576406
        ]
    },
    "name": "F. Graph Traveler",
    "statement": "Gildong is experimenting with an interesting machine . In Graph\r\nTraveler, there is a directed graph consisting of n vertices numbered\r\nfrom 1 to n. The i-th vertex has m_i outgoing edges that are labeled as\r\ne_i[0], e_i[1],\r\nldots, e_i[m_i-1], each representing the destination vertex of the edge.\r\nThe graph can have multiple edges and self-loops. The i-th vertex also\r\nhas an integer k_i written on itself.A on this graph works as follows.\r\nGildong chooses a vertex to start from, and an integer to start with.\r\nSet the variable c to this integer. After arriving at the vertex i, or\r\nwhen Gildong begins the travel at some vertex i, add k_i to c. The next\r\nvertex is e_i[x] where x is an integer 0\r\nle x\r\nle m_i-1 satisfying x\r\nequiv c\r\npmod {m_i}. Go to the next vertex and go back to step 2. It\u2019s obvious\r\nthat a travel never ends, since the 2nd and the 3rd step will be\r\nrepeated endlessly.For example, assume that Gildong starts at vertex 1\r\nwith c = 5, and m_1 = 2, e_1[0] = 1, e_1[1] = 2, k_1 = -3. Right after\r\nhe starts at vertex 1, c becomes 2. Since the only integer x (0\r\nle x\r\nle 1) where x\r\nequiv c\r\npmod {m_i} is 0, Gildong goes to vertex e_1[0] = 1. After arriving at\r\nvertex 1 again, c becomes -1. The only integer x satisfying the\r\nconditions is 1, so he goes to vertex e_1[1] = 2, and so on.Since\r\nGildong is quite inquisitive, he\u2019s going to ask you q queries. He wants\r\nto know how many vertices will be visited , if he starts the travel from\r\na certain vertex with a certain value of c. Note that you should count\r\nthe vertices that will be visited only finite times.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mxN=1e3, M=2520;\nint n, k[mxN], m[mxN], e[mxN][10], nxt[mxN*M], ans[mxN*M], d[mxN*M], v[mxN*M];\n\nvoid compute(int u) {\n\tint v=u;\n\tvector<int> w;\n\tdo {\n\t\tw.push_back(v/M);\n\t\tv=nxt[v];\n\t} while(v^u);\n\tsort(w.begin(), w.end());\n\tans[u]=unique(w.begin(), w.end())-w.begin();\n}\n\nvoid dfs1(int u, int r) {\n\tv[u]=r;\n\tif(!v[nxt[u]]) {\n\t\td[nxt[u]]=d[u]+1;\n\t\tdfs1(nxt[u], r);\n\t\tans[u]=ans[nxt[u]];\n\t} else {\n\t\tif(v[nxt[u]]==r) {\n\t\t\tcompute(u);\n\t\t} else {\n\t\t\tans[u]=ans[nxt[u]];\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; ++i) {\n\t\tcin >> k[i];\n\t\tk[i]%=M;\n\t\tif(k[i]<0)\n\t\t\tk[i]+=M;\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tcin >> m[i];\n\t\tfor(int j=0; j<m[i]; ++j) {\n\t\t\tcin >> e[i][j], --e[i][j];\n\t\t}\n\t\tfor(int j=0; j<M; ++j) {\n\t\t\tint l=(j+k[i])%M, o=l%m[i];\n\t\t\t//e[i][o]\n\t\t\tnxt[i*M+j]=e[i][o]*M+l;\n\t\t}\n\t}\n\tfor(int i=0; i<n*M; ++i) {\n\t\tif(v[i])\n\t\t\tcontinue;\n\t\tdfs1(i, i+1);\n\t}\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tint x, y;\n\t\tcin >> x >> y, --x;\n\t\ty%=M;\n\t\tif(y<0)\n\t\t\ty+=M;\n\t\tcout << ans[x*M+y] << \"\\n\";\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Graph Traveler.json",
    "editorial_link": "https://codeforces.com/blog/entry/69035",
    "editorial": "Since a travel will never end, it is clear that every travel will\r\neventually get into an infinite loop. But we should consider more than\r\njust the vertices, since could be different every time he visits the\r\nsame vertex. Since the number of outgoing edges of each vertex is at\r\nmost , we can see a can be reduced to for each vertex. Therefore, we can\r\nthink that the graph actually has vertices, each with a single outgoing\r\nedge.To simulate the travels, we just need to follow the exact process\r\nwritten in the description, except that should be kept in modulo . The\r\nproblem is when to stop, and how to count the number of vertices that\r\nare in the loop.We can stop simulating until we find a state that we\r\nalready have visited. There can be two cases when we find a visited\r\nstate.The first case is when we have not visited this state in the\r\nprevious travels, i.e. this is the first travel that visits this state.\r\nWe need to check all of the states after the first visit of this state\r\nand count the number of distinct vertices. Duplicated vertices can be\r\nremoved simply by using a set, or more efficiently, using timestamp.\r\nThen we can apply the answer to all of the states we visited in this\r\ntravel.The second case is when the state was visited in one of the\r\nprevious travels. We know that both the previous travel and the current\r\ntravel will end in the same loop, so we can apply the same answer to all\r\nof the states we visited in this travel.On a side note, the simulation\r\ncan be done with recursion, but this can lead to maximum of recursion\r\ndepth. This causes stack overflow or recursion limit excess for some\r\nlanguages (including Java).Time complexity:\r\n"
}