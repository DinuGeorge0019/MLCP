{"link": "https://codeforces.com//contest/1831/problem/D", "problemId": "1942564", "problem_idx": "D", "shortId": "1831D", "contest_number": "1831", "problem_submissions": {"F": [208138276, 207709337], "E": [208138261, 207648682, 207658220, 207656838, 207666357, 207774368, 207656515, 207695977, 207710932, 207657876, 208163887, 207670786, 207664348, 207669868, 207660228], "D": [208138229, 207624019, 207622747, 207707096, 207639773, 207642056, 207665762, 207606856, 207612471, 207613443, 207614547, 207617717, 207621891, 207622928, 207622371, 207623544, 207626326, 207683940, 207628627], "C": [208138202, 207603654, 207591133, 207610375, 207604106, 207604842, 207591198, 207597318, 207602578, 207595759, 207597417, 207600531, 207601702, 207596236, 207598453, 207596408, 207607400, 207594213, 207608501, 207603207], "B": [207933759, 207587309, 207585317, 207591044, 207597740, 207626518, 207586353, 207592366, 207588011, 207586628, 207590623, 207592643, 207591011, 207586905, 209739181, 207587547, 207588237, 207602435, 207588035, 207591775, 207591535], "A": [207933729, 207580780, 207580051, 207582133, 207593347, 207580551, 207581151, 207591960, 207580225, 207581009, 207582654, 207583238, 207580711, 207581264, 209739158, 207580917, 207581616, 207598296, 207580446, 207582701, 207581592]}, "name": "D. The BOSS Can Count Pairs", "statement": "You are given two arrays a and b, both of length n.Your task is to count\r\nthe number of pairs of integers (i,j) such that 1\r\nleq i < j\r\nleq n and a_i\r\ncdot a_j = b_i+b_j.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate < typename T >\ninline const void read(T &x)\n{\n\tbool flg = x = 0;\n\tchar c;\n\twhile ((c = getchar()) < 48 || c > 57)\n\t\tflg |= c == '-';\n\tdo\n\t\tx = (x << 1) + (x << 3) + (c ^ 48);\n\twhile ((c = getchar()) > 47 && c < 58);\n\tif (flg) x = -x;\n}\n\nint OUTPUT[45];\n\ntemplate < typename T >\ninline const void write(T x)\n{\n\tif (x < 0)\n\t{\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tint len = 0;\n\tdo\n\t{\n\t\tOUTPUT[++len] = x % 10 | 48;\n\t\tx /= 10;\n\t}while (x);\n\twhile (len)\n\t\tputchar(OUTPUT[len--]);\n}\n\ntemplate < typename T >\ninline const void writesp(const T x)\n{\n\twrite(x);\n\tputchar(32);\n}\n\ntemplate < typename T >\ninline const void writeln(const T x)\n{\n\twrite(x);\n\tputchar(10);\n}\n\nconst int N = 2e5 + 5;\nint T, n, a[N], b[N];\nmap < int, int > mp[N];\n\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tread(T);\n\twhile (T--)\n\t{\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tread(a[i]);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tread(b[i]);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tmp[i].clear();\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t++mp[a[i]][b[i]];\n\t\tlong long ans = 0ll;\n\t\tfor (int i = 1; i <= n && (long long)i * (long long)i <= (n << 1); ++i) \n\t\t\tif (mp[i].size())\n\t\t\t{\n\t\t\t\tint sq = i * i;\n\t\t\t\tif (sq & 1)\n\t\t\t\t{\n\t\t\t\t\tfor (auto j : mp[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j.first > sq - j.first) break;\n\t\t\t\t\t\tauto it = mp[i].find(sq - j.first);\n\t\t\t\t\t\tif (it != mp[i].end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans += (long long)j.second * (long long)(it -> second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (auto j : mp[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j.first > sq - j.first) break;\n\t\t\t\t\t\tif (j.first == sq - j.first)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans += (((long long)j.second * (j.second - 1ll)) >> 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse//j.first < sq - j.first\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto it = mp[i].find(sq - j.first);\n\t\t\t\t\t\t\tif (it != mp[i].end())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tans += (long long)j.second * (long long)(it -> second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = i + 1; j <= n && (long long)i * (long long)j <= (n << 1); ++j)\n\t\t\t\t\tif (mp[j].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tint num = i * j;\n\t\t\t\t\t\tif (mp[i].size() < mp[j].size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (auto k : mp[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tauto it = mp[j].find(num - k.first);\n\t\t\t\t\t\t\t\tif (it != mp[j].end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans += (long long)k.second * (long long)(it -> second);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse//mp[i].size() > mp[j].size()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (auto k : mp[j])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tauto it = mp[i].find(num - k.first);\n\t\t\t\t\t\t\t\tif (it != mp[i].end())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans += (long long)k.second * (long long)(it -> second);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\twriteln(ans);\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures", "math"], "dificulty": "2000", "interactive": false}