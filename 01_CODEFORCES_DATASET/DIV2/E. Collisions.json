{"link": "https://codeforces.com//contest/34/problem/E", "problemId": "163", "problem_idx": "E", "shortId": "34E", "contest_number": "34", "problem_submissions": {"E": [149443, 149486, 149296, 149692, 149695, 149861, 149815, 149892, 150067, 150121, 150338, 150361, 149747, 150891], "D": [148876, 148578, 148654, 148286, 149242, 149046, 149356, 149232, 149202, 149561, 149681, 149837, 148969, 148779], "C": [148446, 148259, 148380, 147901, 148723, 148716, 149028, 148780, 148867, 148942, 149049, 149444, 1288885, 148173], "B": [147829, 147766, 147991, 148454, 148119, 148124, 148114, 148340, 148112, 148042, 148372, 148576, 148152, 147806, 147813], "A": [147656, 147624, 147815, 147607, 147780, 147787, 147700, 148115, 147723, 147796, 147956, 147948, 147884, 147651]}, "name": "E. Collisions", "statement": "On a number line there are balls. At time moment for each ball the\r\nfollowing data is known: its coordinate , speed (possibly, negative) and\r\nweight . The radius of the balls can be ignored.The balls collide\r\nelastically, i.e. if two balls weighing and and with speeds and collide,\r\ntheir new speeds will be: .Your task is to find out, where each ball\r\nwill be seconds after.\r\n", "solutions": ["#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair <int,int> ii;\ntypedef pair <double,ii> dii;\n#define sz(a) int((a).size())\n#define pb push_back\nconst int INF = 2147483647;\nconst double PI = 3.141592653589793;\n\nint kol[15],n,t,i,k1,k2;\nset<dii> zbior;\ndouble v[15],x[15],r,tim,nv1,nv2,m[15];\n\nbool cmp (int a, int b) {\n     return x[a] < x[b];\n}\n\nint main () {\nscanf (\"%d %d\",&n,&t);\nfor (i=0;i<n;i++) {\n    scanf (\"%lf %lf %lf\",&x[i],&v[i],&m[i]);\n    kol[i]=i;\n}\nsort (kol,kol+n,cmp);\ntim = 0.0;\nwhile (1) {\n      zbior.clear();\n      for (i=0;i<n-1;i++) {\n          k1 = kol[i];\n          k2 = kol[i+1];\n          if (v[k1]<0 && v[k2] > 0) continue;\n          if (v[k1] > 0 && v[k2] > v[k1]) continue;\n          if (v[k2] < 0 && v[k1] < v[k2]) continue;\n          zbior.insert(dii(abs(x[k1]-x[k2]) / abs(v[k1]-v[k2]),ii(k1,k2)));\n      }\n      if (zbior.size()==0) break;\n      r = (*zbior.begin()).first;\n      if ( tim + r > t) break;\n      k1 = (*zbior.begin()).second.first;\n      k2 = (*zbior.begin()).second.second;\n      for (i=0;i<n;i++) x[i]+=v[i]*r;\n      nv1 = ((m[k1]-m[k2])*v[k1]+2*m[k2]*v[k2])/(m[k1]+m[k2]);\n      nv2 = ((m[k2]-m[k1])*v[k2]+2*m[k1]*v[k1])/(m[k1]+m[k2]);\n      v[k1]=nv1;\n      v[k2]=nv2;\n      tim += r;\n}\nr = t-tim;\nfor (i=0;i<n;i++) x[i]+=v[i]*r;\nfor (i=0;i<n;i++) printf(\"%.8lf\\n\",x[i]);\nreturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "implementation", "math"], "dificulty": "2000", "interactive": false}