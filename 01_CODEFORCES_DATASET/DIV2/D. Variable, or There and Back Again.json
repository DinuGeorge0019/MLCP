{"link": "https://codeforces.com//contest/174/problem/D", "problemId": "1099", "problem_idx": "D", "shortId": "174D", "contest_number": "174", "problem_submissions": {"B": [1503930, 1499525, 1499538, 1500205, 1499258, 1499768, 1501357, 1499457, 1503985, 1505557, 1499961, 1499234, 1500331], "D": [1503363, 1501621, 1502127, 1503092, 1503245, 1503411, 1501894, 1503085, 1501903, 1500001, 1503531, 1501616, 1502373, 1502070, 1502395, 1502564, 1503108], "C": [1503107, 1508292, 1501371, 1501282, 1500969, 1500926, 1499876, 1501802, 1501230, 1502044, 1502361, 1504842, 1501563, 1501111, 1501734, 1502012], "A": [1501910, 1498466, 1498355, 1498723, 1498298, 1498576, 1498366, 1498300, 1498312, 1502389, 1498657, 1498399, 1498335, 1498390, 1499307, 1498408, 1498327, 1498514], "E": [1499649, 1502782, 1505549, 1505680, 1505679, 1505670, 1505552]}, "name": "D. Variable, or There and Back Again", "statement": "Life is not easy for the perfectly common variable named Vasya. Wherever\r\nit goes, it is either assigned a value, or simply ignored, or is being\r\nused!Vasya\u2019s life goes in states of a program. In each state, Vasya can\r\neither be used (for example, to calculate the value of another\r\nvariable), or be assigned a value, or ignored. Between some states are\r\ndirected (oriented) transitions.A is a sequence of states , where for\r\nany exists a transition from to .Vasya\u2019s value in state is interesting\r\nto the world, if exists path such, that for some , in state Vasya gets\r\nassigned a value, in state Vasya is used and there is no state (except\r\nfor ) where Vasya gets assigned a value.Help Vasya, find the states in\r\nwhich Vasya\u2019s value is interesting to the world.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include <string>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\nconst int sz = 100001;\nint a[sz];\nvector<int> G[sz], invG[sz];\nbool u1[sz], u2[sz];\n\nvoid dfs1(int x)\n{\n    u1[x] = 1;\n    for (int i = 0; i < G[x].size(); i++)\n        if (!u1[G[x][i]])\n            dfs1(G[x][i]);\n}\nvoid dfs2(int x)\n{\n    u2[x] = 1;\n    if (a[x] == 1)\n        return;\n    for (int i = 0; i < invG[x].size(); i++)\n        if (!u2[invG[x][i]])\n            dfs2(invG[x][i]);\n}\n\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n        freopen(\"input.txt\", \"rt\", stdin);\n        freopen(\"output.txt\", \"wt\", stdout);\n    #endif\n\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n    for (int i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        G[x].push_back(y);\n        invG[y].push_back(x);\n    }\n\n    for (int i = 1; i <= n; i++)\n        if (a[i] == 1 && !u1[i])\n            dfs1(i);\n    for (int i = 1; i <= n; i++)\n        if (a[i] == 2 && !u2[i])\n            dfs2(i);\n\n    for (int i = 1; i <= n; i++)\n        printf(\"%d\\n\", u1[i] && u2[i]);\n}"], "input": "", "output": "", "tags": ["graphs"], "dificulty": "1700", "interactive": false}