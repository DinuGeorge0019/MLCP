{
    "link": "https://codeforces.com//contest/2028/problem/F",
    "problemId": "3015770",
    "problem_idx": "F",
    "shortId": "2028F",
    "contest_number": "2028",
    "problem_submissions": {
        "F": [
            290935691,
            290949712,
            290955148,
            290955187,
            290957184,
            292391424
        ],
        "E": [
            290922245,
            290922480,
            290920424,
            290927233,
            290924245,
            290933073,
            290931752,
            290929839,
            290930222,
            290933477,
            290938776,
            290925205,
            290935230,
            290939685,
            290935948,
            290940043,
            290940956,
            290939742,
            290941596
        ],
        "D": [
            290914114,
            290910753,
            290911155,
            290918762,
            290914432,
            290916818,
            290919264,
            290917594,
            290919639,
            290918811,
            290925900,
            290936103,
            290915690,
            290926820,
            290971789,
            290922189,
            290916679,
            290927684,
            290928018,
            290925322
        ],
        "C": [
            290904384,
            290896368,
            290900564,
            290905625,
            290896283,
            290906809,
            290893283,
            290905680,
            290908077,
            290905220,
            290900117,
            290902591,
            290910230,
            290901329,
            290904962,
            290902731,
            290903557,
            290906063,
            290905134
        ],
        "B": [
            290895606,
            290891907,
            290894947,
            290900151,
            290892659,
            290894607,
            290903522,
            290896362,
            290901510,
            290898064,
            290894885,
            290895319,
            290897887,
            290896070,
            290896548,
            290895196,
            290898108,
            290896215
        ],
        "A": [
            290889080,
            290888110,
            290888845,
            290888449,
            290888344,
            290888834,
            290895010,
            290888416,
            290888296,
            290888948,
            290888415,
            290888738,
            290892035,
            290889212,
            290888467,
            290903576,
            290888326,
            290888321,
            290889167
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136096",
    "editorial": "Let be whether can be satisfied. Then, letâs case on . If , then (where\r\nwe will take , the indicator that ). This is because we can multiply\r\ntogether any suffix to form . We can do this in time by keeping these\r\nprefix ORs. If , then (since we donât have to worry about accidentally\r\nallowing s). This is because we can either multiply by or add .\r\nOtherwise, note that we can only multiply together at most many before\r\nthe result exceeds . So, for each let denote the biggest such that .\r\nThen, we can write where we continue until we either reach , hit , or\r\nexceed . There is one special case: if for any , then we should also\r\nallow . We can keep track of the last time and use the same prefix OR\r\nidea as above.Note that all of these operations are \"batch\" operations:\r\nthat is, we can do them for all simultaneously for a given . Thus, this\r\ngives a bitset solution in time and with space complexity . However,\r\nthis uses too much space. We can optimize the space complexity to only\r\nstore bitsets (with some extra integers) instead. To do this, note that\r\nfor the case we only require one bitset which we can update after each ,\r\nfor the case we only have to keep the previous bitset, and for the case\r\nwe only need to store the most recent bitsets for indices with . We can\r\nkeep this in a deque and pop from the back if the size exceeds . For the\r\nspecial case at the end, we can keep track of a prefix bitset for the\r\nlast occurrence of a . Overall, this uses space complexity which is\r\nsufficient (interestingly, we donât even have to store the input!)\r\n",
    "name": "F. Alice s Adventures in Addition",
    "statement": "The Cheshire Cat has a riddle for Alice: given n integers a_1, a_2,\r\nldots, a_n and a target m, is there a way to insert + and\r\ntimes into the circles of the expression a_1\r\ncirc a_2\r\ncirc\r\ncdots\r\ncirc a_n = m to make it true? We follow the usual order of operations:\r\ntimes is done before +.Although Alice is excellent at chess, she is not\r\ngood at math. Please help her so she can find a way out of Wonderland!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")#define ll long long#define ull unsigned long long#define lll __int128#define pc __builtin_popcount#define pr pair<int,int>#define pb push_back#define mp make_pair#define x first#define y second#define lb(x) x&-xusing namespace std;void read(int &X){\tX=0;\tchar cr=getchar();\twhile(cr<'0'||cr>'9') cr=getchar();\twhile(cr>='0'&&cr<='9') X=(X<<3)+(X<<1)+(cr^48),cr=getchar();}const int maxn=2e5+10,S=1e4+10,M=52;int T,n,m;int a[maxn],q[maxn],tl,tr,w[maxn];bitset<S> s[M],s0,sm,e;int nc[M],tot;int calc(){    tot++;    s[nc[tot]].reset();    return nc[tot];}void del(int &p){    if(!p)return;    nc[tot--]=p,p=0;}int main(){    //freopen(\".in\",\"r\",stdin);    //freopen(\".out\",\"w\",stdout);    read(T);    while(T--)\t{        read(n),read(m),tot=0;        for(int i=1;i<=n;i++) read(a[i]);        for(int i=1;i<M;i++) nc[i]=i;        s0.reset(),q[tl=tr=1]=calc(),s[q[1]][0]=1,w[q[1]]=1,sm.reset();        for(int i=1;i<=n;i++)\t\t{            for(int j=tl;j<=tr;j++) w[q[j]]*=a[i];            if(!a[i]) s0|=sm,sm.reset();            while(tl<=tr)\t\t\t{                if(w[q[tl]]>m) sm|=s[q[tl]],del(q[tl]),tl++;                else if(!w[q[tl]]) s0|=s[q[tl]],del(q[tl]),tl++;                else break;            }            e=s0;            for(int j=tl;j<=tr;j++) e|=(s[q[j]]<<w[q[j]]);            if(tl<=tr&&1==w[q[tr]]) s[q[tr]]|=e;            else q[++tr]=calc(),w[q[tr]]=1,s[q[tr]]=e;        }        printf((e[m]==1)?\"YES\\n\":\"NO\\n\");    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Alice s Adventures in Addition.json",
    "hint": [
        "Hint 1 Come up with a DP algorithm running in time .",
        "Hint 2 Try optimizing the Hint 1 DP to run in time when for all .",
        "Hint 3 Do some casework to extend Hint 2 to .",
        "Hint 4 Bitset"
    ]
}