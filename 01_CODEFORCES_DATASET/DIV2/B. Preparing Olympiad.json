{
    "link": "https://codeforces.com//contest/550/problem/B",
    "problemId": "28712",
    "problem_idx": "B",
    "shortId": "550B",
    "contest_number": "550",
    "problem_submissions": {
        "E": [
            11427018,
            11429644,
            11432526,
            11430611,
            11432228,
            11432165,
            11489207,
            11427558,
            11432275,
            11429524,
            11432478,
            11432415,
            11430446,
            11486308
        ],
        "D": [
            11423745,
            11423796,
            11427878,
            11431814,
            11429565,
            11429723,
            11427594,
            11427339,
            11431790,
            11428771,
            11426823,
            11429779,
            11429172,
            11429089,
            11430041
        ],
        "C": [
            11421138,
            11416776,
            11423192,
            11422512,
            11424510,
            11421428,
            11421418,
            11420140,
            11434273,
            11422988,
            11421940,
            11421776,
            11433710,
            11424080,
            11421277,
            11423080,
            11425605
        ],
        "B": [
            11420010,
            11420534,
            11419884,
            11420795,
            11419465,
            11418370,
            11419003,
            11418791,
            11421152,
            11420042,
            11419639,
            11419437,
            11420868,
            11422488,
            11419737,
            11424665,
            11422066,
            11422524
        ],
        "A": [
            11417030,
            11416689,
            11417915,
            11416872,
            11429128,
            11417246,
            11416778,
            11416762,
            11416557,
            11416626,
            11434617,
            11421161,
            11417521,
            11420430,
            11419146
        ]
    },
    "name": "B. Preparing Olympiad",
    "statement": "You have problems. You have estimated the difficulty of the -th one as\r\ninteger . Now you want to prepare a problemset for a contest, using some\r\nof the problems you\u2019ve made.A problemset for the contest must consist of\r\nat least two problems. You think that the total difficulty of the\r\nproblems of the contest must be at least and at most . Also, you think\r\nthat the difference between difficulties of the easiest and the hardest\r\nof the chosen problems must be at least .Find the number of ways to\r\nchoose a problemset for the contest.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-9;\nconst int oo = 0x3f3f3f3;\nconst int MAXN = (int)1e5 + 10;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, l, r, x;\n    cin >> n >> l >> r >> x;\n\n    vector<int> V(n);\n\n    for (int i = 0; i < n; ++i)\n        cin >> V[i];\n\n    sort(V.begin(), V.end());\n\n    int ans = 0;\n\n    for (int i = 1; i < (1 << n); ++i){\n        if ( (i & (i - 1)) == 0) continue;\n        int tot = 0;\n        int mn = V[n - 1], mx = V[0];\n        for (int j = 0; j < n; ++j){\n            if (i & (1 << j))\n            {\n                tot += V[j];\n                mn = min(mn, V[j]);\n                mx = max(mx, V[j]);\n            }\n        }\n        if (l <= tot && tot <= r && mx - mn >= x)\n            ++ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Preparing Olympiad.json",
    "editorial_link": "https://codeforces.com/blog/entry/18329",
    "editorial": "Because of the low constraints, this problem can be solved by complete\r\nsearch over all problem sets (there are of them). For every potential\r\nproblem set (which can be conviniently expressed as bit mask) we need to\r\ncheck if it satisfies all needed criteria. We can simply find the sum of\r\nproblem complexities and also the difference between the most difficult\r\nand the easiest problems in linear time, iterating over the problems\r\nthat we included in our current set/bitmask. If this problem set can be\r\nused, we increase the answer by one. Complexity of this solution is .\r\n"
}