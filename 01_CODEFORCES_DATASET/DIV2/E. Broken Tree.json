{"link": "https://codeforces.com//contest/758/problem/E", "problemId": "89339", "problem_idx": "E", "shortId": "758E", "contest_number": "758", "problem_submissions": {"F": [23961911, 23961832, 23965370, 23967077, 23964444, 23962828, 23961458, 23959907, 23962385, 23972421, 23961385], "E": [23961199, 23969660], "D": [23954905, 23959005, 23958687, 23961234, 23966280, 23981466, 23957019, 23970497, 23990624, 23958899, 23958219, 23957228, 23958436, 23958155], "C": [23954486, 23955509, 23955744, 23956366, 23958572, 23953897, 23975736, 23955059, 23956120, 23952427, 23952244, 23955152, 23953675, 23954430, 23955137, 23954127, 23955341, 23955536, 23969442, 23966778], "B": [23949178, 23953141, 23951861, 23953552, 23951433, 23950823, 23950433, 23961140, 23952985, 23949054, 23949507, 23952101, 23950424, 23951944, 23951182, 23950619, 23951222, 23951421, 23953877], "A": [23947216, 23950206, 23947310, 23949396, 23949600, 23947716, 23947436, 23947618, 23948628, 23947219, 23947297, 23948336, 23948103, 23948298, 23947546, 23947915, 23948934, 23948465]}, "name": "E. Broken Tree", "statement": "You are given a tree that has vertices, which are numbered from to ,\r\nwhere the vertex number one is the root. Each edge has weight and\r\nstrength .Botanist Innokentiy, who is the only member of the jury of the\r\nOlympiad in Informatics, doesn\u2019t like broken trees. The tree is broken\r\nif there is such an edge the strength of which is less than the sum of\r\nweight of subtree\u2019s edges to which it leads.It is allowed to reduce\r\nweight of any edge by arbitrary integer value, but then the strength of\r\nits edge is reduced by the same value. It means if the weight of the\r\nedge is , and the strength is , then by the reducing the weight by its\r\nweight will equal , and the strength will equal . It is not allowed to\r\nincrease the weight of the edge.Your task is to get the tree, which is\r\nnot broken, by reducing the weight of edges of the given tree, and also\r\nall edged should have the positive weight, moreover, the total weight of\r\nall edges should be as large as possible.It is obvious that the strength\r\nof edges can not be negative, however it can equal zero if the weight of\r\nthe subtree equals zero.\r\n", "solutions": ["#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n#define rep(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nconst ll INF = 1e18;\n\nll n, x, y, w, p, sum[N], sz[N];\n\nll can[N];\n\nstruct EDGE\n{\n\tll x, y, w, p;\n\tll mw, mp;\n} edge[N];\n\nvector<ll> g[N], we[N], pe[N];\n\ninline void calc(ll v, ll p = -1)\n{\n\tfor(ll i = 0 ; i < g[v].size() ; ++ i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tcalc(to, v);\n\t\tif(pr < can[to])\n\t\t{\n\t\t\tcout << -1;\n\t\t\texit(0);\n\t\t}\n\t\tll er = min(weight - 1, pr - can[to]);\n\t\tedge[id].w -= er;\n\t\tedge[id].p -= er;\n\t\tcan[v] += can[to] + edge[id].w;\n\t}\n}\n\ninline ll solve(int v, int p = -1, ll canadd = 2e18)\n{\n\tll ret = 0;\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tll er = edge[id].mw - edge[id].w;\n\t\tll cancuradd = min(canadd - ret, er);\n\t\tedge[id].w += cancuradd;\n\t\tedge[id].p += cancuradd;\n\t\tret += cancuradd;\n\t}\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tll mn = pr - can[to];\n\t\tret += solve(to, v, min(mn, canadd - ret));\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(ll i=1;i<n;++i)\n\t{\n\t\tcin>>x>>y>>w>>p;\n\t\tint id = i;\n\t\tg[x].pb(id);\n\t\tg[y].pb(id);\n\t\tedge[id].x = x;\n\t\tedge[id].y = y;\n\t\tedge[id].mp = p;\n\t\tedge[id].mw = w;\n\t\tedge[id].w = w;\n\t\tedge[id].p = p;\n\t}\n\tcalc(1);\n\tsolve(1);\n\tcout << n << \"\\n\";\n\tfor(ll i = 1; i < n; ++i)\n\t\tcout << edge[i].x << ' ' << edge[i].y << ' ' << edge[i].w << ' ' << edge[i].p << \"\\n\";\n\treturn 0;\t\n}                                      \t"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "greedy", "trees"], "dificulty": "2600", "interactive": false}