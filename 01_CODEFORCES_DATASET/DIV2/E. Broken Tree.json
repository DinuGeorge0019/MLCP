{
    "link": "https://codeforces.com//contest/758/problem/E",
    "problemId": "89339",
    "problem_idx": "E",
    "shortId": "758E",
    "contest_number": "758",
    "problem_submissions": {
        "F": [
            23961911,
            23961832,
            23965370,
            23967077,
            23964444,
            23962828,
            23961458,
            23959907,
            23962385,
            23972421,
            23961385
        ],
        "E": [
            23961199,
            23969660
        ],
        "D": [
            23954905,
            23959005,
            23958687,
            23961234,
            23966280,
            23981466,
            23957019,
            23970497,
            23990624,
            23958899,
            23958219,
            23957228,
            23958436,
            23958155
        ],
        "C": [
            23954486,
            23955509,
            23955744,
            23956366,
            23958572,
            23953897,
            23975736,
            23955059,
            23956120,
            23952427,
            23952244,
            23955152,
            23953675,
            23954430,
            23955137,
            23954127,
            23955341,
            23955536,
            23969442,
            23966778
        ],
        "B": [
            23949178,
            23953141,
            23951861,
            23953552,
            23951433,
            23950823,
            23950433,
            23961140,
            23952985,
            23949054,
            23949507,
            23952101,
            23950424,
            23951944,
            23951182,
            23950619,
            23951222,
            23951421,
            23953877
        ],
        "A": [
            23947216,
            23950206,
            23947310,
            23949396,
            23949600,
            23947716,
            23947436,
            23947618,
            23948628,
            23947219,
            23947297,
            23948336,
            23948103,
            23948298,
            23947546,
            23947915,
            23948934,
            23948465
        ]
    },
    "name": "E. Broken Tree",
    "statement": "You are given a tree that has vertices, which are numbered from to ,\r\nwhere the vertex number one is the root. Each edge has weight and\r\nstrength .Botanist Innokentiy, who is the only member of the jury of the\r\nOlympiad in Informatics, doesn\u2019t like broken trees. The tree is broken\r\nif there is such an edge the strength of which is less than the sum of\r\nweight of subtree\u2019s edges to which it leads.It is allowed to reduce\r\nweight of any edge by arbitrary integer value, but then the strength of\r\nits edge is reduced by the same value. It means if the weight of the\r\nedge is , and the strength is , then by the reducing the weight by its\r\nweight will equal , and the strength will equal . It is not allowed to\r\nincrease the weight of the edge.Your task is to get the tree, which is\r\nnot broken, by reducing the weight of edges of the given tree, and also\r\nall edged should have the positive weight, moreover, the total weight of\r\nall edges should be as large as possible.It is obvious that the strength\r\nof edges can not be negative, however it can equal zero if the weight of\r\nthe subtree equals zero.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n#define rep(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nconst ll INF = 1e18;\n\nll n, x, y, w, p, sum[N], sz[N];\n\nll can[N];\n\nstruct EDGE\n{\n\tll x, y, w, p;\n\tll mw, mp;\n} edge[N];\n\nvector<ll> g[N], we[N], pe[N];\n\ninline void calc(ll v, ll p = -1)\n{\n\tfor(ll i = 0 ; i < g[v].size() ; ++ i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tcalc(to, v);\n\t\tif(pr < can[to])\n\t\t{\n\t\t\tcout << -1;\n\t\t\texit(0);\n\t\t}\n\t\tll er = min(weight - 1, pr - can[to]);\n\t\tedge[id].w -= er;\n\t\tedge[id].p -= er;\n\t\tcan[v] += can[to] + edge[id].w;\n\t}\n}\n\ninline ll solve(int v, int p = -1, ll canadd = 2e18)\n{\n\tll ret = 0;\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tll er = edge[id].mw - edge[id].w;\n\t\tll cancuradd = min(canadd - ret, er);\n\t\tedge[id].w += cancuradd;\n\t\tedge[id].p += cancuradd;\n\t\tret += cancuradd;\n\t}\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tll mn = pr - can[to];\n\t\tret += solve(to, v, min(mn, canadd - ret));\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(ll i=1;i<n;++i)\n\t{\n\t\tcin>>x>>y>>w>>p;\n\t\tint id = i;\n\t\tg[x].pb(id);\n\t\tg[y].pb(id);\n\t\tedge[id].x = x;\n\t\tedge[id].y = y;\n\t\tedge[id].mp = p;\n\t\tedge[id].mw = w;\n\t\tedge[id].w = w;\n\t\tedge[id].p = p;\n\t}\n\tcalc(1);\n\tsolve(1);\n\tcout << n << \"\\n\";\n\tfor(ll i = 1; i < n; ++i)\n\t\tcout << edge[i].x << ' ' << edge[i].y << ' ' << edge[i].w << ' ' << edge[i].p << \"\\n\";\n\treturn 0;\t\n}                                      \t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Broken Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/49880",
    "editorial": "First, let\u00e2\u0080\u0099s calculate min and max weight for subtrees of each\r\nvertex.Minimal weight of a subtree is sum of minimal weights of all\r\nadjacent to the root of current subtree subtrees and sum of weights of\r\nall outgoing edges reduced in weight to minimal possible.Thus, minimal\r\nweight is , where subtree root, number of outgoing edges from , each\r\nadjacent to vertex, its strength, its weight.Note that minimal weight\r\nshould be less or equal to strength of incoming edge. If this condition\r\nisn\u00e2\u0080\u0099t satisfied for at least one subtree then the answer is .Maximal\r\nweight of a subtree is sum of maximal weights of all adjacent to the\r\nroot of current subtree subtrees and sum of weights of all outgoing\r\nedges. Note that this maximum should stay in such boundaries that the\r\ntree remains unbroken. So maximal weight should not exceed strength of\r\nincoming edge of a root.Therefore, maximum is , where subtree root,\r\nweight of an incoming edge of , that is -th edge outgoing from some\r\nvertex , number of outgoing edges from , each adjacent to vertex, its\r\nweight.After that, let\u00e2\u0080\u0099s calculate current weight of every subtree to\r\nfind difference between actual value and the optimal one. Weight of\r\nsubtree is sum of weights of all adjacent to the root of current subtree\r\nsubtrees and sum of weights of all outgoing edges.Then actual weight is\r\n, where subtree root, number of outgoing edges from , each adjacent to\r\nvertex, its weight.One dfs from the root of the tree is enough to\r\ncalculate all these values.Note that , and are set to for leaves . is\r\nmaximal possible weight of each subtree, so weight of the whole tree can\r\nbe reduced to , it means that weight of subtree of vertex should be\r\nreduced by .Next goal is to learn how to reduce weight of subtree of\r\nvertex by units. At first, you should reduce weights of subtrees of\r\nadjacent to vertices to their maximum. So after this step . Then while ,\r\nreduce weight of each next subtree. If it\u00e2\u0080\u0099s still then reduce weights of\r\noutgoing edges from maintaining unbroken state of tree.This process also\r\ntakes one dfs.Overall complexity is the complexity of two dfs calls,\r\nthat is .\r\n"
}