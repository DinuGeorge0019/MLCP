{"link": "https://codeforces.com//contest/635/problem/F", "problemId": "49959", "problem_idx": "F", "shortId": "635F", "contest_number": "635", "problem_submissions": {"F": [16715109, 16429856], "E": [16413519, 16414980, 16415683, 16413671, 16416127, 16415965, 16412886, 16411309, 16414895, 16431030, 16415653, 16557734], "D": [16411390, 16412670, 16411204, 16413229, 16412878, 16413863, 16411883, 16412667, 16409842, 16411803, 16408893, 16411766, 16411437, 16412231, 16411782, 16413499, 16413108], "C": [16410177, 16409314, 16412788, 16419061, 16414730, 16411184, 16411076, 16417490, 16413342, 16420377, 16409924, 16410108, 16409728, 16410259, 16410185, 16410892], "A": [16409333, 16408548, 16407902, 16407920, 16407765, 16408000, 16407909, 16408814, 16407724, 16408398, 16412714, 16407922, 16407797, 16408056, 16414324, 16407823, 16407862], "B": [16408961, 16410486, 16409109, 16409265, 16408639, 16409212, 16408803, 16414234, 16408509, 16409385, 16408280, 16408866, 16408225, 16408994, 16407968, 16409084, 16408701]}, "name": "F. Preorder Test", "statement": "For his computer science class, Jacob builds a model tree with sticks\r\nand balls containing nodes in the shape of a tree. Jacob has spent\r\nminutes building the -th ball in the tree.Jacob\u2019s teacher will evaluate\r\nhis model and grade Jacob based on the effort he has put in. However,\r\nshe does not have enough time to search his whole tree to determine\r\nthis; Jacob knows that she will examine the first nodes in a DFS-order\r\ntraversal of the tree. She will then assign Jacob a grade equal to the\r\nminimum she finds among those nodes.Though Jacob does not have enough\r\ntime to rebuild his model, he can choose the root node that his teacher\r\nstarts from. Furthermore, he can rearrange the list of neighbors of in\r\nany order he likes. Help Jacob find the best grade he can get on this\r\nassignment.A DFS-order traversal is an ordering of the nodes of a rooted\r\ntree, built by a recursive DFS-procedure initially called on the root of\r\nthe tree. When called on a given node , the procedure does the\r\nfollowing: Print . Traverse the list of neighbors of the node in order\r\nand iteratively call DFS-procedure on each one. Do not call\r\nDFS-procedure on node if you came to node directly from .\r\n", "solutions": ["#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N = 2e5 + 5, M = 1e6 + 5;\nint a[N], n, m;\nint full[N], b1[N], b2[N];\nint sz[N], ans;\nbool ava[N];\nvector<int> G[N];\nint dfs0(int x, int p)\n{\n\tsz[x] = 1;\n\tfor (int u : G[x])\n\t{\n\t\tif (u == p) continue;\n\t\tsz[x] += dfs0(u, x);\n\t}\n\treturn sz[x];\n}\nvoid dfs1(int x, int p)\n{\n\tfull[x] = b1[x] = b2[x] = 0;\n\tfor (int u : G[x])\n\t{\n\t\tif (u == p) continue;\n\t\tdfs1(u, x);\n\t\tif (full[u] == sz[u])\n\t\t{\n\t\t\tfull[x] += full[u];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b1[x] < full[u])\n\t\t\t{\n\t\t\t\tb2[x] = b1[x];\n\t\t\t\tb1[x] = full[u];\n\t\t\t}\n\t\t\telse if (b2[x] < full[u])\n\t\t\t{\n\t\t\t\tb2[x] = full[u];\n\t\t\t}\n\t\t}\n\t}\n\tif (!ava[x]) full[x] = 0; else full[x] += 1 + b1[x];\n}\nvoid dfs2(int x, int p, int ufull, int usz)\n{\n\tfull[x] -= b1[x];\n\tif (ufull == usz)\n\t{\n\t\tfull[x] += usz;\n\t}\n\telse\n\t{\n\t\tif (b1[x] < ufull)\n\t\t{\n\t\t\tb2[x] = b1[x];\n\t\t\tb1[x] = ufull;\n\t\t}\n\t\telse if (b2[x] < ufull)\n\t\t{\n\t\t\tb2[x] = ufull;\n\t\t}\n\t}\n\tif (!ava[x])\n\t{\n\t\tb1[x] = b2[x] = full[x] = 0;\n\t}\n\telse\n\t{\n\t\tans = max(ans, full[x] + b1[x]);\n\t}\n\tfor (int u : G[x])\n\t{\n\t\tif (u == p) continue;\n\t\tint tmp = b1[x];\n\t\tif (full[u] == tmp) tmp = b2[x];\n\t\tif (full[u] == sz[u]) tmp -= sz[u];\n\t\tdfs2(u, x, full[x] + tmp, n - sz[u]);\n\t}\n}\nbool calc(int mid)\n{\n\tfor (int i = 1; i <= n; ++ i) ava[i] = a[i] >= mid;\n\tdfs1(1, 0);\n\tans = 0;\n\tdfs2(1, 0, 0, 0);\n\treturn ans >= m;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i < n; ++ i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs0(1, 0);\n\tint ans = 0, L = 0, R = M;\n\twhile (L <= R)\n\t{\n\t\tint mid = (L + R) >> 1;\n\t\tif (calc(mid))\n\t\t{\n\t\t\tans = mid;\n\t\t\tL = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tR = mid - 1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "dfs and similar", "graphs", "greedy"], "dificulty": "2600", "interactive": false}