{
    "link": "https://codeforces.com//contest/1104/problem/E",
    "problemId": "286144",
    "problem_idx": "E",
    "shortId": "1104E",
    "contest_number": "1104",
    "problem_submissions": {
        "E": [
            48758453,
            48757745,
            48860407,
            48894452
        ],
        "D": [
            48749288,
            48751393,
            48739522,
            48739394,
            48740563,
            48754038,
            48739408,
            48740821,
            48748481,
            48742803,
            48738301,
            48739495,
            48742984,
            48743793,
            48784753,
            48777626,
            48748805,
            48747430,
            48746053,
            48743794,
            48744017
        ],
        "B": [
            48730862,
            48734922,
            48725853,
            48727408,
            48724591,
            48727896,
            48729302,
            48727214,
            48728799,
            48726973,
            48729023,
            48725831,
            48730076,
            48728780,
            48725458,
            48730157,
            48728034,
            48724532,
            48732794
        ],
        "C": [
            48740971,
            48728632,
            48731211,
            48727173,
            48731021,
            48734041,
            48734825,
            48733419,
            48733357,
            48732320,
            48729298,
            48733894,
            48732918,
            48730070,
            48735185,
            48732353,
            48732560,
            48733524
        ],
        "A": [
            48730201,
            48723824,
            48724179,
            48723533,
            48724165,
            48726185,
            48724880,
            48724445,
            48724599,
            48730100,
            48723532,
            48725656,
            48724536,
            48723661,
            48725183,
            48724389,
            48723526,
            48730308
        ]
    },
    "name": "E. Johnny Solving",
    "statement": "Today is tuesday, that means there is a dispute in JOHNNY SOLVING team\r\nagain: they try to understand who is Johnny and who is Solving. That’s\r\nwhy guys asked Umnik to help them. Umnik gave guys a connected graph\r\nwith n vertices without loops and multiedges, such that a degree of any\r\nvertex is at least 3, and also he gave a number 1\r\nleq k\r\nleq n. Because Johnny is not too smart, he promised to find a simple\r\npath with length at least\r\nfrac{n}{k} in the graph. In reply, Solving promised to find k simple by\r\nvertices cycles with representatives, such that: Length of each cycle is\r\nat least 3. Length of each cycle is not divisible by 3. In each cycle\r\nmust be a representative - vertex, which belongs only to this cycle\r\namong all cycles. You need to help guys resolve the dispute, for that\r\nyou need to find a solution for Johnny: a simple path with length at\r\nleast\r\nfrac{n}{k} (n is not necessarily divided by k), or solution for Solving:\r\nk cycles that satisfy all the conditions above. If there is no any\r\nsolution - print -1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef __LOCAL_DEBUG__\n# define _debug(fmt, ...) fprintf(stderr, \"\\033[94m%s: \" fmt \"\\n\\033[0m\", \\\n    __func__, ##__VA_ARGS__)\n#else \n# define _debug(...) ((void) 0)\n#endif\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define Rep(i, n) for (int i=1; i<=(n); i++)\n#define range(x) begin(x), end(x)\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nint n, m, k, l;\nvector<int> adj[1 << 18];\nint fa[1 << 18], dep[1 << 18];\nbool leaf[1 << 18];\n\nvoid dfs(int u, int p, int d) {\n    dep[u] = d; fa[u] = p;\n    leaf[u] = true;\n    for (int v : adj[u]) {\n        if (dep[v]) continue;\n        dfs(v, u, d + 1);\n        leaf[u] = false;\n    }\n}\n\nvector<vector<int>> cyc;\n\nvector<int> construct_cyc(int u, int f1, \n        const vector<int> &up, const vector<int> &down) {\n    vector<int> ret; ret.push_back(u);\n    ret.insert(ret.end(), range(up));\n    ret.push_back(f1);\n    ret.insert(ret.end(), down.rbegin(), down.rend());\n    assert(ret.size() % 3);\n    return ret;\n}\n\nvector<int> getcyc(int u) {\n    int num = 0;\n    int f[2], f0, f1;\n    for (int v : adj[u]) {\n        if (v == fa[u]) continue;\n        f[num++] = v;\n        if (num == 2) break;\n    }\n    assert(num == 2);\n    f0 = f[0], f1 = f[1];\n    if (dep[f0] > dep[f1]) swap(f0, f1);\n    vector<int> b[3];\n    int v = fa[u];\n    while (v != f1) b[1].push_back(v), v = fa[v];\n    v = fa[f1]; b[2].push_back(f0);\n    while (v != f0) b[2].push_back(v), v = fa[v];\n    reverse(b[2].begin() + 1, b[2].end());\n    rep (i, 3) {\n        int x = i, y = (i + 1) % 3;\n        if ((b[x].size() + b[y].size() + 2) % 3) {\n            return construct_cyc(u, f1, b[x], b[y]);\n        }\n    }\n    assert(0);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &k);\n    l = (n + k - 1) / k;\n    rep (i, m) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    dfs(1, 0, 1);\n    \n    Rep (u, n) {\n        if (dep[u] >= l) {\n            printf(\"PATH\\n\");\n            printf(\"%d\\n\", dep[u]);\n            while (u) {\n                printf(\"%d \", u);\n                u = fa[u];\n            }\n            return 0;\n        }\n        if (cyc.size() < k and leaf[u]) cyc.push_back(getcyc(u));\n    }\n\n    printf(\"CYCLES\\n\");\n    for (auto& c : cyc) {\n        printf(\"%d\\n\", (int)c.size());\n        for (int v : c) printf(\"%d \", v);\n        puts(\"\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Johnny Solving.json",
    "editorial_link": "https://codeforces.com//blog/entry/64722",
    "editorial": "Letâs build a dfs spanning tree from the vertex and find the depth of\r\nthe tree. If the depth is at least then we can just print the path from\r\nthe root to the deepest vertex.Otherwise, there will be at least leaves\r\nin the tree. Letâs prove it. Consider a tree with leaves, after that\r\nconsider a path from a particular leaf to the root, letâs denote length\r\nof -th path (in vertices) by . We can say that , because every\r\nparticular vertex in the tree will be covered by one of pathways. So,\r\nusing Dirichletâs principle we can say that . Hence, depth of the tree\r\nis at least .Now, consider a leaf in our spanning tree, letâs denote it\r\nlike . This leaf has at least 2 back edges (edges which connected with\r\none of ancestors), letâs denote ancestors like and . Obviosly, we have\r\nthree cycles here: path from to with corresponding back edge, the same\r\ncycle from to , and path between and with two back edges connected with\r\n. Lengths of these cycles are , and , where - distance between vertices\r\na and b. Itâs clear that one of these numbers is not divisible by three.\r\nLast problem is to choose representative - we should choose leaves. Size\r\nof output is not exceed because the depth of our tree at most and each\r\ncycle has length .\r\n",
    "hint": []
}