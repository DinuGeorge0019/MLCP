{
    "link": "https://codeforces.com//contest/1848/problem/E",
    "problemId": "2046242",
    "problem_idx": "E",
    "shortId": "1848E",
    "contest_number": "1848",
    "problem_submissions": {
        "E": [
            214078806,
            214088202,
            214079632,
            214087057,
            214086323,
            214083544,
            214090057,
            214082643,
            214094277,
            214095285,
            214705225
        ],
        "F": [
            214070984,
            214075949,
            214084495,
            214080175,
            214065714,
            214087986,
            214082128,
            214076389,
            214084949,
            214073421,
            214060099,
            214088437,
            214086968,
            214091347,
            214089467,
            214079366
        ],
        "D": [
            214068277,
            214064922,
            214070767,
            214068735,
            214079075,
            214069131,
            214069700,
            214066329,
            214075678,
            214084591,
            214097754,
            214075100,
            214072308,
            214074287,
            214061875,
            214091346
        ],
        "C": [
            214056697,
            214056251,
            214061525,
            214059146,
            214071785,
            214061591,
            214056000,
            214073174,
            214063820,
            214060194,
            214078312,
            214056865,
            214065402,
            214062471,
            214092811,
            214062217
        ],
        "B": [
            214052297,
            214051762,
            214052731,
            214053122,
            214056975,
            214052187,
            214052073,
            214064615,
            214054312,
            214052430,
            214052268,
            214050368,
            214053885,
            214053048,
            214051754,
            214051131
        ],
        "A": [
            214049674,
            214048967,
            214049923,
            214049713,
            214052070,
            214049845,
            214048850,
            214050906,
            214049091,
            214049973,
            214049534,
            214049002,
            214049762,
            214049567,
            214049272,
            214049415
        ]
    },
    "name": "E. Vika and Stone Skipping",
    "statement": "In Vika’s hometown, Vladivostok, there is a beautiful sea.Often you can\r\nsee kids skimming stones. This is the process of throwing a stone into\r\nthe sea at a small angle, causing it to fly far and bounce several times\r\noff the water surface.Vika has skimmed stones many times and knows that\r\nif you throw a stone from the shore perpendicular to the coastline with\r\na force of f, it will first touch the water at a distance of f from the\r\nshore, then bounce off and touch the water again at a distance of f - 1\r\nfrom the previous point of contact. The stone will continue to fly in a\r\nstraight line, reducing the distances between the points where it\r\ntouches the water, until it falls into the sea.Formally, the points at\r\nwhich the stone touches the water surface will have the following\r\ncoordinates: f, f + (f - 1), f + (f - 1) + (f - 2), ... , f + (f - 1) +\r\n(f - 2) +\r\nldots + 1 (assuming that 0 is the coordinate of the shoreline).Once,\r\nwhile walking along the embankment of Vladivostok in the evening, Vika\r\nsaw a group of guys skipping stones across the sea, launching them from\r\nthe same point with different forces.She became interested in what is\r\nthe maximum number of guys who can launch a stone with their force f_i,\r\nso that all f_i are , and all n stones touched the water at the point\r\nwith the coordinate x (assuming that 0 is the coordinate of the\r\nshoreline).After thinking a little, Vika answered her question. After\r\nthat, she began to analyze how the answer to her question would change\r\nif she multiplied the coordinate x by some positive integers x_1, x_2,\r\n... , x_q, which she picked for analysis.Vika finds it difficult to cope\r\nwith such analysis on her own, so she turned to you for help.Formally,\r\nVika is interested in the answer to her question for the coordinates X_1\r\n= x\r\ncdot x_1, X_2 = X_1\r\ncdot x_2, ... , X_q = X_{q-1}\r\ncdot x_q. Since the answer for such coordinates can be quite large, find\r\nit modulo M.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int N = 1 << 22;\n\nvector<int> pr;\nint lpd[N], cnt[N], inv[N], cnt2;\nint x, q, mod;\nint mul(int x, int y) {return ((1ll * x) * y) % mod;}\nint Pow(int x, int y) {int res = 1; for (; y; x = mul(x, x), y >>= 1) if (y & 1) res = mul(res, x); return res;}\n\nint val, zero;\n\nvoid ins(int p) {\n    if (p == 2) {\n        cnt2++;\n        return;\n    }\n    int val2 = 1, zero2 = 0;\n    int tmp = cnt[p] + 1;\n    while (tmp % mod == 0) tmp /= mod, zero2++;\n    val2 = tmp % mod;\n    val = mul(val, inv[val2]), zero -= zero2;\n    cnt[p]++;\n    tmp = cnt[p] + 1;\n    val2 = 1, zero2 = 0;\n    while (tmp % mod == 0) tmp /= mod, zero2++;\n    val2 = tmp % mod;\n    val = mul(val, val2), zero += zero2;\n}\n\nvoid frank() {\n    memset(lpd, -1, sizeof lpd);\n    for (int i = 2; i < N; ++i) {\n        if (lpd[i] == -1) lpd[i] = i, pr.pb(i);\n        for (auto p: pr) {\n            if (p * i >= N) break;\n            lpd[p * i] = p;\n            if (i % p == 0) break;\n        }\n    }\n    cin >> x >> q >> mod;\n    inv[1] = 1;\n    for (int i = 2; i < N; ++i) inv[i] = mul(inv[mod % i], mod - mod / i);\n    val = 1, zero = 0;\n    for (auto p: pr) {\n        if (p * p > x) break;\n        while (x % p == 0) {\n            ins(p);\n            x /= p;\n        }\n    }\n    if (x >= N) val = mul(val, 2);\n    else if(x > 1) ins(x);\n    while (q--) {\n        cin >> x;\n        while (x > 1) {\n            int p = lpd[x];\n            ins(p);\n            x /= p;\n        }\n        cout << (zero ? 0 : val) << \"\\n\";\n    }\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while (t--) {\n        frank();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Vika and Stone Skipping.json",
    "editorial_link": "https://codeforces.com//blog/entry/118333",
    "editorial": "The key observation is that the answer for coordinate is the number of\r\nodd divisors of . Letâs prove this.Letâs see how far a pebble will fly\r\nwith force , which touches the water times: . If is even, then , where .\r\nIn this case, the condition is necessary, which is equivalent to .If is\r\nodd, then , where . Thus, the necessary condition is equivalent to\r\n.Therefore, for each odd divisor of the number , we can uniquely\r\nassociate one of the decomposition options, and hence the number of\r\npossible answers is exactly equal to the number of different odd\r\ndivisors in the factorization of the number .Using this observation, it\r\nis easy to obtain the answer. We will maintain the power of each prime\r\nnumber in the current coordinate. The answer is the product of (powers\r\n). In order to quickly understand how these quantities change, we will\r\npre-calculate the factorization of all numbers from to . Then the query\r\ncan be processed by quickly recalculating the powers using the\r\npre-calculated factorizations.\r\n",
    "hint": []
}