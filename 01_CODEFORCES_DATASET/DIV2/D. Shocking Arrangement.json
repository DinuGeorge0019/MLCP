{
    "link": "https://codeforces.com//contest/1798/problem/D",
    "problemId": "1849270",
    "problem_idx": "D",
    "shortId": "1798D",
    "contest_number": "1798",
    "problem_submissions": {
        "F": [
            199301449,
            199635259,
            199378902,
            199319392,
            199574998,
            200590796,
            199735470,
            201129046,
            199317594
        ],
        "E": [
            199292979,
            199351345,
            199287102,
            199284185,
            199288971,
            199287988,
            199287959,
            199291669,
            199576167,
            199283535,
            199289650,
            199290902,
            199290821,
            199293377,
            199290100,
            199289126,
            199294280,
            199294488,
            199296355,
            199291720,
            199292702,
            199291551
        ],
        "C": [
            199282234,
            199260342,
            199262167,
            199263273,
            199268067,
            199264515,
            199261766,
            199308981,
            199268218,
            199266685,
            199267420,
            199260005,
            199259528,
            199264427,
            199273339,
            199266427,
            199263028,
            199263300,
            199265190,
            199268521,
            199269803
        ],
        "D": [
            199278441,
            199265876,
            199269760,
            199267498,
            199271957,
            199278028,
            199268206,
            199270707,
            199275816,
            199273016,
            199267038,
            199269245,
            199274308,
            199265125,
            199274313,
            199269059,
            199272118,
            199273321,
            199275125,
            199279668
        ],
        "B": [
            199256261,
            199253517,
            199260386,
            199254659,
            199254149,
            199255531,
            199254513,
            199253333,
            199254612,
            199260900,
            199256259,
            199253472,
            199256316,
            199258434,
            199255694,
            199256525,
            199257662,
            199261042,
            199260517
        ],
        "A": [
            199251141,
            199251302,
            199252305,
            199251756,
            199251041,
            199252000,
            199251140,
            199251087,
            199251123,
            199252263,
            199256364,
            199250912,
            199252253,
            199253426,
            199251686,
            199251495,
            199253540,
            199253141,
            199252510
        ]
    },
    "name": "D. Shocking Arrangement",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n consisting of integers such that a_1 + a_2 +\r\nldots + a_n = 0.You have to rearrange the elements of the array a so\r\nthat the following condition is satisfied:\r\nmax\r\nlimits_{1\r\nle l\r\nle r\r\nle n}\r\nlvert a_l + a_{l+1} +\r\nldots + a_r\r\nrvert <\r\nmax(a_1, a_2,\r\nldots, a_n) -\r\nmin(a_1, a_2,\r\nldots, a_n), where |x| denotes the absolute value of x.More formally,\r\ndetermine if there exists a permutation p_1, p_2,\r\nldots, p_n that for the array a_{p_1}, a_{p_2},\r\nldots, a_{p_n}, the condition above is satisfied, and find the\r\ncorresponding array.Recall that the array p_1, p_2,\r\nldots, p_n is called a permutation if for each integer x from 1 to n\r\nthere is exactly one i from 1 to n such that p_i = x.\r\n",
    "solutions": [
        "#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"Ofast,unroll-loops\")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline \"\\n\"                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<\" \"; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<\"{\"; _print(p.first);cerr<<\",\"; _print(p.second);cerr<<\"}\";}\ntemplate<class T>void _print(vector<T> v) {cerr<<\" [ \"; for (T i:v){_print(i);cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T>void _print(set<T> v) {cerr<<\" [ \"; for (T i:v){_print(i); cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< \" [ \"; for (T i:v){_print(i);cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<\" [ \"; for(auto i:v) {_print(i);cerr<<\" \";} cerr<<\"]\";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n; cin>>n;\n    vector<ll> a(n);\n    multiset<ll> posit,negat;\n    for(auto &it:a){\n        cin>>it;\n        if(it>=0){\n            posit.insert(it);\n        }\n        else{\n            negat.insert(it);\n        }\n    }\n    sort(all(a));\n    ll till=a[n-1]-a[0];\n    if(a[0]==0){\n        cout<<\"No\\n\";\n        return;\n    }  \n    cout<<\"Yes\\n\";\n    ll pref_max=0,pref_min=0;\n    ll pref=0;\n    posit.insert(-INF_ADD);\n    negat.insert(INF_ADD); \n    for(ll i=1;i<=n;i++){\n        auto it=*(--posit.lower_bound(till+pref_min-pref));\n        if(it>=0){\n            pref+=it;\n            posit.erase(posit.lower_bound(it));\n            cout<<it<<\" \";\n        }\n        else{\n            auto cur=*(negat.upper_bound(pref_max-pref-till));\n            assert(cur!=INF_ADD); \n            negat.erase(negat.lower_bound(cur)); \n            pref+=cur;\n            cout<<cur<<\" \";\n        }\n        pref_max=max(pref_max,pref);\n        pref_min=min(pref_min,pref);\n    }\n    cout<<nline; \n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(\"input.txt\", \"r\", stdin);                                              \n    freopen(\"output.txt\", \"w\", stdout);  \n    freopen(\"error.txt\", \"w\", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Shocking Arrangement.json",
    "editorial_link": "https://codeforces.com//blog/entry/114208",
    "editorial": "If the array consists entirely of zeros, then this is impossible, since\r\n.Otherwise, we will put all zeros at the beginning. Now our array is\r\nwithout zeros.We will add the elements into the array in order.If now\r\nthe sum of the added elements is , we will take any of the remaining\r\npositive numbers as the next element. Since the sum of all the numbers\r\nis , a positive number is guaranteed to be found (if there are still\r\nnumbers left). If now the sum is , then we will take any of the\r\nremaining negative numbers as the next element. Again, since the sum of\r\nall the numbers is , a negative number is bound to be found.Why it\r\nworks:The maximum number of the form is the same as (including\r\n)According to the structure of the algorithm, it is clear that in the\r\nresulting array , and .In total, the condition will be met.\r\n"
}