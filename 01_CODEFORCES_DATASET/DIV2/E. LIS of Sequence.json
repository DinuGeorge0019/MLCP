{"link": "https://codeforces.com//contest/486/problem/E", "problemId": "17063", "problem_idx": "E", "shortId": "486E", "contest_number": "486", "problem_submissions": {"C": [8656712, 8654869, 8655277, 8661715, 8659367, 8661623, 8671659, 8658387, 44544902, 8655041, 8655195, 8655046, 8655532, 8655723, 8654982, 8655530, 8654402, 8657095, 8655223, 8663823, 8658911], "D": [8656322, 8653249, 8657902, 8655199, 8657521, 8656772, 8655987, 8654471, 8762125, 8656998, 8658007, 8658299, 8659044, 8659007, 8659117, 8660760, 8660451, 8663779], "A": [8652840, 8649416, 8649905, 8649569, 8649694, 8650271, 8649886, 8649533, 8650061, 8649465, 8650144, 8650093, 8650370, 8649662, 8650038, 8650934, 8649593, 8649948, 8650270, 8663811, 8649707], "B": [8652668, 8652141, 8652012, 8652630, 8653907, 8652325, 8651841, 8653366, 8651435, 8652387, 8652466, 8652574, 8652046, 8653190, 8652712, 8651972, 8656481, 8651946, 8663812, 8652791], "E": [8651853, 8654712, 8659740, 8659484, 8661000, 8661038, 8654891, 8659823, 8952883, 8658117, 8661158, 8666251, 8659593, 8663820, 8660769]}, "name": "E. LIS of Sequence", "statement": "The next \"Data Structures and Algorithms\" lesson will be about Longest\r\nIncreasing Subsequence (LIS for short) of a sequence. For better\r\nunderstanding, Nam decided to learn it a few days before the lesson.Nam\r\ncreated a sequence consisting of () elements (). A subsequence where is\r\ncalled increasing if . An increasing subsequence is called longest if it\r\nhas maximum length among all increasing subsequences. Nam realizes that\r\na sequence may have several longest increasing subsequences. Hence, he\r\ndivides all indexes (), into three groups: group of all such that\r\nbelongs to no longest increasing subsequences. group of all such that\r\nbelongs to at least one longest increasing subsequence. group of all\r\nsuch that belongs to every longest increasing subsequence. Since the\r\nnumber of longest increasing subsequences of may be very large,\r\ncategorizing process is very difficult. Your task is to help him finish\r\nthis job.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#define maxn 100010\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nmap<pair<int,int>,int> Hash;\nint n,a[maxn],dp[maxn][2],LIS;\nvoid read()\n{\n\tstatic int stack[maxn],a[maxn];\n\tscanf(\"%d\",&n);\n\tint top=0;\n\tfor(int i=1,x;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tint p=lower_bound(stack+1,stack+top+1,x)-stack;\n\t\ta[i]=x;\n\t\tstack[p]=x,top=max(top,p),dp[i][0]=p;\n\t}\n\tLIS=top;\n\ttop=0;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tint p=lower_bound(stack+1,stack+top+1,-a[i])-stack;\n\t\tstack[p]=-a[i],top=max(top,p),dp[i][1]=p;\n\t\t++Hash[make_pair(dp[i][0],dp[i][1])];\n\t}\n}\nvoid print()\n{\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(dp[i][0]+dp[i][1]-1<LIS)\n\t\t\tprintf(\"1\");\n\t\telse if(Hash[make_pair(dp[i][0],dp[i][1])]>1)\n\t\t\tprintf(\"2\");\n\t\telse\n\t\t\tprintf(\"3\");\n\t}\n\tprintf(\"\\n\");\n}\nint main()\n{\n\tread();\n\tprint();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy", "hashing", "math"], "dificulty": "2200", "interactive": false}