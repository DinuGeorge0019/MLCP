{
    "link": "https://codeforces.com//contest/486/problem/E",
    "problemId": "17063",
    "problem_idx": "E",
    "shortId": "486E",
    "contest_number": "486",
    "problem_submissions": {
        "C": [
            8656712,
            8654869,
            8655277,
            8661715,
            8659367,
            8661623,
            8671659,
            8658387,
            44544902,
            8655041,
            8655195,
            8655046,
            8655532,
            8655723,
            8654982,
            8655530,
            8654402,
            8657095,
            8655223,
            8663823,
            8658911
        ],
        "D": [
            8656322,
            8653249,
            8657902,
            8655199,
            8657521,
            8656772,
            8655987,
            8654471,
            8762125,
            8656998,
            8658007,
            8658299,
            8659044,
            8659007,
            8659117,
            8660760,
            8660451,
            8663779
        ],
        "A": [
            8652840,
            8649416,
            8649905,
            8649569,
            8649694,
            8650271,
            8649886,
            8649533,
            8650061,
            8649465,
            8650144,
            8650093,
            8650370,
            8649662,
            8650038,
            8650934,
            8649593,
            8649948,
            8650270,
            8663811,
            8649707
        ],
        "B": [
            8652668,
            8652141,
            8652012,
            8652630,
            8653907,
            8652325,
            8651841,
            8653366,
            8651435,
            8652387,
            8652466,
            8652574,
            8652046,
            8653190,
            8652712,
            8651972,
            8656481,
            8651946,
            8663812,
            8652791
        ],
        "E": [
            8651853,
            8654712,
            8659740,
            8659484,
            8661000,
            8661038,
            8654891,
            8659823,
            8952883,
            8658117,
            8661158,
            8666251,
            8659593,
            8663820,
            8660769
        ]
    },
    "name": "E. LIS of Sequence",
    "statement": "The next \"Data Structures and Algorithms\" lesson will be about Longest\r\nIncreasing Subsequence (LIS for short) of a sequence. For better\r\nunderstanding, Nam decided to learn it a few days before the lesson.Nam\r\ncreated a sequence consisting of () elements (). A subsequence where is\r\ncalled increasing if . An increasing subsequence is called longest if it\r\nhas maximum length among all increasing subsequences. Nam realizes that\r\na sequence may have several longest increasing subsequences. Hence, he\r\ndivides all indexes (), into three groups: group of all such that\r\nbelongs to no longest increasing subsequences. group of all such that\r\nbelongs to at least one longest increasing subsequence. group of all\r\nsuch that belongs to every longest increasing subsequence. Since the\r\nnumber of longest increasing subsequences of may be very large,\r\ncategorizing process is very difficult. Your task is to help him finish\r\nthis job.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#define maxn 100010\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nmap<pair<int,int>,int> Hash;\nint n,a[maxn],dp[maxn][2],LIS;\nvoid read()\n{\n\tstatic int stack[maxn],a[maxn];\n\tscanf(\"%d\",&n);\n\tint top=0;\n\tfor(int i=1,x;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tint p=lower_bound(stack+1,stack+top+1,x)-stack;\n\t\ta[i]=x;\n\t\tstack[p]=x,top=max(top,p),dp[i][0]=p;\n\t}\n\tLIS=top;\n\ttop=0;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tint p=lower_bound(stack+1,stack+top+1,-a[i])-stack;\n\t\tstack[p]=-a[i],top=max(top,p),dp[i][1]=p;\n\t\t++Hash[make_pair(dp[i][0],dp[i][1])];\n\t}\n}\nvoid print()\n{\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(dp[i][0]+dp[i][1]-1<LIS)\n\t\t\tprintf(\"1\");\n\t\telse if(Hash[make_pair(dp[i][0],dp[i][1])]>1)\n\t\t\tprintf(\"2\");\n\t\telse\n\t\t\tprintf(\"3\");\n\t}\n\tprintf(\"\\n\");\n}\nint main()\n{\n\tread();\n\tprint();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "hashing",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. LIS of Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/14678",
    "editorial": "Let F1i be the length of LIS ending exactly at ai of sequence {a1,?a2,?...,?ai} and D1i is the number of such that LIS.\nLet F2i be the length of LIS beginning exactly at ai of sequence {ai,?ai?+?1,?...,?an} and D2i is the number of such that LIS.\n// Calculates F1i and F2i is familiar task, so I will not dig into this. For those who have'nt known it yet, this link may be useful)\n\n// We can calculate D1i and D2i by using advanced data structure, like BIT or Segment tree.\n\nl = length of LIS of {a1,?a2,?...,?an} = max{F1i} = max{F2j}.\n\nm = number of LIS of {a1,?a2,?...,?an} = \n\nLet Ci be the number of LIS of {a1,?a2,?...,?an} that ai belongs to. Index i must in group:\n\n1) if Ci = 0\n\n2) if 0???Ci?<?m\n\n3) if Ci?=?m\n\nHow to calculate Ci? If (F1i?+?F2i?-?1?<?l) then Ci = 0, else Ci?=?D1i?*?D2i. Done!\n\nWe have an additional issue. The number of LIS of {a1,?a2,?...,?an} maybe very large! D1i,?D2i and m maybe exceed 64-bits integer. Hence, we need to store D1i,?D2i and m after modulo some integer number, call it p.\n\nUsually, we will choose p is a prime, like 109?+?7 or 109?+?9. It's not hard to generate a test such that if you choose p?=?109?+?7 or p?=?109?+?9, your solution will lead to Wrong answer. But I have romeved such that tests, because the data tests is weak, even p is not a prime can pass all tests."
}