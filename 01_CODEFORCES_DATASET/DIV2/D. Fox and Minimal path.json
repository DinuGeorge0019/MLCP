{"link": "https://codeforces.com//contest/389/problem/D", "problemId": "6403", "problem_idx": "D", "shortId": "389D", "contest_number": "389", "problem_submissions": {"E": [5882910, 5882969, 5882623, 5886206, 5886237, 5881359, 5883942, 5881790, 5884306, 5884558, 5884891, 5884833, 5884246, 5880945, 5884605, 5886580, 5885214], "D": [5882237, 5881458, 5884902, 5885057, 5884493, 5888919, 5897772, 5897726, 49394197, 5884093], "C": [5876164, 5877416, 5877602, 5880188, 5879512, 5878436, 5876090, 5875802, 5879892, 5879347, 5879938, 5880138, 5877698, 5882032, 5878167, 5879899, 5881858, 5880866, 5879314], "B": [5874987, 5875378, 5875703, 5877586, 5879904, 5875848, 5877618, 5882807, 5877301, 5876662, 5877573, 5877789, 5875543, 5877904, 5887635, 5878765, 5877214, 5882962], "A": [5874673, 5874703, 5875132, 5876405, 5874775, 5878441, 5882215, 5875954, 5875157, 5875352, 5876029, 5874692, 5875210, 5881846, 5875551, 5874698, 5879937]}, "name": "D. Fox and Minimal path", "statement": "Fox Ciel wants to write a task for a programming contest. The task is:\r\n\"You are given a simple undirected graph with vertexes. Each its edge\r\nhas unit length. You should calculate the number of shortest paths\r\nbetween vertex 1 and vertex 2.\"Same with some writers, she wants to make\r\nan example with some certain output: for example, her birthday or the\r\nnumber of her boyfriend. Can you help her to make a test case with\r\nanswer equal exactly to ?\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) { cout << #x << \" = \"; cout << x << endl; }\n#define PR(a,n) { cout << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }\n#define PR0(a,n) { cout << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl; }\nusing namespace std;\n\nint cur;\nbool c[1011][1011];\nint x[33], y[33], z[33];\n\nvoid connect(int target, int between) {\n    FOR(i,1,between) z[i] = ++cur;\n    z[between+1] = target;\n\n    z[0] = 1;\n    FOR(i,0,between) c[z[i]][z[i+1]] = true;\n}\n\nint main() {\n    // ios :: sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        memset(c, 0, sizeof c);\n        cur = 2;\n        FOR(i,1,30) x[i] = ++cur;\n        FOR(i,1,30) y[i] = ++cur;\n\n        c[x[30]][2] = c[y[30]][2] = true;\n        FOR(i,1,29) {\n            c[x[i]][x[i+1]] = true;\n            c[y[i]][y[i+1]] = true;\n            c[y[i]][x[i+1]] = true;\n            c[x[i]][y[i+1]] = true;\n        }\n        FORD(i,29,0) if ((1<<i) <= n) {\n            n -= 1<<i;\n            connect(x[30-i], 30-i-1);\n        }\n        cout << cur << endl;\n        FOR(i,1,cur) {\n            FOR(j,1,cur) if (c[i][j] || c[j][i]) putchar('Y');\n            else putchar('N');\n            puts(\"\");\n        }\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "implementation", "shortest paths"], "dificulty": "1900", "interactive": false}