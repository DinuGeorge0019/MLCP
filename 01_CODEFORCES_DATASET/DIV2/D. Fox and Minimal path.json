{
    "link": "https://codeforces.com//contest/389/problem/D",
    "problemId": "6403",
    "problem_idx": "D",
    "shortId": "389D",
    "contest_number": "389",
    "problem_submissions": {
        "E": [
            5882910,
            5882969,
            5882623,
            5886206,
            5886237,
            5881359,
            5883942,
            5881790,
            5884306,
            5884558,
            5884891,
            5884833,
            5884246,
            5880945,
            5884605,
            5886580,
            5885214
        ],
        "D": [
            5882237,
            5881458,
            5884902,
            5885057,
            5884493,
            5888919,
            5897772,
            5897726,
            49394197,
            5884093
        ],
        "C": [
            5876164,
            5877416,
            5877602,
            5880188,
            5879512,
            5878436,
            5876090,
            5875802,
            5879892,
            5879347,
            5879938,
            5880138,
            5877698,
            5882032,
            5878167,
            5879899,
            5881858,
            5880866,
            5879314
        ],
        "B": [
            5874987,
            5875378,
            5875703,
            5877586,
            5879904,
            5875848,
            5877618,
            5882807,
            5877301,
            5876662,
            5877573,
            5877789,
            5875543,
            5877904,
            5887635,
            5878765,
            5877214,
            5882962
        ],
        "A": [
            5874673,
            5874703,
            5875132,
            5876405,
            5874775,
            5878441,
            5882215,
            5875954,
            5875157,
            5875352,
            5876029,
            5874692,
            5875210,
            5881846,
            5875551,
            5874698,
            5879937
        ]
    },
    "name": "D. Fox and Minimal path",
    "statement": "Fox Ciel wants to write a task for a programming contest. The task is:\r\n\"You are given a simple undirected graph with vertexes. Each its edge\r\nhas unit length. You should calculate the number of shortest paths\r\nbetween vertex 1 and vertex 2.\"Same with some writers, she wants to make\r\nan example with some certain output: for example, her birthday or the\r\nnumber of her boyfriend. Can you help her to make a test case with\r\nanswer equal exactly to ?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) { cout << #x << \" = \"; cout << x << endl; }\n#define PR(a,n) { cout << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }\n#define PR0(a,n) { cout << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl; }\nusing namespace std;\n\nint cur;\nbool c[1011][1011];\nint x[33], y[33], z[33];\n\nvoid connect(int target, int between) {\n    FOR(i,1,between) z[i] = ++cur;\n    z[between+1] = target;\n\n    z[0] = 1;\n    FOR(i,0,between) c[z[i]][z[i+1]] = true;\n}\n\nint main() {\n    // ios :: sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        memset(c, 0, sizeof c);\n        cur = 2;\n        FOR(i,1,30) x[i] = ++cur;\n        FOR(i,1,30) y[i] = ++cur;\n\n        c[x[30]][2] = c[y[30]][2] = true;\n        FOR(i,1,29) {\n            c[x[i]][x[i+1]] = true;\n            c[y[i]][y[i+1]] = true;\n            c[y[i]][x[i+1]] = true;\n            c[x[i]][y[i+1]] = true;\n        }\n        FORD(i,29,0) if ((1<<i) <= n) {\n            n -= 1<<i;\n            connect(x[30-i], 30-i-1);\n        }\n        cout << cur << endl;\n        FOR(i,1,cur) {\n            FOR(j,1,cur) if (c[i][j] || c[j][i]) putchar('Y');\n            else putchar('N');\n            puts(\"\");\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Fox and Minimal path.json",
    "editorial_link": "https://codeforces.com//blog/entry/10629",
    "editorial": "First we need to know how to calculate the number of different shortest\r\npaths from vertex 1 to vertex 2: it can be done by dp: dp[1] = 1, dp[v]\r\n= sum{dp[t] | dist(1,t) = dist(1,v) 1}, then dp[2] is our answer. We\r\nneed to do dp layer by layer. (first we consider vertexes have distance\r\n1 to node 1, then vertexes have distance 2 to node 1 and so on.) So we\r\ncan construct the graph layer by layer, and link edges to control the dp\r\nvalue of it. My solution is construct the answer by binary express: If k\r\nis 19, then we need some vertexes in previous layer such that the dp\r\nvalue is 16, 2 and 1. So we just need a way to construct layer with dp\r\nvalue equals to 2^k. In the first layer, it contains one node: 1, it has\r\nthe dp value 1. In the next layer, we can construct 2 nodes, with dp\r\nvalue equals to 1. (We use [1 1] to denote it). And the next layer is [1\r\n1 2], then [1 1 2 4], [1 1 2 4 8] and so on. So we need about 30 layers\r\nsuch that gets all 2^k where k < 30. It uses about 500 nodes.\r\n"
}