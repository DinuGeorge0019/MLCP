{
    "link": "https://codeforces.com//contest/2013/problem/F1",
    "problemId": "2890591",
    "problem_idx": "F1",
    "shortId": "2013F1",
    "contest_number": "2013",
    "problem_submissions": {
        "F1": [
            282085508,
            282091649,
            282097681,
            282062964,
            282097010,
            282094496,
            282096102,
            282130493,
            282100468,
            282110907,
            282110226,
            282977558
        ],
        "E": [
            282061833,
            282080813,
            282051849,
            282086247,
            282037391,
            282057195,
            282050812,
            282047875,
            282387310,
            282046660,
            282057981,
            282053861,
            282054405,
            282061649,
            282089310,
            282054594,
            282061765,
            282060270,
            282065503,
            282063375
        ],
        "D": [
            282053393,
            282148584,
            282052109,
            282042335,
            282076655,
            282080799,
            282065676,
            282079143,
            282037385,
            282054240,
            282041005,
            282045620,
            282047474,
            282043487,
            282073249,
            282022525,
            282048467,
            282042436,
            282046096,
            282048201
        ],
        "C": [
            282036735,
            282027206,
            282070402,
            282021424,
            282027464,
            282026938,
            282063555,
            282026144,
            282031663,
            282027005,
            282037319,
            282027256,
            282027279,
            282046717,
            282066980,
            282036015,
            282031256,
            282038898,
            282038980
        ],
        "B": [
            282022099,
            282013728,
            282015453,
            282011770,
            282018552,
            282009811,
            282027915,
            282017479,
            282013009,
            282018195,
            282019086,
            282010905,
            282014462,
            282037982,
            282022835,
            282017402,
            282018955,
            282018976,
            282023313
        ],
        "A": [
            282014277,
            282006421,
            282026971,
            282006385,
            282008034,
            282005836,
            282006296,
            282008704,
            282006066,
            282010046,
            282006523,
            282005614,
            282006702,
            282035715,
            282023370,
            282007442,
            282014269,
            282005794,
            282006570
        ],
        "F2": []
    },
    "editorial_link": "https://codeforces.com/blog/entry/134170",
    "editorial": "SolutionFirst, letâs understand how the game proceeds. Alice and Bob\r\nstart moving toward each other along the path from vertex to vertex . At\r\nsome vertex, one of the players can turn into a subtree of a vertex that\r\nis not on the path . After this, both players go to the furthest\r\naccessible vertex.Let the path from vertex to vertex be denoted as ,\r\nwhere and . Initially, Alice is at vertex and Bob is at vertex .For each\r\nvertex on the path , we define two values: the number of vertices that\r\nAlice will visit if she descends into the subtree of vertex that does\r\nnot lie on the path ; the number of vertices that Bob will visit if he\r\ndescends into the subtree of vertex that also does not lie on this path.\r\nLet the distance to the furthest vertex in the subtree of vertex be\r\ndenoted as . Then: the number of vertices Alice can visit if she\r\ndescends into the subtree at vertex . the number of vertices Bob can\r\nvisit if he descends into the subtree at vertex . Now, consider what\r\nhappens if Alice is at vertex and Bob is at vertex . If Alice decides to\r\ndescend into the subtree of vertex , she will visit vertices. Meanwhile,\r\nBob can reach any vertex on the segment . It is advantageous for Bob to\r\ndescend into the subtree of the vertex with the maximum value of , where\r\n.Therefore, it is beneficial for Alice to descend into the subtree of\r\nvertex if the following condition holds: Otherwise, she should move to\r\nvertex .The situation for Bob is similar: he will descend into the\r\nsubtree of vertex if the condition analogous to Aliceâs condition holds\r\nfor him.To efficiently find the maximum on the segment , one can use a\r\nsegment tree or a sparse table. This allows finding the maximum in for\r\neach query, resulting in an overall time complexity of .However, it can\r\nbe proven that instead of using a segment tree or sparse table, one can\r\nsimply iterate through all vertices on the segment and terminate the\r\nloop upon finding a greater vertex. This approach will yield a solution\r\nwith a time complexity of .\r\n",
    "name": "F1. Game in Tree  Easy Version ",
    "statement": "Alice and Bob are playing a fun game on a tree. This game is played on a\r\ntree with n vertices, numbered from 1 to n. Recall that a tree with n\r\nvertices is an undirected connected graph with n - 1 edges.Alice and Bob\r\ntake turns, with Alice going first. Each player starts at some vertex.On\r\ntheir turn, a player must move from the current vertex to a neighboring\r\nvertex that has not yet been visited by anyone. The first player who\r\ncannot make a move loses.You are given two vertices u and v. Represent\r\nthe simple path from vertex u to v as an array p_1, p_2, p_3,\r\nldots, p_m, where p_1 = u, p_m = v, and there is an edge between p_i and\r\np_{i + 1} for all i (1\r\nle i < m).You need to determine the winner of the game if Alice starts\r\nat vertex 1 and Bob starts at vertex p_j for each j (where 1\r\nle j\r\nle m).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; typedef long long ll;using vi = vector<int>;using vvi = vector<vector<int>>;using vll = vector<ll>;using vvll = vector<vector<ll>>; #define all(x) x.begin(), x.end()#define ckmin(a,b) a = min(a,b)#define ckmax(a,b) a = max(a,b) int ALICE = 0;int BOB = 1; int subsolve(vi& vals) {    int L = (int)vals.size();    assert (L >= 2);     set<pair<int, int>> Aset;    set<pair<int, int>> Bset;     for (int i=0;i<L-1;i++) Aset.insert({vals[i] + i, i});    for (int i=1;i<L;i++) Bset.insert({vals[i] + (L-1 - i), i});     int aloc = 0;    int bloc = L-1;    for (int t=0;t<=L-2;t++) {        if (t % 2 == 0) {            // Alice's turn            int cur_alice = vals[aloc] + aloc;            int cur_bob = (*Bset.rbegin()).first;            if (cur_alice > cur_bob) return ALICE;             // Alice must step forward            Aset.erase({vals[aloc] + aloc, aloc});            aloc++;            if (aloc == bloc) return BOB;            Bset.erase({vals[aloc] + (L-1 - aloc), aloc});        } else {            // Bob's turn            int cur_bob = vals[bloc] + (L-1 - bloc);            int cur_alice = (*Aset.rbegin()).first;            if (cur_bob >= cur_alice) return BOB;             // Bob must step forward            Bset.erase({vals[bloc] + (L-1 - bloc), bloc});            bloc--;            if (bloc == aloc) return ALICE;            Aset.erase({vals[bloc] + bloc, bloc});        }    }     // should not get here    assert(false);    return ALICE;} void solve() {    int N;    cin >> N;     vvi adj(N);    for (int i=0;i<N-1;i++) {        int u, v;        cin >> u >> v;        u--; v--;        adj[u].push_back(v);        adj[v].push_back(u);    }     int bu, bv;    cin >> bu >> bv;    bu--; bv--;    assert(bu == bv);         // get path    vi parent(N, -1);    parent[0] = 0;     auto get_parents = [&]() {        queue<int> bfs;        bfs.push(0);         while (!bfs.empty()) {            int cur = bfs.front(); bfs.pop();             for (int nbr : adj[cur]) {                if (parent[nbr] != -1) continue;                parent[nbr] = cur;                 bfs.push(nbr);            }        }    };    get_parents();     vi path{bu};    while (path.back() != 0) path.push_back(parent[path.back()]);    reverse(all(path));     vector<bool> used(N, false);    for (int v : path) used[v] = true;     int L = (int)path.size();     function<int(int)> get_dist;    get_dist = [&](int v) {        int ans = 0;        for (int w : adj[v]) {            if (used[w]) continue;            used[w] = true;            ckmax(ans, 1 + get_dist(w));        }        return ans;    };     vi vals(L);    for (int i=0;i<L;i++) vals[i] = get_dist(path[i]);     // for (int i=0;i<L;i++) cout << i << \" \" << path[i] << \" \" << vals[i] << endl;     int ans = subsolve(vals);    if (ans == ALICE) cout << \"Alice\\n\";    else cout << \"Bob\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(NULL);     int T;    cin >> T;     for (int t=0;t<T;t++) solve();      return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "games",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Game in Tree  Easy Version .json",
    "hint": []
}