{
    "link": "https://codeforces.com//contest/1419/problem/F",
    "problemId": "729813",
    "problem_idx": "F",
    "shortId": "1419F",
    "contest_number": "1419",
    "problem_submissions": {
        "F": [
            93295033,
            93295948,
            93577512,
            141950739,
            141949703,
            93333082
        ],
        "E": [
            93234753,
            93227212,
            93234200,
            93238693,
            93238493,
            93238433,
            93238275,
            93245697,
            93246537,
            93242848,
            93246826,
            93247065,
            93245207,
            93241549,
            93243538,
            93254913,
            93249479,
            93238516
        ],
        "D2": [
            93212522,
            93217506,
            93213686,
            93220590,
            93215812,
            93218918,
            93214966,
            93215328,
            93210409,
            93223664,
            93218002,
            93222549,
            93220767,
            93225667,
            93221756,
            93229039,
            93216049,
            93227118
        ],
        "D1": [
            93210697,
            93214622,
            93213970,
            93213840,
            93206345,
            93211719,
            93208773,
            93212321,
            93204619,
            93213170,
            93216390,
            93214097,
            93210302,
            93207013,
            93214684,
            93211970,
            93215865,
            93206978
        ],
        "C": [
            93207169,
            93210000,
            93209428,
            93210195,
            93217148,
            93208516,
            93207753,
            93214333,
            93218732,
            93213670,
            93211157,
            93218160,
            93211807,
            93211495,
            93209180,
            93205213,
            93217455
        ],
        "B": [
            93202581,
            93203801,
            93204920,
            93203314,
            93203851,
            93201764,
            93202768,
            93202454,
            93208579,
            93203844,
            93205640,
            93206433,
            93220603,
            93204341,
            93204189,
            93202311,
            93214207
        ],
        "A": [
            93200129,
            93200069,
            93200258,
            93200020,
            93200369,
            93204977,
            93200037,
            93200656,
            93201705,
            93200310,
            93200086,
            93201198,
            93200525,
            93199999,
            93201236,
            93200136,
            93200638
        ]
    },
    "name": "F. Rain of Fire",
    "statement": "There are n detachments on the surface, numbered from 1 to n, the i-th\r\ndetachment is placed in a point with coordinates (x_i, y_i). All\r\ndetachments are placed in different points.Brimstone should visit each\r\ndetachment at least once. You can choose the detachment where Brimstone\r\nstarts.To move from one detachment to another he should first choose one\r\nof four directions of movement (up, right, left or down) and then start\r\nmoving with the constant speed of one unit interval in a second until he\r\ncomes to a detachment. After he reaches an arbitrary detachment, he can\r\nrepeat the same process.Each t seconds an orbital strike covers the\r\nwhole surface, so at that moment Brimstone should be in a point where\r\nsome detachment is located. He can stay with any detachment as long as\r\nneeded.Brimstone is a good commander, thatâ€™s why he can create\r\ndetachment and place it in any empty point with integer coordinates he\r\nwants before his trip. Keep in mind that Brimstone will need to visit\r\nthis detachment, too.Help Brimstone and find such minimal t that it is\r\npossible to check each detachment. If there is no such t report about\r\nit.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s\".in\", \"r\", stdin); freopen(s\".out\", \"w\", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, \"%d \", a[i]); fprintf(stderr, \"\\n\");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = '0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e3 + 5;\nstruct Node {\n\tint x, y;\n}a[MAXN], b[MAXN];\nint n, dx[MAXN], dy[MAXN], tx, ty;\nvector < int > row[MAXN], clm[MAXN];\nbool cmp1(int i, int j) {return a[i].y < a[j].y;}\nbool cmp2(int i, int j) {return a[i].x < a[j].x;}\n\nint f[MAXN], siz[MAXN];\ninline int find(int x) {\n\twhile(x != f[x]) x = f[x];\n\treturn x;\n}\nstruct Tri {\n\tint x, y, r, w;\n};\nstack < Tri > s;\ninline int merge(int x, int y, int opt = 0) {\n\tx = find(x), y = find(y);\n\tif(x == y) return 0;\n\tif(siz[x] < siz[y]) swap(x, y);\n\tif(opt) s.push((Tri) {y, f[y], x, siz[x]});\n\tf[y] = x; siz[x] += siz[y]; return 1;\n}\ninline void back() {\n\twhile(s.size()) {\n\t\tf[s.top().x] = s.top().y; siz[s.top().r] = s.top().w;\n\t\ts.pop();\n\t}\n}\nbool check(int mid) {\n//\tcerr << mid << \":\" << endl;\n\tFor(i, 1, tx) row[i].clear(); tx = 0;\n\tFor(i, 1, ty) clm[i].clear(); ty = 0;\n\tFor(i, 1, n) a[i] = b[i];\n\tFor(i, 1, n) dx[++tx] = a[i].x, dx[++tx] = a[i].x - mid, dx[++tx] = a[i].x + mid; \n\tFor(i, 1, n) dy[++ty] = a[i].y, dy[++ty] = a[i].y - mid, dy[++ty] = a[i].y + mid; \n\tsort(dx + 1, dx + 1 + tx); sort(dy + 1, dy + 1 + ty); tx = unique(dx + 1, dx + 1 + tx) - dx - 1, ty = unique(dy + 1, dy + 1 + ty) - dy - 1;\n//\tcerr << tx << ' ' << ty << endl;\n    For(i, 1, n) row[a[i].x = lower_bound(dx + 1, dx + 1 + tx, a[i].x) - dx].pb(i), clm[a[i].y = lower_bound(dy + 1, dy + 1 + ty, a[i].y) - dy].pb(i);\n\tFor(i, 1, tx) sort(row[i].begin(), row[i].end(), cmp1);\n\tFor(i, 1, ty) sort(clm[i].begin(), clm[i].end(), cmp2);\n\t\n\tFor(i, 1, n + 1) f[i] = i, siz[i] = 1;\n\twhile(s.size()) s.pop();\n\tFor(i, 1, tx) {\n\t\tfor(rint j = 1; j < row[i].size(); j++) {\n\t\t\tif(dy[a[row[i][j]].y] - dy[a[row[i][j-1]].y] <= mid) {\n\t\t\t\tmerge(row[i][j], row[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tFor(i, 1, ty) {\n\t\tfor(rint j = 1; j < clm[i].size(); j++) {\n\t\t\tif(dx[a[clm[i][j]].x] - dx[a[clm[i][j-1]].x] <= mid) {\n\t\t\t\tmerge(clm[i][j], clm[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(siz[find(1)] == n) return 1;\n\tFor(x, 1, tx) {\n\t\tFor(y, 1, ty) {\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tfor(int j = 0; j < row[x].size(); j++) {\n\t\t\t\tif(abs(dy[a[row[x][j]].y] - dy[y]) <= mid) {\n//\t\t\t\t\tcerr << x << ' ' << y << ' ' << row[x][j] << ' ' << dy[a[row[x][j]].y]  << ' ' << dy[y] << endl;\n\t\t\t\t\tmerge(row[x][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < clm[y].size(); j++) {\n\t\t\t\tif(abs(dx[a[clm[y][j]].x] - dx[x]) <= mid) {\n//\t\t\t\t\tcerr << x << ' ' << y << ' ' << clm[y][j] << ' ' << dx[a[clm[y][j]].x] << ' ' << dx[x] << endl;\n\t\t\t\t\tmerge(clm[y][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tif(siz[find(1)] == n + 1) return 1;\n\t\t\tback();\n\t\t}\n\t}\n\treturn 0;\n}\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(\"pro\");\n    #endif\n    cin >> n;\n    For(i, 1, n) cin >> a[i].x >> a[i].y, b[i] = a[i];\n    \n\tll l = 1, r = 2e9, res = -1;\n\twhile(l <= r) {\n//\t\tcerr << l << ' ' << r << endl;\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid)) {\n\t\t\tr = mid - 1, res = mid;\n\t\t} else l = mid + 1;\n\t}\n\tcout << res << endl;\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Rain of Fire.json",
    "editorial_link": "https://codeforces.com//blog/entry/82817",
    "editorial": "We can consider a graph where vertices are the points (detachments), and\r\nthere is an edge between two points, if itÃ¢Â€Â™s possible to move from one\r\npoint to another. It is possible if these points are on the same line (\r\nor ) and the distance between them is .Now we can check, whether current\r\nvalue is good (whether it is possible to check all detachments). It is\r\neasy to see, that it is only possible, when the graph is connected. This\r\nmeans, that we can make a binary search for . LetÃ¢Â€Â™s now learn how to\r\ncheck, whether it is possible to add at most one point to make the graph\r\nconnected.If there is component, then the graph is already connected.If\r\nthere are components, then we can search through all such pairs of\r\npoints, that one point is from the first component, and another point is\r\nfrom the second component. We can connect these points, if they are on\r\none line, and the distance between them is or the differences and .If\r\nare three components, then we should consider triples of points. Two of\r\nthese points should be on the same line. The added point should be on a\r\nsegment between these two points, and there are such segments. Now letÃ¢Â€Â™s\r\nsearch through all such pairs (segment, point) and check whether it is\r\npossible to place a point on the segment and connect it with the point\r\nfrom the pair.If there are components, then you can search trough pairs\r\n(segment, segment), so that one segment is horizontal and another one is\r\nvertical (they should make a cross). Now we just need to check whether\r\nit is possible to connect their intersection point with all 4 endpoints\r\nof the segments.If there are more, than components, then it is not\r\npossible to connect them adding only one point, because there are 4\r\nmovement directions. If your binary search did not find the answer even\r\nfor , then the answer is , because the maximal distance between any two\r\npoints is .\r\n",
    "hint": []
}