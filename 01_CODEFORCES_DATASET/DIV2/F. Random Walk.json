{
    "link": "https://codeforces.com//contest/1823/problem/F",
    "problemId": "1896872",
    "problem_idx": "F",
    "shortId": "1823F",
    "contest_number": "1823",
    "problem_submissions": {
        "E": [
            203705839,
            203701788,
            203710907,
            203711770,
            203705371,
            203702158,
            203705164,
            203708687,
            203695617,
            203698015,
            203713863,
            203711164,
            203711208
        ],
        "F": [
            203698273,
            203688371,
            203699854,
            203692525,
            203713776,
            203706591,
            203701681,
            203697250,
            203707004,
            203714464,
            203718741,
            203709649,
            204276537,
            203715624
        ],
        "D": [
            203690544,
            203695164,
            203688855,
            203701895,
            203696407,
            203691855,
            203694127,
            203710546,
            203714159,
            203700668,
            203695441,
            203690745,
            203703946,
            203707611,
            203710099,
            203694539,
            203701580,
            203697921,
            203699365
        ],
        "C": [
            203682587,
            203678999,
            203681052,
            203684144,
            203687732,
            203680914,
            203689997,
            203682944,
            203686588,
            203690248,
            203682397,
            203683673,
            203689305,
            203682640,
            203682923,
            203682065,
            203686779,
            203685407,
            203684445,
            203683205
        ],
        "B": [
            203677458,
            203684522,
            203677423,
            203681465,
            203680710,
            203678118,
            203686689,
            203678181,
            203679545,
            203680940,
            203678605,
            203678733,
            203683292,
            203678419,
            203679073,
            203679634,
            203680902,
            203679216,
            203679313
        ],
        "A": [
            203676393,
            203676826,
            203676383,
            203676665,
            203678720,
            203676331,
            203678496,
            203676540,
            203676948,
            203676909,
            203676591,
            203676707,
            203676528,
            203676629,
            203676389,
            203676483,
            203678253,
            203677369,
            203678056
        ]
    },
    "name": "F. Random Walk",
    "statement": "You are given a tree consisting of n vertices and n - 1 edges, and each\r\nvertex v has a counter c(v) assigned to it.Initially, there is a chip\r\nplaced at vertex s and all counters, except c(s), are set to 0; c(s) is\r\nset to 1.Your goal is to place the chip at vertex t. You can achieve it\r\nby a series of moves. Suppose right now the chip is placed at the vertex\r\nv. In one move, you do the following: choose one of neighbors to of\r\nvertex v (to is neighbor of v if and only if there is an edge\r\n{v, to\r\n} in the tree); move the chip to vertex to and increase c(to) by 1;\r\nYou\u2019ll repeat the move above until you reach the vertex t.For each\r\nvertex v calculate the of c(v) modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,mod=998244353;\nint add(int x, int y){x+=y; if(x>=mod) x-=mod; return x;}\nint sub(int x, int y){x-=y; if(x<0) x+=mod; return x;}\nint mul(int x, int y){return ((ll)x)*y%mod;}\nint Pow(int x, ll y=mod-2){int res=1; for(; y; x=mul(x,x),y>>=1) if(y&1) res=mul(res,x); return res;}\n\nint n,s,t,p,par[N],dep[N],res[N];\nvector<int> adj[N];\nbool de[N];\n\nvoid dfs(int u, int fa){\n    par[u]=fa,dep[u]=fa==-1?0:dep[fa]+1;\n    for(auto v: adj[u]) if(v!=fa) dfs(v,u);\n}\n\nvoid dfs2(int u, int fa, int cnt){\n    res[fa]=add(res[fa],cnt);\n    for(auto v: adj[u]) if(v!=fa){\n        res[v]=add(res[v],cnt);\n        if(de[v]) dfs2(v,u,cnt+1);\n        else dfs2(v,u,cnt);\n    }\n}\n\nvoid ldc(){\n    cin >> n >> s >> t; s--,t--;\n    for(int i=0; i<n-1; ++i){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    dfs(t,-1);\n    for(int i=s; i>=0; i=par[i]) de[i]=1;\n    for(auto v: adj[t]) if(de[v]){\n        dfs2(v,t,1);\n        break;\n    }\n    res[s]=add(res[s],1);\n    for(int i=0; i<n; ++i) cout << res[i] << ' ';\n    cout << \"\\n\";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    t=1;\n    while(t--) ldc();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "math",
        "probabilities",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Random Walk.json",
    "editorial_link": "https://codeforces.com//blog/entry/115465",
    "editorial": "Let be the number of neighbors of vertex . Let\u00e2\u0080\u0099s fix a vertex and its\r\nneighboring vertices . According to the linearity of the expected\r\nvalues: This gives the system of equations, which, however, cannot be\r\ndirectly solved.Solution by :Let\u00e2\u0080\u0099s solve the subproblem: given a bamboo\r\nwith vertices numbered in order from to , and and . It is easy to see\r\nthat the equation is satisfied by the expected values .Now let\u00e2\u0080\u0099s solve\r\nthe problem. Consider the path from to (it is the only one in the tree).\r\nThe chip must go through it, but at the vertices of the path, it can go\r\nto third-party vertices. Let us represent a tree as non-intersecting\r\ntrees whose roots are vertices lying on the path from to , and all other\r\nvertices do not lie on this path. Let\u00e2\u0080\u0099s place the numbers at the\r\nvertices of the path. Let\u00e2\u0080\u0099s now fix a tree rooted at vertex in the path,\r\nand let its number be equal to . Then we can see that the equation is\r\nsatisfied by the values of the mathematical expectation . Separately,\r\nyou need to make .Solution by :Let\u00e2\u0080\u0099s take a path from to and call it ,\r\nwhere and . Now we will assume that each of the vertices form its own\r\nrooted subtree. Consider a leaf in an arbitrary subtree: , where is the\r\nancestor of .Now, by induction on the subtree size, we prove that for\r\nany vertex in any subtree the expected value is . For the leafs, it\u00e2\u0080\u0099s\r\nobvious. Further, by the inductive hypothesis: .Now consider the\r\nvertices on the path: And so on. For we get: Now let\u00e2\u0080\u0099s expand: That\u00e2\u0080\u0099s\r\nall. For any vertex in the subtree of we get .\r\n"
}