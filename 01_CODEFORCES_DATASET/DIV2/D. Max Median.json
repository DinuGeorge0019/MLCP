{
    "link": "https://codeforces.com//contest/1486/problem/D",
    "problemId": "897793",
    "problem_idx": "D",
    "shortId": "1486D",
    "contest_number": "1486",
    "problem_submissions": {
        "F": [
            107822308,
            107853234,
            107892513,
            107856479,
            107858609,
            107818883,
            107863062,
            107864151,
            107861898,
            107852447
        ],
        "C2": [
            107807571,
            107798543,
            107798512,
            107824454,
            107833215,
            107807829,
            107808299,
            107893894,
            107831280,
            107798206,
            107803513,
            107805796,
            107796329,
            107802055,
            107801594,
            107810753,
            107807623,
            107804366,
            107800246,
            107794787
        ],
        "C1": [
            107807442,
            107798262,
            107798783,
            107806766,
            107826187,
            107799740,
            107808102,
            107806459,
            107804345,
            107798724,
            107803748,
            107805504,
            107796790,
            107802993,
            107801883,
            107810564,
            107806537,
            107804166,
            107800475,
            107795337
        ],
        "E": [
            107800531,
            107809228,
            107835383,
            107836319,
            107858202,
            107831953,
            107841935,
            107828250,
            107866676,
            107815626,
            107818145,
            107822115,
            107819777,
            107823506,
            107819582,
            107793061,
            107821827,
            107818526,
            107827724,
            107835623
        ],
        "D": [
            107794075,
            107802130,
            107818757,
            107810014,
            107838771,
            107823356,
            107812461,
            107800692,
            107835785,
            107804842,
            107809012,
            107812317,
            107808246,
            107810696,
            107812569,
            107833103,
            107812854,
            107810102,
            107818249,
            107811436
        ],
        "B": [
            107789021,
            107789484,
            107787615,
            107791480,
            107795217,
            107789100,
            107788278,
            107793717,
            107792766,
            107788662,
            107787061,
            107791923,
            107801559,
            107790818,
            107784811,
            107802492,
            107792788,
            107796149,
            107790292,
            107785066
        ],
        "A": [
            107783058,
            107787485,
            107782747,
            107783451,
            107784857,
            107784942,
            107784010,
            107783293,
            107785695,
            107784794,
            107783365,
            107784072,
            107790054,
            107785033,
            107793025,
            107799971,
            107782733,
            107782509,
            107783469,
            107782641
        ]
    },
    "name": "D. Max Median",
    "statement": "You are a given an array a of length n. Find a subarray a[l..r] with\r\nlength at least k with the largest median.A median in an array of length\r\nn is an element which occupies position number\r\nlfloor\r\nfrac{n + 1}{2}\r\nrfloor after we sort the elements in non-decreasing order. For example:\r\nmedian([1, 2, 3, 4]) = 2, median([3, 2, 1]) = 2, median([2, 1, 2, 1]) =\r\n1.Subarray a[l..r] is a contiguous part of the array a, i. e. the array\r\na_l,a_{l+1},\r\nldots,a_r for some 1\r\nleq l\r\nleq r\r\nleq n, its length is r - l + 1.\r\n",
    "solutions": [
        "//#pragma GCC target(\"avx,avx2\")\t\n#include<bits/stdc++.h>\n//#include<immintrin.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nchar readc()\n{\n\tchar c;\n\twhile(isspace(gc));\n\treturn c;\n}\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nconst int N=2e5+5;\nint k,n,a[N],s[N],mn[N];\nbool check(int mid)\n{\n\trep(i,1,n){\n\t\ts[i]=s[i-1]+(a[i]>=mid?1:-1);\n\t\tmn[i]=min(mn[i-1],s[i]);\n\t}\n\trep(i,k,n)\n\tif(s[i]>mn[i-k])return 1;\n\treturn 0;\n}\n\nint main()\n{\n#ifdef LOCAL\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\t\n\tcin>>n>>k;\n\trep(i,1,n)a[i]=read();\n\tint l=1,r=n+1;\n\twhile(l+1!=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid))l=mid;\n\t\telse r=mid;\n\t}\n\tcout<<l<<endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Max Median.json",
    "editorial_link": "https://codeforces.com//blog/entry/87849",
    "editorial": "Letâs binary search the answer. Now letâs check if the answer is\nat least . Replace all values that are at least with 1 and values that\nare less than with . Now if for some segment the median is at least if\nthe sum on this subsegment is positive! Now we only need to check if the\narray consisting of and has a subsegment of length at least with\npositive sum. So letâs just calculate prefix sums of this array and for\nprefix sum at position choose the minimum prefix sum amongst positions ,\nwhich can be done using prefix minimum in linear time.So the resulting\ncomplexity is .\n",
    "hint": [
        "Hint1 How to solve the problem if all the values are and ?",
        "Hint2 Binary search ONCE MORE?",
        "Hint3 How to check if the answer is at least ?"
    ]
}