{
    "link": "https://codeforces.com//contest/2064/problem/D",
    "problemId": "3209696",
    "problem_idx": "D",
    "shortId": "2064D",
    "contest_number": "2064",
    "problem_submissions": {
        "F": [
            306407892,
            306425196,
            306377965,
            306528822,
            306420583,
            306436938,
            306464619,
            306464611,
            306464596,
            306421840,
            306436020,
            306431617
        ],
        "E": [
            306390714,
            306398471,
            306384310,
            306394422,
            306398127,
            306399878,
            306406503,
            306383184,
            306400855,
            306401726,
            306402720,
            306406500,
            306407308,
            306407643
        ],
        "D": [
            306371870,
            306386641,
            306395969,
            306366170,
            306368905,
            306376156,
            306376541,
            306371606,
            306373885,
            306397500,
            306381946,
            306383232,
            306376685,
            306374721,
            306378738,
            306378728,
            306379129
        ],
        "C": [
            306354396,
            306362052,
            306353937,
            306355169,
            306355714,
            306353717,
            306358223,
            306359445,
            306355168,
            306369168,
            306356490,
            306351942,
            306356412,
            306355663,
            306365036,
            306361215,
            306362138
        ],
        "B": [
            306350175,
            306351645,
            306349804,
            306350391,
            306352487,
            306349346,
            306350952,
            306351840,
            306351364,
            306350764,
            306349120,
            306348178,
            306353114,
            306350171,
            306353103,
            306355161,
            306356448
        ],
        "A": [
            306345365,
            306345586,
            306346094,
            306345382,
            306344838,
            306344890,
            306345366,
            306345254,
            306346099,
            306344812,
            306345138,
            306344813,
            306347979,
            306345325,
            306346230,
            306349362
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138912",
    "editorial": "SolutionFirst notice that if we are unable to eat the next slime then\r\nthis slime must have had a (most significant bit) at least as large as\r\nthe current value of . Subsequently this means that if a slime has a\r\nstrictly less than we can always eat it.Now see that if we eat a slime\r\nwith lower than then the of will never decrease and that if we eat a\r\nslime with equal then of will decrease, this inspires us to do the\r\nfollowing:at any point we should eat as many slimes as we can to the\r\nleft that have smaller (to calculate the new value of after doing this\r\nwe can just do any range xor query such as prefix sums), after this the\r\nnext slime will always have greater than or equal to and so we will\r\neither not be able to eat it or we will eat it of will decrease. Because\r\nthe will always decrease after every operation we will only need to do\r\nthis operation at most times!And so we should try find some way to\r\ncalculate fast the first slime to our left with greater than or equal to\r\nthe current of . There are many ways to do this but I would say the\r\ncleanest way is to use prefix sums, store for each where (where is the\r\nmax value of and ), the greatest index before it which has greater than\r\nor equal to call this Now we can update it as follows: if then else And\r\nso the final complexity is\r\n",
    "name": "D. Eating",
    "statement": "There are n slimes on a line, the i-th of which has weight w_i. Slime i\r\nis able to eat another slime j if w_i\r\ngeq w_j; afterwards, slime j disappears and the weight of slime i\r\nbecomes w_i\r\noplus w_j^{\r\ntext{ }}.The King of Slimes wants to run an x as follows: Add a new\r\nslime with weight x to the right end of the line (after the n-th slime).\r\nThis new slime eats the slime to its left if it is able to, and then\r\ntakes its place (moves one place to the left). It will continue to do\r\nthis until there is either no slime to its left or the weight of the\r\nslime to its left is greater than its own weight. (No other slimes are\r\neaten during this process.) The of this experiment is the total number\r\nof slimes eaten. The King of Slimes is going to ask you q queries. In\r\neach query, you will be given an integer x, and you need to determine\r\nthe score of the experiment with parameter x.Note that the King does not\r\nwant you to actually perform each experiment; his slimes would die,\r\nwhich is not ideal. He is only asking what the hypothetical score is; in\r\nother words, the queries are persistent.^{\r\ntext{ }}Here\r\noplus denotes the bitwise XOR operation.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "trees",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Eating.json",
    "hint": []
}