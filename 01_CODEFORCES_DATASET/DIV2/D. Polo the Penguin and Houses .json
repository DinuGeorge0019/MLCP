{
    "link": "https://codeforces.com//contest/289/problem/D",
    "problemId": "2799",
    "problem_idx": "D",
    "shortId": "289D",
    "contest_number": "289",
    "problem_submissions": {
        "E": [
            3459146,
            3463369,
            3460609,
            3460604,
            3462555,
            3461006,
            3461728,
            3461588,
            3461307,
            3460025,
            3462334,
            3462779,
            3463498,
            3460536,
            3463551,
            3464172,
            3462631,
            3462960
        ],
        "C": [
            3456054,
            3456066,
            3455021,
            3459797,
            3456042,
            3453824,
            3456655,
            3457204,
            3455279,
            3456988,
            3457381,
            3458050,
            3457221,
            3457801,
            3454599,
            3456362,
            3455735,
            3456889
        ],
        "D": [
            3455963,
            3460496,
            3459068,
            3458621,
            3459481,
            3457268,
            3459857,
            3459925,
            3458097,
            3462947,
            3458331,
            3459472,
            3461935,
            3462472,
            3461241,
            3459422,
            3461116,
            3460679
        ],
        "B": [
            3455203,
            3455368,
            3453821,
            3457116,
            3455086,
            3458732,
            3455817,
            3455593,
            3459615,
            3455651,
            3454891,
            3455252,
            3455908,
            3456410,
            3456449,
            3455178,
            3457543,
            3454105
        ],
        "A": [
            3453433,
            3454495,
            3453333,
            3454660,
            3453910,
            3459883,
            3453757,
            3454123,
            3463162,
            3453754,
            3453562,
            3453866,
            3458954,
            3453377,
            3453432,
            3456188,
            3456399
        ]
    },
    "name": "D. Polo the Penguin and Houses ",
    "statement": "Little penguin Polo loves his home village. The village has houses,\r\nindexed by integers from 1 to . Each house has a plaque containing an\r\ninteger, the -th house has a plaque containing integer ().Little penguin\r\nPolo loves walking around this village. The walk looks like that. First\r\nhe stands by a house number . Then he goes to the house whose number is\r\nwritten on the plaque of house (that is, to house ), then he goes to the\r\nhouse whose number is written on the plaque of house (that is, to house\r\n), and so on.We know that: When the penguin starts walking from any\r\nhouse indexed from 1 to , inclusive, he can walk to house number 1. When\r\nthe penguin starts walking from any house indexed from to , inclusive,\r\nhe definitely cannot walk to house number 1. When the penguin starts\r\nwalking from house number 1, he can get back to house number 1 after\r\nsome non-zero number of walks from a house to a house. You need to find\r\nthe number of ways you may write the numbers on the houses\u2019 plaques so\r\nas to fulfill the three above described conditions. Print the remainder\r\nafter dividing this number by .\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstring> \nusing namespace std;\nint v[9],p[9],n,m,i,mod=1000000007;\nlong long ans;\n\nbool go(int x)\n{\n    if(v[x]==1) return 1;\n    if(v[x]==-1) return 0;\n    v[x]=-1;\n    if(go(p[x])) return v[x]=1;\n    return 0;\n}\n\nvoid dfs(int x)\n{\n    int i;\n    if(x>m)\n    {\n        memset(v,0,sizeof(v));\n        v[1]=1;\n        for(i=2;i<=m;i++)\n            if(!go(i)) break;\n        ans+=i>m;\n        return;\n    }\n    for(i=1;i<=m;i++)\n        if(x==1||i!=x)\n        {\n            p[x]=i;\n            dfs(x+1);\n        }\n}\n\nint main()\n{\n    cin>>n>>m;\n    dfs(1);\n    for(i=1;i<=n-m;i++) ans=ans*(n-m)%mod;\n    cout<<ans<<endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dfs and similar",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Polo the Penguin and Houses .json",
    "editorial_link": "https://codeforces.com//blog/entry/7241",
    "editorial": "Solution. Since k???8 you can solve this problem using brute force. This means that you can recursively construct all possible kk possibilities of first k assignments. (For k?=?8 this is equal to 16 777 216.) For each of that assignments you need to check whether it is correct or not (by problem statement). Ths can be simply done using loops.\n\nWhen you know the number of assignment for the first k tables (let it be f(k)), all you need to do is to count the number of assignment for the rest n?-?k plaques. Since there should bo no path to 1, there should be no path to any of first k houses, so at each plaque for houses from k?+?1 to n there can be any number from k?+?1 to n, inclusive. There are (n?-?k)n?-?k such possibilities. And hence the total answer is f(k)(n?-?k)n?-?k."
}