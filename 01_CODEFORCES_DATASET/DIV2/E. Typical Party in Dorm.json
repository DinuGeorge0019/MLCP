{
    "link": "https://codeforces.com//contest/1679/problem/E",
    "problemId": "1399040",
    "problem_idx": "E",
    "shortId": "1679E",
    "contest_number": "1679",
    "problem_submissions": {
        "E": [
            157180775,
            157191404,
            157182377,
            157177036,
            157184415,
            157176870,
            157175927,
            157179358,
            157179949,
            157181138,
            157181082,
            157188651,
            158765685,
            157182719,
            157183341,
            157204752,
            157188040,
            157183760,
            157190456,
            157188869
        ],
        "F": [
            157169392,
            157164382,
            157193064,
            157199663,
            157199138,
            157186552,
            157273261,
            157180874,
            158765715,
            157250679,
            157197475,
            157509965
        ],
        "A": [
            157160334,
            157139962,
            157137818,
            157155828,
            157137804,
            157138382,
            157140445,
            157138960,
            157138642,
            157138794,
            157144480,
            157142439,
            162719211,
            158765634,
            157138332,
            157138320,
            157139854,
            157140729,
            157138982,
            157137953,
            157138211
        ],
        "B": [
            157157060,
            157145020,
            157140369,
            157158458,
            157140367,
            157140216,
            157144197,
            157146569,
            157143365,
            157142315,
            157148129,
            157146141,
            157198440,
            158765655,
            157143823,
            157143623,
            157144426,
            157145542,
            157143138,
            157142676,
            157142878
        ],
        "C": [
            157154751,
            157170214,
            157147368,
            157161435,
            157149801,
            157145630,
            157152376,
            157151562,
            157149876,
            157147868,
            157153893,
            157150787,
            157196725,
            158765679,
            157151559,
            157154130,
            157157802,
            157152042,
            157149676,
            157150426,
            157148575
        ],
        "D": [
            157148745,
            157180439,
            157159044,
            157144096,
            157159383,
            157154423,
            157160087,
            157161413,
            157158556,
            157158664,
            157164328,
            157159039,
            157192557,
            158765668,
            157159304,
            157162810,
            157169333,
            157162480,
            157162127,
            157163382,
            157167439
        ]
    },
    "name": "E. Typical Party in Dorm",
    "statement": "You are given a string s of length n, which consists of the first 17\r\nlowercase Latin letters {a, b, c,\r\nldots, p, q} and question marks. And q queries. Each query is defined by\r\na set of pairwise distinct lowercase first 17 letters of the Latin\r\nalphabet, which can be used to replace the question marks in the string\r\ns.The answer to the query is the sum of the number of distinct\r\nsubstrings that are palindromes over all strings that can be obtained\r\nfrom the original string s by replacing question marks with available\r\ncharacters. The answer must be calculated modulo 998\r\n,244\r\n,353. Two substrings are different when their start and end positions in\r\nthe string are different. So, the number of different substrings that\r\nare palindromes for the string will be 4: , , , .Consider examples of\r\nreplacing question marks with letters. For example, from the string when\r\nquerying {a, b} you can get the strings or but you cannot get the\r\nstrings , , , , , or .Recall that a palindrome is a string that reads\r\nthe same from left to right as from right to left.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<iostream>\nusing namespace std;\nconst int mod=998244353,maxn=20,maxl=1005;\nint n,q,m;\nint f[maxn][1<<17],mul[maxn][maxl],imul[maxn][maxl];\nstring s,t;\nint ksm(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1)\n\t\t\tres=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n),cin>>s,scanf(\"%d\",&q),s=\" \"+s;\n\tfor(int i=1;i<=n;i++)\n\t\tm+=(s[i]=='?');\n\tfor(int i=1;i<=17;i++){\n\t\tmul[i][0]=imul[i][0]=1;\n\t\tint v0=i,v1=ksm(i,mod-2);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tmul[i][j]=1ll*mul[i][j-1]*v0%mod,imul[i][j]=1ll*imul[i][j-1]*v1%mod;\n\t}\n\tfor(int c=1;c<=17;c++){//ji de gai\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint x=i,y=i,S=0,t=0;\n\t\t\twhile(x>=1&&y<=n){\n\t\t\t\tif(s[x]!='?'&&s[y]!='?'&&s[x]!=s[y])\n\t\t\t\t\tbreak;\n\t\t\t\tif(s[x]=='?'&&s[y]!='?')\n\t\t\t\t\tS|=(1<<(s[y]-97)),t++;\n\t\t\t\tif(s[x]!='?'&&s[y]=='?')\n\t\t\t\t\tS|=(1<<(s[x]-97)),t++;\n\t\t\t\tif(x<y&&s[x]=='?'&&s[y]=='?')\n\t\t\t\t\tt++;\n//\t\t\t\tprintf(\"x=%d y=%d c=%d S=%d t=%d\\n\",x,y,c,S,t);\n\t\t\t\tf[c][S]=(f[c][S]+imul[c][t])%mod;\n\t\t\t\tx--,y++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint x=i,y=i+1,S=0,t=0;\n\t\t\twhile(x>=1&&y<=n){\n\t\t\t\tif(s[x]!='?'&&s[y]!='?'&&s[x]!=s[y])\n\t\t\t\t\tbreak;\n\t\t\t\tif(s[x]=='?'&&s[y]!='?')\n\t\t\t\t\tS|=(1<<(s[y]-97)),t++;\n\t\t\t\tif(s[x]!='?'&&s[y]=='?')\n\t\t\t\t\tS|=(1<<(s[x]-97)),t++;\n\t\t\t\tif(s[x]=='?'&&s[y]=='?')\n\t\t\t\t\tt++;\n\t\t\t\tf[c][S]=(f[c][S]+imul[c][t])%mod;\n//\t\t\t\tprintf(\"x=%d y=%d c=%d S=%d t=%d\\n\",x,y,c,S,t);\n\t\t\t\tx--,y++;\n\t\t\t}\n\t\t}\n\t\tfor(int len=2,now=1;len<=(1<<17);len<<=1,now<<=1)\n\t\t\tfor(int i=0;i<(1<<17);i+=len)\n\t\t\t\tfor(int j=0;j<now;j++)\n\t\t\t\t\tf[c][i+j+now]=(f[c][i+j+now]+f[c][i+j])%mod;\n\t}\n\twhile(q--){\n\t\tint x,S=0;\n\t\tcin>>t;\n\t\tfor(int i=0;i<t.size();i++)\n\t\t\tS|=(1<<(t[i]-97));\n\t\tprintf(\"%d\\n\",1ll*f[t.size()][S]*mul[t.size()][m]%mod);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Typical Party in Dorm.json",
    "editorial_link": "https://codeforces.com//blog/entry/102859",
    "editorial": "Let us solve the problem initially for a query.First, we can see that\r\ninstead of counting the number of palindromes in each possible version\r\nof string , we can count the number of strings in which a substring\r\nwould be a palindrome.Consider the substring . Suppose the set of\r\nallowed characters in this query is . What would be the effect of the\r\nsubstring on the answer? Divide the characters of the substring into\r\npairs: first with last, second with penultimate, and so on. If the\r\nlength of the substring is odd, pair the central character with itself.\r\nNow letâs consider each pair separately: If two characters of the pair\r\nare equal and they are not question marks, then this pair does not\r\naffect the answer. If two characters of the pair are equal and they are\r\nquestion marks, then this pair multiplies the answer by , where the\r\nnumber of possible characters to replace in this query. (Letâs call the\r\nnumber of such pairs ). If two characters of the pair are not equal and\r\nthere is no question mark among them, then this substring will never be\r\na palindrome. If two characters of a pair are not equal and there is a\r\nquestion mark among them, you must check if the letter that is not a\r\nquestion mark belongs to the set , if not, then this substring will\r\nnever be a palindrome. Those pairs that cause this substring not to be a\r\npalindrome will be called . Thus, we got the number of possible ways to\r\nreplace question marks in substring with valid characters such that\r\nsubstring a palindrome is , or if we have a blocking pair. To get the\r\ntotal number of lines in which is a palindrome, just multiply the\r\nprevious value by , where is the number of question marks that lie\r\nwithin .Thus, to get the answer for the substring it is enough: Check\r\nfor blocking pairs if they exist, the answer is by definition.\r\nOtherwise, the answer is , where and are defined above. Letâs assign to\r\neach possible set of letters a binary mask of size , where the size of\r\nthe alphabet in the problem. In the future, we will assume that mask and\r\nset are the same.Consider possible blocking pairs of some substring ,\r\nthey are of two kinds: If two characters of the pair are not equal and\r\nthere is no question mark among them, then this substring will never be\r\na palindrome and we do not consider it. If two characters of the pair\r\nare not equal and there is a question mark between them, a character\r\nthat is not a question mark must be in the query for us to consider this\r\nsubstring. Thus, from the characters in pairs of the second type, we can\r\ncreate a set of \"necessary\" characters, letâs call it .Next, let us note\r\nthe following fact: does not depend on the query , because depends only\r\non and , and on the number of pairs where both characters are question\r\nmarks.It follows that every substring of the form : Or is simply ignored\r\nif it has a blocking pair of the first type. (These substrings will not\r\nbe mentioned further in the tutorial when we say substrings, we\r\nautomatically mean the one described below). Either is characterized by\r\na pair of numbers (; ). Consider an arbitrary query , how to calculate\r\nthe answer for it? We need to go through all substrings, check whether\r\nand if so, add to the answer.The values of and for the substring can be\r\nfound quickly by knowing the same values for the substring . Thus, by\r\niterating over the parity of the palindrome length, then its center, and\r\nthen its length itself, we can quickly find these values for all the\r\nsubstrings.Thus, our solution has asymptotics so far ( ), which is\r\nobviously too slow. But first, letâs figure out how to solve the problem\r\nif we have fixed? Letâs create an array of size (letâs call it ). For\r\neach substring, letâs add to value . What does this give us? We will\r\nthen have in the sum of answers from all the substrings of which is\r\nequal to . To find the answer in this case we have to sum all where\r\n.Actually, we have reached the asymptotics ( ) or ( ).But! The problem\r\nof finding the sum of subset values is a well-known one and solves our\r\nsubproblem for ( ). In more detail:\r\nhttps://codeforces.com/blog/entry/45223Well, here we have reached the\r\nasymptotics of ( ), which is enough.Let us return to the original\r\nproblem. First, note that we donât have many different just . So we\r\ncreate different arrays of size . When processing the current substring,\r\nwe add to each of the arrays at position , where the index of the\r\ncurrent array. Thus, it is as if we times solved the problem for a fixed\r\n. We need to take the sum over subsets of from the th array to get the\r\nanswer.The final asymptotic of the solution ( ).Applied optimizations in\r\nthe authorâs solution: Power optimization: we will often need different\r\nvalues of numbers from to in powers from to , so to remove from the\r\nasymptotic, a precalculation of these values is used. This optimization\r\nis necessary to guarantee a full score on the problem. Addition\r\noptimization: we do not need to add a subset (; ) to arrays whose index\r\nis less than . This is since they will not affect the answer in any way.\r\n(Since the sets from which the answer will be taken in this array have\r\nfewer elements than , they cannot, by definition, be supersets.) This\r\noptimization is unlikely to have much effect on runtime. It is written\r\nhere for a clearer understanding of the authorâs solution. Modulo\r\noptimization: The take modulo operation is slower than other operations,\r\nso it is worth avoiding. Here we often use the sum modulo of two numbers\r\nthat do not exceed , so we will replace it by using instead of\r\n",
    "hint": []
}