{"link": "https://codeforces.com//contest/180/problem/B", "problemId": "1261", "problem_idx": "B", "shortId": "180B", "contest_number": "180", "problem_submissions": {"A": [1612011, 1611035, 1611491, 1610423, 1608646, 1612209, 1610289, 1609636, 1609133, 1612193, 1612229, 1611072, 1612163, 1611991, 1610400, 1612436, 1617622], "E": [1610692, 1609351, 1609009, 1613114, 1609269, 1610641, 1610622, 1610904, 1610311, 1609559, 1609099, 1609957, 1610472, 1610971, 1609912, 1608828], "D": [1610104, 1610284, 1610538, 1611279, 1611479, 1611395, 1611538, 1611063, 1611009, 1611925, 1611800, 1650220], "B": [1609708, 1612372, 1611456, 1610499], "F": [1608611, 1608642, 1608360, 1608443, 1609619, 1608802, 1608911, 1609865, 1608836, 1608333, 1608944, 1608579, 1608822, 1608381], "C": [1608408, 1608345, 1608245, 1608291, 1608998, 1608357, 1608524, 1609626, 1608493, 1608501, 1608480, 1609176, 1608550, 1608260]}, "name": "B. Divisibility Rules", "statement": "Vasya studies divisibility rules at school. Here are some of them: A\r\nnumber is divisible by if and only if its last digit is divisible by or\r\nin other words, is even. A number is divisible by if and only if the sum\r\nof its digits is divisible by . A number is divisible by if and only if\r\nits last two digits form a number that is divisible by . A number is\r\ndivisible by if and only if its last digit equals or . A number is\r\ndivisible by if and only if it is divisible by and simultaneously (that\r\nis, if the last digit is even and the sum of all digits is divisible by\r\n). Vasya doesn\u2019t know such divisibility rule. A number is divisible by\r\nif and only if its last three digits form a number that is divisible by\r\n. A number is divisible by if and only if the sum of its digits is\r\ndivisible by . A number is divisible by if and only if its last digit is\r\na zero. A number is divisible by if and only if the sum of digits on its\r\nodd positions either equals to the sum of digits on the even positions,\r\nor they differ in a number that is divisible by .Vasya got interested by\r\nthe fact that some divisibility rules resemble each other. In fact, to\r\ncheck a number\u2019s divisibility by , , , and it is enough to check\r\nfulfiling some condition for one or several last digits. Vasya calls\r\nsuch rules the rules.If checking divisibility means finding a sum of\r\ndigits and checking whether the sum is divisible by the given number,\r\nthen Vasya calls this rule the rule (because it works for numbers and\r\n).If we need to find the difference between the sum of digits on odd and\r\neven positions and check whether the difference is divisible by the\r\ngiven divisor, this rule is called the rule (it works for number ).In\r\nsome cases we should divide the divisor into several factors and check\r\nwhether rules of different types (-type, -type or -type) work there. For\r\nexample, for number we check -type and -type rules, for number we check\r\nall three types. Such mixed divisibility rules are called rules. And\r\nfinally, there are some numbers for which no rule works: neither -type,\r\nnor -type, nor -type, nor -type. The least such number is number , so\r\nwe\u2019ll say that in such cases the mysterious rule works, the one that\r\nVasya hasn\u2019t discovered yet. Vasya\u2019s dream is finding divisibility rules\r\nfor all possible numbers. He isn\u2019t going to stop on the decimal numbers\r\nonly. As there are quite many numbers, ha can\u2019t do it all by himself.\r\nVasya asked you to write a program that determines the divisibility rule\r\ntype in the -based notation for the given divisor .\r\n", "solutions": ["#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint ntest = 0, test = 0;\ninline void init();\ninline void run();\ninline void stop() {\n\tntest = test - 1;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input\", \"r\", stdin);\n//\tfreopen(\"output\", \"w\", stdout);\n#endif\n\tinit();\n\twhile (++test <= ntest) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); it++)\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<typeof(*(v).begin())>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = (int) 1E9 + 5;\nconst double EPS = 1E-11;\nconst ll MOD = (ll) 1E9 + 7;\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\ninline void init() {\n\tntest = 1;\n}\n\nint b, d;\n\nmap<int, int> factor(int a) {\n\tmap<int, int> ret;\n\tFOR(i, 2, INF) {\n\t\tif (i * i > a) {\n\t\t\tbreak;\n\t\t}\n\t\tif (a % i == 0) {\n\t\t\tint cnt = 0;\n\t\t\twhile (a % i == 0) {\n\t\t\t\tcnt++;\n\t\t\t\ta /= i;\n\t\t\t}\n\t\t\tret[i] = cnt;\n\t\t}\n\t}\n\tif (a != 1) {\n\t\tret[a] = 1;\n\t}\n\treturn ret;\n}\n\nint doCheck(map<int, int> a, map<int, int> b) {\n\tint MAX = -INF;\n\tFIT(it, a) {\n\t\tif (!b.count(it->F)) {\n\t\t\treturn -1;\n\t\t}\n\t\tint u = it->S;\n\t\tint v = b[it->F];\n\t\tint d = u / v + (u % v != 0);\n\t\tMAX = max(MAX, d);\n\t}\n\treturn MAX;\n}\n\nbool pleaseCheck(int b, int d, bool verbose) {\n\tmap<int, int> bf = factor(b);\n\tmap<int, int> df = factor(d);\n\tint is2Type = doCheck(df, bf);\n\tif (is2Type != -1) {\n\t\tif (verbose) {\n\t\t\tcout << \"2-type\" << endl;\n\t\t\tcout << is2Type << endl;\n\t\t}\n\t\treturn true;\n\t}\n\n\tif ((b - 1) % d == 0) {\n\t\tif (verbose) {\n\t\t\tcout << \"3-type\" << endl;\n\t\t}\n\t\treturn true;\n\t}\n\n\tif ((b + 1) % d == 0) {\n\t\tif (verbose) {\n\t\t\tcout << \"11-type\" << endl;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\ninline void run() {\n\tcin >> b >> d;\n\n\tif (pleaseCheck(b, d, true)) {\n\t\treturn;\n\t}\n\n\tmap<int, int> f = factor(d);\n\tFIT(it, f) {\n\t\tint w = 1;\n\t\tREP(i, it->S) {\n\t\t\tw *= it->F;\n\t\t}\n\t\tif (!pleaseCheck(b, w, false)) {\n\t\t\tcout << \"7-type\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcout << \"6-type\" << endl;\n}\n"], "input": "", "output": "", "tags": ["math", "number theory"], "dificulty": "2300", "interactive": false}