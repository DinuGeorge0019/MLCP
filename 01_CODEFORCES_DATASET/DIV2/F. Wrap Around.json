{
    "link": "https://codeforces.com//contest/1038/problem/F",
    "problemId": "216026",
    "problem_idx": "F",
    "shortId": "1038F",
    "contest_number": "1038",
    "problem_submissions": {
        "F": [
            42582709,
            42588924
        ],
        "E": [
            42575080,
            42578573,
            42575208,
            42576431,
            42577789,
            42580719,
            42575666,
            42580571,
            42583311,
            42581396,
            42582088,
            42580954,
            42583334,
            42579643,
            42582008,
            42580920,
            42583129,
            42582580,
            42583754
        ],
        "D": [
            42573485,
            42569896,
            42569634,
            42567012,
            42572149,
            42570113,
            42576120,
            42571013,
            42565752,
            42571052,
            42574327,
            42570312,
            42567294,
            42575127,
            42575057,
            42572394,
            42574539,
            42573852,
            42573051
        ],
        "C": [
            42566710,
            42563399,
            42564810,
            42563947,
            42567501,
            42564966,
            42562683,
            42566829,
            42562396,
            42564608,
            42563976,
            42565121,
            42570852,
            42564983,
            42565516,
            42568404,
            42566048,
            42568514,
            42566544
        ],
        "B": [
            42560979,
            42561635,
            42561921,
            42561073,
            42563881,
            42561586,
            42565172,
            42563091,
            42560475,
            42561602,
            42561362,
            42562336,
            42564791,
            42568121,
            42563027,
            42564081,
            42563007,
            42563149,
            42562895
        ],
        "A": [
            42559251,
            42559046,
            42559189,
            42559233,
            42563411,
            42559174,
            42559467,
            42559825,
            42558982,
            42559283,
            42559010,
            42559078,
            42560087,
            42561636,
            42561187,
            42559807,
            42559670,
            42559820,
            42559436
        ]
    },
    "name": "F. Wrap Around",
    "statement": "You are given a binary string s.Find the number of distinct binary\r\nstrings of length n which contain s as a substring.The cyclical string t\r\ncontains s as a substring if there is some cyclical shift of string t,\r\nsuch that s is a substring of this cyclical shift of t.For example, the\r\ncyclical string \"\" contains substrings \"\", \"\" and \"\", but doesn’t\r\ncontain \"\" and \"\".Two cyclical strings are called different if they\r\ndiffer from each other as strings. For example, two different strings,\r\nwhich differ from each other by a cyclical shift, are still considered\r\ncyclical strings.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\ntypedef long long LL;\nint used[N],Next[N],a[N];char s[N];\nLL F[N][N][2],tmp[N][2],ans;int n,m;\nvoid clear(){\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int k=0;k<m;k++)\n\t\t\tF[i][k][0]=F[i][k][1]=0;\n}\nvoid dp(int st,int ed){\n\tfor (int i=st;i<=ed;i++)\n\t\tfor (int k=0;k<m;k++)\n\t\t\tfor (int ok=0;ok<2;ok++)\n\t\t\t\tif (F[i-1][k][ok]){\n\t\t\t\t\tfor (int cur=0;cur<2;cur++){\n\t\t\t\t\t\tif (used[i]!=-1&&used[i]!=cur) continue;\n\t\t\t\t\t\tint j=k;\n\t\t\t\t\t\tfor (;j&&a[j+1]!=cur;j=Next[j]);\n\t\t\t\t\t\tj+=a[j+1]==cur;\n\t\t\t\t\t\tif (j==m) F[i][0][1]+=F[i-1][k][ok];\n\t\t\t\t\t\t\t else F[i][j][ok]+=F[i-1][k][ok];\n\t\t\t\t\t}\n\t\t\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);m=strlen(s+1);\n\tfor (int i=1;i<=m;i++)\n\t\ta[i]=s[i]-'0';\n\tfor (int i=2,j=0;i<=m;i++){\n\t\tfor (;j&&a[j+1]!=a[i];j=Next[j]);\n\t\tNext[i]=(j+=a[j+1]==a[i]);\n\t}\n\tfor (int i=1;i<=n;i++) used[i]=-1;\n\tclear();F[0][0][0]=1;dp(1,n);\n\tfor (int k=0;k<m;k++)\n\t\tans+=F[n][k][1];\n\tfor (int len=1;len<m;len++){\n\t\tfor (int i=1;i<=n;i++) used[i]=-1;\n\t\tfor (int i=1;i<=len;i++)\n\t\t\tused[n-len+i]=a[i];\n\t\tfor (int i=len+1;i<=m;i++)\n\t\t\tused[i-len]=a[i];\n\t\tclear();F[n-len+1][0][0]=1;\n\t\tdp(n-len+2,n);\n\t\tfor (int k=0;k<m;k++)\n\t\t\tfor (int ok=0;ok<2;ok++) \n\t\t\t\ttmp[k][ok]=F[n][k][ok];\n\t\tclear();\n\t\tfor (int k=0;k<m;k++)\n\t\t\tfor (int ok=0;ok<2;ok++)\n\t\t\t\tF[0][k][ok]=tmp[k][ok];\n\t\tdp(1,n);\n\t\tfor (int k=0;k<m;k++)\n\t\t\tans+=F[n][k][0];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Wrap Around.json",
    "editorial_link": "https://codeforces.com/blog/entry/61692",
    "editorial": "The idea was to solve the problem using Dynamic Programming. The\r\nconstraints of the question were set low to allow even the most basic\r\nDynamic Programming approaches to pass (see the authorâs solution to see\r\nan easy, but time-costly implementation).The solution idea was to use DP\r\nwith 4 states: = Current matching suffix length of string () = Length of\r\nstring so far () = Whether string contains as a substring (non-cyclical)\r\nso far () = Length of the suffix of that is a prefix of ()You can refer\r\nto AC codes for transitions. We may add more details by tomorrow.You can\r\nsee authorâs code for an unoptimised approach, and to testerâs code for\r\nan optimised solution.Overall Complexity:\r\n",
    "hint": []
}