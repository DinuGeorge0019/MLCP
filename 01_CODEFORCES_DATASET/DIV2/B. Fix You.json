{
    "link": "https://codeforces.com//contest/1391/problem/B",
    "problemId": "694516",
    "problem_idx": "B",
    "shortId": "1391B",
    "contest_number": "1391",
    "problem_submissions": {
        "E": [
            89439040,
            89441228,
            89441499,
            89447005,
            89455919,
            89448964,
            89450402,
            89450314,
            89451586,
            89450891,
            89451401,
            89477045,
            89456884,
            89551553,
            89455517,
            134448846
        ],
        "D": [
            89432700,
            89481054,
            89433875,
            89429170,
            89437115,
            89436985,
            89437929,
            89442877,
            89440195,
            89442618,
            89441518,
            89427031,
            89429794,
            89432423,
            89430800,
            89431789,
            89433956,
            89433503,
            89434575,
            89434257,
            89434975
        ],
        "C": [
            89426750,
            89420513,
            89434144,
            89429566,
            89425760,
            89427285,
            89429714,
            89432343,
            89427996,
            89426533,
            89417430,
            89420352,
            89419759,
            89418803,
            89424047,
            89424699,
            89425111,
            89422696,
            89425810,
            89422948
        ],
        "B": [
            89410454,
            89413605,
            89410503,
            89414269,
            89414715,
            89415761,
            89415369,
            89418138,
            89419682,
            89414189,
            89411200,
            89409436,
            89412062,
            89413310,
            89415929,
            89412884,
            89413208,
            89414045,
            89413779,
            89419197
        ],
        "A": [
            89406971,
            89407448,
            89407070,
            89407023,
            89410266,
            89408876,
            89408557,
            89413085,
            89412622,
            89407815,
            89407257,
            89406922,
            89406883,
            89407981,
            89408687,
            89407102,
            89407091,
            89409131,
            89415228,
            89408988
        ]
    },
    "name": "B. Fix You",
    "statement": "Consider a conveyor belt represented using a grid consisting of n rows\r\nand m columns. The cell in the i-th row from the top and the j-th column\r\nfrom the left is labelled (i,j). Every cell, except (n,m), has a\r\ndirection (Right) or (Down) assigned to it. If the cell (i,j) is\r\nassigned direction , any luggage kept on that will move to the cell\r\n(i,j+1). Similarly, if the cell (i,j) is assigned direction , any\r\nluggage kept on that will move to the cell (i+1,j). If at any moment,\r\nthe luggage moves out of the grid, it is considered to be lost. There is\r\na counter at the cell (n,m) from where all luggage is picked. A conveyor\r\nbelt is called if and only if any luggage reaches the counter regardless\r\nof which cell it is placed in initially. More formally, for every cell\r\n(i,j), any luggage placed in this cell should eventually end up in the\r\ncell (n,m). This may not hold initially; you are, however, allowed to\r\nthe directions of some cells to make the conveyor belt functional.\r\nPlease determine the minimum amount of cells you have to change.Please\r\nnote that it is always possible to make any conveyor belt functional by\r\nchanging the directions of some set of cells.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int k_N = 100 + 3;\n\nstring s[k_N];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n\n        for(int i = 0; i < n; ++i)\n            cin >> s[i];\n    \n        int ans = 0;\n        for(int i = 0; i < n - 1; ++i)\n            ans += s[i][m - 1] != 'D';\n\n        for(int i = 0; i < m - 1; ++i)\n            ans += s[n - 1][i] != 'R';\n\n        cout << ans << \"\\n\";\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Fix You.json",
    "editorial_link": "https://codeforces.com//blog/entry/81265",
    "editorial": "The answer is .It\u00e2\u0080\u0099s obvious that we must change all Rs in the last\r\ncolumn and all Ds in the last row. Otherwise, anything placed in those\r\ncells will move out of the grid. We claim that doing just this is enough\r\nto make the grid functional. Indeed, for any other cell, any luggage\r\nplaced in it will eventually reach either the last row or the last\r\ncolumn, from which it will move to the counter.Time Complexity:\r\n"
}