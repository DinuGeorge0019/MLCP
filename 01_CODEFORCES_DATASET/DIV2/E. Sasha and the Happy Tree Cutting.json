{
    "link": "https://codeforces.com//contest/1929/problem/E",
    "problemId": "2478907",
    "problem_idx": "E",
    "shortId": "1929E",
    "contest_number": "1929",
    "problem_submissions": {
        "F": [
            246533325,
            246531273,
            246535602,
            246537728,
            248473670,
            248472907,
            246536511,
            246538004,
            246539955,
            246545257,
            246545291,
            246547847,
            246517420,
            246543420,
            246541449,
            246549298,
            246540895,
            246550782,
            246552572,
            246538786,
            246556383,
            246551792
        ],
        "E": [
            246526711,
            246525335,
            246529920,
            246532407,
            247710837,
            246542700,
            246542158,
            246542829,
            246536287,
            246540991,
            246540586,
            246556061,
            246534976,
            246548547,
            246541367,
            246546569,
            246545920,
            246542715,
            246562305,
            246543807,
            246546073
        ],
        "D": [
            246514987,
            246516364,
            246523834,
            246521878,
            246527738,
            246529658,
            246525748,
            246524974,
            246530714,
            246530595,
            246536018,
            246517832,
            246533128,
            246527574,
            246529579,
            246532376,
            246528687,
            246524837,
            246531715,
            246527894
        ],
        "C": [
            246504265,
            246506492,
            246509311,
            246511086,
            246512939,
            246522191,
            246515413,
            246514318,
            246521012,
            246518198,
            246522829,
            246597787,
            246545456,
            246513164,
            246517021,
            246521174,
            246507321,
            246517238,
            246512362,
            246508483,
            246515953
        ],
        "B": [
            246496908,
            246510099,
            246501616,
            246503108,
            246502307,
            246506254,
            246501930,
            246507459,
            246501810,
            246507250,
            246508662,
            246503154,
            246500767,
            246506410,
            246511238,
            246501517,
            246502536,
            246501220,
            246501502,
            246503229
        ],
        "A": [
            246490029,
            246489425,
            246489778,
            246493551,
            246491292,
            246506396,
            246489787,
            246490848,
            246490635,
            246492686,
            246490767,
            246500334,
            246491854,
            246491116,
            246490960,
            246489189,
            246491592,
            246489513,
            246489387,
            246490308
        ]
    },
    "name": "E. Sasha and the Happy Tree Cutting",
    "statement": "Sasha was given a tree^{\r\ndagger} with n vertices as a prize for winning yet another competition.\r\nHowever, upon returning home after celebrating his victory, he noticed\r\nthat some parts of the tree were missing. Sasha remembers that he\r\ncolored some of the edges of this tree. He is certain that for any of\r\nthe k pairs of vertices (a_1, b_1),\r\nldots, (a_k, b_k), he colored at least one edge on the simple path^{\r\nddagger} between vertices a_i and b_i.Sasha does not remember how many\r\nedges he exactly colored, so he asks you to tell him the minimum number\r\nof edges he could have colored to satisfy the above condition.^{\r\ndagger}A tree is an undirected connected graph without cycles.^{\r\nddagger}A simple path is a path that passes through each vertex at most\r\nonce.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nvector<int>v[300005];\nint sy[45],cnt;\nint bu[25],bv[25],blc[25];\nint bz[300005][20];\nint dep[300005];\nint dfn[300005],siz[300005],tmp;\nint dp[1049576];\nvoid dfs(int x,int f)\n{\n\tdfn[x]=++tmp;\n\tsiz[x]=1;\n\tdep[x]=dep[f]+1;\n\tbz[x][0]=f;\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tbz[x][i]=bz[bz[x][i-1]][i-1];\t\n\t}\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==f)continue;\n\t\tdfs(v[x][i],x);\n\t\tsiz[x]+=siz[v[x][i]];\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dep[bz[x][i]]>=dep[y])x=bz[x][i];\n\t}\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(bz[x][i]!=bz[y][i])\n\t\t{\n\t\t\tx=bz[x][i];\n\t\t\ty=bz[y][i];\n\t\t}\n\t}\n\treturn bz[x][0];\n} \nint findzx(int x,int k)\n{\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(k>=(1<<i))\n\t\t{\n\t\t\tk-=(1<<i);\n\t\t\tx=bz[x][i];\n\t\t}\n\t}\n\treturn x;\n}\nint pd(int x,int y,int z)\n{\n\tint ans=0;\n\tif(dfn[x]>=dfn[z]&&dfn[x]<=dfn[z]+siz[z]-1)ans++;\n\tif(dfn[y]>=dfn[z]&&dfn[y]<=dfn[z]+siz[z]-1)ans++;\n\tif(ans==1)return true;\n\treturn false;\n}\nsigned main()\n{\n\tint t,n,k,x,y;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t\tcnt=0;\n\t\ttmp=0;\n\t\tdfs(1,0);\n\t\tk=read();\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tbu[i]=read();\n\t\t\tbv[i]=read();\n\t\t\tblc[i]=lca(bu[i],bv[i]);\t\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tif(bu[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bu[i],dep[bu[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0;\n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bv[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bv[i],dep[bv[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0; \n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",cnt);\n\t\t//for(int i=1;i<=cnt;i++)printf(\"%d \",sy[i]);\n\t//\tprintf(\"\\n\");\n\t\tfor(int i=0;i<(1<<k);i++)dp[i]=1000000000;\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<k);i++)\n\t\t{\n\t\t\tif(dp[i]==1000000000)continue;\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tdp[i|sy[j]]=min(dp[i|sy[j]],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[(1<<k)-1]);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "math",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sasha and the Happy Tree Cutting.json",
    "editorial_link": "https://codeforces.com//blog/entry/125943",
    "editorial": "Let's consider each edge i\n and mark the set of pairs Si\n that it covers. Then the claim is: we have a total of O(k)\n different sets. This is because we are only interested in the edges that are present in the compressed tree on these k\n pairs of vertices. And as it is known, the number of edges in the compressed tree is O(k)\n.\n\nThen we need to find the minimum number of sets among these sets such that each pair is present in at least one of them. This can be achieved by dynamic programming on sets as follows:\n\nLet dp[mask]\n be the minimum number of edges that need to be removed in order for at least one edge to be removed among the pairs corresponding to the individual set bits in mask\n.\n\nThen the update is as follows: dp[mask|Si]=min(dp[mask|Si],dp[mask]+1)\n for all distinct sets S\n, where Si\n is the mask corresponding to the pairs passing through the edge. This update is performed because we are adding one more edge to this mask.\n\nAs a result, we obtain a solution with a time complexity of O(nk+2kk)\n, where O(nk)\n is for precomputing the set of pairs removed by each edge for each edge, and O(2kk)\n is for updating the dynamic programming."
}