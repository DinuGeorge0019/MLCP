{"link": "https://codeforces.com//contest/686/problem/E", "problemId": "63501", "problem_idx": "E", "shortId": "686E", "contest_number": "686", "problem_submissions": {"E": [18753113], "D": [18677363, 18676926, 18680203, 18677096, 18680500, 18679262, 18679726, 18681134, 18679340, 18681235, 18679151, 18677262, 18680852, 18682604, 18679420, 18683508, 18682836, 18677654], "C": [18674350, 18674219, 18675996, 18670680, 18674843, 18676354, 18677317, 18674277, 18676911, 18677370, 18678038, 18675789, 18677870, 18675610, 18676923, 18681967], "B": [18671047, 18668588, 18669725, 18672830, 18672620, 18669882, 18671172, 18668900, 18674893, 18677911, 18672621, 18670139, 18676902, 18670149, 18671650, 18671701], "A": [18669150, 18667513, 18667542, 18673623, 18668163, 18667514, 18669093, 18667603, 18674115, 18677610, 18668549, 18667772, 18667638, 18667507, 18667916, 18669148]}, "name": "E. Optimal Point", "statement": "When the river brought Gerda to the house of the Old Lady who Knew\r\nMagic, this lady decided to make Gerda her daughter. She wants Gerda to\r\nforget about Kay, so she puts all the roses from the garden\r\nunderground.Mole, who lives in this garden, now can watch the roses\r\nwithout going up to the surface. Typical mole is blind, but this mole\r\nwas granted as special vision by the Old Lady. He can watch any\r\nunderground objects on any distance, even through the obstacles and\r\nother objects. However, the quality of the picture depends on the\r\nManhattan distance to object being observed.Mole wants to find an point\r\nto watch roses, that is such point with that the maximum Manhattan\r\ndistance to the rose is minimum possible.As usual, he asks you to help.\r\nbetween points and is defined as .\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100100;\nconst long long Inf=3000000000000000000ll;\nint n;\nlong long x[N]={},y[N]={},z[N]={},mx,my,mz;\nlong long m1[4]={},m2[4]={},v[4]={};\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%I64d%I64d%I64d\",x+i,y+i,z+i);\n\tfor(int i=0;i<4;++i)\n\t\tm1[i]=Inf,m2[i]=-Inf;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tv[0]=x[i]+y[i]+z[i];\n\t\tv[1]=x[i]+y[i]-z[i];\n\t\tv[2]=x[i]-y[i]+z[i];\n\t\tv[3]=-x[i]+y[i]+z[i];\n\t\tfor(int j=0;j<4;++j)\n\t\t\tm1[j]=min(m1[j],v[j]),m2[j]=max(m2[j],v[j]);\n\t}\n}\nbool check(long long mid)\n{\n\tlong long l[4]={},r[4]={};\n\tfor(int d=0;d<=1;++d)\n\t{\n\t\t//cout<<\"d=\"<<d<<endl;\n\t\tr[0]=m1[0]+mid-d*3, l[0]=m2[0]-mid-d*3;\n\t\tfor(int j=1;j<=3;++j)\n\t\t\tr[j]=m1[j]+mid-d, l[j]=m2[j]-mid-d;\n\t\t//for(int j=0;j<4;++j)\n\t\t//\tcout<<\"l=\"<<l[j]<<\" r=\"<<r[j]<<endl;\n\t\tbool flag=true;\n\t\tfor(int j=0;j<=3;++j)\n\t\t{\n\t\t\tif(l[j]<0) l[j]=l[j]/2*2;\n\t\t\telse l[j]=(l[j]+1)/2*2;\n\t\t\tif(r[j]<0) r[j]=(r[j]-1)/2*2;\n\t\t\telse r[j]=r[j]/2*2;\n\t\t}\n\t\t//for(int j=0;j<4;++j)\n\t\t//\tcout<<\"l=\"<<l[j]<<\" r=\"<<r[j]<<endl;\n\t\tfor(int j=0;j<=3;++j)\n\t\t\tflag&=(l[j]<=r[j]);\n\t\tif(!flag) continue;\n\t\t\n\t\tlong long now=accumulate(l+1,l+4,0ll);\n\t\tif(now>r[0]) continue;\n\t\tfor(int j=1;j<=3;++j)\n\t\t\tif(now<l[0])\n\t\t\t{\n\t\t\t\tlong long add=min(l[0]-now,r[j]-l[j]);\n\t\t\t\tnow+=add,l[j]+=add;\n\t\t\t}\n\t\tif(now<l[0]) continue;\n\t\tmx=(l[1]+l[2])/2+d,my=(l[1]+l[3])/2+d,mz=(l[2]+l[3])/2+d;\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid work()\n{\n\tlong long l=0,r=Inf;\n\twhile(l!=r)\n\t{\n\t\tlong long mid=(l+r)>>1;\n\t\tif(check(mid))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcheck(l);\n\tprintf(\"%I64d %I64d %I64d\\n\",mx,my,mz);\n}\nint main()\n{\t\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": [], "dificulty": "2900", "interactive": false}