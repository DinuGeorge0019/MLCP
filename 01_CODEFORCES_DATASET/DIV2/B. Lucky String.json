{
    "link": "https://codeforces.com//contest/110/problem/B",
    "problemId": "578",
    "problem_idx": "B",
    "shortId": "110B",
    "contest_number": "110",
    "problem_submissions": {
        "E": [
            647829,
            649167,
            646023,
            646546,
            645768,
            647440,
            646441,
            647692,
            647579,
            647730,
            647778,
            648074,
            648205,
            648643,
            672231,
            648607
        ],
        "D": [
            646207,
            648016,
            1801308,
            650206,
            650204,
            650149,
            645758,
            648839,
            651051,
            646617,
            672309,
            672304
        ],
        "C": [
            644127,
            643544,
            644243,
            643865,
            645241,
            644451,
            644887,
            644131,
            644140,
            645305,
            644925,
            643505,
            644385,
            643763,
            644812,
            644362,
            644073,
            643923
        ],
        "B": [
            643233,
            642711,
            643039,
            643416,
            643607,
            643662,
            644238,
            643262,
            643508,
            644064,
            644105,
            643023,
            643503,
            644212,
            644124,
            643915,
            643258,
            643069
        ],
        "A": [
            642482,
            642215,
            642278,
            642632,
            643064,
            642636,
            643448,
            642358,
            642849,
            643249,
            642539,
            642283,
            642426,
            642982,
            643205,
            642425,
            642448,
            642447
        ]
    },
    "name": "B. Lucky String",
    "statement": "Petya recently learned to determine whether a string of lowercase Latin\r\nletters is lucky. For each individual letter all its positions in the\r\nstring are written out in the increasing order. This results in lists of\r\nnumbers; some of them can be empty. A string is considered lucky if and\r\nonly if in each list the absolute difference of any two numbers is a\r\nlucky number. For example, let’s consider string \"\". The lists of\r\npositions of equal letters are: : : : : : : Lists of positions of\r\nletters , , , ..., are empty.This string is lucky as all differences are\r\nlucky numbers. For letters : , , for letters : , for letters : . Note\r\nthat if some letter occurs only once in a string, it doesn’t influence\r\nthe string’s luckiness after building the lists of positions of equal\r\nletters. The string where all the letters are distinct is considered\r\nlucky.Find the lexicographically minimal lucky string whose length\r\nequals .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint N;\n\nint main()\n{\n    char num[1111];\n    while(~scanf(\"%d\", &N)){\n        for(int i = 0; i < N; i++)\n            putchar('a'+i%4);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Lucky String.json",
    "editorial_link": "https://codeforces.com//blog/entry/2547",
    "editorial": "To solve this problem you need to notice that result is a prefix of string abcdabcdabcd...abcd and output first n characters of this string.",
    "hint": []
}