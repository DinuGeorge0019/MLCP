{
    "link": "https://codeforces.com//contest/1230/problem/F",
    "problemId": "419100",
    "problem_idx": "F",
    "shortId": "1230F",
    "contest_number": "1230",
    "problem_submissions": {
        "F": [
            61160420,
            61168761,
            61169473,
            61163448,
            61168484,
            61211410,
            61166190,
            61161224
        ],
        "E": [
            61148718,
            61161040,
            61146705,
            61151905,
            61156612,
            61143760,
            61134387,
            61160007,
            61147362,
            61152540,
            61143988,
            61157501,
            61156272,
            61146445,
            61139279,
            61157405,
            61162378
        ],
        "D": [
            61141780,
            61141760,
            61139292,
            61144818,
            61153245,
            61138124,
            61148103,
            61186591,
            61153749,
            61148878,
            61139116,
            61159398,
            61147761,
            61146515,
            61163213,
            61156688,
            61153790,
            61144523
        ],
        "C": [
            61128802,
            61146533,
            61172060,
            61167384,
            61149264,
            61133355,
            61139896,
            61137699,
            61129905,
            61146775,
            61146749,
            61137639,
            61130666,
            61128891,
            61133021,
            61163475,
            61147427,
            61133523
        ],
        "B": [
            61122260,
            61138928,
            61125100,
            61135886,
            61136151,
            61126292,
            61136826,
            61131007,
            61122773,
            61127439,
            61129919,
            61122576,
            61124319,
            61122348,
            62114936,
            61124404,
            61125885,
            61125887,
            61124264
        ],
        "A": [
            61120076,
            61128524,
            61121738,
            61130255,
            61122144,
            61123763,
            61140465,
            61128200,
            61120371,
            61124618,
            61133127,
            61121262,
            61120693,
            61119937,
            62114885,
            61126319,
            61122327,
            61122607,
            61120311
        ]
    },
    "name": "F. Konrad and Company Evaluation",
    "statement": "Konrad is a Human Relations consultant working for VoltModder, a large\r\nelectrical equipment producer. Today, he has been tasked with evaluating\r\nthe level of happiness in the company.There are n people working for\r\nVoltModder, numbered from 1 to n. Each employee earns a different amount\r\nof money in the company initially, the i-th person earns i rubles per\r\nday.On each of q following days, the salaries will be revised. At the\r\nend of the i-th day, employee v_i will start earning n+i rubles per day\r\nand will become the best-paid person in the company. The employee will\r\nkeep his new salary until it gets revised again.Some pairs of people\r\ndon\u2019t like each other. This creates a great psychological danger in the\r\ncompany. Formally, if two people a and b dislike each other and a earns\r\nmore money than b, employee a will brag about this to b. A is a triple\r\nof three employees a, b and c, such that a brags to b, who in turn brags\r\nto c. If a dislikes b, then b dislikes a.At the beginning of each day,\r\nKonrad needs to evaluate the number of in the company. Can you help him\r\ndo it?\r\n",
    "solutions": [
        "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 1e5 + 5;\n\nvector<int> g[N];\nLL deg[N];\n\nint main() {\n    int n = read(), m = read();\n    for (int i = 0; i < m; ++i) {\n        int x = read(), y = read();\n        if (x > y) swap(x, y);\n        ++deg[x]; ++deg[y];\n        g[x].emplace_back(y);\n    }\n    LL ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        ans += (LL) g[i].size() * (deg[i] - (LL) g[i].size());\n    }\n    printf(\"%lld\\n\", ans);\n    int q = read();\n    while (q--) {\n        int x = read();\n        ans -= (LL) g[x].size() * (deg[x] - (LL) g[x].size());\n        for (int y : g[x]) {\n            ans += deg[y] - 2 * (LL) g[y].size() - 1;\n            g[y].emplace_back(x);\n        }\n        g[x].clear();\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Konrad and Company Evaluation.json",
    "editorial_link": "https://codeforces.com//blog/entry/70008",
    "editorial": "Let's imagine that the graph is directed as in the sample explanation (and edge u?v\n exists if u\n brags to v\n). We have to deal with two kinds of queries:\n\nCount the number of three-vertex directed paths.\nChange the direction of a single edge in the graph.\nIf we remember indegrees indeg\n and outdegrees outdeg\n for each vertex, then we can see that the result for the first query is ?vindeg(v)?outdeg(v)\n. It's also easy to maintain the in- and outdegrees for each vertex when updating the graph using the second query.\n\nLet's get back to the original problem. If a person v\n becomes the best-paid employee in the company, we can model it as taking all the edges ending at v\n, and reversing their direction.\n\nIt turns out that throughout the whole simulation, this edge-reversal won't happen too many times! Let's sort the vertices from left to right by their degree in the decreasing order. It now turns out that each vertex is adjacent with at most 2m????\n vertices to its left: if there were more, it would mean that there exist more that 2m????\n vertices with their degrees larger than 2m????\n. It would mean that the sum of degrees of all the vertices in the graph is more than 2m?????2m????=2m\n \u0097 a contradiction.\n\nDefine the potential of the graph as the number of edges which point from left to right. If we revise the salary for employee v\n, we might need to flip many edges, but at most 2m????\n new edges will start pointing from left to right. The remaining edges incident to v\n will now point from right to left. Therefore, we do the number of swaps proportional to the change of the potential, and the potential at each query can increase at most by 2m????\n. The potential at the beginning could be as high as m\n, and therefore the total number of swaps throughout the algorithm is at most m+q2m????\n.\n\nThe algorithm can be therefore implemented in O(n+m+qm???)\n time. Note that we should store the adjacency list of the directed graph in vectors \u0097 when we revise the salary of employee v\n, we should process all edges entering v\n and simply clear the corresponding vector. Storing the graph in sets or hashsets has worse complexity or a huge constant factor and will likely time out."
}