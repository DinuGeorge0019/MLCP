{"link": "https://codeforces.com//contest/192/problem/C", "problemId": "1357", "problem_idx": "C", "shortId": "192C", "contest_number": "192", "problem_submissions": {"E": [1730427, 1729827, 1729169, 1737343, 1730835, 1730060, 1730937, 1729815, 1729714, 1730328, 1742732, 1730184, 1806477, 1737169, 1737156], "D": [1728885, 1728181, 1729939, 1729209, 1730875, 1729431, 1730793, 1731274, 1729104, 1729076, 1729834, 1729950, 1730041, 1729892, 1730175, 1729978], "C": [1727437, 1727181, 1730368, 1727614, 1728967, 1728425, 1726946, 1730464, 1727937, 1727660, 1727585, 1727616, 1727725, 1727798, 1727968, 1728394, 1728325, 1727926], "B": [1726501, 1725823, 1726206, 1726346, 1727073, 1726253, 1725853, 1726712, 1726473, 1726128, 1725769, 1726259, 1726326, 1726262, 1726409, 1726302, 1726871, 1726862], "A": [1725727, 1725470, 1725578, 1725407, 1725501, 1731382, 2807333, 1731777, 1742258, 1725639, 1725724, 1725378, 1725587, 1725709, 1730327, 1725718, 1725838, 1725740, 1725684]}, "name": "C. Dynasty Puzzles", "statement": "The ancient Berlanders believed that the longer the name, the more\r\nimportant its bearer is. Thus, Berland kings were famous for their long\r\nnames. But long names are somewhat inconvenient, so the Berlanders\r\nstarted to abbreviate the names of their kings. They called every king\r\nby the first letters of its name. Thus, the king, whose name was\r\nVictorious Vasily Pupkin, was always called by the berlanders VVP.In\r\nBerland over its long history many dynasties of kings replaced each\r\nother, but they were all united by common traditions. Thus, according to\r\none Berland traditions, to maintain stability in the country, the first\r\nname of the heir should be the same as the last name his predecessor\r\n(hence, the first letter of the abbreviated name of the heir coincides\r\nwith the last letter of the abbreviated name of the predecessor).\r\nBerlanders appreciate stability, so this tradition has never been\r\nbroken. Also Berlanders like perfection, so another tradition requires\r\nthat the first name of the first king in the dynasty coincides with the\r\nlast name of the last king in this dynasty (hence, the first letter of\r\nthe abbreviated name of the first king coincides with the last letter of\r\nthe abbreviated name of the last king). This tradition, of course, has\r\nalso been always observed.The name of a dynasty is formed by very simple\r\nrules: we take all the short names of the kings in the order in which\r\nthey ruled, and write them in one line. Thus, a dynasty of kings \"ab\"\r\nand \"ba\" is called \"abba\", and the dynasty, which had only the king\r\n\"abca\", is called \"abca\".Vasya, a historian, has recently found a list\r\nof abbreviated names of all Berland kings and their relatives. Help\r\nVasya to find the maximally long name of the dynasty that could have\r\nexisted in Berland.Note that in his list all the names are ordered by\r\nthe time, that is, if name is earlier in the list than , then if and\r\nwere kings, then king ruled before king .\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define FORD(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define fup FOR\n#define fdo FORD\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define ALL(x) (x).begin(),(x).end()\n#define SIZE(x) ((int)(x).size())\n#define siz SIZE\n#define CLR memset((x),0,sizeof (x))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SQR(a) ((a)*(a))\n\n#define DEBUG 1\n#define debug(x) {if(DEBUG) cerr << #x << \" = \" << x << endl;}\n#define debugv(x) {if(DEBUG) {cerr << #x << \" = \"; FORE(it,(x)) cerr << *it << \" . \"; cerr  <<endl;}}\n\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef VI vi;\ntypedef LL lli;\n\nconst int inf = 1000000000;\n\nconst int ALF = 26;\nint res[ALF][ALF];\n\nvoid sset(int i, int j, int v) {\n    if (res[i][j] < v) res[i][j] = v;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char buf[20];\n    REP(i, ALF) REP(j, ALF) res[i][j] = -inf;\n    REP(i, n) {\n        scanf(\"%s\", buf);\n        int l = strlen(buf);\n        REP(j,l) buf[j] -= 'a';\n        REP(a, ALF) {\n            sset(a, buf[l-1], l+res[a][buf[0]]);\n        }\n        sset(buf[0], buf[l-1], l);\n    }\n    int m = 0;\n    REP(i, ALF) {\n        m = max(m, res[i][i]);\n    }\n    printf(\"%d\\n\", m);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "1500", "interactive": false}