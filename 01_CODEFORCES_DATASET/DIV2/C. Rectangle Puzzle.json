{"link": "https://codeforces.com//contest/281/problem/C", "problemId": "2722", "problem_idx": "C", "shortId": "281C", "contest_number": "281", "problem_submissions": {"E": [3283483, 3280513, 83186797, 3282100, 3282867], "D": [3280737, 3280273, 3278003, 3278968, 3282200, 3280660, 3279694, 3281443, 3282246, 3283008, 3283922, 3282844, 3283697], "C": [3278293, 3277396, 3284012, 3281377, 3283186], "B": [3276309, 3278090, 3276072, 3277223, 3286976, 3276173, 3276703, 3277506, 3276168, 3280432, 3280316, 3277025, 3276467, 3417552, 3277388, 3276638, 3287354], "A": [3274463, 3274325, 3274769, 3275162, 3274438, 3274688, 3274803, 3274521, 3274569, 3274437, 3279688, 3274972, 3274371, 3275776, 3274400, 3276374]}, "name": "C. Rectangle Puzzle", "statement": "You are given two rectangles on a plane. The centers of both rectangles\r\nare located in the origin of coordinates (meaning the center of the\r\nrectangle\u2019s symmetry). The first rectangle\u2019s sides are parallel to the\r\ncoordinate axes: the length of the side that is parallel to the axis,\r\nequals , the length of the side that is parallel to the axis, equals .\r\nThe second rectangle can be obtained by rotating the first rectangle\r\nrelative to the origin of coordinates by angle . Your task is to find\r\nthe area of the region which belongs to both given rectangles. This\r\nregion is shaded in the picture.\r\n", "solutions": ["#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nconst double Pi = acos(-1.0);\n#define eps 1e-8\n\ninline int cmp(double x, double y = 0, double tol = eps) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x = 0, double y = 0): x(x), y(y) {}\n\tpoint operator +(point q) { return point(x + q.x, y + q.y); }\n\tpoint operator -(point q) { return point(x - q.x, y - q.y); }\n\tpoint operator *(double t) { return point(x * t, y * t); }\n\tpoint operator /(double t) { return point(x / t, y / t); }\n\tdouble operator *(point q) { return x * q.x + y * q.y; } //produto escalar\n\tdouble operator %(point q) { return x * q.y - y * q.x; } //produto cruzado\n\tdouble mod() { return sqrt(x * x + y * y); }\n\tpoint rotate(double t) { return point(x*cos(t) - y*sin(t), x*sin(t) + y*cos(t)); }\n\tint cmp(point q) const {\n\t\tif (int t = ::cmp(x, q.x)) return t;\n\t\treturn ::cmp(y, q.y);\n\t}\n\tbool operator ==(point q) const { return cmp(q) == 0; }\n\tbool operator !=(point q) const { return cmp(q) != 0; }\n\tbool operator < (point q) const { return cmp(q) < 0; }\n\tstatic point pivot;\n};\npoint point::pivot;\ntypedef vector<point> polygon;\ntypedef pair<point,point> line;\n\n\ndouble poly_area(polygon& T) {\n\tdouble s = 0; int n = T.size();\n\tfor (int i = 0; i < n; i++)\n\t\ts += T[i] % T[(i+1) % n];\n\treturn s / 2;\n}\n\n//Encontra o ponto de interse\u00e7\u00e3o das retas pq e rs.\npoint line_intersect(point p, point q, point r, point s) {\n\tpoint a = q - p, b = s - r, c = point(p % q, r % s);\n\treturn point(point(a.x, b.x) % c, point(a.y, b.y) % c) / (a % b);\n}\n\n// Retorna a intersec\u00e7\u00e3o de um pol\u00edgono simples com um semiplano\n// TODO cuidado qdo o poligono nao for convexo\n// sumpoem q o semiplano eh o lado esquerdo, indo de p1 para p2\npolygon halfplane(polygon& p, line semiplano) {\n\tpolygon q;\n\tpoint p1 = semiplano.first, p2 = semiplano.second;\n\n\t// Sequ\u00eancia pol\u00edgono convexo exaustiva, para determinar se o semiplano.\n\tint n = p.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble c = (p2-p1) % (p[i]-p1);\n\t\tdouble d = (p2-p1) % (p[(i+1)%n]-p1);\n\t\tif (cmp(c) >= 0) q.push_back(p[i]);\n\t\tif (cmp(c * d) < 0) q.push_back(line_intersect(p1, p2, p[i], p[(i+1)%n]));\n\t}\n\treturn q;\n}\n\npolygon semi_plano_cruzado(vector <line> semiplano) {\n\t// Pr\u00e9-definir um limite grande quadrado\n\tpolygon p;\n\tp.push_back(point(-1e9,-1e9));\n\tp.push_back(point(-1e9,+1e9));\n\tp.push_back(point(+1e9,+1e9));\t\n\tp.push_back(point(+1e9,-1e9));\n\n\tint n = semiplano.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tp = halfplane(p, semiplano[i]);\n\t\tif (p.size() == 0) break;    // Degrada\u00e7\u00e3o ou vazio\n\t}\n\treturn p;\n}\n\n\nint main() {\n\tdouble w, h, a; cin >> w >> h >> a;\n\tdouble gama = atan(w/h); //printf(\"%lf %lf\\n\", gama, gama*180/Pi);\n\tdouble beta = atan(h/w);\n\tpolygon p, q;\n\tp.pb(point(-0.5*w, -0.5*h));\n\tp.pb(point(-0.5*w, 0.5*h));\n\tp.pb(point(0.5*w, 0.5*h));\t\n\tp.pb(point(0.5*w, -0.5*h));\n\t\n\ta = a*Pi / 180;\n\tdouble teta = 0.5*Pi + a - gama - beta;//printf(\"%lf %lf\\n\", teta, teta*180/Pi);\n\tq.pb(point(-0.5*w, -0.5*h));\n\tq.pb(point(-0.5*w, 0.5*h));\n\tq.pb(point(0.5*w, 0.5*h));\t\n\tq.pb(point(0.5*w, -0.5*h));\t\n\tfor (int i = 0; i < 4; i++) q[i] = q[i].rotate(teta);\n\t\n\t\n\t//for (int i = 0; i < 4; i++) printf(\"%.2lf %.2lf\\n\", p[i].x, p[i].y);\n\t//printf(\"\\n\");\n\t//for (int i = 0; i < 4; i++) printf(\"%.2lf %.2lf\\n\", q[i].x, q[i].y);\n\t//printf(\"\\n\");\t\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tp = halfplane(p, mp(q[(i+1)%4], q[i]) );\t\n\t}\n\tprintf(\"%.9lf\\n\", fabs(poly_area(p)));\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["geometry", "implementation"], "dificulty": "2000", "interactive": false}