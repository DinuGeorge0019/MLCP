{
    "link": "https://codeforces.com//contest/747/problem/C",
    "problemId": "85394",
    "problem_idx": "C",
    "shortId": "747C",
    "contest_number": "747",
    "problem_submissions": {
        "F": [
            23126704,
            23217267,
            52339523,
            52339464,
            23341357,
            23340816,
            23578865
        ],
        "E": [
            23125674,
            23121557,
            23122370,
            23123161,
            23124718,
            23124657,
            23124656,
            23123981,
            23122979,
            23122492,
            23124234,
            23124489,
            23124720,
            23123438,
            23122625,
            23124699,
            23124636,
            23124788
        ],
        "C": [
            23123534,
            23119516,
            23119605,
            23119464,
            23119789,
            23119774,
            23120245,
            23120834,
            23119880,
            23120172,
            23121050,
            23121104,
            23120094,
            23119293,
            23120587,
            23121256,
            23120349,
            23120870
        ],
        "D": [
            23122972,
            23121671,
            23121446,
            23122129,
            23122827,
            23122607,
            23123052,
            23122954,
            23121673,
            23124427,
            23123104,
            23123270,
            23123828,
            23121861,
            23124873,
            23123416,
            23123688,
            23123414
        ],
        "B": [
            23118814,
            23120201,
            23118777,
            23118662,
            23118893,
            23118919,
            23119154,
            23119419,
            23124358,
            23119396,
            23119237,
            23119831,
            23119076,
            23124567,
            23119518,
            23119781,
            23119199,
            23119454
        ],
        "A": [
            23117745,
            23119565,
            23117723,
            23117761,
            23117767,
            23117895,
            23117920,
            23118535,
            23123976,
            23117977,
            23119603,
            23118496,
            23117834,
            23123993,
            23117965,
            23119512,
            23118198,
            23118178
        ]
    },
    "name": "C. Servers",
    "statement": "There are servers in a laboratory, each of them can perform tasks. Each\r\nserver has a unique id integer from to .It is known that during the day\r\ntasks will come, the -th of them is characterized with three integers:\r\nthe moment in seconds in which the task will come, the number of servers\r\nneeded to perform it, and the time needed to perform this task in\r\nseconds. All are distinct.To perform the -th task you need servers which\r\nare unoccupied in the second . After the servers begin to perform the\r\ntask, each of them will be busy over the next seconds. Thus, they will\r\nbe busy in seconds . For performing the task, servers with the smallest\r\nids will be chosen from all the unoccupied servers. If in the second\r\nthere are not enough unoccupied servers, the task is ignored.Write the\r\nprogram that determines which tasks will be performed and which will be\r\nignored.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define ff first\n#define ss second\nusing namespace std;\nconst int N=200005;\nconst int inf=1e9+7;\ntypedef long long ll;\ntypedef long double lb;\ninline void read(int &x){x=0; char ch=getchar();while(ch<'0') ch=getchar();while(ch>='0'){x=x*10+ch-48; ch=getchar();}}\n//------------------------------------------head---------------------------------------------------//\nint f[105],ed[105];\nint main()\n{\n\tint n,q; read(n); read(q);\n\twhile(q--)\n\t{\n\t\tint ti,x,y; read(ti); read(x); read(y); int cnt=0;\n\t\trep(i,1,n) if(ed[i]<=ti) f[i]=0; rep(i,1,n) if(!f[i]) ++cnt;\n\t\tif(cnt<x)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}int ans=0;\n \t\trep(i,1,n) if(!f[i] && x)\n \t\t{\n \t\t\tx--; f[i]=1; ans+=i;\n \t\t\ted[i]=ti+y;\n \t\t}\n \t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Servers.json",
    "editorial_link": "https://codeforces.com//blog/entry/49171",
    "editorial": "The given constraints allow to simply modulate described process. Letâs\r\nuse array , where is equals to the time when -th server will become\r\nfree. Than for each query letâs find the number of servers which free in\r\nmoment when this query came. We can do it in , where is the number of\r\nservers. If the number of free servers is less than we need to print .\r\nIn the other case, we can iterate through all free servers and find the\r\nsum of servers with smallest numbers and store in array for this servers\r\ntime of release equals to .\r\n",
    "hint": []
}