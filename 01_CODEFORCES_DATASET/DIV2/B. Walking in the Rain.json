{"link": "https://codeforces.com//contest/192/problem/B", "problemId": "1356", "problem_idx": "B", "shortId": "192B", "contest_number": "192", "problem_submissions": {"E": [1730427, 1729827, 1729169, 1737343, 1730835, 1730060, 1730937, 1729815, 1729714, 1730328, 1742732, 1730184, 1806477, 1737169, 1737156], "D": [1728885, 1728181, 1729939, 1729209, 1730875, 1729431, 1730793, 1731274, 1729104, 1729076, 1729834, 1729950, 1730041, 1729892, 1730175, 1729978], "C": [1727437, 1727181, 1730368, 1727614, 1728967, 1728425, 1726946, 1730464, 1727937, 1727660, 1727585, 1727616, 1727725, 1727798, 1727968, 1728394, 1728325, 1727926], "B": [1726501, 1725823, 1726206, 1726346, 1727073, 1726253, 1725853, 1726712, 1726473, 1726128, 1725769, 1726259, 1726326, 1726262, 1726409, 1726302, 1726871, 1726862], "A": [1725727, 1725470, 1725578, 1725407, 1725501, 1731382, 2807333, 1731777, 1742258, 1725639, 1725724, 1725378, 1725587, 1725709, 1730327, 1725718, 1725838, 1725740, 1725684]}, "name": "B. Walking in the Rain", "statement": "In Berland the opposition is going to arrange mass walking on the\r\nboulevard. The boulevard consists of tiles that are lain in a row and\r\nare numbered from to from right to left. The opposition should start\r\nwalking on the tile number and the finish on the tile number . During\r\nthe walk it is allowed to move from right to left between adjacent tiles\r\nin a row, and jump over a tile. More formally, if you are standing on\r\nthe tile number , you can reach the tiles number or the tile number from\r\nit (if you stand on the tile number , you can only reach tile number ).\r\nWe can assume that all the opposition movements occur instantaneously.In\r\norder to thwart an opposition rally, the Berland bloody regime organized\r\nthe rain. The tiles on the boulevard are of poor quality and they are\r\nrapidly destroyed in the rain. We know that the -th tile is destroyed\r\nafter days of rain (on day tile isn\u2019t destroyed yet, and on day it is\r\nalready destroyed). Of course, no one is allowed to walk on the\r\ndestroyed tiles! So the walk of the opposition is considered thwarted,\r\nif either the tile number is broken, or the tile number is broken, or it\r\nis impossible to reach the tile number from the tile number if we can\r\nwalk on undestroyed tiles.The opposition wants to gather more supporters\r\nfor their walk. Therefore, the more time they have to pack, the better.\r\nHelp the opposition to calculate how much time they still have and tell\r\nus for how many days the walk from the tile number to the tile number\r\nwill be possible.\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define FORD(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define fup FOR\n#define fdo FORD\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define ALL(x) (x).begin(),(x).end()\n#define SIZE(x) ((int)(x).size())\n#define siz SIZE\n#define CLR memset((x),0,sizeof (x))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SQR(a) ((a)*(a))\n\n#define DEBUG 1\n#define debug(x) {if(DEBUG) cerr << #x << \" = \" << x << endl;}\n#define debugv(x) {if(DEBUG) {cerr << #x << \" = \"; FORE(it,(x)) cerr << *it << \" . \"; cerr  <<endl;}}\n\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef VI vi;\ntypedef LL lli;\n\nconst int inf = 1000000000;\nconst int MAXN = 10000;\nint a[MAXN];\nbool o[MAXN];\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    REP(i, n) {\n        scanf(\"%d\", &a[i]);\n    }\n    int beg = 0, end = MAXN;\n    o[n] = false;\n    while(end > beg) {\n        int med = (beg+end)/2;\n        bool ok = false;\n        REP(i, n) o[i] = false;\n        o[n-1] = a[n-1] >= med;\n        FORD(i, n-2, 0) {\n            o[i] = o[i+1] || o[i+2];\n            o[i] = o[i] && a[i] >= med;\n        }\n        ok = o[0]; \n        if (ok) beg = med+1;\n        else end = med;\n    }\n    printf(\"%d\\n\", beg-1);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "implementation"], "dificulty": "1100", "interactive": false}