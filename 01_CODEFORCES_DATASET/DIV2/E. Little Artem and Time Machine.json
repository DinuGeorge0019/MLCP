{"link": "https://codeforces.com//contest/669/problem/E", "problemId": "57069", "problem_idx": "E", "shortId": "669E", "contest_number": "669", "problem_submissions": {"E": [17491512, 17491017, 19750171, 17501056, 17493518, 17492061, 17493713, 17493393, 17493817, 17492979, 17493371, 17493114, 17495492, 17494782, 17494292, 17495191, 17493974, 17493836, 17494124], "D": [17488668, 17488489, 17486897, 17489357, 17489309, 17489532, 17490586, 17488952, 17490577, 17490565, 17488280, 17489742, 18583027, 18583013, 17490428, 17487352, 17490248, 17491103, 17491769], "C": [17485441, 17485907, 17484920, 17487516, 17486088, 17486618, 17486621, 17484945, 17488083, 17486963, 17486429, 17487871, 17486801, 17486397, 17488132, 17485146, 17486999], "B": [17482906, 17484441, 17482918, 17484173, 17483561, 17483294, 17484370, 17485567, 17486297, 17482984, 17483079, 17484306, 17484088, 17483002, 17484517, 17483240, 17484521], "A": [17481725, 17483043, 17482128, 17482178, 17481873, 17482008, 17481996, 17485818, 17482048, 17481645, 17481657, 17481965, 17482978, 17481666, 17483249, 17481910, 17482894]}, "name": "E. Little Artem and Time Machine", "statement": "Little Artem has invented a time machine! He could go anywhere in time,\r\nbut all his thoughts of course are with computer science. He wants to\r\napply this time machine to a well-known data structure: .Artem wants to\r\ncreate a basic multiset of integers. He wants these structure to support\r\noperations of three types: Add integer to the multiset. Note that the\r\ndifference between set and multiset is that multiset may store several\r\ninstances of one integer. Remove integer from the multiset. Only one\r\ninstance of this integer is removed. Artem doesn\u2019t want to handle any\r\nexceptions, so he assumes that every time remove operation is called,\r\nthat integer is presented in the multiset. Count the number of instances\r\nof the given integer that are stored in the multiset. But what about\r\ntime machine? Artem doesn\u2019t simply apply operations to the multiset one\r\nby one, he now travels to different moments of time and apply his\r\noperation there. Consider the following example. First Artem adds\r\ninteger to the multiset at the -st moment of time. Then Artem adds\r\ninteger to the multiset at the moment . Then Artem asks how many are\r\nthere in the multiset at moment . The answer is . Then Artem returns\r\nback in time and asks how many integers are there in the set at moment .\r\nSince was added only at moment , the number of integers at moment equals\r\nto . Then Artem goes back in time again and removes from the multiset at\r\nmoment . Finally Artyom asks at moment how many integers are there in\r\nthe set. The result is , since we have removed at the moment . Note that\r\nArtem dislikes exceptions so much that he assures that after each change\r\nhe makes all delete operations are applied only to element that is\r\npresent in the multiset. The answer to the query of the third type is\r\ncomputed at the moment Artem makes the corresponding query and are not\r\naffected in any way by future changes he makes.Help Artem implement time\r\ntravellers multiset.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define FOR(i, a, b) for(int i = a;i < b;++i)\n#define pb push_back\n#define X first\n#define Y second\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> ii;\nconst int MAX = 1 << 20;\nint ai[MAX], ti[MAX], xi[MAX];\nint comp[MAX];\nint n;\nvector<int> t[MAX];\nvector<int> logg[MAX];\n\nvoid compress () {\n\tcopy(xi, xi + n, comp);\n\tsort(comp, comp + n);\n\tREP(i, n) xi[i] = lower_bound(comp, comp + n, xi[i]) - comp;\n\tREP(i, n) t[xi[i]].pb(ti[i]);\n\tREP(i, MAX) sort(t[i].begin(), t[i].end());\n\tREP(i, n) ti[i] = lower_bound(t[xi[i]].begin(), t[xi[i]].end(), ti[i]) - t[xi[i]].begin();\n\tREP(i, MAX) {\n\t\tlogg[i].resize(t[i].size() + 1);\n\t\tfill(logg[i].begin(), logg[i].end(), 0);\n\t}\n}\n\nvoid update (vector<int> &lg, int pos, int val) {\n\tfor(pos++;pos < int(lg.size());pos += pos&-pos) lg[pos] += val;\n}\n\nint query (vector<int> &lg, int pos) {\n\tint res = 0;\n\tfor(pos++;pos;pos -= pos&-pos) res += lg[pos];\n\treturn res;\n}\n\nvoid solve () {\n\tREP(i, n) {\n\t\tif(ai[i] == 1) update(logg[xi[i]], ti[i], 1);\n\t\telse if(ai[i] == 2) update(logg[xi[i]], ti[i], -1);\n\t\telse printf(\"%d\\n\", query(logg[xi[i]], ti[i]));\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i, n) scanf(\"%d %d %d\", &ai[i], &ti[i], &xi[i]);\n\tcompress();\n\tsolve();\n}\n\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2000", "interactive": false}