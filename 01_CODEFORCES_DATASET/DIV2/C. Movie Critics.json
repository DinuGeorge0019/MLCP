{
    "link": "https://codeforces.com//contest/250/problem/C",
    "problemId": "2293",
    "problem_idx": "C",
    "shortId": "250C",
    "contest_number": "250",
    "problem_submissions": {
        "D": [
            2661219,
            2661302,
            2661169,
            2662484,
            2661663,
            2661650,
            2663624,
            2661614,
            2662775,
            2662098,
            2661832,
            2662182,
            2662202,
            2662743,
            2662343,
            2662306
        ],
        "E": [
            2660453,
            2662495,
            2662431,
            2662896,
            2662159,
            2663414,
            2662356,
            2666687,
            2663326,
            3224559
        ],
        "C": [
            2659482,
            2660436,
            2660472,
            2658939,
            2660327,
            2660252,
            2659990,
            2660985,
            2659709,
            2660447,
            2660653,
            2678663,
            2660908,
            2661315,
            2660197,
            2661069,
            2661058
        ],
        "B": [
            2659124,
            2659956,
            2659963,
            2660324,
            2659809,
            2659468,
            2659350,
            2660518,
            2660539,
            2659612,
            2660025,
            2660108,
            2659586,
            2659566,
            2660019,
            2659920
        ],
        "A": [
            2658537,
            2658807,
            2658632,
            2658949,
            2658816,
            2658618,
            2658590,
            2658601,
            2658691,
            2658849,
            2658966,
            2659142,
            2658749,
            2658817,
            2659154,
            2658983
        ]
    },
    "name": "C. Movie Critics",
    "statement": "A film festival is coming up in the city N. The festival will last for\r\nexactly days and each day will have a premiere of exactly one film. Each\r\nfilm has a genre an integer from 1 to .On the -th day the festival will\r\nshow a movie of genre . We know that a movie of each of genres occurs in\r\nthe festival programme at least once. In other words, each integer from\r\n1 to occurs in the sequence at least once.Valentine is a movie critic.\r\nHe wants to watch some movies of the festival and then describe his\r\nimpressions on his site.As any creative person, Valentine is very\r\nsusceptive. After he watched the movie of a certain genre, Valentine\r\nforms the he preserves until he watches the next movie. If the genre of\r\nthe next movie is the same, it does not change Valentine\u2019s mood. If the\r\ngenres are different, Valentine\u2019s mood changes according to the new\r\ngenre and Valentine has a .Valentine can\u2019t watch all movies, so he\r\ndecided to exclude from his to-watch list movies of one of the genres.\r\nIn other words, Valentine is going to choose exactly one of the genres\r\nand will skip all the movies of this genre. He is sure to visit other\r\nmovies.Valentine wants to choose such genre (), that the total number of\r\nafter-movie stresses (after all movies of genre are excluded) were\r\nminimum.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define FOR(it,a) for (__typeof((a).begin()) it=(a).begin();it!=(a).end();++it)\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\ninline int sign(double x)\n{\n    if (x<-eps) return -1;\n    return x>eps;\n}\n\nstruct Tpoint\n{\n    double x,y;\n    Tpoint(){}\n    Tpoint(double x,double y):x(x),y(y){}\n    inline double norm(){return sqrt(x*x+y*y);}\n    inline void rotate(double ang)\n    {\n        double co=cos(ang),si=sin(ang);\n        double tx=x,ty=y;\n        x=tx*co-ty*si;\n        y=tx*si+ty*co;\n    }\n};\n\ninline Tpoint operator +(const Tpoint &a,const Tpoint &b){return Tpoint(a.x+b.x,a.y+b.y);}\ninline Tpoint operator -(const Tpoint &a,const Tpoint &b){return Tpoint(a.x-b.x,a.y-b.y);}\ninline Tpoint operator *(const Tpoint &a,const double &b){return Tpoint(a.x*b,a.y*b);}\ninline Tpoint operator /(const Tpoint &a,const double &b){return Tpoint(a.x/b,a.y/b);}\ninline double det(const Tpoint &a,const Tpoint &b){return a.x*b.y-a.y*b.x;}\ninline double dot(const Tpoint &a,const Tpoint &b){return a.x*b.x+a.y*b.y;}\n//================================\n\nconst int maxn  =   100005;\n\nint delta[maxn];\n\nint main()\n{\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    VI a;\n    for (int i=0,x;i<n;++i){\n        scanf(\"%d\",&x);\n        if (a.size()==0 || x!=a.back()){\n            a.PB(x);\n        }\n    }\n    \n    int basic=(int)a.size()-1;\n    if (a.size()>1){\n        ++delta[a[0]];\n        ++delta[a[a.size()-1]];\n    }\n    for (int i=1;i+1<a.size();++i){\n        if (a[i-1]==a[i+1]){\n            delta[a[i]]+=2;\n        }else{\n            delta[a[i]]+=1;\n        }\n    }\n    int ans=1000000000,choice=0;\n    for (int i=1;i<=k;++i){\n        if (ans>basic-delta[i]){\n            ans=basic-delta[i];\n            choice=i;\n        }\n    }\n    printf(\"%d\\n\",choice);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Movie Critics.json",
    "editorial_link": "https://codeforces.com//blog/entry/5973",
    "editorial": "Now you should iterate over all maximal be inclusion segments and find\r\nimprovement for every of them. After that you should group all segments\r\nby genre and calculate sum of improvements inside every group. Answer\r\nwill be number of genre of group that has maximal total improvement (if\r\nthere are many of them, you should chose minimal number of genre). You\r\ncan implement this solution in in . Authors are MikeMirzayanov Gerald\r\nRipatti.\r\n"
}