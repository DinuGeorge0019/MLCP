{"link": "https://codeforces.com//contest/1339/problem/D", "problemId": "590529", "problem_idx": "D", "shortId": "1339D", "contest_number": "1339", "problem_submissions": {"E": [76376836, 76387473, 76384887, 76379831, 76388585, 76390578, 76396660, 76387000, 76387243, 76398417, 76396262, 76393298, 76399344, 76397428, 76394900, 76392890, 76397397], "D": [76366206, 76361616, 76361489, 76362609, 76370115, 76368889, 76363614, 76372647, 76369118, 76367884, 76374852, 76373935, 76373663, 76374136, 76369373, 76371535, 76374633], "C": [76348562, 76344606, 76350287, 76349364, 76346531, 76351575, 76343954, 76360371, 76355938, 76349819, 76351779, 76350689, 76348249, 76354286, 76352877, 76346445, 76346553], "B": [76343501, 76338131, 76337793, 76336924, 76339593, 76343198, 76337765, 76339336, 76344314, 76341691, 76343582, 76339210, 76341443, 76348496, 76344625, 76338360, 76339452], "A": [76339423, 76333974, 76334483, 76333757, 76334414, 76335125, 76333704, 76335982, 76335394, 76336250, 76335663, 76334669, 76335712, 76339115, 76336582, 76353895, 76335154]}, "name": "D. Edge Weight Assignment", "statement": "You have unweighted tree of n vertices. You have to assign a weight to\r\neach edge so that the following condition would hold: For every two\r\ndifferent leaves v_{1} and v_{2} of this tree, bitwise XOR of weights of\r\nall edges on the simple path between v_{1} and v_{2} has to be equal to\r\n0. Note that you can put positive integers (like 10^{(10^{10})}).It\u2019s\r\nguaranteed that such assignment always exists under given constraints.\r\nNow let\u2019s define f as in assignment. In this example, assignment is\r\nvalid, because bitwise XOR of all edge weights between every pair of\r\nleaves is 0. f value is 2 here, because there are 2 distinct edge\r\nweights(4 and 5). In this example, assignment is invalid, because\r\nbitwise XOR of all edge weights between vertex 1 and vertex 6 (3, 4, 5,\r\n4) is not 0. What are the minimum and the maximum possible values of f\r\nfor the given tree? Find and print both.\r\n", "solutions": ["\ufeff#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tvector<vector<UL>> E(N);\n\t\trep(i, N - 1) {\n\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\tE[u].push_back(v);\n\t\t\tE[v].push_back(u);\n\t\t}\n\t\tvector<UL> F(N);\n\t\tUL s; rep(i, N) if (E[i].size() == 1) s = i;\n\t\tqueue<UL> Q; F[s] = 1; Q.push(s);\n\t\twhile (Q.size()) {\n\t\t\tUL p = Q.front(); Q.pop();\n\t\t\tfor (UL e : E[p]) {\n\t\t\t\tif (F[e]) continue;\n\t\t\t\tF[e] = 3 - F[p];\n\t\t\t\tQ.push(e);\n\t\t\t}\n\t\t}\n\t\tbool dual = false;\n\t\trep(i, N) if (E[i].size() == 1) if (F[i] == 2) dual = true;\n\t\tUL ans = (dual ? 3 : 1);\n\t\tcout << ans << \" \";\n\t\tans = N - 1;\n\t\trep(i, N) if (E[i].size() != 1) {\n\t\t\tUL n = 0; for (UL e : E[i]) if (E[e].size() == 1) n++;\n\t\t\tn = max(n, 1u) - 1;\n\t\t\tans -= n;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "greedy", "trees"], "dificulty": "1800", "interactive": false}