{"link": "https://codeforces.com//contest/1562/problem/E", "problemId": "1090692", "problem_idx": "E", "shortId": "1562E", "contest_number": "1562", "problem_submissions": {"D1": [127110573, 127085719, 127084796, 127084014, 127082028, 127085521, 127097411, 127086825, 127084098, 127152628, 127086357, 127091256, 127089578, 127094935, 127087378, 127145842, 127096913, 127085638, 127093081, 127092946, 127097887], "C": [127103744, 127070687, 127073196, 127078874, 127072653, 127077271, 127080224, 127080082, 127076281, 127152605, 127080001, 127084225, 127080395, 127079018, 127078269, 127145835, 127074373, 127074883, 127071594, 127080320, 127084605], "F": [127097089, 127135208, 127161728, 127161600, 127229394, 127157826, 127137600, 127137538], "B": [127076926, 127064047, 127067878, 127063714, 127064849, 127070358, 127068285, 127074157, 127067634, 127152598, 127071567, 127066882, 127070574, 127066706, 127070386, 127145825, 127065946, 127063213, 127065381, 127068953, 127075580], "E": [127072906, 127104112, 127107000, 127110960, 127115711, 127114212, 127106853, 127106260, 127114534, 127115452, 127152643, 127119064, 127113726, 127111252, 127120883, 127122598, 127145862, 127118199, 127123949, 127112032, 127125984, 127116259], "A": [127058831, 127058219, 127058722, 127058582, 127058274, 127060830, 127061981, 127062185, 127059322, 127061493, 127152592, 127059028, 127058289, 127059753, 127058370, 127060017, 127145811, 127058384, 127058502, 127058367, 127058839, 127058595], "D2": [127087276, 127093820, 127092460, 127093109, 127096811, 127100821, 127112348, 127097441, 127096385, 127152634, 127098403, 127095759, 127102138, 127094867, 127102605, 127145854, 127108326, 127092734, 127119011, 127100809, 127104819]}, "name": "E. Rescue Niwen ", "statement": "After crossing the Windswept Wastes, Ori has finally reached the\r\nWindtorn Ruins to find the Heart of the Forest! However, the ancient\r\nrepository containing this priceless Willow light did not want to\r\nopen!Ori was taken aback, but the Voice of the Forest explained to him\r\nthat the cunning Gorleks had decided to add protection to the\r\nrepository.The Gorleks were very fond of the \"string expansion\"\r\noperation. They were also very fond of increasing subsequences.Suppose a\r\nstring s_1s_2s_3\r\nldots s_n is given. Then its \"expansion\" is defined as the sequence of\r\nstrings s_1, s_1 s_2, ..., s_1 s_2\r\nldots s_n, s_2, s_2 s_3, ..., s_2 s_3\r\nldots s_n, s_3, s_3 s_4, ..., s_{n-1} s_n, s_n. For example, the\r\n\"expansion\" the string \u201d will be the following sequence of strings: \u201d,\r\n\u201d, \u201d, \u201d, \u201d, \u201d, \u201d, \u201d, \u201d, \u201d. To open the ancient repository, Ori must find\r\nthe size of the largest increasing subsequence of the \"expansion\" of the\r\nstring s. Here, strings are compared lexicographically.Help Ori with\r\nthis task!A string a is lexicographically smaller than a string b if and\r\nonly if one of the following holds: a is a prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int N = 5005;\nint t, n, f[N];\nchar a[N];\nint rk[N], tp[N], tax[N], sa[N];\nint d[14][N];\ninline void radix_sort(int m) {\n  for (int i = 0; i <= m; i++) tax[i] = 0;\n  for (int i = 1; i <= n; i++) tax[rk[i]]++;\n  for (int i = 1; i <= m; i++) tax[i] += tax[i - 1];\n  for (int i = n; i; i--) sa[tax[rk[tp[i]]]--] = tp[i];\n}\ninline void suffix_sort() {\n  memset(rk, 0, sizeof rk);\n  memset(tp, 0, sizeof tp);\n  memset(tax, 0, sizeof tax);\n  memset(sa, 0, sizeof sa);\n  for (int i = 1; i <= n; i++) tax[rk[i] = a[i] - '0']++;\n  for (int i = 1; i <= 'z' - '0'; i++) tax[i] += tax[i - 1];\n  for (int i = n; i; i--) sa[tax[a[i] - '0']--] = i;\n  for (int len = 1, p = 0, m = 'z' - '0'; p < n; m = p, len <<= 1) {\n    p = len;\n    for (int i = 1; i <= len; i++) tp[i] = n - len + i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > len) tp[++p] = sa[i] - len;\n    radix_sort(m);\n    std::swap(tp, rk);\n    rk[sa[1]] = p = 1;\n    for (int i = 2; i <= n; i++)\n      rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + len] == tp[sa[i] + len]) ? p : ++p;\n  }\n  memset(tax, 0, (n + 1) << 2);\n}\ninline void get_height() {\n  memset(d, 0, sizeof d);\n  int j, k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (k) k--;\n    j = sa[rk[i] - 1];\n    while (a[i + k] == a[j + k]) k++;\n    d[0][rk[i]] = k;\n  }\n}\ninline void doubly() {\n  for (int j = 1; (1 << j) <= n; j++)\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n      d[j][i] = min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);\n    }\n}\ninline int query(int x, int y) {\n  if (x > y) swap(x, y);\n  x++;\n  int k = __lg(y - x + 1);\n  return min(d[k][x], d[k][y - (1 << k) + 1]);\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d%s\", &n, a + 1);\n    suffix_sort();\n    get_height();\n    doubly();\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int x = sa[i];\n      f[x] = n - x + 1;\n      for (int j = 1; j < i; j++)\n        if (sa[j] < x) {\n          f[x] = max(f[x], f[sa[j]] + n - x + 1 - query(j, i));\n        }\n      ans = max(ans, f[x]);\n    }\n    cout << ans << endl;\n  }\n}"], "input": "", "output": "", "tags": ["dp", "greedy", "string suffix structures", "strings"], "dificulty": "2500", "interactive": false}