{
    "link": "https://codeforces.com//contest/1562/problem/E",
    "problemId": "1090692",
    "problem_idx": "E",
    "shortId": "1562E",
    "contest_number": "1562",
    "problem_submissions": {
        "D1": [
            127110573,
            127085719,
            127084796,
            127084014,
            127082028,
            127085521,
            127097411,
            127086825,
            127084098,
            127152628,
            127086357,
            127091256,
            127089578,
            127094935,
            127087378,
            127145842,
            127096913,
            127085638,
            127093081,
            127092946,
            127097887
        ],
        "C": [
            127103744,
            127070687,
            127073196,
            127078874,
            127072653,
            127077271,
            127080224,
            127080082,
            127076281,
            127152605,
            127080001,
            127084225,
            127080395,
            127079018,
            127078269,
            127145835,
            127074373,
            127074883,
            127071594,
            127080320,
            127084605
        ],
        "F": [
            127097089,
            127135208,
            127161728,
            127161600,
            127229394,
            127157826,
            127137600,
            127137538
        ],
        "B": [
            127076926,
            127064047,
            127067878,
            127063714,
            127064849,
            127070358,
            127068285,
            127074157,
            127067634,
            127152598,
            127071567,
            127066882,
            127070574,
            127066706,
            127070386,
            127145825,
            127065946,
            127063213,
            127065381,
            127068953,
            127075580
        ],
        "E": [
            127072906,
            127104112,
            127107000,
            127110960,
            127115711,
            127114212,
            127106853,
            127106260,
            127114534,
            127115452,
            127152643,
            127119064,
            127113726,
            127111252,
            127120883,
            127122598,
            127145862,
            127118199,
            127123949,
            127112032,
            127125984,
            127116259
        ],
        "A": [
            127058831,
            127058219,
            127058722,
            127058582,
            127058274,
            127060830,
            127061981,
            127062185,
            127059322,
            127061493,
            127152592,
            127059028,
            127058289,
            127059753,
            127058370,
            127060017,
            127145811,
            127058384,
            127058502,
            127058367,
            127058839,
            127058595
        ],
        "D2": [
            127087276,
            127093820,
            127092460,
            127093109,
            127096811,
            127100821,
            127112348,
            127097441,
            127096385,
            127152634,
            127098403,
            127095759,
            127102138,
            127094867,
            127102605,
            127145854,
            127108326,
            127092734,
            127119011,
            127100809,
            127104819
        ]
    },
    "name": "E. Rescue Niwen ",
    "statement": "After crossing the Windswept Wastes, Ori has finally reached the\r\nWindtorn Ruins to find the Heart of the Forest! However, the ancient\r\nrepository containing this priceless Willow light did not want to\r\nopen!Ori was taken aback, but the Voice of the Forest explained to him\r\nthat the cunning Gorleks had decided to add protection to the\r\nrepository.The Gorleks were very fond of the \"string expansion\"\r\noperation. They were also very fond of increasing subsequences.Suppose a\r\nstring s_1s_2s_3\r\nldots s_n is given. Then its \"expansion\" is defined as the sequence of\r\nstrings s_1, s_1 s_2, ..., s_1 s_2\r\nldots s_n, s_2, s_2 s_3, ..., s_2 s_3\r\nldots s_n, s_3, s_3 s_4, ..., s_{n-1} s_n, s_n. For example, the\r\n\"expansion\" the string ” will be the following sequence of strings: ”,\r\n”, ”, ”, ”, ”, ”, ”, ”, ”. To open the ancient repository, Ori must find\r\nthe size of the largest increasing subsequence of the \"expansion\" of the\r\nstring s. Here, strings are compared lexicographically.Help Ori with\r\nthis task!A string a is lexicographically smaller than a string b if and\r\nonly if one of the following holds: a is a prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int N = 5005;\nint t, n, f[N];\nchar a[N];\nint rk[N], tp[N], tax[N], sa[N];\nint d[14][N];\ninline void radix_sort(int m) {\n  for (int i = 0; i <= m; i++) tax[i] = 0;\n  for (int i = 1; i <= n; i++) tax[rk[i]]++;\n  for (int i = 1; i <= m; i++) tax[i] += tax[i - 1];\n  for (int i = n; i; i--) sa[tax[rk[tp[i]]]--] = tp[i];\n}\ninline void suffix_sort() {\n  memset(rk, 0, sizeof rk);\n  memset(tp, 0, sizeof tp);\n  memset(tax, 0, sizeof tax);\n  memset(sa, 0, sizeof sa);\n  for (int i = 1; i <= n; i++) tax[rk[i] = a[i] - '0']++;\n  for (int i = 1; i <= 'z' - '0'; i++) tax[i] += tax[i - 1];\n  for (int i = n; i; i--) sa[tax[a[i] - '0']--] = i;\n  for (int len = 1, p = 0, m = 'z' - '0'; p < n; m = p, len <<= 1) {\n    p = len;\n    for (int i = 1; i <= len; i++) tp[i] = n - len + i;\n    for (int i = 1; i <= n; i++)\n      if (sa[i] > len) tp[++p] = sa[i] - len;\n    radix_sort(m);\n    std::swap(tp, rk);\n    rk[sa[1]] = p = 1;\n    for (int i = 2; i <= n; i++)\n      rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + len] == tp[sa[i] + len]) ? p : ++p;\n  }\n  memset(tax, 0, (n + 1) << 2);\n}\ninline void get_height() {\n  memset(d, 0, sizeof d);\n  int j, k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (k) k--;\n    j = sa[rk[i] - 1];\n    while (a[i + k] == a[j + k]) k++;\n    d[0][rk[i]] = k;\n  }\n}\ninline void doubly() {\n  for (int j = 1; (1 << j) <= n; j++)\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n      d[j][i] = min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);\n    }\n}\ninline int query(int x, int y) {\n  if (x > y) swap(x, y);\n  x++;\n  int k = __lg(y - x + 1);\n  return min(d[k][x], d[k][y - (1 << k) + 1]);\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d%s\", &n, a + 1);\n    suffix_sort();\n    get_height();\n    doubly();\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int x = sa[i];\n      f[x] = n - x + 1;\n      for (int j = 1; j < i; j++)\n        if (sa[j] < x) {\n          f[x] = max(f[x], f[sa[j]] + n - x + 1 - query(j, i));\n        }\n      ans = max(ans, f[x]);\n    }\n    cout << ans << endl;\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Rescue Niwen .json",
    "editorial_link": "https://codeforces.com//blog/entry/94278",
    "editorial": "The constraints on the problem were chosen so that solutions slower than\r\nwould not get AC, or would get with difficulty. The solution could be,\r\nfor example, to sort all substrings by assigning numbers to them, and\r\nthen find the largest increasing subsequence in the resulting array.Let\r\nus describe the solution for . The most important thing required for the\r\nsolution is to understand what the largest increasing subsequence should\r\nlook like.Let a string, and the length of the string .It can be shown\r\nthat if the largest increasing subsequence has a substring [ ... ], then\r\nit also has a substring [ ... ]. I will not give a formal proof, I will\r\nonly give the key idea. Let the increasing subsequence first have the\r\nstring [ ... ], and then the substring [ ... ], with . It can be\r\nunderstood that if suffixes [ ... ] and [ ... ] have some common prefix,\r\nand it has already been included in the largest increasing subsequence,\r\nthen we can drop the prefixes of the suffix [ . . ], and instead of them\r\nwrite exactly the same suffix prefixes of [ ... ], and the size of the\r\nincreasing subsequence will not change, and the condition above will be\r\nsatisfied. If, however, the suffixes [ ... ] and [ ... ] have no common\r\nprefix, then we could take the suffix itself [ ... ] together with its\r\nprefixes, and the answer would only improve.Thus, the largest increasing\r\nsubsequence looks like this: first comes some substring [ ... ],\r\nfollowed by a substring [ ... ], and so on, ending with the suffix [ ...\r\n]. After that comes some substring [ ... ], followed by a substring [\r\n... ], and so on, ending with the suffix [ ... ], and so on. Moreover,\r\nknowing which suffixes are included in this subsequence, we can\r\nestablish all other substrings. Indeed, let the suffixes [ ... ] and [\r\n... ] be included in the sequence, and < . Then it is not difficult to\r\nsee that the suffix prefixes [ ... ] can be typed greedily, namely, to\r\ntake all substring [ ... ] such that they are larger than the suffix [\r\n... ].Note that if the substring [ ... ] is larger than the suffix [ ...\r\n], then the substring [ ... ] is also larger than the suffix [ ... ].\r\nAnd so, we can use the following algorithm to find out , that is, to\r\nfind out which suffix prefix [ ... ] to start typing the subsequence.\r\nLet be the size of the largest common prefix of suffixes [ ... ] and [\r\n... ]. Then it is easy to see that if the suffix [ ... ] is larger than\r\nthe suffix [ ... ], then the appropriate is , which means that you must\r\nstart typing all substrings, starting from the one that differs from the\r\nlargest common prefix of the two suffixes.So now we are left with two\r\nproblems. The first is you have to learn to quickly recognize the\r\ngreatest common prefix of the two suffixes. The second is to write a DP\r\nthat would allow you to recognize the answer.Letâs see how to solve the\r\nfirst problem. You can use different string algorties, such as a suffix\r\narray. Or we can write a simple DP that calculates an array of the\r\nlargest common prefixes over . The transitions in this DP and its\r\nimplementation can be seen in the authorâs solution code (lines\r\n37-48).Now about the DP that calculates the answer. Let us use the facts\r\nabove and do the following. Let denote the size of the answer if the\r\nlast substring in it is the suffix [ ... ]. Let , and then . Now letâs\r\ndo the following. We will go through from to , doing the following\r\nsimple steps: for each from to ( denotes the previous suffix in the\r\nanswer) we will check how many substring of the suffix [ ... ] we can\r\ntake: if the suffix [ ... ] is larger than the suffix [ ... ], we\r\ncalculate this number with the above described algorithm, using the\r\narray of largest common prefixes. Otherwise, we will not update, because\r\nthe suffix [ ... ] is less than or equal to the suffix [ ... ], we\r\ncannot take it in response. It is not difficult to guess that the answer\r\nis maximal in all .Thus, the problem is solved using two uncomplicated\r\ndynamics.Asymptotics: per test case.\r\n",
    "hint": [
        "Hint 1 To solve it, you will need to quickly (in O(1)) find the largest common prefix of two substring.",
        "Hint 2 Take some small strings and try to build the largest increasing subsequence. Maybe there's something special about it.",
        "Hint 3 Use dynamic programming."
    ]
}