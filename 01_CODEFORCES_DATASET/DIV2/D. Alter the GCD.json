{
    "link": "https://codeforces.com//contest/2005/problem/D",
    "problemId": "2874764",
    "problem_idx": "D",
    "shortId": "2005D",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "Full SolutionLet be the maximal value of .Finding the maximal sum of\r\n-s.Let\u00e2\u0080\u0099s define and as the -s of the -th prefixes of and , respectively.\r\nThen, for each index , such that , is a divisor of , so either or (the\r\nsame holds for ). This means, that there are at most different values in\r\neach of and . The same holds for suffixes.Now, let\u00e2\u0080\u0099s assume we have\r\nfixed the -s of and after the operation as and . Now, let\u00e2\u0080\u0099s consider the\r\nshortest of the longest prefixes of and having and , respectively. If\r\nthe swapped range has intersection with that prefix, we can just not\r\nswap the intersection as it cannot worsen the answer. The same holds for\r\nthe suffix. This means, that the swapped range should be inside the\r\nmiddle part left between that prefix and suffix. But the first and last\r\nelements of the middle part have to be changed, because they didn\u00e2\u0080\u0099t\r\nallow us to take longer prefix or suffix. So, the part that has to be\r\nswapped is that middle part.Then, we can see that the only sufficient\r\nlengths of the longest prefixes and suffixes are the places where one of\r\nthem (i.e. in array or ) changes (i.e. is a sufficient prefix if or ,\r\nbecause otherwise we would have taken longer prefix). So, we can brute\r\nforce through the sufficient prefixes and suffixes (the number of each\r\nis at most ). All we are left with is calculating the -s of the middle\r\nparts to update the answer, which can be done with sparse table. Now,\r\nlet\u00e2\u0080\u0099s brute force through the sufficient prefixes. Assume we are\r\nconsidering the prefix ending at . This means the left border of the\r\nrange will start at . Then, we can brute force the right border starting\r\nfrom . In each iteration, we keep -s of the range and update the answer.\r\nTo proceed to the next one, we only need to update the -s with the next\r\nnumbers of and .Finding the number of ways.Let\u00e2\u0080\u0099s fix the -s of and and\r\ncompute ( and ), which shows: the number of ways to get the fixed -s in\r\nthe interval without swapping a range, if the number of ways to get the\r\nfixed -s in the interval with a range started swapping but not ended\r\nyet, if the number of ways to get the fixed -s in the interval with an\r\nalready swapped range, if In all -s we assume we don\u00e2\u0080\u0099t swap and Then, we\r\ncalculate the with starting from . In each iteration, we check if the\r\npair is sufficient, or no (we consider them swapped, if ). If it is not\r\nsufficient, we don\u00e2\u0080\u0099t do anything. Otherwise: After the calculations the\r\nanswer is . But we have to subtract from the answer if not swapping any\r\nrange gives the expected sum of -s, because we counted that case once in\r\nand times when adding to . We also check the swaps of prefixes\r\nseparately.Finally, the only thing left is to brute force through the -s\r\nof and in a smart way. As and are not swapped, the -s of the arrays\r\nshould be their divisors. Then, it is enough to brute force through the\r\ndivisors of only (the of ), as the other is derieved from their sum. And\r\nsince has at most (, to be precise) divisors, the solution will be fast\r\nenough (actually, there are way too few cases when the derieved of is\r\nactually a divisor of ).Finalizing.But this solution is not fast enough\r\nwhen all -s are , because they have divisors, but in order to find them,\r\nwe need to do checks. It means, that the time complexity is , which is\r\nslow. To handle this, we can write another slower solution which doesn\u00e2\u0080\u0099t\r\ndepend on . One of them is the following solution working in , but comes\r\nfrom , which is actually amortized and faster. Slow SolutionWe brute\r\nforce through the left border, and then through the right border of the\r\nswapping range, keeping its and checking each of them.The reason we need\r\nthis slow solution is that now, we can use it for . But for bigger -s,\r\nthe first solution will work, because there are at most such -s. So the\r\ntime complexity for them will be for the sum of the -s and for the\r\nnumber of ways.For the small -s, the time complexity will be . See the\r\nformal proof below. Formal ProofLet\u00e2\u0080\u0099s say there are -s equal to . We\r\nknow, that . Then the time complexity will be .Time complexity: . It is\r\nactually a very rough estimation with amortized .\r\n",
    "name": "D. Alter the GCD",
    "statement": "You are given two arrays a_1, a_2,\r\nldots, a_n and b_1, b_2,\r\nldots, b_n.You must perform the following operation : choose any indices\r\nl and r such that 1\r\nle l\r\nle r\r\nle n; swap a_i and b_i for all i such that l\r\nleq i\r\nleq r. Find the maximum possible value of\r\ntext{gcd}(a_1, a_2,\r\nldots, a_n) +\r\ntext{gcd}(b_1, b_2,\r\nldots, b_n) after performing the operation exactly once. Also find the\r\nnumber of distinct pairs (l, r) which achieve the maximum value.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0int sir[2][200001] , prefix[2][200001] , sufix[2][200002];pair < pair <int , int> , int > stiva[2][2048];\u00a0inline void Solve (){    int lungime;    cin >> lungime;\u00a0    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[0][indice]; prefix[0][indice] = __gcd(prefix[0][indice - 1] , sir[0][indice]); }    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[1][indice]; prefix[1][indice] = __gcd(prefix[1][indice - 1] , sir[1][indice]); }\u00a0    sufix[0][lungime + 1] = sufix[1][lungime + 1] = 0;    for (int indice = lungime ; indice ; indice--)        { sufix[0][indice] = __gcd(sufix[0][indice + 1] , sir[0][indice]); }    for (int indice = lungime ; indice ; indice--)        { sufix[1][indice] = __gcd(sufix[1][indice + 1] , sir[1][indice]); }\u00a0    int maxim = -1;    int64_t aparitii = 0;    for (int dreapta = 1 ; dreapta <= lungime ; dreapta++)    {        int ramas = 1;        stiva[0][++stiva[0][0].second] = {{prefix[0][dreapta - 1] , sir[0][dreapta]} , dreapta};        stiva[0][1].first.second = __gcd(stiva[0][1].first.second , sir[0][dreapta]);\u00a0        for (int indice = 2 ; indice <= stiva[0][0].second ; indice++)        {            stiva[0][indice].first.second = __gcd(stiva[0][indice].first.second , sir[0][dreapta]);            if (stiva[0][indice].first == stiva[0][ramas].first)                { stiva[0][ramas].second = stiva[0][indice].second; }            else                { stiva[0][++ramas] = stiva[0][indice]; }        }\u00a0        stiva[0][0].second = ramas;                ramas = 1;        stiva[1][++stiva[1][0].second] = {{prefix[1][dreapta - 1] , sir[1][dreapta]} , dreapta};        stiva[1][1].first.second = __gcd(stiva[1][1].first.second , sir[1][dreapta]);\u00a0        for (int indice = 2 ; indice <= stiva[1][0].second ; indice++)        {            stiva[1][indice].first.second = __gcd(stiva[1][indice].first.second , sir[1][dreapta]);            if (stiva[1][indice].first == stiva[1][ramas].first)                { stiva[1][ramas].second = stiva[1][indice].second; }            else                { stiva[1][++ramas] = stiva[1][indice]; }        }\u00a0        stiva[1][0].second = ramas;\u00a0        int indice_1 = stiva[0][0].second , indice_2 = stiva[1][0].second;        while (indice_1)        {            const int urmatorul_1 = (indice_1 == 1 ? 0 : stiva[0][indice_1 - 1].second);            const int urmatorul_2 = (indice_2 == 1 ? 0 : stiva[1][indice_2 - 1].second);            const int candidat_1 = __gcd(sufix[0][dreapta + 1] , __gcd(stiva[0][indice_1].first.first , stiva[1][indice_2].first.second));            const int candidat_2 = __gcd(sufix[1][dreapta + 1] , __gcd(stiva[1][indice_2].first.first , stiva[0][indice_1].first.second));            if (candidat_1 + candidat_2 > maxim) { maxim = candidat_1 + candidat_2; aparitii = min(stiva[0][indice_1].second , stiva[1][indice_2].second) - max(urmatorul_1 , urmatorul_2); }            else if (candidat_1 + candidat_2 == maxim) { aparitii += min(stiva[0][indice_1].second , stiva[1][indice_2].second) - max(urmatorul_1 , urmatorul_2); }            if (urmatorul_1 == urmatorul_2) { indice_1--; indice_2--; }            else if (urmatorul_1 < urmatorul_2) { indice_2--; }            else { indice_1--; }        }    }\u00a0    cout << maxim << ' ' << aparitii << '\\n';\u00a0    stiva[0][0].second = stiva[1][0].second = 0;}\u00a0int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);\u00a0    int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }\u00a0    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "implementation",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Alter the GCD.json"
}