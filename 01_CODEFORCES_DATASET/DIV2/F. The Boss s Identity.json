{
    "link": "https://codeforces.com//contest/1847/problem/F",
    "problemId": "1996643",
    "problem_idx": "F",
    "shortId": "1847F",
    "contest_number": "1847",
    "problem_submissions": {
        "F": [
            212433608,
            212431110,
            212414836,
            212437044,
            212436646,
            212438573,
            212439809,
            212461142,
            212444034,
            212441048,
            212442560,
            212446414,
            212448526,
            212446363,
            212477387,
            212473113,
            212447258,
            212445412,
            212440060,
            212484613,
            212430011,
            212447626,
            212448642,
            212429172
        ],
        "D": [
            212389437,
            212405663,
            212427981,
            212401825,
            212406614,
            212408665,
            212391793,
            212412178,
            212420289,
            212416938,
            212416798,
            212415041,
            212411965,
            212408607,
            212417943,
            212402342,
            212440813,
            212424407,
            212414209,
            212448028
        ],
        "C": [
            212379554,
            212388481,
            212381978,
            212383167,
            212391492,
            212395637,
            212408363,
            212918680,
            212459952,
            212459679,
            212387499,
            212392748,
            212401136,
            212392067,
            212389261,
            212394523,
            212454918,
            212396638,
            212395742,
            212387056,
            212410808,
            212403757,
            212388758,
            212439567
        ],
        "B": [
            212375586,
            212386366,
            212383195,
            212377114,
            212379209,
            212382779,
            212400416,
            212381176,
            212374781,
            212381202,
            212383485,
            212376778,
            212384302,
            212388840,
            212379283,
            212442148,
            212382593,
            212383125,
            212398777,
            212403514
        ],
        "A": [
            212372531,
            212381099,
            212372843,
            212372985,
            212372832,
            212383462,
            212396957,
            212372898,
            212372422,
            212372468,
            212373223,
            212373301,
            212373237,
            212373415,
            212375604,
            212372629,
            212374004,
            212375662,
            212372722,
            212387500
        ],
        "E": [
            212780531,
            212480822
        ]
    },
    "name": "F. The Boss s Identity",
    "statement": "While tracking Diavolo’s origins, Giorno receives a secret code from\r\nPolnareff. The code can be represented as an infinite sequence of\r\npositive integers: a_1, a_2,\r\ndots . Giorno immediately sees the pattern behind the code. The first n\r\nnumbers a_1, a_2,\r\ndots, a_n are . For i > n the value of a_i is (a_{i-n}\r\n|\r\na_{i-n+1}), where | denotes the bitwise OR operator.Pieces of\r\ninformation about Diavolo are hidden in q questions. Each question has a\r\npositive integer v associated with it and its answer is the smallest\r\nindex i such that a_i > v. If no such i exists, the answer is -1. Help\r\nGiorno in answering the questions!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define N 200'005\n\nint n, q, a[N << 1], val[N];\nvector<pair<int, int>> mx[N];\nvector<int> bit[31];\nvoid solve()\n{\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i], a[i + n] = a[i];\n    for (int i = 1; i <= n * 2; i++)\n    {\n        for (int j = 30; j >= 0; j--)\n        {\n            if (a[i] >> j & 1)\n                bit[j].push_back(i);\n        }\n    }\n    for (int i = n + 1; i <= n * 2; i++)\n    {\n        vector<int> zerobit;\n        for (int j = 30; j >= 0; j--)\n        {\n            if (!(a[i] >> j & 1))\n                zerobit.push_back(j);\n        }\n        vector<int> pos{i};\n        if (i != n + 1)\n        {\n            for (int j : zerobit)\n            {\n                auto it = lower_bound(bit[j].begin(), bit[j].end(), i);\n                if (it != bit[j].begin())\n                    it--;\n                if (it != bit[j].end() && *it + n > i)\n                    pos.push_back(*it);\n            }\n        }\n        sort(pos.begin(), pos.end(), greater<>());\n        int xval = 0;\n        for (int j : pos)\n        {\n            xval |= a[j];\n            int x = i - j + 1;\n            if (xval > val[x])\n            {\n                mx[x].push_back({xval, i - n});\n                val[x] = xval;\n            }\n        }\n    }\n\n    for (int i = 2; i <= n; i++)\n        val[i] = max(val[i - 1], val[i]);\n\n    while (q--)\n    {\n        int x;\n        cin >> x;\n        x++;\n        if (val[n] < x)\n        {\n            cout << -1 << '\\n';\n            continue;\n        }\n        int l = 1, r = n, mid;\n        while (l < r)\n        {\n            mid = l + r >> 1;\n            if (val[mid] < x)\n                l = mid + 1;\n            else\n                r = mid;\n        }\n\n        auto cal = [&](int x, int val) -> i64\n        {\n            if (x == 1)\n            {\n                auto it = lower_bound(mx[x].begin(), mx[x].end(), pair<int, int>{val, 0});\n                return it->second;\n            }\n            i64 res = n;\n            res += (i64)(x - 2) * (n - 1);\n            auto it = lower_bound(mx[x].begin(), mx[x].end(), pair<int, int>{val, 0});\n            res += it->second - 1;\n            return res;\n        };\n\n        cout << cal(r, x) << '\\n';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        val[i] = 0;\n        mx[i].clear();\n    }\n    for (int i = 0; i <= 30; i++)\n        bit[i].clear();\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "dfs and similar",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. The Boss s Identity.json",
    "editorial_link": "https://codeforces.com//blog/entry/117928",
    "editorial": "Lets start with an example of . Let where ,,, and are variables. First\r\nelements of will be [,,,,,,,,,,,,,,,,,,,]. By removing and rearranging\r\nsome elements we can get Here you can observe that each group will have\r\na size of . The next group will be the previous group, _or_ed with the\r\nelement the first element (circularly).So we have the rule. Now letâs\r\nsolve the problem in binary (that is, every element is ). Letâs take a\r\nlook at the element in the rearranged version (the highlighted ones). If\r\nis , it wonât contribute anything to the subsequent groups, so we can\r\nignore it. Otherwise, it will contribute by keeping moving to the right.\r\nThis will end when it meets a cell in the group that is already . And\r\nafter that, we can drop the act of moving .This algorithm can actually\r\nhelp us construct the whole array sparsely and incrementally. We can\r\nmaintain the list of in the initial array, and then update the array by\r\nmoving all of them to the right. That is, if we have one group, we can\r\nobtain the next group by moving the . After that, we can drop moving\r\nsome if it meets another .The whole action is , as there are at most\r\nzeros to be updated.So for the original problem, first of all, we can\r\nrepeat the above algorithm times, that is, repeat the algorithm for each\r\nbit. Secondly, there are at most unique numbers for each position, so we\r\ncan just find all last positions of all numbers, and put them in a\r\narray.You can either find all unique positions in ascending order and or\r\nin random order and sort the array. Then using binary search we can\r\nanswer each query. Time complexity of the former version is and the\r\nlatter version is .\r\n",
    "hint": []
}