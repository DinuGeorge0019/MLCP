{
    "link": "https://codeforces.com//contest/430/problem/A",
    "problemId": "9397",
    "problem_idx": "A",
    "shortId": "430A",
    "contest_number": "430",
    "problem_submissions": {
        "E": [
            6596209,
            6601239,
            6595457,
            6596869,
            6611998
        ],
        "C": [
            6593903,
            6589689,
            6590185,
            6591146,
            6594509,
            6591043,
            6594881,
            6592145,
            6591439,
            6590916,
            6592010,
            6592041,
            6592596,
            6592644,
            6593233,
            6592230,
            6592515,
            6591488,
            6591864
        ],
        "D": [
            6592681,
            6591086,
            6597590,
            6592274,
            6591820,
            6594037,
            6592628,
            6594400,
            6599564,
            6594397,
            6596203,
            6595708,
            6594744,
            6595014,
            6595972,
            6596088,
            6594380,
            6593712,
            6595433
        ],
        "B": [
            6591917,
            6588904,
            6589347,
            6590112,
            6589136,
            6589725,
            6590062,
            6590923,
            6589922,
            6588990,
            6590100,
            6590128,
            6591019,
            6591186,
            6590471,
            6590715,
            6590194,
            6589294,
            6593720
        ],
        "A": [
            6588412,
            6588136,
            6588222,
            6588465,
            6590072,
            6588672,
            6588238,
            6589003,
            6588856,
            6595945,
            6588333,
            6588427,
            6589419,
            6589285,
            6588864,
            6589371,
            6595841,
            6600698,
            6589758
        ]
    },
    "name": "A. Points and Segments  easy ",
    "statement": "Iahub isnâ€™t well prepared on geometry problems, but he heard that this\r\nyear there will be a lot of geometry problems on the IOI selection camp.\r\nScared, Iahub locked himself in the basement and started thinking of new\r\nproblems of this kind. One of them is the following.Iahub wants to draw\r\ndistinct points and segments on the axis. He can draw each point with\r\neither red or blue. The drawing is good if and only if the following\r\nrequirement is met: for each segment consider all the red points belong\r\nto it ( points), and all the blue points belong to it ( points); each\r\nsegment should satisfy the inequality .Iahub thinks that point belongs\r\nto segment , if inequality holds.Iahub gives to you all coordinates of\r\npoints and segments. Please, help him to find any good drawing.\r\n",
    "solutions": [
        "/**************************************************\n *        Problem:  Codeforces #245 Div.2 Problem A\n *         Author:  clavichord93\n *          State:  \n **************************************************/\n\n/**************************************************\n * Header\n **************************************************/\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <limits>\n#define Fill(a, b) memset(a, b, sizeof(a))\n#define Copy(a, b) memcpy(a, b, sizeof(b))\n#define NPOS string::npos\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define rrep(i, a, b) for (int i = a; i >= b; i--)\n#define erep(j, a) for (Edge *j = a; j; j = j->next)\n#define irep(i, a) for (__typeof(a.begin()) i = a.begin(); i != a.end(); i++)\n#define srep(sub, s) for (int sub = s & (s - 1); sub; sub = (sub - 1) & s)\n#define sqr(a) ((a) * (a))\n#define R(x) scanf(\"%d\", &x)\n#define SS(a, b) scanf(\"%d %d\", &a, &b)\n#define SSS(a, b, c) scanf(\"%d %d %d\", &a, &b, &c)\n#define O(x) pf(\"%d\\n\", x)\n#define TEST int T;scanf(\"%d\", &T);for (int cas = 1; cas <= T; cas++)\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define ppb pop_back\n#define pft push_front\n#define ppf pop_front\n#define mp make_pair\n#define vec vector\n#define it iterator\n#define fir first\n#define sec second\n#define x first\n#define y second\n#define all(a) a.begin(),a.end()\n#define sz(a) (int)(a.size())\n#define bg(a) (a).begin()\n#define en(a) (a).end()\n#define clr(a) (a).clear()\n#define dbg(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n#define bit_cnt(x) __builtin_popcount((unsigned)x)\n#define gcd(a, b) __gcd(a, b)\n#define sqr(a) ((a) * (a))\n#define lch(t) (t << 1)\n#define rch(t) (t << 1 | 1)\n#define inf numeric_limits<int>::max()\n#define finf numeric_limits<double>::infinity()\nusing namespace std;\ntemplate<class T> inline bool gmin(T &a, T b) { if (a > b) return a = b, true; return false; }\ntemplate<class T> inline bool gmax(T &a, T b) { if (a < b) return a = b, true; return false; }\ntemplate<class T> T exgcd(T a, T b, T &x, T &y) { if (!b) return x = (T)1, y = (T)0, a; else { T d = exgcd(b, a % b, y, x); return y -= a / b * x, d; } }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\ntypedef pair<double, double> pdd;\ntypedef pair<double, pdd> pddd;\ntypedef vec<int> vi;\ntypedef vec<double> vd;\ntypedef vec<pii> vii;\ntypedef vec<pdd> vdd;\ntypedef istringstream iss;\ntypedef ostringstream oss;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1e10;\nconst double EPS = 1e-9;\nconst double PI = 3.14159265358979323846264338327950288;\nconst double TAU = 2.0 * PI;\ninline int sgn(const double &a) { return a > EPS ? 1 : (a < -EPS ? -1 : 0); }\ninline int lowbit(int i) { return i & (-i); }\nstruct Initializer { Initializer() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); } } initializer;\n\n/**************************************************\n * Templates\n **************************************************/\n\n\n\n/**************************************************\n * Main\n **************************************************/\n\nconst int MAXN = 105;\n\nint n, m;\npii x[MAXN], s[MAXN];\nint c[MAXN], ans[MAXN];\n\nint main() {\n    SS(n, m);\n    rep (i, 1, n) {\n        sf(\"%d\", &x[i].fir);\n        x[i].sec = i;\n    }\n    sort(x + 1, x + 1 + n);\n    rep (i, 1, m) sf(\"%d %d\", &s[i].fir, &s[i].sec);\n    sort(s + 1, s + 1 + m);\n    Fill(c, 0xff);\n    rep (i, 1, m) {\n        int col = 0;\n        rep (j, 1, n) if (s[i].fir <= x[j].fir && x[j].fir <= s[i].sec) {\n            if (c[j] == -1) c[j] = col, col ^= 1;\n            else col = c[j] ^ 1;\n        }\n    }\n    rep (i, 1, n) {\n        if (c[i] == -1) c[i] = 0;\n        ans[x[i].sec] = c[i];\n    }\n    pf(\"%d\", ans[1]);\n    rep (i, 2, n) pf(\" %d\", ans[i]);\n    pf(\"\\n\");\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Points and Segments  easy .json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "The problem asks you to output -1 if there is no solution. A natural\r\nquestion is now: when there is no solution ? Try to come up with a test\r\nlike this! After some analysis, you ll see anyhow we draw the points and\r\nthe lines, there will always be a solution. By manually solving small\r\ncases, you might already have found the pattern. But for now, let s\r\nassume anyhow we draw points and lines, there will always be a solution.\r\nLet s have a fixed set of points. Then, anyhow we draw a line, there\r\nshould still be a solution. So, we need to find a coloring of points,\r\nsuch as for every line, |number of red points which belong to it number\r\nof blue points which belong to it| <= 1. Suppose anytime you color a\r\npoint with red you assign it +1 value. Also, anytime you color it with\r\nblue you assign it -1 value. Then, for a segment, the drawing is good if\r\nS = sum of values assigned to points that belong to segment is between\r\n-1 and 1 (in other words |S| <= 1). Let s sort points increasing by\r\nabscissa. It s useful because now, for a segment, there will be a\r\ncontiguous range of points that belong to that segment. For example,\r\nsuppose my current segment is [3, 7] and the initial set of points was\r\n{4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would\r\nbe first, third and sixth. Let s sort the points by abscissa. It looks\r\nlike {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of\r\npoints that belongs to [3, 7] segment: more exactly third, fourth and\r\nfifth. We reduced problem to: given an array, assign it either +1 or -1\r\nvalues such as, for each subarray (contiguous range), the sum S of\r\nsubarray s elements follows the condition |S| <= 1. Before reading on,\r\ntry to come up with an example by yourself. My solution uses the\r\npattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its\r\nelements either -1, 0 or 1. How to proof it? When dealing with sums of\r\nsubarrays, a good idea is to use partial sums. Denote sum[i] = x[1] +\r\nx[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] sum[x 1].\r\nPartial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there\r\nare 4 possible cases: 1/ sum[x 1] = 0 and sum[y] = 0. sum[y] sum[x 1] =\r\n0 2/ sum[x 1] = 1 and sum[y] = 1. sum[y] sum[x 1] = 0 3/ sum[x 1] = 0\r\nand sum[y] = 1. sum[y] sum[x 1] = 1 4/ sum[x 1] = 1 and sum[y] = 0.\r\nsum[y] sum[x 1] = -1 Hence, each subarray sum is either -1, 0 or 1. So,\r\ngeneral algorithm looks like: sort points by abscissa, assign them red,\r\nblue, red, blue, ... and then sort them back by original order and print\r\nthe colors.\r\n",
    "hint": []
}