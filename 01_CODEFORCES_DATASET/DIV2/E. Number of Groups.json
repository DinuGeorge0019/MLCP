{
    "link": "https://codeforces.com//contest/1691/problem/E",
    "problemId": "1416261",
    "problem_idx": "E",
    "shortId": "1691E",
    "contest_number": "1691",
    "problem_submissions": {
        "F": [
            159037796,
            159004862,
            159045351,
            159041486,
            159074626,
            159060003,
            159067904,
            159020729,
            159065774,
            159064237,
            159068264,
            159063969,
            159078050,
            159063182,
            159071648,
            159076943,
            159063472,
            159076016,
            159077857
        ],
        "B": [
            159027507,
            159038230,
            158993583,
            158988023,
            158992996,
            158994717,
            158998069,
            158998926,
            158995615,
            158994699,
            158990804,
            158993808,
            158998565,
            158999263,
            158993130,
            158999935,
            158995666,
            158999458,
            158995141
        ],
        "C": [
            159022549,
            159035573,
            159003255,
            159002225,
            159000529,
            159011268,
            159008002,
            159028212,
            159004618,
            159012184,
            158998251,
            159004574,
            159008883,
            159022667,
            159090832,
            159011554,
            159006572,
            159005346,
            159010957,
            159006486
        ],
        "D": [
            159013958,
            159031555,
            159015433,
            159028094,
            159016632,
            159019611,
            159021146,
            159042470,
            159021759,
            159030292,
            159022623,
            159025372,
            159146607,
            159023715,
            159047830,
            159026170,
            159023572,
            159028563,
            159187233,
            159031404,
            159022310
        ],
        "E": [
            159000396,
            159018557,
            159029594,
            159057177,
            159032015,
            159039937,
            159038189,
            159062074,
            159045617,
            159045245,
            159054013,
            159039162,
            209514948,
            209514832,
            209514807,
            159105644,
            159105615,
            159105572,
            159105377,
            159104884,
            159097312,
            159096514,
            159095571,
            159042066,
            159035791,
            159048242,
            159046117,
            159052677,
            159191233,
            159190974,
            159179554,
            159054650,
            159057264
        ],
        "A": [
            158985679,
            159039068,
            158986800,
            158984482,
            158984538,
            158986015,
            158985132,
            158992280,
            158986339,
            158985193,
            158984622,
            158989832,
            158990669,
            158984543,
            158985817,
            158988085,
            158998809,
            158987967
        ]
    },
    "name": "E. Number of Groups",
    "statement": "You are given n colored segments on the number line. Each segment is\r\neither colored red or blue. The i-th segment can be represented by a\r\ntuple (c_i, l_i, r_i). The segment contains all the points in the range\r\n[l_i, r_i], inclusive, and its color denoted by c_i: if c_i = 0, it is a\r\nred segment; if c_i = 1, it is a blue segment. We say that two segments\r\nof colors are , if they share at least one common point. Two segments\r\nbelong to the same group, if they are either connected directly, or\r\nthrough a sequence of directly connected segments. Find the number of\r\ngroups of segments.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == '-', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nvector < tuple < int, int, int > > pot;\nint n, fa[N];\nset < pii > tpot[2];\n\nint gf(int x) { return x == fa[x] ? x : fa[x] = gf(fa[x]); }\n\nvoid solve() {\n\tn = in; pot.clear(), tpot[0].clear(), tpot[1].clear(); rep(i, 1, n) { int c = in, l = in, r = in; pot.eb(l, r, c); }\n\tsort(pot.begin(), pot.end()); rep(i, 1, n) fa[i] = i; int tot = 0;\n\tfor(auto v : pot) {\n\t\tint l, r, c, id = ++tot; tie(l, r, c) = v;\n\t\tauto it = tpot[c ^ 1].begin();\n\t\twhile(it != tpot[c ^ 1].end()) {\n\t\t\tif(it->fi < l) tpot[c ^ 1].erase(it++);\n\t\t\telse it++;\n\t\t}\n\t\tif(tpot[c ^ 1].size()) {\n\t\t\tpii mxr = { 0, 0 };\n\t\t\tfor(auto v : tpot[c ^ 1]) chkmax(mxr, v), fa[gf(v.se)] = gf(id);\n\t\t\ttpot[c ^ 1].clear(); tpot[c ^ 1].ep(mxr);\n\t\t}\n\t\ttpot[c].ep(r, id);\n\t}\n\tint ans = 0; rep(i, 1, n) if(gf(i) == i) ans++;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Number of Groups.json",
    "editorial_link": "https://codeforces.com//blog/entry/103212",
    "editorial": "We will be using the starting and ending points of different segments to\r\ncount the final answer. We maintain a Union-Find data structure (DSU) on\r\nsize corresponding to the segments given as input. We store all the\r\nstarting and ending points in a set. (example: If segments are and , we\r\nstore in a set irrespective of the color of the segment). We now iterate\r\nthrough these points in ascending order. We maintain running sets\r\ncorresponding to the colors. In these sets, we will store the segments\r\nfor which the starting point has been reached while iterating through\r\nthe set of points but the ending point hasnât been reached (ie: we store\r\nthe segments that have started but not ended).The algorithm works as\r\nfollows:If we are at a point : If it corresponds to a segmentâs starting\r\npoint: We add that segment to the set corresponding to its color We\r\nmerge (DSU merge) this segment with all segments present in the set\r\ncorresponding to the other color (since their ending point hasnât been\r\nreached yet). We also erase all segments in the set corresponding to the\r\nother color except the one with the largest closing point value. If the\r\npoint corresponds to a segmentâs ending point: We delete the segment\r\nfrom the set corresponding to its color. Why can we delete the segments\r\nof color except for the one with the largest ending point if we\r\nencounter a starting point of the other color?We are able to greedily\r\npick the segment with the furthest ending point value because all\r\nsegments of the same color in that set have been connected together by\r\nthe segments of the other color. Hence, we can just work with the\r\nsegments with the largest ending point value of both colors for each\r\ncomponent that exists.\r\n",
    "hint": [
        "Hint 1 We can iterate over the starting and ending points of all segments.",
        "Hint 2 Is it necessary to connect all segments which can be connected? Can we make observations which would reduce the number of connections we actually make?",
        "Hint 3 For each group formed, it is enough to store the blue segment with maximum ending point, and red segment with maximum ending point."
    ]
}