{
    "link": "https://codeforces.com//contest/675/problem/D",
    "problemId": "60391",
    "problem_idx": "D",
    "shortId": "675D",
    "contest_number": "675",
    "problem_submissions": {
        "E": [
            17948562,
            17949439,
            17951477,
            17952621,
            17953457,
            17950428,
            17953529,
            17947770,
            17951235,
            17951895,
            17951367,
            17951619,
            17948510,
            17952736,
            17951724
        ],
        "C": [
            17943932,
            17938689,
            17941522,
            17944729,
            17944175,
            17953098,
            17943056,
            17944846,
            17947374,
            17939953,
            17962657,
            17966235,
            17954725,
            17940735,
            17941726,
            22255966,
            17952634,
            17944646,
            17957135
        ],
        "D": [
            17942614,
            17940890,
            17945507,
            17947894,
            17948215,
            17945745,
            17947110,
            17948235,
            17945049,
            17945728,
            17947720,
            17940113,
            17945095,
            17943288,
            17943504,
            17946575,
            17949945,
            17942674,
            17945705,
            17947663
        ],
        "B": [
            17938759,
            17936066,
            17938993,
            17938420,
            17938948,
            17938583,
            17948981,
            17937018,
            17940037,
            17964516,
            17938191,
            17942540,
            17939538,
            17937369,
            17937220,
            17939353,
            17954945,
            17936753,
            17939065,
            17939668
        ],
        "A": [
            17936166,
            17934371,
            17935192,
            17936993,
            17935281,
            17935512,
            17947868,
            17934798,
            17935340,
            17934655,
            17934645,
            17943337,
            17937162,
            17934833,
            17935029,
            17935291,
            17934716,
            17934453,
            17934986,
            17937083
        ]
    },
    "name": "D. Tree Construction",
    "statement": "During the programming classes Vasya was assigned a difficult problem.\r\nHowever, he doesn\u2019t know how to code and was unable to find the solution\r\nin the Internet, so he asks you to help.You are given a sequence a,\r\nconsisting of n integers, that is used to construct the binary search\r\ntree. Below is the formal description of the construction process. First\r\nelement a_1 becomes the root of the tree. Elements a_2, a_3,\r\nldots, a_n are added one by one. To add element a_i one needs to\r\ntraverse the tree starting from the root and using the following rules:\r\nThe pointer to the current node is set to the root. If a_i is greater\r\nthan the value in the current node, then its right child becomes the\r\ncurrent node. Otherwise, the left child of the current node becomes the\r\nnew current node. If at some point there is no required child, the new\r\nnode is created, it is assigned value a_i and becomes the corresponding\r\nchild of the current node.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nset <pair<int, int> > s;\nint a[200000];\nint lc[200000];\nint l, r;\nset <pair<int, int> > :: iterator it;\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    int n, x;\n    cin >> n;\n    cin >> a[0];\n    s.insert(make_pair(a[0], 0));\n\n    for (int i = 1; i < n; i++)\n    {\n        cin >> a[i];\n        x = a[i];\n\n        it = s.lower_bound(make_pair(x, 0));\n        if (it == s.end())\n            r = -1;\n        else\n            r = it->second;\n\n        if (it == s.begin())\n        {\n            l = -1;\n        }\n        else\n        {\n            it--;\n            l = it->second;\n        }\n\n        if (l == -1 || (l >= 0 && r >= 0 && a[lc[l]] < x))\n        {\n            cout << a[r] << ' ' ;\n            lc[i] = r;\n        }\n        else\n        {\n            cout << a[l] << ' ' ;\n            lc[i] = lc[l];\n            lc[l] = l;\n        }\n\n        s.insert(make_pair(x, i));\n    }\n\n\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tree Construction.json",
    "editorial_link": "https://codeforces.com//blog/entry/44902",
    "editorial": "We have binary search tree (BST) and should insert number in it with\r\ngood time complexity. Let we should add number . Find numbers which were\r\nadded earlier, is maximal possible, is minimal possible (all will be\r\nsimilar if only one of this numbers exists). We can find them for\r\nexample with std::set and upper_bound in C++. We should keep sorted tree\r\ntraversal (it\u00e2\u0080\u0099s property of BST). So must be right child of vertex with\r\nor left child of vertex with . Let hasn\u00e2\u0080\u0099t right child and hasn\u00e2\u0080\u0099t left\r\nchild. Hence lowest common ancestor (lca) of and doesn\u00e2\u0080\u0099t equal to or .\r\nSo lca is between and in tree traversal. But it\u00e2\u0080\u0099s impossible because is\r\nmaximal possible and is minimal possible. So has right child or has left\r\nchild and we know exactly which of them will be parent of . That\u00e2\u0080\u0099s all.\r\nTime complexity is . Code\r\n"
}