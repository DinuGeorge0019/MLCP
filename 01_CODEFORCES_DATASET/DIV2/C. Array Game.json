{
    "link": "https://codeforces.com//contest/1904/problem/C",
    "problemId": "2374322",
    "problem_idx": "C",
    "shortId": "1904C",
    "contest_number": "1904",
    "problem_submissions": {
        "F": [
            236570080,
            236576621,
            236554431,
            236568040,
            236582005,
            236574981,
            236880626,
            236880480,
            236569573
        ],
        "E": [
            236554914,
            236578860,
            236576444,
            236573774,
            238458664,
            236560297,
            236558822,
            236558918,
            236569149,
            236563127,
            236567711,
            236569198,
            236566626,
            236565306,
            236568569,
            236566882,
            236569261,
            236579274,
            236552305,
            236552808,
            236798985
        ],
        "D1": [
            236545065,
            236536170,
            236543035,
            236535328,
            236546645,
            236545333,
            236534429,
            236543154,
            236535118,
            236545269,
            236548952,
            236561907,
            236552142,
            236547668,
            236547285,
            236579190,
            236560952,
            236535340,
            236566707
        ],
        "D2": [
            236544975,
            236536268,
            236547976,
            236535232,
            236546707,
            236545240,
            236539045,
            236543101,
            236535019,
            236550494,
            236549022,
            236539644,
            236552226,
            236551334,
            236547141,
            236579204,
            236562744,
            236535269,
            236566631
        ],
        "C": [
            236537578,
            236532163,
            236538305,
            236529701,
            236530813,
            236537981,
            236531278,
            236536485,
            236540998,
            236534952,
            236537201,
            236530975,
            236533757,
            236539773,
            236559221,
            236579140,
            236529162,
            236713604,
            236530644
        ],
        "B": [
            236533750,
            236526956,
            236527715,
            236527401,
            236528167,
            236531303,
            236527554,
            236530718,
            236528605,
            236528181,
            236531779,
            236528715,
            236530882,
            236530328,
            236531954,
            236579315,
            236527688,
            236526407,
            236558484,
            236528501
        ],
        "A": [
            236526415,
            236525678,
            236525809,
            236525816,
            236525646,
            236527341,
            236525550,
            236527627,
            236527718,
            236525848,
            236525742,
            236526468,
            236525731,
            236528067,
            236527808,
            236579299,
            236525701,
            236525590,
            236554437,
            236526433
        ]
    },
    "name": "C. Array Game",
    "statement": "You are given an array a of n positive integers. In one operation, you\r\nmust pick some (i, j) such that 1\r\nleq i < j\r\nleq |a| and append |a_i - a_j| to the end of the a (i.e. increase n by 1\r\nand set a_n to |a_i - a_j|). Your task is to minimize and print the\r\nminimum value of a after performing k operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 2007;\nint T, n, m, k;\nll a[N], b[N * N];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n >> k;\n\t\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\t\tif (k >= 3) {\n\t\t\tcout << \"0\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tll ans = 2e18;\n\t\t\tfor (int i = 1; i <= n; ++i) ans = min(ans, a[i]);\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\t\tans = min(ans, abs(a[i] - a[j]));\n\t\t\tcout << ans << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tll ans = 2e18;\n\t\tfor (int i = 1; i <= n; ++i) ans = min(ans, a[i]);\n\t\tm = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\tb[++m] = abs(a[i] - a[j]);\n\t\tsort(b + 1, b + m + 1);\n\t\tans = min(ans, b[1]);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint p = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif (p <= m) ans = min(ans, b[p] - a[i]);\n\t\t\tif (p > 1) ans = min(ans, a[i] - b[p - 1]);\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Array Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/123160",
    "editorial": "SolutionIf , the answer is equal to since after performing an operation\r\non the same pair twice, performing an operation on the two new values\r\n(which are the same) results in .Therefore, letâs consider the case for\r\n.For , it is sufficient to sort the array and output the minimum between\r\nand .For , letâs brute force the first operation. If the newly created\r\nvalue is , then it is sufficient to find the smallest satisfying and\r\ngreatest satisfying and relax the answer on . Also, remember to consider\r\nthe cases of performing no operation or one operation. This runs in .\r\nThere also exists a solution in using a two pointers approach.\r\n",
    "hint": []
}