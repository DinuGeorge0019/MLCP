{
    "link": "https://codeforces.com//contest/1768/problem/F",
    "problemId": "1720623",
    "problem_idx": "F",
    "shortId": "1768F",
    "contest_number": "1768",
    "problem_submissions": {
        "D": [
            204982953,
            188071247,
            188067925,
            188068130,
            188070945,
            188072940,
            188074516,
            188075810,
            188085152,
            188074579,
            188073456,
            188074101,
            188082385,
            188164225,
            188089006,
            188069736,
            188081987,
            188082522,
            188078305,
            188078232,
            188080797
        ],
        "F": [
            188116348,
            188135822,
            188160798,
            188176131,
            188168385
        ],
        "E": [
            188083790,
            188076616,
            188084542,
            188083977,
            188085068,
            188090588,
            188090979,
            188080120,
            188090253,
            188095827,
            188095081,
            188082638,
            188089969,
            188164249,
            188075544,
            188101242,
            188092147,
            188102271,
            188100942,
            188097984
        ],
        "C": [
            188076017,
            188062341,
            188060907,
            188066248,
            188067691,
            188065722,
            188067475,
            188070114,
            188066780,
            188064718,
            188068797,
            188076939,
            188164202,
            188081893,
            188163969,
            188059068,
            188075112,
            188075686,
            188069461,
            188068577,
            188075836
        ],
        "B": [
            188057634,
            188051968,
            188049872,
            188053488,
            188055902,
            188055318,
            188053420,
            188056521,
            188052830,
            188053386,
            188052891,
            188065110,
            188164191,
            188059182,
            188051170,
            188056859,
            188053279,
            188061154,
            188058286
        ],
        "A": [
            188047123,
            188046830,
            188047332,
            188048108,
            188047085,
            188046543,
            188047234,
            188050361,
            188047575,
            188046807,
            188046596,
            188059906,
            188164162,
            188047560,
            188046948,
            188050516,
            188048920,
            188047550,
            188060898,
            188051639
        ]
    },
    "name": "F. Wonderful Jump",
    "statement": "You are given an array of positive integers a_1,a_2,\r\nldots,a_n of length n. In one operation you can jump from index i to\r\nindex j (1\r\nle i\r\nle j\r\nle n) by paying\r\nmin(a_i, a_{i + 1},\r\nldots, a_j)\r\ncdot (j - i)^2 eris.For all k from 1 to n, find the minimum number of\r\neris needed to get from index 1 to index k.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=4e5+10;\nint a[maxn],lst[maxn],n,pos[maxn];\nll f[maxn];\nint lg,lg2[maxn],st[__lg(maxn)+1][maxn];\ninline void build_st(){\n\tfor(ri i=1;i<=n;++i)lg2[i]=lg2[i-1]+((2<<lg2[i-1])==i),st[0][i]=a[i];\n\tlg=lg2[n];\n\tfor(ri i=1;i<=lg;++i)\n\t\tfor(ri j=1;j+(1<<i)-1<=n;++j)\n\t\t\tst[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n}\ninline int query(int l,int r){\n\tri k=lg2[r-l+1];\n\treturn min(st[k][l],st[k][r-(1<<k)+1]);\n}\ninline ll calc(ll l,ll r){\n\treturn f[l]+1ll*query(l,r)*(l-r)*(l-r);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(ri i=1;i<=n;++i)scanf(\"%d\",a+i),f[i]=1ll*(i-1)*n;\n\tbuild_st();\n\tfor(ri i=1;i<=n;++i){\n\t\tri d=n/a[i]+1;\n\t\tfor(ri j=i-1;j>0&&j>=i-d;--j){\n\t\t\tckmin(f[i],calc(j,i));\n\t\t\tif(a[j]<=a[i])break;\n\t\t}\n\t\tfor(ri j=i+1;j<=n&&j<=i+d;++j){\n\t\t\tckmin(f[j],calc(i,j));\n\t\t\tif(a[j]<=a[i])break;\n\t\t}\n\t}\n\tfor(ri i=1;i<=n;++i)printf(\"%lld%c\",f[i],\" \\n\"[i==n]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Wonderful Jump.json",
    "editorial_link": "https://codeforces.com//blog/entry/110901",
    "editorial": "There is a very easy dp solution, we will show one possible way to\r\noptimize it to , where is the maximum possible value of .Let be the\r\nminimum number of eris required to reach index , . Suppose we want to\r\ncalculate and we already know . Let\u00e2\u0080\u0099s look at our cost function more\r\nclosely. We can notice that it is definitely not optimal to use the\r\ntransition if . That is, it will be more optimal to perform jumps of\r\nlength 1.Transforming this inequality, we get . So if is quite large, we\r\nonly need to look at a couple of close to , and then do something else\r\nfor the small values of .1. To handle this case, we can just iterate\r\nover all from to , since the transition could be optimal only if .Time\r\ncomplexity: .2. Another useful fact is that if there exists an index\r\nsuch that and , the transition also cannot be optimal, since followed by\r\nwill cost less.Proof: This leaves us two subcases two handle.2.1 Just\r\nmaintain the rightmost occurrences of all values from to . Time\r\ncomplexity: .2.2 Initially set to and decrease it until becomes true.\r\nTime complexity: amortized.Total time complexity:\r\n"
}