{
    "link": "https://codeforces.com//contest/1536/problem/E",
    "problemId": "1007473",
    "problem_idx": "E",
    "shortId": "1536E",
    "contest_number": "1536",
    "problem_submissions": {
        "E": [
            118631124,
            118614939,
            118616967,
            118624386,
            118627719,
            118635620,
            118636863,
            118621534,
            118623141,
            118619496,
            118630371,
            118626916,
            118634340,
            118635235,
            118626014,
            118625912,
            118631232,
            118724771,
            118637508,
            118632134,
            118634841
        ],
        "F": [
            118625791,
            118638866,
            118613437,
            118637695,
            118644936,
            118650446,
            118647459,
            118663966,
            118711352,
            118653882,
            118654218,
            118882357
        ],
        "C": [
            118608971,
            118600883,
            118628209,
            118608554,
            118608052,
            118619465,
            118622898,
            118607847,
            118602584,
            118598176,
            118609484,
            118609006,
            118618271,
            118606277,
            118606392,
            118620701,
            118612692,
            118724743,
            118612675,
            118612583,
            118612872
        ],
        "D": [
            118608031,
            118607288,
            118623947,
            118617513,
            118619773,
            118632284,
            118632215,
            118614859,
            118617552,
            118601113,
            118616452,
            118622152,
            118614133,
            118620886,
            118617343,
            118616486,
            118624441,
            118724752,
            118620219,
            118627264,
            118625159
        ],
        "B": [
            118602956,
            118599083,
            118634218,
            118612957,
            118602526,
            118613641,
            118606813,
            118602130,
            118599340,
            118630482,
            118605942,
            118604400,
            118601413,
            118601634,
            118600081,
            118601184,
            118602824,
            118724734,
            118602945,
            118605239,
            118604772
        ],
        "A": [
            118598232,
            118597991,
            118635775,
            118598107,
            118598184,
            118601999,
            118598235,
            118599189,
            118598143,
            118622748,
            118598451,
            118598128,
            118598114,
            118598284,
            118598026,
            118597979,
            118598563,
            118724715,
            118598620,
            118599178,
            118598920
        ]
    },
    "name": "E. Omkar and Forest",
    "statement": "Omkar’s most recent follower, Ajit, has entered the Holy Forest. Ajit\r\nrealizes that Omkar’s forest is an n by m grid (1\r\nleq n, m\r\nleq 2000) of some non-negative integers. Since the forest is blessed by\r\nOmkar, it satisfies some special conditions: For any two adjacent\r\n(sharing a side) cells, the absolute value of the difference of numbers\r\nin them is at most 1. If the number in some cell is strictly larger than\r\n0, it should be strictly greater than the number in of the cells\r\nadjacent to it. Unfortunately, Ajit is not fully worthy of Omkar’s\r\npowers yet. He sees each cell as a \"0\" or a \"\". If a cell is labeled as\r\n\"0\", then the number in it must equal 0. Otherwise, the number in it can\r\nbe any nonnegative integer.Determine how many different assignments of\r\nelements exist such that these special conditions are satisfied. Two\r\nassignments are considered different if there exists at least one cell\r\nsuch that the numbers written in it in these assignments are different.\r\nSince the answer may be enormous, find the answer modulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,mod=1e9+7;\nll n,m,ans,c1,c2;\nchar s[N][N];\nint read()\n{\n\tint res=0,fl=0; char a=getchar();\n\twhile(a<'0'||a>'9') fl|=a=='-',a=getchar();\n\twhile(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();\n\treturn fl? -res:res;\n}\nll ksm(ll di,ll mi) {ll res=1; for(;mi;mi>>=1,di=di*di%mod) if(mi&1) res=res*di%mod; return res;}\n//ll c(ll a,ll b) {return a>=b? jc[a]*jv[b]%mod*jv[a-b]%mod:0;}\nint main()\n{\n\tint i,j,t=read();\n\twhile(t--)\n\t{\n\t\tn=read(),m=read(),c1=0,c2=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(scanf(\"%s\",s[i]+1),j=1;j<=m;j++) if(s[i][j]=='#') c1++; else c2++;\n\t\tcout<<(ksm(2,c1)+mod-1+(!!c2))%mod<<'\\n';\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "graphs",
        "math",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Omkar and Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/91520",
    "editorial": "SolutionImagine picking some subset of and making them . Then there is\r\nexactly one way to make all the remaining positive integers. To see why,\r\nimagine multisource BFS with all as the sources. After the BFS, each\r\nwill be equal to the minimum distance from itself to any cell.\r\nDifference between adjacent cells will be at most . Proof can be shown\r\nby contradiction: if two cells with difference existed, then the larger\r\nof these cells is not labeled with the shortest distance to a source\r\n(since the distance from the smaller cell will be a better choice).\r\nBecause of the nature of BFS, we can also ensure the second condition is\r\nalso satisfied, since the only cells that have no neighbor strictly\r\nsmaller will be the source cells. This is the only valid assignment\r\nbecause if we make any number larger, there will exist a pair of cells\r\nwith difference . If we try to make any number smaller, there will exist\r\na cell with positive karma that has no strictly smaller neighbor.If we\r\nlet equal to the frequency of in the input, then the answer is . Keep in\r\nmind of the special case where the input is all , in which case you have\r\nto subtract . This is because a possible arrangement must contain at\r\nleast one cell with karma of . Obviously the solution runs in time.\r\n",
    "hint": [
        "Hint 1 Consider forcing some set of ‘#’ positions to be and the rest to be positive integers.",
        "Hint 2 Multisource BFS"
    ]
}