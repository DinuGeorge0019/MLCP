{
    "link": "https://codeforces.com//contest/1100/problem/E",
    "problemId": "281743",
    "problem_idx": "E",
    "shortId": "1100E",
    "contest_number": "1100",
    "problem_submissions": {
        "D": [
            48353320,
            48357025,
            48358665,
            48352439,
            48485627,
            48356511,
            48354584,
            48367255,
            48355872,
            48356938,
            48418676,
            48367598,
            48366911,
            48360912
        ],
        "E": [
            48350143,
            48346134,
            48343035,
            48344468,
            48345510,
            48344044,
            48355215,
            48356334,
            48347647,
            48367496,
            48345429,
            48350647,
            48345628,
            48345908,
            48337155,
            48369088,
            48368217,
            48368175,
            48346637
        ],
        "F": [
            48345973,
            48351415,
            48352189,
            48350710,
            48349016,
            48346778,
            48348725,
            48353766,
            48349571,
            58874033,
            48356957,
            48346827,
            48367535,
            48349001
        ],
        "C": [
            48336896,
            48335321,
            48334130,
            48334390,
            48335310,
            48344018,
            48335734,
            48342199,
            48338272,
            48337047,
            48341951,
            48335611,
            48336047,
            48332446,
            48337175,
            48367539,
            48338679,
            48338717
        ],
        "B": [
            48334048,
            48332782,
            48332647,
            48331840,
            48351673,
            48332494,
            48337726,
            48333602,
            48340544,
            48335461,
            48333231,
            48335841,
            48335239,
            48333836,
            48331660,
            48334686,
            48373723,
            48367780,
            48340073,
            48333386
        ],
        "A": [
            48332192,
            48331699,
            48331636,
            48331355,
            48331447,
            48334124,
            48331785,
            48335827,
            48332710,
            48331483,
            48333294,
            48331582,
            48332077,
            48331359,
            48331604,
            48367585,
            48333354,
            48331926
        ]
    },
    "name": "E. Andrew and Taxi",
    "statement": "Andrew prefers taxi to other means of transport, but recently most taxi\r\ndrivers have been acting inappropriately. In order to earn more money,\r\ntaxi drivers started to drive in circles. Roads in Andrew\u2019s city are\r\none-way, and people are not necessary able to travel from one part to\r\nanother, but it pales in comparison to insidious taxi drivers.The mayor\r\nof the city decided to change the direction of certain roads so that the\r\ntaxi drivers wouldn\u2019t be able to increase the cost of the trip\r\nendlessly. More formally, if the taxi driver is on a certain crossroads,\r\nthey wouldn\u2019t be able to reach it again if he performs a nonzero trip.\r\nTraffic controllers are needed in order to change the direction the road\r\ngoes. For every road it is known how many traffic controllers are needed\r\nto change the direction of the road to the opposite one. It is allowed\r\nto change the directions of roads one by one, meaning that each traffic\r\ncontroller can participate in reversing two or more roads.You need to\r\ncalculate the minimum number of traffic controllers that you need to\r\nhire to perform the task and the list of the roads that need to be\r\nreversed.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct edge\n{\n    int from,to,cost,id;\n};\nint n,m,ord[MAXN];\nvector<edge> G[MAXN];\nvector<int> order,ans;\nvector<edge> E;\nbool f;\nint color[MAXN];\nvoid add_edge(int u,int v,int cost,int id)\n{\n    G[u].push_back((edge){u,v,cost,id});\n}\nvoid dfs(int v,int x,int save)\n{\n    if(!f) return;\n    color[v]=1;\n    for(auto e:G[v])\n    {\n        if(e.cost<=x)\n        {\n            if(save) E.push_back(e);\n            continue;\n        }\n        if(color[e.to]==1)\n        {\n            f=false;\n            return;\n        }\n        else if(color[e.to]==0) dfs(e.to,x,save);\n    }\n    color[v]=2;\n    if(save)order.push_back(v);\n}\nbool C(int x,int save=0)\n{\n    memset(color,0,sizeof(color));\n    f=true;\n    for(int i=1;i<=n;i++)\n    {\n        if(!color[i]) dfs(i,x,save);\n        if(!f) return false;\n    }\n    return true;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        int u,v,c;\n        scanf(\"%d%d%d\",&u,&v,&c);\n        add_edge(u,v,c,i);\n    }\n    int l=-1,r=INF;\n    while(r-l>1)\n    {\n        int mid=(l+r)/2;\n        if(C(mid)) r=mid; else l=mid;\n    }\n    printf(\"%d \",r);C(r,1);\n    reverse(order.begin(),order.end());\n    for(int i=0;i<(int)order.size();i++) ord[order[i]]=i;\n    for(auto e:E)\n    {\n        if(ord[e.from]>ord[e.to]) ans.push_back(e.id);\n    }\n    sort(ans.begin(),ans.end());\n    printf(\"%d\\n\",(int)ans.size());\n    for(auto v:ans) printf(\"%d \",v);\n    puts(\"\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Andrew and Taxi.json",
    "editorial_link": "https://codeforces.com//blog/entry/64545",
    "editorial": "Suppose we have traffic controllers. They can turn all edges whose\r\nweight is less than or equal to . Then let\u00e2\u0080\u0099s remove all these edges from\r\nthe graph, make a topological sorting of the remaining graph, and orient\r\nthe other edges in the order of topological sorting. If there are cycles\r\nleft in the graph after removing the edges, then we cannot get rid of\r\nthem, having traffic controllers. Otherwise, by adding edges we will not\r\nadd new loops. The parameter can be iterated through a binary search.\r\nAlso in binary search, you can go through not all possible values of ,\r\nbut only the values that are on the edges.Complexity or .\r\n"
}