{
    "link": "https://codeforces.com//contest/570/problem/E",
    "problemId": "33021",
    "problem_idx": "E",
    "shortId": "570E",
    "contest_number": "570",
    "problem_submissions": {
        "A": [
            12511664,
            12494868,
            12495315,
            12495052,
            12498729,
            12495010,
            12494706,
            12495365,
            12494962,
            12496174,
            12494954,
            12502600,
            12496200,
            12496316,
            12506558,
            12502467,
            12495107,
            12496065,
            12498893,
            12498878
        ],
        "B": [
            12509887,
            12497298,
            12497382,
            12499467,
            12505096,
            12495563,
            12498176,
            12497892,
            12496695,
            12495228,
            12498861,
            12499890,
            12502905,
            12497610,
            12503032,
            12504155,
            12497913,
            12496421
        ],
        "E": [
            12508866,
            12514963,
            12515149,
            12513258,
            12512484,
            12512570,
            12514497,
            12512953,
            12509761,
            12511947,
            12514813
        ],
        "D": [
            12503406,
            12507923,
            12507699,
            12507537,
            12509874,
            12513189,
            12507259,
            12527819,
            12514569,
            12511515,
            12568414,
            12512833
        ],
        "C": [
            12498193,
            12507310,
            12502209,
            12498057,
            12501547,
            12500587,
            12501845,
            12503728,
            12502079,
            12505954,
            12509333,
            12499956,
            12503373,
            12503640,
            12501153,
            12511401,
            12502671,
            12506512,
            12510295,
            12502880
        ]
    },
    "name": "E. Pig and Palindromes",
    "statement": "Peppa the Pig was walking and walked into the forest. What a strange\r\ncoincidence! The forest has the shape of a rectangle, consisting of rows\r\nand columns. We enumerate the rows of the rectangle from top to bottom\r\nwith numbers from to , and the columns from left to right with numbers\r\nfrom to . Let\u2019s denote the cell at the intersection of the -th row and\r\nthe -th column as .Initially the pig stands in cell , and in the end she\r\nwants to be in cell . Since the pig is in a hurry to get home, she can\r\ngo from cell , only to either cell or . She cannot leave the forest.The\r\nforest, where the pig is, is very unusual. Some cells of the forest\r\nsimilar to each other, and some look very different. Peppa enjoys taking\r\npictures and at every step she takes a picture of the cell where she is\r\nnow. The path through the forest is considered to be if photographs\r\ntaken on her way, can be viewed in both forward and in reverse order,\r\nshowing the same sequence of photos. More formally, the line formed by\r\nthe cells in order of visiting should be a (you can read a formal\r\ndefinition of a palindrome in the previous problem).Count the number of\r\nbeautiful paths from cell to cell . Since this number can be very large,\r\ndetermine the remainder after dividing it by .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nconst int mo=1000000007;\n\n#define MAXN 505\n\nint n,m;\n\nchar a[MAXN][MAXN],a1[MAXN][MAXN];\n\nint f0[MAXN][MAXN],f1[MAXN][MAXN];\n\ninline void add(int &a,int b) {\n    a=(a+b)%mo;\n}\n\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    int i,j,k;\n    for (i=1;i<=n;i++) {\n        scanf(\"%s\",a[i]+1);\n    }\n    if (n>m) {\n        for (i=1;i<=n;i++) {\n            for (j=1;j<=m;j++) {\n                a1[j][i]=a[i][j];\n            }\n        }\n        memcpy(a,a1,sizeof(a));\n        std::swap(n,m);\n    }\n    f0[1][m]=a[1][1]==a[n][m];\n    int t=(n+m-2)/2;\n    for (i=0;i<t;i++) {\n        // step < n-1\n        int L,R;\n        if (i<=n-1) {\n            L=1;R=1+i;\n        } else {\n            L=1+i-(n-1);\n            R=1+i;\n        }\n        int A,B;\n        if (i<=n-1) {\n            A=m-i;\n            B=m;\n        } else {\n            A=m-i;\n            B=m-(i-(n-1));\n        }\n        memset(f1,0,sizeof(f1));\n        int t1,t2;\n        for (j=R,t1=1;j>=L;j--,t1++) {\n            // (t1,j)\n            for (k=A,t2=n;k<=B;k++,t2--) {\n                // (t2,k)\n                // f0[j][k]\n                int tmp=f0[j][k];\n                if (t1<n) {\n                    // (t1+1,j)\n                    if (t2>1) {\n                        // (t2-1,k)\n                        if (a[t1+1][j]==a[t2-1][k]) {\n                            add(f1[j][k],tmp);\n                        }\n                    }\n                    if (k>1) {\n                        // (t2,k-1)\n                        if (a[t1+1][j]==a[t2][k-1]) {\n                            add(f1[j][k-1],tmp);\n                        }\n                    }\n                }\n                if (j<m) {\n                    // (t1,j+1)\n                    if (t2>1) {\n                        // (t2-1,k)\n                        if (a[t1][j+1]==a[t2-1][k]) {\n                            add(f1[j+1][k],tmp);\n                        }\n                    }\n                    if (k>1) {\n                        // (t2,k-1)\n                        if (a[t1][j+1]==a[t2][k-1]) {\n                            add(f1[j+1][k-1],tmp);\n                        }\n                    }\n                }\n            }\n        }\n        memcpy(f0,f1,sizeof(f0));\n    }\n    int ans=0;\n    if ((n+m)%2==0) {\n        for (i=1;i<=m;i++) {\n            ans=(ans+f0[i][i])%mo;\n        }\n    } else {\n        for (i=1;i<=m;i++) {\n            ans=(ans+f0[i][i])%mo;\n            ans=(ans+f0[i][i+1])%mo;\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Pig and Palindromes.json",
    "editorial_link": "https://codeforces.com//blog/entry/19770",
    "editorial": "We need palindrome paths. Palindrome is word which reads the same\r\nbackward or forward. We can use it. Count the dynamic from coordinates\r\nof 2 cells, first and latest in palindrome. From each state exists 4\r\ntransitions (combinations: first cell down/to the right and second cell\r\nup/to the left). We need only transitions on equal symbols for making a\r\npalindrome. Note that we need a pairs of cells on equal distance from\r\nstart and end for each. For saving memory we need to store two latest\r\nlayers. time and memory Solutions\r\n"
}