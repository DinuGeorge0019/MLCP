{
    "link": "https://codeforces.com//contest/2027/problem/D2",
    "problemId": "2980653",
    "problem_idx": "D2",
    "shortId": "2027D2",
    "contest_number": "2027",
    "problem_submissions": {
        "E1": [
            288173465
        ],
        "C": [
            288155049,
            288120759,
            288122093,
            288125570,
            288127321,
            288123494,
            288123556,
            288122333,
            288123755,
            288125169,
            288121427,
            288117465,
            288125690,
            288124584,
            288121786,
            288127829,
            288125975,
            288124342
        ],
        "B": [
            288142255,
            288115334,
            288114511,
            288119086,
            288120877,
            288116135,
            288118059,
            288116134,
            288116952,
            288118306,
            288116355,
            288118112,
            288118023,
            288118240,
            288114959,
            288119841,
            288117994,
            288116831
        ],
        "D1": [
            288128564,
            288128933,
            288128524,
            288131968,
            288133129,
            288135744,
            288132103,
            288131863,
            288129253,
            288133201,
            288129398,
            288141909,
            288136583,
            288131627,
            288137428,
            288134171,
            288136755,
            288139102
        ],
        "D2": [
            288128086,
            288140616,
            288241523,
            288145908,
            288142238,
            288141377,
            288147849,
            288144735,
            288148268,
            288155865,
            288150156,
            288152683,
            288141628,
            288150384,
            288157699,
            288150265,
            288151809,
            288152365,
            288146843
        ],
        "A": [
            288116848,
            288110808,
            288111033,
            288112146,
            288115964,
            288110952,
            288112831,
            288111212,
            288110889,
            288110825,
            288111627,
            288112681,
            288110645,
            288110604,
            288114987,
            288112466,
            288110744
        ],
        "E2": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/135558",
    "editorial": "Each pile is an independent game, so letâs try to find the nimber of a\r\npile with value and size letâs denote this by . Suppose for some integer\r\n; in this case, the nimber is entirely dependent on . If is not in that\r\nform, consider the binary representation of . If any bit in is on where\r\nis off, then itâs equivalent to if had that bit off, but all lower bits\r\nwere on. Letâs call such a bit a âgood bitâ. So we can build some value\r\nby iterating along the bits from highest to lowest; if has an on bit in\r\nthis position, then will have an on bit in this position if and only if\r\nhas one there, or weâve already found a good bit. Now that the bits of\r\nand align, we can remove all zeros from both representations and itâs\r\nclear that this is an equivalent game with .One small observation to\r\nmake is that we can remove the ones in which correspond to leading zeros\r\nin , since we can never use these. So actually, after calculating we\r\nonly need , where is the smallest integer such that . By running a brute\r\nforce using the Sprague Grundy theorem to find the nimbers you can\r\nobserve some patterns which encompass all cases: , for all . , for all .\r\n, for all . , for all . The first cases are nice and relatively simple\r\nto prove, but the last is a lot harder (at least, I couldnât find an\r\neasier way). Anyway, I will prove all of them here, for\r\ncompleteness.First, note that if at any point we have , then we have a\r\nstandard nim-game over the bits of the number, since we can remove any\r\nof them on each operation, so the nimber of such a game would be . The\r\nsecond case is one example of this; we have , so its nimber is . Now\r\nletâs prove the first case. When , since there are no moves. For larger\r\nvalues of , no matter which value of we choose, the resulting game has\r\nwhere has a positive number of bits. Overall, we have the of a bunch of\r\nnumbers which are all positive, so the nimber is as required. Now letâs\r\nprove the third case. To reiterate, since we have by definition. This\r\ncase is equivalent to having a nim-game with one pile of bits (all bits\r\nbelow the most significant one), and another pile of bit (the most\r\nsignificant one). This is because we can remove any amount from either\r\npile in one move, but never both. Therefore, the nimber is as\r\nrequired.The last case is the hardest to prove. We need to show that\r\nthere is some move that lands you in a game for all nimbers from to ,\r\nand never with nimber . Well, the only way that you could get a nimber\r\nof is by landing in case without changing the number of bits in /. Any\r\nmove will change this though, since any move will remove some bits of\r\nand when is recalculated itâll have fewer bits. Okay, now one way of\r\ngetting a nimber of is just by removing all bits in which are strictly\r\nafter the first zero-bit in . For example, if , then letâs choose ; then\r\nweâll land in case . As for getting the rest of the nimbers from to , it\r\nhelps if we can just land in case but with a varying number of bits. If\r\nthis is easily possible by considering all in the range . On the other\r\nhand, if , letâs first consider the resulting value of to be equal to ,\r\nwhere is the lowest set bit in . This will give a nimber of . Now, we\r\ncan repeatedly add the highest unset bit in this to itself to generate\r\nthe next nimber until we now have all nimbers from to . For the nimber\r\nof , just have the resulting be .Time complexity: , where is the upper\r\nlimit on .\r\n",
    "name": "D2. The Endspeaker  Hard Version ",
    "statement": "You’re given an array a of length n, and an array b of length m (b_i >\r\nb_{i+1} for all 1\r\nle i < m). Initially, the value of k is 1. Your aim is to make the array\r\na empty by performing one of these two operations repeatedly: Type 1 If\r\nthe value of k is less than m and the array a is , you can increase the\r\nvalue of k by 1. This does not incur any cost. Type 2 You remove a\r\nnon-empty prefix of array a, such that its sum does not exceed b_k. This\r\nincurs a cost of m - k. You need to minimize the total cost of the\r\noperations to make array a empty. If it’s impossible to do this through\r\nany sequence of operations, output -1. Otherwise, output the minimum\r\ntotal cost of the operations, and the number of sequences of operations\r\nwhich yield this minimum cost modulo 10^9 + 7. Two sequences of\r\noperations are considered different if you choose a different type of\r\noperation at any step, or the size of the removed prefix is different at\r\nany step.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#endif const int M = 1e9 + 7;const long long inf = 1e18; void add(int &x, int y) {  if ((x += y) >= M) {    x -= M;  }} struct ft {  int n;  vector<long long> s;  vector<int> cnt;  ft() = default;  ft(int n): n(n), s(n + 2, inf), cnt(n + 2) {};  void upd(int i, long long x, int y) {    for (++i; i > 0; i -= i & -i) {      if (s[i] > x) {        s[i] = x;        cnt[i] = y;      } else if (s[i] == x) {        add(cnt[i], y);      }    }  }  pair<long long, int> qry(int i) {    long long res = inf;    int c = 0;    for (++i; i <= n + 1; i += i & -i) {      if (res > s[i]) {        res = s[i];        c = cnt[i];      } else if (res == s[i]) {        add(c, cnt[i]);      }    }    return {res, c};  }}; void solve() {  int n, m; cin >> n >> m;  vector<long long> a(n + 1);  for (int i = 1; i <= n; ++i) {    cin >> a[i];    a[i] += a[i - 1];  }  vector<int> b(m);  for (int &x : b) {    cin >> x;  }  vector<ft> tree(m);  for (int i = 0; i < m; ++i) {    tree[i] = ft(n);    tree[i].upd(0, 0, 1);  }  vector<int> ptr(m);  long long lx;  int ly;  for (int i = 1; i <= n; ++i) {    lx = inf, ly = 0;    for (int j = 0; j < m; ++j) {      int &l = ptr[j];      while (a[i] - a[l] > b[j]) {        ++l;      }      auto [x, y] = tree[j].qry(l);      x += m - j - 1;      if (lx > x) {        lx = x;        ly = y;      } else if (x == lx) {        add(ly, y);      }      tree[j].upd(i, lx, ly);    }  }  if (lx == inf) {    cout << -1 << \"\\n\";  } else {    cout << lx << \" \" << ly << \"\\n\";  }} int main() {  ios::sync_with_stdio(false); cin.tie(nullptr);   int t; cin >> t;  while (t--) {    solve();  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. The Endspeaker  Hard Version .json",
    "hint": []
}