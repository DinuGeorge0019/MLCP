{
    "link": "https://codeforces.com//contest/400/problem/D",
    "problemId": "6826",
    "problem_idx": "D",
    "shortId": "400D",
    "contest_number": "400",
    "problem_submissions": {
        "D": [
            5942946,
            5938217,
            5938966,
            5937625,
            5935311,
            5938926,
            5940475,
            5940990,
            5937079,
            5944638,
            5955647,
            5943946,
            5937794,
            5946557,
            5936465,
            5939830,
            5950427,
            5941016
        ],
        "E": [
            5940590,
            5942014,
            5941822,
            5942894,
            5940333,
            5944467,
            5944452,
            5943295,
            5943002,
            5942790,
            5935656,
            5940436,
            5940115,
            5945285,
            5940524,
            5941127,
            5943876,
            5942957
        ],
        "C": [
            5934630,
            5936091,
            5936231,
            5935790,
            5939164,
            5935792,
            5937387,
            5938564,
            5934697,
            5938828,
            5935714,
            5935729,
            5935058,
            5936232,
            5935137,
            5934332,
            5936129,
            5935750,
            5937003
        ],
        "B": [
            5933775,
            5934595,
            5934975,
            5934196,
            5940471,
            5936516,
            5935696,
            5934075,
            5933798,
            5937278,
            5934053,
            5934760,
            5933911,
            5934786,
            5933892,
            5938918,
            5934764,
            5934389,
            5934127
        ],
        "A": [
            5933588,
            5933768,
            5934022,
            5933647,
            5933945,
            5933905,
            5933697,
            5933650,
            5933599,
            5936558,
            5933618,
            5933930,
            5933611,
            5933796,
            5933591,
            5939685,
            5933878,
            5933786,
            5933680
        ]
    },
    "name": "D. Dima and Bacteria",
    "statement": "Dima took up the biology of bacteria, as a result of his experiments, he\r\ninvented types of bacteria. Overall, there are bacteria at his\r\nlaboratory right now, and the number of bacteria of type equals . For\r\nconvenience, we will assume that all the bacteria are numbered from to .\r\nThe bacteria of type are numbered from to .With the help of special\r\nequipment Dima can move energy from some bacteria into some other one.\r\nOf course, the use of such equipment is not free. Dima knows ways to\r\nmove energy from some bacteria to another one. The way with number can\r\nbe described with integers , and mean that this way allows moving energy\r\nfrom bacteria with number to bacteria with number or vice versa for\r\ndollars.Dima\u2019s Chef (Inna) calls the type-distribution if there is a way\r\n(may be non-direct) to move energy from any bacteria of the particular\r\ntype to any other bacteria of the same type (between any two bacteria of\r\nthe same type) for zero cost.As for correct type-distribution the cost\r\nof moving the energy depends only on the types of bacteria help Inna to\r\ndetermine is the type-distribution correct? If it is, print the matrix\r\nwith size . Cell of this matrix must be equal to the minimal possible\r\ncost of energy-moving from bacteria with type to bacteria with type .\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nconst int C=1e6;\nint n, m, k, ty[C], c[555], d[555][555], u[C], uc[555], lo[555], ls;\nvector<int> t[C];\nvoid go(int v)\n{\n    if (!uc[ty[v]]) lo[ls++]=ty[v];\n    ++uc[ty[v]];\n    u[v]=1;\n    for (int i=0;i<t[v].size();++i) if (!u[t[v][i]]) go(t[v][i]);\n}\nvoid sm(int &a, int x)\n{\n    if (a==-1||a>x) a=x;\n}\nint main()\n{\n    scanf(\"%d %d %d\", &n, &m, &k);\n    for (int i=0;i<k;++i) scanf(\"%d\", &c[i]);\n    for (int i=0, s=0;i<k;s+=c[i], ++i) for (int j=s;j<s+c[i];++j) ty[j]=i;\n    for (int i=0;i<k;++i) for (int j=0;j<k;++j) if (i!=j) d[i][j]=-1;\n    for (int i=0;i<m;++i)\n    {\n        int a, b, x;\n        scanf(\"%d %d %d\", &a, &b, &x);\n        --a; --b;\n        if (x==0)\n        {\n            t[a].push_back(b);\n            t[b].push_back(a);\n        }\n        a=ty[a];\n        b=ty[b];\n        sm(d[a][b], x);\n        sm(d[b][a], x);\n    }\n    for (int i=0;i<n;++i)\n    {\n        if (uc[ty[i]]) continue;\n        int pp=ls;\n        go(i);\n        for (int j=pp;j<ls;++j) if (uc[lo[j]]!=c[lo[j]]) { puts(\"No\"); return 0; }\n    }\n    for (int l=0;l<k;++l) for (int i=0;i<k;++i) for (int j=0;j<k;++j)\n    {\n        if (d[i][l]!=-1&&d[l][j]!=-1) sm(d[i][j], d[i][l]+d[l][j]);\n    }\n    puts(\"Yes\");\n    for (int i=0;i<k;++i) for (int j=0;j<k;++j) printf(\"%d%c\", d[i][j], j+1==k?'\\n':' ');\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Dima and Bacteria.json",
    "editorial_link": "https://codeforces.com//blog/entry/10755",
    "editorial": "If the distribution is correct, after deleting all ribs with cost more\r\nthan 0 graph will transform to components of corrects size. Also, the\r\nnodes are numereted so we should turn dfs for the first node of each\r\ntype and be sure that we receive exact all nodes of this type and no\r\nohter. Now simple floyd warshall, and put in each cell of adjacent\r\nmatrix of components the minimal weight between all ribs from 1\r\ncomponent to another.\r\n"
}