{"link": "https://codeforces.com//contest/1758/problem/F", "problemId": "1661253", "problem_idx": "F", "shortId": "1758F", "contest_number": "1758", "problem_submissions": {"F": [182540191, 182568321], "E": [182511822, 182586636, 182586387, 182515621, 182519585, 182518611, 182521484, 182522469, 182521201, 182526835, 182524445, 182531747, 182527370, 182535662, 182516659, 182531389, 182540195, 182534906, 182535704, 182534874, 182530934], "D": [182500138, 182501532, 182504442, 182507521, 182511731, 182494704, 182508383, 182512302, 182512544, 182503927, 182510854, 182528079, 182501802, 182493856, 182514498, 182506950, 182513404, 182511217, 182525174, 182492321], "C": [182492468, 182496509, 182492305, 182495507, 182494119, 182500722, 182502459, 182500806, 182500441, 182492103, 182505245, 182496553, 182526899, 182500230, 182495864, 182508565, 182493170, 182498448, 182538442], "B": [182487714, 182492898, 182486562, 182485510, 182487169, 182486096, 182487229, 182491179, 182486630, 182482943, 182485521, 182488443, 182519764, 182489830, 182487145, 182487987, 182502412, 182487085, 182484646], "A": [182480951, 182480859, 182482976, 182480629, 182480620, 182481772, 182483562, 182480441, 182483772, 182479955, 182480275, 182480273, 182517991, 182490014, 182483571, 182480580, 182480710, 182480601, 182480454]}, "name": "F. Decent Division", "statement": "A binary string is a string where every character is\r\ntexttt{0} or\r\ntexttt{1}. Call a binary string if it has an equal number of\r\ntexttt{0}s and\r\ntexttt{1}s.Initially, you have an infinite binary string t whose\r\ncharacters are all\r\ntexttt{0}s. You are given a sequence a of n updates, where a_i indicates\r\nthat the character at index a_i will be flipped (\r\ntexttt{0}\r\nleftrightarrow\r\ntexttt{1}). You need to keep and modify after each update a set S of\r\nranges such that: for each range [l,r], the substring t_l\r\ndots t_r is a decent binary string, and for all indices i such that t_i\r\n=\r\ntexttt{1}, there exists [l,r] in S such that l\r\nleq i\r\nleq r. You only need to output the ranges that are added to or removed\r\nfrom S after each update. You can only add or remove ranges from S at\r\nmost\r\nmathbf{10^6} times.More formally, let S_i be the set of ranges after the\r\ni-th update, where S_0 =\r\nvarnothing (the empty set). Define X_i to be the set of ranges removed\r\nafter update i, and Y_i to be the set of ranges added after update i.\r\nThen for 1\r\nleq i\r\nleq n, S_i = (S_{i - 1}\r\nsetminus X_i)\r\ncup Y_i. The following should hold for all 1\r\nleq i\r\nleq n:\r\nforall a,b\r\nin S_i, (a\r\nneq b)\r\nrightarrow (a\r\ncap b =\r\nvarnothing); X_i\r\nsubseteq S_{i - 1}; (S_{i-1}\r\nsetminus X_i)\r\ncap Y_i =\r\nvarnothing;\r\ndisplaystyle\r\nsum_{i = 1}^n {(|X_i| + |Y_i|)}\r\nleq 10^6.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc getchar()\n// #define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch=='-')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=1e6+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint n,m=N-1;\n#define P pair<int,int>\nset<P>mp;\nV input(){\n\tn = getint();\n}\nset<int>one,zero,alen;\nV init(){\n\tFOR(i,1,m)zero.insert(i);\n\tFOR(i,1,m)alen.insert(i);\n}\nstruct node{ // \u7ef4\u62a4\u5386\u53f2\u6700\u5c0f\u503c\n\tint minn, sum;\n\tnode operator+(const node&o)const{\n\t\tnode out;\n\t\tout.minn = min(minn,sum+o.minn);\n\t\tout.sum = sum+o.sum;\n\t\treturn out;\n\t}\n}t1[N<<2],t2[N<<2];\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,m\n#define lson lc,L,mid\n#define rson rc,mid+1,R\nV build(int p,int L,int R){\n\tt1[p].minn = t2[p].minn = -(R-L+1);\n\tt1[p].sum = t2[p].sum = -(R-L+1);\n\tif(L==R)return;\n\tint mid=L+R>>1;\n\tbuild(lson),build(rson);\n}\nV upd(int p){\n\tt1[p]=t1[lc]+t1[rc];\n\tt2[p]=t2[rc]+t2[lc];\n}\nV change(int p,int L,int R,int x,int w){\n\tif(L==R){\n\t\tif(w){\n\t\t\tt1[p].minn = t2[p].minn = 1;\n\t\t\tt1[p].sum = t2[p].sum = 1;\n\t\t}\n\t\telse{\n\t\t\tt1[p].minn = t2[p].minn = -1;\n\t\t\tt1[p].sum = t2[p].sum = -1;\n\t\t}\n\t\treturn;\n\t}\n\tint mid=L+R>>1;\n\tif(x<=mid)change(lson,x,w);\n\telse change(rson,x,w);\n\tupd(p);\n}\nnode ask1(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t1[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask1(rson,l,r);\n\tif(r<=mid)return ask1(lson,l,r);\n\treturn ask1(lson,l,mid)+ask1(rson,mid+1,r);\n}\nnode ask2(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t2[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask2(rson,l,r);\n\tif(r<=mid)return ask2(lson,l,r);\n\treturn ask2(rson,mid+1,r)+ask2(lson,l,mid);\n}\nV work(){\n\tint x, l, r;\n\tbuild(1,1,m);\n\twhile(n--){\n\t\tx = getint();\n\t\tif(zero.find(x)!=zero.end()){\n\t\t\tl = x, r = *alen.upper_bound(x); // \u627e\u4e00\u4e2a\u4e0d\u88ab\u7ba1\u8f96\u7684 0\n\t\t\t// alen.erase(x);\n\t\t\tif(alen.find(x)!=alen.end())\n\t\t\t\talen.erase(x);\n\t\t\telse{\n\t\t\t\talen.erase(r);\n\t\t\t\tr = *alen.upper_bound(x);\n\t\t\t}\n\t\t\talen.erase(r);\n\t\t\tauto it = mp.upper_bound(P(x+1,0));\n\t\t\tif(it != mp.begin()){\n\t\t\t\tauto tmp = it;\n\t\t\t\ttmp --;\n\t\t\t\tif(tmp->first<=x && tmp->second >=x)\n\t\t\t\t\tit --;\n\t\t\t}\n\t\t\tif(it != mp.end()) cmin(l,it->first);\n\t\t\tauto itl = it;\n\t\t\tint cnt = 0;\n\t\t\twhile(it != mp.end() && it->second<=r){\n\t\t\t\tcmax(r, it->second);\n\t\t\t\tit ++, cnt ++;\n\t\t\t}\n\t\t\tauto itr = it;\n\t\t\tcout<<cnt<<'\\n';\n\t\t\tfor(it = itl;it!=itr;it++){\n\t\t\t\tcout<<it->first<<' '<<it->second<<'\\n';\n\t\t\t}\n\t\t\tmp.erase(itl, itr);\n\t\t\tmp.insert(P(l,r));\n\t\t\tcout<<1<<'\\n';\n\t\t\tcout<<l<<' '<<r<<'\\n';\n\t\t\t// auto v = *--mp.lower_bound()\n\t\t\tzero.erase(x);\n\t\t\tone.insert(x);\n\t\t\tchange(root,x,1);\n\t\t}\n\t\telse{\n\t\t\tauto it = --mp.upper_bound(P(x+1,0));\n\t\t\tchange(root,x,0);\n\t\t\tcout<<1<<'\\n';\n\t\t\tint l = it->first,r = it->second;\n\t\t\tcout<<l<<' '<<r<<'\\n';\n\t\t\tmp.erase(it);\n\t\t\tint L, R, mid1, mid2;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid1=L+R>>1,L^R)\n\t\t\t\tif(ask1(root,l,mid1).minn <= -1) R=mid1;\n\t\t\t\telse L=mid1+1;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid2=L+R>>1, L^R)\n\t\t\t\tif(ask2(root,mid2+1,r).minn<=-1)\n\t\t\t\t\tL=mid2+1;\n\t\t\t\telse R= mid2;\n\t\t\t// if(l == x || ask1(root,l,x-1).sum == 0){\n\t\t\t// \tL = x+1, R=r;\n\t\t\t// \twhile(mid=L+R>>1, L^R)\n\t\t\t// \t\tif(ask2(root,mid+1,r).minn<=-1)\n\t\t\t// \t\t\tL=mid+1;\n\t\t\t// \t\telse R= mid;\n\t\t\t// }\n\t\t\t// else{\n\t\t\t// \tL = l, R = x-1;\n\t\t\t// \twhile(mid=L+R>>1,L^R)\n\t\t\t// \t\tif(ask1(root,l,mid).minn <= -1) R=mid;\n\t\t\t// \t\telse L=mid+1;\n\t\t\t// }\n\t\t\tint cnt = (l<=mid1-1) + (mid1+1<=mid2-1)+(mid2+1<=r);\n\t\t\tcout<<cnt<<'\\n';\n\t\t\tif(l<=mid1-1){\n\t\t\t\tmp.insert(P(l,mid1-1));\n\t\t\t\tcout<<l<<' '<<mid1-1<<'\\n';\n\t\t\t}\n\t\t\tif(mid1+1<=mid2-1){\n\t\t\t\tmp.insert(P(mid1+1,mid2-1));\n\t\t\t\tcout<<mid1+1<<' '<<mid2-1<<'\\n';\n\t\t\t}\n\t\t\tif(mid2+1<=r){\n\t\t\t\tmp.insert(P(mid2+1,r));\n\t\t\t\tcout<<mid2+1<<' '<<r<<'\\n';\n\t\t\t}\n\t\t\tone.erase(x);\n\t\t\tzero.insert(x);\n\t\t\talen.insert(mid1);\n\t\t\talen.insert(mid2);\n\t\t}\n\t\t// cerr<<\"===========================\\n\";\n\t}\n}\nint main(){\n\t// freopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\t// for(scanf(\"%d\",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t// }\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures"], "dificulty": "3000", "interactive": false}