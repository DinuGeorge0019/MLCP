{
    "link": "https://codeforces.com//contest/1758/problem/F",
    "problemId": "1661253",
    "problem_idx": "F",
    "shortId": "1758F",
    "contest_number": "1758",
    "problem_submissions": {
        "F": [
            182540191,
            182568321
        ],
        "E": [
            182511822,
            182586636,
            182586387,
            182515621,
            182519585,
            182518611,
            182521484,
            182522469,
            182521201,
            182526835,
            182524445,
            182531747,
            182527370,
            182535662,
            182516659,
            182531389,
            182540195,
            182534906,
            182535704,
            182534874,
            182530934
        ],
        "D": [
            182500138,
            182501532,
            182504442,
            182507521,
            182511731,
            182494704,
            182508383,
            182512302,
            182512544,
            182503927,
            182510854,
            182528079,
            182501802,
            182493856,
            182514498,
            182506950,
            182513404,
            182511217,
            182525174,
            182492321
        ],
        "C": [
            182492468,
            182496509,
            182492305,
            182495507,
            182494119,
            182500722,
            182502459,
            182500806,
            182500441,
            182492103,
            182505245,
            182496553,
            182526899,
            182500230,
            182495864,
            182508565,
            182493170,
            182498448,
            182538442
        ],
        "B": [
            182487714,
            182492898,
            182486562,
            182485510,
            182487169,
            182486096,
            182487229,
            182491179,
            182486630,
            182482943,
            182485521,
            182488443,
            182519764,
            182489830,
            182487145,
            182487987,
            182502412,
            182487085,
            182484646
        ],
        "A": [
            182480951,
            182480859,
            182482976,
            182480629,
            182480620,
            182481772,
            182483562,
            182480441,
            182483772,
            182479955,
            182480275,
            182480273,
            182517991,
            182490014,
            182483571,
            182480580,
            182480710,
            182480601,
            182480454
        ]
    },
    "name": "F. Decent Division",
    "statement": "A binary string is a string where every character is\r\ntexttt{0} or\r\ntexttt{1}. Call a binary string if it has an equal number of\r\ntexttt{0}s and\r\ntexttt{1}s.Initially, you have an infinite binary string t whose\r\ncharacters are all\r\ntexttt{0}s. You are given a sequence a of n updates, where a_i indicates\r\nthat the character at index a_i will be flipped (\r\ntexttt{0}\r\nleftrightarrow\r\ntexttt{1}). You need to keep and modify after each update a set S of\r\nranges such that: for each range [l,r], the substring t_l\r\ndots t_r is a decent binary string, and for all indices i such that t_i\r\n=\r\ntexttt{1}, there exists [l,r] in S such that l\r\nleq i\r\nleq r. You only need to output the ranges that are added to or removed\r\nfrom S after each update. You can only add or remove ranges from S at\r\nmost\r\nmathbf{10^6} times.More formally, let S_i be the set of ranges after the\r\ni-th update, where S_0 =\r\nvarnothing (the empty set). Define X_i to be the set of ranges removed\r\nafter update i, and Y_i to be the set of ranges added after update i.\r\nThen for 1\r\nleq i\r\nleq n, S_i = (S_{i - 1}\r\nsetminus X_i)\r\ncup Y_i. The following should hold for all 1\r\nleq i\r\nleq n:\r\nforall a,b\r\nin S_i, (a\r\nneq b)\r\nrightarrow (a\r\ncap b =\r\nvarnothing); X_i\r\nsubseteq S_{i - 1}; (S_{i-1}\r\nsetminus X_i)\r\ncap Y_i =\r\nvarnothing;\r\ndisplaystyle\r\nsum_{i = 1}^n {(|X_i| + |Y_i|)}\r\nleq 10^6.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc getchar()\n// #define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch=='-')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=1e6+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint n,m=N-1;\n#define P pair<int,int>\nset<P>mp;\nV input(){\n\tn = getint();\n}\nset<int>one,zero,alen;\nV init(){\n\tFOR(i,1,m)zero.insert(i);\n\tFOR(i,1,m)alen.insert(i);\n}\nstruct node{ // 维护历史最小值\n\tint minn, sum;\n\tnode operator+(const node&o)const{\n\t\tnode out;\n\t\tout.minn = min(minn,sum+o.minn);\n\t\tout.sum = sum+o.sum;\n\t\treturn out;\n\t}\n}t1[N<<2],t2[N<<2];\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,m\n#define lson lc,L,mid\n#define rson rc,mid+1,R\nV build(int p,int L,int R){\n\tt1[p].minn = t2[p].minn = -(R-L+1);\n\tt1[p].sum = t2[p].sum = -(R-L+1);\n\tif(L==R)return;\n\tint mid=L+R>>1;\n\tbuild(lson),build(rson);\n}\nV upd(int p){\n\tt1[p]=t1[lc]+t1[rc];\n\tt2[p]=t2[rc]+t2[lc];\n}\nV change(int p,int L,int R,int x,int w){\n\tif(L==R){\n\t\tif(w){\n\t\t\tt1[p].minn = t2[p].minn = 1;\n\t\t\tt1[p].sum = t2[p].sum = 1;\n\t\t}\n\t\telse{\n\t\t\tt1[p].minn = t2[p].minn = -1;\n\t\t\tt1[p].sum = t2[p].sum = -1;\n\t\t}\n\t\treturn;\n\t}\n\tint mid=L+R>>1;\n\tif(x<=mid)change(lson,x,w);\n\telse change(rson,x,w);\n\tupd(p);\n}\nnode ask1(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t1[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask1(rson,l,r);\n\tif(r<=mid)return ask1(lson,l,r);\n\treturn ask1(lson,l,mid)+ask1(rson,mid+1,r);\n}\nnode ask2(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t2[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask2(rson,l,r);\n\tif(r<=mid)return ask2(lson,l,r);\n\treturn ask2(rson,mid+1,r)+ask2(lson,l,mid);\n}\nV work(){\n\tint x, l, r;\n\tbuild(1,1,m);\n\twhile(n--){\n\t\tx = getint();\n\t\tif(zero.find(x)!=zero.end()){\n\t\t\tl = x, r = *alen.upper_bound(x); // 找一个不被管辖的 0\n\t\t\t// alen.erase(x);\n\t\t\tif(alen.find(x)!=alen.end())\n\t\t\t\talen.erase(x);\n\t\t\telse{\n\t\t\t\talen.erase(r);\n\t\t\t\tr = *alen.upper_bound(x);\n\t\t\t}\n\t\t\talen.erase(r);\n\t\t\tauto it = mp.upper_bound(P(x+1,0));\n\t\t\tif(it != mp.begin()){\n\t\t\t\tauto tmp = it;\n\t\t\t\ttmp --;\n\t\t\t\tif(tmp->first<=x && tmp->second >=x)\n\t\t\t\t\tit --;\n\t\t\t}\n\t\t\tif(it != mp.end()) cmin(l,it->first);\n\t\t\tauto itl = it;\n\t\t\tint cnt = 0;\n\t\t\twhile(it != mp.end() && it->second<=r){\n\t\t\t\tcmax(r, it->second);\n\t\t\t\tit ++, cnt ++;\n\t\t\t}\n\t\t\tauto itr = it;\n\t\t\tcout<<cnt<<'\\n';\n\t\t\tfor(it = itl;it!=itr;it++){\n\t\t\t\tcout<<it->first<<' '<<it->second<<'\\n';\n\t\t\t}\n\t\t\tmp.erase(itl, itr);\n\t\t\tmp.insert(P(l,r));\n\t\t\tcout<<1<<'\\n';\n\t\t\tcout<<l<<' '<<r<<'\\n';\n\t\t\t// auto v = *--mp.lower_bound()\n\t\t\tzero.erase(x);\n\t\t\tone.insert(x);\n\t\t\tchange(root,x,1);\n\t\t}\n\t\telse{\n\t\t\tauto it = --mp.upper_bound(P(x+1,0));\n\t\t\tchange(root,x,0);\n\t\t\tcout<<1<<'\\n';\n\t\t\tint l = it->first,r = it->second;\n\t\t\tcout<<l<<' '<<r<<'\\n';\n\t\t\tmp.erase(it);\n\t\t\tint L, R, mid1, mid2;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid1=L+R>>1,L^R)\n\t\t\t\tif(ask1(root,l,mid1).minn <= -1) R=mid1;\n\t\t\t\telse L=mid1+1;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid2=L+R>>1, L^R)\n\t\t\t\tif(ask2(root,mid2+1,r).minn<=-1)\n\t\t\t\t\tL=mid2+1;\n\t\t\t\telse R= mid2;\n\t\t\t// if(l == x || ask1(root,l,x-1).sum == 0){\n\t\t\t// \tL = x+1, R=r;\n\t\t\t// \twhile(mid=L+R>>1, L^R)\n\t\t\t// \t\tif(ask2(root,mid+1,r).minn<=-1)\n\t\t\t// \t\t\tL=mid+1;\n\t\t\t// \t\telse R= mid;\n\t\t\t// }\n\t\t\t// else{\n\t\t\t// \tL = l, R = x-1;\n\t\t\t// \twhile(mid=L+R>>1,L^R)\n\t\t\t// \t\tif(ask1(root,l,mid).minn <= -1) R=mid;\n\t\t\t// \t\telse L=mid+1;\n\t\t\t// }\n\t\t\tint cnt = (l<=mid1-1) + (mid1+1<=mid2-1)+(mid2+1<=r);\n\t\t\tcout<<cnt<<'\\n';\n\t\t\tif(l<=mid1-1){\n\t\t\t\tmp.insert(P(l,mid1-1));\n\t\t\t\tcout<<l<<' '<<mid1-1<<'\\n';\n\t\t\t}\n\t\t\tif(mid1+1<=mid2-1){\n\t\t\t\tmp.insert(P(mid1+1,mid2-1));\n\t\t\t\tcout<<mid1+1<<' '<<mid2-1<<'\\n';\n\t\t\t}\n\t\t\tif(mid2+1<=r){\n\t\t\t\tmp.insert(P(mid2+1,r));\n\t\t\t\tcout<<mid2+1<<' '<<r<<'\\n';\n\t\t\t}\n\t\t\tone.erase(x);\n\t\t\tzero.insert(x);\n\t\t\talen.insert(mid1);\n\t\t\talen.insert(mid2);\n\t\t}\n\t\t// cerr<<\"===========================\\n\";\n\t}\n}\nint main(){\n\t// freopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\t// for(scanf(\"%d\",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t// }\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Decent Division.json",
    "editorial_link": "https://codeforces.com//blog/entry/109438",
    "editorial": "After each update, we want to maintain the invariant that each interval\r\nis balanced, and additionally that there is a gap containing at least\r\none zero in between each pair of consecutive intervals. Since every must\r\nbe contained in an interval, this is equivalent to having non-empty gaps\r\nbetween consecutive intervals after an update.There are several cases we\r\nneed to handle. Case 1: Bit is changed from to . Case 1a: Bit is\r\ncontained in an interval after the previous updateIf we are inside an\r\ninterval, then we want to grow the interval that contains it by 2 zeros\r\nto maintain balance. If the interval containing is , then we can expand\r\nit to . Since there is at least one after each interval, , so this\r\ncontains one of the two zeroes we need.If there is another interval ,\r\nthen increasing the right bound again by 1 would overlap with this\r\ninterval. In this case, We know that as well, so we can merge both\r\nintervals together into to get a total of two new zeros. was also\r\npreviously balanced, so the interval is still balanced. In this case, we\r\nremoved two intervals and added one interval, so a total of three\r\noperations were used.If there is no intervals where , then , so we can\r\nsimply expand the current interval once more to . One interval was\r\nremoved and one interval was added, so a total of two operations were\r\nused. Case 1b: Bit is not contained in an interval.If there exists an\r\ninterval where , then we can expand it to . This interval is directly\r\nafter , so expanding it by one to the left will include an extra . since\r\nit is part of the gap between two intervals, so including it balances .\r\nOne interval was removed and one interval was added, so a total of two\r\noperations were used.If there is no interval where , then . Therefore,\r\nwe can simply add , which is balanced. One interval was added, so a\r\ntotal of one operation was used. In both cases, after adding a new\r\ninterval to the set, we can merge with any adjacent intervals to the\r\nleft or right. This will maintain the invariant that there is a gap\r\nbetween consecutive ranges as mentioned earlier. We merge at most once\r\nto the left and one to the right. Since the maximum number of operations\r\ndone earlier is 3, the maximum number of operations in total is 5 in\r\nthis case. Case 2: Bit is changed from to . Suppose that . In this case,\r\nwe want to somehow split the interval into two balanced portions. Now,\r\nsuppose we compute the prefix sums of the balance, where corresponds to\r\nand corresponds to . If is the first location where the prefix sum\r\nequals , then we claim that we can split the interval into and .To prove\r\nthis, note that the balance of the empty prefix is 0, so before the\r\nprefix sum equals for the first time, it must have gone . To have two\r\ndecreases in a row, we must have . In the interval , the final balance\r\nprefix sum is , so the first interval is balanced. Since we changed a to\r\na and removed two s, the first interval being balanced implies that the\r\nsecond interval is balanced as well. In addition, since the original\r\ninterval satisfied the separation invariant, and the new intervals are\r\nseparated by two s, the separation invariant is still satisfied.To\r\ncompute the first time when the balance prefix sum equals -2, we can use\r\nbinary search on the interval using a lazy segment tree. The segment\r\ntree represents a global balance prefix sum, and we can range query the\r\nminimum balance on an interval. We can binary search for the lowest\r\nindex on the interval where the minimum prefix sum is less than -2.In\r\nthis case, we removed one interval and added two new intervals, for a\r\ntotal of three operations. In both cases, we use at most 5 operations in\r\na single step, so we in total use at most operations, which fits in our\r\nbound. In practice, this upper bound is quite loose.Because of the\r\nbinary search on the lazy segment tree, the time complexity for this\r\nsolution is . Note that this can be optimized to by optimizing the\r\nbinary search, but this was not required.\r\n",
    "hint": [
        "Hint If we are modifying a point already in an interval, how can we grow/split the interval to maintain balance?",
        "Hint: Answer is impossible is n is not divisible by x Start with the identity permutation 1,2,3,...,n Now we know, p[1] = x , p[n] = 1 , so p[x] = n . So, we get x,2,3,..,x-1,n,x+1,...,n-1,1 The only task left is to make this lexicographically smaller. Now elements from 2,3,...,x-1 are fixed, so to make this lexicographically smaller, which element can you swap?"
    ]
}