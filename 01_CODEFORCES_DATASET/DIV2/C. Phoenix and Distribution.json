{"link": "https://codeforces.com//contest/1348/problem/C", "problemId": "609090", "problem_idx": "C", "shortId": "1348C", "contest_number": "1348", "problem_submissions": {"F": [78730137, 78732956, 78738021, 78735188, 78738507, 78734079, 78753080, 78717089, 78727355, 78727368, 78773476, 78740376], "E": [78711148, 78713291, 78707898, 78710381, 78719540, 78713433, 78709333, 79466363, 78772738, 78713600, 78699633, 78717322, 78717382, 78717153, 78728870, 78722408, 78722025, 78727426, 78728940], "C": [78694419, 78693419, 78696011, 78687630, 78679892, 78697771, 78685191, 78681524, 78686378, 78693929, 78687938, 78717342, 78689661, 78687381, 78689833, 78687589, 78685601, 78687639, 78687038], "D": [78686862, 78702906, 78690856, 78698132, 78702134, 78701001, 78706132, 78701735, 78701924, 78711443, 78693858, 78706550, 78704171, 78707502, 78702198, 78714055, 78702526, 78697601, 78708853, 78702351], "B": [78677169, 78673852, 78668555, 78675102, 78668889, 78672084, 78671272, 78669645, 79465649, 78671217, 78677254, 78667586, 78673648, 78677181, 78676314, 78695320, 78673038, 78670148, 78674360, 78670529, 78675058], "A": [78669591, 78665336, 78662907, 78664918, 78662747, 78662442, 78662941, 78662589, 78662555, 78665985, 78662547, 78662641, 78669435, 78666111, 78662690, 78662462, 78663929, 78669719, 78662632, 78663426]}, "name": "C. Phoenix and Distribution", "statement": "Phoenix has a string s consisting of lowercase Latin letters. He wants\r\nto distribute all the letters of his string into k strings a_1, a_2,\r\ndots, a_k such that every letter of s goes to exactly one of the strings\r\na_i. The strings a_i need to be substrings of s. Phoenix can distribute\r\nletters of s and rearrange the letters within each string a_i however he\r\nwants.For example, if s = and k=2, Phoenix may distribute the letters of\r\nhis string in many ways, such as: and and and and But these ways are\r\ninvalid: and and and empty string (a_i should be non-empty) Phoenix\r\nwants to distribute the letters of his string s into k strings a_1, a_2,\r\ndots, a_k to the lexicographically maximum string among them, i. e.\r\nminimize max(a_1, a_2,\r\ndots, a_k). Help him find the optimal distribution and print the minimal\r\npossible value of max(a_1, a_2,\r\ndots, a_k).String x is lexicographically less than string y if either x\r\nis a prefix of y and x\r\nne y, or there exists an index i (1\r\nle i\r\nle min(|x|, |y|)) such that x_i < y_i and for every j (1\r\nle j < i) x_j = y_j. Here |x| denotes the length of the string x.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=100010;\nint t,k,n,a[MAXN];\nchar c[MAXN];\nint divc (int a,int b) {\n\tif (a%b==0) {return a/b;}\n\telse {return a/b+1;}\n}\nint main () {\n\tscanf(\"%d\",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tscanf(\"%s\",c+1);\n\t\tfor (int i=1;i<=n;i++) {a[i]=c[i]-'a'+1;}\n\t\tsort(a+1,a+n+1);\n\t\tif (a[1]==a[k]) {\n\t\t\tint flg=0;\n\t\t\tfor (int j=k+1;j<=n;j++) {if (a[j]!=a[k+1]) {flg=1;break;}}\n\t\t\tif (!flg) {\n\t\t\t\tprintf(\"%c\",a[k]+'a'-1);\n\t\t\t\tfor (int j=1;j<=divc((n-k),k);j++) {printf(\"%c\",a[k+1]+'a'-1);}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t} else {\n\t\t\t\tfor (int j=k;j<=n;j++) {printf(\"%c\",a[j]+'a'-1);}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"%c\\n\",a[k]+'a'-1);\n\t\t}\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings", "strings"], "dificulty": "1600", "interactive": false}