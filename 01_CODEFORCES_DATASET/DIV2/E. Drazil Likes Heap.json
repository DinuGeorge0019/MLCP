{
    "link": "https://codeforces.com//contest/1330/problem/E",
    "problemId": "582582",
    "problem_idx": "E",
    "shortId": "1330E",
    "contest_number": "1330",
    "problem_submissions": {
        "E": [
            75407483,
            75403686,
            75406825,
            75412857,
            75411514,
            75411404,
            75407783,
            75407274,
            75400418,
            75447922,
            75412935,
            75466280
        ],
        "D": [
            75391296,
            75385541,
            80644507,
            75388709,
            75387337,
            75393475,
            75395701,
            75385540,
            75376125,
            75379564,
            75382546,
            75380901,
            75384917,
            75382324,
            75380657,
            75388115,
            75386567,
            75461008,
            75388223,
            75387064
        ],
        "C": [
            75379279,
            75374912,
            75381565,
            75376079,
            75376451,
            75390556,
            75381440,
            75360964,
            75379654,
            75372629,
            75367460,
            75443397,
            75374056,
            75373762,
            75374173,
            220742361,
            75370741,
            75373514,
            75361682,
            75373297
        ],
        "B": [
            75362106,
            75368513,
            75363431,
            75362706,
            75364291,
            75378289,
            75379661,
            75360912,
            75356953,
            75360775,
            75363811,
            75360857,
            75361079,
            75359545,
            195278107,
            75360634,
            75361090,
            75371429,
            75361221
        ],
        "A": [
            75355521,
            75354244,
            75354217,
            75356116,
            75354591,
            75364896,
            75353923,
            75353902,
            75354562,
            75354818,
            75353692,
            75353618,
            75362319,
            179068881,
            75354934,
            75353839,
            75364875,
            75354143
        ]
    },
    "name": "E. Drazil Likes Heap",
    "statement": "Drazil likes heap very much. So he created a problem with heap:There is\r\na max heap with a height h implemented on the array. The details of this\r\nheap are the following:This heap contains exactly 2^h - 1 positive\r\nnon-zero integers. All integers are distinct. These numbers are stored\r\nin the array a indexed from 1 to 2^h-1. For any 1 < i < 2^h, a[i] < a[\r\nleft\r\nlfloor{\r\nfrac{i}{2}}\r\nright\r\nrfloor].Now we want to reduce the height of this heap such that the\r\nheight becomes g with exactly 2^g-1 numbers in heap. To reduce the\r\nheight, we should perform the following action 2^h-2^g times:Choose an\r\nindex i, which contains an element and call the following function f in\r\nindex i:Note that we suppose that if a[i]=0, then index i don\u2019t contain\r\nan element.After all operations, the remaining 2^g-1 element must be\r\nlocated in indices from 1 to 2^g-1. Now Drazil wonders what\u2019s the\r\nminimum possible sum of the remaining 2^g-1 elements. Please find this\r\nsum and find a sequence of the function calls to achieve this value.\r\n",
    "solutions": [
        "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nint t,h,g,n,a[2100000],Log2[2100000];\nint cnt,Ans[2100000];\nll ans;\nint getd(int u){\n\tint ls=(u<<1),rs=(ls|1);\n\tif (!a[ls]&&!a[rs]) return u;\n\telse if (a[ls]>a[rs]) return getd(ls);\n\telse return getd(rs);\n}\nvoid work(int u){\n\tint ls=(u<<1),rs=(ls|1);\n\tif (!a[ls]&&!a[rs]){\n\t\ta[u]=0;\n\t}else\n\t\tif (a[ls]>a[rs]){\n\t\t\ta[u]=a[ls];\n\t\t\twork(ls);\n\t\t}\n\t\telse{\n\t\t\ta[u]=a[rs];\n\t\t\twork(rs);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&t);\n\tLog2[0]=-1;\n\tfor (int i=1;i<=2097152;i++) Log2[i]=Log2[i>>1]+1;\n\twhile (t--){\n\t\tscanf(\"%d%d\",&h,&g);\n\t\tn=(1<<(h+1))-1;\n\t\tfor (int i=1;i<=n;i++) a[i]=0;\n\t\tn=(1<<h)-1;\n\t\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\t\tcnt=0; ans=0;\n\t\tn=(1<<g)-1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\twhile (Log2[getd(i)]+1>g)\n\t\t\t\twork(i),Ans[++cnt]=i;\n\t\tfor (int i=1;i<=n;i++) ans+=a[i];\n\t\tprintf(\"%lld\\n\",ans);\n\t\tfor (int i=1;i<cnt;i++) printf(\"%d \",Ans[i]);\n\t\tprintf(\"%d\\n\",Ans[cnt]);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Drazil Likes Heap.json",
    "editorial_link": "https://codeforces.com//blog/entry/75559",
    "editorial": "The property of heap we concern in this problem mainly are:\n\n1. The tree is a binary tree, each node has a weight value.\n\n2. The weight of a node is always larger than the weight of its children.\n\n3. We use a[I]\n to record the weight of vertex i\n, and the number of its children are 2\u00d7i\n and vertex 2\u00d7i+1\n (if exist).\n\nAnother key point we should consider seriously is before all operations and after all operations, the tree must be a perfect binary tree. Many contestants didn't notice the constraint during the contest.\n\nI think there are two different thinking directions for this problem. One is considering node from bottom to top. Another one is considering node from top to bottom. For me, from bottom to top is more intuitive.\n\nNow we talk about \"from bottom to top\" first, it means we consider node from larger index to smaller index in the tree after all operations (call it final tree after). For the leaves in the final tree, it's not hard to know, the minimum possible final weight of each leaf is the minimum weight of nodes in its subtree before all operations (call it beginning tree after). For the other nodes in the final tree, its weight must satisfy two constraints, one is it should be larger than the final weight of his children, another is the weight should exist in its subtree of the beginning tree. Luckily, these lower bounds are all constraints we should consider to get the answer. For each leaf in the final tree, we maintain a data structure that stores all weight of its subtree in the beginning tree. Then the minimum value in this data structure is its final weight. For other nodes in the final tree, we merge the two data structures of its children. the remove all value which is less than the final weight of his children. There are many data structure can do these operations, such as min heap(author's code) or sorted array(isaf27's code).\n\nWith the above method, we get the minimum possible sum of the remaining 2g?1\n elements. But we still don't know how to construct it. All we know is which weight values are reaming in the final tree. Now I want to prove that no matter how the order I call the function f\n, if the remaining weight values set is the same, the final shape of the final tree will be the same.\n\nThis time I prove it from top to bottom. We only know which weight values set to remain in the final, Then We iterate node from smallest index to the larger one. We always can determine the weight value of the iterated node, because the weight value only can be the maximum value in its subtree. This trait also can let us know that the final tree we get in our method is a perfect binary tree.\n\nConclude all things above. after we can apply the function f\n from bottom to top on these nodes with weight value doesn't exist in the final tree.\n\nIn the \"from bottom to top\" method, it has some thinking level difference between calculating the minimum sum and constructing a list of possible operations. So I determine let competitors output the operations.\n\n- - -\n\nNow we talk about the \"from top to bottom\" method. The main idea of this method is iterating index from 1\n to 2g?1\n and in each iteration, applying the function f\n on i\n-th node until the shape of the final tree is impossible to become a perfect binary tree. The method is quite easy to write and almost has no difference when asking you to output the operations. But I think it's hard to prove. Evenly, I think the solution should be wrong until I write this solution and test it.\n\nFirstly I want to prove the minimum possible final weight value of node 1\n is the same as the above \"from top to bottom\" method get. We call the value as mi1\n. If some algorithm B\n can get more small weight value in the final tree, It means all weight values which are not smaller than mi1\n disappear. But according to the conclusion \"if the remaining weight values set is the same, the final shape of the final tree will be the same.\". the final tree generated by B\n can also get with firstly applying the function f\n on node 1\n at least one more time than above \"from top to bottom\" algorithm, and do some other operations. But it will make the final tree is impossible to be the perfect binary tree. Now we disprove it.\n\nNow we want to prove the final weight value of node i\n(i>1\n) is the same as the above \"from top to bottom\" method get. Only when applying function f\n on ancestors and descendants of node i\n will affect the final weight value of node i\n. And when we apply on its ancestors, the f\n may recursively apply f\n on it\n at most once. So each time f\n applies on its ancestors is equivalent to apply on itself once or do nothing. Therefore, The proof can be don as what we do on node 1\n just by only considering the subtree of node i\n.\n\nNow, we have proved the \"top to bottom\" algorithm can make each node of the final tree has the minimum possible weight value."
}