{"link": "https://codeforces.com//contest/1330/problem/E", "problemId": "582582", "problem_idx": "E", "shortId": "1330E", "contest_number": "1330", "problem_submissions": {"E": [75407483, 75403686, 75406825, 75412857, 75411514, 75411404, 75407783, 75407274, 75400418, 75447922, 75412935, 75466280], "D": [75391296, 75385541, 80644507, 75388709, 75387337, 75393475, 75395701, 75385540, 75376125, 75379564, 75382546, 75380901, 75384917, 75382324, 75380657, 75388115, 75386567, 75461008, 75388223, 75387064], "C": [75379279, 75374912, 75381565, 75376079, 75376451, 75390556, 75381440, 75360964, 75379654, 75372629, 75367460, 75443397, 75374056, 75373762, 75374173, 220742361, 75370741, 75373514, 75361682, 75373297], "B": [75362106, 75368513, 75363431, 75362706, 75364291, 75378289, 75379661, 75360912, 75356953, 75360775, 75363811, 75360857, 75361079, 75359545, 195278107, 75360634, 75361090, 75371429, 75361221], "A": [75355521, 75354244, 75354217, 75356116, 75354591, 75364896, 75353923, 75353902, 75354562, 75354818, 75353692, 75353618, 75362319, 179068881, 75354934, 75353839, 75364875, 75354143]}, "name": "E. Drazil Likes Heap", "statement": "Drazil likes heap very much. So he created a problem with heap:There is\r\na max heap with a height h implemented on the array. The details of this\r\nheap are the following:This heap contains exactly 2^h - 1 positive\r\nnon-zero integers. All integers are distinct. These numbers are stored\r\nin the array a indexed from 1 to 2^h-1. For any 1 < i < 2^h, a[i] < a[\r\nleft\r\nlfloor{\r\nfrac{i}{2}}\r\nright\r\nrfloor].Now we want to reduce the height of this heap such that the\r\nheight becomes g with exactly 2^g-1 numbers in heap. To reduce the\r\nheight, we should perform the following action 2^h-2^g times:Choose an\r\nindex i, which contains an element and call the following function f in\r\nindex i:Note that we suppose that if a[i]=0, then index i don\u2019t contain\r\nan element.After all operations, the remaining 2^g-1 element must be\r\nlocated in indices from 1 to 2^g-1. Now Drazil wonders what\u2019s the\r\nminimum possible sum of the remaining 2^g-1 elements. Please find this\r\nsum and find a sequence of the function calls to achieve this value.\r\n", "solutions": ["#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nint t,h,g,n,a[2100000],Log2[2100000];\nint cnt,Ans[2100000];\nll ans;\nint getd(int u){\n\tint ls=(u<<1),rs=(ls|1);\n\tif (!a[ls]&&!a[rs]) return u;\n\telse if (a[ls]>a[rs]) return getd(ls);\n\telse return getd(rs);\n}\nvoid work(int u){\n\tint ls=(u<<1),rs=(ls|1);\n\tif (!a[ls]&&!a[rs]){\n\t\ta[u]=0;\n\t}else\n\t\tif (a[ls]>a[rs]){\n\t\t\ta[u]=a[ls];\n\t\t\twork(ls);\n\t\t}\n\t\telse{\n\t\t\ta[u]=a[rs];\n\t\t\twork(rs);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&t);\n\tLog2[0]=-1;\n\tfor (int i=1;i<=2097152;i++) Log2[i]=Log2[i>>1]+1;\n\twhile (t--){\n\t\tscanf(\"%d%d\",&h,&g);\n\t\tn=(1<<(h+1))-1;\n\t\tfor (int i=1;i<=n;i++) a[i]=0;\n\t\tn=(1<<h)-1;\n\t\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\t\tcnt=0; ans=0;\n\t\tn=(1<<g)-1;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\twhile (Log2[getd(i)]+1>g)\n\t\t\t\twork(i),Ans[++cnt]=i;\n\t\tfor (int i=1;i<=n;i++) ans+=a[i];\n\t\tprintf(\"%lld\\n\",ans);\n\t\tfor (int i=1;i<cnt;i++) printf(\"%d \",Ans[i]);\n\t\tprintf(\"%d\\n\",Ans[cnt]);\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy", "implementation"], "dificulty": "2400", "interactive": false}