{
    "link": "https://codeforces.com//contest/1918/problem/G",
    "problemId": "2452577",
    "problem_idx": "G",
    "shortId": "1918G",
    "contest_number": "1918",
    "problem_submissions": {
        "G": [
            244132893,
            245985475,
            244948797,
            244948670
        ],
        "F": [
            244120772,
            244125092,
            244126848,
            244126771,
            244130168,
            244131697,
            244138260,
            244138344,
            244139263,
            244138435,
            244141669,
            244144124,
            244142227,
            244122678,
            244157073,
            244156595,
            244332251,
            244124771,
            244360495,
            244129898
        ],
        "D": [
            244109167,
            244099156,
            244092966,
            244101787,
            244100881,
            244108481,
            244101721,
            244106486,
            244109529,
            244104916,
            244106995,
            244113590,
            244113865,
            244099423,
            244110295,
            244096244,
            244108027,
            244103663,
            244360463,
            244108155
        ],
        "E": [
            244103507,
            244108050,
            244110113,
            244110472,
            244112287,
            244124161,
            244125655,
            244123391,
            244119446,
            244125406,
            244135128,
            244134725,
            244128795,
            244112679,
            244118320,
            244116217,
            244928601,
            244928561
        ],
        "C": [
            244091247,
            244087599,
            244079342,
            244087694,
            244092782,
            244089213,
            244094187,
            244089808,
            244094684,
            244096501,
            244097023,
            244099017,
            244107490,
            244085730,
            244089866,
            244086764,
            244094953,
            244095107,
            244360406,
            244091142
        ],
        "B": [
            244083801,
            244076050,
            244075794,
            244073267,
            244075602,
            244075619,
            244082026,
            244079074,
            244080512,
            244082819,
            244079063,
            244082004,
            244078089,
            244075054,
            244078156,
            244075906,
            244081851,
            244083244,
            244360342,
            244080338
        ],
        "A": [
            244083099,
            244071431,
            244072186,
            244071210,
            244070855,
            244071315,
            244075506,
            244071630,
            244072257,
            244074358,
            244071939,
            244071253,
            244071114,
            244071560,
            244071154,
            244071990,
            244074495,
            244089579,
            244360312,
            244073174
        ]
    },
    "name": "G. Permutation of Given",
    "statement": "You were given only one number, n. It didn\u2019t seem interesting to you, so\r\nyou wondered if it\u2019s possible to come up with an array of length n\r\nconsisting of non-zero integers, such that if each element of the array\r\nis replaced by the sum of its neighbors (the elements on the ends are\r\nreplaced by their only neighbors), you obtain a permutation of the\r\nnumbers in the original array.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N ;\n#define P 1000000007\n#define INF 1061109567\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> PII;\ntypedef unsigned long long ull;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline ll read(){\n\tll x=0,f=1;char ch=GC;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=GC;}\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=GC;}\n\treturn x*f;\n}\nvoid Solve(){\n\tint n=read();\n\tif(n==3||n==5){printf(\"NO\\n\");return;}\n\tprintf(\"YES\\n\");\n\tif(n%6==0){\n\t\tprintf(\"2 -2 -1 \");\n\t\tfor(int i=1;i<n/6;i++)printf(\"1 2 1 -1 -2 -1 \");\n\t\tprintf(\"1 2 1\\n\");\n\t}else if(n%6==1){\n\t\tprintf(\"-3 -3 2 \");\n\t\tfor(int i=1;i<n/6;i++)printf(\"1 -1 -2 -1 1 2 \");\n\t\tprintf(\"1 -1 1 -2\\n\");\n\t}else if(n%6==2){\n\t\tprintf(\"-1 \");\n\t\tfor(int i=1;i<=n/6;i++)printf(\"1 2 1 -1 -2 -1 \");\n\t\tprintf(\"1\\n\");\n\t}else if(n%6==3){\n\t\tprintf(\"-3 -3 1 2 \");\n\t\tfor(int i=1;i<n/6;i++)printf(\"1 -1 -2 -1 1 2 \");\n\t\tprintf(\"1 -1 -2 2 -1\\n\");\n\t}else if(n%6==4){\n\t\tprintf(\"1 -1 \");\n\t\tfor(int i=1;i<=n/6;i++)printf(\"1 2 1 -1 -2 -1 \");\n\t\tprintf(\"1 2\\n\");\n\t}else{\n\t\tprintf(\"-3 -3 1 1 -2 1 -1 \");\n\t\tfor(int i=1;i<n/6;i++)printf(\"-2 -1 1 2 1 -1 \");\n\t\tprintf(\"-2 2 3 -1\\n\");\n\t}\n}\nint main(){\n\tSolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Permutation of Given.json",
    "editorial_link": "https://codeforces.com//blog/entry/125300",
    "editorial": "Tutorial At first, you can manually find answers for small values of .\nFor , the answer will be \"YES\" and the arrays will be , , . It is not\ndifficult to prove by case analysis that the answer is \"NO\" for and . It\ncan be assumed that for all odd , the answer is \"NO\", but if you try to\nprove the absence of an array or find an array for , it turns out that\nthe array exists: . In fact, an array exists for all except and .It\nwould be easy if it were possible to make the number in each cell\nunchanged. But the presence of array edges and the prohibition of zeros\nmake this impossible. Furthermore, it can be noticed that an infinite\narray in which the sequence of six numbers is repeated, generates the\nsame number in each cell as it was there. In general, any sequence of\nsix numbers of the form will have this property. Thus, it is possible to\ntransform the internal cells of the array into cells with the same\nnumbers, the question is what to do at the edges. In the author\u00e2\u0080\u0099s\nsolution, suitable edges (possibly consisting of several numbers) were\nmanually selected for each remainder of division by . And then the\nsolution for each value of was created as follows: take the edges for\nand insert into the middle as many sequences of six numbers that\ntransition into themselves as needed.Solution by green_gold_dog:The idea\nis that any correct array can be extended by elements to remain correct.\nLet the array end with the numbers and . Then it can be extended by two\nelements as follows: This array transitions into its permutation: the\nentire old array, except for , is generated by the old array; the last\nthree cells generate , , , i.e., two new elements, and the missing\nelement . It is also necessary for the new elements to be non-zero. If\nthe last two elements of the old array were different, then the new\nelements are non-zero; moreover, the new elements cannot be the same, as\nand are non-zero, so this operation can be repeated many times.To start,\ntwo arrays are sufficient: for and for . Then these arrays can be\nextended by to obtain the answer for even or odd .Both solutions print\nan array using simple rules and work in time.\n"
}