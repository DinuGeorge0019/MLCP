{
    "link": "https://codeforces.com//contest/842/problem/D",
    "problemId": "120315",
    "problem_idx": "D",
    "shortId": "842D",
    "contest_number": "842",
    "problem_submissions": {
        "E": [
            29892175,
            29896709,
            29892728
        ],
        "C": [
            29876363,
            29876870,
            29881263,
            29880716,
            29891701,
            29882766,
            29881217,
            29877383,
            29881389,
            29887847,
            29882055,
            29876553,
            29885327,
            29897484,
            29879763,
            29887443,
            29895634,
            29895199,
            29916549,
            29916532,
            29916152,
            29891176,
            29895609
        ],
        "D": [
            29875168,
            29881874,
            29886504,
            29883941,
            29879589,
            29886046,
            29872999,
            29882468,
            29887643,
            29882954,
            29887687,
            29889517,
            29890953,
            29888540,
            29891985,
            29892689,
            29883468,
            29883460,
            29887258,
            29886746
        ],
        "B": [
            29874014,
            29874407,
            29872985,
            29872379,
            29886135,
            38859573,
            29873183,
            29883006,
            29876642,
            29873270,
            29874068,
            29874064,
            29886058,
            29876537,
            29878343,
            29881672,
            29872806,
            29873575,
            29872847,
            29873445,
            29873104
        ],
        "A": [
            29870801,
            29869133,
            29887434,
            29870152,
            29882916,
            29869760,
            29883576,
            29869196,
            29869793,
            29870793,
            29869617,
            29869267,
            29869102,
            29871125,
            29882379,
            29869173,
            29870818,
            29869360,
            29870433,
            29869454
        ]
    },
    "name": "D. Vitya and Strange Lesson",
    "statement": "Today at the lesson Vitya learned a very interesting function . of a\r\nsequence of numbers is the minimum non-negative number that is not\r\npresent in the sequence as element. For example, and .Vitya quickly\r\nunderstood all tasks of the teacher, but can you do the same?You are\r\ngiven an array consisting of non-negative integers, and queries. Each\r\nquery is characterized by one number and consists of the following\r\nconsecutive steps: Perform the bitwise addition operation modulo () of\r\neach array element with the number . Find of the resulting array.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define MN 600000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m,s[25];\nstruct Tree{int l,r,x;}T[MN*4+5];\n\nvoid Build(int x,int l,int r)\n{\n    if((T[x].l=l)==(T[x].r=r)) return;\n    int mid=T[x].l+T[x].r>>1;\n    Build(x<<1,l,mid);Build(x<<1|1,mid+1,r);\n}\n\nvoid insert(int x,int k)\n{\n    if(T[x].l==T[x].r) {T[x].x=1;return;}\n    int mid=T[x].l+T[x].r>>1;\n    insert(x<<1|(k>mid),k);\n    T[x].x=T[x<<1].x+T[x<<1|1].x;\n}\n\nint Query(int x,int k)\n{\n    if(T[x].l==T[x].r) return 0;\n    int y=x<<1|s[k];\n    if(T[y].x==T[y].r-T[y].l+1) return Query(y^1,k-1)+(1<<k);\n    else return Query(y,k-1);\n}\n\nint main()\n{\n    n=read();m=read();Build(1,0,524287);\n    for(int i=1;i<=n;++i) insert(1,read());\n    for(int i=1;i<=m;++i)\n    {\n        int x=read();\n        for(int j=0;j<19;++j) if(x&(1<<j)) s[j]^=1;\n        printf(\"%d\\n\",Query(1,18));\n    }\n    \n    \n    \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Vitya and Strange Lesson.json",
    "editorial_link": "https://codeforces.com//blog/entry/54179",
    "editorial": "If the last query was and then we receive a query , then we can leave\r\nthe original array unchanged and use the number as the second query. So\r\nwe will maintain current xor of queries instead of changing the array.\r\nIt\u00e2\u0080\u0099s easy to see that if the array contains all numbers from zero to and\r\nthe number in the query is less than , then the array will still contain\r\nall those numbers. Let\u00e2\u0080\u0099s store all numbers from the array in binary trie\r\nand maintain the number of leaves in each subtree. To answer each query,\r\nwe will descend the trie. We need to get the lowest possible answer, so\r\nif current bit of the number in the query equals ( or ), so we firstly\r\ncheck the subtree that corresponds to bit . We will descend into the\r\nvertex only if the subtree is not a complete binary tree (so there\r\nexists a number that would belong to this subtree but is not included in\r\nthe array). When we try to descend into an empty subtree, then we set\r\nall remaining bits in the answer to zero. https://ideone.com/gVE1kC\r\n"
}