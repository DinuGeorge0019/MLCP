{
    "link": "https://codeforces.com//contest/1733/problem/D1",
    "problemId": "1545181",
    "problem_idx": "D1",
    "shortId": "1733D1",
    "contest_number": "1733",
    "problem_submissions": {
        "D2": [
            172908790,
            172751668,
            172751592,
            172688818,
            172697623,
            172704330,
            172699879,
            172705767,
            172702852,
            172714613,
            172708338,
            172708145,
            172730890,
            172696294,
            172712879,
            172716774,
            172688613,
            172689119,
            172689710,
            172695749,
            172696981
        ],
        "D1": [
            172745848,
            172681320,
            172687676,
            172680669,
            172685630,
            172696041,
            172687426,
            172689916,
            172696394,
            172697035,
            172699792,
            172689249,
            172700313,
            172694614,
            172716626,
            172702590,
            172680742,
            172680205,
            172683816,
            172681184,
            172674583
        ],
        "E": [
            172704678,
            172710249,
            172719591,
            172713937,
            172716945,
            172716621,
            172726801,
            172726417,
            172719626,
            172716943,
            172733013,
            172732883,
            172718293,
            172731490,
            172731251,
            172913723
        ],
        "C": [
            172676165,
            172683984,
            172676733,
            172677972,
            172690144,
            172679557,
            172682040,
            172688901,
            172690916,
            172688245,
            172682291,
            172693974,
            172680990,
            172692339,
            172679773,
            172676779,
            172675599,
            172678602,
            172677398,
            172680874
        ],
        "B": [
            172670086,
            172672965,
            172671197,
            172672977,
            172676007,
            172675583,
            172672789,
            172677489,
            172677650,
            172675221,
            172676078,
            172675427,
            172674469,
            172685302,
            172673596,
            172671749,
            172670718,
            172670846,
            172673489,
            172671842
        ],
        "A": [
            172667033,
            172667345,
            172667036,
            172667352,
            172668545,
            172668036,
            172667195,
            172670967,
            172668926,
            172667072,
            172674028,
            172668209,
            172667604,
            172671761,
            172667273,
            172667385,
            172667155,
            172667212,
            172667018,
            172667026
        ]
    },
    "name": "D1. Zero-One  Easy Version ",
    "statement": "You are given two binary strings a and b, both of length n. You can do\r\nthe following operation any number of times (possibly zero). Select two\r\nindices l and r (l < r). Change a_l to (1 - a_l), and a_r to (1 - a_r).\r\nIf l + 1 = r, the cost of the operation is x. Otherwise, the cost is y.\r\nYou have to find the minimum cost needed to make a equal to b or say\r\nthere is no way to do so.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint T;\n\nint n,m;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tstring s,t;\n\t\tvector<int>v;\n\t\tcin>>s>>t;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(s[i]!=t[i])\n\t\t\t\tv.push_back(i);\n\t\tif(v.size()&1)\n\t\t{\n\t\t\tcout<<\"-1\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tlong long ans=0;\n\t\tif(v.size()>2||v.size()==0||(v[0]+1!=v[1]))\n\t\t{\n\t\t\tans=v.size()/2*y;\n\t\t\tcout<<ans<<\"\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans=min(2*y,x);\n\t\t\tcout<<ans<<\"\\n\";\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Zero-One  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/83109",
    "editorial": "Consider another binary string , in which (). So doing an\noperation means selecting two indices of and flipping them. Also, letâs\ndefine is the number of in . Because the parity of never changes, the\nanswer is if is odd.If is even, classify the cases: If and two -s are\nadjacent, the answer is . Because holds, we can always replace one -cost\noperation with two -cost operations. If and two -s are not adjacent, the\nanswer is . If , select -th and -th each (). This costs , and we showed\nthe cost cannot be reduced more in hint 3.\n",
    "hint": [
        "Hint 1 Consider is another binary string, in which . We have to make equal to using the operation.",
        "Hint 2 Because the operation does not change the parity of the number of in , the answer is if has odd number of .",
        "Hint 3 If the number of in is (now assume that is even), at least operations are needed. So total cost would be at least .",
        "Hint 4 One -cost operation can be replaced with two -cost operations."
    ]
}