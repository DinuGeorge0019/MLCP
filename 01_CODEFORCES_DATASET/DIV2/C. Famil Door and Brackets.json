{"link": "https://codeforces.com//contest/629/problem/C", "problemId": "48978", "problem_idx": "C", "shortId": "629C", "contest_number": "629", "problem_submissions": {"E": [16243210, 16242894, 16246160, 16254693, 16246007, 16245862, 16244672, 16242439, 16242471, 16258760, 16243275, 16248006], "C": [16240352, 16245370, 16241705, 16242440, 16239928, 16244882, 16239964, 16237682, 16237279, 16238555, 16240653, 16241020, 16238564, 16239658, 16239634], "D": [16239018, 16239572, 16235953, 16238851, 16241535, 16240168, 16238831, 16236923, 16236354, 16239430, 16240177, 16240027, 16239268, 16236114, 16247725, 16240713, 16264201, 16261091, 16260254, 16241789], "B": [16234677, 16235476, 16237727, 16234525, 16235367, 16236730, 16234379, 16237767, 16237135, 16233315, 16234172, 16233262, 16234095, 16233764, 16235011, 16233668], "A": [16232727, 16233109, 16236608, 16232783, 16233137, 16233465, 16232870, 16238509, 16232645, 16232640, 16233626, 16232665, 16232698, 16232767, 16233370, 16232800]}, "name": "C. Famil Door and Brackets", "statement": "As Famil Door s birthday is coming, some of his friends (like Gabi)\r\ndecided to buy a present for him. His friends are going to buy a string\r\nconsisted of round brackets since Famil Door loves string of brackets of\r\nlength more than any other strings!The sequence of round brackets is\r\ncalled if and only if: the total number of opening brackets is equal to\r\nthe total number of closing brackets; for any prefix of the sequence,\r\nthe number of opening brackets is greater or equal than the number of\r\nclosing brackets. Gabi bought a string of length () and want to complete\r\nit to obtain a valid sequence of brackets of length . He is going to\r\npick some strings and consisting of round brackets and merge them in a\r\nstring , that is add the string at the beginning of the string and\r\nstring at the end of the string .Now he wonders, how many of strings and\r\nexists, such that the string is a valid sequence of round brackets. As\r\nthis number may be pretty large, he wants to calculate it modulo .\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define pll pair < ll, ll >\n#define all(s) s.begin(), s.end()\n#define sz(s) (int) s.size()\n#define vi vector < int >\n\nconst int inf = (int)1e9;\nconst int mod = (int) 1e9 + 7;\n\nint n, m;\nstring s;\nvector < int > g;\nint dp[4000][4000];\n\n\nvoid add(int &v, int u){\n\tv += u;\n\tif(v >= mod) v -= mod;\n}\n\n\nint main () {\n    #ifdef LOCAL\n    freopen (\"a.in\", \"r\", stdin);\n    freopen (\"a.out\", \"w\", stdout);\n    #endif\n    cin>> n >> m;\n    cin >> s;\n    int x = 0;\n    for(int i = 0; i < m; i++){\n    \tif(s[i] == '('){\n    \t\tg.pb(1);\n    \t}\n    \telse{\n    \t\tif(g.size() > 0){\n    \t\t\tg.pop_back();\n    \t\t}\n    \t\telse {\n    \t\t\tx++;\n    \t\t}\n    \t}\n    }\n    int y = (int) g.size();\n    if(x+y + m > n){\n    \tcout << 0 << endl;\n    \treturn 0;\n    }\n    dp[0][0] = 1;\n    for(int i = 0; i < 3000; i++){\n    \tfor(int j = 0; j <= i; j++){\n    \t\tif(j > 0) add(dp[i+1][j-1], dp[i][j]);\n    \t\tadd(dp[i+1][j+1], dp[i][j]);\n    \t}\n    }\n    int tt = n - m;\n    int ans = 0;\n    for(int len = 0; len <= tt; len++){\n    \tint t = tt - len;\n    \tfor(int j = x; j <= len && j - x + y <= t; j++){\n    \t\tadd(ans, dp[len][j] * 1ll * dp[t][j - x + y] % mod);\n    \t}\n    }\n    cout << ans << endl;\n    \n    \n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    #endif\n    return 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["dp", "strings"], "dificulty": "2000", "interactive": false}