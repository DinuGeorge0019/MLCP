{"link": "https://codeforces.com//contest/1219/problem/G", "problemId": "412348", "problem_idx": "G", "shortId": "1219G", "contest_number": "1219", "problem_submissions": {"I": [60646525], "G": [60642032], "C": [60637618], "D": [60636167], "A": [], "B": [], "E": [], "F": []}, "name": "G. Harvester", "statement": "It is Bubble Cup finals season and farmer Johnny Bubbles must harvest\r\nhis bubbles. The bubbles are in a rectangular bubblefield formed of N x\r\nM square parcels divided into N rows and M columns. The parcel in i^{th}\r\nrow and j^{th} column yields A_{i,j} bubbles.Johnny Bubbles has\r\navailable a very special self-driving bubble harvester that, once\r\nmanually positioned at the beginning of a row or column, automatically\r\nharvests all the bubbles in that row or column. Once the harvester\r\nreaches the end of the row or column it stops and must be repositioned.\r\nThe harvester can pass through any parcel any number of times, but it\r\ncan collect bubbles from the parcel only once.Johnny is very busy\r\nfarmer, so he is available to manually position the harvester at most\r\nfour times per day. Johnny is also impatient, so he wants to harvest as\r\nmany bubbles as possible on the first day.Please help Johnny to\r\ncalculate what is the maximum number of bubbles he can collect on the\r\nfirst day.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MIN = -1;\npair<ll,ll> getTwo(vector<ll> arr){\n    ll first, second; \n    first = second = MIN; \n    for (int i = 0; i < arr.size() ; i ++) \n    { \n        /* If current element is greater than first*/\n        if (arr[i] > first) \n        { \n            second = first; \n            first = arr[i]; \n        } \n   \n        /* If arr[i] is in between first and second then update second  */\n        else if (arr[i] > second) \n        { \n            second = arr[i]; \n        } \n    } \n    assert(first!=MIN);\n    assert(second!=MIN);\n    return {first, second};\n}\n// program it such that N < M\nint N,M;\nvector< vector<ll> > fields, tmp_fields;\nvector<ll> row_sum, col_sum;\nint main(void){\n    cin >> N >> M;\n    ll sum = 0;\n    for(int i=0;i<N;i++){\n        vector<ll> tmp;\n        for(int j=0;j<M;j++){\n            ll x;\n            cin >> x;\n            sum += x;\n            tmp.push_back(x);\n        }\n        tmp_fields.push_back(tmp);\n    }\n\n    // Finish all the read in\n    // If trivial case happens\n    // output the sum\n    if(N<=4 || M<=4){\n        cout << sum << endl;\n        return 0;\n    }\n\n    // transpose if N > M\n    if(N>=M){\n        for(int i=0;i<M;i++){\n            vector<ll> tmp;\n            for(int j=0;j<N;j++){\n                ll x = tmp_fields[j][i];\n                tmp.push_back(x);\n            }\n            fields.push_back(tmp);\n        }\n        ll tmp = N;\n        N = M;\n        M = tmp;\n    }else{\n        fields = tmp_fields;\n    }\n    // TODO: Verify transpose\n\n    // Compute row sum and col sum\n    row_sum.resize(N);\n    for(int i=0;i<N;i++){\n        row_sum[i] = 0;\n    }\n    col_sum.resize(M);\n    for(int i=0;i<M;i++){\n        col_sum[i] = 0;\n    }\n    for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++){\n            row_sum[i] += fields[i][j];\n            col_sum[j] += fields[i][j];\n        }\n    }\n\n    // Write the toughest case\n    ll ans = 0;\n    for(int i=0;i<N;i++){\n        vector<ll> cand(M);\n        for(int j=0;j<M;j++){\n            cand[j] = col_sum[j] - fields[i][j];\n        }\n        for(int k=i+1;k<N;k++){\n            vector<ll> cand_(M);\n            for(int j=0;j<M;j++){\n                cand_[j] = cand[j] - fields[k][j];\n            }\n            pair<ll,ll> res = getTwo(cand_);\n            ans = max(ans, res.first + res.second + row_sum[i] + row_sum[k]);\n        }\n    }\n\n    // Write the 1-3 and 3-1 case\n    for(int i=0;i<N;i++){\n        // choose an arbitrary row\n        vector<ll> cand(M);\n        for(int j=0;j<M;j++){\n            cand[j] = col_sum[j] - fields[i][j];\n        }\n        sort(cand.begin(), cand.end());\n        ll three_sum = 0;\n        for(int j=M-1;j>=M-3;j--){\n            three_sum += cand[j];\n        }   \n        ans = max(ans, row_sum[i] + three_sum);\n    }\n    for(int j=0;j<M;j++){\n        // choose an arbitrary row\n        vector<ll> cand(N);\n        for(int i=0;i<N;i++){\n            cand[i] = row_sum[i] - fields[i][j];\n        }\n        sort(cand.begin(), cand.end());\n        ll three_sum = 0;\n        for(int i=N-1;i>=N-3;i--){\n            three_sum += cand[i];\n        }   \n        ans = max(ans, col_sum[j] + three_sum);\n    }\n    // Write the trivial case\n    sort(row_sum.begin(), row_sum.end());\n    ll four_sum = 0;\n    for(int i=N-1;i>=N-4;i--){\n        four_sum += row_sum[i];\n    }\n    ans = max(ans, four_sum);\n    sort(col_sum.begin(), col_sum.end());\n    four_sum = 0;\n    for(int j=M-1;j>=M-4;j--){\n        four_sum += col_sum[j];\n    }\n    ans = max(ans, four_sum);\n    cout << ans << endl;\n}"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "2000", "interactive": false}