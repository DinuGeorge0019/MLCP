{
    "link": "https://codeforces.com//contest/1659/problem/D",
    "problemId": "1371414",
    "problem_idx": "D",
    "shortId": "1659D",
    "contest_number": "1659",
    "problem_submissions": {
        "E": [
            153913573,
            153929614,
            153928927,
            153922832,
            153919141,
            153972138,
            153926923,
            153927092,
            153929319,
            153932903,
            153930192,
            153930364,
            153930632,
            153931626,
            153929090,
            153932497,
            153927674,
            153932539,
            153931108,
            153930225
        ],
        "D": [
            153912412,
            153905719,
            153910339,
            153913081,
            153925687,
            153914747,
            153914843,
            153917030,
            153914214,
            153914225,
            153916202,
            153914923,
            153911260,
            153911942,
            153919382,
            153913809,
            153916530,
            153910597,
            153914778,
            153923066
        ],
        "B": [
            153899189,
            153895163,
            153894044,
            153901045,
            153896660,
            153905534,
            153895509,
            153894100,
            153894393,
            153894053,
            153896780,
            153900091,
            153895296,
            153893292,
            153896323,
            153897272,
            153895755,
            153896012,
            153922971,
            153892638
        ],
        "C": [
            153893804,
            153899081,
            153898923,
            153904670,
            153899860,
            153895491,
            153906966,
            153902317,
            153904388,
            153898598,
            153905688,
            153905657,
            153901854,
            153898683,
            153904460,
            153903103,
            153900333,
            153901824,
            153895900,
            153899518
        ],
        "A": [
            153892134,
            153890875,
            153890881,
            153898852,
            153891639,
            153899777,
            153891702,
            153891302,
            153890852,
            153890890,
            153891590,
            153893681,
            153891282,
            153890712,
            153890944,
            153892901,
            153890725,
            153890838,
            153891604,
            153890839
        ],
        "F": [
            153937865
        ]
    },
    "name": "D. Reverse Sort Sum",
    "statement": "Suppose you had an array A of n elements, each of which is 0 or 1.Let us\r\ndefine a function f(k,A) which returns another array B, the result of\r\nsorting the first k elements of A in non-decreasing order. For example,\r\nf(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0]. Note that the first 4 elements\r\nwere sorted.Now consider the arrays B_1, B_2,\r\nldots, B_n generated by f(1,A), f(2,A),\r\nldots,f(n,A). Let C be the array obtained by taking the element-wise sum\r\nof B_1, B_2,\r\nldots, B_n.For example, let A=[0,1,0,1]. Then we have B_1=[0,1,0,1],\r\nB_2=[0,1,0,1], B_3=[0,0,1,1], B_4=[0,0,1,1]. Then\r\nC=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4].You\r\nare given C. Determine a binary array A that would give C when processed\r\nas above. It is guaranteed that an array A exists for given C in the\r\ninput.\r\n",
    "solutions": [
        "#include<iostream>\nusing namespace std;\nint a[200010];\nbool ans[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t}\n\t\tint p=0;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tif(p<i) {\n\t\t\t\tif(a[i]==0) {\n\t\t\t\t\tans[i]=0,p=i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[i]=1,p=i;\n\t\t\t}\n\t\t\tif(ans[i]) {\n\t\t\t\ta[i]-=i-1;\n\t\t\t}\n\t\t\ta[i]-=p-i+1;\n\t\t\twhile(a[i]--) {\n\t\t\t\tans[++p]=1;\n\t\t\t}\n\t\t\tif(p<n) {\n\t\t\t\tans[++p]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcout<<ans[i]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation",
        "math",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Reverse Sort Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/100938",
    "editorial": "The first thing to notice is that any in the initial array , will\r\ncontribute to the sum of elements of array exactly times. That means, if\r\n, must be divisible by .Let be the number of s in the initial array .\r\nThe s in form a suffix of it.Weâll process the array from right to\r\nleft.Assume was . Then, it is clear that . Then, we can place a there.\r\nNow assume was . Then, it is clear that if there were any s in (in other\r\nwords, if ), then . Otherwise . If this is the case, we can place a\r\nthere and move on. Finally, we must subtract from each of the last\r\nelements provided . Decrement if a was placed. In essence, we simulated\r\nremoving from the elementwise sum.Once weâve processed , we can forget\r\nabout it and continue solving the problem assuming there are elements,\r\nand so on.The last thing is to handle subtracting from the last\r\nelements. It is possible to do it using a segment tree/BIT, but that is\r\noverkill for this problem. A simpler way is to maintain a left border\r\nfor the suffix, and keep track of when the border crosses an element\r\n(say ) and when we reach it. Then we can get a simple formula for the\r\nvalue of the element that looks something like .Time complexity: or\r\n",
    "hint": [
        "Hint 1 Is there any way to tell how many s were in ?",
        "Hint 2 Can you tell what was by looking at just ?",
        "Hint 3 Try to simulate removing each starting from ."
    ]
}