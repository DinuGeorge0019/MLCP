{
    "link": "https://codeforces.com//contest/980/problem/C",
    "problemId": "181716",
    "problem_idx": "C",
    "shortId": "980C",
    "contest_number": "980",
    "problem_submissions": {
        "E": [
            38038539,
            38045785,
            38060701,
            38046614,
            38041883,
            38044896,
            38156095,
            38156078,
            38156061,
            38156040,
            38072066,
            38047353,
            38038047,
            38043388,
            38111608,
            38111590,
            38045284,
            38042270,
            38038266,
            38035504,
            38040125,
            38049313,
            38049169,
            38042734,
            38048647,
            38040602,
            38042070,
            38043155
        ],
        "D": [
            38033907,
            38032813,
            38038724,
            38038674,
            38041057,
            38038837,
            38034371,
            38046473,
            38049113,
            38037846,
            38051369,
            38051240,
            38044218,
            38039452,
            38054307,
            38079043,
            38079024,
            38043863,
            38813838
        ],
        "C": [
            38031306,
            38038468,
            38034397,
            38032152,
            38033603,
            38033400,
            38059857,
            38035211,
            38035303,
            38033154,
            38031809,
            38032840,
            38031754,
            38036211,
            38036608,
            38032601,
            38035163,
            38031869,
            38035397,
            38029282
        ],
        "B": [
            38028530,
            38048301,
            38030919,
            38029470,
            38030897,
            38030105,
            38029818,
            38031146,
            38060661,
            38028845,
            38030045,
            38037463,
            38028546,
            38038973,
            38029430,
            38050585,
            38032687,
            38031932
        ],
        "A": [
            38024341,
            38025152,
            38027637,
            38026879,
            38024463,
            38025009,
            38024567,
            38024355,
            38024220,
            38024988,
            38024959,
            38024227,
            38024460,
            38024685,
            38024924,
            38024456,
            38024718,
            38025274,
            38024545
        ],
        "F": [
            138375213
        ]
    },
    "name": "C. Posterized",
    "statement": "Professor Ibrahim has prepared the final homework for his algorithm s\r\nclass. He asked his students to implement the Posterization Image\r\nFilter.Their algorithm will be tested on an array of integers, where the\r\ni-th integer represents the color of the i-th pixel in the image. The\r\nimage is in black and white, therefore the color of each pixel will be\r\nan integer between 0 and 255 (inclusive).To implement the filter,\r\nstudents are required to divide the black and white color range [0, 255]\r\ninto groups of consecutive colors, and select one color in each group to\r\nbe the group s key. In order to preserve image details, the size of a\r\ngroup must not be greater than k, and each color should belong to\r\nexactly one group.Finally, the students will replace the color of each\r\npixel in the array with that color s assigned group key.To better\r\nunderstand the effect, here is an image of a basking turtle where the\r\nPosterization Filter was applied with increasing k to the right. To make\r\nthe process of checking the final answer easier, Professor Ibrahim wants\r\nstudents to divide the groups and assign the keys in a way that produces\r\nthe lexicographically smallest possible array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e5 + 5;\nint n, k;\nint a[maxn];\nint f[maxn];\n\nvoid phongthan() {\n    cin >> n >> k;\n    FOR(i, 0, n) cin >> a[i];\n    fill_n(f, 256, -1);\n    FOR(i, 0, n) {\n        if (f[a[i]] == -1) {\n            int x = a[i];\n            FORd(ii, x, max(0, x - k + 1)) {\n                if (f[ii] != -1 && (!ii || f[ii] != f[ii - 1])) {\n                    FOR(j, ii + 1, x + 1) f[j] = f[ii];\n                    break;\n                }\n            }\n            if (f[a[i]] == -1) {\n                FOR(ii, max(0, x - k + 1), x + 1) if (f[ii] == -1) {\n                    FOR(j, ii, x + 1) f[j] = ii;\n                    break;\n                }\n            }\n        }\n        cout << f[a[i]] << \" \\n\"[i == n - 1];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    phongthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Posterized.json",
    "editorial_link": "https://codeforces.com//blog/entry/59350",
    "editorial": "First, it\u00e2\u0080\u0099s obvious that for each group we should choose the color with\r\nminimum value as the group\u00e2\u0080\u0099s key. Now since we want to find the\r\nlexicographically smallest array, we iterate from the leftmost number in\r\nthe array and minimize it as much as possible without considering the\r\nnumbers to its right.There are many ways to implement this, one of them\r\nis the following:Iterate from left to right, for each number , if it is\r\nalready assigned to a group then ignore it. Otherwise, check the colors\r\nless than in decreasing order until you find a color that is assigned.If\r\nwe can extend the group of to include and the size won\u00e2\u0080\u0099t be exceeding ,\r\nthen we do extend it and assign all the colors between and to the key of\r\n\u00e2\u0080\u0099s group. If the size will exceed or such was not found (set it to in\r\nthis case), we create a new group with key equals to and assign all\r\ncolors in the range to it.The complexity of this solution is , where is\r\nthe size of the color range.\r\n"
}