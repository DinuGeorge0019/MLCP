{
    "link": "https://codeforces.com//contest/1605/problem/D",
    "problemId": "1182997",
    "problem_idx": "D",
    "shortId": "1605D",
    "contest_number": "1605",
    "problem_submissions": {
        "E": [
            135140556,
            135137170,
            135140149,
            135131162,
            135139425,
            135135884,
            135145750,
            135134170,
            135146319,
            135151738,
            135143897,
            135157772,
            135157112,
            135164572,
            135156916,
            135165811,
            135157373,
            135164912,
            135160322,
            135160455
        ],
        "D": [
            135123258,
            135121299,
            135126903,
            135118749,
            135131018,
            135121443,
            135128070,
            135130028,
            135134932,
            135133895,
            135133786,
            135133991,
            135133461,
            135131214,
            135138932,
            135135042,
            135138476,
            135132029,
            135132400,
            135148563
        ],
        "C": [
            135109471,
            135112911,
            135114732,
            135134429,
            135118955,
            135116544,
            135116248,
            135117340,
            135108363,
            135118939,
            135119487,
            135116822,
            135120064,
            135117077,
            135120474,
            135119518,
            135124633,
            135117200,
            135123222,
            135116741
        ],
        "B": [
            135104011,
            135105341,
            135106044,
            135104987,
            135108524,
            135104124,
            135112684,
            135116832,
            135113729,
            135109962,
            135123178,
            135110129,
            135109123,
            135109984,
            135111099,
            135109709,
            135119558,
            135106232,
            135120020,
            135107502
        ],
        "A": [
            135103035,
            135103047,
            135103241,
            135103076,
            135103421,
            135106303,
            135106513,
            135110580,
            135103745,
            135103393,
            135105600,
            135103522,
            135103862,
            135104535,
            135103487,
            135103484,
            135106186,
            135103066,
            135106006,
            135103429
        ]
    },
    "name": "D. Treelabeling",
    "statement": "Eikooc and Sushi play a game.The game is played on a tree having n nodes\r\nnumbered 1 to n. Recall that a tree having n nodes is an undirected,\r\nconnected graph with n-1 edges.They take turns alternately moving a\r\ntoken on the tree. on any node of her choice. Sushi makes the next move,\r\nfollowed by Eikooc, followed by Sushi, and so on. In each turn after the\r\nfirst, a player must move the token to a node u such that u is adjacent\r\nto the node v the token is currently on u has not been visited before u\r\noplus v\r\nleq min(u, v) Here x\r\noplus y denotes the bitwise XOR operation on integers x and y.Both the\r\nplayers play optimally. The player who is unable to make a move\r\nloses.The following are examples which demonstrate the rules of the\r\ngame. Before the game begins, Eikooc decides to sneakily relabel the\r\nnodes of the tree in her favour. Formally, a relabeling is a permutation\r\np of length n (sequence of n integers wherein each integer from 1 to n\r\noccurs exactly once) where p_i denotes the new numbering of node i.She\r\nwants to maximize the number of nodes she can choose in the first turn\r\nwhich will guarantee her a win. Help Eikooc find any relabeling which\r\nwill help her do so.\r\n",
    "solutions": [
        "// Problem: D. Treelabeling\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\nusing namespace std;\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nvector<int> e[200003];\nint p1[200003],p2[200003];\nint v1[200003],v2[200003];\nint a[200003];\nint dep[200003];\nint fa[2000003];\nint tmp[103],ts,sdt[103];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tint c1=0,c2=0;\n\t\tfor(int i=1; i<=n; ++i) e[i].clear();\n\t\tfor(int i=1; i<n; ++i)\n\t\t{\n\t\t\tint x=read(),y=read();\n\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push(1);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();q.pop();\n\t\t\tdep[x]=dep[fa[x]]+1;\n\t\t\tif(dep[x]&1) p1[++c1]=x; else p2[++c2]=x;\n\t\t\tfor(int y:e[x]) if(y!=fa[x])\n\t\t\t\tfa[y]=x,q.push(y);\n\t\t}\n\t\tint M=n;\n\t\tts=0;\n\t\tfor(int i=1,ss=1; M; ss+=i,i<<=1) if(i<M) \n\t\t\tM-=i,tmp[++ts]=i,sdt[ts]=ss;\n\t\telse tmp[++ts]=M,sdt[ts]=ss,M=0;\n\t\tint cur=c1;\n\t\tfor(int i=ts; i>=1; --i) if(cur>=tmp[i])\n\t\t{\n\t\t\tfor(int q=1,qq=sdt[i]; q<=tmp[i]; ++q,++qq)\n\t\t\t\ta[p1[c1]]=qq,--c1;\n\t\t\tcur-=tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int q=1,qq=sdt[i]; q<=tmp[i]; ++q,++qq)\n\t\t\t\ta[p2[c2]]=qq,--c2;\n\t\t}\n\t\tassert(c1==0),assert(c2==0);\n\t\tfor(int i=1; i<=n; ++i) printf(\"%d \",a[i]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "games",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Treelabeling.json",
    "editorial_link": "https://codeforces.com//blog/entry/96866",
    "editorial": "If the most significant bits (MSBs) of two integers and are the same,\r\nsay , then the -th bit will be unset in . Since will have this bit set,\r\nit will be greater than . Thus, if then .If a node in the tree is\r\nadjacent only to nodes whose MSB differs from its MSB, then the player\r\nwho plays this node will win.It turns out that not only is it always\r\npossible to make it such that no two nodes sharing an edge have the same\r\nMSB, it is also necessary to do so in order to maximize the number of\r\nwinnning starting nodes for Eikooc. Consequently, starting at any node\r\nwill guarantee a win for her. Assume there exists at least two nodes in\r\nthe tree that are adjacent to each other, having the same MSB. We prove\r\nthat there will be at least one losing node for Eikooc to start on,\r\nwhich is suboptimal. Consider a connected component of nodes in the tree\r\nof size at least two, all having the same MSB. Since this connected\r\ncomponent also forms a tree, it must have at least one leaf node. Any\r\nnode in the component which is adjacent to at least one of these leaf\r\nnodes will be losing for Eikooc (since Sushi can just move the token to\r\na leaf node and Eikooc will have no moves to play). We aim to relabel\r\nthe nodes of the tree in such a way that for every node in the tree and\r\nall nodes adjacent to it, . Think bipartite. In the bipartite colouring\r\nof a tree, no two adjacent nodes have the same colour. If we are able to\r\nrelabel the nodes in such a way that all nodes with the same MSB belong\r\nto the same colour, we are done. : There are occurrences of integers\r\nfrom to with the -th bit as MSB (0-indexed) for each from to , and all\r\nsuch groups of integers are disjoint (since each integer has exactly one\r\nMSB). Let the number of white and black nodes be and respectively and\r\nWLOG let (we can swap the colours otherwise). Since all nodes are\r\ncoloured either white or black, . Under these constraints, it is then\r\neasy to show that . Consequently, . Since , can possibly only have those\r\nbits set which lie in the range . Can you connect the dots? Consider the\r\nbinary representation of . We can assign all integers from to having the\r\n-th bit as MSB to a white node if the -th bit is set in , and assign all\r\nthe remaining integers to black nodes. In doing so, no two nodes having\r\nthe same MSB will belong to different colours. This ensures that no such\r\npair is adjacent. This is also guaranteed to always be possible since\r\nthe binary representation of only spans the first bits and we also have\r\naccess to groups of sizes comprising all powers of two upto .:\r\n"
}