{
    "link": "https://codeforces.com//contest/1453/problem/E",
    "problemId": "821026",
    "problem_idx": "E",
    "shortId": "1453E",
    "contest_number": "1453",
    "problem_submissions": {
        "E": [
            100380052,
            155118161,
            100374406,
            100382833,
            100376358,
            100380373,
            100377845,
            100376439,
            100372651,
            100372508,
            100374319,
            100375311,
            100361396,
            100374016,
            100375798,
            100374877,
            100376885,
            100376092,
            100374918,
            100369776
        ],
        "D": [
            100375780,
            155118139,
            100367299,
            100371256,
            100369898,
            100372322,
            100371648,
            100366312,
            100368463,
            100366176,
            100366391,
            100373742,
            100368086,
            100364639,
            100371848,
            100367162,
            100368628,
            100369799,
            100372351
        ],
        "C": [
            100370717,
            155118105,
            100363680,
            100365192,
            100365975,
            100366748,
            100365481,
            100362777,
            100362628,
            100362653,
            100362794,
            100366264,
            100365011,
            100362269,
            100364059,
            100363843,
            100363639,
            100365174,
            100365522,
            100366070
        ],
        "F": [
            100365572,
            155118244,
            100384810,
            100377057,
            100384158,
            100383537,
            100385977,
            100390112,
            100382350,
            100381472,
            100408619,
            100428520
        ],
        "B": [
            100359448,
            155118064,
            100359921,
            100359636,
            100358954,
            100362716,
            100359915,
            100357443,
            100358086,
            100356217,
            100356739,
            100370528,
            100358105,
            100356427,
            100359186,
            100359063,
            100373277,
            100358271,
            100360209,
            100363310
        ],
        "A": [
            100352068,
            155118022,
            100354202,
            100352085,
            100350847,
            100354848,
            100351796,
            100357299,
            100351053,
            100350650,
            100351488,
            100367409,
            100350533,
            100350757,
            100350887,
            100350551,
            100351187,
            100351697,
            100352074,
            100358933
        ]
    },
    "name": "E. Dog Snacks",
    "statement": "Gildong is playing with his dog, Badugi. They\u2019re at a park that has n\r\nintersections and n-1 bidirectional roads, each 1 meter in length and\r\nconnecting two intersections with each other. The intersections are\r\nnumbered from 1 to n, and for every a and b (1\r\nle a, b\r\nle n), it is possible to get to the b-th intersection from the a-th\r\nintersection using some set of roads.Gildong has put one snack at every\r\nintersection of the park. Now Gildong will give Badugi a mission to eat\r\nall of the snacks. Badugi starts at the 1-st intersection, and he will\r\nmove by the following rules: Badugi looks for snacks that are as close\r\nto him as possible. Here, the distance is the length of the shortest\r\npath from Badugi\u2019s current location to the intersection with the snack.\r\nHowever, Badugi\u2019s sense of smell is limited to k meters, so he can only\r\nfind snacks that are less than or equal to k meters away from himself.\r\nIf he cannot find any such snack, he fails the mission. Among all the\r\nsnacks that Badugi can smell from his current location, he chooses a\r\nsnack that minimizes the distance he needs to travel from his current\r\nintersection. If there are multiple such snacks, Badugi will choose one\r\narbitrarily. He repeats this process until he eats all n snacks. After\r\nthat, he has to find the 1-st intersection again which also must be less\r\nthan or equal to k meters away from the last snack he just ate. If he\r\nmanages to find it, he completes the mission. Otherwise, he fails the\r\nmission. Unfortunately, Gildong doesn\u2019t know the value of k. So, he\r\nwants you to find the minimum value of k that makes it possible for\r\nBadugi to complete his mission, if Badugi moves optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nconst int N=200005;\nint n,flag,dp[N],deg[N];\nvector<int>E[N];\ninline void add(int x,int y){\n\tE[x].PB(y),E[y].PB(x);\n\tdeg[x]++,deg[y]++;\n}\ninline void getDP(int x,int f,int dis){\n\tif(x!=1&&deg[x]==1){\n\t\tdp[x]=0;\n\t\treturn ;\n\t}\n\tvector<int>temp;\n\tRep(y,E[x]){\n\t\tif(y==f)continue;\n\t\tgetDP(y,x,dis);\n\t\ttemp.PB(dp[y]);\n\t}\n\tsort(temp.begin(),temp.end());\n\tint size=temp.size();\n\tif(temp[size-1]>=dis){\n\t\tflag=0;\n\t}\n\telse if(temp[size-1]==dis-1){\n\t\tif(size>=2&&temp[size-2]==dis-1)flag=0;\n\t\telse dp[x]=dis;\n\t}\n\telse dp[x]=temp[0]+1;\n}\nint _;\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\",\"r\",stdin);\n        freopen(\"out.txt\",\"w\",stdout);\n    #endif\n    read(_);\n    while(_--){\n    \tread(n);\n    \tF(i,1,n)E[i].clear(),deg[i]=0;\n    \tint tu,tv;\n    \tF(i,1,n-1){\n    \t\tread(tu),read(tv),add(tu,tv);\n    \t\t//cout<<tu<<' '<<tv<<endl;\n\t\t}\n    \tint L=1,R=n;\n    \twhile(L<R){\n    \t\tflag=1;\n    \t\tint mid=(L+R)>>1;\n    \t\tgetDP(1,0,mid);\n    \t\tif(flag&&dp[1]<=mid)R=mid;\n    \t\telse L=mid+1;\n\t\t}\n\t\tcout<<L<<'\\n';\n\t}\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Dog Snacks.json",
    "editorial_link": "https://codeforces.com//blog/entry/85288",
    "editorial": "It is obvious that the problem can be modeled as a tree rooted at the\r\n-st vertex. Given a large enough , we can see that Badugi will always\r\n\u00e2\u0080\u0099clear out\u00e2\u0080\u0099 each subtree and then move back to its parent. This is\r\nbecause if there exists an unvisited child for a vertex, the distance\r\nbetween them is , while any unvisited vertex at the parent\u00e2\u0080\u0099s side has\r\ndistance of at least . Therefore, Badugi\u00e2\u0080\u0099s moves will look like a\r\npreorder tree traversal.This implies another fact. Let\u00e2\u0080\u0099s say the -th\r\nvertex is a child of the -th vertex. After visiting the last vertex of a\r\nsubtree rooted at the -th vertex, Badugi has to move a longer distance\r\nwhen it was the last child of the -th vertex than when the -th vertex\r\nhas another unvisited child. The only important rule for Badugi is to\r\nchoose the child that has the shortest \u00e2\u0080\u0099moving back\u00e2\u0080\u0099 distance as the\r\nlast child he will visit. This distance can be sent back to its parent\r\nso that the parent can choose between the candidates. Let\u00e2\u0080\u0099s say the\r\nminimum among the candidates is , and the maximum is . It is optimal to\r\nuse as the \u00e2\u0080\u0099moving back\u00e2\u0080\u0099 distance, and the maximum of the\r\n\u00e2\u0080\u0099child-to-child\u00e2\u0080\u0099 distances will be .There is one exception for this\r\nstrategy the root. Unlike the others, there is no need to move any\r\nfurther after visiting all vertices and then getting back to the root.\r\nThis means choosing as the \u00e2\u0080\u0099moving back\u00e2\u0080\u0099 distance is optimal, because we\r\ndon\u00e2\u0080\u0099t need to add anything to it. Then we can use the sub-maximum of the\r\ncandidates as the maximum of \u00e2\u0080\u0099child-to-child\u00e2\u0080\u0099 distances.Along these\r\nprocesses we can update the answer whenever we find the maximum of\r\n\u00e2\u0080\u0099child-to-child\u00e2\u0080\u0099 distances, along with the last move back to the\r\nroot.Time complexity: for each test case, but it\u00e2\u0080\u0099s too boring to find\r\nthe sub-maximum in linear time, so just sort the candidates and it will\r\nbe for each test case.\r\n"
}