{"link": "https://codeforces.com//contest/1903/problem/D1", "problemId": "2355505", "problem_idx": "D1", "shortId": "1903D1", "contest_number": "1903", "problem_submissions": {"D2": [235128331, 235435764, 235183865, 235116126, 235121557, 235122165, 236143935, 235115553, 235129873, 235119268], "F": [235111543, 235102179, 235105725, 235099949, 235124718, 235126382, 235187626, 235129442, 235218441, 235126934, 235133564, 235146171, 235141771, 235179210], "E": [235106076, 235104135, 235115833, 235114935, 235102473, 235112204, 235107850, 235103854, 235111843, 235109842, 235115868, 235124408, 235114753, 235126753, 235108387, 235107433, 235107971, 235105219, 235108510, 235108333], "D1": [235093312, 235109270, 235095674, 235117999, 235091603, 235099696, 235100348, 235094032, 235098578, 235098148, 235119995, 235115692, 235105537, 235119353, 235094232, 235095613, 235096813, 235097844, 235096074, 235099176], "C": [235088892, 235089084, 235089891, 235103743, 235087836, 235093791, 235088528, 235088785, 235092085, 235091882, 235086000, 235089517, 235099201, 235093455, 235087482, 235090537, 235090823, 235091561, 235089639, 235091936], "B": [235086528, 235084790, 235086716, 235102627, 235086465, 235090208, 235086073, 235088901, 235087776, 235087683, 235089557, 235084538, 235096155, 235090241, 235085240, 235087001, 235086944, 235087486, 235086654, 235088684], "A": [235083574, 235084421, 235082280, 235100671, 235083954, 235085469, 235082350, 235089029, 235082379, 235083014, 235084518, 235090802, 235083842, 235083352, 235082144, 235082627, 235082396, 235082150, 235082134, 235082717]}, "name": "D1. Maximum And Queries  easy version ", "statement": "Theofanis really likes to play with the bits of numbers. He has an array\r\na of size n and an integer k. He can make at most k operations in the\r\narray. In each operation, he picks a single element and increases it by\r\n1.He found the bitwise AND that array a can have after at most k\r\noperations.Theofanis has put a lot of work into finding this value and\r\nwas very happy with his result. Unfortunately, Ada , being the evil\r\nperson that he is, decided to bully him by repeatedly changing the value\r\nof k.Help Theofanis by calculating the possible bitwise AND for q\r\ndifferent values of k. Note that queries are independent.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll solve(vector <ll> a, ll k) {\n    int n = a.size();\n    ll ans = 0;\n    for (int bit = 61; ~bit; --bit) {\n        ll sum = 0;\n        vector <ll> add(n);\n        for (int i = 0; i < n; ++i) if (~a[i] >> bit & 1) {\n            add[i] = (1ll << bit) - (a[i] & ((1ll << bit) - 1));\n            sum += add[i];\n            if (sum >= k + 1) {\n                sum = k + 1;\n            }\n        }\n        if (sum <= k) {\n            k -= sum;\n            for (int i = 0; i < n; ++i) {\n                a[i] += add[i];\n            }\n            ans |= 1ll << bit;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector <ll> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    while (q--) {\n        ll k; cin >> k;\n        cout << solve(a, k) << '\\n';\n    }\n}"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "brute force", "greedy"], "dificulty": "1700", "interactive": false}