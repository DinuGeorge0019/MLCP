{
    "link": "https://codeforces.com//contest/1131/problem/D",
    "problemId": "302311",
    "problem_idx": "D",
    "shortId": "1131D",
    "contest_number": "1131",
    "problem_submissions": {
        "G": [
            50392574,
            50483553,
            50483191,
            50597351
        ],
        "E": [
            50370230,
            50377398,
            50376874,
            50374805,
            50370023,
            50374639,
            50376085,
            50370141,
            59337133,
            50372624,
            50376988,
            50380444,
            51393637,
            50379092,
            50379324,
            50375235,
            50378370,
            50376960,
            50378218,
            50375618,
            50380739,
            50377794
        ],
        "D": [
            50363533,
            50363627,
            50365255,
            50374692,
            50360365,
            50367830,
            50371553,
            50364690,
            59336364,
            50377671,
            50371391,
            50369645,
            51393629,
            50371580,
            50368694,
            50364122,
            50370641,
            50367474,
            50370633,
            50364697,
            50370324,
            50391827,
            50367431
        ],
        "F": [
            50359710,
            50366576,
            50362359,
            50363609,
            50372028,
            50364108,
            54391189,
            54391158,
            54391141,
            50775614,
            50775596,
            50775586,
            50775566,
            50775556,
            50366322,
            50374409,
            59338739,
            50364318,
            50366547,
            50364869,
            51393655,
            50365763,
            50362358,
            50366172,
            50366229,
            50370184,
            50365915,
            50363686,
            50365490,
            50370524
        ],
        "C": [
            50357039,
            50359567,
            50360582,
            50355123,
            50364439,
            50361693,
            50361183,
            50360745,
            50361372,
            50363542,
            50360374,
            50363293,
            50355730,
            50368491,
            50363309,
            50362385,
            50362421,
            50365348,
            50362731,
            50360623
        ],
        "B": [
            50355578,
            50356862,
            50357573,
            50357717,
            50364015,
            50361039,
            50356264,
            50358549,
            50359269,
            50359561,
            50357291,
            50358021,
            50372318,
            50359218,
            50357829,
            50359757,
            50364553,
            50364635,
            50358492,
            50357639
        ],
        "A": [
            50354897,
            50355112,
            50355078,
            50360224,
            50354946,
            50354851,
            50362936,
            50355762,
            50355563,
            50355186,
            50355036,
            50355259,
            50369979,
            50355032,
            50355231,
            50355565,
            50355478,
            50359515,
            50355346,
            50355260
        ]
    },
    "name": "D. Gourmet choice",
    "statement": "Mr. Apple, a gourmet, works as editor-in-chief of a gastronomic\r\nperiodical. He travels around the world, tasting new delights of famous\r\nchefs from the most fashionable restaurants. Mr. Apple has his own\r\nsignature method of review in each restaurant Mr. Apple orders two sets\r\nof dishes on two different days. All the dishes are different, because\r\nMr. Apple doesn’t like to eat the same food. For each pair of dishes\r\nfrom different days he remembers exactly which was better, or that they\r\nwere of the same quality. After this the gourmet evaluates each dish\r\nwith a positive integer.Once, during a revision of a restaurant of\r\nCeltic medieval cuisine named Poisson , that serves chestnut soup with\r\nfir, warm soda bread, spicy lemon pie and other folk food, Mr. Apple was\r\nvery pleasantly surprised the gourmet with its variety of menu, and\r\nhence ordered too much. Now he’s confused about evaluating dishes.The\r\ngourmet tasted a set of n dishes on the first day and a set of m dishes\r\non the second day. He made a table a of size n\r\ntimes m, in which he described his impressions. If, according to the\r\nexpert, dish i from the first set was better than dish j from the second\r\nset, then a_{ij} is equal to \"\", in the opposite case a_{ij} is equal to\r\n\"\". Dishes also may be equally good, in this case a_{ij} is \"\".Now Mr.\r\nApple wants you to help him to evaluate every dish. Since Mr. Apple is\r\nvery strict, he will evaluate the dishes so that the maximal number used\r\nis as small as possible. But Mr. Apple also is very fair, so he never\r\nevaluates the dishes so that it goes against his feelings. In other\r\nwords, if a_{ij} is \"\", then the number assigned to dish i from the\r\nfirst set should be less than the number of dish j from the second set,\r\nif a_{ij} is \"\", then it should be greater, and finally if a_{ij} is \"\",\r\nthen the numbers should be the same.Help Mr. Apple to evaluate each dish\r\nfrom both sets so that it is consistent with his feelings, or determine\r\nthat this is impossible.\r\n",
    "solutions": [
        "/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,\"r\",stdin);\n#define fpo(x) freopen(x,\"w\",stdout);\n#define fprio fpi(\"in.txt\");fpo(\"out.txt\");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==' ');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes(\"\");}\ninline void writei(int x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<\"No\";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nint n,m,i,j,deg[2005],a[2005][2005],g[2005][2005],ans[2005],fa[2005],cnt;\nchar c;\nint fnd(int x){if (fa[x]==x)return x;return fa[x]=fnd(fa[x]);}\nset<int> s;\nvoid dfs(int x)\n{\n\tcnt++;deg[x]=-1;\n\tint i;rep(i,n+m) if (g[x][i]==1)\n\t{\n\t\tdeg[i]--;\n\t\tans[i]=max(ans[i],ans[x]+1);\n\t\tif (deg[i]==0) dfs(i);\n\t}\n}\nint main()\n{\n\tread(n);read(m);\n\trep(i,n+m) fa[i]=i;\n\trep(i,n)\n\t{\n\t\tscanf(\" \");\n\t\tforup(j,n+1,n+m)\n\t\t{\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif (c=='=')\n\t\t\t{\n\t\t\t\tfa[fnd(i)]=fnd(j);\n\t\t\t}\n\t\t\tif (c=='<')\n\t\t\t{\n\t\t\t\ta[i][j]=1;\n\t\t\t\ta[j][i]=-1;\n\t\t\t}\n\t\t\tif (c=='>')\n\t\t\t{\n\t\t\t\ta[i][j]=-1;\n\t\t\t\ta[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n+m) s.in(fnd(i));\n\trep(i,n+m) rep(j,n+m)\n\t{\n\t\tif (a[i][j]==1)\n\t\t{\n\t\t\tif (fnd(i)==fnd(j))\n\t\t\t{\n\t\t\t\tNO\n\t\t\t}\n\t\t\tif (g[fnd(i)][fnd(j)]==-1)\n\t\t\t{\n\t\t\t\tNO\n\t\t\t}\n\t\t\tg[fnd(i)][fnd(j)]=1;\n\t\t\tg[fnd(j)][fnd(i)]=-1;\n\t\t}\n\t\tif (a[i][j]==-1)\n\t\t{\n\t\t\tif (fnd(i)==fnd(j))\n\t\t\t{\n\t\t\t\tNO\n\t\t\t}\n\t\t\tif (g[fnd(i)][fnd(j)]==1)\n\t\t\t{\n\t\t\t\tNO\n\t\t\t}\n\t\t\tg[fnd(i)][fnd(j)]=-1;\n\t\t\tg[fnd(j)][fnd(i)]=1;\n\t\t}\n\t}\n\trep(i,n+m) if (fnd(i)==i) rep(j,n+m) if (fnd(j)==j)\n\t{\n\t\tif (g[i][j]==1)\n\t\t{\n\t\t\tdeg[j]++;\n\t\t}\n\t}\n\trep(i,n+m) if (fnd(i)==i) if (deg[i]==0) {ans[i]=1;dfs(i);}\n\tif (cnt!=s.size()) NO\n\tputs(\"Yes\");\n\trep(i,n) printf(\"%d \",ans[fnd(i)]);puts(\"\");\n\trep(i,m) printf(\"%d \",ans[fnd(n+i)]);puts(\"\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Gourmet choice.json",
    "editorial_link": "https://codeforces.com//blog/entry/65487",
    "editorial": "This task has different possible solutions.One of them is as follows\r\nmake a DSU for all dishes (Disjoint Set Union data structure,\r\nhttps://en.wikipedia.org/wiki/Disjoint-set_data_structure), and unite\r\nall dishes that should be evaluated with the same number according to\r\nthe table (unite dishes and if equals \"\".Then create graph. We will\r\niterate over all , and add a directed edge in some direction between the\r\nsets, corresponding to the and , if one of them is better, then the\r\nother.In case the graph has a self-loop or cycle, itâs easy to see that\r\nthe answer is impossible. Otherwise assign numbers, where the vertex\r\ngets the least number greater than the vertex it goes to. This is the\r\nanswer.\r\n",
    "hint": []
}