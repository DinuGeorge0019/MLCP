{
    "link": "https://codeforces.com//contest/2022/problem/A",
    "problemId": "2947274",
    "problem_idx": "A",
    "shortId": "2022A",
    "contest_number": "2022",
    "problem_submissions": {
        "D1": [
            285726010,
            285732443,
            285720467,
            285721725,
            285710598,
            285716496,
            285709185,
            285722223,
            285721840,
            285726265,
            285729782,
            285729870,
            285772115,
            285771713,
            285716249,
            285713460,
            285712248,
            285718533,
            285715843
        ],
        "E2": [
            285719910,
            285720748,
            285735574,
            285735176,
            288055359,
            286524378,
            285733091,
            285771493,
            285770412,
            285770170,
            285769301
        ],
        "E1": [
            285717777,
            285720862,
            285735538,
            285732412,
            285730131,
            285734694,
            285730466,
            285740393,
            285736961,
            285737293,
            285738689,
            285733822,
            285723809
        ],
        "C": [
            285713470,
            285709435,
            285713964,
            285712717,
            285726534,
            285712313,
            285728850,
            285716262,
            285717872,
            285721376,
            285719625,
            285718527,
            285713136,
            285713916,
            285709969,
            285709168,
            285707306,
            285710892,
            285710354
        ],
        "B": [
            285703660,
            285702595,
            285706421,
            285702197,
            285705976,
            285703966,
            285719780,
            285706485,
            285711437,
            285705925,
            285707565,
            285707987,
            285708651,
            285708053,
            285702275,
            285704156,
            285708490,
            285702360,
            285704264
        ],
        "A": [
            285702679,
            285701420,
            285703196,
            285701332,
            285704286,
            285701973,
            285705578,
            285709500,
            285703987,
            285704902,
            285704417,
            285704940,
            285701496,
            285701330,
            285702274,
            285701454,
            285701489,
            285702531
        ],
        "D2": [
            286191597,
            285736183,
            290850953,
            285816124
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135095",
    "editorial": "Step 1The key to maximizing happiness is to seat family members together\r\nas much as possible. If two members of the same family sit in the same\r\nrow, both will be happy, and we only use two seats. However, if they are\r\nseated separately, only one person is happy, but two seats are still\r\nused. Therefore, we prioritize seating family pairs together first.\r\n",
    "name": "A. Bus to Pénjamo",
    "statement": "Ya vamos llegando a P eeenjamoo There are n families travelling to P\r\nnjamo to witness Mexico’s largest-ever \"walking a chicken on a leash\"\r\nmarathon. The i-th family has a_i family members. All families will\r\ntravel using a single bus consisting of r rows with 2 seats each.A\r\nperson is considered if: Another family member is seated in the same row\r\nas them, or They are sitting alone in their row (with an empty seat next\r\nto them). Determine the maximum number of happy people in an optimal\r\nseating arrangement. Note that must be seated in the bus.It is\r\nguaranteed that all family members will fit on the bus. Formally, it is\r\nguaranteed that\r\ndisplaystyle\r\nsum_{i=1}^{n}a_i\r\nle 2r.\r\n",
    "solutions": [
        "#line 1 \"library/Template/template.hpp\"#include <bits/stdc++.h>using namespace std; #define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin()) using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff; template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));} template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << \"P(\" << p.first << \", \" << p.second << \")\";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << \"{\";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");    }    os << \"}\";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << \"{\";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << \"(\" << itr->first << \", \" << itr->second << \")\";        itr++;        if (itr != map_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << \"{\";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << '\\n';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != ',' && a[i] != '\\0'; i++)        cerr << a[i];    cerr << \":\" << b << \" \";    _show(i + 1, a, c...);}#line 2 \"library/Utility/fastio.hpp\"#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf uint32_t pil = 0, pir = 0, por = 0; struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | '0';                n /= 10;            }        }    }} constexpr pre; inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = '\\n';} inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;} void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));} void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));} template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);} template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < '-');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == '-') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while ('0' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }} void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);} template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);} template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);} void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);} void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);} template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = '-', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | '0';        obuf[por + 1] = (x - q * 10) | '0';        por += 2;    } else        obuf[por++] = x | '0';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;} template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);} void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);} template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(' ');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(' ');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }} void print() {    wt('\\n');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(' ');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio using fastio::flush;using fastio::print;using fastio::read; inline void first(bool i = true) {    print(i ? \"first\" : \"second\");}inline void Alice(bool i = true) {    print(i ? \"Alice\" : \"Bob\");}inline void Takahashi(bool i = true) {    print(i ? \"Takahashi\" : \"Aoki\");}inline void yes(bool i = true) {    print(i ? \"yes\" : \"no\");}inline void Yes(bool i = true) {    print(i ? \"Yes\" : \"No\");}inline void No() {    print(\"No\");}inline void YES(bool i = true) {    print(i ? \"YES\" : \"NO\");}inline void NO() {    print(\"NO\");}inline void Yay(bool i = true) {    print(i ? \"Yay!\" : \":(\");}inline void Possible(bool i = true) {    print(i ? \"Possible\" : \"Impossible\");}inline void POSSIBLE(bool i = true) {    print(i ? \"POSSIBLE\" : \"IMPOSSIBLE\");} /** * @brief Fast IO */#line 3 \"sol.cpp\" void solve(int _rot) {    // write(\"Case #\"+to_string(_rot)+\": \");    int n, R;    read(n, R);    vector<int> a(n);    read(a);     int ret = 0, emp = R, odd = 0;    rep(i, 0, n) {        ret += (a[i] / 2) * 2;        if (a[i] & 1)            odd++;        emp -= a[i] / 2;    }    if (odd <= emp)        ret += odd;    else        ret += emp * 2 - odd;    print(ret);} int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Bus to Pénjamo.json",
    "hint": []
}