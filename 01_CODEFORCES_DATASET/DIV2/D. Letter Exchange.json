{
    "link": "https://codeforces.com//contest/1786/problem/D",
    "problemId": "1767294",
    "problem_idx": "D",
    "shortId": "1786D",
    "contest_number": "1786",
    "problem_submissions": {
        "E": [
            192342570,
            192306394,
            192404273,
            192327524,
            192339032,
            192311189,
            192325805,
            192320065,
            192441626,
            192343977,
            192328171,
            192315469,
            192316636,
            192338226,
            192342670,
            192339784,
            192342778
        ],
        "D": [
            192320379,
            192313768,
            192307277,
            192318549,
            192309409,
            192292999,
            192316314,
            192320950,
            192332305,
            192309612,
            192327595,
            192325214,
            192325223,
            192311769,
            192310059,
            192313834,
            192316588,
            192327743
        ],
        "F": [
            192310858,
            192336618,
            192349130,
            192348404,
            192333052,
            192339600,
            192329659,
            192334176,
            192328243,
            192307751,
            192340487,
            192363526,
            192345318
        ],
        "C": [
            192293366,
            192290648,
            192294881,
            192293245,
            192293510,
            192290179,
            192292716,
            192294689,
            192305954,
            192310133,
            192289535,
            192298071,
            192296223,
            192302623,
            192296901,
            192292106,
            192294116,
            192300798,
            192295593,
            192301556
        ],
        "B": [
            192288687,
            192344141,
            192291360,
            192289646,
            192340206,
            192287135,
            192290672,
            192302280,
            192292700,
            192296847,
            192294213,
            192293367,
            192300808,
            192292539,
            192288767,
            192289750,
            192293496,
            192292722,
            192296815
        ],
        "A2": [
            192287082,
            192284625,
            192286145,
            192285724,
            192290142,
            192283788,
            192286284,
            192297549,
            192284597,
            192306985,
            192286345,
            192288530,
            192296607,
            192287030,
            192284519,
            192284365,
            192288011,
            192288312,
            192289376
        ],
        "A1": [
            192287049,
            192283178,
            192286410,
            192283361,
            192283338,
            192284177,
            192283764,
            192296237,
            192283279,
            192307201,
            192286846,
            192283729,
            192297100,
            192283762,
            192283137,
            192282950,
            192288217,
            192285269,
            192287405
        ]
    },
    "name": "D. Letter Exchange",
    "statement": "A cooperative game is played by m people. In the game, there are 3m\r\nsheets of paper: m sheets with letter ”, m sheets with letter ”, and m\r\nsheets with letter ”.Initially, each person is given three sheets\r\n(possibly with equal letters).The goal of the game is to allow each of\r\nthe m people to spell the word \"\" using their sheets of paper. In other\r\nwords, everyone should have one sheet with letter ”, one sheet with\r\nletter ”, and one sheet with letter ”.To achieve the goal, people can\r\nmake . Two people participate in each exchange. Both of them choose\r\nexactly one sheet of paper from the three sheets they own and exchange\r\nit with each other.Find the shortest sequence of exchanges after which\r\neveryone has one ”, one ”, and one ”.\r\n",
    "solutions": [
        "// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\n#pragma GCC optimize(2, 3, \"Ofast\")\n\ndef(N, int, 1e5 + 5)\n\nstruct Node {\n\tint i, j;\n\tchar c1, c2;\n};\n\nint n, m;\nchar to[] = {'w', 'i', 'n'};\nint c[N][3];\nset<int> s[3][3];\nvector<Node> ans;\n\nvoid solve() {\n\tcin >> n; ans.clear();\n\trep(i, 1, n) {\n\t\tc[i][0] = c[i][1] = c[i][2] = 0;\n\t\trep(j, 1, 3) {\n\t\t\tchar ch; cin >> ch;\n\t\t\tif(ch == 'w') ++c[i][0];\n\t\t\telse if(ch == 'i') ++c[i][1];\n\t\t\telse ++c[i][2];\n\t\t}\n\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i][j] > 1 && !c[i][k]) s[j][k].insert(i);\n\t}\n\twhile(1) {\n\t\t// rep(i, 1, n) cout << c[i][0] << ' ' << c[i][1] << ' ' << c[i][2] << '\\n';\n\t\t// cout << '\\n';\n\t\trep(j, 0, 2) rep(k, 0, 2) {\n\t\t\tif(s[j][k].size() && s[k][j].size()) {\n\t\t\t\tint i1 = *s[j][k].begin(), i2 = *s[k][j].begin();\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i1][j] > 1 && !c[i1][k]) s[j][k].erase(i1);\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i2][j] > 1 && !c[i2][k]) s[j][k].erase(i2);\n\t\t\t\t--c[i1][j], ++c[i1][k];\n\t\t\t\t++c[i2][j], --c[i2][k];\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i1][j] > 1 && !c[i1][k]) s[j][k].insert(i1);\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i2][j] > 1 && !c[i2][k]) s[j][k].insert(i2);\n\t\t\t\t// cout << i1 << ' ' << to[j] << ' ' << i2 << ' ' << to[k] << '\\n';\n\t\t\t\tans.pb({i1, i2, to[j], to[k]});\n\t\t\t\tgoto End;\n\t\t\t}\n\t\t}\n\t\trep(j, 0, 2) rep(k, 0, 2) if(s[j][k].size()) {\n\t\t\trep(l, 0, 2) if(s[k][l].size()) {\n\t\t\t\tint i1 = *s[k][l].begin(), i2 = *s[j][k].begin();\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i1][j] > 1 && !c[i1][k]) s[j][k].erase(i1);\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i2][j] > 1 && !c[i2][k]) s[j][k].erase(i2);\n\t\t\t\t--c[i1][k], ++c[i1][j];\n\t\t\t\t++c[i2][k], --c[i2][j];\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i1][j] > 1 && !c[i1][k]) s[j][k].insert(i1);\n\t\t\t\trep(j, 0, 2) rep(k, 0, 2) if(c[i2][j] > 1 && !c[i2][k]) s[j][k].insert(i2);\n\t\t\t\tans.pb({i1, i2, to[k], to[j]});\n\t\t\t\t// cout << i1 << ' ' << to[k] << ' ' << i2 << ' ' << to[j] << '\\n';\n\t\t\t\tgoto End;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tEnd:;\n\t}\n\tcout << ans.size() << '\\n';\n\tfor(Node x : ans) cout << x.i << ' ' << x.c1 << ' ' << x.j << ' ' << x.c2 << '\\n';\n\t\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Letter Exchange.json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "For each person, there are three essential cases of what they could initially have:\n\nThree distinct letters: \"win\". No need to take part in any exchanges.\nTwo equal letters and another letter, e.g. \"wii\". An extra 'i' must be exchanged with someone's 'n'.\nThree equal letters, e.g. \"www\". One 'w' must be exchanged with someone's 'i', another 'w' must be exchanged with someone's 'n'.\nLet's create a graph on three vertices: 'w', 'i', 'n'. Whenever person i\n has an extra letter x\n and is lacking letter y\n, create a directed edge x?y\n marked with i\n.\n\nOnce the graph is built, whenever you have a cycle of length 2\n, that is, x?iy?jx\n, it means person i\n needs to exchange x\n for y\n, while person j\n needs to exchange y\n for x\n. Thus, both of their needs can be satisfied with just one exchange.\n\nFinally, once there are no cycles of length 2\n, note that the in-degree and the out-degree of every vertex are equal. If e.g. there are p\n edges 'w' ?\n 'i', it follows that there are p\n edges 'i' ?\n 'n' and p\n edges 'n' ?\n 'w'. It means we can form p\n cycles of length 3\n. (The cycles could also go in the opposite direction: 'w' ?\n 'n' ?\n 'i' ?\n 'w'.) In any case, each cycle of length 3\n can be solved using 2\n exchanges.",
    "hint": []
}