{
    "link": "https://codeforces.com//contest/327/problem/D",
    "problemId": "3286",
    "problem_idx": "D",
    "shortId": "327D",
    "contest_number": "327",
    "problem_submissions": {
        "E": [
            4017313,
            4017507,
            4018772,
            4017910,
            4019268,
            4023331,
            4015900,
            4017838,
            4016759,
            4027441,
            4022024,
            4019276
        ],
        "C": [
            4014970,
            4014797,
            4014725,
            4014945,
            4015808,
            4013334,
            4014670,
            4013527,
            4014594,
            4014368,
            4014192,
            4014033,
            4014334,
            4014505,
            4015890,
            4015156,
            4015704
        ],
        "D": [
            4014693,
            4016265,
            4015556,
            4017918,
            4018611,
            4017193,
            4015911,
            4016489,
            4016642,
            4016033,
            4016317,
            4016734,
            4016607,
            4017683,
            4017510
        ],
        "A": [
            4012718,
            4011428,
            4014213,
            4012212,
            4011845,
            4011264,
            4011546,
            4011299,
            4011577,
            4011527,
            4011323,
            4011508,
            4011858,
            4011904,
            4011582,
            4012111,
            4011772
        ],
        "B": [
            4011621,
            4012593,
            4012805,
            4012674,
            4012463,
            4011873,
            4012480,
            4011682,
            4012186,
            4012474,
            4011938,
            4011986,
            4012535,
            4012626,
            4012279,
            4012988,
            4012431
        ]
    },
    "name": "D. Block Tower",
    "statement": "After too much playing on paper, Iahub has switched to computer games.\r\nThe game he plays is called \"Block Towers\". It is played in a\r\nrectangular grid with rows and columns (it contains cells). The goal of\r\nthe game is to build your own city. Some cells in the grid are big\r\nholes, where Iahub can’t build any building. The rest of cells are\r\nempty. In some empty cell Iahub can build exactly one tower of two\r\nfollowing types: Blue towers. Each has population limit equal to . Red\r\ntowers. Each has population limit equal to . However, it can be built in\r\nsome cell only if in that moment at least one of the neighbouring cells\r\nhas a Blue Tower. Two cells are neighbours is they share a side. Iahub\r\nis also allowed to destroy a building from any cell. He can do this\r\noperation as much as he wants. After destroying a building, the other\r\nbuildings are not influenced, and the destroyed cell becomes empty (so\r\nIahub can build a tower in this cell if needed, see the second example\r\nfor such a case).Iahub can convince as many population as he wants to\r\ncome into his city. So he needs to configure his city to allow maximum\r\npopulation possible. Therefore he should find a sequence of operations\r\nthat builds the city in an optimal way, so that total population limit\r\nis as large as possible.He says he’s the best at this game, but he\r\ndoesn’t have the optimal solution. Write a program that calculates the\r\noptimal one, to show him that he’s not as good as he thinks.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for (int i=1;i<=n;i++)\nconst int u[]={0,1,0,-1,0},v[]={0,0,1,0,-1},N=505;\nchar s[N][N]; int n,m,len,f[N*N],g[N*N]; bool b[N][N];\nvoid bfs(int x,int y,int flag)\n{\n\tint h=0,t=1; f[1]=x,g[1]=y; b[x][y]=1;\n\twhile (h<t){\n\t\tx=f[++h],y=g[h];\n\t\trep(i,4){\n\t\t\tint x1=x+u[i],y1=y+v[i];\n\t\t\tif (x1 && x1<=n && y1 && y1<=m && s[x1][y1]=='.' && !b[x1][y1])\n\t\t\t\tb[x1][y1]=1,f[++t]=x1,g[t]=y1; \n\t\t\t}\n\t\t}\n\tif (flag) len+=t*3-2;\n\telse {\n\trep(i,t) printf(\"B %d %d\\n\",f[i],g[i]);\n\tfor (int i=t;i>1;i--) printf(\"D %d %d\\n\",f[i],g[i]),printf(\"R %d %d\\n\",f[i],g[i]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) scanf(\"%s\",s[i]+1);\n\trep(i,n) rep(j,m) if (s[i][j]=='.' && !b[i][j]) bfs(i,j,1);\n\tmemset(b,0,sizeof(b)); printf(\"%d\\n\",len);\n\trep(i,n) rep(j,m) if (s[i][j]=='.' && !b[i][j]) bfs(i,j,0);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Block Tower.json",
    "editorial_link": "https://codeforces.com//blog/entry/8274",
    "editorial": "In case you want to try some examples on your own, you may play this\r\ngame, which is the origin of this problem:\r\nhttp://en.wikipedia.org/wiki/Tower_Bloxx Now back to the analysis :) The\r\nrestriction given in the problem poses you to think of building as many\r\nRed Towers as possible, and fill the rest with Blue Towers (since there\r\nis no profit of letting cells empty, such cells can be filled by Blue\r\nTowers). Also, itâs quite obvious to see that each connected component\r\n(containing empty cells only) is independent from each other, so we\r\nshall iterate the component one by one. Denote the current component be\r\nS. Lemma 1 is impossible to build S so that it contains all Red Towers\r\nonly. Proof Suppose there exists such a way. Look up the last cell that\r\nis built (denote by x). Clearly x is a Red Tower, so at the moment it is\r\nbuilt, x must be adjacent to a cell than contains a Blue Tower. However,\r\nitâs obvious that thereâs no such cell (if there is, it must belong to\r\nS, which is impossible). As itâs impossible to have all Red Towers, itâs\r\nnatural to look up at the next best solution: the one with exactly one\r\nBlue Tower, and among them, we need to find the least lexicographic\r\nsolution. Fortunately, we can prove that such a configuration is always\r\npossible. Such proof is quite tricky, indeed: Lemma 2 Pick any cell b in\r\nS. It is possible to build a configuration that has all but b be Red\r\nTowers, and b is a Blue Tower. Proof Construct a graph whose vertices\r\ncorrespond to the cells of S, and the edges correspond to cells that are\r\nadjacent. Since S is connected, it is possible to build a tree that\r\nspans to all vertices of S. Pick b as the root and do the following: How\r\ncan it be the valid solution? Take any vertex u which is about to be\r\nrebuilt. Clearly u is not b, and u has its parent to be blue, so the\r\ncondition for rebuilding can be met. When the building is completed,\r\nonly b remains intact, while others have been transformed into Red\r\nTowers. So we get the following algorithm: do a BFS / DFS search to find\r\nconnected components. Then, apply Lemma 2 to build a valid\r\nconfiguration.\r\n",
    "hint": []
}