{
    "link": "https://codeforces.com//contest/604/problem/C",
    "problemId": "42007",
    "problem_idx": "C",
    "shortId": "604C",
    "contest_number": "604",
    "problem_submissions": {
        "D": [
            14596500,
            14593346,
            14595214,
            14597164,
            14594625,
            14591286,
            14596851,
            14596627,
            14597744,
            14595935,
            14605132,
            14596012,
            14596656,
            14597363,
            14604366
        ],
        "E": [
            14595112,
            14597709,
            14599612,
            14601657,
            14601583,
            14602620,
            14601006,
            14598712,
            14611507,
            14600405,
            14603271,
            14606898,
            14598106
        ],
        "C": [
            14591727,
            14591485,
            14590401,
            14591803,
            14590167,
            14598812,
            14590931,
            14593957,
            14594227,
            14592838,
            14592345,
            14591994,
            14604053,
            14594007,
            14591853,
            14592988
        ],
        "B": [
            14589366,
            14588467,
            14587631,
            14589936,
            14596744,
            23519332,
            14588532,
            14589419,
            14589534,
            14587511,
            14588487,
            14588973,
            14588129,
            14588264,
            14589189
        ],
        "A": [
            14587013,
            14586403,
            14586260,
            14587679,
            14595485,
            14586765,
            14586177,
            14586973,
            14586715,
            14586347,
            14586267,
            14586259,
            14587001,
            14586457,
            14586288,
            14586867
        ]
    },
    "name": "C. Alternative Thinking",
    "statement": "Kevin has just recevied his disappointing results on the USA\r\nIdentification of Cows Olympiad (USAICO) in the form of a binary string\r\nof length . Each character of Kevin’s string represents Kevin’s score on\r\none of the questions of the olympiad for a correctly identified cow and\r\notherwise.However, all is not lost. Kevin is a big proponent of\r\nalternative thinking and believes that his score, instead of being the\r\nsum of his points, should be the length of the longest alternating\r\nsubsequence of his string. Here, we define an of a string as a\r\nsubsequence where no two consecutive elements are equal. For example, ,\r\n, and are alternating sequences, while and are not.Kevin, being the\r\nsneaky little puffball that he is, is willing to hack into the USAICO\r\ndatabases to improve his score. In order to be subtle, he decides that\r\nhe will flip exactly one substring that is, take a non-empty substring\r\nof his score and change all s in that substring to s and vice versa.\r\nAfter such an operation, Kevin wants to know the length of the longest\r\npossible alternating subsequence that his string could have.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, dp[100009][2][3], A[100009];\nchar sir[100009];\n\nint main()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\\n\", &N);\ngets (sir + 1);\nfor (int i=1; i<=N; i++)\n    A[i] = sir[i] - '0';\n///A[i][j][k] = din primele i, lungimea maxima a unui subsir alternant care se temrina in valoarea j, k fiind stadiul(0 inseamna ca n-am facut niciun swap,\n///1 reprezinta ca sunt in interiorul secventei swapuite, 2 ca am facut deja odata swap\nfor (int i=1; i<=N; i++)\n    for (int j=0; j<=1; j++)\n    {\n        dp[i][j][0] = dp[i - 1][j][0];\n        if (j == A[i]) dp[i][j][0] = max (dp[i][j][0], dp[i - 1][j ^ 1][0] + 1);\n        dp[i][j][2] = max (dp[i - 1][j][2], dp[i - 1][j][1]);\n        if (j == A[i]) dp[i][j][2] = max (dp[i][j][2], max (dp[i - 1][j ^ 1][2], dp[i - 1][j ^ 1][1]) + 1);\n        dp[i][j][1] = max (dp[i - 1][j][1], dp[i - 1][j][0]);\n        if ((j ^ 1) == A[i]) dp[i][j][1] = max (dp[i][j][1], max (dp[i - 1][j ^ 1][0], dp[i - 1][j ^ 1][1]) + 1);\n    }\nint ans = 0;\nfor (int j=0; j<=1; j++)\n    for (int k=0; k<3; k++)\n        if (dp[N][j][k] > ans) ans = dp[N][j][k];\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Alternative Thinking.json",
    "editorial_link": "https://codeforces.com//blog/entry/21885",
    "editorial": "Hint: Is there any easy way to describe the longest alternating subsequence of a string? What happens at the endpoints of the substring that we flip?\n\nImagine compressing each contiguous block of the same character into a single character. For example, the first sample case 10000011 gets mapped to 101. Then the longest alternating subsequence of our string is equal to the length of our compressed string. So what does flipping a substring do to our compressed string? To answer this, we can think about flipping a substring as flipping two (possibly empty) prefixes. As an example, consider the string 10000011. Flipping the bolded substring 100 00 011 is equivalent to flipping the two bolded prefixes 10000011 and 10000.\n\nFor the most part, flipping the prefix of a string also flips the corresponding portion of the compressed string. The interesting case occurs at the endpoint of the prefix. Here, we have two possibilities: the two characters on either side of the endpoint are the same or different. If they are the same (00 or 11), then flipping this prefix adds an extra character into our compressed string. If they are different (01 or 10), we merge two characters in our compressed string. These increase and decrease, respectively, the length of the longest alternating subsequence by one. There is actually one more case that we left out: when the endpoint of our prefix is also an endpoint of the string. Then it is easy to check that the length of the longest alternating subsequence doesn't change.\n\nWith these observations, we see that we want to flip prefixes that end between 00 or 11 substrings. Each such substring allows us to increase our result by one, up to a maximum of two, since we only have two flips. If there exist no such substrings that we can flip, we can always flip the entire string and have our result stay the same. Thus our answer is the length of the initial longest alternating subsequence plus .\n\nA very easy way to even simplify the above is to notice that if the initial longest alternating subsequence has length len?-?2, then there will definitely be two 00 or 11 substrings. If it has length n?-?1, then it has exactly one 00 or 11 substring. So our answer can be seen as the even easier .",
    "hint": []
}