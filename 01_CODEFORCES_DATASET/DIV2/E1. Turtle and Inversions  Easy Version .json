{
    "link": "https://codeforces.com//contest/2003/problem/E1",
    "problemId": "2836630",
    "problem_idx": "E1",
    "shortId": "2003E1",
    "contest_number": "2003",
    "problem_submissions": {
        "E2": [
            278341707,
            278455104,
            278330622,
            278179988,
            278257072,
            278360261,
            278589270
        ],
        "E1": [
            278142159,
            278142843,
            278147621,
            278145820,
            278139445,
            278118163,
            278284773,
            278152908,
            278522597
        ],
        "D2": [
            278115632,
            278124223,
            278116119,
            278123063,
            278131280,
            278090274,
            278184104,
            278101954,
            278115622,
            278113440,
            278105822,
            278109507,
            278111408,
            278106372,
            278109910,
            278114958,
            278113518,
            278109092
        ],
        "D1": [
            278092613,
            278095057,
            278099358,
            278106267,
            278123018,
            278076086,
            278136646,
            278080662,
            278086676,
            278089029,
            278091347,
            278090118,
            278085289,
            278096196,
            278091226,
            278088309,
            278092415,
            278094460
        ],
        "C": [
            278073298,
            278084142,
            278084204,
            278091216,
            278102032,
            278059873,
            278062388,
            278064696,
            278066407,
            278065300,
            278076163,
            278064469,
            278071045,
            278077312,
            278070267,
            278068388,
            278071776,
            278071322
        ],
        "B": [
            278057061,
            278062158,
            278060356,
            278059818,
            278072173,
            278051522,
            278051239,
            278054673,
            278056246,
            278057857,
            278063310,
            278056133,
            278051957,
            278062245,
            278058767,
            278054937,
            278067356,
            278063368
        ],
        "A": [
            278051014,
            278054951,
            278054980,
            278049465,
            278052299,
            278047930,
            278047962,
            278049334,
            278049908,
            278052979,
            278052705,
            278049194,
            278048004,
            278057248,
            278049244,
            278048425,
            278067001,
            278049077
        ],
        "F": [
            283415067,
            278185607,
            278644931
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/132953",
    "editorial": "Divide all numbers into two types: small numbers () and large numbers\r\n(), such that any small number is less than any large number. In this\r\nway, a permutation can be transformed into a sequence.A permutation is\r\ninteresting if and only if there exists a way to divide all numbers into\r\ntwo types such that, for every given interval , all s appear before all\r\ns, and there is at least one and one in the interval. Such a sequence is\r\ncalled interesting.If an interesting sequence is fixed, we can greedily\r\narrange all s in descending order and all s in descending order. Let the\r\nnumber of s be and the number of s be . Let be the number of index pairs\r\n, where the -th number is and the -th number is (such pairs are called\r\npairs). Then, the maximum number of inversions is .In this version, the\r\nintervals are non-overlapping, so DP can be applied directly. Let\r\nrepresent the maximum number of pairs when considering all numbers from\r\nto , where there are s. For transitions, if is the left endpoint of an\r\ninterval and the right endpoint of this interval is , we can enumerate\r\nthe number of s as and the number of s as for the transition. Otherwise,\r\nwe consider whether is or .The answer is .Time complexity: per test\r\ncase.\r\n",
    "name": "E1. Turtle and Inversions  Easy Version ",
    "statement": "Turtle gives you m intervals [l_1, r_1], [l_2, r_2],\r\nldots, [l_m, r_m]. He thinks that a permutation p is interesting if\r\nthere exists an integer k_i for every interval (l_i\r\nle k_i < r_i), and if he lets a_i =\r\nmax\r\nlimits_{j = l_i}^{k_i} p_j, b_i =\r\nmin\r\nlimits_{j = k_i + 1}^{r_i} p_j for every integer i from 1 to m, the\r\nfollowing condition holds:\r\nmax\r\nlimits_{i = 1}^m a_i <\r\nmin\r\nlimits_{i = 1}^m b_iTurtle wants you to calculate the maximum number of\r\ninversions of all interesting permutations of length n, or tell him if\r\nthere is no interesting permutation.An inversion of a permutation p is a\r\npair of integers (i, j) (1\r\nle i < j\r\nle n) such that p_i > p_j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0#define ranges std::ranges#define views std::views\u00a0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\u00a0using pii = std::pair<int, int>;using a3 = std::array<int, 3>;using a4 = std::array<int, 4>;\u00a0const int N = 1e6;const int MAXN = 1e6 + 10;const int inf = 1e9;// const int mod = 1e9 + 7;const int mod = 998244353;\u00a0template<typename T>struct Fenwick {    int n;    std::vector<T> a;\u00a0    Fenwick(int n_ = 0) {        init(n_);    }\u00a0    void init(int n_) {        n = n_;        a.assign(n + 5, T{});    }\u00a0    void add(int x, const T& v) {        for (int i = x; i <= n; i += i & -i) {            a[i] = a[i] + v;        }    }\u00a0    T sum(int x) {        T ans{};        for (int i = x; i > 0; i -= i & -i) {            ans = ans + a[i];        }        return ans;    }\u00a0    T rangeSum(int l, int r) {        return sum(r) - sum(l);    }\u00a0    int select(const T& k) {        int x = 0;        T cur{};        for (int i = 1 << std::__lg(n); i; i /= 2) {            if (x + i <= n && cur + a[x + i] <= k) {                x += i;                cur = cur + a[x];            }        }        return x;    }};\u00a0void solve() {    int n, m;std::cin >> n >> m;    std::vector<pii> info(m);    for (auto& [l, r] : info)std::cin >> l >> r;    std::vector<int> big, small;//, other;    ranges::sort(info);    int cur = 1;    int leg = 0;    for (auto& [l, r] : info) {        while (cur < l) {            // other.push_back(cur);            if (leg >= m - leg) {                small.push_back(cur);            }            else {                big.push_back(cur);            }            cur++;        }        big.push_back(r);        small.push_back(l);        if (leg >= m - leg) {            for (int i = l + 1;i <= r - 1;++i) {                small.push_back(i);            }        }        else {            for (int i = l + 1;i <= r - 1;++i) {                big.push_back(i);            }        }        cur = r + 1;        leg++;    }    while (cur <= n) {        // other.push_back(cur);        if (leg >= m - leg) {            small.push_back(cur);        }        else {            big.push_back(cur);        }        cur++;    }    std::vector<int> ans(n + 1);    int max = n;    // ranges::sort(other);    ranges::sort(big);    ranges::sort(small);    // for (auto y : other)ans[y] = max, max--;    for (auto y : big)ans[y] = max, max--;    for (auto y : small)ans[y] = max, max--;    Fenwick<int> fw(n);    i64 ot = 0;    for (int i = 1;i <= n;++i) {        ot += i - 1 - fw.sum(ans[i]);        fw.add(ans[i], 1);    }    std::cout << ot << '\\n';    // for (int i = 1;i <= n;++i)    //     std::cout << ans[i] << \" \";}\u00a0signed main() {    std::ios::sync_with_stdio(false);    std::cin.tie(0), std::cout.tie(0);    int t;std::cin >> t;    while (t--) {        solve();    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "divide and conquer",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Turtle and Inversions  Easy Version .json"
}