{"link": "https://codeforces.com//contest/1944/problem/D", "problemId": "2535052", "problem_idx": "D", "shortId": "1944D", "contest_number": "1944", "problem_submissions": {"E": [251782515, 251752198, 251760134, 251765767, 251780123, 251755818, 251785307, 251786773, 251774041, 251782215, 251788365, 251768261, 251786805, 251786877], "D": [251774395, 251745809, 251734994, 251735975, 251741617, 251753993, 251816452, 251754858, 251782010, 251751610, 251760683, 251760131, 251771429, 251757991, 251756622, 251757761, 251764901, 251792696, 251771886, 251771626], "F2": [251750838, 251716813, 251789175, 252177387], "F1": [251747784, 251709303, 251789140, 251765369, 252064569, 251778632, 251783727, 251776370, 252190323, 251778029, 251787478], "C": [251727192, 251748340, 251720353, 251717607, 251744834, 251719448, 251721344, 251728728, 251723190, 251722648, 251720271, 251715992, 251711499, 251727997, 251722342, 251754221, 251727857, 251727380, 251734830, 251734204], "B": [251714769, 251743002, 251717270, 251713265, 251751112, 251715501, 251712246, 251715265, 251717723, 251714892, 251714867, 251712443, 251720698, 251717033, 251737965, 251714389, 251717278, 251719138, 251727691, 251724161], "A": [251705704, 251744128, 251703581, 251703048, 251747005, 251704719, 251705040, 251701932, 251706171, 251701886, 251705757, 251701530, 251704051, 251712020, 251711838, 251705512, 251702145, 251704041, 251711450, 251703284]}, "name": "D. Non-Palindromic Substring", "statement": "A string t is said to be k-good if there exists at least one substring^\r\ndagger of length k which is not a palindrome^\r\nddagger. Let f(t) denote the sum of all values of k such that the string\r\nt is k-good.You are given a string s of length n. You will have to\r\nanswer q of the following queries: Given l and r (l < r), find the value\r\nof f(s_ls_{l + 1}\r\nldots s_r). ^\r\ndagger A substring of a string z is a contiguous segment of characters\r\nfrom z. For example, \"\r\nmathtt{defor}\", \"\r\nmathtt{code}\" and \"\r\nmathtt{o}\" are all substrings of \"\r\nmathtt{codeforces}\" while \"\r\nmathtt{codes}\" and \"\r\nmathtt{aaa}\" are not.^\r\nddagger A palindrome is a string that reads the same backwards as\r\nforwards. For example, the strings \"\r\ntexttt{z}\", \"\r\ntexttt{aa}\" and \"\r\ntexttt{tacocat}\" are palindromes while \"\r\ntexttt{codeforces}\" and \"\r\ntexttt{ab}\" are not.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl '\\n'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nconst int N=4e5+10;\nint n,m;\nchar a[N];\nint f[N],g[N],d[N];\nll s1[N],s2[N];\nvoid manacher(int n) {\n\tint l=0,r=-1;\n\tFor(i,1,n) {\n\t\tint &k=d[i];\n\t\tk=i>r?1:min(d[l+r-i],r-i+1);\n\t\twhile(a[i-k]==a[i+k])k++;\n\t\tif(i+k-1>r)r=i+k-1,l=i-k+1;\n\t}\n}\nbool chk(int l,int r) {\n\tif((r-l+1)&1) {\n\t\treturn f[l+r>>1]*2+1>=r-l+1;\n\t} else {\n\t\treturn g[l+r>>1]*2>=r-l+1;\n\t}\n}\nll que(int l,int r,int k) {\n\treturn 1ll*(l+r)*((r-l)/k+1)/2;\n}\nvoid work() {\n\tcin>>n>>m;\n\tFor(i,1,n<<1|1) f[i]=g[i]=d[i]=a[i]=0;\n\tFor(i,1,n) {\n\t\tchar x; cin>>x; a[i<<1]=x;\n\t}\n\ta[1]=114; a[n<<1|1]=514; manacher(n<<1|1);\n\tFor(i,1,n) f[i]=d[i<<1]-1>>1;\n\tFor(i,1,n) g[i]=d[i<<1|1]>>1;\n\twhile(m--) {\n\t\tint l,r; cin>>l>>r;\n\t\tif(l+1==r) {\n\t\t\tcout<<2*!chk(l,r)<<endl; continue;\n\t\t}\n\t\tif(chk(l,r)) {\n\t\t\tif(chk(l,r-1)) cout<<0<<endl;\n\t\t\telse if(chk(l,r-2)) {\n\t\t\t\t// r-l+1 % 2 ==1\n\t\t\t\tcout<<que(2,r-l,2)<<endl;\n\t\t\t} else cout<<que(2,r-l,1)<<endl;\n\t\t} else {\n\t\t\tif(chk(l,r-1) && chk(l+1,r)) {\n\t\t\t\tcout<<que(2,r-l+1,2)<<endl;\n\t\t\t} else cout<<que(2,r-l+1,1)<<endl;\n\t\t}\n\t}\n}\n// aaaa\n//  aaaa\nint main() {\n#ifdef LOCAL\n\tfreopen(\".in\",\"r\",stdin);\n\t// freopen(\".out\",\"w\",stdout);\n\t// freopen(\".debug\",\"w\",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}"], "input": "", "output": "", "tags": ["hashing", "implementation", "strings"], "dificulty": "2000", "interactive": false}