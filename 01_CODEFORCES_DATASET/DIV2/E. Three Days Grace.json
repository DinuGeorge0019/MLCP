{
    "link": "https://codeforces.com//contest/1699/problem/E",
    "problemId": "1450611",
    "problem_idx": "E",
    "shortId": "1699E",
    "contest_number": "1699",
    "problem_submissions": {
        "E": [
            162793364,
            162775692,
            162793126,
            162793513,
            162776568,
            162806794,
            163072479,
            162904221,
            162802356,
            163208563
        ],
        "D": [
            162777822,
            162787041,
            162785884,
            162779113,
            162783159,
            162788510,
            162781676,
            162786062,
            162780446,
            162782104,
            162783172,
            162786827,
            162785330,
            162784706,
            162851711,
            162787598,
            162793458,
            162789076
        ],
        "C": [
            162770178,
            162790195,
            162774066,
            162764166,
            162787790,
            162799603,
            162771580,
            162766383,
            162773288,
            162773209,
            162772203,
            162768894,
            162771772,
            162772012,
            162769394,
            162775382,
            162765676,
            162769675
        ],
        "A": [
            162765690,
            162760464,
            162756544,
            162756228,
            162790360,
            162759372,
            162757442,
            162756339,
            162756415,
            162759006,
            162765012,
            162756289,
            162759551,
            162756446,
            162756312,
            162762960,
            162756449,
            162756887
        ],
        "B": [
            162765501,
            162770833,
            162765076,
            162770497,
            162789467,
            162781290,
            162762444,
            162760246,
            162769636,
            162765813,
            162765204,
            162760315,
            162764383,
            162763818,
            162761397,
            162778301,
            162759501,
            162763396
        ]
    },
    "name": "E. Three Days Grace",
    "statement": "You are given a multiset A with initial size n, whose elements are\r\nintegers between 1 and m. In one operation, do the following: select a\r\nvalue x from the multiset A, then select two integers p and q such that\r\np, q > 1 and p\r\ncdot q = x. Insert p and q to A, delete x from A. Note that the size of\r\nthe multiset A increases by 1 after each operation. We define the\r\nbalance of the multiset A as\r\nmax(a_i) -\r\nmin(a_i). Find the minimum possible balance after performing any number\r\n(possible zero) of operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint f[5000005],cnt[5000005],Mn;\nbitset <5000005> vis;\nvector <int> v;\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0); \n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tfor(int i=1;i<=m;i++) cnt[i]=0,f[i]=0,vis[i]=0;\n\t\tint mn=0;\n\t\tint ans=1e8;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif(!vis[x]) ++cnt[0];\n\t\t\tvis[x]=1;\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(vis[i]) --cnt[f[i]];\n\t\t\tf[i]=i;\n\t\t\tif(vis[i]) ++cnt[f[i]];\n\t\t\tfor(int j=1;j*i<=m;j++)\n\t\t\t{\n\t\t\t\tif(vis[i*j]) --cnt[f[i*j]];\n\t\t\t\tf[i*j]=max(f[j],f[j*i]);\n\t\t\t\tif(vis[i*j]) ++cnt[f[i*j]];\n\t\t\t}\n\t\t\twhile(!cnt[mn]) ++mn;\n\t\t\tif(mn) ans=min(ans,i-mn);\n\t\t}\n\t\tcout << ans << \"\\n\"; \n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Three Days Grace.json",
    "editorial_link": "https://codeforces.com//blog/entry/108560",
    "editorial": "SolutionWe can see that in the final multiset, each number from the\r\ninitial multiset will be assigned to a subset of values such that their\r\nproduct is . Every such multiset can be created. Also let be the maximum\r\nvalue in the initial multiset.Consider iterating through the minimum\r\nvalue. To get the best maximum value that has this minimum we fixed, one\r\ncan use dynamic programming the best possible maximum if we had number\r\nand the minimum value in the product is , is a divisor of . This dp can\r\nbe calculated in for all values. We can also process all updates when\r\nincrementing the minimum and keeping the result with a total effort of .\r\nThus we have a total time complexity of . However, this ( we hope )\r\nwonât pass.Here is a way more elegant solution ( thanks to ntherner ):To\r\nget things straight, we observe that when we decompose a number, we just\r\nactually write it as a product of numbers. We still consider fixing the\r\nminimum value used in our multiset, call it . We will further consider\r\nthat we iterate from the greatest possible value (i.e. ) to , and as\r\nsuch, we try at each iteration to calculate the minimum possible value\r\nwhich will appear in any decomposition as the maximum value in said\r\ndecomposition. We shall now retain for each element the minimal maximum\r\nvalue in a decomposition where the minimum of that decomposition is ,\r\nletâs say for element , this value will be stored in . Naturally, after\r\ncalculating this value for every number, we now try to tweak the\r\ncalculated values as to match the fact that, after this iteration\r\nconcluded, we will decrease . For further simplicity, we denote . So, we\r\nchanged the minimum value allowed. What changes now? Well, it is easy to\r\nsee that any element that is not divisible by wonât be affected by this\r\nmodification, as much as it is impossible to include in any\r\ndecomposition of said number. So it remains to modify the multiples of .\r\nLetâs take a such number, . How can we modify ? Well, we can include in\r\nthe decomposition as many times as we want, and then when we decide to\r\nstop including it, we remain with a number which needs to be further\r\ndecomposed. The attributed maximum of this value should already be\r\ncalculated, so we can consider it as a new candidate for the update of .\r\nThis idea could be implemented simpler by going through multiples of ,\r\nand for an element, updating with (by taking the minimum of either)We\r\nnow need for each iteration to keep track of the attributed maximums of\r\neach element that actually appears in our initial list. This can be done\r\nby keeping a frequency of all these elements, and after all updates,\r\ntaking the (already known) maximum of the previous iteration and\r\ndecreasing it until we find another element that actually appears in our\r\nset (this can be verified by simply checking the frequency). This is\r\ncorrect, as much as all the values gradually decrease as decreases, so\r\ntheir maximum would have to decrease as well.Final time complexity:\r\n",
    "hint": []
}