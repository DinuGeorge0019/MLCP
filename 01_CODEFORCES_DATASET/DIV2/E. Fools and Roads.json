{"link": "https://codeforces.com//contest/192/problem/E", "problemId": "1359", "problem_idx": "E", "shortId": "192E", "contest_number": "192", "problem_submissions": {"E": [1730427, 1729827, 1729169, 1737343, 1730835, 1730060, 1730937, 1729815, 1729714, 1730328, 1742732, 1730184, 1806477, 1737169, 1737156], "D": [1728885, 1728181, 1729939, 1729209, 1730875, 1729431, 1730793, 1731274, 1729104, 1729076, 1729834, 1729950, 1730041, 1729892, 1730175, 1729978], "C": [1727437, 1727181, 1730368, 1727614, 1728967, 1728425, 1726946, 1730464, 1727937, 1727660, 1727585, 1727616, 1727725, 1727798, 1727968, 1728394, 1728325, 1727926], "B": [1726501, 1725823, 1726206, 1726346, 1727073, 1726253, 1725853, 1726712, 1726473, 1726128, 1725769, 1726259, 1726326, 1726262, 1726409, 1726302, 1726871, 1726862], "A": [1725727, 1725470, 1725578, 1725407, 1725501, 1731382, 2807333, 1731777, 1742258, 1725639, 1725724, 1725378, 1725587, 1725709, 1730327, 1725718, 1725838, 1725740, 1725684]}, "name": "E. Fools and Roads", "statement": "They say that Berland has exactly two problems, fools and roads.\r\nBesides, Berland has cities, populated by the fools and connected by the\r\nroads. All Berland roads are bidirectional. As there are many fools in\r\nBerland, between each pair of cities there is a path (or else the fools\r\nwould get upset). Also, between each pair of cities there is no more\r\nthan one simple path (or else the fools would get lost). But that is not\r\nthe end of Berland\u2019s special features. In this country fools sometimes\r\nvisit each other and thus spoil the roads. The fools aren\u2019t very smart,\r\nso they always use only the simple paths. is the path which goes through\r\nevery Berland city not more than once.The Berland government knows the\r\npaths which the fools use. Help the government count for each road, how\r\nmany distinct fools can go on it.Note how the fools\u2019 paths are given in\r\nthe input.\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define FORD(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define fup FOR\n#define fdo FORD\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define FORED(i,c) for(VAR(i,(c).rbegin());i!=(c).rend();++i)\n#define ALL(x) (x).begin(),(x).end()\n#define SIZE(x) ((int)(x).size())\n#define siz SIZE\n#define CLR memset((x),0,sizeof (x))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SQR(a) ((a)*(a))\n\n#define DEBUG 1\n#define debug(x) {if(DEBUG) cerr << #x << \" = \" << x << endl;}\n#define debugv(x) {if(DEBUG) {cerr << #x << \" = \"; FORE(it,(x)) cerr << *it << \" . \"; cerr  <<endl;}}\n\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef VI vi;\ntypedef LL lli;\n\nconst int inf = 1000000000;\nconst int MAXN = 100100;\nstruct node {\n    node(): parent(-1), edge(-1), out(), sons(), din(-1), dout(-1) {}\n    int parent;\n    int edge;\n    vector<PII> out;\n    vector<int> sons;\n    int din, dout;\n\n};\nconst int MAXT = 1<<18;\nstruct it {\n    int ile[MAXT];\n    int mx;\n    it(int n) {\n        mx = 1;\n        while(mx < n) mx*= 2;\n    }\n\n    void put(int i) {\n        int p = i+mx;\n        while(p > 0) {\n            ++ile[p];\n            p /= 2;\n        }\n    }\n    int _get(int c, int i, int j, int bi, int bj){ \n        if (i > bj || j < bi) return 0;\n        if (i <= bi && bj <= j) return ile[c];\n        return _get(2*c, i,j, bi, (bi+bj)/2) + _get(2*c+1, i,j,(bi+bj)/2+1, bj);\n    }\n\n    int get(int i, int j) {\n        return _get(1, i, j, 0, mx-1);\n    }\n};\n\nvector<int> fwd[MAXN];\n\nnode T[MAXN];\nint tm;\nvoid dfs(int i, int p) {\n    T[i].din = tm;\n    ++tm;\n    FORE(it,T[i].out) {\n        int j = it->FI;\n        if (j ==p) continue;\n        T[i].sons.PB(j);\n        T[j].parent = i;\n        T[j].edge  =it->SE;\n        dfs(j, i);\n    }\n    T[i].dout = tm-1;\n    //printf(\"%d : (%d - %d)\\n\", i, T[i].din, T[i].dout);\n}\n\nint res[MAXN];\nvoid dfs_fwd(int i, it & iT) {\n    node &t = T[i];\n    if (t.edge != -1) res[t.edge] += iT.get(t.din, t.dout);\n    FORE(it, fwd[i]) {\n        iT.put(*it);\n    }\n    FORE(it, t.sons) {\n        dfs_fwd(*it, iT);\n    } \n}\nvoid dfs_bcw(int i, it & iT) {\n    node &t = T[i];\n    if (t.edge != -1) res[t.edge] += iT.get(t.din, t.dout);\n    FORED(it, t.sons) {\n        dfs_bcw(*it, iT);\n    } \n    FORE(it, fwd[i]) {\n        iT.put(*it);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    REP(i, n-1) {\n        int u,v;\n        scanf(\"%d%d\", &u, &v);\n        --u;--v;\n        T[u].out.PB(MP(v, i));\n        T[v].out.PB(MP(u, i));\n    }\n    tm = 0;\n    dfs(0, -1);\n    it fwdT(n), bcwT(n); \n    int k;\n    scanf(\"%d\", &k);\n    REP(i, k) {\n        int a,b;\n        scanf(\"%d%d\", &a, &b);\n        --a;--b;\n        if (T[a].din > T[b].din) swap(a,b); \n        fwd[a].PB(T[b].din);\n        fwd[b].PB(T[a].din);\n    }\n    dfs_fwd(0, fwdT);\n  /*  REP(i, n-1) printf(\"%d \", res[i]);\n    printf(\"\\n\");*/\n    dfs_bcw(0, bcwT);\n    REP(i, n-1) printf(\"%d \", res[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "1900", "interactive": false}