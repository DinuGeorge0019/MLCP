{
    "link": "https://codeforces.com//contest/1393/problem/D",
    "problemId": "693073",
    "problem_idx": "D",
    "shortId": "1393D",
    "contest_number": "1393",
    "problem_submissions": {
        "D": [
            89235864,
            89237678,
            89239942,
            89241904,
            89240571,
            89239873,
            89230308,
            89237378,
            89247700,
            89240803,
            89243160,
            89243648,
            89242883,
            89238243,
            89242864,
            89249422,
            89245780,
            89244250
        ],
        "B": [
            89221116,
            89217441,
            89220933,
            89222989,
            89220509,
            89223779,
            89220401,
            89219535,
            89219377,
            89227149,
            89220055,
            89224518,
            89222569,
            89225245,
            89223599,
            89220060,
            89222338,
            89225655
        ],
        "C": [
            89218957,
            89225521,
            89228764,
            89230329,
            89224448,
            89234176,
            89238147,
            89233693,
            89228718,
            89234223,
            89234984,
            89234287,
            89231225,
            89232086,
            89232825,
            89232005,
            89235490,
            89236144
        ],
        "A": [
            89218814,
            89212583,
            89214268,
            89213479,
            89214230,
            89213219,
            89213191,
            89220955,
            89212600,
            89213989,
            89213307,
            89215648,
            89216757,
            89215210,
            89215943,
            89213088,
            89214183
        ],
        "E1": [
            89281813
        ]
    },
    "name": "D. Rarity and New Dress",
    "statement": "Carousel Boutique is busy again! Rarity has decided to visit the pony\r\nball and she surely needs a new dress, because going out in the same\r\ndress several times is a sign of bad manners. First of all, she needs a\r\ndress pattern, which she is going to cut out from the rectangular piece\r\nof the multicolored fabric.The piece of the multicolored fabric consists\r\nof n\r\ntimes m separate square scraps. Since Rarity likes dresses in style, a\r\ndress pattern must only include scraps sharing the same color. A dress\r\npattern must be the square, and since Rarity is fond of rhombuses, the\r\nsides of a pattern must form a 45^{\r\ncirc} angle with sides of a piece of fabric (that way it will be\r\nresembling the traditional picture of a rhombus).Examples of proper\r\ndress patterns: Examples of improper dress patterns: The first one\r\nconsists of multi-colored scraps, the second one goes beyond the bounds\r\nof the piece of fabric, the third one is not a square with sides forming\r\na 45^{\r\ncirc} angle with sides of the piece of fabric.Rarity wonders how many\r\nways to cut out a dress pattern that satisfies all the conditions that\r\ndo exist. Please help her and satisfy her curiosity so she can continue\r\nworking on her new masterpiece!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nconst ll NN = 2e5 + 5;\nll n, m, has;\nchar a[2020][2020];\nll d[2020][2020];\nll dx[] = {-1, 1, 0, 0};\nll dy[] = {0, 0, -1, 1};\nll cek(ll X, ll Y)\n{\n    ll H = 0;\n    for(ll i = 0; i < 4; i++)\n    {\n        ll nx = X + dx[i];\n        ll ny = Y + dy[i];\n        // cout << X << \" \" << Y << \" \" << nx << \" \" << ny << \"  \" << a[nx][ny] << \" \" << a[X][Y] << \"\\n\";\n        if(1 <= nx && nx <= n && 1 <= ny && ny <= m && (a[nx][ny] == a[X][Y]))\n            H++;\n    }\n    // cout << X << \" \" << Y << \" \" << H << \"\\n\";\n    return (H < 4);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> n >> m;\n    for(ll i = 1; i <= n; i++)\n        for(ll j = 1; j <= m; j++)\n            cin >> a[i][j];\n    queue<pair<ll, ll> >  q;\n    for(ll i = 1; i <= n; i++)\n        for(ll j = 1; j <= m; j++)\n            if(cek(i, j))\n            {\n                d[i][j] = 1;\n                q.push(mp(i, j));\n            }\n    while(!q.empty())\n    {\n        ll X = q.front().fi;\n        ll Y = q.front().se;\n        q.pop();\n        for(ll i = 0; i < 4; i++)\n        {\n            ll nx = X + dx[i];\n            ll ny = Y + dy[i];\n            if(1 <= nx && nx <= n && 1 <= ny && ny <= m && d[nx][ny] == 0)\n            {\n                d[nx][ny] = d[X][Y] + 1;\n                q.push(mp(nx, ny));\n            }\n        }\n    }\n    // for(ll i = 1; i <= n; i++)\n    // {\n    //     for(ll j = 1; j <= m; j++)\n    //         cout << d[i][j] << \" \";\n    //     cout << \"\\n\";\n    // }\n    for(ll i = 1; i <= n; i++)\n        for(ll j = 1; j <= m; j++)\n            has += d[i][j];\n    cout << has << \"\\n\";\n}   "
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Rarity and New Dress.json",
    "editorial_link": "https://codeforces.com//blog/entry/81161",
    "editorial": "Letâs note that if there is a rhombus of size in the cell , then there\r\nare also rhombuses with the smaller sizes.Letâs divide the rhombus into\r\nthe left part and the right part. Letâs solve the problem separately for\r\nboth of them and then the answer for the cell is going to be equal to\r\nthe minimum of these values.Note that if the maximum size for the cell\r\nis , then the maximum size for the cell is at most (and at most , if\r\nthese two cells are not equal). Also the maximums size for the left part\r\nis at most minimum of the number of consecutive cells to the up and to\r\nleft from the fixed cell.To find the number of consective equal cells to\r\nthe up, we will use the dynamic programming. If the cells and are equal,\r\nthen the answer for the cell is equal to the answer for the cell plus ,\r\notherwise it is equal to . Similarly we can find the answer for the\r\ncells to the left.Now we need to find the maximum size of the left part.\r\nWe can use dynamic programming and calculate it accordingly to our\r\nobservations.Similarly for the right part.The total complexity is .\r\n",
    "hint": []
}