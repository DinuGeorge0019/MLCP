{
    "link": "https://codeforces.com//contest/897/problem/E",
    "problemId": "137068",
    "problem_idx": "E",
    "shortId": "897E",
    "contest_number": "897",
    "problem_submissions": {
        "D": [
            32869363,
            32868967,
            32870299,
            32871420,
            32871096,
            32871069,
            32872537,
            32872235,
            32873063,
            32867675,
            32899611,
            32872434,
            32870151,
            32872540,
            32868724,
            32872412,
            32871965,
            32870305,
            32870537
        ],
        "C": [
            32866469,
            32867357,
            32867913,
            32867474,
            32867444,
            32868703,
            32867464,
            32865520,
            32867687,
            32873999,
            32867162,
            32872564,
            32869517,
            32873487,
            32868079,
            32870223,
            32867096,
            32871838
        ],
        "B": [
            32863081,
            32866614,
            32863458,
            32862862,
            32863043,
            32864870,
            32863155,
            32862993,
            32862870,
            32864103,
            32865012,
            32863471,
            32863794,
            32862844,
            32864643,
            32865335,
            32872101,
            32864895
        ],
        "A": [
            32860112,
            32864431,
            32860323,
            32860778,
            32862516,
            32860290,
            32860663,
            32860439,
            32860544,
            32861554,
            32860704,
            32860360,
            32860929,
            32861796,
            32861440,
            32860719,
            32861670
        ],
        "E": [
            32893341
        ]
    },
    "name": "E. Willem, Chtholly and Seniorious",
    "statement": "Seniorious is made by linking special talismans in particular\r\norder.After over 500 years, the carillon is now in bad condition, so\r\nWillem decides to examine it thoroughly.Seniorious has pieces of\r\ntalisman. Willem puts them in a line, the -th of which is an integer .In\r\norder to maintain it, Willem needs to perform operations.There are four\r\ntypes of operations: : For each such that , assign to . : For each such\r\nthat , assign to . : Print the -th smallest number in the index range ,\r\ni.e. the element at the -th position if all the elements such that are\r\ntaken and sorted into an array of non-decreasing integers. It\u2019s\r\nguaranteed that . : Print the sum of the -th power of such that , modulo\r\n, i.e. .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint ModPow(int a,int r,int m)\n{\n\tint x=1;\n\tfor(;r;r>>=1){\n\t\tif(r&1) x=(ll)x*a%m;\n\t\ta=(ll)a*a%m;\n\t}\n\treturn x;\n}\n\ntuple<vi,vvi> generate_input(int n,int m,int seed,int vmax)\n{\n\tauto rnd=[&](){return exchange(seed,((ll)seed*7+13)%MOD);};\n\tvi a(n);\n\trep(i,n) a[i]=rnd()%vmax+1;\n\tvvi qs;\n\trep(i,m){\n\t\tint op=rnd()%4+1;\n\t\tint l=rnd()%n+1;\n\t\tint r=rnd()%n+1;\n\t\tif(l>r) swap(l,r);\n\t\tint x=op==3?rnd()%(r-l+1)+1:rnd()%vmax+1;\n\t\tif(op==4){\n\t\t\tint y=rnd()%vmax+1;\n\t\t\tqs.push_back({op,l,r,x,y});\n\t\t}\n\t\telse{\n\t\t\tqs.push_back({op,l,r,x});\n\t\t}\n\t}\n\treturn mt(a,qs);\n}\n\nvoid split(map<int,tuple<int,ll>>& rs,int i)\n{\n\tauto it=prev(rs.upper_bound(i));\n\tif(it->first==i) return;\n\tint r; ll x; tie(r,x)=it->second;\n\tit->second={i,x};\n\trs[i]={r,x};\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(int n,m,seed,vmax;cin>>n>>m>>seed>>vmax&&n|m|seed|vmax;){\n\t\tvi a;\n\t\tvvi qs;\n\t\ttie(a,qs)=generate_input(n,m,seed,vmax);\n\n\t\trep(i,m) qs[i][1]--;  // l,r\u30920-origin\u306e\u534a\u958b\u533a\u9593\u306b\u3059\u308b\n\t\tmap<int,tuple<int,ll>> rs;  // l->(r,x)\n\t\trep(i,n) rs[i]={i+1,a[i]};\n\n\t\tfor(auto q:qs){\n\t\t\tint op=q[0];\n\t\t\tint l=q[1],r=q[2],x=q[3];\n\t\t\tsplit(rs,l); split(rs,r);\n\t\t\tauto i=rs.lower_bound(l);\n\t\t\tauto j=rs.lower_bound(r);\n\t\t\tif(op==1){\n\t\t\t\tfor(auto k=i;k!=j;k++)\n\t\t\t\t\tget<1>(k->second)+=x;\n\t\t\t}\n\t\t\telse if(op==2){\n\t\t\t\tfor(auto k=i;k!=j;rs.erase(k++));\n\t\t\t\trs[l]={r,x};\n\t\t\t}\n\t\t\telse if(op==3){\n\t\t\t\tx--;\n\t\t\t\tmap<ll,int> f;\n\t\t\t\tfor(auto k=i;k!=j;k++)\n\t\t\t\t\tf[get<1>(k->second)]+=get<0>(k->second)-k->first;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(auto p:f)\n\t\t\t\t\tif(x<(cnt+=p.second)){\n\t\t\t\t\t\tcout<<p.first<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op==4){\n\t\t\t\tint y=q[4];\n\t\t\t\tmap<ll,int> f;\n\t\t\t\tfor(auto k=i;k!=j;k++)\n\t\t\t\t\tf[get<1>(k->second)]+=get<0>(k->second)-k->first;\n\t\t\t\tll res=0;\n\t\t\t\tfor(auto p:f)\n\t\t\t\t\t(res+=(ll)p.second*ModPow(p.first%y,x,y))%=y;\n\t\t\t\tcout<<res<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Willem, Chtholly and Seniorious.json",
    "editorial_link": "https://codeforces.com//blog/entry/56135",
    "editorial": "This is an interesting algorithm which can easily deal with many data structure problems------if the data is random...\n\nI initially named it as \"Old Driver Tree\" ( Which is my codeforces ID ).\n\n(But now I call it Chtholly Tree~).\n\nWe can find that there is an operation that makes a range of number the same.\n\nWe can use an interval tree (std::set is enough) to maintain every interval that consists of the same number.\n\nAnd for operation 2, we destory all the intervals in range [l,?r] , and put in a new interval [l,?r] into the interval tree.\n\nFor operations 1, 3, 4, we can brute-forcely walk on the tree, find every interval in range [l,?r], and do the required operation on it.\n\nProof of time complexity:\n\nWe suppose that we have a randomly selected range [l,?r] now, and we randomly choose which operation it is, suppose that there are x intervals in this range.\n\n1/4 possibility we use O(x) time to erase O(x) nodes.\n\n2/4 possibility we use O(x) time to erase nothing.\n\n1/4 possibility we use O(x) time to erase nothing and add 2 new nodes into the tree.\n\nSo we are expected to use O(x) time to erase O(x) nodes.\n\nBy using interval tree to maintain, the time complexity of this problem is .\n\nIf operation 3 and 4 are changed into output the sum of ai for every i range [l,?r], it seems that the time complexity may change into  , but I do not know how to prove it..."
}