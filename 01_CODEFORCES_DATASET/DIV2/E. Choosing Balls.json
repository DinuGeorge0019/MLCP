{"link": "https://codeforces.com//contest/265/problem/E", "problemId": "2525", "problem_idx": "E", "shortId": "265E", "contest_number": "265", "problem_submissions": {"E": [2970019, 2969814, 2971806, 2972492, 2972772, 2970736], "D": [2968205, 2967708, 2967237, 2968473, 2967999, 2967756, 2971736, 2969158, 2969904, 2966908, 2968608, 2970666, 2968760, 2968451, 2969659, 2966606, 2966951], "B": [2967771, 2964317, 2964787, 2965276, 2964902, 2964309, 2965378, 2964669, 3347348, 2965826, 2967252, 2965239, 2965920, 2965167, 2966106, 2964904, 2964503, 2964762], "A": [2964815, 2963268, 2963454, 2963256, 2963422, 2963233, 2963728, 2963215, 3347333, 2964025, 2963259, 2963495, 2963155, 2963704, 2964004, 2965452, 2963951, 2963523], "C": [2966018, 2965716, 2966720, 2966022, 2965227, 2966717, 2966330, 2966665, 2964777, 2966177, 2966801, 2966556, 2966845, 2967129, 2965425]}, "name": "E. Choosing Balls", "statement": "There are balls. They are arranged in a row. Each ball has a color (for\r\nconvenience an integer) and an integer value. The color of the -th ball\r\nis and the value of the -th ball is .Squirrel Liss chooses some balls\r\nand makes a new sequence without changing the relative order of the\r\nballs. She wants to maximize the value of this sequence.The value of the\r\nsequence is defined as the sum of following values for each ball (where\r\nand are given constants): If the ball is not in the beginning of the\r\nsequence and the color of the ball is same as previous ball\u2019s color, add\r\n(the value of the ball) . Otherwise, add (the value of the ball) . You\r\nare given queries. Each query contains two integers and . For each query\r\nfind the maximal value of the sequence she can make when and .Note that\r\nthe new sequence can be , and the value of an empty sequence is defined\r\nas zero.\r\n", "solutions": ["#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=200000;\nconst long long inf=20000000000000ll;\nint n,q;\nint c[MAXN],v[MAXN],FG[MAXN];\nlong long a,b,VE[MAXN],hl[MAXN],hr[MAXN];\nstruct node\n{\n\tint col;\n\tlong long val;\n}l,r;\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&v[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&c[i]);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%I64d %I64d\",&a,&b);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tVE[j]=-inf;\n\t\tl.val=0;l.col=-1;\n\t\tr.val=0;r.col=-2;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tlong long TT=VE[c[j]] + a * v[j];\n\t\t\tif (c[j]!=l.col)\n\t\t\t\tTT=max(TT,l.val + b * v[j]);\n\t\t\telse\n\t\t\t\tTT=max(TT,r.val + b * v[j]);\n\t\t\t\n\t\t\tif (c[j]!=l.col && c[j]!=r.col)\n\t\t\t{\n\t\t\t\tif (TT > l.val)\n\t\t\t\t\tr=l,l.val=TT,l.col=c[j];\n\t\t\t\telse\n\t\t\t\tif (TT > r.val)\n\t\t\t\t\tr.val=TT,r.col=c[j];\n\t\t\t} else\n\t\t\tif (c[j]==l.col && TT > l.val)\n\t\t\t\tl.val=TT;\n\t\t\telse\n\t\t\tif (c[j]==r.col && TT > r.val)\n\t\t\t\tr.val=TT;\t\t\t\n\t\t\tif (r.val > l.val)\n\t\t\t\tswap(l,r);\n\t\t\tVE[c[j]]=max(VE[c[j]],TT);\n\t\t}\n\t\tprintf(\"%I64d\\n\",l.val);\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["schedules", "sortings"], "dificulty": "2000", "interactive": false}