{"link": "https://codeforces.com//contest/216/problem/E", "problemId": "1601", "problem_idx": "E", "shortId": "216E", "contest_number": "216", "problem_submissions": {"E": [2009676, 2007456, 2010925, 2011846, 2010767, 2013186, 2012062, 2014949, 2013666, 2046735, 2013517], "D": [2008985, 2008016, 2009087, 2009267, 2009116, 2010292, 2010461, 2009515, 2010965, 2010788, 2008354, 2011910, 2011812, 2010997, 2011635, 2010429, 2010591], "C": [2008196, 2010650, 2010398, 2010245, 2009928, 2008042, 2009220, 2212789, 2010921, 2010250, 2009530, 2011922, 2009776, 2011084, 2009565, 2010436, 2011686, 2009858], "B": [2007383, 2008222, 2006806, 2008461, 2008911, 2011583, 2007848, 2008640, 2008312, 2007798, 2007852, 2009984, 2009151, 2011696, 2009696, 2009222, 2012291], "A": [2006576, 2008320, 2007244, 2007015, 2006474, 2492889, 2492882, 2006494, 2006484, 2006601, 2007349, 2006728, 2006555, 2006564, 2007269, 2006768, 2007828, 2006557, 2007513]}, "name": "E. Martian Luck", "statement": "You know that the Martians use a number system with base . Digit () is\r\nconsidered , as the first contact between the Martians and the\r\nEarthlings occurred in year (by Martian chronology).A of number is a\r\nnumber that consists of a single digit, resulting after cascading\r\nsumming of all digits of number . Word \"cascading\" means that if the\r\nfirst summing gives us a number that consists of several digits, then we\r\nsum up all digits again, and again, until we get a one digit number.For\r\nexample, . In this sample the calculations are performed in the 7-base\r\nnotation.If a number\u2019s digital root equals , the Martians also call this\r\nnumber lucky.You have string , which consists of digits in the -base\r\nnotation system. Your task is to find, how many distinct substrings of\r\nthe given string are lucky numbers. Leading zeroes are permitted in the\r\nnumbers.Note that substring of the string () is the string . Two\r\nsubstrings and of the string are different if either or .\r\n", "solutions": ["#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint a[110000];\nmap<int,int> mp;\n\nint main()\n{\n  _int64 ans;\n  int i,j,k,b,n,tot,tmp,z;\n  scanf(\"%d%d%d\",&k,&b,&n);\n  for (i=0;i<n;i++)\n  {\n    scanf(\"%d\",&a[i]);\n  }\n  mp.clear();\n  mp[0]++;\n  tot=0;\n  ans=0;\n  z=0;\n  for (i=0;i<n;i++)\n  {\n    tot+=a[i];\n    tot%=(k-1);\n    if (a[i]==0) z++;\n    else z=0;\n    tmp=(tot+(k-1)-b)%(k-1);\n    if ((b==(k-1))||(b==0))\n    {\n      if (b==0) ans+=z;\n      else ans+=(mp[tmp]-z);\n    }\n    else\n    {\n      ans+=mp[tmp];\n    }\n    mp[tot]++;\n  }\n  printf(\"%I64d\\n\",ans);\n}\n"], "input": "", "output": "", "tags": ["math", "number theory"], "dificulty": "2000", "interactive": false}