{
    "link": "https://codeforces.com//contest/216/problem/E",
    "problemId": "1601",
    "problem_idx": "E",
    "shortId": "216E",
    "contest_number": "216",
    "problem_submissions": {
        "E": [
            2009676,
            2007456,
            2010925,
            2011846,
            2010767,
            2013186,
            2012062,
            2014949,
            2013666,
            2046735,
            2013517
        ],
        "D": [
            2008985,
            2008016,
            2009087,
            2009267,
            2009116,
            2010292,
            2010461,
            2009515,
            2010965,
            2010788,
            2008354,
            2011910,
            2011812,
            2010997,
            2011635,
            2010429,
            2010591
        ],
        "C": [
            2008196,
            2010650,
            2010398,
            2010245,
            2009928,
            2008042,
            2009220,
            2212789,
            2010921,
            2010250,
            2009530,
            2011922,
            2009776,
            2011084,
            2009565,
            2010436,
            2011686,
            2009858
        ],
        "B": [
            2007383,
            2008222,
            2006806,
            2008461,
            2008911,
            2011583,
            2007848,
            2008640,
            2008312,
            2007798,
            2007852,
            2009984,
            2009151,
            2011696,
            2009696,
            2009222,
            2012291
        ],
        "A": [
            2006576,
            2008320,
            2007244,
            2007015,
            2006474,
            2492889,
            2492882,
            2006494,
            2006484,
            2006601,
            2007349,
            2006728,
            2006555,
            2006564,
            2007269,
            2006768,
            2007828,
            2006557,
            2007513
        ]
    },
    "name": "E. Martian Luck",
    "statement": "You know that the Martians use a number system with base . Digit () is\r\nconsidered , as the first contact between the Martians and the\r\nEarthlings occurred in year (by Martian chronology).A of number is a\r\nnumber that consists of a single digit, resulting after cascading\r\nsumming of all digits of number . Word \"cascading\" means that if the\r\nfirst summing gives us a number that consists of several digits, then we\r\nsum up all digits again, and again, until we get a one digit number.For\r\nexample, . In this sample the calculations are performed in the 7-base\r\nnotation.If a number\u2019s digital root equals , the Martians also call this\r\nnumber lucky.You have string , which consists of digits in the -base\r\nnotation system. Your task is to find, how many distinct substrings of\r\nthe given string are lucky numbers. Leading zeroes are permitted in the\r\nnumbers.Note that substring of the string () is the string . Two\r\nsubstrings and of the string are different if either or .\r\n",
    "solutions": [
        "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint a[110000];\nmap<int,int> mp;\n\nint main()\n{\n  _int64 ans;\n  int i,j,k,b,n,tot,tmp,z;\n  scanf(\"%d%d%d\",&k,&b,&n);\n  for (i=0;i<n;i++)\n  {\n    scanf(\"%d\",&a[i]);\n  }\n  mp.clear();\n  mp[0]++;\n  tot=0;\n  ans=0;\n  z=0;\n  for (i=0;i<n;i++)\n  {\n    tot+=a[i];\n    tot%=(k-1);\n    if (a[i]==0) z++;\n    else z=0;\n    tmp=(tot+(k-1)-b)%(k-1);\n    if ((b==(k-1))||(b==0))\n    {\n      if (b==0) ans+=z;\n      else ans+=(mp[tmp]-z);\n    }\n    else\n    {\n      ans+=mp[tmp];\n    }\n    mp[tot]++;\n  }\n  printf(\"%I64d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Martian Luck.json",
    "editorial_link": "https://codeforces.com//blog/entry/5066",
    "editorial": "Digital root of number is equal to that number modulo k?-?1 for most cases. It is lie only for digital roots 0 and k?-?1 \u0097 in that cases number modulo k?-?1 will be 0. But you can get digital root 0 only for numbers like 00...00. Total number of numbers that type you can find using any other way. So, now you can find number of substrings that have some digital root, if you know number of substrings that equals some number modulo k?-?1.\n\nHow to find number of substrings of some modulo? You should iterate over all digits of s from the left to the rigth and for every modulo store number of prefixes of that modulo in some array dp[] of size k. Let's current position is i. Then number of substrings modulo b that ends in position i equals to number of prefixes leftmost position i that have modulo (x?-?b)mod(k?-?1), where x is modulo of s[1... i]. I.e. just dp[(x?-?b)mod(k?-?1)].\n\nTo fit into memory limit, you should replace array dp[] by some associative array. For example, std::map from ?++ or some hashtable.\n\nSo we have solution in O(nz), where z is complexety of access to dp[] ( for std::map and O(1) for hashtable)."
}