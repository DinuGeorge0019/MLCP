{
    "link": "https://codeforces.com//contest/195/problem/E",
    "problemId": "1423",
    "problem_idx": "E",
    "shortId": "195E",
    "contest_number": "195",
    "problem_submissions": {
        "E": [
            1777341,
            1777807,
            1780602,
            1778882,
            1779695,
            1778939,
            1778079,
            1779584,
            1779643,
            1780676,
            1779994,
            1779882,
            1781688
        ],
        "D": [
            1776612,
            1777077,
            1778398,
            1777210,
            1777366,
            1777818,
            1778286,
            1778743,
            1779250,
            1776789,
            1779690,
            1779525,
            1779340,
            1779758
        ],
        "C": [
            1776366,
            1778703,
            1777228,
            1786363,
            1778918,
            1777720,
            1778071,
            1778134,
            1779053,
            1780725,
            1777787,
            1778730,
            1778503,
            1778557
        ],
        "B": [
            1775818,
            1776287,
            1776244,
            1776178,
            1776166,
            1776316,
            1776212,
            1776715,
            1776133,
            1776660,
            1776543,
            1776189,
            1776717,
            1777992,
            1776246,
            1777021,
            1776348,
            1776593
        ],
        "A": [
            1775640,
            1775659,
            1775647,
            1775756,
            1775776,
            1775645,
            1775901,
            1776042,
            1775714,
            1776301,
            1775707,
            1775754,
            1776172,
            1777471,
            1775841,
            1775942,
            1776937,
            1775764
        ]
    },
    "name": "E. Building Forest",
    "statement": "An is an acyclic weighted digraph in which from each vertex at most one\r\nedge goes.The of vertex of an oriented weighted forest is a vertex from\r\nwhich no edge goes and which can be reached from vertex moving along the\r\nedges of the weighted oriented forest. We denote the root of vertex as\r\n.The of vertex is the sum of weights of paths passing from the vertex to\r\nits root. Let’s denote the depth of the vertex as .Let’s consider the\r\nprocess of constructing a weighted directed forest. Initially, the\r\nforest does not contain vertices. Vertices are added sequentially one by\r\none. Overall, there are performed operations of adding. The -th adding\r\noperation is described by a set of numbers and means that we should add\r\nvertex number and edges to the graph: an edge from vertex to vertex with\r\nweight , an edge from vertex to vertex with weight and so on. If , then\r\nonly vertex is added to the graph, there are no added edges.Your task is\r\nlike this: given the operations of adding vertices, calculate the sum of\r\nthe weights of all edges of the forest, resulting after the application\r\nof all defined operations, modulo .\r\n",
    "solutions": [
        "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vll;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\n#define MOD 1000000007\n\nstatic pair<int, ll> find(vi &parent, vll &weight, int x)\n{\n    int y = x;\n    ll w = 0;\n    while (parent[y] >= 0)\n    {\n        w = (w + weight[y]) % MOD;\n        y = parent[y];\n    }\n\n    ll ws = 0;\n    while (parent[x] >= 0)\n    {\n        int n = parent[x];\n        ll wn = weight[x];\n\n        parent[x] = y;\n        weight[x] = (w - ws) % MOD;\n        ws = (ws + wn) % MOD;\n        x = n;\n    }\n\n    return make_pair(y, w);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N;\n    vi parent(N, -1);\n    vll weight(N, 0);\n    ll ans = 0;\n    for (int i = 0; i < N; i++)\n    {\n        int K;\n        cin >> K;\n        for (int j = 0; j < K; j++)\n        {\n            int v;\n            ll x;\n            cin >> v >> x;\n            v--;\n            pair<int, ll> root = find(parent, weight, v);\n            ll w = (root.second + x) % MOD;\n            ans = (ans + w) % MOD;\n            parent[root.first] = i;\n            weight[root.first] = w;\n            cerr << i << ' ' << root.first << ' ' << w << '\\n';\n        }\n    }\n    ans %= MOD;\n    if (ans < 0)\n        ans += MOD;\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Building Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/4699",
    "editorial": "The longest operation in this problem is\nto find the root of some vertex and the sum of the path to this root. To\nfind these values fast we will use compression ways heuristics which is\nused in data structure \"disjoint-set-union\". For every vertex v we keep\ntwo values : and . , if root, else next vertex on path from to root. =\nsum of lengths of edges on path from to . To add new edge from to of\nlength it is enough to do and . Note that we only add new edges (we\ndonât erase edges). That is, if we find and for some vertex we can\nassign , Unable to parse markup [type=CF_TEX] It can proved that such\nimplementation works using time for every query. The complexity of the\nsolution is .\n",
    "hint": []
}