{
    "link": "https://codeforces.com//contest/2107/problem/D",
    "problemId": "3369876",
    "problem_idx": "D",
    "shortId": "2107D",
    "contest_number": "2107",
    "problem_submissions": {
        "F2": [
            318524340,
            318484817,
            318509938,
            318511203,
            318525439,
            318523594,
            318519776
        ],
        "F1": [
            318519651,
            318487840,
            318492813,
            318505063,
            318504824,
            318527743,
            318517545,
            318515290,
            318492245,
            318507170,
            318502926,
            318494892,
            318509274,
            318493554,
            318492460,
            318538698,
            318513104
        ],
        "E": [
            318507496,
            318520903,
            318524820,
            319045355,
            318517429,
            318526986,
            318522135,
            318520283
        ],
        "D": [
            318493293,
            318536403,
            318487166,
            318499916,
            318508438,
            318508583,
            318505898,
            318493577,
            318513154,
            318499523,
            318510734,
            318518593,
            318502474,
            318501316,
            318505642
        ],
        "C": [
            318476342,
            318476070,
            318476829,
            318476779,
            318475602,
            318489984,
            318490878,
            318480285,
            318468986,
            318484993,
            318479001,
            318481099,
            318477842,
            318483418,
            318469245,
            318475881,
            318486336
        ],
        "B": [
            318459029,
            318461790,
            318460834,
            318460140,
            318461949,
            318460838,
            318465148,
            318465596,
            318462205,
            318463062,
            318467674,
            318475025,
            318483564,
            318464926,
            318482093,
            318463365,
            318465794
        ],
        "A": [
            318456403,
            318456545,
            318456374,
            318456379,
            318456465,
            318456630,
            318465029,
            318458451,
            318456594,
            318457358,
            318459958,
            318457429,
            318485822,
            318458433,
            318472714,
            318456756,
            318458361
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142642",
    "editorial": "SolutionNote that the problem has a simple solution by greedily finding\r\nthe largest diameter in the current forest (set of disjoint trees) at\r\nevery step, tiebreaking by the lexicographic order of the endpoints,\r\nthen removing the diameter and continuing this process while at least\r\nnode remains. Property : diameters always share at least one node.\r\nProofWith some background theory about diameters, this becomes trivial\r\nas when diameter length (in terms of nodes) is odd, they share a common\r\ncentral node; and when even, they share an edge (which shares nodes).\r\nNevertheless, we provide an elementary proof.Let and be distinct\r\ndiameters that do not share any node. Consider the closest pair of\r\npoints in these paths, say and are closest. Then, the path cannot\r\ncontain any other or any other because otherwise it would be a\r\ncontradiction to the fact that they are closest.Now, the length of the\r\npath is , where denotes the number of nodes on the path . Assume that ,\r\nthen is strictly larger than (using ), contradicting that is the\r\ndiameter. In the other cases of being smaller than , we can check the\r\npairs and . It is easy to see at least one of them will be larger than\r\n.Property : Let denote a diameter path, and denote the tree. Then\r\n(strictly smaller). ProofThis comes directly from the previous property.\r\nSince all diameters share at least one node, the new forest generated\r\nafter removing path will have a strictly smaller diameter.Property : In\r\nany sequence of positive numbers such that such that for all , is at\r\nmost . ProofThis is a classical property. Note that for all by\r\ninduction. And thus, .But, implies , and so .With these properties, we\r\ncan now solve the problem. We describe the algorithm below: Maintain a\r\ncollection of subtrees (of nodes which have apples). Initially, the\r\nwhole tree is there as one component. For every subtree, find it’s\r\nlexicographically largest triplet of using a BFS/DFS. Remove the nodes\r\non the diameter path for each subtree. This divides the component into\r\nseveral smaller subtrees. Add them to our collection. Repeat steps and\r\nwhile our collection is non-empty. Finally, sort (in descending order)\r\nthe list of collected throughout all the steps, and output. It is not\r\nhard to see that the above approach produces the correct answer. And it\r\nruns in time because steps and are repeated only times. ProofEvery\r\nsmaller tree is formed from a larger \"parent\" tree. The diameter of the\r\nsmaller tree is smaller than the diameter of the larger tree using\r\nProperty . Suppose that there is some tree that is formed at -th step.\r\nThen, consider the sequence of parent trees of this tree, and their\r\ndiameters. Their diameters form a strictly increasing sequence, but\r\ntheir sum must be bounded by since we remove that many nodes, and total\r\nremoved nodes is . Thus, using Property , we get .There are several\r\ncorrect ways to implement Step . One of the neatest way is as follows:\r\nFind the furthest node from , tie breaking lexicographically, say we got\r\n. Find the furthest node from , again tie breaking lexicopgraphically,\r\nsay we got . Then is the required diameter. To prove that these\r\ntraversals are enough, you can use the fact mentioned in proof of\r\nproperty , i.e. diameters share a central node or an edge (depending on\r\nparity). To find the furthest node, we can use BFS or DFS both fairly\r\neasily.For step , we can keep recursing to the parent of till we reach ,\r\nassuming we have calculated the parents of all vertices with a dfs from\r\n. You may refer to the code.\r\n",
    "name": "D. Apple Tree Traversing",
    "statement": "There is an apple tree with n nodes, initially with one apple at each\r\nnode. You have a paper with you, initially with nothing written on\r\nit.You are traversing on the apple tree, by doing the following action\r\nas long as there is at least one apple left: Choose an (u,v). A path\r\n(u,v) is called an if and only if for every node on the path (u,v),\r\nthere’s an apple on it. Let d be the number of apples on the path, write\r\ndown three numbers (d,u,v), in this order, on the paper. Then remove all\r\nthe apples on the path (u,v). Here, the path (u, v) refers to the\r\nsequence of vertices on the unique shortest walk from u to v. Let the\r\nnumber sequence on the paper be a. Your task is to find the\r\nlexicographically largest possible sequence a.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Apple Tree Traversing.json",
    "hint": []
}