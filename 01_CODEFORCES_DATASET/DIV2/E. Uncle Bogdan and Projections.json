{
    "link": "https://codeforces.com//contest/1388/problem/E",
    "problemId": "686570",
    "problem_idx": "E",
    "shortId": "1388E",
    "contest_number": "1388",
    "problem_submissions": {
        "E": [
            88517531,
            88530891,
            88517600,
            88523055,
            88559408,
            88542097
        ],
        "C": [
            88495900,
            88476175,
            88487310,
            88473716,
            88465503,
            88475038,
            88476262,
            88491274,
            88495411,
            88490211,
            88478175,
            88476725,
            88481845,
            88482918,
            88481225,
            88495504,
            88478995,
            88495759,
            88479604,
            88484795
        ],
        "D": [
            88480866,
            88490926,
            88497401,
            88487086,
            88484181,
            88486444,
            88489488,
            88473157,
            98881770,
            88482199,
            88475588,
            88491188,
            88488173,
            88491949,
            88494949,
            88491042,
            88480887,
            88497356,
            88482729,
            88496957,
            88493773
        ],
        "B": [
            88462054,
            88457078,
            88466301,
            88459212,
            88468622,
            88456432,
            88454997,
            88458888,
            88464610,
            88464365,
            88460797,
            88461431,
            88459743,
            88458713,
            88465245,
            88463298,
            88463309,
            88464312,
            88458653,
            88460565
        ],
        "A": [
            88452967,
            88450708,
            88455876,
            88453483,
            88454243,
            88450256,
            88459790,
            88452559,
            88453995,
            88452985,
            88451474,
            88453407,
            88450218,
            88453612,
            88453949,
            88452546,
            88454306,
            88453052,
            88449709,
            88452291
        ]
    },
    "name": "E. Uncle Bogdan and Projections",
    "statement": "There are n non-intersecting horizontal segments with ends in integers\r\npoints on the plane with the standard cartesian coordinate system. All\r\nsegments are strictly above the OX axis. You can choose an arbitrary\r\nvector (a, b), where b < 0 and coordinates are real numbers, and project\r\nall segments to OX axis along this vector. Find the minimum possible\r\ndifference between x coordinate of the right end of the rightmost\r\nprojection and x coordinate of the left end of the leftmost projection.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 2020\n#define EPS 0.00000000000001\n#define pb push_back\n\nint main() {\n\tint n, k;\n\tint sza, szb;\n\tlong double x1[N];\n\tlong double x2[N];\n\tlong double y[N];\n\tlong double xx, yy, zz;\n\tlong double xxx, yyy;\n\tvector < pair<long double, long double> >a;\n\tpair<long double, long double>ma[N];\n\tpair<long double, long double>mb[N];\n\tlong double s, ans;\n\tscanf(\"%d\", &n);\n\txxx = 10000000000;\n\tyyy = -10000000000;\n\tf(i, n) {\n\t\tscanf(\"%Lf %Lf %Lf\", &x1[i], &x2[i], &y[i]);\n\t\tif (xxx > x1[i]) xxx = x1[i];\n\t\tif (yyy < x2[i])yyy = x2[i];\n\t}\n\tf(i, n) {\n\t\ta.pb({ y[i],x2[i] });\n\t}\n\tsort(a.begin(), a.end());\n\tsza = 0;\n\tf(i, n) {\n\t\twhile (sza > 1) {\n\t\t\tif (abs(a[i].first - ma[sza - 1].first) < 0.1) {\n\t\t\t\tsza--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\txx = (ma[sza - 1].second - a[i].second) / (a[i].first - ma[sza - 1].first);\n\t\t\t\tyy = (ma[sza - 2].second - a[i].second) / (a[i].first - ma[sza - 2].first);\n\t\t\t\tif (xx < yy)sza--;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tma[sza] = a[i];\n\t\tsza++;\n\t}\n\ta.clear();\n\tf(i, n) {\n\t\ta.pb({ y[i],x1[i] });\n\t}\n\tsort(a.begin(), a.end(), greater< pair<long double, long double> >());\n\tszb = 0;\n\tf(i, n) {\n\t\twhile (szb > 1) {\n\t\t\tif (abs(a[i].first - mb[szb - 1].first) < 0.1) {\n\t\t\t\tszb--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\txx = (mb[szb - 1].second - a[i].second) / (a[i].first - mb[szb - 1].first);\n\t\t\t\tyy = (mb[szb - 2].second - a[i].second) / (a[i].first - mb[szb - 2].first);\n\t\t\t\tif (xx < yy)szb--;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tmb[szb] = a[i];\n\t\tszb++;\n\t}\n\tint sz, itra, itrb;\n\tvector<pair<long double, int> >c;\n\tf(i, n) {\n\t\tf(j, i) {\n\t\t\tif (abs(y[i] - y[j]) > 0.1) {\n\t\t\t\txx = (x2[j] - x1[i]) / (y[i] - y[j]);\n\t\t\t\tyy = (x1[j] - x2[i]) / (y[i] - y[j]);\n\t\t\t\tif (xx > yy)swap(xx, yy);\n\t\t\t\tc.pb({ xx + EPS,1 });\n\t\t\t\tc.pb({ yy - EPS,-1 });\n\t\t\t}\n\t\t}\n\t}\n\tint cur = 0;\n\tsort(c.begin(), c.end());\n\tsz = c.size();\n\titra = 0;\n\titrb = 0;\n\tans = 1000000000000000000;\n\tif (sz == 0) {\n\t\tans = yyy - xxx;\n\t}\n\tf(i, sz) {\n\t\tif (cur <= 1) {\n\t\t\twhile (itra < (sza - 1)) {\n\t\t\t\txx = ma[itra].first*c[i].first + ma[itra].second;\n\t\t\t\tyy = ma[itra + 1].first*c[i].first + ma[itra + 1].second;\n\t\t\t\tif (xx > yy)break;\n\t\t\t\telse itra++;\n\t\t\t}\n\t\t\twhile (itrb < (szb - 1)) {\n\t\t\t\txx = mb[itrb].first*c[i].first + mb[itrb].second;\n\t\t\t\tyy = mb[itrb + 1].first*c[i].first + mb[itrb + 1].second;\n\t\t\t\tif (xx < yy)break;\n\t\t\t\telse itrb++;\n\t\t\t}\n\t\t}\n\t\tif (cur == 0) {\n\t\t\txx = ma[itra].first*c[i].first + ma[itra].second;\n\t\t\tyy = mb[itrb].first*c[i].first + mb[itrb].second;\n\t\t\tans = min(ans, xx - yy);\n\t\t}\n\t\tcur += c[i].second;\n\t\tif (cur == 0) {\n\t\t\txx = ma[itra].first*c[i].first + ma[itra].second;\n\t\t\tyy = mb[itrb].first*c[i].first + mb[itrb].second;\n\t\t\tans = min(ans, xx - yy);\n\t\t}\n\t}\n\n\tprintf(\"%.08Lf\\n\", ans);\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "geometry",
        "sortings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Uncle Bogdan and Projections.json",
    "editorial_link": "https://codeforces.com//blog/entry/80828",
    "editorial": "It is easy to understand that there is an optimal vector at which the\r\nvalue we need is minimal and at least one pair of projections is\r\ntouching. Note also that the vector is completely described by the angle\r\nbetween it and the positive direction of the axis. If two line segments\r\nare at different heights, then there are two ways to select a vector so\r\nthat their projections touch. Let\u00e2\u0080\u0099s find two angles that describe these\r\nvectors. If we project along a vector with an angle that is in the\r\ninterval that the found two angles form, then the projections will\r\nintersect. So, this range of angles is \u00e2\u0080\u0099forbidden\u00e2\u0080\u0099. Using the scanline\r\nmethod, we can find such angles that they are the boundaries of some\r\n\u00e2\u0080\u0099forbidden\u00e2\u0080\u0099 interval and do not fall into any \u00e2\u0080\u0099forbidden\u00e2\u0080\u0099 interval. Then\r\nwe only need to check these angles.We also need to quickly find the\r\nrightmost and leftmost points for each angle. Let\u00e2\u0080\u0099s take two points at\r\ndifferent heights. Let them project to one point with a vector with an\r\nangle . Then on the interval the upper one will be to the right, and on\r\nthe interval the upper one will be to the left. We will process two\r\ntypes of requests using the scanning line: Check the answer for the\r\ncurrent angle; Swap two points. It is necessary to carefully handle the\r\ncase when, at some angle, several points are swapped. Alternative way:\r\nif you project the point along the vector with the angle , you get the\r\npoint . We\u00e2\u0080\u0099ll use the Convex Hull Trick to quickly find the rightmost\r\nand leftmost points for each angle. We will store CHT for maximums and\r\nminimums with lines . Queries at will give us the leftmost and rightmost\r\npoints.It is a corner case if all points are at the same height. Then\r\nthe answer is .Complexity of solution - .\r\n"
}