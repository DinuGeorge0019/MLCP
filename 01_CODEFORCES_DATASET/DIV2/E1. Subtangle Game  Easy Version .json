{
    "link": "https://codeforces.com//contest/2005/problem/E1",
    "problemId": "2874765",
    "problem_idx": "E1",
    "shortId": "2005E1",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "Let's say some number x\n accures in a\n more than once. Let's define by u\n and v\n the first two indexes of a\n, such that u<v\n and au=av=x\n. When a player reahces au=x\n, it is always optimal to choose such cell that after it no x\n can be choosen (there is no other x\n in the remaining submatrix). This is true, because if the player would win when choosing that \"inside\" x\n (let's call him x2\n), he would also win in that bigger matrix. But if he would lose, that means there is some number inside the submatrix left from x2\n that is winning for the other player, so the latter can choose that not depending on the opponent's choose. So, when a player reaches av\n, he will lose, which is the same as the array a\n ends there. This gives us the chance to \"stop\" array a\n at the first index where some number appears the second time.\n\nNow, as all the numbers are not greater than 7\n, we can shorten array a\n to at most 7\n elements. Then, we can keep dpk,i,j\n which shows whether the player, starting from k\n-th position of the array a\n (i.e. considering only the suffix starting at k\n, but not necessarily Tsovak has to start), will win, or not. To calculate the dp\n, we can go from the bottom-right cell of the matrix to the upper-left cell. dpk,i,j\n wins, if at least ono of these happens:\n\ni<n\n and dpk,i+1,j\n wins\n\nj<m\n and dpk,i,j+1\n wins\n\nbi,j=ak\n and (k=l\n or i=n\n or j=m\n or dpk+1,i+1,j+1\n loses)\n\nFinally, if dp1,1,1\n wins, Tsovak wins, otherwise, Narek wins.\n\nTime complexity: O(n?m)\n.",
    "name": "E1. Subtangle Game  Easy Version ",
    "statement": "Tsovak and Narek are playing a game. They have an array a and a matrix b\r\nof integers with n rows and m columns, numbered from 1. The cell in the\r\ni-th row and the j-th column is (i, j).They are looking for the elements\r\nof a in turns; Tsovak starts first. Each time a player looks for a cell\r\nin the matrix containing the current element of a (Tsovak looks for the\r\nfirst, then Narek looks for the second, etc.). Let’s say a player has\r\nchosen the cell (r, c). The next player has to choose his cell in the\r\nsubmatrix starting at (r + 1, c + 1) and ending in (n, m) (the submatrix\r\ncan be empty if r=n or c=m). If a player cannot find such a cell (or the\r\nremaining submatrix is empty) or the array ends (the previous player has\r\nchosen the last element), then he loses.Your task is to determine the\r\nwinner if the players play optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; vector < vector < pair <int , int> > > aparitii;vector < vector <int> > matrice;vector <int> sir , maxim; inline void Solve (){    int lungime , linii , coloane;    cin >> lungime >> linii >> coloane;     aparitii.resize(linii * coloane + 1);    matrice.resize(linii + 1);    sir.resize(lungime + 1);     for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[indice]; }     for (int linie = 1 ; linie <= linii ; linie++)     {        matrice[linie].resize(coloane + 1);        for (int coloana = 1 ; coloana <= coloane ; coloana++)            { cin >> matrice[linie][coloana]; }    }            for (int coloana = 1 ; coloana <= coloane ; coloana++) {        for (int linie = 1 ; linie <= linii ; linie++) {            if (!aparitii[matrice[linie][coloana]].empty() && aparitii[matrice[linie][coloana]].back().second == coloana)                { aparitii[matrice[linie][coloana]].back().first = linie; }            else                { aparitii[matrice[linie][coloana]].push_back({linie , coloana}); }        }    }         matrice.clear();    maxim.resize(coloane + 2);    for (int indice = lungime ; indice ; indice--)    {        int ramas = 0;        for (auto locatie : aparitii[sir[indice]])         {            while (ramas < locatie.second)                { maxim[++ramas] = 0; }             if (maxim[locatie.second + 1] <= locatie.first)                { maxim[ramas] = locatie.first; }        }         while (ramas < coloane)            { maxim[++ramas] = 0; }         for ( ; ramas ; ramas--)            { maxim[ramas] = max(maxim[ramas] , maxim[ramas + 1]); }    }     cout << (maxim[1] ? \"T\\n\" : \"N\\n\");     aparitii.clear();    maxim.clear();    sir.clear();} int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);     int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games",
        "greedy",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Subtangle Game  Easy Version .json",
    "hint": []
}