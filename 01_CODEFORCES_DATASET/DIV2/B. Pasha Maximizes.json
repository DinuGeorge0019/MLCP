{
    "link": "https://codeforces.com//contest/435/problem/B",
    "problemId": "9909",
    "problem_idx": "B",
    "shortId": "435B",
    "contest_number": "435",
    "problem_submissions": {
        "D": [
            6747211,
            6748926,
            6748870,
            6749244,
            6749267,
            6749555,
            6750451,
            6750474,
            6750773,
            6750608,
            6749630,
            6749229,
            6750042,
            6750327,
            6750912,
            6750822,
            6749853,
            6749690,
            6751146
        ],
        "C": [
            6744948,
            6744969,
            6752395,
            6746173,
            6746535,
            6745384,
            6746890,
            6745689,
            6745344,
            6746116,
            6747240,
            6747721,
            6745948,
            6745784,
            6747231,
            6747354,
            6745897,
            6747543,
            6745255,
            6744189
        ],
        "B": [
            6743176,
            6742784,
            6743725,
            6746058,
            6744812,
            6743216,
            6743831,
            6743565,
            6743560,
            6745917,
            6743627,
            6748909,
            6745181,
            6744428,
            6745029,
            6745253,
            6749581,
            6747847
        ],
        "A": [
            6741556,
            6741154,
            6741740,
            6746603,
            6742626,
            6741223,
            6741194,
            6742017,
            6741345,
            6742582,
            6744122,
            6741228,
            6742721,
            6741593,
            6742043,
            6744026,
            6743936,
            6741314
        ],
        "E": [
            6752027,
            6760318
        ]
    },
    "name": "B. Pasha Maximizes",
    "statement": "Pasha has a positive integer without leading zeroes. Today he decided\r\nthat the number is too small and he should make it larger.\r\nUnfortunately, the only operation Pasha can do is to swap two adjacent\r\ndecimal digits of the integer.Help Pasha count the maximum number he can\r\nget if he has the time to make at most swaps.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    char s[100];\n    int x;\n    scanf(\"%s%d\", s, &x);\n    int n = strlen(s), tot = 0;\n    for (int i = 0; i < n; i++) {\n        int to = -1;\n        for (int j = 9; j >= 0; j--) {\n            for (int k = i; k < n; k++) {\n                if (s[k] == j + '0') {\n                    to = k;\n                    break;\n                }\n            }\n            if (to == -1) continue;\n            if (tot + to - i <= x) {\n                for (int k = to - 1; k >= i; k--) {\n                    s[k + 1] = s[k];\n                }\n                tot += to - i;\n                s[i] = j + '0';\n                break;\n            }\n        }\n    }\n    puts(s);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Pasha Maximizes.json",
    "editorial_link": "https://codeforces.com//blog/entry/12479",
    "editorial": "The problem could solved by greedy algorithm. We will try to pull\r\nmaximum digits to the beginning. The algorithm could be described in\r\nthis way: 1) Consider every position in the number from the first,\r\nassume that the current position is 2) Find the nearest maximum digit\r\nfrom the next digits of the number, assume that this digit is on\r\nposition 3) If this maximum digit is greater than current digit on\r\nposition , then make series of swaps, push this digit to position , also\r\ndecrease , that is do\r\n",
    "hint": []
}