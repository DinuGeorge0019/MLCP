{
    "link": "https://codeforces.com//contest/1191/problem/F",
    "problemId": "371225",
    "problem_idx": "F",
    "shortId": "1191F",
    "contest_number": "1191",
    "problem_submissions": {
        "E": [
            56930360,
            56932667,
            56928716,
            56939088,
            56921323,
            56912974,
            57115550,
            56932804,
            56928990,
            56929337
        ],
        "F": [
            56920637,
            56922296,
            56916787,
            56919049,
            56925732,
            56927861,
            56918099,
            56924133,
            56926209,
            56927829,
            56929051,
            56926532,
            56918795,
            56929264,
            56925632
        ],
        "D": [
            56909567,
            56895679,
            56907074,
            56908396,
            56910207,
            56924101,
            56908587,
            56910537,
            56910111,
            56912606,
            56912357,
            56914322,
            56913159,
            56915287,
            56927088,
            56914751,
            56910068,
            56910772
        ],
        "C": [
            56903274,
            56901059,
            56900847,
            56901577,
            56899620,
            56896966,
            56900160,
            56902858,
            56901879,
            56903244,
            56905051,
            56904771,
            56905406,
            56905745,
            56906709,
            56903940,
            56907892,
            56901275,
            56900697
        ],
        "B": [
            56898378,
            56936114,
            56896298,
            56896362,
            56892729,
            56894831,
            56896705,
            56898252,
            56898407,
            56897313,
            56900034,
            56899250,
            56894956,
            56901112,
            56898471,
            56900914,
            56897260,
            56894862
        ],
        "A": [
            56890181,
            56923779,
            56890755,
            56890634,
            56890043,
            56890012,
            56890112,
            56897182,
            56894935,
            56890461,
            56890221,
            56891378,
            56893934,
            56889978,
            56892226,
            56896066,
            56891166,
            56896868,
            56890375
        ]
    },
    "name": "F. Tokitsukaze and Strange Rectangle",
    "statement": "There are n points on the plane, the i-th of which is at (x_i, y_i).\r\nTokitsukaze wants to draw a strange rectangular area and pick all the\r\npoints in the area.The strange area is enclosed by three lines, x = l, y\r\n= a and x = r, as its left side, its bottom side and its right side\r\nrespectively, where l, r and a can be any real numbers satisfying that l\r\n< r. The upper side of the area is boundless, which you can regard as a\r\nline parallel to the x-axis at infinity. The following figure shows a\r\nstrange rectangular area. A point (x_i, y_i) is in the strange\r\nrectangular area if and only if l < x_i < r and y_i > a. For example, in\r\nthe above figure, p_1 is in the area while p_2 is not.Tokitsukaze wants\r\nto know how many different non-empty sets she can obtain by picking all\r\nthe points in a strange rectangular area, where we think two sets are\r\ndifferent if there exists at least one point in one set of them but not\r\nin the other.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 200005;\n\nstruct point {\n\tint x,y;\n} a[N];\n\nbool cmp(const point &p,const point &q) {\n\tif (p.y==q.y) return (p.x<q.x);\n\treturn (p.y>q.y);\n}\n\nint n;\nint tot=0,tmp[N],used[N];\ninline int F(int x) {return lower_bound(tmp+1,tmp+tot+1,x)-tmp;}\n\nint sum[N];\ninline int add(int x) {\n\twhile (x<=tot) {\n\t\tsum[x]++;\n\t\tx+=x&(-x);\n\t}\n}\n\ninline int query(int x) {\n\tint ret=0;\n\twhile (x>0) {\n\t\tret+=sum[x];\n\t\tx-=x&(-x);\n\t}\n\treturn ret;\n}\n\nint main() {\n\n\tn=read(); rep(i,1,n) {a[i].x=read(),a[i].y=read(); tmp[++tot]=a[i].x;}\n\tsort(a+1,a+n+1,cmp);\n\tsort(tmp+1,tmp+tot+1);\n\ttot=unique(tmp+1,tmp+tot+1)-tmp-1;\n\trep(i,1,n) a[i].x=F(a[i].x);\n\tLL ans=0;\n\trep(i,1,n) {\n\t\tint left=query(a[i].x-1),right;\n\t\tif (i!=n&&a[i+1].y==a[i].y) right=query(a[i+1].x-1)-query(a[i].x);\n\t\telse right=query(tot)-query(a[i].x);\n\t\tans=ans+(LL)(left+1)*(LL)(right+1);\n\t\tif (!used[a[i].x]) {used[a[i].x]=1; add(a[i].x);}\n\t}\n\tprintf(\"%I64d\\n\",ans);\n\n\treturn 0;\n\t\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Tokitsukaze and Strange Rectangle.json",
    "editorial_link": "https://codeforces.com/blog/entry/68314",
    "editorial": "TutorialFor each strange rectangular area and its corresponding set of\r\npoints, we only need to focus on the lowest -coordinate , the leftmost\r\n-coordinate and the rightmost -coordinate of points in this set.\r\nDifferent sets must have different , , , so we can count them by\r\nenumerating these values.Let\u00e2\u0080\u0099s enumerate first. Then, we need to list\r\nall the possible -coordinates of points satisfying that and mark every\r\npossible satisfying there is a point . By doing so, we can make sure\r\nwhen enumerating and , the requirement for is met as well. However,\r\nenumerating forcibly, which is in time complexity , is too slow to pass,\r\nso let\u00e2\u0080\u0099s optimize the enumeration step by step.Let\u00e2\u0080\u0099s pick and sort the\r\npoints from left to right. Assuming that , and Unable to parse markup\r\n[type=CF_MATHJAX] is the leftmost point of them that is in the chosen\r\nset, we can count the number of aforementioned different -coordinates in\r\nranges and and then count the number of possible pairs immediately. More\r\nspecifically, let be the number of different -coordinates of points in\r\nthe area , and we know the number of possible pairs is . After\r\nprecalculating for each , we can reduce the time complexity into .The\r\nvery last step is using the trick of sweeping lines. We can enumerate\r\nfrom highest to lowest, and during that process, use data structures to\r\nmaintain possible -coordinates. What we need to implement is to maintain\r\na container, check if a coordinate is already in the container, add a\r\ncoordinate to the container, and query the number of coordinates in a\r\nrange. These requirements can be easily achieved by Fenwick tree,\r\nsegment tree or others. With the last optimization, we can solve in time\r\ncomplexity .By the way, there also exist solutions using other\r\napproaches, such as divide and conquer.\r\n"
}