{
    "link": "https://codeforces.com//contest/382/problem/D",
    "problemId": "5700",
    "problem_idx": "D",
    "shortId": "382D",
    "contest_number": "382",
    "problem_submissions": {
        "E": [
            5722079,
            5724986,
            5723752,
            5718812,
            5721924
        ],
        "D": [
            5718725,
            5717756,
            5717851,
            5717745,
            5719690,
            5714810,
            5721932,
            5720567,
            5722151,
            5717791,
            5721410,
            5720203,
            5719876,
            5721225
        ],
        "C": [
            5716710,
            5711942,
            5714271,
            5713299,
            5715983,
            5716064,
            5717488,
            5717351,
            5717548,
            5715922,
            5713490,
            5715750,
            5723505,
            5723844,
            5715400,
            5713682,
            5713980
        ],
        "B": [
            5715404,
            5715550,
            5712671,
            5715816,
            5713961,
            5713314,
            5719630,
            5714660,
            5714188,
            5714767,
            5717962,
            5712988,
            5721070,
            5713270,
            5717088,
            5718416,
            5713327,
            5716113,
            5717857
        ],
        "A": [
            5711555,
            5712570,
            5718543,
            5711489,
            5711959,
            5711620,
            5711695,
            5711887,
            5718283,
            5711414,
            5711584,
            5711421,
            5717859,
            5711558,
            5711377,
            5711567,
            5711709,
            5711919
        ]
    },
    "name": "D. Ksenia and Pawns",
    "statement": "Ksenia has a chessboard of size . Each cell of the chessboard contains\r\none of the characters: \"\", \"\", \"\", \"\", \"\". The cells that contain\r\ncharacter \"\" are blocked. We know that all chessboard cells that touch\r\nthe border are blocked.Ksenia is playing with two pawns on this\r\nchessboard. Initially, she puts the pawns on the chessboard. One cell of\r\nthe chessboard can contain two pawns if and only if the cell is blocked.\r\nIn other cases two pawns can not stand in one cell. The game begins when\r\nKsenia put pawns on the board. In one move, Ksenia moves each pawn to a\r\nside adjacent cell in the direction of arrows painted on the cell on\r\nwhich the corresponding pawn sits (if the pawn sits on \"\", it does not\r\nmove). Assume that Ksenia moves pawns simultaneously (see the second\r\ntest case). Of course, Ksenia plays for points. How can one calculate\r\nthe points per game? Very simply! Let’s count how many movements the\r\nfirst pawn made and how many movements the second pawn made, sum these\r\ntwo numbers it will be the resulting score of the game. Ksenia wonders:\r\nwhat is the maximum number of points she can earn (for that, she should\r\nplace the pawns optimally well early in the game). Help her and find\r\nthat number.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar s[3001][3001];\nint d[3001][3001];\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\nconst char ds[]=\">v<^\";\nbool vis[3001][3001];\nint dp[3001][3001][2];\nint n,m;\nint bfs[3001*3001][2];\nint T;\nint anss[2];\nvoid Update(int ans[],int x,int y){\n\tif(x>ans[1]){\n\t\tans[1]=x;\n\t\tif(ans[1]>ans[0]) swap(ans[1],ans[0]);\n\t\tif(y>ans[1]) ans[1]=y;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;++i) scanf(\"%s\",s[i]);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tdp[i][j][0]=0,dp[i][j][1]=-1;\n\t\tif(s[i][j]!='#'){\n\t\t\tfor(int k=0;k<4;++k) if(ds[k]==s[i][j]){\n\t\t\t\t++d[i+dx[k]][j+dy[k]];\n\t\t\t}\n\t\t}\n\t}\n\tT=-1;\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tif(!d[i][j]) ++T,bfs[T][0]=i,bfs[T][1]=j;\n\t}\n\tfor(int i=0;i<=T;++i){\n\t\tint x=bfs[i][0],y=bfs[i][1];\n\t\tif(s[x][y]=='#'){\n\t\t\tUpdate(anss,dp[x][y][0],dp[x][y][1]);\n\t\t}\n\t\telse{\n\t\t\tif(dp[x][y][0]==dp[x][y][1]) --dp[x][y][1];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tif(s[x][y]==ds[k]){\n\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\tUpdate(dp[nx][ny],dp[x][y][0]+1,dp[x][y][1]+1);\n\t\t\t\t\tif(--d[nx][ny]==0) ++T,bfs[T][0]=nx,bfs[T][1]=ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(T!=n*m-1) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",anss[0]+anss[1]);\n\tscanf(\"%d\",&n);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Ksenia and Pawns.json",
    "editorial_link": "https://codeforces.com//blog/entry/10442",
    "editorial": "In this problem from every cell except there is one next cell. Thatâs\r\nwhy this graph is almost functional graph. If this graph contains a\r\ncycle, then answer is -1 because the length of the cycle is at least\r\ntwo. In the other case, there are no cycles in the graph. Letâs find the\r\nlongest path in it, denote is as . Then is answer is at least because we\r\ncan put the two pawns in the first two cells of this path. But in some\r\ncases we could get the answer if there are two non-intersecting by\r\nvertices (not ) paths of length . They are non-intersecting because if\r\nthey intersect in some cell then they will be equal to the end (and the\r\nstatement says that such moves are invalid). So, we should check if the\r\ngraph contains two non-intersecting by vertices (not ) paths of length .\r\nIt could be done in any way. For example, using dfs searches.\r\n",
    "hint": []
}