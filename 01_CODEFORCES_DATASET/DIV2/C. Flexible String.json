{
    "link": "https://codeforces.com//contest/1778/problem/C",
    "problemId": "1760988",
    "problem_idx": "C",
    "shortId": "1778C",
    "contest_number": "1778",
    "problem_submissions": {
        "F": [
            191602138,
            191602532,
            191585447,
            191594114,
            191608712,
            191599535,
            191655210,
            191599057,
            191639606,
            191639396,
            194532248,
            191803468
        ],
        "E": [
            191585870,
            191584814,
            191630281,
            191592729,
            191585095,
            191596251,
            191595141,
            191596106,
            191592952,
            191595620,
            191594841,
            191592544,
            191599842,
            192093615,
            191596381,
            191597065,
            191595454
        ],
        "D": [
            191578502,
            191573421,
            191565024,
            191574576,
            191564042,
            191573088,
            191575933,
            191584703,
            191563224,
            191573409,
            191579570,
            191582926,
            191579755,
            191563101,
            191580474,
            191576462,
            192093593,
            191580965,
            191580785,
            191581424
        ],
        "C": [
            191564515,
            191569583,
            191570422,
            191567662,
            191567630,
            191565698,
            191566998,
            191565471,
            191569851,
            191564933,
            191565678,
            191572047,
            191565438,
            191575434,
            191578186,
            191570415,
            192093564,
            191571887,
            191568771,
            191569498
        ],
        "B": [
            191559138,
            191557434,
            191555391,
            191555255,
            191553335,
            191555438,
            191554286,
            191555414,
            191559515,
            191556063,
            191555690,
            191562726,
            191558781,
            191582547,
            191561046,
            191559475,
            192093542,
            191562296,
            191558152,
            191563075
        ],
        "A": [
            191546307,
            191548742,
            191545919,
            191546220,
            191545819,
            191546256,
            191546020,
            191545963,
            191558184,
            191545949,
            191545987,
            191550651,
            191554728,
            191565464,
            191546734,
            191548201,
            192093519,
            191547332,
            191546175,
            191551024
        ]
    },
    "name": "C. Flexible String",
    "statement": "You have a string a and a string b. Both of the strings have length n.\r\nThere are in the string a. You also have a set Q. Initially, the set Q\r\nis empty. You can apply the following operation on the string a any\r\nnumber of times: Choose an index i (1\r\nleq i\r\nleq n) and a lowercase English letter c. Add a_i to the set Q and then\r\nreplace a_i with c. For example, Let the string a be \"\r\ntt{abecca}\". We can do the following operations: In the first operation,\r\nif you choose i = 3 and c =\r\ntt{x}, the character a_3 =\r\ntt{e} will be added to the set Q. So, the set Q will be\r\n{\r\ntt{e}\r\n}, and the string a will be \"\r\ntt{ab\r\nunderline{x}cca}\". In the second operation, if you choose i = 6 and c =\r\ntt{s}, the character a_6 =\r\ntt{a} will be added to the set Q. So, the set Q will be\r\n{\r\ntt{e},\r\ntt{a}\r\n}, and the string a will be \"\r\ntt{abxcc\r\nunderline{s}}\". You can apply any number of operations on a, but in the\r\nend, the set Q should contain . Under this constraint, you have to\r\nmaximize the number of integer pairs (l, r) (1\r\nleq l\r\nleq r\r\nleq n) such that a[l,r] = b[l,r]. Here, s[l,r] means the substring of\r\nstring s starting at index l (inclusively) and ending at index r\r\n(inclusively).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n//inline int fastpow(int x, int y){\n//\tint z=1;\n//\tfor (; y; y>>=1,x=1ll*x*x%mod)\n//\t\tif (y&1) z=1ll*z*x%mod;\n//\treturn z;\n//}\nint T,n,k;\nchar a[200005],b[200005];\nint ch[100],seq[100],vis[100];\nint main(){\n\tfor (cin>>T; T; T--){\n\t\tscanf(\"%d%d%s%s\",&n,&k,a+1,b+1);\n\t\tint len=0; ll ans=0;\n\t\tfor (int i=1; i<=n; i++) vis[a[i]-'a']=1;\n\t\tfor (int i=0; i<26; i++)\n\t\t\tif (vis[i]) seq[++len]=i;\n\t\tk=min(k,len);\n\t\tfor (int i=0; i<(1<<len); i++)\n\t\t\tif (__builtin_popcount(i)==k){\n\t\t\t\tfor (int j=0; j<len; j++)\n\t\t\t\t\tif (i&(1<<j)) ch[seq[j+1]]=1;\n\t\t\t\tint pre=1; ll sum=0;\n\t\t\t\tfor (int j=1; j<=n; j++){\n\t\t\t\t\tif (a[j]!=b[j] && !ch[a[j]-'a']) pre=j+1;\n\t\t\t\t\tsum+=j-pre+1;\n\t\t\t\t}\n\t\t\t\tans=max(ans,sum);\n\t\t\t\tfor (int j=0; j<len; j++)\n\t\t\t\t\tif (i&(1<<j)) ch[seq[j+1]]=0;\n\t\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tfor (int i=0; i<26; i++) vis[i]=0;\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Flexible String.json",
    "editorial_link": "https://codeforces.com//blog/entry/112149",
    "editorial": "If we can replace all the characters of the string , we can transform\r\nthe string to the string . So, replacing more characters is always\r\nbeneficial. For a fixed string and another fixed string , if the answer\r\nis for and for , it can be shown that always satisfies.That is to say,\r\nwe can safely consider the size of the set to be the maximum limit where\r\nis the number of unique characters in the string . Now, we can generate\r\nall possible sets of characters having size . Obviously, we wonât take\r\nthe characters that are not present in the string because they have no\r\neffect on the answer. There are many ways to generate the sets, like\r\nbacktracking, bitmasking, etc. If we can calculate the number of valid\r\npairs for each set efficiently, the rest task will be just taking the\r\nmaximum of them.To calculate the number of pairs for each set\r\nefficiently, we can observe the fact that if is true, satisfies for any\r\n. So, we will get number of valid pairs from here where . Now, we can\r\nstart iterating from the beginning of the string . We can say that\r\nmatches if they are equal or exists in the currently generated set.While\r\niterating, when we are on the th index, we need to find the rightmost\r\nindex such that satisfies. Then we need to add the number of valid pairs\r\nin this range to the contribution of this set. After that, we need to\r\nset the value of to and repeat the steps again. The rest of the tasks\r\nare trivial.Time complexity: In each test case, , where\r\n",
    "hint": []
}