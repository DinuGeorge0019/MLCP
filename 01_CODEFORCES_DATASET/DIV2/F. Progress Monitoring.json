{"link": "https://codeforces.com//contest/509/problem/F", "problemId": "21542", "problem_idx": "F", "shortId": "509F", "contest_number": "509", "problem_submissions": {"F": [9650295, 9648525, 9652941, 66412652, 9656510, 9654779, 9656634], "D": [9649357, 9654774, 17987388, 9655232, 9650962, 9652519, 9653543, 9654747, 9652061, 9654982, 9653984, 9647661, 9657026, 9650855], "E": [9647331, 9646822, 9648254, 9648062, 9650747, 9650969, 9652383, 9648899, 9651327, 9650674, 9650867, 9649973, 9651180, 9649729, 9651615, 9648041, 9654967, 9654814, 9654669, 9653966, 9647539], "C": [9645828, 9652330, 9645693, 9644588, 9646725, 9649235, 9647186, 9656672, 9648094, 9645838, 9646105, 9648771, 9647552, 9649596, 9652387, 9650184, 9650446], "B": [9642318, 9650812, 9644457, 9646310, 9647229, 9643332, 9648725, 9645322, 9642950, 9643872, 9643385, 9643757, 9643187, 9643245, 9644721, 9645020, 9642364, 9643723, 9651476], "A": [9640468, 9644536, 9640418, 9640550, 9640578, 9642285, 9643656, 9644283, 9640433, 9640454, 9641139, 9641249, 9640654, 9640465, 9642716, 9641084, 9640702, 9640994, 9640877]}, "name": "F. Progress Monitoring", "statement": "Programming teacher Dmitry Olegovich is going to propose the following\r\ntask for one of his tests for students:You are given a tree with\r\nvertices, specified by its adjacency matrix . What is the output of the\r\nfollowing pseudocode?used[1 ... n] = {0, ..., 0};procedure dfs(v): print\r\nv; used[v] = 1; for i = 1, 2, ..., n: if (a[v][i] == 1 and used[i] ==\r\n0): dfs(i);dfs(1);In order to simplify the test results checking\r\nprocedure, Dmitry Olegovich decided to create a tree such that the\r\nresult is his favorite sequence . On the other hand, Dmitry Olegovich\r\ndoesn\u2019t want to provide students with same trees as input, otherwise\r\nthey might cheat. That\u2019s why Dmitry Olegovich is trying to find out the\r\nnumber of different trees such that the result of running the above\r\npseudocode with as input is exactly the sequence . Can you help him?Two\r\ntrees with vertices are called different if their adjacency matrices and\r\nare different, i. e. there exists a pair , such that and .\r\n", "solutions": ["#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\n#define ll long long \n#define pp 1000000007\n#define N 510\nll dp[N][N];\nint a[N],n;\nll mo(ll a){\n   if(a>=0 && a<pp)return a;\n   a%=pp;\n   if(a<0)a+=pp;\n   return a;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    for(int i=0;i<=n+1;i++)dp[i][i-1]=1;\n    for(int i=1;i<=n;i++)dp[i][i]=1;\n    for(int len=2;len<n;len++)\n      for(int i=1;i+len-1<=n;i++){\n        int j=i+len-1;\n        dp[i][j]=dp[i+1][j];\n        for(int k=i+1;k<=j;k++)\n          if(a[k]>a[i])dp[i][j]=mo(dp[i][j]+dp[i+1][k-1]*dp[k][j]);\n      }\n    cout<<dp[2][n]<<endl;\n    return 0;\n} \n"], "input": "", "output": "", "tags": ["dp", "trees"], "dificulty": "2300", "interactive": false}