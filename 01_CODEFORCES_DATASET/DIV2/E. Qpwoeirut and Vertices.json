{"link": "https://codeforces.com//contest/1706/problem/E", "problemId": "1466356", "problem_idx": "E", "shortId": "1706E", "contest_number": "1706", "problem_submissions": {"D2": [164755947, 164771403, 164762268, 164830322, 164783821, 164762155, 164763660, 167727726, 164763512, 164771385, 164768987, 164786591, 165109549, 164774482, 164772244, 164787948, 164789501, 164767866, 164774049, 164768972, 164786019, 164781366], "D1": [164755812, 164767814, 164760721, 164830311, 164764715, 164761873, 164763978, 167106725, 164760911, 164771592, 164764309, 164755426, 164758751, 164758461, 164759026, 164768432, 164762506, 164771653, 164768895, 164754659, 164780135], "E": [164750123, 164754977, 164771776, 164830331, 164760396, 164775552, 164750599, 167106869, 164780737, 164776992, 164776365, 164769697, 165109519, 164782832, 164784446, 164777832, 164745185, 164783769, 164782907, 164785318, 164774423, 164765688], "C": [164743602, 164744687, 164740571, 164830300, 164745917, 164752415, 164768743, 167106646, 167106607, 164749531, 164746963, 164750898, 164748957, 164751304, 164751822, 164752230, 164762906, 164749665, 164747043, 164749516, 164747945, 164752780], "B": [164740418, 164739248, 164748883, 164830286, 164740306, 164748574, 164773017, 167106480, 164740862, 164740238, 164743331, 164741485, 164741615, 164739143, 164740378, 164753096, 164741049, 164740372, 164742312, 164741022, 164745456], "A": [164734517, 164734482, 164750605, 164830274, 164734645, 164734321, 164774887, 167106382, 164735301, 164734871, 164734669, 164735191, 164734536, 164734449, 164734493, 164748128, 164735346, 164734733, 164735598, 164734982, 164735759]}, "name": "E. Qpwoeirut and Vertices", "statement": "You are given a connected undirected graph with n vertices and m edges.\r\nVertices of the graph are numbered by integers from 1 to n and edges of\r\nthe graph are numbered by integers from 1 to m.Your task is to answer q\r\nqueries, each consisting of two integers l and r. The answer to each\r\nquery is the smallest non-negative integer k such that the following\r\ncondition holds: For all pairs of integers (a, b) such that l\r\nle a\r\nle b\r\nle r, vertices a and b are reachable from one another using only the\r\nfirst k edges (that is, edges 1, 2,\r\nldots, k).\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 2e5 + 5;\n\nvector<int> vec[N];\nint st[N][18], lg[N], f[N], t[N];\nint T, n, m, q;\n\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\n\nint query(int l, int r) {\n\tint k = lg[r - l + 1];\n\treturn max(st[l][k], st[r - (1 << k) + 1][k]);\n}\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\tm = read();\n\t\tq = read();\n\t\trep(i, 1, n) f[i] = i, vec[i].clear(), vec[i].push_back(i);\n\t\trep(i, 1, m) {\n\t\t\tint u = read(), v = read();\n\t\t\tint x = find(u), y = find(v);\n\t\t\tif (x != y) {\n\t\t\t\tif (vec[x].size() > vec[y].size()) swap(x, y);\n\t\t\t\tfor (auto j: vec[x]) {\n\t\t\t\t\tif (j != 1 && find(j - 1) == y) t[j - 1] = i;\n\t\t\t\t\tif (j != n && find(j + 1) == y) t[j] = i;\n\t\t\t\t\tvec[y].push_back(j);\n\t\t\t\t}\n\t\t\t\tf[x] = y;\n\t\t\t}\n\t\t}\n\t\tlg[0] = -1;\n\t\trep(i, 1, n) lg[i] = lg[i >> 1] + 1, st[i][0] = t[i];\n\t\trep(j, 1, 17) {\n\t\t\trep(i, 1, n - (1 << j) + 1) {\n\t\t\t\tst[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t\trep(i, 1, q) {\n\t\t\tint l = read(), r = read();\n\t\t\tif (l == r) {\n\t\t\t\tprintf(\"0%c\", i == q ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tprintf(\"%d%c\", query(l, r - 1), i == q ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "divide and conquer", "dsu", "greedy", "trees"], "dificulty": "2300", "interactive": false}