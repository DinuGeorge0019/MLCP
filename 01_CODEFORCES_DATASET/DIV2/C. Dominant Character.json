{
    "link": "https://codeforces.com//contest/1605/problem/C",
    "problemId": "1182996",
    "problem_idx": "C",
    "shortId": "1605C",
    "contest_number": "1605",
    "problem_submissions": {
        "E": [
            135140556,
            135137170,
            135140149,
            135131162,
            135139425,
            135135884,
            135145750,
            135134170,
            135146319,
            135151738,
            135143897,
            135157772,
            135157112,
            135164572,
            135156916,
            135165811,
            135157373,
            135164912,
            135160322,
            135160455
        ],
        "D": [
            135123258,
            135121299,
            135126903,
            135118749,
            135131018,
            135121443,
            135128070,
            135130028,
            135134932,
            135133895,
            135133786,
            135133991,
            135133461,
            135131214,
            135138932,
            135135042,
            135138476,
            135132029,
            135132400,
            135148563
        ],
        "C": [
            135109471,
            135112911,
            135114732,
            135134429,
            135118955,
            135116544,
            135116248,
            135117340,
            135108363,
            135118939,
            135119487,
            135116822,
            135120064,
            135117077,
            135120474,
            135119518,
            135124633,
            135117200,
            135123222,
            135116741
        ],
        "B": [
            135104011,
            135105341,
            135106044,
            135104987,
            135108524,
            135104124,
            135112684,
            135116832,
            135113729,
            135109962,
            135123178,
            135110129,
            135109123,
            135109984,
            135111099,
            135109709,
            135119558,
            135106232,
            135120020,
            135107502
        ],
        "A": [
            135103035,
            135103047,
            135103241,
            135103076,
            135103421,
            135106303,
            135106513,
            135110580,
            135103745,
            135103393,
            135105600,
            135103522,
            135103862,
            135104535,
            135103487,
            135103484,
            135106186,
            135103066,
            135106006,
            135103429
        ]
    },
    "name": "C. Dominant Character",
    "statement": "Ashish has a string s of length n containing only characters ”, ” and\r\n”.He wants to find the length of the smallest substring, which satisfies\r\nthe following conditions: Length of the substring is 2 ” occurs strictly\r\nmore times in this substring than ” ” occurs strictly more times in this\r\nsubstring than ” Ashish is busy planning his next Codeforces round. Help\r\nhim solve the problem.A string a is a substring of a string b if a can\r\nbe obtained from b by deletion of several (possibly, zero or all)\r\ncharacters from the beginning and several (possibly, zero or all)\r\ncharacters from the end.\r\n",
    "solutions": [
        "// Problem: C. Dominant Character\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nchar s[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tscanf(\"%s\",s+1);\n\t\tbool flg=0;\n\t\tfor(int i=1; i<n; ++i) if(s[i]=='a'&&s[i+1]=='a')\n\t\t{\n\t\t\tflg=1;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tputs(\"2\");\n\t\t\tcontinue;\n\t\t}\n\t\tint len=n+5;\n\t\tfor(int i=1; i<=n; ++i) if(s[i]=='a')\n\t\t{\n\t\t\tint sa=0,sb=0,sc=0;\n\t\t\tfor(int j=i; j<=i+10&&j<=n; ++j)\n\t\t\t{\n\t\t\t\tif(s[j]=='a') ++sa;\n\t\t\t\telse if(s[j]=='b') ++sb;\n\t\t\t\telse ++sc;\n\t\t\t\tif(j>i&&sa>sb&&sa>sc)\n\t\t\t\t{\n\t\t\t\t\tlen=min(len,j-i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(len>n) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",len);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Dominant Character.json",
    "editorial_link": "https://codeforces.com//blog/entry/96866",
    "editorial": ": The following are all the possible minimal substrings (there arenât\r\nthat many) which satisfy the given conditions: \"\", \"\", \"\", \"\", \"\", \"\",\r\n\"\". Any other string that satisfies the condition contains at least one\r\nof these as a substring, and hence is not the optimal substring for the\r\nanswer.: If a substring exists which satisfies the given conditions,\r\nthen the length of the shortest such substring is at most . Otherwise\r\nthe solution does not exist.: Let us consider that the solution exists.\r\nWe will try to prove this by breaking this into the following cases::\r\nThere exist two such \"\" whose distance is less than or equal to , where\r\ndistance is the absolute difference of their indices. In this case where\r\nthere are two such \"\" whose distance is less than , then either these\r\ntwo \"\" are present consecutive or there is only one single letter\r\nbetween these two \"\". All these minimal substrings are \"\", \"\" and\r\n\"\"which satisfies all the given conditions.Hence we can say that the\r\nshortest length of such substring that satisfies the given conditions is\r\nat most in this case. There exists no two such \"\" whose distance is less\r\nthan or equal to . In this case all the consecutive occurrences of \"\"\r\nare present at a distance at least . Then in order for the number of \"\"\r\nto be bigger than that of \"\" and \"\" the string must look like \"\". Let us\r\ndefine \"\" as a block. Now if there is any block consisting of different\r\ncharacters \"\" or \"\" then the substring \"\" will satisfy all the given\r\nconditions and hence the minimal length will be . Notice that there must\r\nbe at least one block of \"\" and atleast one block of \"\", otherwise \"\"\r\nwill not be in a majority. Hence, there must exist 2 consecutive blocks\r\nequal to \"\" and \"\" or \"\" and \"\" in the string (otherwise all blocks\r\nwould be of the same character). Hence we can pick the substring \"\" or\r\n\"\" which satisfies the given conditions. The minimal length is,\r\ntherefore, in this case.Therefore we can say that the shortest length of\r\nsuch substring that satisfies the given conditions is at most in this\r\ncase.Thus, it suffices to only check all substrings of length up to and\r\nfind the smallest among them that satisfies the given conditions (or\r\nreport that it does not exist).:\r\n",
    "hint": [
        "Hint 1 Think about small substrings.",
        "Hint 2 What are the strings that satisfy the given conditions?",
        "Hint 3 If you got WA on pretest , then you're probably not checking length strings."
    ]
}