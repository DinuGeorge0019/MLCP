{"link": "https://codeforces.com//contest/231/problem/E", "problemId": "1910", "problem_idx": "E", "shortId": "231E", "contest_number": "231", "problem_submissions": {"E": [2315623, 2318030, 2317938, 2318674, 2318779, 2317611, 2320585, 2319865, 2321228, 2699180], "B": [2314265, 2313607, 2314034, 2314278, 2314068, 2314153, 2313828, 2314473, 2314118, 2313793, 2314083, 2313846, 2315002, 2315695, 2314096, 2316200, 2314037, 2313902], "C": [2313829, 2314125, 2314733, 2315243, 2315319, 2313875, 2315066, 2315078, 2314341, 2315041, 2314618, 2314471, 2313703, 2314701, 2313945, 2315683, 2314609], "A": [2312031, 2312037, 2312506, 2312986, 2312060, 2312377, 2312848, 2312030, 2312702, 2312166, 2312096, 2312665, 2315132, 2312576, 2312184, 2312109, 2312683, 2312307], "D": [2315039, 2315337, 2315944, 2316047, 2314614, 2314405, 2315592, 2316024, 2314917, 2314554, 2314992, 2313590, 2314889, 2315003, 2314692, 2314435, 2315454]}, "name": "E. Cactus", "statement": "A connected undirected graph is called a , if each vertex of this graph\r\nbelongs to at most one simple cycle.A in a undirected graph is a\r\nsequence of distinct vertices , such that for any exists an edge between\r\nvertices and , and also exists an edge between vertices and .A in a\r\nundirected graph is a sequence of not necessarily distinct vertices ,\r\nsuch that for any exists an edge between vertices and and furthermore\r\neach . We\u2019ll say that a simple path starts at vertex and ends at vertex\r\n.You\u2019ve got a graph consisting of vertices and edges, that is a vertex\r\ncactus. Also, you\u2019ve got a list of pairs of interesting vertices , for\r\nwhich you want to know the following information the number of distinct\r\nsimple paths that start at vertex and end at vertex . We will consider\r\ntwo simple paths distinct if the sets of edges of the paths are\r\ndistinct.For each pair of interesting vertices count the number of\r\ndistinct simple paths between them. As this number can be rather large,\r\nyou should calculate it modulo ().\r\n", "solutions": ["#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n#include<complex>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\n#define cdp(x) memset((x),-1,sizeof(x))\n#define rep(i,n) for (i=0;i<n;i++)\n#define Rep(i,a,b) for (i=a;i<=b;i++)\n#define ff(i,x) for (i=start[x];i!=-1;i=a[i].next)\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nconst int maxn=210000;\nstruct edge \n{\n    int u,v,next;\n}a[420000];\nint start[maxn],tot=0;\nint dfn[maxn],low[maxn],root,cut[maxn],n,m,stamp,pos,id[maxn],bcnt;\nint v[maxn],in[maxn];\nstruct node \n{\n    int u,v;\n}br[maxn];\nvoid init(int n)\n{\n    memset(dfn,0,sizeof(dfn[0])*(n+3));\n    memset(low,0,sizeof(low[0])*(n+3));\n    memset(cut,0,sizeof(cut[0])*(n+3));\n    memset(start,-1,sizeof(start[0])*(n+3));\n    memset(id,-1,sizeof(id[0])*(n+3));\n    memset(in,0,sizeof(in[0])*(n+3));\n    for (int i=1;i<=n+3;i++)v[i]=i;\n    bcnt=pos=tot=0;\n}\nint f1(int u)\n{\n    return u==v[u]?u:v[u]=f1(v[u]);\n}\nvoid ui(int x,int y)\n{\n    int p=f1(x),q=f1(y);\n    v[p]=q;\n}\ninline void addedge(int u,int v)\n{\n    a[tot].u=u;\n    a[tot].v=v;\n    a[tot].next=start[u];\n    start[u]=tot++;\n}\nvoid dfs(int u,int pa)\n{\n    low[u]=dfn[u]=++stamp;\n    int td=0;\n    for (int i=start[u];i!=-1;i=a[i].next)\n    {\n        int j(a[i].v);\n        if (!dfn[j])\n        {\n            td++;\n            dfs(j,u);\n            low[u]=min(low[u],low[j]);\n            if (low[j]<=dfn[u])\n            {\n                ui(u,j);\n            }\n            else \n            {\n                br[pos].u=u;\n                br[pos++].v=j;\n                //printf(\"%d %d\\n\",u,j);\n            }\n        }\n        else \n        {\n            if (j!=pa)\n            {\n                low[u]=min(low[u],dfn[j]);\n            }\n        }\n    }\n}\nvi g[maxn];\nint ct[maxn];\nvoid bcc()\n{\n    int i,j,k;\n    for (i=1;i<=n;i++)\n    {\n        int tmp=f1(i);\n        if (id[tmp]==-1)\n        {\n            id[tmp]=++bcnt;\n        }\n        id[i]=id[tmp];\n    }\n    for (i=0;i<pos;i++)\n    {\n        g[id[br[i].u]].pb(id[br[i].v]);\n        g[id[br[i].v]].pb(id[br[i].u]);\n    }\n    for (i=1;i<=n;i++)\n    {\n        ct[id[i]]++;\n    }\n}\nint deep[maxn];\nint f[maxn][19];\n\n\nvoid dd(int x,int d,int fa)\n{\n    deep[x]=d;\n    int i;\n    for (i=1;i<=18;i++)\n    {\n        if (f[x][i-1]!=-1)\n        {\n            f[x][i]=f[f[x][i-1]][i-1];\n        }\n    }\n    foreach (e,g[x])\n    {\n        if (*e==fa)continue;\n        f[*e][0]=x;\n        dd(*e,d+1,x);\n    }\n}\nint LCA(int x,int y)\n{\n    int i,j,k;\n    if (deep[x]<deep[y])swap(x,y);\n    for (i=deep[x]-deep[y],j=0;i;i>>=1,j++)\n    {\n        if (i&1)x=f[x][j];\n    }\n    i=18-1;\n    while (x!=y)\n    {\n        for (;i&&f[x][i]==f[y][i];i--);\n        x=f[x][i];y=f[y][i];\n    }\n    return x;\n}\nint dp[111111];\nvoid dc(int x,int p,int fa)\n{\n    dp[x]=p;\n    //if (x==2)printf(\"p=%d\\n\",p);\n    foreach (e,g[x])\n    {\n        if (*e==fa)continue;\n        //if (x==1)printf(\"bb %d\\n\",*e);\n        dc(*e,p+(ct[*e]>1),x);\n    }\n}\nll pp[222222];\nint main()\n{\n    int i,j,k;pp[0]=1;\n    for (i=1;i<maxn;i++)\n    {\n        pp[i]=2LL*pp[i-1];\n        pp[i]%=1000000007LL;\n    }\n    scanf(\"%d%d\",&n,&m);\n    init(n);\n        for (i=0;i<m;i++)\n        {\n            int q,w;\n            scanf(\"%d%d\",&q,&w);\n            addedge(q,w);\n            addedge(w,q);\n        }\n        int cnt=0;\n        stamp=0;\n        root=1;\n        dfs(1,-1);\n        bcc();\n    dd(1,0,-1);\n    dc(1,ct[1]>1,-1);\n    int q;scanf(\"%d\",&q);\n    //printf(\"ct[3]=%d\\n\",ct[3]);\n    while (q--)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        \n        x=id[x];\n        y=id[y];\n        int c=LCA(x,y);//printf(\"%d %d %d\\n\",x,y,c);\n        int ans=dp[x]+dp[y]-2*dp[c];\n        if (ct[c]>1)ans++;\n        //printf(\"%d %d %d\\n\",dp[x],dp[y],dp[c]);\n        /*\n        if (c!=x&&c!=y)\n        {\n            if (ct[c]>1)ans++;\n        }\n        else if (c==x||c==y)\n        {\n            if (ct[c]>1)ans++;\n        }*/\n        printf(\"%d\\n\",(int)pp[ans]);\n    }\n    return 0;\n}\n/*\n10 11\n1 2\n2 3\n3 4\n1 4\n3 5\n5 6\n8 6\n8 7\n7 6\n7 9\n9 10\n6\n3 5\n*/"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dp", "graphs", "trees"], "dificulty": "2100", "interactive": false}