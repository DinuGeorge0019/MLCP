{
    "link": "https://codeforces.com//contest/1705/problem/F",
    "problemId": "1463493",
    "problem_idx": "F",
    "shortId": "1705F",
    "contest_number": "1705",
    "problem_submissions": {
        "E": [
            164313678,
            164283877,
            164322922,
            164296635,
            164328190,
            164330200,
            182244316,
            164662858,
            164301911,
            164382357,
            164307832,
            164311215,
            164877717,
            164877334,
            164877248,
            164876250,
            164876123,
            164311471,
            164312217,
            164309954,
            164307210,
            164313972,
            164313748
        ],
        "F": [
            164297533,
            164313413,
            164317453,
            164328892,
            164293393,
            164327045,
            164284621,
            164284133,
            164291743,
            164302194,
            165132539,
            164348710,
            164323281,
            164391921
        ],
        "D": [
            164286707,
            164304717,
            164280506,
            164282817,
            164306344,
            164300946,
            164312628,
            164317244,
            164662848,
            164319640,
            164284384,
            164325926,
            164285658,
            164285757,
            164290551,
            164293318,
            164291394,
            164299908,
            164293093,
            164301425,
            164291705
        ],
        "C": [
            164281860,
            164296877,
            164275420,
            164273360,
            164295006,
            164295319,
            164301269,
            164662833,
            164288918,
            164274715,
            164280149,
            164277014,
            164275688,
            165102447,
            164283971,
            164282615,
            164282594,
            164274835,
            164277444,
            164285515,
            164285435
        ],
        "B": [
            164273413,
            164289760,
            164270705,
            164266717,
            164276123,
            164275997,
            164276303,
            164274236,
            164662822,
            164269128,
            164268180,
            164273865,
            164270610,
            164270505,
            164271837,
            164271931,
            164276822,
            164279085,
            164272358,
            164272892,
            164272828
        ],
        "A": [
            164266986,
            164279867,
            164266709,
            164265172,
            164267444,
            164266906,
            164267475,
            164265741,
            164662806,
            164278230,
            164265167,
            164265698,
            164265336,
            164266101,
            164266312,
            164265878,
            164265963,
            164265319,
            164267659,
            164267039,
            164266626
        ]
    },
    "name": "F. Mark and the Online Exam",
    "statement": "Mark is administering an online exam consisting of n true-false\r\nquestions. However, he has lost all answer keys. He needs a way to\r\nretrieve the answers before his client gets infuriated.Fortunately, he\r\nhas access to the grading system. Thus, for each query, you can input\r\nthe answers to all n questions, and the grading system will output how\r\nmany of them are correct.He doesn’t have much time, so he can use the\r\ngrading system at most 675 times. Help Mark determine the answer\r\nkeys.Note that answer keys are fixed in advance and will not change\r\ndepending on your queries.\r\n",
    "solutions": [
        "//link:https://www.luogu.com.cn/blog/1973224568qq/kao-shi-2021-coe-iii-d\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i, n) for (int i = 0, _n = n; i < _n; i++)\n#define pb push_back\ntypedef vector <int> vi;\ntypedef vector <vi> vii;\n\nvii A[15];\n\nvoid gA(int m) {\n    if (m == 0) {\n        A[0] = {{1}};\n        return ;\n    }\n    vii &L = A[m - 1], &R = A[m];\n    forn(i, L.size()) {\n        vi t;\n        forn(j, L[i].size()) t.pb(L[i][j]);\n        forn(j, L[i].size()) t.pb(-L[i][j]);\n        forn(j, L.size()) t.pb(i == j);\n        R.pb(t);\n    }\n    forn(i, L.size()) {\n        vi t;\n        forn(j, L[i].size()) t.pb(L[i][j]);\n        forn(j, L[i].size()) t.pb(L[i][j]);\n        forn(j, L.size()) t.pb(0);\n        R.pb(t);\n    }\n}\n\nvi operator + (vi x, vi y) {\n    x.insert(x.end(), y.begin(), y.end());\n    return x;\n}\n\nvi dA(int m, vi r) {\n    if (m == 0) {\n        return r;\n    }\n    int l = A[m - 1].size();\n    vi x, y, z;\n    for (int i = 0; i < l; i++) {\n        z.pb(((r[i] + r[l + i]) % 2 + 2) % 2);\n        x.pb((r[l + i] + (r[i] - z[i])) / 2);\n        y.pb((r[l + i] - (r[i] - z[i])) / 2);\n    }\n    return dA(m - 1, x) + dA(m - 1, y) + z;\n}\n\nvii B[15];\n\nvoid gB(int m) {\n    if (m == 1) {\n        B[1] = {{1}, {0}};\n        return ;\n    }\n    vii &L = B[m - 1], &V = A[m - 1], &R = B[m];\n    forn(i, L.size()) {\n        vi t;\n        forn(j, L[i].size()) t.pb(L[i][j]);\n        forn(j, V[i].size()) t.pb(V[i][j] == 1);\n        R.pb(t);\n    }\n    forn(i, L.size()) {\n        vi t;\n        forn(j, L[i].size()) t.pb(L[i][j]);\n        forn(j, V[i].size()) t.pb(V[i][j] == -1);\n        R.pb(t);\n    }\n}\n\nvi dB(int m, vi r) {\n    if (m == 1) {\n        return {r[0]};\n    }\n    int l = B[m - 1].size();\n    vi x, y;\n    for (int i = 0; i < l; i++) {\n        x.pb(r[i] - r[l + i]);\n    }\n    x = dA(m - 1, x);\n    for (int i = 0; i < l; i++) {\n        int t = r[i];\n        for (int j = 0; j < (int)x.size(); j++) {\n            t -= x[j] * (A[m - 1][i][j] == 1);\n        }\n        y.pb(t);\n    }\n    y = dB(m - 1, y);\n    return y + x;\n}\n\nint n;\ndouble K;\n\nint query(vi A) {\n    string S;\n    for (int i = 0; i < n; i++)\n        S += \"TF\"[A[i]];\n    printf(\"%s\\n\", S.c_str());\n    fflush(stdout);\n\n    int res;\n    scanf(\"%d\", &res);\n    if (res == n) exit(0);\n    return res;\n}\n\nint popcnt(vi x) {\n    int c = 0;\n    for (auto i : x) c += i;\n    return c;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < 11; i++) gA(i);\n    for (int i = 1; i < 11; i++) gB(i);\n    int c = 1;\n    while (B[c][0].size() < n) c++;\n\n    vi ret;\n    ret.clear();\n    for (int i = 0; i < B[c].size(); i++) {\n        ret.pb(query(B[c][i]));\n    }\n    int lst = ret.back();\n    for (int i = 0; i < B[c].size(); i++) {\n        ret[i] = (ret[i] - lst + popcnt(B[c][i])) / 2;\n    }\n\n    vi ans = dB(c, ret);\n    query(ans);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "interactive",
        "probabilities"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mark and the Online Exam.json",
    "editorial_link": "https://codeforces.com//blog/entry/104881",
    "editorial": "TutorialThere are many possible approaches, including using randomized\r\nalgorithms. However, I will present the solution that takes about\r\nqueries deterministically.We pre-query and . Then, for , we take the\r\ndifference when both the -th and the -th question in is changed to . If\r\nthe difference is , then both answers must be . If the difference is ,\r\nthen both answers must be . Else, the answers must be or in some order.\r\nNow, here is the key idea: if the last case happens, then we can figure\r\nout if itâs or as well as the answer to one more question in one query.\r\nTo do so, compare the previous with a new query that has differences:\r\n(Note: we assume that the third question corresponds to in the query. If\r\nitâs , just change to and proceed analogously.)There are four possible\r\nscenarios. If the answers are and , then the difference is . If the\r\nanswers are and , then the difference is . If the answers are and , then\r\nthe difference is . If the answers are and , then the difference is .\r\nTherefore, we can distinguish these four scenarios in one go.Finally, if\r\nthe first two cases happen, we can easily figure out the answer to one\r\nmore question in one query (say, by changing that question to and\r\ncompare with the query). Either way, we can deduce the answer to\r\nquestions in queries, leading to a solution with queries.Note that this\r\nsolution can be easily improved to on average by randomly shuffling the\r\nquestions.\r\n",
    "hint": [
        "Hint 0 It's possible to solve this problem without any randomization. See the subsequent hints for how to do so.",
        "Hint 1 Observe that we can take differences between two very close queries to get the number of 's in a small subsequence.",
        "Hint 2 You can take the difference against a pre-computed query. Applying this with a group of two questions.",
        "Hint 3 You have three possibilities: either , , and . If the third possibility happens, simultaneously figure out whether is or and answer one question within one query.",
        "Hint 4 You will need to precompute the query ."
    ]
}