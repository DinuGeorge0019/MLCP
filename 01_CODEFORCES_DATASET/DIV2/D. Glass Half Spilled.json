{"link": "https://codeforces.com//contest/1459/problem/D", "problemId": "837951", "problem_idx": "D", "shortId": "1459D", "contest_number": "1459", "problem_submissions": {"C": [101746653, 101722886, 101730123, 101721760, 101730712, 101728008, 101731166, 101730952, 101740001, 101726009, 101726762, 101728277, 101727158, 101729187, 101723361, 101723810, 101728376, 101726644, 101732897, 101727240], "E": [101738323, 101839753, 102232354, 101778763], "D": [101727682, 101736410, 101735995, 101740518, 101738063, 101735219, 101739686, 101738152, 101733975, 101740963, 101743516, 101745649, 101741362, 101744865, 101740597, 101748885, 101751093, 101741581, 101747404, 101748856], "B": [101727154, 101727768, 101730156, 101728078, 101737211, 101728162, 101729594, 101812219, 101721826, 101733013, 101722434, 101734872, 101735665, 101845089, 101726205, 101744534, 101734571, 101725649, 101745878, 101729907, 101738583], "A": [101719213, 101723947, 101718569, 101719365, 101718481, 101720960, 101718492, 101812211, 101718737, 101720191, 101718915, 101722560, 101731743, 101845090, 101719378, 101727785, 101719966, 101719274, 101731147, 101726149, 101719284], "F": [101844942]}, "name": "D. Glass Half Spilled", "statement": "There are n glasses on the table numbered 1,\r\nldots, n. The glass i can hold up to a_i units of water, and currently\r\ncontains b_i units of water.You would like to choose k glasses and\r\ncollect as much water in them as possible. To that effect you can pour\r\nwater from one glass to another as many times as you like. However,\r\nbecause of the glasses\u2019 awkward shape (and totally unrelated to your\r\nnatural clumsiness), each time you try to transfer any amount of water,\r\nhalf of the amount is spilled on the floor.Formally, suppose a glass i\r\ncurrently contains c_i units of water, and a glass j contains c_j units\r\nof water. Suppose you try to transfer x units from glass i to glass j\r\n(naturally, x can not exceed c_i). Then, x / 2 units is spilled on the\r\nfloor. After the transfer is done, the glass i will contain c_i - x\r\nunits, and the glass j will contain\r\nmin(a_j, c_j + x / 2) units (excess water that doesn\u2019t fit in the glass\r\nis also spilled).Each time you transfer water, you can arbitrarlly\r\nchoose from which glass i to which glass j to pour, and also the amount\r\nx transferred can be any positive real number.For each k = 1,\r\nldots, n, determine the largest possible total amount of water that can\r\nbe collected in arbitrarily chosen k glasses after transferring water\r\nbetween glasses zero or more times.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n#include <ext/rope>\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization(\"unroll-loops, no-stack-protector\")\n#pragma GCC target(\"avx,avx2,fma\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define gcd __gcd\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define rep1(i, n) for (int i=1; i<=(n); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define endl \"\\n\"\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned uint;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntemplate<typename T, typename cmp = less<T>>\nusing ordered_set=tree<T, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef trie<string, null_type, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update> pref_trie;\n\ntemplate<typename T, typename U>\nvoid ckmax(T& a, U b) {a=a<b?b:a;}\n\nconstexpr int16_t N=105, M=105;\nint16_t dp[N][N*M];\n\nint32_t main() {\n    fastio;\n    int n; cin>>n;\n    memset(dp, -1, sizeof(dp));\n    dp[0][0]=0;\n    int16_t sa=0, sb=0;\n    rep(c, n) {\n        int16_t a, b; cin>>a>>b;\n        for(auto i=c; ~i; i--) {\n            for(auto j=sa; ~j; j--) {\n                if(~dp[i][j]) ckmax(dp[i+1][j+a], dp[i][j]+b);\n            }\n        }\n        sa+=a, sb+=b;\n    }\n    rep1(i, n) {\n        int16_t ans=0;\n        rep(j, sa+1) if(~dp[i][j]) ckmax(ans, min(2*j, dp[i][j]+sb));\n        cout<<ans/2<<(ans&1?\".5 \":\" \");\n    }\n    cout<<endl;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp"], "dificulty": "2000", "interactive": false}