{
    "link": "https://codeforces.com//contest/1981/problem/E",
    "problemId": "2672993",
    "problem_idx": "E",
    "shortId": "1981E",
    "contest_number": "1981",
    "problem_submissions": {
        "F": [
            263497142,
            263559226
        ],
        "E": [
            263476287,
            263464534,
            263479972,
            263479996,
            263481278,
            263484948,
            263487311,
            263488586,
            263490466,
            263488413,
            263485273,
            263486361,
            263491158,
            263492494,
            263487751,
            263490431,
            263594935,
            263475669,
            263731983
        ],
        "D": [
            263469280,
            263482604,
            263470136,
            263467974,
            263476735,
            263476815,
            263475122,
            263473573,
            263468370,
            263465514,
            263477018,
            263481941,
            263480436,
            263478668,
            263478475,
            263485875,
            263469409,
            263472129,
            263470882
        ],
        "C": [
            263456919,
            263468416,
            263459011,
            263454953,
            263461770,
            263457891,
            263464609,
            263463038,
            263456449,
            263472358,
            263463129,
            263464204,
            263463482,
            263460745,
            263470157,
            263458930,
            263460066,
            263458494,
            263461448
        ],
        "B": [
            263449078,
            263456587,
            263450957,
            263448611,
            263450566,
            263450086,
            263449888,
            263451971,
            263448293,
            263451226,
            263454153,
            263455701,
            263455723,
            263449188,
            263455405,
            263451294,
            263451169,
            263449953,
            263456283
        ],
        "A": [
            263445832,
            263446092,
            263445924,
            263445701,
            263447399,
            263445953,
            263446026,
            263448629,
            263445764,
            263445931,
            263446308,
            263445723,
            263447638,
            263446507,
            263449757,
            263445656,
            263446328,
            263445901,
            263446447
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129848",
    "editorial": "We observe that for three segments where each pair of segments\r\nintersects (assume ), we only need to keep the edges between and ,\r\nbecause and for every cycle in a graph, the edge with the maximum weight\r\nwill not appear in the minimum spanning tree.Therefore, consider the\r\nfollowing scanline process: each segment is added at and removed at .\r\nWhen adding a segment, find its predecessor and successor in the order\r\nsorted by and connect edges accordingly. Essentially, we maintain all\r\nthe segments that exist at each moment as a chain sorted by .It is easy\r\nto see that after the scanline process, the number of edges is reduced\r\nto . Then we can directly compute the minimum spanning tree.Time\r\ncomplexity: per test case.\r\n",
    "name": "E. Turtle and Intersected Segments",
    "statement": "Turtle just received n segments and a sequence a_1, a_2,\r\nldots, a_n. The i-th segment is [l_i, r_i].Turtle will create an\r\nundirected graph G. If segment i and segment j intersect, then Turtle\r\nwill add an undirected edge between i and j with a weight of |a_i -\r\na_j|, for every i\r\nne j.Turtle wants you to calculate the sum of the weights of the edges\r\nof the minimum spanning tree of the graph G, or report that the graph G\r\nhas no spanning tree.We say two segments [l_1, r_1] and [l_2, r_2]\r\nintersect if and only if\r\nmax(l_1, l_2)\r\nle\r\nmin(r_1, r_2).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define LL long long#define LLL __int128#define uint unsigned#define ldb long double#define uLL unsigned long longusing namespace std;struct node{    int l,r;    mutable int v;    node(int _l,int _r=0,int _v=0):l(_l),r(_r),v(_v){}    bool operator<(const node &o)const{return l<o.l;}};set<node>S;typedef set<node>::iterator sit;sit split(int pos){\tsit it=S.lower_bound(node(pos));\tif(it!=S.end()&&it->l==pos)return it;\tit--;\tif(it->r<pos)return S.end();\tint l=it->l,r=it->r,v=it->v;\tS.erase(it);\tS.insert(node(l,pos-1,v));\treturn S.insert(node(pos,r,v)).first;}const int N=5e5+5;int fd[N];inline int find(const int&x){return fd[x]==x?x:fd[x]=find(fd[x]);}inline void MAIN(){\tS.clear();\tS.emplace(1,1e9,-1);\tint n;cin>>n;LL ans=0;\tvector<tuple<int,int,int>>E(n),Q;\tfor(auto&[w,l,r]:E)cin>>l>>r>>w;\tsort(E.begin(),E.end());\tfor(int i=0;i<n;++i){\t\tconst auto&[w,l,r]=E[i];\t\tconst auto R=split(r+1),L=split(l);\t\tfor(auto it=L;it!=R;++it)if(~it->v)Q.emplace_back(w-get<0>(E[it->v]),it->v,i);\t\tS.erase(L,R),S.emplace(l,r,i);\t}\tsort(Q.begin(),Q.end());\tiota(fd,fd+n,0);int cnt=0;\tfor(auto&[w,x,y]:Q){\t\tif(find(x)!=find(y)){\t\t\tfd[find(x)]=find(y),ans+=w,++cnt;\t\t}\t}\tcout<<(cnt<n-1?-1:ans)<<'\\n';}signed main(){    cin.tie(0)->sync_with_stdio(0);\tint t=1;cin>>t;while(t--)MAIN();    return 0;}/**/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Turtle and Intersected Segments.json",
    "hint": [
        "Hint 1 Stop thinking about Boruvka.",
        "Hint 2 Most of the edges in the graph are useless."
    ]
}