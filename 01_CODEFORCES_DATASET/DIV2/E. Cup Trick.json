{
    "link": "https://codeforces.com//contest/421/problem/E",
    "problemId": "8697",
    "problem_idx": "E",
    "shortId": "421E",
    "contest_number": "421",
    "problem_submissions": {
        "D": [
            6443401,
            6444205,
            6444726,
            6446063,
            6446478,
            6446284,
            6446050,
            6444829,
            6454312,
            6446753,
            6445453,
            6450944,
            6450576,
            6450561,
            6443659,
            6449123,
            6444238,
            6451898,
            6452897,
            6444608
        ],
        "E": [
            6445907,
            6454320,
            6451461,
            6451356
        ],
        "B": [
            6441973,
            6441563,
            6441704,
            6441641,
            6441800,
            6442174,
            6441468,
            6441877,
            6442830,
            6440426,
            6441645,
            6441812,
            6441558,
            6441555,
            6441997,
            6441532,
            6442176,
            6442193
        ],
        "A": [
            6440466,
            6440550,
            6440945,
            6440732,
            6440837,
            6440790,
            6440596,
            6440584,
            6445521,
            6440258,
            6440321,
            6440470,
            6440634,
            6440611,
            6440374,
            6440525,
            6440392,
            6440664
        ],
        "C": [
            6445332,
            6444054,
            6443650,
            6444031,
            6444561,
            6446258,
            6444406,
            6445050,
            6443582,
            6444686,
            6444343,
            6444298,
            6443933,
            6444277,
            6449346
        ]
    },
    "name": "E. Cup Trick",
    "statement": "The employees of the F company have lots of ways to entertain\r\nthemselves. Today they invited a famous magician who shows a trick with\r\nplastic cups and a marble.The point is to trick the spectator’s\r\nattention. Initially, the spectator stands in front of a line of plastic\r\ncups. Then the magician places a small marble under one cup and shuffles\r\nthe cups. Then the spectator should guess which cup hides the marble.But\r\nthe head coder of the F company isn’t easy to trick. When he saw the\r\nperformance, he noticed several important facts: each cup contains a\r\nmark a number from to ; all marks on the cups are distinct; the magician\r\nshuffles the cups in operations, each operation looks like that: take a\r\ncup marked , sitting at position in the row of cups (the positions are\r\nnumbered from left to right, starting from 1) and shift it to the very\r\nbeginning of the cup row (on the first position). When the head coder\r\ncame home after work he wanted to re-do the trick. Unfortunately, he\r\ndidn’t remember the starting or the final position of the cups. He only\r\nremembered which operations the magician performed. Help the coder:\r\ngiven the operations in the order they were made find at least one\r\ninitial permutation of the cups that can go through the described\r\noperations in the given order. Otherwise, state that such permutation\r\ndoesn’t exist.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n\n#define ms(x) memset(x,0,sizeof(x)) \n#define For(a,b,c) for(int a = b ; a <= c ; a ++ )\n#define int64 long long \n#define real long double\n#define SZ size()\n\nint getint(){\n    char ch = getchar() ; int ret = 0 ; bool flag = true ; \n    while(( ch < '0' || ch > '9' ) && ch != '-' ) ch = getchar() ; \n    if( ch == '-' ) flag = false , ch = getchar() ; \n    while( ch >= '0' && ch <= '9' ) ret = ret * 10 + ch - '0' , ch = getchar() ;  \n    return flag ? ret : - ret ; \n}\n\nusing namespace std ; \nconst int MAXN = (int) 1e6 + 10000 ; \ntypedef int arr32[MAXN] ; \n\narr32 l , r , c , ok , size , id , w , bel ; \nint n , m ; \n\nstruct node{\n  int x , y ; \n} ; \n\nvoid update(int x){ size[x] = size[l[x]] + size[r[x]] + 1 ; }\n\nint merge(int x , int y){\n  if(!x || !y) return x + y ; \n  int t ; \n  if(w[x] > w[y]) r[x] = merge(r[x] , y) , update(x) , t = x ; \n  else l[y] = merge(x , l[y]) , update(y) , t = y ; \n  return t ; \n}\n\nnode split(int x , int k){\n  if(!k) return (node){ 0 , x } ; \n  int cnt = k - size[l[x]] - 1 ; \n  if(cnt >= 0){\n     node s = split(r[x] , cnt) ; \n     r[x] = s.x ; update(x) ;\n     return (node){ x , s.y } ; \n  }else{\n     node s = split(l[x] , k) ; \n     l[x] = s.y ; update(x) ; \n     return (node){ s.x , x } ; \n  }\n}\n\nint find(int x , int k){\n  int cnt = size[l[x]] + 1 ; \n  if(k == cnt) return x ; \n  if(k < cnt) return find(l[x] , k) ; \n  else return find(r[x] , k - cnt) ; \n}\n\nconst int mo = (int) 1e9 ; \nint64 ax[MAXN] , ay[MAXN] ; \nint root ; \n\nint main(){\n \n   \n   cin >> n >> m ; \n   ax[0] = ay[0] = 1 ; \n   for(int i = 1 ; i <= n ; i ++ ) ax[i] = ax[i - 1] * 1023 % mo , ay[i] = ay[i - 1] * 1025 % mo ; \n   for(int i = 1 ; i <= n ; i ++ ) w[i] = ax[i] ^ ay[i] ; \n   for(int i = 1 ; i <= n ; i ++ ) id[i] = i , c[i] = 0 , size[i] = 1 , root = merge(root , i) ;\n    \n   int x , y ; \n   \n   for(int i = 1 ; i <= m ; i ++ ){\n     scanf(\"%d %d\",&x,&y) ; \n     int t = find(root , y) ; \n     if((c[id[t]] && c[id[t]] != x) || ( bel[x] && id[t] != bel[x])) return puts(\"-1\") , 0 ; \n     if(!c[id[t]]) c[id[t]] = x , bel[x] = id[t] ; \n     node a = split(root , y ) ; \n     node b = split(a.x , y - 1) ;\n     root = merge(b.y , b.x) ; \n     root = merge(root , a.y) ; \n   }\n   \n   for(int i = 1 ; i <= n ; i ++ ) if(c[i]) ok[c[i]] = 1 ; \n   int now = 1 ; \n   for(int i = 1 ; i <= n ; i ++ )if(!c[i]){\n     while(ok[now]) now ++ ; \n     c[i] = now ; \n     ok[now] = 1 ; \n   }\n   \n   for(int i = 1 ; i <= n ; i ++ ) printf(\"%d \",c[i]) ; \n   return 0 ; \n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cup Trick.json",
    "editorial_link": "https://codeforces.com//blog/entry/11871",
    "editorial": "The solution consists of two parts.\n\n1) Find the valid permutation.\n\nLet's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.\n\nSuppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1?<?b2?<?...?<?bk). After every query the number from that query goes to the begging of the permutation, so all ai (1???i???k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p?+?x?=?b, where x is the number of such bi that bi?>?p.\n\nWe can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg?+?xrg???b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p?+?x?=?b. If this equation isn't correct then the answer is ?-?1.\n\n2) Check that the sequence of the operations is correct.\n\nLet's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j?<?i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j?+?1,?i?-?1]. We should get exactly b?-?1.",
    "hint": []
}