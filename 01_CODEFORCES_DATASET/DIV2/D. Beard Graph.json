{
    "link": "https://codeforces.com//contest/165/problem/D",
    "problemId": "1015",
    "problem_idx": "D",
    "shortId": "165D",
    "contest_number": "165",
    "problem_submissions": {
        "D": [
            1366499,
            1366969,
            1365112,
            1367097,
            1366684,
            1365807,
            1365962,
            1368726,
            1367643,
            1365427,
            1364667,
            1370595,
            1385240
        ],
        "E": [
            1364192,
            1364774,
            1367313,
            1365367,
            1364379,
            1368630,
            1368754,
            1367792,
            1368549,
            1365271,
            1364231,
            1368793,
            1367116,
            2473344,
            1366372,
            1367247,
            1366533,
            1367425
        ],
        "C": [
            1362928,
            1363517,
            1362594,
            1363696,
            1366879,
            1362613,
            1362246,
            1363281,
            1364362,
            1363392,
            1367553,
            1369077,
            1364690,
            2473167,
            2473156,
            1362666,
            1363958,
            1364223,
            1365162,
            1365345
        ],
        "B": [
            1362163,
            1362376,
            1365799,
            1362605,
            1362500,
            1363337,
            1362770,
            1362069,
            1363813,
            1363948,
            1362915,
            1369003,
            1362557,
            2473004,
            2473001,
            2472997,
            1362110,
            1362242,
            1362516,
            1363280,
            1362708
        ],
        "A": [
            1361696,
            1361752,
            1362836,
            1361758,
            1361587,
            1361647,
            1361570,
            1361606,
            1362825,
            1365691,
            1361805,
            1362263,
            1361965,
            2472978,
            2472975,
            2472970,
            1361665,
            1361602,
            1361734,
            1362468,
            1361751
        ]
    },
    "name": "D. Beard Graph",
    "statement": "Let’s define a non-oriented connected graph of vertices and edges as a ,\r\nif all of its vertices except, perhaps, one, have the degree of 2 or 1\r\n(that is, there exists no more than one vertex, whose degree is more\r\nthan two). Let us remind you that the degree of a vertex is the number\r\nof edges that connect to it. Let each edge be either black or white.\r\nInitially all edges are black.You are given the description of the beard\r\ngraph. Your task is to analyze requests of the following types: paint\r\nthe edge number black. The edge number is the edge that has this number\r\nin the description. It is guaranteed that by the moment of this request\r\nthe -th edge is white paint the edge number white. It is guaranteed that\r\nby the moment of this request the -th edge is black find the length of\r\nthe shortest path going between vertices and or indicate that no such\r\npath exists between them (a path’s length is the number of edges in it)\r\nThe vertices are numbered with integers from to , and the edges are\r\nnumbered with integers from to .\r\n",
    "solutions": [
        "#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define two(w) (1<<(w))\n#define test(x,w) (x&two(w))\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\n\n\n#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n\n#define maxn 110000\n\n\nstruct Node{\n\tbool all;\n\t//\n\tint l,r;\n\tNode *ls,*rs; //���Ҷ���\n\tvoid init(int _l,int _r){\n\t\tl=_l,r=_r; ls=rs=NULL; all=true;\n\t}\n\tint mid(){ return (l+r)>>1; }\n\tint len(){ return (r-l+1); }\n\t\n\tvoid update(){ //��֤�ж���\n\t\tif( ls->all && rs->all ) all=true;\n\t\telse all=false;\n\t}\n\tvoid modify(int id){\n\t\tif( l==r){\n\t\t\tall=!all;\n\t\t\treturn;\n\t\t}\n\t\tif( id<=mid() ) ls->modify(id);\n\t\telse rs->modify(id);\n\t\t\n\t\tupdate();\n\t}\n\tbool query(int a,int b){\n\t\tif( l==a && r==b ) return all;\n\t\t\n\t\tif( b<=mid() ) return ls->query(a,b);\n\t\telse if( a>mid() ) return rs->query(a,b);\n\t\telse {\n\t\t\treturn ls->query(a,mid()) && rs->query(mid()+1,b);\n\t\t}\n\t}\n}dd[maxn*10];\n\nint e; \nNode* _alloc(int l,int r) { dd[e].init(l,r); return &dd[e++]; }\nNode* _make(int l,int r){\n\tNode* p=_alloc(l,r);\n\tif( l==r ) \n\t\treturn p; \n\tp->ls=_make(l,p->mid());\n\tp->rs=_make(p->mid()+1,r);\n\tp->update();\n\treturn p;\n}\n\nPII edges[maxn];\nVI adj[maxn];\nbool vst[maxn];\n\n\nint rt, dep[maxn];\nNode* bel[maxn];\n\nVI path;\nvoid dfs(int u){\n\twhile( true ){\n\t\tpath.PB(u);\n\t\tvst[u]=true;\n\t\tint ttt=u;\n\t\trepv(i, adj[u] ){\n\t\t\tint v=adj[u][i];\n\t\t\tif( vst[v] ) continue;\n\t\t\tu=v; break;\n\t\t}\n\t\tif( u==ttt ) break;\n\t}\n}\nint main(){\n\tint n, Q;\n\twhile( scanf(\"%d\",&n)!=EOF ){\n\t\te=0; //\n\t\trep(i, 1, n+1) adj[i].clear();\n\t\t\n\t\trep(i, 1, n){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tedges[i]=MP(a, b);\n\t\t\tadj[a].PB(b);\n\t\t\tadj[b].PB(a);\n\t\t}\n\t\tint ma=0;\n\t\trep(i, 1, n+1){\n\t\t\tif( sz(adj[i]) > ma ){\n\t\t\t\tma=sz(adj[i]);\n\t\t\t\trt=i;\n\t\t\t}\n\t\t}\n\t\t//printf(\"rt=%d\\n\", rt);\n\t\tclr(vst, false);\n\t\tvst[rt]=true; dep[rt]=0;\n\t\trepv(i, adj[rt] ){\n\t\t\tpath.clear();\n\t\t\tdfs( adj[rt][i] );\n\t\t\tNode *root=_make(1, sz(path));\n\t\t\trepv(j, path){\n\t\t\t\t//printf(\"%d \", path[j]);\n\t\t\t\tdep[ path[j] ]=j+1;\n\t\t\t\tbel[ path[j] ]=root;\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\tscanf(\"%d\", &Q);\n\t\twhile( Q-- ){\n\t\t\tint op;\n\t\t\tscanf(\"%d\", &op);\n\t\t\tif( op<=2 ){\n\t\t\t\tint eid; scanf(\"%d\", &eid);\n\t\t\t\tint a=edges[ eid ].ff;\n\t\t\t\tint b=edges[ eid ].ss;\n\t\t\t\tif( dep[a]<dep[b] ) swap(a, b);\n\t\t\t\tbel[a]->modify(dep[a]);\n\t\t\t}else{\n\t\t\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\t\t\tif( u==v ){\n\t\t\t\t\tputs(\"0\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( dep[u]>dep[v] ) swap(u, v);\n\t\t\t\tif( u==rt ){\n\t\t\t\t\tif( bel[v]->query(1, dep[v]) ){\n\t\t\t\t\t\tprintf(\"%d\\n\", dep[v]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}else if( bel[u]==bel[v] ){\n\t\t\t\t\tif( bel[v]->query(dep[u]+1, dep[v]) ){\n\t\t\t\t\t\tprintf(\"%d\\n\", dep[v]-dep[u]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( bel[u]->query(1, dep[u]) && bel[v]->query(1, dep[v]) ){\n\t\t\t\t\t\tprintf(\"%d\\n\", dep[u]+dep[v]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Beard Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/4124",
    "editorial": "Beard-graph is a tree. It consists of one root and several paths from\r\nthis root. There is a single path between every pair of vertices. Thatâs\r\nwhy you should check whether every edge on the path between two vertices\r\nis black. If some edge is white there is no path between two vertices\r\nnow. The distances could be found separately. For every vertex precalc\r\nsuch information: index of path from the root where is situated and\r\ndistance between root and . If you know such information you can find\r\ndistance between any two vertices. To check whether every edge on the\r\npath between two vertices is black we will use segment tree. Mark black\r\nedge with value and white with . Than repainting some edge update in\r\nsome point. The query sum on some segment (the path between two\r\nvertices). If the sum equals to there is a single path. Else the answer\r\nis -1 now. Complexity is .\r\n",
    "hint": []
}