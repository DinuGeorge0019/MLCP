{"link": "https://codeforces.com//contest/534/problem/E", "problemId": "25994", "problem_idx": "E", "shortId": "534E", "contest_number": "534", "problem_submissions": {"E": [10683933, 10683934], "D": [10678175, 10678621, 10677106, 10675536, 10676106, 10674810, 10677903, 10677747, 10679006, 10677924, 10680207, 10678552, 10679589, 10680738, 10678781, 10678817, 10680761], "C": [10671852, 10674805, 10673233, 10673070, 10671645, 10677139, 10673078, 10674877, 10676809, 10674952, 10672887, 10676606, 10670002, 10674948, 10676024, 10676008, 10674748], "B": [10669948, 10673036, 10671795, 10670663, 10670379, 10671586, 10670885, 10672541, 10673957, 10673051, 10670344, 10673862, 10674029, 10669586, 10673422, 10671966, 10672486], "A": [10669180, 10670286, 10669409, 10669242, 10669361, 10670184, 10669504, 10669859, 10671143, 10670792, 10669355, 10669710, 10671717, 10669137, 10670714, 10672627, 10669808], "F": [10688186, 10766570]}, "name": "E. Berland Local Positioning System", "statement": "In Berland a bus travels along the main street of the capital. The\r\nstreet begins from the main square and looks like a very long segment.\r\nThere are bus stops located along the street, the -th of them is located\r\nat the distance from the central square, all distances are distinct, the\r\nstops are numbered in the order of increasing distance from the square,\r\nthat is, for all from 1 to . The bus starts its journey from the first\r\nstop, it passes stops , and so on. It reaches the stop number , turns\r\naround and goes in the opposite direction to stop , passing all the\r\nintermediate stops in the reverse order. After that, it again starts to\r\nmove towards stop . During the day, the bus runs non-stop on this\r\nroute.The bus is equipped with the Berland local positioning system.\r\nWhen the bus passes a stop, the system notes down its number.One of the\r\nkey features of the system is that it can respond to the queries about\r\nthe distance covered by the bus for the parts of its path between some\r\npair of stops. A special module of the system takes the input with the\r\ninformation about a set of stops on a segment of the path, a stop number\r\noccurs in the set as many times as the bus drove past it. This module\r\nreturns the length of the traveled segment of the path (or -1 if it is\r\nimpossible to determine the length uniquely). The operation of the\r\nmodule is complicated by the fact that .For example, if the number of\r\nstops is , and the part of the bus path starts at the bus stop number ,\r\nends at the stop number and passes the stops as follows: , then the\r\nrequest about this segment of the path will have form: . If the bus on\r\nthe segment of the path from stop to stop has time to drive past the -th\r\nstop (i.e., if we consider a segment that ends with the second visit to\r\nstop on the way from ), then the request will have form: .You will have\r\nto repeat the Berland programmers achievement and implement this\r\nfunction.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define For(i,a,b) for(long long i=a;i<b;i++)\n#define pb push_back\n#define mod 1000000007\n#define reset(s,val) memset(s,val,sizeof(s))\n#define eps 0.0000001\n#define pi acos(-1)\n#define sqr(x) (x)*(x)\n#define maxn 32000\n\nlong long n,m,lis[200005],cnt[200005],val,rou,ans,l2,r2,l1,r1,each;\n\nint main( ){\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    cin>>n;\n    ans=each=0;\n    For(i,0,n) cin>>lis[i];\n    for(int i=n-1;i;i--)\n    {\n        lis[i]-=lis[i-1];\n        each+=lis[i];\n    }\n    cin>>m;\n    while(m--)\n    {\n        cin>>val;\n        cnt[val]++;\n    }\n    if(n==2)\n    {\n        cout<<each*(cnt[1]+cnt[2]-1);\n        return 0;\n    }\n    rou=mod;\n    For(i,2,n) rou=min(rou,cnt[i]/2);\n    rou=min(rou,min(cnt[1],cnt[n]));\n    cnt[1]-=rou;\n    cnt[n]-=rou;\n    ans=each*2*rou;\n    For(i,2,n) cnt[i]-=2*rou;\n    l2=l1=n+1;r2=r1=0;\n    For(i,2,n)\n    {\n        if(cnt[i]==2)\n        {\n            l2=min(l2,i);r2=max(r2,i);\n        }\n        else if(cnt[i]==1)\n        {\n            l1=min(l1,i);r1=max(r1,i);\n        }\n    }\n    if(cnt[1]&&cnt[n])\n    {\n        ans+=each;\n        //cout<<ans<<endl;\n        int cur=2;\n        while(cnt[cur]==2)\n        {\n            ans+=lis[cur-1];\n            cur++;\n        }\n        if(cur<n-1)\n        {\n            cur=n-1;\n            while(cnt[cur]==2)\n            {\n                ans+=lis[cur];\n                cur--;\n            }\n        }\n        cout<<ans;\n        return 0;\n    }\n    if(cnt[1])\n    {\n        if(cnt[2]==0)\n        {\n            cout<<ans;\n            return 0;\n        }\n        if(r2)\n        {\n            For(i,1,r2) ans+=lis[i]*2;\n            if(r1) For(i,r2,r1) ans+=lis[i];\n            cout<<ans;return 0;\n        }\n        if(r1)\n        {\n            For(i,1,r1) ans+=lis[i];\n            cout<<ans;return 0;\n        }\n    }\n    if(cnt[n])\n    {\n        if(cnt[n-1]==0)\n        {\n            cout<<ans;return 0;\n        }\n        if(l2!=n+1)\n        {\n            For(i,l2,n) ans+=2*lis[i];\n            if(l1) For(i,l1,l2) ans+=lis[i];\n            cout<<ans;return 0;\n        }\n        if(l1)\n        {\n            For(i,l1,n) ans+=lis[i];\n            cout<<ans;return 0;\n        }\n    }\n    if(r1)\n    {\n        For(i,l1,r1) ans+=lis[i];\n        cout<<ans;return 0;\n    }\n    int com=lis[1];\n    For(i,2,n) if(com!=lis[i])\n    {\n        cout<<-1;return 0;\n    }\n    cout<<ans-com;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "hashing", "implementation"], "dificulty": "2400", "interactive": false}