{
    "link": "https://codeforces.com//contest/1282/problem/B1",
    "problemId": "502547",
    "problem_idx": "B1",
    "shortId": "1282B1",
    "contest_number": "1282",
    "problem_submissions": {
        "E": [
            67546320,
            67540524,
            67541446,
            67546303,
            67546008,
            67555357,
            67546940,
            67554692,
            67554152,
            67544350,
            67536466,
            67548692,
            67540027,
            67545669,
            67549313,
            67547161,
            67559435,
            67546463
        ],
        "D": [
            67539652,
            67544407,
            67549747,
            67552213,
            67545569,
            67553744,
            67546954,
            67547692,
            67559514,
            67555818,
            67556694,
            67549779,
            67598315,
            67547666,
            67544808,
            67560465,
            67548234,
            67564097,
            67563835,
            67550417,
            67558326
        ],
        "C": [
            67534787,
            67533541,
            67536568,
            67540389,
            67537852,
            67536983,
            67539275,
            67539714,
            67541087,
            67545744,
            67547743,
            67539703,
            67555448,
            67535851,
            67539752,
            67537500,
            67540009,
            67540608,
            67537965,
            67542806
        ],
        "B1": [
            67530651,
            67528820,
            67529188,
            67532639,
            67529290,
            67531855,
            67532183,
            67532128,
            67536143,
            67531195,
            67544224,
            67536607,
            67547534,
            67532778,
            67535678,
            67530911,
            67533223,
            67529828,
            67532257,
            67532690
        ],
        "B2": [
            67530568,
            67528747,
            67529121,
            67532572,
            67529220,
            67531772,
            67532043,
            67532055,
            67536010,
            67535218,
            67544175,
            67536559,
            67747743,
            67553996,
            67532837,
            67535576,
            67530786,
            67533144,
            67529811,
            67532146,
            67532632
        ],
        "A": [
            67527639,
            67527588,
            67527631,
            67528416,
            67527601,
            67528381,
            67527986,
            67528304,
            67530259,
            67527611,
            67537517,
            67551469,
            67529352,
            67527672,
            67527752,
            67527928,
            67529147,
            67527871,
            67528083
        ]
    },
    "name": "B1. K for the Price of One  Easy Version ",
    "statement": "Vasya came to the store to buy goods for his friends for the New Year.\r\nIt turned out that he was very lucky today the offer \"k of goods for the\r\nprice of one\" is held in store. Using this offer, Vasya can buy exactly\r\nk of any goods, paying only for the most expensive of them. Vasya\r\ndecided to take this opportunity and buy as many goods as possible for\r\nhis friends with the money he has.More formally, for each good, its\r\nprice is determined by a_i the number of coins it costs. Initially,\r\nVasya has p coins. He wants to buy the maximum number of goods. Vasya\r\ncan perform one of the following operations as many times as necessary:\r\nVasya can buy one good with the index i if he currently has enough coins\r\n(i.e p\r\nge a_i). After buying this good, the number of Vasyaâ€™s coins will\r\ndecrease by a_i, (i.e it becomes p := p - a_i). Vasya can buy a good\r\nwith the index i, and also choose exactly k-1 goods, the price of which\r\ndoes not exceed a_i, if he currently has enough coins (i.e p\r\nge a_i). Thus, he buys all these k goods, and his number of coins\r\ndecreases by a_i (i.e it becomes p := p - a_i). Please note that each\r\ngood can be bought no more than once.For example, if the store now has\r\nn=5 goods worth a_1=2, a_2=4, a_3=3, a_4=5, a_5=7, respectively, k=2,\r\nand Vasya has 6 coins, then he can buy 3 goods. A good with the index 1\r\nwill be bought by Vasya without using the offer and he will pay 2 coins.\r\nGoods with the indices 2 and 3 Vasya will buy using the offer and he\r\nwill pay 4 coins. It can be proved that Vasya can not buy more goods\r\nwith six coins.Help Vasya to find out the maximum number of goods he can\r\nbuy.\r\n",
    "solutions": [
        "#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nll a[MAXN], b[MAXN], c[MAXN];\nvector<ll> f;\nvector<ll> g[MAXN];\nvoid solve() {\n    ll p;\n    cin >> n >> p >> k;\n    for (int i = 0;i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i <= n; i++) {\n        b[i] = c[i] = 0;\n    }\n    sort(a, a+n);\n    for (int i = 0; i < n; i++) {\n        c[i+1] = c[i] + a[i];\n        if (i < k) {\n            b[i] = a[i];\n        } else {\n            b[i] = b[i-k] + a[i];\n        }\n\n    }\n    ll x = 0;\n    for (ll i = 0; i < n; i++) {\n        if (b[i] <= p) {\n            ll suck = (i + 1) / k * k;\n            ll diff = i + 1 - suck;\n            ll diffp = p - b[i];\n            ll pos = upper_bound(c, c+diff, diffp) - c;\n            x = max(x, suck + pos);\n        }\n    }\n    cout << x << \"\\n\";\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B1. K for the Price of One  Easy Version .json",
    "editorial_link": "https://codeforces.com/blog/entry/72461?locale=en",
    "editorial": "If you sort the array by costs, it will always be profitable to take\r\nsegments of length with the cheapest possible end. It remains only to\r\nunderstand when you need to take gifts without a promotion.It makes no\r\nsense to take or more gifts without a promotion, so we can combine them\r\nand buy together. It also makes no sense to take not the cheapest gifts\r\nwithout a stock, since the total cost from this will only increase.So\r\nthe solution to the problem is to iterate over the prefix in a sorted\r\narray of length no more than , and then buy items together for pieces.\r\nThis solution works in the linear time since we will always look at\r\nelements with a different index by modulo .\r\n",
    "hint": []
}