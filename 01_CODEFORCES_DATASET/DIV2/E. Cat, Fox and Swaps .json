{
    "link": "https://codeforces.com//contest/1973/problem/E",
    "problemId": "2652014",
    "problem_idx": "E",
    "shortId": "1973E",
    "contest_number": "1973",
    "problem_submissions": {
        "F": [
            261463251,
            261436494,
            261787514
        ],
        "D": [
            261394881,
            261402242,
            261380949,
            261382024,
            261382530,
            261387010,
            261390196,
            261382271,
            261387986,
            261384447,
            261402787,
            261386421,
            261427816,
            261407792,
            261395337,
            261376975,
            261379252,
            261380684,
            261382950
        ],
        "E": [
            261381347,
            261382046,
            261401618,
            261402013,
            261401999,
            261406109,
            261402299,
            261407866,
            261402896,
            261405986,
            261394102,
            261405366,
            261389878,
            261408472,
            261404774,
            261590660
        ],
        "C": [
            261360567,
            261360988,
            261363426,
            261364691,
            261354543,
            261360787,
            261363933,
            261369573,
            261365792,
            261367077,
            261359236,
            261367488,
            261357141,
            261374894,
            261387975,
            261359851,
            261363374,
            261357155
        ],
        "B": [
            261348324,
            261350288,
            261353838,
            261351331,
            261349040,
            261350145,
            261349881,
            261347862,
            261350513,
            261350776,
            261350235,
            261356753,
            261350384,
            261354721,
            261390204,
            261350344,
            261351974,
            261347066
        ],
        "A": [
            261346207,
            261346661,
            261348023,
            288952169,
            261346140,
            261346181,
            261346010,
            261346089,
            261345101,
            261344789,
            261344990,
            261346630,
            261346138,
            261346691,
            261348987,
            261391373,
            261346139,
            261346040,
            261349777
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129556",
    "editorial": "Solution:Let\u00e2\u0080\u0099s consider the pairs that have first. Then you can swap\r\neach with at most one other element, . So if for some , then we need to\r\nbe able to swap the element with the element , so it must hold that .\r\nThis is obviously also a sufficient condition, so it\u00e2\u0080\u0099s enough to just\r\nfind all for , if there exist more then one different value, there\u00e2\u0080\u0099s no\r\ngood pair with , if there\u00e2\u0080\u0099s exactly one different value, there\u00e2\u0080\u0099s exactly\r\none good pair with and otherwise there are such pairs.Now let\u00e2\u0080\u0099s count\r\nthe pairs with . If the array is sorted already, all pairs of are good.\r\nFrom now, consider only the case when the array isn\u00e2\u0080\u0099t sorted yet.Let be\r\nthe smallest value such that and the largest such value respectively. We\r\nobviously need to be able to swap and with some other values. Note that\r\nand , otherwise the array would be sorted already. Now we can get the\r\ninequalities and , those are the necessary conditions for being able to\r\nswap the numbers with at least one other element. We can actually prove\r\nthat these are the sufficient conditions too. If satisfy these\r\nconditions, then for any number in the range , we can find an in the\r\nrange such that and then we can swap the numbers and , while not\r\naffecting any other element, by swapping and first and then swapping and\r\n. Thanks to this, we can sort the whole range of values between and\r\nwhile the array isn\u00e2\u0080\u0099t sorted, we will always find the smallest index\r\nthat doesn\u00e2\u0080\u0099t have the right value and keep swapping the value with the\r\nvalue , so eventually we will get and we can continue sorting on the\r\nright.So it\u00e2\u0080\u0099s enough to just count the number of pairs such that , and ,\r\nadd it to the answer and print it. All of this can be done in time and\r\nmemory complexity .Implementation in C++: 261999566 (I used set and\r\ntherefore the time complexity is because it was more comfortable)\r\n",
    "name": "E. Cat, Fox and Swaps ",
    "statement": "Fox has found an array p_1, p_2,\r\nldots, p_n, that is a permutation of length n^\r\ndagger of the numbers 1, 2,\r\nldots, n. She wants to sort the elements in increasing order. Cat wants\r\nto help her he is able to swap any two numbers x and y in the array, but\r\nonly if l\r\nleq x + y\r\nleq r (note that the constraint is imposed on the values of the\r\nelements, not their positions). He can make such swaps any number of\r\ntimes.They don\u2019t know the numbers l, r yet, they only know that it\u2019s\r\ntrue that 1\r\nleq l\r\nleq r\r\nleq 2\r\ncdot n. You are given the number n and the array p_1, p_2,\r\nldots, p_n. Determine how many pairs (l, r) satisfying the conditions\r\nare there such that you can sort the permutation if you can only swap\r\ntwo number (x, y) such that l\r\nleq x + y\r\nleq r (arbitrary number of times, possibly 0).^\r\ndagger A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define ll long longint n,p[101000],q[101000];void sol(){    scanf(\"%d\",&n);for(int i=1;i<=n;i++)scanf(\"%d\",&p[i]),q[p[i]]=i;    bool fl=1;    for(int i=1;i<n;i++)fl&=(q[i]<q[i+1]);    if(fl){printf(\"%lld\\n\",1ll*n*(n*2+1));return;}    int L=n+1,R=-1,h=0;    for(int i=1;i<=n;i++)if(q[i]!=i){        L=min(L,i),R=max(R,i);        if(h==-1)continue;        if(!h||h==i+q[i])h=i+q[i];        else h=-1;    }    ll ans=0;    for(int l=1;l<=n*2;l++)if(L>=l-n){        int re=max(l,R)+1;        if(re<=n*2)ans+=n*2-re+1;        //R+1,l+1<=r    }    if(h>0)ans++;    printf(\"%lld\\n\",ans);}int main(){    int T;scanf(\"%d\",&T);while(T--)sol();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "math",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cat, Fox and Swaps .json"
}