{
    "link": "https://codeforces.com//contest/259/problem/E",
    "problemId": "2441",
    "problem_idx": "E",
    "shortId": "259E",
    "contest_number": "259",
    "problem_submissions": {
        "E": [
            2813039,
            2816939,
            2814909,
            4167338,
            4137723
        ],
        "C": [
            2809858,
            2808871,
            2809902,
            2809737,
            2809898,
            2810009,
            2809632,
            2810402,
            2809449,
            2811265,
            2809553,
            2810721,
            2809373,
            2809260,
            2807799,
            2811480,
            2809146,
            2809912,
            2810184
        ],
        "B": [
            2809426,
            2810084,
            2809284,
            2809125,
            2809325,
            2811095,
            2809244,
            2811116,
            2808962,
            2810591,
            2810202,
            2810095,
            2808730,
            2808863,
            2809270,
            2809527,
            2808652,
            2809415,
            2809855
        ],
        "A": [
            2807976,
            2808177,
            2807683,
            2807618,
            2807679,
            2807891,
            2807707,
            2807642,
            2807614,
            2809094,
            2808555,
            2808299,
            2807492,
            2807537,
            2808474,
            2807922,
            2807557,
            2808322,
            2807778
        ],
        "D": [
            2812836,
            2813225,
            2814117,
            2813559,
            2813985,
            2814364,
            2814925,
            2813998,
            2814354,
            2814825,
            2816069,
            2815431,
            2815253,
            2815318,
            2815331,
            2814947
        ]
    },
    "name": "E. Little Elephant and LCM",
    "statement": "The Little Elephant loves the LCM (least common multiple) operation of a\r\nnon-empty set of positive integers. The result of the LCM operation of\r\npositive integers is the minimum positive integer that is divisible by\r\neach of numbers .Let\u2019s assume that there is a sequence of integers .\r\nLet\u2019s denote their LCMs as and the maximum of them as . The Little\r\nElephant considers a sequence , if .The Little Elephant has a sequence\r\nof integers . Help him find the number of good sequences of integers ,\r\nsuch that for all the following condition fulfills: . As the answer can\r\nbe rather large, print the remainder from dividing it by .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int M = 1000000007;\nconst int N = 100003;\nint ld[N];\nint a[N];\n\n\nvoid sieve()\n{\n    for(int i = 2; i*i < N; ++i)\n        if(ld[i] == 0)\n            for(int j = i*i; j < N; j += i)\n                if(ld[j] == 0)\n                    ld[j] = i;\n    for(int i = 2; i < N; ++i)\n        if(ld[i] == 0)\n            ld[i] = i;\n}\n\nvector<int> p;\nvector<int> k;\nvector<int> d;\nvoid genDivisors(int i, int x)\n{\n    if(i == (int)p.size()) {\n        d.push_back(x);\n        return;\n    }\n    \n    for(int c = 0; c <= k[i]; ++c) {\n        genDivisors(i+1, x);\n        x *= p[i];\n    }\n}\n\nint expMod(int a, int n)\n{\n    int res = 1;\n    while(n > 0) {\n        if(n & 1) res = (LL)res * a % M;\n        n >>= 1;\n        a = (LL)a * a % M; \n    }\n    return res;\n}\n\nint main()\n{\n    sieve();\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i)\n        scanf(\"%d\", a+i);\n    sort(a, a + n);\n    \n    int res = 0;\n    for(int x = 1; x <= a[n-1]; ++x) {\n        p.clear();\n        k.clear();\n        d.clear();\n        int y = x;\n        while(y > 1) {\n            int z = ld[y];\n            p.push_back(ld[y]);\n            k.push_back(1);\n            y /= z;\n            while(y % z == 0) {\n                y /= z;\n                ++k.back();\n            }\n        }\n        \n        genDivisors(0, 1);\n        sort(d.begin(), d.end());\n        \n        k.clear();\n        k.resize(d.size());\n        for(int i = 0; i < (int)d.size(); ++i)\n            k[i] = n - (lower_bound(a, a + n, d[i]) - a);\n        \n        y = 1;\n        for(int i = 0; i < (int)d.size()-1; ++i) {\n            k[i] -= k[i+1];\n            y = (LL)y * expMod(i+1, k[i]) % M;\n        }\n        int z = (expMod(d.size(), k.back()) - expMod((int)d.size()-1, k.back()) + M) % M;\n        y = (LL)y * z % M;\n        res = (res + y) % M;\n    }\n    \n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Little Elephant and LCM.json",
    "editorial_link": "https://codeforces.com//blog/entry/6213",
    "editorial": "The complexity of the possible solution is O(n?*?sqrt(n)?*?log(n)). You can see that statement lcm(b1,?b2,?...,?bn)?=?max(b1,?b2,?...,?bn) is equal to statement \"All the numbers b1,?b2,?...,?bn must divide max(b1,?b2,?...,?bn)\". You can iterate that max(b1,?b2,?...,?bn), let it be equal to m. Find all divisors of m and sort them \u0097 p1,?p2,?...,?pk. For each i between 1 and k you can find (using simple DP) the number of numbers aj that pi???aj?<?pi?+?1 (if i?=?k than pi?+?1?=?max(a1,?a2,?...,?an)?+?1), denote it as qi. Then the reuslt is equal to 1q1?*?2q2?*?3q3?*?...?*?pqp, because for each of the q1 numbers there is 1 way to assign, for each of q2 numbers there is 2 ways of assignments, and so on. But you should notice that if doing this problem in such way, you need to garantee that there is some i such bi?=?m. Hance you need from the last multiplier (pqp) subtract (p?-?1)qp \u0097 all the ways that there is no number equal to m."
}