{"link": "https://codeforces.com//contest/1041/problem/E", "problemId": "220443", "problem_idx": "E", "shortId": "1041E", "contest_number": "1041", "problem_submissions": {"F": [42937145, 42936460, 42941789, 42939791, 42936055, 42943259, 42941945, 42942600, 42940476, 42943214, 42942904, 42941561, 42940422, 42942676, 42967085, 42945698, 42942819, 42940517, 42945082], "E": [42931045, 42932542, 42929311, 42932587, 42939274, 42934189, 42934028, 42935828, 42936456, 42936222, 42934576, 42934053, 42934830, 42936131, 42933423, 42935645, 42936145, 42934904], "D": [42928058, 42928419, 42932086, 42926606, 42928328, 42929346, 42929592, 42930860, 42930895, 42928722, 42931546, 42929735, 42930750, 42931175, 42929657, 42930694, 42932165, 42929565], "C": [42924598, 42925979, 42923335, 42923874, 42924882, 42924328, 42925322, 42926206, 42927308, 42925269, 42926071, 42925958, 42929148, 42926562, 42925843, 42927423, 42929003, 42925656], "B": [42919830, 42920297, 42919741, 42920667, 42921333, 42921057, 42919493, 42920331, 42920664, 42920599, 42920862, 42919750, 42921237, 42921905, 42921366, 42922548, 42922190, 42921585], "A": [42918068, 42918894, 42917952, 42918346, 42918563, 42921193, 42918207, 42918103, 42917969, 42918179, 42919024, 42917972, 42919232, 42918320, 42918302, 42919340, 42918232, 42918340]}, "name": "E. Tree Reconstruction", "statement": "Monocarp has drawn a tree (an undirected connected acyclic graph) and\r\nthen has given each vertex an index. All indices are distinct numbers\r\nfrom 1 to n. For every edge e of this tree, Monocarp has written two\r\nnumbers: the maximum indices of the vertices of the two components\r\nformed if the edge e (and only this edge) is erased from the\r\ntree.Monocarp has given you a list of n - 1 pairs of numbers. He wants\r\nyou to provide an example of a tree that will produce the said list if\r\nthis tree exists. If such tree does not exist, say so.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nint f[200009];\nmain(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n - 1; i++){\n        int a, b;\n        cin >>a >> b;\n        if(a > b) swap(a, b);\n        if(a == n || b != n){\n            cout << \"NO\"<<endl;\n            return 0;\n        }\n        f[a] ++;\n        f[b] ++;\n    }\n    int k = n;\n    vector<int> v;\n    vector<pair<int,int> > ans;\n    for(int i = 1; i <= n - 1; i++){\n        if(f[i] == 0){\n            v.push_back(i);\n        }\n        else{\n            if(v.size() < f[i] - 1){\n                cout << \"NO\"<<endl;\n                return 0;\n            }\n            vector<int> C;\n            C.push_back(n);\n\n            int x = f[i] -1;\n            while(x--){\n                C.push_back(v.back());\n                v.pop_back();\n            }\n            C.push_back(i);\n            for(int i = 1; i < C.size(); i++)\n                ans.push_back({C[i-1], C[i]});\n        }\n    }\n    if(v.size()){\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    cout <<\"YES\"<<endl;\n    for(int i = 0; i < ans.size(); i++){\n        cout << ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "graphs", "greedy"], "dificulty": "1900", "interactive": false}