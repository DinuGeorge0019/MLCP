{
    "link": "https://codeforces.com//contest/1041/problem/E",
    "problemId": "220443",
    "problem_idx": "E",
    "shortId": "1041E",
    "contest_number": "1041",
    "problem_submissions": {
        "F": [
            42937145,
            42936460,
            42941789,
            42939791,
            42936055,
            42943259,
            42941945,
            42942600,
            42940476,
            42943214,
            42942904,
            42941561,
            42940422,
            42942676,
            42967085,
            42945698,
            42942819,
            42940517,
            42945082
        ],
        "E": [
            42931045,
            42932542,
            42929311,
            42932587,
            42939274,
            42934189,
            42934028,
            42935828,
            42936456,
            42936222,
            42934576,
            42934053,
            42934830,
            42936131,
            42933423,
            42935645,
            42936145,
            42934904
        ],
        "D": [
            42928058,
            42928419,
            42932086,
            42926606,
            42928328,
            42929346,
            42929592,
            42930860,
            42930895,
            42928722,
            42931546,
            42929735,
            42930750,
            42931175,
            42929657,
            42930694,
            42932165,
            42929565
        ],
        "C": [
            42924598,
            42925979,
            42923335,
            42923874,
            42924882,
            42924328,
            42925322,
            42926206,
            42927308,
            42925269,
            42926071,
            42925958,
            42929148,
            42926562,
            42925843,
            42927423,
            42929003,
            42925656
        ],
        "B": [
            42919830,
            42920297,
            42919741,
            42920667,
            42921333,
            42921057,
            42919493,
            42920331,
            42920664,
            42920599,
            42920862,
            42919750,
            42921237,
            42921905,
            42921366,
            42922548,
            42922190,
            42921585
        ],
        "A": [
            42918068,
            42918894,
            42917952,
            42918346,
            42918563,
            42921193,
            42918207,
            42918103,
            42917969,
            42918179,
            42919024,
            42917972,
            42919232,
            42918320,
            42918302,
            42919340,
            42918232,
            42918340
        ]
    },
    "name": "E. Tree Reconstruction",
    "statement": "Monocarp has drawn a tree (an undirected connected acyclic graph) and\r\nthen has given each vertex an index. All indices are distinct numbers\r\nfrom 1 to n. For every edge e of this tree, Monocarp has written two\r\nnumbers: the maximum indices of the vertices of the two components\r\nformed if the edge e (and only this edge) is erased from the\r\ntree.Monocarp has given you a list of n - 1 pairs of numbers. He wants\r\nyou to provide an example of a tree that will produce the said list if\r\nthis tree exists. If such tree does not exist, say so.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint f[200009];\nmain(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n - 1; i++){\n        int a, b;\n        cin >>a >> b;\n        if(a > b) swap(a, b);\n        if(a == n || b != n){\n            cout << \"NO\"<<endl;\n            return 0;\n        }\n        f[a] ++;\n        f[b] ++;\n    }\n    int k = n;\n    vector<int> v;\n    vector<pair<int,int> > ans;\n    for(int i = 1; i <= n - 1; i++){\n        if(f[i] == 0){\n            v.push_back(i);\n        }\n        else{\n            if(v.size() < f[i] - 1){\n                cout << \"NO\"<<endl;\n                return 0;\n            }\n            vector<int> C;\n            C.push_back(n);\n\n            int x = f[i] -1;\n            while(x--){\n                C.push_back(v.back());\n                v.pop_back();\n            }\n            C.push_back(i);\n            for(int i = 1; i < C.size(); i++)\n                ans.push_back({C[i-1], C[i]});\n        }\n    }\n    if(v.size()){\n        cout<<\"NO\"<<endl;\n        return 0;\n    }\n    cout <<\"YES\"<<endl;\n    for(int i = 0; i < ans.size(); i++){\n        cout << ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree Reconstruction.json",
    "editorial_link": "https://codeforces.com/blog/entry/61876",
    "editorial": "First of all, if there exists some , then the answer is clearly . Then\r\nletâs consider that every and analyze only the values of (and\r\nfurthermore, letâs sort all values of beforehand).Suppose that we have\r\nconstructed a tree satisfying all the requirements and rooted it at\r\nvertex . Then for any such that there exist no more than subtrees\r\ncontaining only vertices with indices not exceeding (because there are\r\nno more than vertices that can be the roots of such subtrees). So, if\r\nfor some constant the number of is greater than , then the answer is\r\nsince it would imply that there are more than subtrees containing only\r\nvalues not greater then .Now we consider only the case such that for\r\nevery the number of such that is not greater than . In this case the\r\nanswer is ; letâs prove it with an algorithm that constructs a tree\r\nmeeting the constraints.Actually, we can always build a bamboo (a tree\r\nwhere no vertex has degree greater than , or simply a path) according to\r\nthese constraints. Letâs put vertex at one of the ends of the bamboo and\r\nstart building a bamboo from the other end. Itâs obvious that if we make\r\nsome vertex a leaf, then the array will contain only values not less\r\nthan . So, if we consider values of to be sorted, then the leaf has\r\nindex .Then letâs repeat the following process for every : if , then\r\nletâs use the vertex with index as the parent of the previous vertex;\r\notherwise, letâs find any index such that and index is not used yet, and\r\nuse vertex with index as the parent of the previous vertex (there will\r\nbe at least one such vertex since for every the number of such that is\r\nnot greater than ). Itâs easy to prove that the bamboo we construct in\r\nsuch a way meets the constraints given in the statement.\r\n",
    "hint": []
}