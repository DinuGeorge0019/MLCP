{
    "link": "https://codeforces.com//contest/155/problem/D",
    "problemId": "952",
    "problem_idx": "D",
    "shortId": "155D",
    "contest_number": "155",
    "problem_submissions": {
        "C": [
            1225243,
            1226717,
            1224971,
            1224506,
            1224768,
            1224444,
            1224336,
            1226178,
            1224907,
            1224916,
            1224811,
            1224924,
            1224662,
            1223975,
            1226905,
            1227456,
            1225902,
            1228923,
            4141949,
            1225351
        ],
        "D": [
            1224117,
            1227696,
            1226383,
            1225863,
            1228335,
            1226351,
            1226456,
            1225394,
            1226266,
            1226950,
            1226772,
            1227105,
            1227425,
            1226475,
            1226136,
            1224942,
            1227473,
            1225325,
            1227301
        ],
        "B": [
            1221607,
            1221762,
            1222099,
            1223177,
            1225270,
            1222150,
            1223376,
            1222553,
            1222471,
            1222167,
            1223151,
            1222830,
            1222882,
            1224581,
            1222789,
            1222810,
            1222778,
            1222687,
            1222965
        ],
        "A": [
            1221146,
            1221148,
            1221169,
            1221961,
            1222044,
            1221349,
            1221696,
            1221640,
            1221515,
            1221343,
            1221470,
            1221634,
            1221617,
            17013899,
            1224871,
            1221409,
            1221848,
            1221716,
            1221534,
            1221252
        ],
        "E": [
            1239607,
            1239595,
            1239584,
            1231448,
            1239840,
            1243072
        ]
    },
    "name": "D. Colliders",
    "statement": "By 2312 there were Large Hadron Colliders in the inhabited part of the\r\nuniverse. Each of them corresponded to a single natural number from to .\r\nHowever, scientists did not know what activating several colliders\r\nsimultaneously could cause, so the colliders were deactivated.In 2312\r\nthere was a startling discovery: a collider’s activity is safe if and\r\nonly if all numbers of activated colliders are pairwise relatively prime\r\nto each other (two numbers are relatively prime if their greatest common\r\ndivisor equals )! If two colliders with relatively nonprime numbers are\r\nactivated, it will cause a global collapse.Upon learning this,\r\nphysicists rushed to turn the colliders on and off and carry out all\r\nsorts of experiments. To make sure than the scientists’ quickness\r\ndoesn’t end with big trouble, the Large Hadron Colliders’ Large Remote\r\nControl was created. You are commissioned to write the software for the\r\nremote (well, you do not expect anybody to operate it manually, do\r\nyou?).Initially, all colliders are deactivated. Your program receives\r\nmultiple requests of the form \"activate/deactivate the -th collider\".\r\nThe program should handle requests in the order of receiving them. The\r\nprogram should print the processed results in the format described\r\nbelow.To the request of \"\" (that is, to activate the -th collider), the\r\nprogram should print exactly one of the following responses: \"\" if the\r\nactivation was successful. \"\", if the -th collider was already activated\r\nbefore the request. \"\", if there is a conflict with the -th collider\r\n(that is, the -th collider is on, and numbers and are not relatively\r\nprime). In this case, the -th collider shouldn’t be activated. If a\r\nconflict occurs with several colliders simultaneously, you should print\r\nthe number of any of them. The request of \"\" (that is, to deactivate the\r\n-th collider), should receive one of the following responses from the\r\nprogram: \"\", if the deactivation was successful. \"\", if the -th collider\r\nwas already deactivated before the request. You don’t need to print\r\nquotes in the output of the responses to the requests.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n, m; cin >> n >> m;\n    \n    int factor[n+1];\n    memset(factor, -1, sizeof factor);\n    for (int i=2; i < n+1; i++) {\n        if (factor[i] == -1) {\n            factor[i] = i;\n            for (int j=i+i; j < n+1; j+=i) {\n                factor[j] = i;\n            }\n        }\n    }\n    bool on[n+1];\n    memset(on, 0, sizeof on);\n    \n    map<int, set<int> > curf;\n    for (int i=0; i < m; i++) {\n        char s; cin >> s; int t; cin >> t; \n        int oldt = t;\n        if (s == '+') {\n            if (on[t]) {\n                cout << \"Already on\" << endl;\n            } else {\n                bool good = true;\n                vector<int> f;\n                while(t != 1) {\n                    if (curf.count(factor[t])) {\n                        cout << \"Conflict with \" << *(curf[factor[t]].begin()) << endl;\n                        good = false;\n                        break;\n                    }\n                    int next = factor[t];\n                    while(t%next == 0) t /= next;\n                    f.push_back(next);\n                }\n                if (good) {\n                    cout << \"Success\" << endl;\n                    on[oldt] = true;\n                    \n                    for (int i=0; i < f.size(); i++) {\n                        curf[f[i]];\n                        curf[f[i]].insert(oldt);\n                    }\n                }\n            }\n        } else {\n            if (!on[t]) {\n                cout << \"Already off\" << endl;\n            } else {\n                cout << \"Success\" << endl;\n                on[t] = false;\n                \n                while(t != 1) {\n                    int next = factor[t];\n                    while(t%next == 0) t /= next;\n                    \n                    curf[next].erase(oldt);\n                    if (curf[next].size() == 0) curf.erase(next);\n                }\n            }\n        }\n    }\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Colliders.json",
    "editorial_link": "https://codeforces.com//blog/entry/3969",
    "editorial": "The clueless solution ''store all the enabled numbers and compare each new number with each of them'' works too slow, as we can add all the prime numbers below n, number of which is O(n / log n).\n\nWe can note that for each number k > 1 at any time no more than one collider is turned on which number is divided by k. Let us store an array which has in k-th element the number of turned-on collider which is divided by k, on 0 if there is no such at the moment. To enable the collider with number q we can look over q's divisors and check whether all the array's elements with these numbers have 0's. If some of them has a positive integer, that's the number of collider we conflict with  we can just print it and go on. Otherwise, we have to put q into all the overlooked elements.\n\nThis works in O(M sqrt(N) + N). There's faster solution as we can store all of the above only for prime divisors. Total size of the prime divisors list for number from 1 to N is O(N log log N). Thus we have a solution with complexity O(N log log N + M log N), as the number of prime divisors of k doesn't exceed log k (exact upper bound  log k / log log k * (1 + o(1)).",
    "hint": []
}