{
    "link": "https://codeforces.com//contest/1419/problem/B",
    "problemId": "729808",
    "problem_idx": "B",
    "shortId": "1419B",
    "contest_number": "1419",
    "problem_submissions": {
        "F": [
            93295033,
            93295948,
            93577512,
            141950739,
            141949703,
            93333082
        ],
        "E": [
            93234753,
            93227212,
            93234200,
            93238693,
            93238493,
            93238433,
            93238275,
            93245697,
            93246537,
            93242848,
            93246826,
            93247065,
            93245207,
            93241549,
            93243538,
            93254913,
            93249479,
            93238516
        ],
        "D2": [
            93212522,
            93217506,
            93213686,
            93220590,
            93215812,
            93218918,
            93214966,
            93215328,
            93210409,
            93223664,
            93218002,
            93222549,
            93220767,
            93225667,
            93221756,
            93229039,
            93216049,
            93227118
        ],
        "D1": [
            93210697,
            93214622,
            93213970,
            93213840,
            93206345,
            93211719,
            93208773,
            93212321,
            93204619,
            93213170,
            93216390,
            93214097,
            93210302,
            93207013,
            93214684,
            93211970,
            93215865,
            93206978
        ],
        "C": [
            93207169,
            93210000,
            93209428,
            93210195,
            93217148,
            93208516,
            93207753,
            93214333,
            93218732,
            93213670,
            93211157,
            93218160,
            93211807,
            93211495,
            93209180,
            93205213,
            93217455
        ],
        "B": [
            93202581,
            93203801,
            93204920,
            93203314,
            93203851,
            93201764,
            93202768,
            93202454,
            93208579,
            93203844,
            93205640,
            93206433,
            93220603,
            93204341,
            93204189,
            93202311,
            93214207
        ],
        "A": [
            93200129,
            93200069,
            93200258,
            93200020,
            93200369,
            93204977,
            93200037,
            93200656,
            93201705,
            93200310,
            93200086,
            93201198,
            93200525,
            93199999,
            93201236,
            93200136,
            93200638
        ]
    },
    "name": "B. Stairs",
    "statement": "Jett is tired after destroying the town and she wants to have a rest.\r\nShe likes high places, that’s why for having a rest she wants to get\r\nhigh and she decided to craft staircases.A staircase is a squared figure\r\nthat consists of square cells. Each staircase consists of an arbitrary\r\nnumber of stairs. If a staircase has n stairs, then it is made of n\r\ncolumns, the first column is 1 cell high, the second column is 2 cells\r\nhigh,\r\nldots, the n-th column if n cells high. The lowest cells of all stairs\r\nmust be in the same row.A staircase with n stairs is called nice, if it\r\nmay be covered by n squares made of cells. All squares should fully\r\nconsist of cells of a staircase. This is how a nice covered staircase\r\nwith 7 stairs looks like: Find out the maximal number of nice\r\nstaircases, that can be built, using no more than x cells, . No cell can\r\nbe used more than once.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s\".in\", \"r\", stdin); freopen(s\".out\", \"w\", stdout)\n#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, \"%d \", a[i]); fprintf(stderr, \"\\n\");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = '0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint pw[MAXN], t[MAXN];\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(\"pro\");\n    #endif\n    int T; cin >> T;\n    pw[0] = 1; For(i, 1, 62) pw[i] = pw[i-1] * 2;\n    For(i, 1, 63) t[i] = t[i-1] + pw[i-1];\n    while(T--) {\n    \tint x; cin >> x;\n    \tFor(i, 1, 63) {\n    \t\tif(x < t[i] * (t[i] + 1) / 2) {\n    \t\t\tprintf(\"%d\\n\", i - 1); break;\n\t\t\t}\n\t\t\telse x -= t[i] * (t[i] + 1) / 2;\n\t\t}\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Stairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/82817",
    "editorial": "Letâs prove, that the minimal amount of squares needed to cover the\r\nstaircase is not less than , where is the height of a staircase. To\r\nhighest cell of each stair is the top left cell of some square. Thatâs\r\nwhy we need at least squares. You need exactly squares if and only if\r\nthe top left cell of each stair is a top left cell of some sqaure.Letâs\r\nconsider a square that covers the lowest cell in the last stair. Its top\r\nleft corner should contain the highest cell with index for odd . Then\r\nthe staircase is divided into 2 staircases, each stairs high. These\r\nstaircases should be nice, too. It means that nice staircases are stairs\r\nhigh, where . To maximize the amount of different staircases we should\r\ncreate staircases greedily. If is even, then we can consider a square\r\nthat will have the lowest cell of the last stair. The top left corner of\r\nthis square may not contain any top cells of a staircase, thatâs why you\r\nwill need more than squares. This means that a staircase with an even\r\nheight may not be nice.\r\n",
    "hint": []
}