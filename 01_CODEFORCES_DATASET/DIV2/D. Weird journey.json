{
    "link": "https://codeforces.com//contest/789/problem/D",
    "problemId": "100715",
    "problem_idx": "D",
    "shortId": "789D",
    "contest_number": "789",
    "problem_submissions": {
        "E": [
            25921417,
            25928664,
            25938608,
            26079210,
            25947954,
            26156847,
            25952720,
            25948873,
            25927282,
            25920863
        ],
        "C": [
            25907485,
            25920845,
            25908240,
            25909409,
            25909007,
            25905160,
            25908451,
            25908709,
            25907436,
            25913347,
            25910091,
            25912715,
            25905998,
            25914226,
            25910850,
            25914881,
            25912811,
            25910391
        ],
        "B": [
            25905735,
            25936346,
            25905545,
            25905376,
            25905148,
            25909677,
            25906183,
            25904190,
            25902630,
            25909186,
            25906079,
            25908841,
            25906659,
            25906692,
            25949245,
            25917385,
            25906432,
            25939487
        ],
        "A": [
            25903396,
            25902876,
            25900899,
            25900290,
            25900204,
            25900048,
            25900683,
            25900192,
            25900117,
            25900433,
            25900607,
            25901029,
            25900382,
            25900017,
            25900928,
            25900038,
            25900011,
            25900777
        ],
        "D": [
            25920092,
            25917739,
            25919852,
            25922157,
            25919194,
            25919753,
            25920835,
            25927363,
            25921216,
            25924692,
            25924134,
            25910294,
            25927095,
            25925921,
            25927864
        ]
    },
    "name": "D. Weird journey",
    "statement": "Little boy Igor wants to become a traveller. At first, he decided to\r\nvisit all the cities of his motherland Uzhlyandia.It is widely known\r\nthat Uzhlyandia has cities connected with bidirectional roads. Also,\r\nthere are no two roads in the country that connect the same pair of\r\ncities, but roads starting and ending in the same city can exist. Igor\r\nwants to plan his journey beforehand. Boy thinks a path is if the path\r\ngoes over roads twice, and over the other exactly once. The good path\r\ncan start and finish in any city of Uzhlyandia.Now he wants to know how\r\nmany different good paths are in Uzhlyandia. Two paths are considered\r\ndifferent if the sets of roads the paths goes over exactly once differ.\r\nHelp Igor calculate the number of good paths.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define SZ(S) S.size()\n#define vi vector<int>\n#define pr pair<int,int>\n#define REP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,a,b) for(int i=(int)(a);i<=(int)(b);++i)\n#define FORD(i,b,a) for(int i=(int)(b);i>=(int)(a);--i)\n#define ALL(S) S.begin(),S.end()\n \nusing namespace std;\ntypedef long long ll;\n \nconst int N=1000005,INF=99999999;\nconst ll P=1e9+7;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile (ch<'0' || ch>'9') {if (ch=='-') f=-1; ch=getchar();}\n\twhile (ch>='0' && ch<='9') {x=x*10+ch-'0'; ch=getchar();} \n\treturn x*f;\n}\n \nvi g[N];\nint d[N],cnt,fuck;\nbool vis[N];\nbool c[N];\nvoid dfs(int x) {\n    vis[x]=1;\n    for(auto i:g[x]) {\n        if(!vis[i]) dfs(i);\n    }\n}\n \nint main() {\n    int n,m,u,v;\n    n=read(),m=read();\n    for (int i=1; i<=m; i++) {\n        u=read(),v=read();\n        if(u==v) {\n            d[u]++;\n            c[u]=1;\n            cnt++;\n        }\n        else {\n            g[u].pb(v);\n            g[v].pb(u);\n            d[u]++,d[v]++;\n            fuck++;\n        }\n    }\n    ll ans=0;\n    ans=1ll*cnt*(cnt-1)/2;\n    ans+=1ll*cnt*fuck;\n    for (int i=1; i<=n; i++) \n\t\tif(d[i]!=0) {\n        dfs(i);\n        break;\n    }\n    for (int i=1; i<=n; i++) \n\t\tif(!vis[i]&&d[i]!=0) {\n        cout<<0<<endl;\n        return 0;\n    }\n    for (int i=1; i<=n; i++)  if(c[i]) d[i]--;\n    for (int i=1; i<=n; i++)  {\n        ans+=1ll*d[i]*(d[i]-1)/2;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Weird journey.json",
    "editorial_link": "https://codeforces.com//blog/entry/51312",
    "editorial": "We can consider the system of towns and roads as a graph, where edges correspond to roads and vertexes to cities.\n\nNow, let's fix two edges, that will be visited once. All other edges we can split into two. Then, the good way in the old graph equivalents to any Euler path in the computed one. Widely known that Euler path exists in graph when and only when there are 0 or 2 vertexes with odd degree. Consider following cases of mutual placement of edges that will be visited once:\n\nRegular(not loops) edges that are not adjacent  graph has four vertexes with odd degree, so Euler path doesn't exist.\nRegular edges that are adjacent  graph has exactly two vertexes with odd degree, so Euler path exists. So, any pair of adjacent regular edges satisfies Igor.\nOne of the edges is a loop  graph hasn't any vertex with the odd degree(if another chosen edge is a loop too) or has two of them(if another chosen edge is regular). So, any pair in which at least one edge is a loop satisfies Igor.\nSo, we have to calculate the number of pairs of adjacent regular edges and add the answer for loops. For every vertex i we can calculate cnti  the number of regular edges incoming in it. General number of adjacent regular edges is . Also, we need to add the number of pairs with loops. Let's count loop  general number of loops in the graph. So we can add loop·(m?-?1) to the answer. Now, we included pairs with two loops twice. That's why we need to subtract Cloop2  the number of pairs with two loops.\n\nAlso, we need to check the graph to be connected by edges. If the graph is not connected then the answer is 0. We can do it using algorithms of DFS or BFS.",
    "hint": []
}