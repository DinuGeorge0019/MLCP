{"link": "https://codeforces.com//contest/1567/problem/F", "problemId": "1099178", "problem_idx": "F", "shortId": "1567F", "contest_number": "1567", "problem_submissions": {"C": [127974564, 127939959, 127954581, 127964000, 127952919, 127944623, 127939332, 127964327, 127943124, 127968891, 127947814, 127940553, 127945813, 127964268, 127942609, 127947600, 127945820, 127938032, 127948426, 127964716], "A": [127964852, 127922278, 127932015, 127955526, 127943035, 127922628, 127923688, 127926840, 127922694, 127925712, 127924423, 127923731, 127922858, 127922205, 127926705, 127927113, 127928956, 127922373, 127923105, 127922692], "B": [127964231, 127928229, 127928104, 127960707, 127944459, 127929761, 127931746, 127932290, 127933652, 127938027, 127928958, 127942519, 127932981, 127927891, 127934499, 127937493, 127935529, 127926955, 127935971, 127930754], "D": [127962995, 127955193, 127945755, 127969042, 127959015, 127952114, 127951882, 127957740, 127965163, 127957338, 127967067, 128042803, 127957487, 127961796, 127954276, 127956523, 127952133, 127952975, 127957557, 127953745], "E": [127956967, 127950306, 127967160, 127953453, 128966040, 127974173, 128003977, 127960229, 127963530, 127951320, 127958948, 128021683, 127976249, 127963411, 127950253, 128042735, 127964337, 127947637, 127967826, 127965391, 128541587, 127968997, 127966309, 127964418, 127961161], "F": [127951988, 127980467, 127976901, 127981608, 127980938, 128003888, 128003811, 128049440, 127960253, 128042163]}, "name": "F. One-Four Overload", "statement": "Alice has an empty grid with n rows and m columns. Some of the cells are\r\nmarked, and . (Two squares are if they share a side.) Alice wants to\r\nfill each cell with a number such that the following statements are\r\ntrue: every cell contains either the number 1 or 4; every cell contains\r\nthe sum of the numbers in all cells adjacent to it (if a marked cell is\r\nnot adjacent to any unmarked cell, this sum is 0); every cell contains a\r\nmultiple of 5. Alice couldn\u2019t figure it out, so she asks Bob to help\r\nher. Help Bob find any such grid, or state that no such grid exists.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 555, maxM = maxN * maxN * 2;\nint n, m, c[maxN][maxN];\nchar b[maxN][maxN];\nint f[maxM], vis[maxM];\nint dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nvector<int> p[maxM];\n\nint find(int x) {\n\tif (f[x] == x) return x;\n\telse return f[x] = find(f[x]);\n}\n\nvoid merge(int u, int v) {\n\tu = find(u);\n\tv = find(v);\n\tf[find(u)] = find(v);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", b[i]);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tf[(i * m + j) * 2] = (i * m + j) * 2;\n\t\t\tf[(i * m + j) * 2 + 1] = (i * m + j) * 2 + 1;\n\t\t\tvis[i * m + j] = (b[i][j] == '.');\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (b[i][j] == 'X') {\n\t\t\t\tvector<int> d;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (b[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\td.push_back((i + dx[k])*m + (j + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d.size() % 2 != 0) {\n\t\t\t\t\tprintf(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (d.size() == 0) continue;\n\t\t\t\tif (d.size() == 2) {\n\t\t\t\t\tmerge(d[0] * 2, d[1] * 2 + 1);\n\t\t\t\t\tmerge(d[0] * 2 + 1, d[1] * 2);\n\t\t\t\t}\n\t\t\t}\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (b[i][j] == 'X') {\n\t\t\t\tvector<int> d;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (b[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\td.push_back((i + dx[k])*m + (j + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d.size() <= 2) continue;\n\t\t\t\tmerge(d[0] * 2, d[1] * 2 );\n\t\t\t\tmerge(d[0] * 2 + 1, d[1] * 2 + 1);\n\t\t\t\tmerge(d[2] * 2, d[3] * 2 );\n\t\t\t\tmerge(d[2] * 2 + 1, d[3] * 2 + 1);\n\n\t\t\t\tmerge(d[0] * 2, d[2] * 2 + 1);\n\t\t\t\tmerge(d[0] * 2 + 1, d[2] * 2);\n\n\t\t\t}\n\tfor (int i = 0; i < n * m; i++) assert(find(2 * i) != find(2 * i + 1));\n\tfor (int i = 0; i < 2 * n * m; i++) if (vis[i / 2]) p[find(i)].push_back(i);\n\tfor (int i = 0; i < 2 * n * m; i += 2) {\n\t\tif (p[i].empty()) continue;\n\t\tfor (auto q : p[i]) {\n\t\t\tif (q % 2 == 1) {\n\t\t\t\tc[q / 2 / m][q / 2 % m] = 4;\n\t\t\t} else {\n\t\t\t\tc[q / 2 / m][q / 2 % m] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (b[i][j] == 'X') {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (b[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\tc[i][j] += c[i + dx[k]][j + dy[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tputs(\"YES\");\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) printf(\"%d \", c[i][j]);\n\t\tputs(\"\");\n\t}\n}"], "input": "", "output": "", "tags": ["2-sat", "constructive algorithms", "dfs and similar", "dsu", "graphs", "implementation"], "dificulty": "2700", "interactive": false}