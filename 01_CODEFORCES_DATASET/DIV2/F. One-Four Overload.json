{
    "link": "https://codeforces.com//contest/1567/problem/F",
    "problemId": "1099178",
    "problem_idx": "F",
    "shortId": "1567F",
    "contest_number": "1567",
    "problem_submissions": {
        "C": [
            127974564,
            127939959,
            127954581,
            127964000,
            127952919,
            127944623,
            127939332,
            127964327,
            127943124,
            127968891,
            127947814,
            127940553,
            127945813,
            127964268,
            127942609,
            127947600,
            127945820,
            127938032,
            127948426,
            127964716
        ],
        "A": [
            127964852,
            127922278,
            127932015,
            127955526,
            127943035,
            127922628,
            127923688,
            127926840,
            127922694,
            127925712,
            127924423,
            127923731,
            127922858,
            127922205,
            127926705,
            127927113,
            127928956,
            127922373,
            127923105,
            127922692
        ],
        "B": [
            127964231,
            127928229,
            127928104,
            127960707,
            127944459,
            127929761,
            127931746,
            127932290,
            127933652,
            127938027,
            127928958,
            127942519,
            127932981,
            127927891,
            127934499,
            127937493,
            127935529,
            127926955,
            127935971,
            127930754
        ],
        "D": [
            127962995,
            127955193,
            127945755,
            127969042,
            127959015,
            127952114,
            127951882,
            127957740,
            127965163,
            127957338,
            127967067,
            128042803,
            127957487,
            127961796,
            127954276,
            127956523,
            127952133,
            127952975,
            127957557,
            127953745
        ],
        "E": [
            127956967,
            127950306,
            127967160,
            127953453,
            128966040,
            127974173,
            128003977,
            127960229,
            127963530,
            127951320,
            127958948,
            128021683,
            127976249,
            127963411,
            127950253,
            128042735,
            127964337,
            127947637,
            127967826,
            127965391,
            128541587,
            127968997,
            127966309,
            127964418,
            127961161
        ],
        "F": [
            127951988,
            127980467,
            127976901,
            127981608,
            127980938,
            128003888,
            128003811,
            128049440,
            127960253,
            128042163
        ]
    },
    "name": "F. One-Four Overload",
    "statement": "Alice has an empty grid with n rows and m columns. Some of the cells are\r\nmarked, and . (Two squares are if they share a side.) Alice wants to\r\nfill each cell with a number such that the following statements are\r\ntrue: every cell contains either the number 1 or 4; every cell contains\r\nthe sum of the numbers in all cells adjacent to it (if a marked cell is\r\nnot adjacent to any unmarked cell, this sum is 0); every cell contains a\r\nmultiple of 5. Alice couldn’t figure it out, so she asks Bob to help\r\nher. Help Bob find any such grid, or state that no such grid exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 555, maxM = maxN * maxN * 2;\nint n, m, c[maxN][maxN];\nchar b[maxN][maxN];\nint f[maxM], vis[maxM];\nint dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nvector<int> p[maxM];\n\nint find(int x) {\n\tif (f[x] == x) return x;\n\telse return f[x] = find(f[x]);\n}\n\nvoid merge(int u, int v) {\n\tu = find(u);\n\tv = find(v);\n\tf[find(u)] = find(v);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", b[i]);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tf[(i * m + j) * 2] = (i * m + j) * 2;\n\t\t\tf[(i * m + j) * 2 + 1] = (i * m + j) * 2 + 1;\n\t\t\tvis[i * m + j] = (b[i][j] == '.');\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (b[i][j] == 'X') {\n\t\t\t\tvector<int> d;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (b[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\td.push_back((i + dx[k])*m + (j + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d.size() % 2 != 0) {\n\t\t\t\t\tprintf(\"NO\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (d.size() == 0) continue;\n\t\t\t\tif (d.size() == 2) {\n\t\t\t\t\tmerge(d[0] * 2, d[1] * 2 + 1);\n\t\t\t\t\tmerge(d[0] * 2 + 1, d[1] * 2);\n\t\t\t\t}\n\t\t\t}\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (b[i][j] == 'X') {\n\t\t\t\tvector<int> d;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (b[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\td.push_back((i + dx[k])*m + (j + dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d.size() <= 2) continue;\n\t\t\t\tmerge(d[0] * 2, d[1] * 2 );\n\t\t\t\tmerge(d[0] * 2 + 1, d[1] * 2 + 1);\n\t\t\t\tmerge(d[2] * 2, d[3] * 2 );\n\t\t\t\tmerge(d[2] * 2 + 1, d[3] * 2 + 1);\n\n\t\t\t\tmerge(d[0] * 2, d[2] * 2 + 1);\n\t\t\t\tmerge(d[0] * 2 + 1, d[2] * 2);\n\n\t\t\t}\n\tfor (int i = 0; i < n * m; i++) assert(find(2 * i) != find(2 * i + 1));\n\tfor (int i = 0; i < 2 * n * m; i++) if (vis[i / 2]) p[find(i)].push_back(i);\n\tfor (int i = 0; i < 2 * n * m; i += 2) {\n\t\tif (p[i].empty()) continue;\n\t\tfor (auto q : p[i]) {\n\t\t\tif (q % 2 == 1) {\n\t\t\t\tc[q / 2 / m][q / 2 % m] = 4;\n\t\t\t} else {\n\t\t\t\tc[q / 2 / m][q / 2 % m] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (b[i][j] == 'X') {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (b[i + dx[k]][j + dy[k]] == '.') {\n\t\t\t\t\t\tc[i][j] += c[i + dx[k]][j + dy[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tputs(\"YES\");\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) printf(\"%d \", c[i][j]);\n\t\tputs(\"\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. One-Four Overload.json",
    "editorial_link": "https://codeforces.com//blog/entry/94581",
    "editorial": "Letâs look at the numbers in the grid modulo . and are and modulo , and\r\nby definition each marked cell must be modulo . This means that each\r\nmarked cell must have an even number of unmarked neighbors, and there\r\nmust be an equal number of s and s among those neighbors.In other words,\r\nthe problem is about two-coloring a grid so each marked square has the\r\nsame number of red and blue neighbors. If each cell is adjacent to 2 or\r\n4 unmarked cells, then they will form a graph whose faces are\r\ntwo-colorable (the proof of this is below), which will satisfy all\r\nconditions, since all cells adjacent to 2 unmarked cells will be\r\nadjacent to two cells on opposite faces. However, the tricky case is to\r\ndeal with cells with 0 unmarked neighbors.The idea is to put a \"mask\" on\r\ntop of the grid, which will also allow the cells with no unmarked\r\nneighbors to satisfy the condition while not interfering with already\r\nplaced cells. That is, in the coloring terminology above, we will two\r\ncolor the grid, and then flip some cells according to the \"mask\" such\r\nthat all cells with 2 or 4 unmarked neighbors still satisfy the\r\ncondition, and all cells with 0 unmarked neighbors now satisfy the\r\ncondition. We claim that we should flip all cells in all even-numbered\r\ncolumns; that is, the mask should contain columns alternately colored\r\nred and blue. Letâs prove this works.There are four types of marked\r\ncells: a marked cell with no marked neighbors: all four neighbors are in\r\nsame connected component, so none of them will be \"flipped\" with respect\r\nto the rest, and they will work: they will be the numbers by the mask. a\r\nmarked cell with only marked neighors: nothing to check. a marked cell\r\nwith marked neighbors in the shape of an L tromino: again, these\r\nunmarked cells must be part of same connected component, so they will\r\nwork: they will be the numbers and by the mask. a marked cell with\r\nmarked neighbors in the shape of an I tromino: then the cell on one side\r\nis necessarily in a different connected component than the other, so one\r\nwill be flipped by the two-coloring, and they will be the right\r\nparities. It suffices to show that the graph formed by edges between\r\nconnected components of unmarked cells is bipartite. Consider instead\r\nthe graph formed by the marked cells, with an edge between orthogonally\r\nadjacent cells. Consider each connected component of this graph\r\nindividually. By the condition all vertices have degree 0, 2, or 4, but\r\nnone can have degree 0 because the graph is connected. Now by a theorem\r\nof Euler this graph must have a Eulerian cycle.Now we have a more\r\ngeneral claim: the face-vertex dual of a Eulerian graph is bipartite.\r\nSuppose otherwise. Then the dual has some odd cycle. This means that\r\nsome face of the dual must be bounded by an odd number of edges, since\r\nyou can never \"split\" an odd cycle into only even ones. Also, the dual\r\nis planar, because our original graph is obviously planar (we are given\r\nan explicit planar embedding of it!).Now some face of the dual has an\r\nodd number of edges. This means that in the dual graph of the dual, some\r\nvertex has odd degree. But the dual graph of the dual is the original\r\ngraph. So the original graph is both Eulerian and has odd degree, which\r\nis absurd.Finally, even though there are many connected components, it\r\nis clear that they do not interact: just set the infinite outside face\r\nto be one color, and the rest of the faces will be colored\r\nautomatically.Therefore this graph is bipartite, so we can two-color as\r\ndesired, and we are done. Time complexity: .\r\n",
    "hint": []
}