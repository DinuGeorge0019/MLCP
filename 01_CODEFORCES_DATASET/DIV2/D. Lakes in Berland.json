{
    "link": "https://codeforces.com//contest/723/problem/D",
    "problemId": "74120",
    "problem_idx": "D",
    "shortId": "723D",
    "contest_number": "723",
    "problem_submissions": {
        "F": [
            21155697,
            21154113,
            21155933,
            21154904,
            21149973,
            21159426,
            21152095,
            21153693,
            21156752,
            21154148,
            21155446,
            21158512,
            21156719,
            21157841,
            63684195,
            21157428,
            21156472,
            21165079
        ],
        "D": [
            21145243,
            21158845,
            21147482,
            21142220,
            21145053,
            21143706,
            21144743,
            21145722,
            21163140,
            21144768,
            21147552,
            21144060,
            21144166,
            21146675,
            21148374,
            21147946,
            21149603,
            21146889,
            21147955,
            21145653
        ],
        "E": [
            21142890,
            21148616,
            21159045,
            21149920,
            21158556,
            21150731,
            21180051,
            21153029,
            21177875,
            21161980,
            21155864,
            21154968,
            21148045
        ],
        "C": [
            21140474,
            21141296,
            21140148,
            21162108,
            21142166,
            21146292,
            21147879,
            21142862,
            21142174,
            21148589,
            21144499,
            21141215,
            21141347,
            21144291,
            21144339,
            21143781,
            21144417,
            21143640,
            21144289,
            21142493
        ],
        "B": [
            21138785,
            21138330,
            21144052,
            21141269,
            21138610,
            21139747,
            21138581,
            21138753,
            21138976,
            21139782,
            21142236,
            21137955,
            21139130,
            21139752,
            21139693,
            21141265,
            21138488,
            21140188,
            21156231
        ],
        "A": [
            21135605,
            21135289,
            21141496,
            21135525,
            21135366,
            21137068,
            21135345,
            21136036,
            21135454,
            21135984,
            21136355,
            21135335,
            21136286,
            21136540,
            21136310,
            21138762,
            21135363,
            21135712,
            21156449
        ]
    },
    "name": "D. Lakes in Berland",
    "statement": "The map of Berland is a rectangle of the size , which consists of cells\r\nof size . Each cell is either land or water. The map is surrounded by\r\nthe ocean. are the maximal regions of water cells, connected by sides,\r\nwhich are not connected with the ocean. Formally, lake is a set of water\r\ncells, such that it’s possible to get from any cell of the set to any\r\nother without leaving the set and moving only to cells adjacent by the\r\nside, none of them is located on the border of the rectangle, and it’s\r\nimpossible to add one more water cell to the set such that it will be\r\nconnected with any other cell.You task is to fill up with the earth the\r\nminimum number of water cells so that there will be lakes in Berland.\r\nNote that the initial number of lakes on the map is than .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N(55);\nchar st[N][N];\nbool vst[N][N];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint n, m;\ninline bool inRange(int x, int y) {\n\treturn 0 <= x && x < n && 0 <=y && y < m;\n}\nint main() {\n\tvector<vector<pair<int, int> > > ans;\n\tint k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor(int i(0); i < n; i++) {\n\t\tscanf(\"%s\", st[i]);\n\t}\n\tfor(int i(0); i < n; i++) {\n\t\tfor(int j(0); j < m; j++) {\n\t\t\tif(st[i][j] == '.' && !vst[i][j]) {\n\t\t\t\tbool flag(false);\n\t\t\t\tvector<pair<int, int> > vec;\n\t\t\t\tvec.push_back(make_pair(i, j));\n\t\t\t\tvst[i][j] = true;\n\t\t\t\tfor(int op(0); op < (int)vec.size(); op++) {\n\t\t\t\t\tauto v(vec[op]);\n\t\t\t\t\tint x(v.first), y(v.second);\n\t\t\t\t\tfor(int d(0); d < 4; d++) {\n\t\t\t\t\t\tint X(x + dx[d]), Y(y + dy[d]);\n\t\t\t\t\t\tif(!inRange(X, Y)) {\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}else if(st[X][Y] == '.' && vst[X][Y] == false) {\n\t\t\t\t\t\t\tvst[X][Y] = true;\n\t\t\t\t\t\t\tvec.push_back(make_pair(X, Y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag == false) {\n\t\t\t\t\tans.push_back(vec);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res(0);\n\tint rmn(ans.size());\n\twhile(rmn > k) {\n\t\tint mni(-1);\n\t\tfor(int i(0); i < (int)ans.size(); i++) {\n\t\t\tif(ans[i].size()) {\n\t\t\t\tif(mni == -1 || ans[i].size() < ans[mni].size()) {\n\t\t\t\t\tmni = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres += ans[mni].size();\n\t\tfor(auto i : ans[mni]) {\n\t\t\tst[i.first][i.second] = '*';\n\t\t}\n\t\tans[mni].clear();\t\n\t\trmn--;\n\t}\n\tcout << res << endl;\n\tfor(int i(0); i < n; i++) {\n\t\tcout << st[i] << endl;\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Lakes in Berland.json",
    "editorial_link": "https://codeforces.com//blog/entry/47502",
    "editorial": "To solve this problem we need to find all connected components\r\nconsisting of dots, which do not have common border with ocean. For that\r\nwe need to implement depth search which returns vector of the points\r\nfrom which the current connected component consists.Then we need to sort\r\nall connected components in order of increasing of their sizes and\r\nchanges all dots on asterisks in components, beginning from the\r\ncomponent with minimum size, until the number of left components does\r\nnot equals to .\r\n",
    "hint": []
}