{
    "link": "https://codeforces.com//contest/1831/problem/F",
    "problemId": "1942566",
    "problem_idx": "F",
    "shortId": "1831F",
    "contest_number": "1831",
    "problem_submissions": {
        "F": [
            208138276,
            207709337
        ],
        "E": [
            208138261,
            207648682,
            207658220,
            207656838,
            207666357,
            207774368,
            207656515,
            207695977,
            207710932,
            207657876,
            208163887,
            207670786,
            207664348,
            207669868,
            207660228
        ],
        "D": [
            208138229,
            207624019,
            207622747,
            207707096,
            207639773,
            207642056,
            207665762,
            207606856,
            207612471,
            207613443,
            207614547,
            207617717,
            207621891,
            207622928,
            207622371,
            207623544,
            207626326,
            207683940,
            207628627
        ],
        "C": [
            208138202,
            207603654,
            207591133,
            207610375,
            207604106,
            207604842,
            207591198,
            207597318,
            207602578,
            207595759,
            207597417,
            207600531,
            207601702,
            207596236,
            207598453,
            207596408,
            207607400,
            207594213,
            207608501,
            207603207
        ],
        "B": [
            207933759,
            207587309,
            207585317,
            207591044,
            207597740,
            207626518,
            207586353,
            207592366,
            207588011,
            207586628,
            207590623,
            207592643,
            207591011,
            207586905,
            209739181,
            207587547,
            207588237,
            207602435,
            207588035,
            207591775,
            207591535
        ],
        "A": [
            207933729,
            207580780,
            207580051,
            207582133,
            207593347,
            207580551,
            207581151,
            207591960,
            207580225,
            207581009,
            207582654,
            207583238,
            207580711,
            207581264,
            209739158,
            207580917,
            207581616,
            207598296,
            207580446,
            207582701,
            207581592
        ]
    },
    "name": "F. Mex Tree",
    "statement": "You are given a tree with n nodes. For each node, you either color it in\r\n0 or 1.The value of a path (u,v) is equal to the MEX^\r\ndagger of the colors of the nodes from the shortest path between u and\r\nv.The value of a coloring is equal to the sum of values of all paths\r\n(u,v) such that 1\r\nleq u\r\nleq v\r\nleq n.What is the maximum possible value of any coloring of the tree?^{\r\ndagger} The MEX (minimum excluded) of an array is the smallest\r\nnon-negative integer that does not belong to the array. For instance:\r\nThe MEX of [2,2,1] is 0, because 0 does not belong to the array. The MEX\r\nof [3,1,0,1] is 2, because 0 and 1 belong to the array, but 2 does not.\r\nThe MEX of [0,3,1,2] is 4 because 0, 1, 2, and 3 belong to the array,\r\nbut 4 does not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate < typename T >\ninline void read(T &x)\n{\n\tx = 0;\n\tbool flg = 0;\n\tchar c;\n\twhile ((c = getchar()) < 48 || c > 57)\n\t\tflg |= (c == '-');\n\tdo\n\t\tx = (x << 1) + (x << 3) + (c ^ 48);\n\twhile ((c = getchar()) > 47 && c < 58);\n\tif (flg) x = -x;\n}\n\nint OUTPUT[45];\n\ntemplate < typename T >\ninline void write(T x)\n{\n\tif (x < 0)\n\t{\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tint len = 0;\n\tdo\n\t{\n\t\tOUTPUT[++len] = (x % 10) | 48;\n\t\tx /= 10;\n\t}while (x);\n\twhile (len)\n\t\tputchar(OUTPUT[len--]);\n}\n\ntemplate < typename T >\ninline void writesp(T x)\n{\n\twrite(x);\n\tputchar(32);\n}\n\ntemplate < typename T >\ninline void writeln(T x)\n{\n\twrite(x);\n\tputchar(10);\n}\n\nconst int N = 2e5 + 5, B = 785;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nint siz[N];\nlong long g[2][N];\nvector < int > G[N];\nvector < long long > f[N][2];\n/*\nmex \u4e0d\u4e3a 2 \u7684\u70b9\u6784\u6210\u82e5\u5e72\u4e2a\u8fde\u901a\u5757\nf[i][j][k] \u8868\u793a\u7b2c i \u4e2a\u70b9\u989c\u8272\u4e3a k\uff0c\u6240\u5728\u8fde\u901a\u5757\u5927\u5c0f\u4e3a j\uff0c\u5b50\u6811\u5185\u7684\u7b54\u6848 \n*/\ntemplate < typename T >\ninline void Chkmin(T &x, T y)\n{\n\tif (y < x) x = y;\n}\n\nvoid dfs(int x, int fa)\n{\n\tsiz[x] = 1;\n\tf[x][0].emplace_back(INF);\n\tf[x][0].emplace_back(1ll);\n\tf[x][1].emplace_back(INF);\n\tf[x][1].emplace_back(2ll);\n\tfor (auto i : G[x])\n\t\tif (i != fa)\n\t\t{\n\t\t\tdfs(i, x);\n\t\t\tlong long minn0 = INF, minn1 = INF;\n\t\t\tfor (int j = min(siz[i], B); j; --j)\n\t\t\t{\n\t\t\t\tChkmin(minn0, f[i][0][j]);\n\t\t\t\tChkmin(minn1, f[i][1][j]);\n\t\t\t}\n\t\t\tfor (int j = min(siz[x], B); j; --j)\n\t\t\t{\n\t\t\t\tg[0][j] = f[x][0][j];\n\t\t\t\tf[x][0][j] = INF;\n\t\t\t\tg[1][j] = f[x][1][j];\n\t\t\t\tf[x][1][j] = INF;\n\t\t\t}\n\t\t\tfor (int j = min(siz[x] + siz[i], B) - min(siz[x], B); j; --j)\n\t\t\t{\n\t\t\t\tf[x][0].emplace_back(INF);\n\t\t\t\tf[x][1].emplace_back(INF);\n\t\t\t}\n\t\t\tfor (int j = 1; j <= min(siz[x] + siz[i], B); ++j)\n\t\t\t\tfor (int k = max(j - min(siz[x], B), 1); k <= min(min(siz[i], B), j - 1); ++k)\n\t\t\t\t{\n\t\t\t\t\tChkmin(f[x][0][j], f[i][0][k] + g[0][j - k] + (j - k) * k);\n\t\t\t\t\tChkmin(f[x][1][j], f[i][1][k] + g[1][j - k] + (((j - k) * (k << 1))));\n\t\t\t\t}\n\t\t\tfor (int j = min(siz[x], B); j; --j)\n\t\t\t{\n\t\t\t\tChkmin(f[x][0][j], g[0][j] + minn1);\n\t\t\t\tChkmin(f[x][1][j], g[1][j] + minn0);\n\t\t\t}\n\t\t\tsiz[x] += siz[i];\n\t\t\tf[i][0].clear();\n\t\t\tf[i][0].shrink_to_fit();\n\t\t\tf[i][1].clear();\n\t\t\tf[i][1].shrink_to_fit();\n\t\t}\n}\n\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tint T;\n\tread(T);\n\twhile (T--)\n\t{\n\t\tint n;\n\t\tread(n);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tG[i].clear();\n\t\t\tf[i][0].clear();\n\t\t\tf[i][1].clear();\n\t\t}\n\t\tfor (int i = 1; i < n; ++i)\n\t\t{\n\t\t\tint x, y;\n\t\t\tread(x);\n\t\t\tread(y);\n\t\t\tG[x].emplace_back(y);\n\t\t\tG[y].emplace_back(x);\n\t\t}\n\t\tdfs(1, 0);\n\t\tlong long ans = INF;\n\t\tfor (int i = min(siz[1], B); i; --i)\n\t\t\tChkmin(ans, min(f[1][0][i], f[1][1][i]));\n\t\twriteln((long long)n * (n + 1ll) - ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "brute force",
        "dp",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mex Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "Disclaimer: I ( tibinyte2006 ) wanted to cut O(nn???)\n memory because I thought that setting 1024 MB memory limit would spoil the solution. So only blame me for this.\n\nWe will do a complementary problem which is finding the minimum loss of a coloring. The initial cost is the maximum possible cost, n?(n+1)\n.\n\nIf we analyze how good a bipartite coloring of the given tree is we can note that loss?2?n\n\nNow suppose the tree has a connected component of size k\n. We can note that in such a coloring loss?k?(k+1)2\n\nBy the 2\n claims above, we can note that in an optimal coloring, the maximum size k\n of a connected component respects k?(k+1)2?2?n\n. Thus we can safely say k?4?n?????\n.\n\nNow let dpi,j,color\n be the minimum loss if we color the subtree of i\n and the connected component of vertex i\n has size j\n. We can calculate this in a knapsack style by adding subtrees successively. The computation takes O(n?n???)\n if we use the 7\n-th trick from this blog.\n\nNow we are only left to optimize memory, since now it's O(n?n???)\n. We can directly apply this to get linear memory.\n\nHowever, the bound of k?4?n?????\n is overestimated, for n=200000\n it can be proven that the worst case for k\n is 258\n."
}