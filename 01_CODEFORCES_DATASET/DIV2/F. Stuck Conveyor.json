{
    "link": "https://codeforces.com//contest/1838/problem/F",
    "problemId": "1951239",
    "problem_idx": "F",
    "shortId": "1838F",
    "contest_number": "1838",
    "problem_submissions": {
        "E": [
            208486336,
            208494772,
            208495329,
            208495228,
            208504838,
            208502550,
            208502081,
            208506624,
            208501784,
            208497568,
            208484754,
            208502274,
            208506982,
            208508861,
            208509587
        ],
        "D": [
            208474393,
            208472020,
            208475917,
            208474806,
            208470276,
            208484610,
            208476486,
            208481947,
            208484438,
            208492182,
            208509562,
            208485512,
            208497675,
            208502977,
            208488728,
            208469550,
            208477928,
            208461571
        ],
        "C": [
            208459822,
            208460902,
            208460156,
            208459254,
            208459677,
            208455873,
            208462517,
            208452784,
            208459736,
            208463220,
            208467092,
            208460581,
            208458526,
            208468810,
            208477568,
            208454310,
            208448256,
            208470265
        ],
        "B": [
            208453654,
            208447995,
            208452616,
            208450470,
            208449926,
            208446381,
            208454035,
            208446799,
            208444336,
            208450882,
            208456322,
            208448611,
            208449662,
            208456059,
            208462080,
            208447155,
            208442110,
            208452374
        ],
        "A": [
            208438767,
            208438058,
            208439478,
            208435532,
            208440850,
            208437783,
            208437196,
            208435664,
            208435519,
            208435964,
            208439335,
            208440976,
            208441596,
            208440802,
            208440409,
            208436085,
            208439210,
            208439722
        ],
        "F": [
            209584777,
            208548659
        ]
    },
    "name": "F. Stuck Conveyor",
    "statement": "This is an interactive problem.There is an n by n grid of conveyor\r\nbelts, in positions (1, 1) through (n, n) of a coordinate plane. Every\r\nother square in the plane is empty. Each conveyor belt can be configured\r\nto move boxes up (”), down (”), left (”), or right (”). If a box moves\r\nonto an empty square, it stops moving.However, one of the n^2 belts is\r\nstuck, and will always move boxes in the same direction, no matter how\r\nit is configured. Your goal is to perform a series of tests to determine\r\nwhich conveyor belt is stuck, and the direction in which it sends\r\nitems.To achieve this, you can perform up to 25 tests. In each test, you\r\nassign a direction to all n^2 belts, place a box on top of one of them,\r\nand then turn all of the conveyors on. The conveyors move the box around\r\ntoo quickly for you to see, so the only information you receive from a\r\ntest is whether the box eventually stopped moving, and if so, the\r\ncoordinates of its final position.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n// clang-format off\n\n#define           fi    first\n#define           se    second\n#define           pb    push_back\n#define           ep    emplace\n#define           eb    emplace_back\n#define           lb    lower_bound\n#define           ub    upper_bound\n#define       all(x)    x.begin(), x.end()\n#define      rall(x)    x.rbegin(), x.rend()\n#define   uniquev(v)    sort(all(v)), (v).resize(unique(all(v)) - (v).begin())\n#define     mem(f,x)    memset(f , x , sizeof(f))\n#define        sz(x)    (int32_t)(x).size()\n#define  __lcm(a, b)    (1ll * ((a) / __gcd((a), (b))) * (b))\n#define          mxx    *max_element\n#define          mnn    *min_element\n#define         left    Kurumi_Tokisaki\n#define        right    Kei_Karuizawa\n#define         next    Mai_Sakurajima\n#define          div    Yume_Irido\n#define         prev    Chizuru_Mizuhara\n#define    cntbit(x)    __builtin_popcountll(x)\n#define      MASK(x)    ( 1ll << (x) )\n#define          Yes    cout << \"Yes\"\n#define          YES    cout << \"YES\"\n#define           No    cout << \"No\"\n#define           NO    cout << \"NO\"\n#define           AA    cout << \"Alice\"\n#define           BB    cout << \"Bob\"\n\n/// TASK\n/// -----------------------------\n#ifdef LMQZZZ\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \" ]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n\n#define deb(x...) cerr << \"[ in \" <<__func__<< \"() : line \" <<__LINE__<< \" ] : [ \" << #x << \" ] = [ \"; _print(x); cerr << '\\n';\n#define TASK \"ss\"\n#else\n#define deb(x...) 3326\n#define TASK \"\"\n#endif\n///------------------------------\n\nvoid lmqzzz();\nvoid init() {};\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);      cout.tie(0);\n        if (fopen(TASK \".inp\", \"r\")) {\n                freopen(TASK \".inp\", \"r\", stdin);\n                freopen(TASK \".out\", \"w\", stdout);\n        }\n        /// =================================\n                constexpr bool MULTITEST = 0;\n        /// ================================\n        init();\n        int32_t TT = 1;\n        if ( MULTITEST ) cin >> TT;\n        for(int32_t TTT = 1; TTT <= TT; TTT ++) {\n                lmqzzz();\n                cout << '\\n';\n        }\n}\n\ntemplate <class T> inline T min(const T &a, const T &b, const T &c) { return min(a, min(b, c)); }\ntemplate <class T> inline T max(const T &a, const T &b, const T &c) { return max(a, max(b, c)); }\ntemplate <class T, class U> inline bool mini(T &a, const U &b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate <class T, class U> inline bool maxi(T &a, const U &b) { if (a < b) { a = b; return 1; } return 0; }\n\nconstexpr     int16_t dr[]  =  {0, 0, -1, 1};\nconstexpr     int16_t dc[]  =  {1, -1, 0, 0};\nconstexpr      int64_t MOD  =  1e9 + 7;\nconstexpr     int32_t MAXN  =  1e6 + 10;\n\n// clang-format on\n\nconst string dir = \"^v<>\";\n\nenum {\n        U = 0,\n        D = 1,\n        L = 2,\n        R = 3\n};\n\nvoid lmqzzz() {\n        int n;\n        cin >> n;\n        string left(n - 1, dir[L]);\n        string right(n - 1, dir[R]);\n        vector<string> mat;\n        for (int i = 0; i < n; i++) {\n                string tmp = i % 2 ? (dir[D] + left) : (right + dir[D]);\n                mat.emplace_back(tmp);\n        }\n        int xx = n + 1, yy = n % 2 ? n : 1;\n        cout << \"? 1 1\\n\";\n        for (auto s : mat) cout << s << '\\n';\n        cout << flush;\n\n        int x, y;\n        cin >> x >> y;\n\n        vector<pair<int, int>> path;\n        for (int i = 1; i <= n; i++) {\n                vector<pair<int, int>> tmp;\n                for (int j = 1; j <= n; j++) tmp.emplace_back(i, j);\n                if ((i - 1) % 2) reverse(all(tmp));\n                path.insert(path.end(), all(tmp));\n        }\n        if (x != xx || y != yy) {\n                path.emplace_back(xx, yy);\n        } else {\n                mat.clear();\n                for (int i = 1; i <= n; i++) {\n                        mat.emplace_back(i % 2 ? (dir[U] + string(n - 1, dir[L])) : (string(n - 1, dir[R]) + dir[U]));\n                }\n                reverse(all(path));\n                path.emplace_back(0, 1);\n        }\n\n        int l = 0, r = path.size() - 2, ax, ay;\n        while (l <= r) {\n                int mid = l + r >> 1;\n                auto [rr, cc] = path[mid];\n                cout << \"? \" << rr << ' ' << cc << '\\n';\n                for (auto s : mat) cout << s << '\\n';\n                cout << flush;\n                int x, y;\n                cin >> x >> y;\n                if (make_pair(x, y) != path.back()) {\n                        ax = rr, ay = cc;\n                        l = mid + 1;\n                } else {\n                        r = mid - 1;\n                }\n        }\n        mat.clear();\n        for (int i = 1; i <= n; i++) mat.emplace_back(string(n, dir[R]));\n        cout << \"? \" << ax << ' ' << ay << '\\n';\n        for (auto s : mat) cout << s << '\\n';\n        cout << flush;\n        int bx, by;\n        cin >> bx >> by;\n        char ad;\n        if (bx == -1 || by == 0) {\n                ad = dir[L];\n        } else if (bx == ax - 1) {\n                ad = dir[U];\n        } else if (bx == ax + 1) {\n                ad = dir[D];\n        } else {\n                ad = dir[R];\n        }\n\n        cout << \"! \" << ax << ' ' << ay << ' ' << ad;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Stuck Conveyor.json",
    "editorial_link": "https://codeforces.com//blog/entry/116995",
    "editorial": "The key to our solution will be these two \"snake\" configurations:We will\r\ninitially query the first snake with the box on the top left, and the\r\nsecond snake with the box on the bottom left (or bottom right, depending\r\non parity of ).Note that these two snakes, with the box on the given\r\nstarting positions, each form a single path such that the box visits all\r\nsquares, and the second snake visits squares in the reverse order of the\r\nfirst.Now, consider some cases.If the stuck conveyor belt directs items\r\nto an empty square, then for both of the above configurations, the box\r\nwill end up in that empty square. This cannot be the \"intended\" behavior\r\nfor both of them, because the intended behavior for both of them is\r\ndifferent. So in one snake, we will know that this is unintended\r\nbehavior. Because each possible empty square is only adjacent to one\r\nbelt, we know exactly which belt must have sent it there, and therefore\r\nwhich one is broken.If the stuck conveyor belt directs items to another\r\nbelt, number the conveyor belts from to in the order they are visited by\r\nthe first snake, and consider two subcases: If the other belt has a\r\nlower number than the stuck belt, then the box will enter an infinite\r\nloop for the first snake query, and will terminate for the second snake\r\nquery. Since the opposite will happen in the other case, this allows us\r\nto distinguish these two subcases.Consider what happens if we ask the\r\nfirst snake query again, but place the box on belt instead of belt .\r\nAssume the stuck belt is belt . Because the stuck belt directs items to\r\na belt with smaller number, if , the box will hit the stuck belt, and\r\nenter an infinite loop. If , the box will never encounter the stuck\r\nbelt, so it will eventually reach the end of the snake and stop\r\nmoving.So with one query, by checking whether the box enters an infinite\r\nloop, we can determine whether or . This allows us to binary search for\r\nin queries. The case where the other belt has a higher number than the\r\nstuck belt is analogous, using the second snake query rather than the\r\nfirst. So now, in all cases, we know which of the belts is stuck. In\r\norder to determine the direction in which it is stuck, we use one more\r\nquery. Place the box on the stuck conveyor, and direct all belts in the\r\nsame row or column as the stuck belt away from it (all other belts can\r\nbe directed arbitrarily). Here is one example for where the stuck belt\r\nis :So we will get a different final position for the box for each of\r\nthe four directions in which it could be stuck, and can recover the\r\ndirection.The total number of queries for these steps is bounded by .\r\nSince , this is at most .Complexity:\r\n",
    "hint": []
}