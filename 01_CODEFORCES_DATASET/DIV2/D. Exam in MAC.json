{"link": "https://codeforces.com//contest/1935/problem/D", "problemId": "2510288", "problem_idx": "D", "shortId": "1935D", "contest_number": "1935", "problem_submissions": {"F": [249811158, 249879664, 249914146, 253436865, 253436779, 249829995, 249883407, 250140723, 250140588], "E": [249795863, 249806897, 249806016, 249798150, 249809204, 249810510, 249813605, 249811376, 249815627, 249812083, 249809741, 249806184, 249812511, 249817539, 249815136, 249812113, 249814837, 249819842], "B": [249781740, 249751689, 249753292, 249765548, 249748977, 249751802, 249753680, 249757222, 249771661, 249760318, 249763328, 249766386, 249759882, 249765172, 249756443, 249760201, 249770177, 249763394, 249755331], "C": [249775741, 249762276, 249765158, 249776179, 249761477, 249764700, 249766485, 249776568, 249788464, 249770693, 249776753, 249780744, 249769798, 249778919, 249777602, 249777662, 249785568, 249777744, 249769139], "D": [249754703, 249774116, 249776894, 249784670, 249778866, 249776850, 249778167, 249792030, 249756994, 249781860, 249794874, 249794304, 249791400, 249793376, 249789336, 249797727, 249794804, 249793568, 249791344], "A": [249745747, 249745965, 249747700, 249754230, 249752123, 249745614, 249941865, 249747635, 249746024, 249765018, 249751275, 249749292, 249756879, 249748862, 249749602, 249746174, 249751494, 249751493, 249747948, 249747369]}, "name": "D. Exam in MAC", "statement": "The Master\u2019s Assistance Center has announced an entrance exam, which\r\nconsists of the following.The candidate is given a set s of size n and\r\nsome strange integer c. For this set, it is needed to calculate the\r\nnumber of pairs of integers (x, y) such that 0\r\nleq x\r\nleq y\r\nleq c, x + y contained in the set s, and also y - x contained in the set\r\ns.Your friend wants to enter the Center. Help him pass the exam!\r\n", "solutions": ["#include<bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)\n#define cln cerr<<\"Line:   \"<<__LINE__<<\"    \"\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]='\\n';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,n,m,a[N],b[N];\nll ans;\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n>>m;\n        for(i=1;i<=n;++i)cin>>a[i];\n        sort(a+1,a+n+1),n=unique(a+1,a+n+1)-a-1;\n        ans=(1ll+m)*(m+2)/2;\n        for(i=1;i<=n;++i){\n            ans-=(a[i]>>1)+1;\n            ans-=m-a[i]+1;\n        }\n        for(i=1,l=r=0;i<=n;++i){\n            if(a[i]&1)ans+=++l;\n            else ans+=++r;\n        }printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "combinatorics", "implementation", "math"], "dificulty": "1800", "interactive": false}