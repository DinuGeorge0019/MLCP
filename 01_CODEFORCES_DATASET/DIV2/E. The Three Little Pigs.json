{
    "link": "https://codeforces.com//contest/1549/problem/E",
    "problemId": "1062378",
    "problem_idx": "E",
    "shortId": "1549E",
    "contest_number": "1549",
    "problem_submissions": {
        "F2": [
            124954760
        ],
        "B": [
            124947565,
            124545808,
            124541593,
            124946530,
            124553166,
            124545711,
            124536914,
            124556540,
            124566832,
            124527986,
            124941325,
            124545594,
            124575237,
            124552639,
            124521339,
            124527240,
            124534396,
            124536389,
            124529098,
            124547548,
            124525326,
            124539590,
            124546541
        ],
        "A": [
            124947501,
            124518305,
            124519670,
            124946570,
            124520785,
            124519203,
            124517993,
            124517559,
            124518317,
            124518952,
            124941237,
            124534955,
            124569653,
            124519648,
            124517299,
            124518094,
            124521899,
            124520868,
            124518074,
            124519228,
            124517443,
            124519076,
            124518992
        ],
        "F1": [
            124584680,
            124595832,
            124599734,
            124593371,
            124597616,
            124593738,
            124591194,
            124592802,
            124602219,
            124602384,
            124588472,
            124753532,
            124592653,
            124603568,
            124595865
        ],
        "E": [
            124572687,
            124578681,
            124586160,
            124580564,
            124586278,
            124587026,
            124603080,
            124600315,
            124577736,
            124595081,
            124580521,
            124597748,
            124594829,
            124597255,
            124685628,
            124601974
        ],
        "D": [
            124558908,
            124554190,
            124550650,
            124565038,
            124571505,
            124565266,
            124557657,
            124634855,
            124586699,
            124566420,
            124566608,
            124571026,
            124544812,
            124558707,
            124568055,
            124617780,
            124551649,
            124555888,
            124569746,
            124549100,
            124571724,
            124554851
        ],
        "C": [
            124534727,
            124537090,
            124536290,
            124552036,
            124551687,
            124549175,
            124538153,
            124547780,
            124552849,
            124553941,
            124540508,
            124527050,
            124538078,
            124556164,
            124573095,
            124538823,
            124554597,
            124536966,
            124553733,
            124540516
        ]
    },
    "name": "E. The Three Little Pigs",
    "statement": "Three little pigs from all over the world are meeting for a convention!\r\nEvery minute, a triple of 3 new pigs arrives on the convention floor.\r\nAfter the n-th minute, the convention ends.The big bad wolf has learned\r\nabout this convention, and he has an attack plan. At some minute in the\r\nconvention, he will arrive and eat exactly x pigs. Then he will get\r\naway.The wolf wants Gregor to help him figure out the number of possible\r\nattack plans that involve eating exactly x pigs for various values of x\r\n(1\r\nle x\r\nle 3n). Two attack plans are considered different, if they occur at\r\ndifferent times or if the sets of little pigs to eat are different.Note\r\nthat all queries are independent, that is, the wolf does not eat the\r\nlittle pigs, he only makes plans!\r\n",
    "solutions": [
        "// Problem: E. The Three Little Pigs\n// Contest: Codeforces - Codeforces Round #736 (Div. 2)\n// URL: https://codeforces.com/contest/1549/problem/E\n// Memory Limit: 512 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define chkmx(a,b) ((a)=max((a),(b)))\n#define chkmn(a,b) ((a)=min((a),(b)))\nusing namespace std;\ntemplate<typename T>\ninline void read(T &x){x=0;char c=getchar();bool f=false;for(;!isdigit(c);c=getchar())f|=c=='-';for(;isdigit(c);c=getchar())x=x*10+c-'0';if(f)x=-x;}\ntemplate<typename T ,typename ...Arg>inline void read(T &x,Arg &...args){read(x);read(args...);}\ntemplate<typename T>inline void write(T x){if(x<0)putchar('-'),x=-x;if(x>=10)write(x/10);putchar(x%10+'0');}\n//#define int long long\ntypedef long long ll;\ntemplate<const int mod>\nstruct modint{\n    int x;\n    modint<mod>(int o=0){x=o;}\n    modint<mod> &operator = (int o){return x=o,*this;}\n    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}\n    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}\n    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}\n    modint<mod> &operator ^=(int b){\n        modint<mod> a=*this,c=1;\n        for(;b;b>>=1,a*=a)if(b&1)c*=a;\n        return x=c.x,*this;\n    }\n    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}\n    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}\n    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}\n    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}\n    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}\n    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}\n    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}\n    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}\n    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}\n    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}\n    friend bool operator ==(modint<mod> a,int b){return a.x==b;}\n    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}\n    bool operator ! () {return !x;}\n    modint<mod> operator - () {return x?mod-x:0;}\n    modint<mod> &operator++(int){return *this+=1;}\n};\ntypedef modint<1000000007>mint;\nconst int N=3000100;\nint n,m;mint fac[N],ifac[N],f[N],g[N];\nmint C(int n,int m){\n\tif(n<m)return 0;\n\treturn fac[n]*ifac[m]*ifac[n-m];\n}\nsigned main(){\n\tread(n,m);\n\tfac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i;\n\tifac[N-1]=1/fac[N-1];for(int i=N-1;i;i--)ifac[i-1]=ifac[i]*i;\n\tfor(int i=0;i<=3*n+3;i++)f[i]=C(3*n+3,i)-C(3,i);\n\tfor(int i=0;i<=3*n+3;i++)f[i]=f[i+1];\n\tfor(int i=3*n+3;~i;i--){\n\t\tg[i]=f[i+2];\n\t\tf[i+2]-=g[i];\n\t\tf[i+1]-=3*g[i];\n\t\tf[i]-=3*g[i];\n\t}\n\tassert(f[0]==0);\n\tassert(f[1]==0);\n\tassert(f[2]==0);\n\twhile(m--){\n\t\tint x;read(x);write(g[x].x);putchar('\\n');\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Three Little Pigs.json",
    "editorial_link": "https://codeforces.com//blog/entry/93586",
    "editorial": "For a given x\n, we want to compute ?Ni=1(3ix)\n, which can be solved with a combinatorial dynamic programming.\n\nDefine the array dp[x][m] (dimensions: N+1\u00d73\n), which computes the sum ?N?1i=0(3i+mx)\n. Under this definition, ans[x]=dp[x][0]+(3Nx)\n, where ans is what we want to find.\n\nUnder the definition of the dp, we can make the following mathematical observations.\n\ndp[x][0]+dp[x][1]+dp[x][2]=?3N?1i=0(ix)\n, since term i\n belongs to the array with m=imod3\n. This summation can be condensed with the Hockey Stick Identity into (3Nx+1)\n.\n\nBy repeated uses of Pascal's Identity, we get equations (2) and (3), giving us a system of 3 equations with 3 new unknowns, which can easily be solved.\n\n?2m=0dp[x][m]=(3Nx+1)\n.\ndp[x][1]=dp[x][0]+dp[x?1][0]\ndp[x][2]=dp[x][1]+dp[x?1][1]\nThe base case is that dp[0][0]=dp[0][1]=dp[0][2]=N\n. Each query can now be answered trivially.\n\nThe time complexity is O(N+Q)\n with combinatorial precomputation."
}