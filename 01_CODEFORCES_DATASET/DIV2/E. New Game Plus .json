{
    "link": "https://codeforces.com//contest/1457/problem/E",
    "problemId": "814145",
    "problem_idx": "E",
    "shortId": "1457E",
    "contest_number": "1457",
    "problem_submissions": {
        "E": [
            99868612,
            99868820,
            99868894,
            99871379,
            99876241,
            99873210,
            99873073,
            99877427,
            99875242,
            99874362,
            99880934,
            99878599,
            99880282,
            99880267,
            99880129,
            99881010,
            99881186,
            99878842,
            99883433,
            99887042
        ],
        "D": [
            99860413,
            99858501,
            99859224,
            99855503,
            99852261,
            99861676,
            99862738,
            99863057,
            99864198,
            99864361,
            99855111,
            99866971,
            99857047,
            99869259,
            99872023,
            99871057,
            99871185,
            99871389,
            99870989,
            99870957
        ],
        "C": [
            99848523,
            99846546,
            99854121,
            99849522,
            99849975,
            99852554,
            99857957,
            99855488,
            99850137,
            99854183,
            99851123,
            99848085,
            99862644,
            99857309,
            99851618,
            99858097,
            99853416,
            99850485,
            99861161,
            99863907
        ],
        "B": [
            99842172,
            99842416,
            99847160,
            99843642,
            99841920,
            99843802,
            99852704,
            99845703,
            99844331,
            99847361,
            99846671,
            99841358,
            99851090,
            99848157,
            99844121,
            99845368,
            99843677,
            99857603,
            99853155,
            99848846
        ],
        "A": [
            99839848,
            99840102,
            99841257,
            99839720,
            99841011,
            99840218,
            99839732,
            99841278,
            99840508,
            99841843,
            99839833,
            99839677,
            99846294,
            99845677,
            99840019,
            99840219,
            99840262,
            99842567,
            99843366,
            99841538
        ]
    },
    "name": "E. New Game Plus ",
    "statement": "Wabbit is playing a game with n bosses numbered from 1 to n. The bosses\r\ncan be fought in any order. Each boss needs to be defeated . There is a\r\nparameter called which is initially 0.When the i-th boss is defeated,\r\nthe current is added to Wabbit\u2019s score, and then the value of the\r\nincreases by the point increment c_i. Note that c_i can be negative,\r\nwhich means that other bosses now give fewer points.However, Wabbit has\r\nfound a glitch in the game. At any point in time, he can reset the\r\nplaythrough and start a New Game Plus playthrough. This will set the\r\ncurrent to 0, while all defeated bosses remain defeated. The current\r\nscore is also saved and does reset to zero after this operation. This\r\nglitch can be used k times. He can reset after defeating any number of\r\nbosses (including before or after defeating all of them), and he also\r\ncan reset the game several times in a row without defeating any\r\nboss.Help Wabbit determine the maximum score he can obtain if he has to\r\ndefeat n bosses.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pre(i,a,b) for(int i=a;i>=b;i--)\n#define N 500005\n#define int long long\nusing namespace std;\nint n,k,a[N],u[N],m;\npriority_queue<int>q;\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\trep(i,1,n)scanf(\"%lld\",&a[i]),a[i]=-a[i];\n\tsort(a+1,a+n+1);rep(i,1,n)a[i]=-a[i];\n\tint c=0,cur=1,ans=0;\n\twhile(c>=0&&cur<=n)ans+=c,c+=a[cur++];\n\trep(i,cur,n)u[++m]=a[i];\n\tsort(u+1,u+m+1);\n\tk++;rep(i,1,k)q.push(0);\n\t//rep(i,1,m)printf(\"%d \",u[i]);putchar('\\n');\n\trep(i,1,m){\n\t\tint x=-q.top();q.pop();\n\t\tans+=x*u[i];q.push(-x-1);\n\t}\n\tprintf(\"%lld\\n\",ans+c*(-q.top()));\n\treturn 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. New Game Plus .json",
    "editorial_link": "https://codeforces.com//blog/entry/85118",
    "editorial": "We see that each playthrough (whether it is the first one or any of the playthroughs after the reset) is completely independent of any other playthrough. Thus, we should instead think of the problem as partitioning the n\n bosses into k+1\n playthroughs.\n\nConsider a playthrough with x\n bosses which have point increments a1,a2,?,ax\n when fought in order. Then, the number of points that we will get is (x?1)a1+(x?2)a2+\u0085+(1)ax?1+(0)ax\n. A simple greedy argument tell us that within a single playthrough, we should always fight the bosses in non-increasing order of point increments, i.e. a1?a2?\u0085?ax\n.\n\nWe can visualize this with k+1\n stacks, each representing a playthrough. Each stack contains all of the bosses that will be fought in that playthrough, and the stack is non-increasing from top to bottom, meaning we fight the bosses from top to bottom.\n\n\nWe now see that k=0\n is a fairly trivial case; just fight the bosses in non-increasing order of point increments. For the rest of the tutorial, we will assume k?1\n.\n\nFor simplicity, we say that a boss is in position p\n of a playthrough if there are p\n more bosses below this one on its playthrough stack. Notice that if we have two bosses in two different playthroughs with point increments a\n and b\n with positions i\n and j\n in their respective playthroughs, then the total points gained from the two bosses is ia+jb\n. We now see that if a?b\n, then i?j\n and vice versa. For example, the configuration below is not optimal because swapping the ?5\n and ?3\n gives a better answer.\n\n\nTherefore, all bosses in lower-numbered positions should have point increments that are less than any boss in a higher-numbered position. This means that we can place the bosses on the stacks one at a time in non-decreasing order of point increments to reach an optimal configuration.\n\nCall a boss good if it has a non-negative point increment, and bad otherwise. Let's fix the arrangement of bad bosses and try to place the good bosses in non-decreasing order of point increments. We can see that placing a boss with point increment a\n on a stack with height h\n will add ah\n to the total, so we should always pick the stack with maximum height. Thus, all of the good bosses will always end up on the same stack, and that stack will be the stack of maximum height. Call this stack the main stack; the other k\n stacks are the side stacks.\n\nIf there exists two side stacks whose heights differ by at least 2\n, then we can always move the top-most bad boss of the taller side stack to the shorter side stack and decrease the loss in points. In the example below, the ?10\n on the left stack (of height 5\n) can be moved down to the top of the right stack (of height 3\n).\n\n\nThus, the maximum and minimum heights of these k\n side stacks cannot differ by more than 1.\n\nLet the minimum height of these k\n stacks be h\n. If we consider the bottom h\n bosses of all k+1\n stacks, we see that they still must have the property that all bosses in lower positions have point increments that are less than any boss in higher positions. Thus, they must consist of the h(k+1)\n bosses with smallest point increments.\n\nDirect Greedy\n\nWe first sort the bosses in non-decreasing order of point increments. For each possible prefix P\n that contains only negative point increments, we take all bosses in P\n and distribute them evenly across the k+1\n stacks. We then take the remaining bosses and place them on the tallest of the stacks (if there are multiple stacks of the same height, the result is the same).\n\nPerforming this computation naively takes O(n2)\n time, but this can be sped up using precomputation of weighted prefix and suffix sums to evaluate all configurations in O(n)\n. The final time complexity is O(nlogn)\n due to sorting.\n\nSmarter Greedy\n\nLet's take all n\n point increments and place them in a \"sliding\" stack such that they are arranged in non-decreasing order from bottom to top. We will slide the stack across the k+1\n playthroughs and leave the bottom point increment behind. Shown below is an example with n=8\n and k=2\n.\n\n\nEvery time we slide the stack, we reduce the total by the sum of all of the point increments that we slide down by 1\n position. Thus, we should only slide it down if the sum of those is less than 0\n as that will give us a more optimal solution.\n\n\nWe notice that the point increments that we slide down always form a suffix of the point increments when sorted in non-decreasing order. The moment we stop sliding is when the sum of the suffix is non-negative, giving the optimal solution. Thus, we can find the optimal configuration directly by finding the right suffix and distributing the remaining negative point increments evenly.\n\nGenius Greedy (found by K0u1e)\n\nSort the point increments in non-increasing order a1,a2,\u0085,an\n. Maintain a priority queue that initially contains k+1\n zeros. We now process the point increments in non-increasing order.\n\nTo process the current point increment ai\n, we perform the following steps in order:\n\nFind the largest number x\n in the priority queue and remove it from the priority queue\nAdd x\n to our running total\nPush x+ai\n back into the priority queue\nThe answer is the final total at the end. It will be left as an exercise to the reader to figure out why this solution is indeed equivalent to the previous solution."
}