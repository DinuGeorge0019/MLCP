{
    "link": "https://codeforces.com//contest/617/problem/C",
    "problemId": "46105",
    "problem_idx": "C",
    "shortId": "617C",
    "contest_number": "617",
    "problem_submissions": {
        "B": [
            15525292,
            15520241,
            15520782,
            15519093,
            15520541,
            15518993,
            15520816,
            15520328,
            15522323,
            15519740,
            15519199,
            15519236,
            15522269,
            15520061,
            15520921,
            15520553,
            15521134
        ],
        "E": [
            15524504,
            15533637,
            15536969,
            15529659,
            15535325,
            15529489,
            15527806,
            15532273,
            19715009,
            15542654,
            15534610,
            15534856,
            53538378,
            15532458
        ],
        "D": [
            15522122,
            15524102,
            15527458,
            15532675,
            15531424,
            15537486,
            15523234,
            15528078,
            15529838,
            15539257,
            15526873,
            15536074,
            15530391,
            15531537,
            15525866,
            15527771,
            15525195,
            15535593
        ],
        "A": [
            15518850,
            15516543,
            15516542,
            15517397,
            15516883,
            15518022,
            15517052,
            15517168,
            15516689,
            15517881,
            15517750,
            15516596,
            15516595,
            15516666,
            15516591,
            15517486,
            15517447,
            15518711
        ],
        "C": [
            15527346,
            15535776,
            15522904,
            15520819,
            15525590,
            15541637,
            15525965,
            15525876,
            15534504,
            15523565,
            15522950,
            15532930,
            15526671,
            15524426,
            15522962,
            15532766
        ]
    },
    "name": "C. Watering Flowers",
    "statement": "A flowerbed has many flowers and two fountains.You can adjust the water\r\npressure and set any values and , giving the distances at which the\r\nwater is spread from the first and second fountain respectively. You\r\nhave to set such and that all the flowers are watered, that is, for each\r\nflower, the distance between the flower and the first fountain doesn’t\r\nexceed , or the distance to the second fountain doesn’t exceed . It’s OK\r\nif some flowers are watered by both fountains.You need to decrease the\r\namount of water you need, that is set such and that all the flowers are\r\nwatered and the is minimum possible. Find this minimum value.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <int, PII> PIP;\ntypedef pair <ll, int> PLI;\ntypedef pair <PII, ll> PIIL;\ntypedef pair <int, ll> PIL;\ntypedef unsigned int ui;\nconst int mod = 1e9+7;\nconst int inf = 1e9+9;\nconst ll MOD = 1e9+696969;\nconst ll INF = 1e18;\n#define maxn 2010\ninline ll sqr(ll a) {\n\treturn a*a;\n}\nint n;\nPII t[maxn];\nll d[maxn][2];\nll odl(int a, int b)\n{\n\treturn sqr(t[a].e1 - t[b].e1) + sqr(t[a].e2 - t[b].e2);\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &t[0].e1, &t[0].e2);\n\tscanf(\"%d%d\", &t[n+1].e1, &t[n+1].e2);\n\tfor (int i=1; i<=n; ++i) scanf(\"%d%d\", &t[i].e1, &t[i].e2);\n\tfor (int i=1; i<=n; ++i)\n\t  d[i][0] = odl(0, i), d[i][1] = odl(n+1, i);\n\n\tll res = INF;\n\tfor (int j=0; j<2; ++j) {\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tll wart = d[i][0]; //kwadrat\n\t\tll MIN = 0;\n\t\tfor (int j=1; j<=n; ++j)\n\t\t  if (d[j][0] > wart) MIN = max(MIN, d[j][1]);\n\t\tres = min(res, wart + MIN);\n\t}\n\tfor (int j=1; j<=n; ++j) swap(d[j][0], d[j][1]);\n\t}\n\n\tcout << res;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Watering Flowers.json",
    "editorial_link": "https://codeforces.com//blog/entry/22971",
    "editorial": "First radius equals to zero or distance from first fountain to some\r\nflower. Letâs iterate over this numbers. Second radius equals to maximal\r\ndistance from second fountain to flower which doesnât belong to circle\r\nwith first radius. Now we should choose variant with minimal . Bonus:\r\nItâs solution. Can you solve problem in )? Solution 15550812 Solution\r\n15550822\r\n",
    "hint": []
}