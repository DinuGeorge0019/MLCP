{
    "link": "https://codeforces.com//contest/1990/problem/D",
    "problemId": "2766779",
    "problem_idx": "D",
    "shortId": "1990D",
    "contest_number": "1990",
    "problem_submissions": {
        "E2": [
            271608671,
            271607138,
            271614388,
            271623848,
            271611159,
            271612390,
            271624654,
            271606284,
            271618767,
            271968367,
            271632009,
            271670295,
            271670041,
            271669953,
            271631571,
            271628300,
            271628735,
            271594502,
            271625522,
            271630429,
            271657508,
            271657312,
            271656848,
            271656620,
            271656329,
            271656057,
            271655884,
            271651026,
            271650811,
            271629403,
            271633667
        ],
        "E1": [
            271608290,
            271606824,
            271613580,
            271620803,
            271612480,
            271607245,
            271626074,
            271605565,
            271618674,
            271617329,
            271631880,
            271630922,
            271628223,
            271626847,
            271593184,
            271625989,
            271629147,
            271621610,
            271633499
        ],
        "D": [
            271584964,
            271585839,
            271588228,
            271580018,
            271775642,
            271574070,
            271621395,
            271597835,
            276025328,
            271618139,
            271579386,
            271580161,
            271592306,
            271593113,
            271583094,
            271588957,
            271599530,
            271586840,
            271606900,
            271582390,
            271597556,
            271601916
        ],
        "C": [
            271573202,
            271574801,
            271573394,
            271562726,
            271563640,
            271558919,
            271563245,
            276025316,
            271572711,
            271573247,
            271567920,
            271567517,
            271556748,
            271561905,
            271578677,
            271614383,
            271580098,
            271585887,
            271628007,
            271582340,
            271582612
        ],
        "B": [
            271544838,
            271560423,
            271562782,
            271545814,
            271553448,
            271544083,
            271550614,
            271557693,
            271552078,
            271550946,
            271576591,
            271554451,
            271552855,
            271607828,
            271555492,
            271573754,
            271547063,
            271567926,
            271553335
        ],
        "A": [
            271536644,
            271538330,
            271540486,
            271536626,
            271537675,
            271536719,
            271540682,
            271537637,
            271536282,
            271542554,
            271544093,
            271538945,
            271539444,
            271610786,
            271544740,
            271545994,
            271537196,
            271539275,
            271540687
        ],
        "F": [
            271738112,
            271736701,
            271736437,
            271736279,
            271732364,
            271623141
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131716",
    "editorial": "Read hints first.\n\nFor ai?5\n, we will definitely use operation 2\n on the i\n-th row because at least three 2×2\n subgrid are needed to cover it, which is not better then do three times operation 2\n in the i?1,i\n and i+1\n row.\n\nNow we can only consider ai?4\n cases. Let's consider from left to right.\n\nIn the left most row, there are 3\n cases:\n\nthere is no black cells Do nothing;\n\nthere is ?2\n black cells. We can put one 2×2\n subgrid greedily;\n\nthere is >2\n black cells. We just use one time operation 2\n in this row(try to prove it).\n\nWe can summarize that for the i\n-th row, there are only three situations where it is affected by the i?1\n-th row:\n\nit is not affected;\n\nthe cells in the third and fourth columns have been colored white;\n\nthe cells in the first and second columns have been colored white.\n\nWe can greedily process this process from left to right, or use DP.",
    "name": "D. Grid Puzzle",
    "statement": "You are given an array a of size n.There is an n\r\ntimes n grid. In the i-th row, the first a_i cells are black and the\r\nother cells are white. In other words, note (i,j) as the cell in the\r\ni-th row and j-th column, cells (i,1), (i,2),\r\nldots, (i,a_i) are black, and cells (i,a_i+1),\r\nldots, (i,n) are white.You can do the following operations any number of\r\ntimes in any order: Dye a 2\r\ntimes 2 subgrid white; Dye a whole row white. Note you can dye a whole\r\ncolumn white. Find the minimum number of operations to dye all cells\r\nwhite.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; using ll = long long;// #define int ll #define endl '\\n'#define pb push_backusing pi = array<int, 2>; const int V = 4;const int INF = 1e9; void skibidi_sigma() {  int n;  cin >> n;    vector<int> a(n + 1);  for (int i = 1; i <= n; ++i) {    cin >> a[i];  }    // dp[i][0] - if nothing erased  // dp[i][1] - if first 2 erased  // dp[i][2] - if last 2 erased  vector dp(n + 1, vector(3, INF));  dp[0][0] = dp[0][1] = dp[0][2] = 0;  for (int i = 1; i <= n; ++i) {    if (a[i] > 4) {      dp[i][0] = dp[i][1] = dp[i][2] = dp[i - 1][0] + 1;    } else if (a[i] == 0) {      dp[i][0] = dp[i][1] = dp[i][2] = dp[i - 1][0];    } else if (a[i] <= 2) {      dp[i][0] = dp[i - 1][1] + 1;      dp[i][1] = dp[i - 1][0];      dp[i][2] = dp[i - 1][1] + 1;    } else {      dp[i][0] = dp[i - 1][0] + 1;      dp[i][1] = dp[i - 1][2] + 1;      dp[i][2] = dp[i - 1][1] + 1;    }  }    int ans = dp[n][0];  cout << ans;} int32_t main() {  ios_base::sync_with_stdio(false);  cin.tie(NULL);    int T;  cin >> T;    while (T--) {    skibidi_sigma();    cout << endl;  }} /* if a[i] > 4 then i should just apply full row operation */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Grid Puzzle.json",
    "hint": []
}