{
    "link": "https://codeforces.com//contest/1668/problem/A",
    "problemId": "1373074",
    "problem_idx": "A",
    "shortId": "1668A",
    "contest_number": "1668",
    "problem_submissions": {
        "E": [
            154123739,
            154125336,
            154119851,
            154113083,
            154126230,
            154111025,
            154118734,
            154118893,
            154116518
        ],
        "D": [
            154102065,
            154111480,
            154109461,
            154112828,
            154127256,
            154120568,
            154199100,
            154098507,
            154101292,
            154104775,
            154103929,
            154095552,
            154104771,
            154104638
        ],
        "C": [
            154084164,
            154089822,
            154082750,
            154086924,
            154096669,
            154097603,
            154087733,
            154089704,
            154084845,
            154091220,
            154093921,
            154082051,
            154082528,
            154089420,
            154085834,
            154089820,
            154100489,
            154080049,
            154081283
        ],
        "B": [
            154081285,
            154084224,
            154085663,
            154082020,
            154152941,
            154084489,
            154090124,
            154084331,
            154085985,
            154081983,
            154085223,
            154085348,
            154095598,
            154087105,
            154085147,
            154082318,
            154081788,
            154081908,
            154090843,
            154084167
        ],
        "A": [
            154079113,
            154080383,
            154079244,
            154078891,
            154152929,
            154079977,
            154085842,
            154079717,
            154081051,
            154079292,
            154081689,
            154080381,
            154089065,
            154090204,
            154080866,
            154080201,
            154079483,
            154080405,
            154087751,
            154079358
        ],
        "F": [
            154125193,
            154162167,
            154110277,
            154120657
        ]
    },
    "name": "A. Direction Change",
    "statement": "You are given a grid with n rows and m columns. Rows and columns are\r\nnumbered from 1 to n, and from 1 to m. The intersection of the a-th row\r\nand b-th column is denoted by (a, b). Initially, you are standing in the\r\ntop left corner (1, 1). Your goal is to reach the bottom right corner\r\n(n, m).You can move in four directions from (a, b): up to (a-1, b), down\r\nto (a+1, b), left to (a, b-1) or right to (a, b+1).You cannot move in\r\nthe same direction in two consecutive moves, and you cannot leave the\r\ngrid. What is the minimum number of moves to reach (n, m)?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll i,j,k,n,m,t;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m;\n\t\tn--;m--;\n\t\tif(n>m)swap(n,m);\n\t\tif(n+m<=1){\n\t\t\tcout<<n+m<<'\\n';continue;\n\t\t}\n\t\tif(!n||!m){\n\t\t\tcout<<\"-1\\n\";continue;\n\t\t}\n\t\tcout<<m+m-((m-n)&1)<<'\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Direction Change.json",
    "editorial_link": "https://codeforces.com//blog/entry/102013",
    "editorial": "Solution The moves are symmetrical, so we can assume that . There is no\nsolution if and , because one can only move up and down, but two\nconsecutive down moves is required to reach .Otherwise, there is a\nsolution. One should move downwards at least times, and it is forbidden\nto do that twice in a row, so another move is necessary ( between each\npair). So at least moves required. If is even, then one more, because\nthe parity of changes after every move, and the parity is even before\nthe first and after the last move, so the total number of moves should\nbe even.There is a construction for that lower bound:Move alternately\ndown and right. After reaching the -th column, repeat the following\nsequence of moves: down, left, down, right. With this move long\nsequence, one can move down two times. So we will reach , then one more\nmove is required, or we will reach . If we add all of these moves, we\nget the formula: if is even then: ,and if is odd then: .\n",
    "hint": []
}