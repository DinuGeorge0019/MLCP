{
    "link": "https://codeforces.com//contest/447/problem/D",
    "problemId": "11397",
    "problem_idx": "D",
    "shortId": "447D",
    "contest_number": "447",
    "problem_submissions": {
        "E": [
            7084046,
            7087165,
            7086012,
            7107031,
            7088335
        ],
        "D": [
            7080732,
            7079815,
            7083822,
            7083834,
            7085600,
            7097008,
            7086688,
            7084686,
            7086053,
            7083895,
            7086461,
            7089129,
            7088930,
            7089222,
            7089284,
            7087016,
            7089423
        ],
        "C": [
            7078096,
            7076875,
            7077066,
            7078076,
            7077877,
            7079534,
            7081397,
            7082455,
            7080387,
            7085378,
            7082941,
            7079168,
            7082968,
            7081821,
            7082878,
            7082053,
            7087589,
            7079590
        ],
        "B": [
            7076707,
            7075254,
            7075472,
            7076218,
            7075554,
            7075342,
            7077508,
            7076837,
            7076067,
            7075642,
            7075896,
            7082177,
            7078872,
            7077244,
            7076799,
            7078894,
            7077501,
            7076959
        ],
        "A": [
            7074384,
            7074446,
            7074355,
            7074389,
            7074552,
            7074411,
            7075432,
            7075052,
            7074452,
            7074502,
            7074400,
            7080033,
            7075081,
            7075723,
            7074815,
            7076200,
            7075918,
            7075090
        ]
    },
    "name": "D. DZY Loves Modification",
    "statement": "As we know, DZY loves playing games. One day DZY decided to play with a\r\nmatrix. To be more precise, he decided to modify the matrix with exactly\r\noperations.Each modification is one of the following: Pick some row of\r\nthe matrix and decrease each element of the row by . This operation\r\nbrings to DZY the value of pleasure equal to the sum of elements of the\r\nrow before the decreasing. Pick some column of the matrix and decrease\r\neach element of the column by . This operation brings to DZY the value\r\nof pleasure equal to the sum of elements of the column before the\r\ndecreasing. DZY wants to know: what is the largest total value of\r\npleasure he could get after performing exactly modifications? Please,\r\nhelp him to calculate this value.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n\nchar ch;\n\nvoid read(int &x)\n{\n    x=0;\n    ch=getchar();\n    while (ch<=32) ch=getchar();\n    while (ch>32) x=x*10+ch-48,ch=getchar();\n}\n\nint n,m,k,p;\nint a[1005][1005];\nint s1[1005];\nint s2[1005];\n\nlong long ans1[1000005];\nlong long ans2[1000005];\n\nstd::priority_queue<long long> pq;\n\nvoid solve1()\n{\n    while (!pq.empty()) pq.pop();\n    int i;\n    for (i=1;i<=n;i++) {\n        pq.push(s1[i]);\n    }\n    ans1[0]=0;\n    long long now=0;\n    for (i=1;i<=k;i++) {\n        long long tmp=pq.top();\n        now+=tmp;\n        pq.pop();\n        pq.push(tmp-1LL*p*m);\n        ans1[i]=now;\n    }\n}\n\nvoid solve2()\n{\n    while (!pq.empty()) pq.pop();\n    int i;\n    for (i=1;i<=m;i++) {\n        pq.push(s2[i]);\n    }\n    ans2[0]=0;\n    long long now=0;\n    for (i=1;i<=k;i++) {\n        long long tmp=pq.top();\n        now+=tmp;\n        pq.pop();\n        pq.push(tmp-1LL*p*n);\n        ans2[i]=now;\n    }\n}\n\nlong long ans;\n\nvoid solve()\n{\n    solve1();\n    solve2();\n    ans=-1000000000000000000LL;\n    int i;\n    for (i=0;i<=k;i++) {\n        long long tmp=ans1[i]+ans2[k-i]-1LL*i*(k-i)*p;\n        if (tmp>ans) ans=tmp;\n    }\n}\n\nint main()\n{\n    read(n);read(m);read(k);read(p);\n    int i,j;\n    for (i=1;i<=n;i++) {\n        for (j=1;j<=m;j++) {\n            read(a[i][j]);\n            s1[i]+=a[i][j];\n            s2[j]+=a[i][j];\n        }\n    }\n    solve();\n    printf(\"%I64d\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. DZY Loves Modification.json",
    "editorial_link": "https://codeforces.com//blog/entry/13036",
    "editorial": "If p?=?0, apperently the best choice is choosing the row or column which can give greatest pleasure value each time.\n\nIgnore p first,then we can get a greatest number ans. Then if we choose rows for i times, choose columns for k?-?i times, ans should subtract (k?-?i)?×?i?×?p.\n\nSo we could enumerate i form 0 to k and calculate ansi?-?(k?-?i)?*?i?*?p each time, max {ansi?-?(k?-?i)?*?i?*?p} is the maximum possible pleasure value DZY could get.\n\nLet ai be the maximum pleasure value we can get after choosing i rows and bi be the maximum pleasure value we can get after choosing i columns. Then ansi?=?ai?+?bk?-?i. We can use two priority queues to calculate ai and bi quickly.",
    "hint": []
}