{
    "link": "https://codeforces.com//contest/1858/problem/E2",
    "problemId": "2166171",
    "problem_idx": "E2",
    "shortId": "1858E2",
    "contest_number": "1858",
    "problem_submissions": {
        "E1": [
            218971675,
            218948691,
            218950036,
            218981081,
            218981577,
            218982148,
            219044099,
            218987081,
            218959071,
            219043079,
            218997113,
            218975893,
            218978028,
            218974432,
            218978584,
            218984712,
            218984251,
            219051896,
            218984058,
            218985452,
            218989668,
            218998871,
            218971815
        ],
        "E2": [
            218971226,
            218946559,
            218949779,
            219003260,
            218981396,
            218982111,
            218983780,
            219043918,
            218987338,
            219043124,
            218997698,
            218975689,
            218977856,
            219035037,
            219051939,
            218998573
        ],
        "D": [
            218958822,
            218970595,
            218957970,
            218958903,
            218949856,
            218961365,
            218967040,
            218972943,
            219043010,
            218960726,
            218998607,
            218989664,
            218961840,
            218965618,
            218966574,
            218969464,
            218974328,
            218972414,
            218969139,
            218981714,
            218991387
        ],
        "C": [
            218944984,
            218929618,
            218962105,
            218928296,
            218926980,
            218941771,
            218950307,
            218944949,
            219042947,
            218946392,
            218934108,
            218941439,
            218951937,
            218933349,
            218935592,
            218942151,
            218948522,
            218948262,
            218943920,
            218947281,
            218951547
        ],
        "B": [
            218935374,
            218982876,
            218965626,
            218941114,
            218939372,
            218933262,
            218946217,
            218938100,
            219042924,
            218940019,
            218950811,
            218937233,
            218946328,
            218943500,
            218950259,
            218936903,
            218940772,
            218941478,
            218938583,
            218962280,
            218941262
        ],
        "A": [
            218918372,
            218920879,
            218959798,
            218918668,
            218919313,
            218918787,
            218926715,
            218920787,
            219043052,
            219042898,
            218921173,
            218920067,
            218918574,
            218919674,
            218918423,
            218919655,
            218919188,
            218922439,
            218922802,
            218918900,
            218943440,
            218921894
        ]
    },
    "name": "E2. Rollbacks  Hard Version ",
    "statement": "You have an array a, which is initially empty. You need to process\r\nqueries of the following types: x add the integer x to the end of the\r\narray a. k remove the last k numbers from the array a. roll back the\r\nlast active change (i.e., make the array a the way it was before the\r\nchange). In this problem, only queries of the first two types ( and )\r\nare considered as changes. find the number of distinct numbers in the\r\narray a.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...)\n#endif\n\nconst int N = 1e6 + 6, A = 1e6, L = 20;\nconst int N_ = N * (L + 1);\n\nint tt = 0;\nint lc[N_], rc[N_];\n\nint copy(int k) {\n  int i = ++tt;\n  lc[i] = lc[k];\n  rc[i] = rc[k];\n  return i;\n}\nvoid upd(int &k, int l, int r, int i) {\n  k = copy(k);\n  if (l < r) {\n    int m = (l + r) / 2;\n    if (i <= m) {\n      upd(lc[k], l, m, i);\n    } else {\n      upd(rc[k], m + 1, r, i);\n    }\n  }\n}\nbool qry(int k, int l, int r, int i) {\n  if (!k) return 0;\n  if (l == r) return 1;\n  int m = (l + r) / 2;\n  return i <= m ? qry(lc[k], l, m, i) : qry(rc[k], m + 1, r, i);\n}\n\nint ver[N], sum[N];\nint pp[L][N], par[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int q;\n  cin >> q;\n  for (int h = 1; h <= q; h++) {\n    char c;\n    cin >> c;\n    if (c == '+') {\n      int x;\n      cin >> x, x--;\n      par[h] = h - 1;\n      ver[h] = ver[h - 1];\n      sum[h] = sum[h - 1];\n      if (!qry(ver[h], 0, A - 1, x)) {\n        upd(ver[h], 0, A - 1, x);\n        sum[h]++;\n      }\n      pp[0][h] = h - 1;\n      for (int l = 1; l < L; l++) {\n        pp[l][h] = pp[l - 1][pp[l - 1][h]];\n      }\n    } else if (c == '-') {\n      int k;\n      cin >> k;\n      par[h] = h - 1;\n      int u = h - 1;\n      for (int l = 0; l < L; l++)\n        if (k >> l & 1) u = pp[l][u];\n      ver[h] = ver[u];\n      sum[h] = sum[u];\n      for (int l = 0; l < L; l++) pp[l][h] = pp[l][u];\n    } else if (c == '!') {\n      int p = par[h - 1];\n      par[h] = par[p];\n      ver[h] = ver[p];\n      sum[h] = sum[p];\n      for (int l = 0; l < L; l++) pp[l][h] = pp[l][p];\n    } else {\n      par[h] = par[h - 1];\n      ver[h] = ver[h - 1];\n      sum[h] = sum[h - 1];\n      for (int l = 0; l < L; l++) pp[l][h] = pp[l][h - 1];\n      cout << sum[h] << endl;\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "interactive",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Rollbacks  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/119398",
    "editorial": "First, let\u00e2\u0080\u0099s learn how to solve the problem without rollbacks. Let be an\r\narray of the same length as , where if is the minimum position at which\r\nthe number is in the array , and otherwise. Then the number of different\r\nnumbers in the array is equal to the sum of all the elements of the\r\narray .The array can be maintained using a Fenwick tree, a segment tree,\r\nor any other data structure that supports point updates and range sum\r\nqueries. The author\u00e2\u0080\u0099s solution uses the Fenwick tree. Let\u00e2\u0080\u0099s use the\r\nmethod that is often used when implementing a stack or a deque: we\r\ncreate a large array and at each moment we store the index of the last\r\n\"existing\" element (this is just the size of the array at this moment).\r\nThe array itself will be a prefix of , that is, for . Also, for each\r\nvalue we maintain of indexes on which the value is located in the array\r\n(in , not in ).Then for the operation of removing elements from the end\r\nof the array , it is enough to reduce the value of the index by . This\r\noperation works in .When adding one element to the end of the array, we\r\nneed to check if it has been encountered before, and change one element\r\nin the Fenwick tree accordingly. This can be done in using for the\r\ncorresponding value. You also need to increase by 1, assign after that,\r\nand update the corresponding . This operation works for .In order to\r\nfind the number of different numbers in , we need to find the sum in the\r\nFenwick tree on the prefix of length in the array . This operation works\r\nin .Now, we need to learn how to roll back operations. Note that we\r\nperform the deletion operation in , and the addition operation in , so\r\nwe can roll back these operations with the same asymptotics. We can just\r\nstore a stack of all changes, and remember everything that we changed\r\nduring the operations.The final asymptotics is .\r\n"
}