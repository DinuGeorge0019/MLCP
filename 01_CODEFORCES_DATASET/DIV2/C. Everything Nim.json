{
    "link": "https://codeforces.com//contest/1966/problem/C",
    "problemId": "2615003",
    "problem_idx": "C",
    "shortId": "1966C",
    "contest_number": "1966",
    "problem_submissions": {
        "E": [
            258440120,
            258447865,
            258441495,
            258448292,
            258453329,
            258455007,
            258455562,
            258463703,
            258454902,
            258457920,
            258464021,
            258461311,
            258462638,
            258462895,
            258465595,
            258463312,
            258462674,
            258458699
        ],
        "B": [
            258438529,
            258422443,
            258424110,
            258425316,
            258424919,
            258422815,
            258422044,
            258421183,
            258426420,
            258424238,
            258425787,
            258424328,
            258425355,
            258428106,
            258426188,
            258424457,
            258424995,
            258442623
        ],
        "D": [
            258429599,
            258433739,
            258439478,
            258442551,
            258438117,
            258440328,
            258436731,
            258432022,
            258450610,
            258450325,
            258442193,
            258450098,
            258450833,
            258450813,
            258448974,
            258453024,
            258454359,
            258451828
        ],
        "C": [
            258425131,
            258429293,
            258430381,
            258430477,
            258430820,
            258432851,
            258429869,
            258440236,
            258434780,
            258430009,
            258432109,
            258435350,
            258435642,
            258434757,
            258435098,
            258436413,
            258434457,
            258433325
        ],
        "A": [
            258421447,
            258418791,
            258419370,
            258420086,
            258417776,
            258418880,
            258418284,
            258421321,
            258417852,
            258418112,
            258418571,
            258418222,
            258418421,
            258419544,
            258419765,
            258417953,
            258420988,
            258424462
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "If the smallest pile is of size 1\n, then Alice must choose k=1\n in her first move. Therefore, we can imagine subtracting 1\n from all piles, and determining who wins given that Bob goes first. We can repeat this process, switching the first player back and forth, until there is no longer a pile of size 1\n. At this point, we are in one of two states:\n\nIf there are no piles remaining, the first player loses, because they cannot make any moves\nOtherwise, the smallest pile is of size x?2\n. We can show that the first player will always win. To do this, consider what happens if the first player chooses k=x\n:\nIf this would create a losing state for the next player, then the first player can choose k=x\n and win.\nOtherwise, the state reached by choosing k=x\n is a winning state for the next player to move. So the first player can choose k=x?1\n, forcing the second player to choose k=1\n. The first player will now be in the winning state and can proceed to win the game.\nTo implement this solution, we only need to keep track of the largest pile size a\n, and the smallest positive integer b\n that is not a pile size (essentially the MEX of the pile sizes, excluding 0\n).\n\nIf b>a\n, then Alice and Bob will be forced to choose k=1\n until the end of the game, so the parity of a\n determines the winner. Otherwise, they will eventually reach a state with minimum pile size at least 2\n, so the parity of b\n determines the winner.\n\nComplexity: O(n)\n or O(nlogn)\n depending on implementation",
    "name": "C. Everything Nim",
    "statement": "Alice and Bob are playing a game on n piles of stones. On each player\u2019s\r\nturn, they select a positive integer k that is at most the size of the\r\nsmallest pile and remove k stones from nonempty pile at once. The first\r\nplayer who is unable to make a move (because all piles are empty)\r\nloses.Given that Alice goes first, who will win the game if both players\r\nplay optimally?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair<int,int> pii;const int N=5e5+5,Inf=1e9;int n,m,a[N];signed main(){\tstd::ios::sync_with_stdio(false);\tcin.tie(0),cout.tie(0);\tint t;\tcin>>t;\twhile(t--){\t\tcin>>n;\t\tfor(int i=1;i<=n;++i)cin>>a[i];\t\tsort(a+1,a+n+1),m=unique(a+1,a+n+1)-a-1;\t\tbool tag=false;\t\tfor(int i=1;i<=m;++i){\t\t\tif(a[i]!=i){\t\t\t\tif(i&1)cout<<\"Alice\\n\";\t\t\t\telse cout<<\"Bob\\n\";\t\t\t\ttag=true;break;\t\t\t}\t\t}\t\tif(!tag){\t\t\tif(m&1)cout<<\"Alice\\n\";\t\t\telse cout<<\"Bob\\n\";\t\t}\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Everything Nim.json"
}