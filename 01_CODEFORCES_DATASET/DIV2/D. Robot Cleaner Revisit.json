{
    "link": "https://codeforces.com//contest/1623/problem/D",
    "problemId": "1243268",
    "problem_idx": "D",
    "shortId": "1623D",
    "contest_number": "1623",
    "problem_submissions": {
        "E": [
            140927316,
            140928588,
            140930913,
            140931529,
            140930666,
            140933308,
            140932491,
            140927816,
            140937929,
            140940400,
            140934079,
            140940202,
            140928211,
            140936652,
            140911137,
            140938749,
            140941503,
            140941228,
            140938408,
            140940310
        ],
        "D": [
            140917013,
            140919394,
            140925084,
            140922860,
            140922841,
            140918471,
            140924963,
            140923599,
            140924181,
            140925202,
            140925220,
            140928107,
            140933937,
            140922988,
            140926612,
            140931586,
            140929916,
            140930490,
            140925401,
            140923945
        ],
        "A": [
            140906789,
            140901830,
            140902316,
            140901965,
            140901890,
            140902105,
            140901764,
            140909860,
            140901988,
            140902630,
            140901845,
            140901878,
            140902576,
            140902335,
            140902196,
            140902015,
            140902189,
            140902188,
            140903240
        ],
        "C": [
            140904718,
            140907986,
            140909100,
            140911556,
            140909513,
            140908941,
            140916100,
            140929063,
            140914447,
            140912787,
            140914401,
            140913485,
            140929704,
            140924697,
            140932081,
            140917741,
            140907191,
            140910390,
            140913379,
            140914345
        ],
        "B": [
            140902082,
            140904432,
            140906305,
            140905274,
            140903910,
            140903807,
            140906896,
            140906851,
            140906344,
            140908551,
            140906181,
            140906829,
            140906183,
            140905516,
            140935513,
            140912560,
            140903639,
            140905940,
            140907051,
            140906596
        ]
    },
    "name": "D. Robot Cleaner Revisit",
    "statement": "A robot cleaner is placed on the floor of a rectangle room, surrounded\r\nby walls. The floor consists of n rows and m columns. The rows of the\r\nfloor are numbered from 1 to n from top to bottom, and columns of the\r\nfloor are numbered from 1 to m from left to right. The cell on the\r\nintersection of the r-th row and the c-th column is denoted as (r,c).\r\nThe initial position of the robot is (r_b, c_b).In one second, the robot\r\nmoves by dr rows and dc columns, that is, after one second, the robot\r\nmoves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc\r\n= 1. If there is a vertical wall (the left or the right walls) in the\r\nmovement direction, dc is before the movement, so the new value of dc is\r\n-dc. And if there is a horizontal wall (the upper or lower walls), dr is\r\nbefore the movement, so the new value of dr is -dr.Each second\r\n(including the moment before the robot starts moving), the robot cleans\r\nevery cell lying in the same row the same column as its position. There\r\nis only one dirty cell at (r_d, c_d). The job of the robot is to clean\r\nthat dirty cell. After a lot of testings in problem A, the robot is now\r\nbroken. It cleans the floor as described above, but at each second the\r\ncleaning operation is performed with probability\r\nfrac p {100} only, and not performed with probability 1 -\r\nfrac p {100}. The cleaning or not cleaning outcomes are independent each\r\nsecond.Given the floor size n and m, the robot\u2019s initial position (r_b,\r\nc_b) and the dirty cell\u2019s position (r_d, c_d), find the for the robot to\r\ndo its job.It can be shown that the answer can be expressed as an\r\nirreducible fraction\r\nfrac x y, where x and y are integers and y\r\nnot\r\nequiv 0\r\npmod{10^9 + 7} . Output the integer equal to x\r\ncdot y^{-1}\r\nbmod (10^9 + 7). In other words, output such an integer a that 0\r\nle a < 10^9 + 7 and a\r\ncdot y\r\nequiv x\r\npmod {10^9 + 7}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint mpow(int x, int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % mod;\n\t\ty >>= 1; x = 1ll * x * x % mod;\n\t}\n\treturn ret;\n}\n\nint norm(int x) {\n\treturn x >= mod ? x - mod : x;\n}\n\nint reduce(int x) {\n\treturn x < 0 ? x + mod : x;\n}\n\nconst int d[2] = {-1, 1};\n\nint vis[100005][2][2];\n\nstruct state {\n\tint x, y, dx, dy;\n\tstate(int x_ = 0, int y_ = 0, int dx_ = 0, int dy_ = 0) : x(x_), y(y_), dx(dx_), dy(dy_) {}\n};\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, m, x, y, a, b, p;\n\t\tcin >> n >> m >> x >> y >> a >> b >> p;\n\t\tauto s = [&](int x, int y) { return (x - 1) * m + y; };\n\t\tp = 1ll * p * mpow(100, mod - 2) % mod; p = reduce(1 - p);\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvector<state> seq;\n\t\tstate now = state(x, y, 1, 1);\n\t\tint pos = 0;\n\t\twhile (1) {\n\t\t\tseq.push_back(now);\n\t\t\tif (vis[s(now.x, now.y)][now.dx][now.dy]) {\n\t\t\t\tpos = vis[s(now.x, now.y)][now.dx][now.dy];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[s(now.x, now.y)][now.dx][now.dy] = (int)seq.size();\n\t\t\tif (now.x + d[now.dx] < 1 || now.x + d[now.dx] > n) now.dx ^= 1;\n\t\t\tif (now.y + d[now.dy] < 1 || now.y + d[now.dy] > m) now.dy ^= 1;\n\t\t\tnow.x += d[now.dx]; now.y += d[now.dy];\n\t\t}\n\t\t--pos;\n\t\tint ca = 1, cb = 0;\n\t\t// for (int i = 0; i < (int)seq.size(); i++) cout << seq[i].x << \" \" << seq[i].y << endl;\n\t\tfor (int i = (int)seq.size() - 2; i >= pos; i--) {\n\t\t\tif (seq[i].x == a || seq[i].y == b) {\n\t\t\t\tca = 1ll * p * ca % mod, cb = 1ll * p * cb % mod;\n\t\t\t\tcb = norm(cb + p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcb = (cb + 1) % mod;\n\t\t}\n\t\tint ans = 1ll * cb * mpow(reduce(1 - ca), mod - 2) % mod;\n\t\tfor (int i = pos - 1; i >= 0; i--) {\n\t\t\tif (seq[i].x == a || seq[i].y == b) {\n\t\t\t\tans = 1ll * ans * p % mod;\n\t\t\t\tans = norm(ans + p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = (ans + 1) % mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Robot Cleaner Revisit.json",
    "editorial_link": "https://codeforces.com//blog/entry/98463",
    "editorial": "In order to see how my solution actually works, let\u00e2\u0080\u0099s solve this\r\nproblem, the math way! You can skip to the \"In general, ...\" part if you\r\ndon\u00e2\u0080\u0099t really care about these concrete examples.First of all, let be the\r\nprobability of , that is, the probability that the robot will not be\r\nable to clean. So .Let\u00e2\u0080\u0099s revisit the first example again. In this\r\nexample, the robot has 2 states: when it was at position , and when it\r\nwas at . Let be the answer for this problem when the robot started at ,\r\nand be the answer for this problem when the robot started at .Let\u00e2\u0080\u0099s\r\nconsider the first state. If the robot can clean, it spends seconds to\r\nclean the dirty cell. Otherwise, it will spend seconds. Therefore, we\r\nhave an equation: .Similarly, we also have the an equation: , since\r\nthese two states are symetrical. Subtituding into , we haveBy\r\nsubstituting in, we can find the value of .Let\u00e2\u0080\u0099s consider the other\r\nexample. In this example, the robot has 4 states: when it is at , when\r\nit is at but going to the right, when it is at , and when it is at but\r\ngoing to the left. Let the answer for these states be and . Similar to\r\nthe previous example, we can write down the equations:Substituting these\r\nequations back to back, we can have the following equation: And again,\r\nif we substitute in, the answer can be found easily.In general, the path\r\nthat the robot takes will form a cycle, containing the initial position.\r\nIf we call the answer to the problem at the initial position, the\r\nequation we need to solve will have the following form:where is the\r\nnumber of states in the cycle, and is some coefficient. if, at the -th\r\nstate in the cycle, we have an opportunity to clean the dirty cell, and\r\notherwise.The equation can easily be solved by expanding the brackets\r\nfrom the innermost to the outermost, by going through the cycle in the\r\nreverse order. After the expansion, the equation will be a very simple\r\nlinear equation with the form , and the solution will be .To construct\r\nthe equation, we can first find the cycle by either DFS or BFS, and go\r\nthrough the cycle in the reverse order for expansion. Or, we can do the\r\nreverse simulation, maintaining the coefficient and right away. And even\r\nbetter, we can just forget about the cycle and iterate exactly times\r\n(not though), since will always be the multiple of the cycle length. The\r\ntime complexity of this solution is .\r\n"
}