{
    "link": "https://codeforces.com//contest/1979/problem/F",
    "problemId": "2684284",
    "problem_idx": "F",
    "shortId": "1979F",
    "contest_number": "1979",
    "problem_submissions": {
        "F": [
            264479061,
            264488646,
            264505247,
            264595233,
            264619291
        ],
        "E": [
            264463709,
            264456182,
            264454663,
            264460110,
            264469235,
            264463422,
            264466790,
            264478578,
            264473477,
            264470909,
            264471670,
            264477459,
            264475074,
            264468357,
            264475963,
            264472031,
            264477800,
            264475608,
            264472217
        ],
        "D": [
            264443096,
            264466698,
            264438605,
            264433389,
            264436848,
            264441621,
            264445629,
            264439468,
            264443494,
            264448547,
            264437284,
            264438609,
            264445824,
            264448565,
            264448792,
            264448782,
            264436980,
            264445527,
            264444587
        ],
        "C": [
            264426913,
            264419354,
            264425968,
            264424857,
            264419880,
            264427385,
            264428474,
            264417768,
            264426268,
            264426216,
            264426191,
            264428203,
            264424558,
            264432779,
            264423537,
            264427769,
            264423741,
            264426473,
            264428054
        ],
        "B": [
            264418439,
            264411481,
            264417433,
            264418710,
            264412854,
            264416785,
            264417289,
            264409596,
            264415411,
            264416480,
            264411733,
            264416203,
            264418002,
            264418445,
            264413144,
            264415814,
            264415134,
            264412074,
            264419017
        ],
        "A": [
            264409604,
            264408727,
            264409156,
            264412898,
            264408950,
            264409241,
            264410321,
            264408352,
            264408494,
            264408922,
            264408390,
            264408516,
            264410187,
            264409625,
            264408487,
            264409057,
            264408498,
            264408238,
            264408615
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130213",
    "editorial": "SolutionLet\u00e2\u0080\u0099s consider the following recursive algorithm. We will store\r\nthe Hamiltonian path as a double-ended queue, maintaining the start and\r\nend.In case there are only or vertices left in the graph, the problem is\r\nsolved trivially.Suppose we know that the current graph has vertices,\r\nand there are at most edges missing. Then the total number of edges in\r\nsuch a graph is at least Let all vertices in the graph have a degree of\r\nat most , then the total number of edges does not exceed which is less\r\nthan the stated value. Hence, we conclude that there is at least one\r\nvertex with a degree greater than .If there exists a vertex with a\r\ndegree of , then it is sufficient to run our recursive algorithm for the\r\nremaining graph. Since is only not connected by an edge to one vertex,\r\nis connected either to the start or the end of the maintained path in\r\nthe remaining graph. Thus, we can insert the vertex either at the\r\nbeginning or at the end of the path.Otherwise, let be the vertex with a\r\ndegree of . There is at least one vertex with a degree not exceeding .\r\nRemove and from the graph. Notice that the number of edges in such a\r\ngraph does not exceed The invariant is preserved, so we can run the\r\nalgorithm for the remaining graph. Then, we can arrange the vertices in\r\nthe following order: ..., where the start of the Hamiltonian path in the\r\nremaining graph.It remains to understand how to use queries.Make a query\r\n. Let be the second number in the response to our query. If , the degree\r\nof vertex is . Run our recursive algorithm, and then compare the start\r\nand end of the obtained path with .Otherwise, if , it means the degree\r\nof vertex is . In this case, ask about any vertex with a low degree\r\n(this can be done with a query ). Then simply arrange the vertices in\r\nthe order mentioned above.We will make no more than queries, and the\r\nfinal asymptotic will be .\r\n",
    "name": "F. Kostyanych s Theorem",
    "statement": "Kostyanych has chosen a complete undirected graph^{\r\ndagger} with n vertices, and then removed exactly (n - 2) edges from it.\r\nYou can ask queries of the following type: \" d\" Kostyanych tells you the\r\nnumber of vertex v with a degree d. Among all possible such vertices, he\r\nselects the vertex , and if there are several such vertices, he selects\r\nthe one with the minimum number. He also tells you the number of another\r\nvertex in the graph, with which v is not connected by an edge (if none\r\nis found, then 0 is reported). Among all possible such vertices, he\r\nselects the one with the minimum number. Then he removes the vertex v\r\nand all edges coming out of it. If the required vertex v is not found,\r\nthen \"0\r\n0\" is reported. Find a Hamiltonian path^{\r\nddagger} in the graph in at most n queries. It can be proven that under\r\nthese constraints, a Hamiltonian path always exists.^{\r\ndagger}A complete undirected graph is a graph in which there is exactly\r\none undirected edge between any pair of distinct vertices. Thus, a\r\ncomplete undirected graph with n vertices contains\r\nfrac{n(n-1)}{2} edges.^{\r\nddagger}A Hamiltonian path in a graph is a path that passes through each\r\nvertex exactly once.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));int n,m;deque<int> q;pair<int,int> ask(int x){\tcout<<\"? \"<<x<<endl;\tint y;cin>>x>>y;\treturn MP(x,y);}void solve(int x){\tif(x==1){\t\tq.push_back(ask(0).first);\t\treturn;\t}\tauto p=ask(x-2);\tif(p.second==0){\t\tauto t=ask(0);\t\tif(x>2) solve(x-2);\t\tq.push_back(p.first),q.push_back(t.first);\t}else{\t\tsolve(x-1);\t\tif(q.front()!=p.second) q.push_front(p.first);\t\telse q.push_back(p.first);\t}}void solve(){\tcin>>n;\tsolve(n);\tcout<<\"! \";\twhile(!q.empty()){\t\tcout<<q.front()<<' ';\t\tq.pop_front();\t}\tcout<<endl;}int main(){\t// freopen(\"Otomachi_Una.in\",\"r\",stdin);\t// freopen(\"Otomachi_Una.out\",\"w\",stdout);\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "interactive"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Kostyanych s Theorem.json"
}