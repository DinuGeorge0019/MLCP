{"link": "https://codeforces.com//contest/894/problem/E", "problemId": "134794", "problem_idx": "E", "shortId": "894E", "contest_number": "894", "problem_submissions": {"E": [32471307, 32470808, 32477653, 32468892, 32476378, 32473286, 32472749, 32479578, 32478798, 32483759, 32466869, 32470695, 32470873, 32493311], "C": [32467626, 32472589, 32462133, 32463427, 32461488, 32465456, 32463529, 32464758, 32463676, 32464462, 32469317, 32465537, 32470577, 32468611, 32464977, 32465202, 32462633, 32464400], "B": [32465947, 32462718, 32464339, 32462164, 32478784, 32490475, 32479651, 32463872, 32461816, 32462196, 32472670, 32462354, 32463630, 32462716, 32463341, 32469382], "D": [32464126, 32467179, 32469559, 32463935, 32469406, 32468195, 32470253, 32466945, 32470315, 32471173, 32471807, 32476896, 32473554, 32474533, 32473511], "A": [32458491, 32461795, 32458601, 32458521, 32458627, 32465359, 32458507, 32458624, 32459097, 32461613, 32461662, 32461348, 32461278, 32459033, 32459890, 32458837, 32458739, 32458734]}, "name": "E. Ralph and Mushrooms", "statement": "Ralph is going to collect mushrooms in the Mushroom Forest. There are\r\ndirected paths connecting trees in the Mushroom Forest. On each path\r\ngrow some mushrooms. When Ralph passes a path, he collects all the\r\nmushrooms on the path. The Mushroom Forest has a magical fertile ground\r\nwhere mushrooms grow at a fantastic speed. New mushrooms regrow as soon\r\nas Ralph finishes mushroom collection on a path. More specifically,\r\nafter Ralph passes a path the -th time, there regrow mushrooms less than\r\nthere was before this pass. That is, if there is initially mushrooms on\r\na path, then Ralph will collect mushrooms for the first time, mushrooms\r\nthe second time, mushrooms the third time, and so on. However, the\r\nnumber of mushrooms can never be less than .For example, let there be\r\nmushrooms on a path initially. The number of mushrooms that can be\r\ncollected from the path is , , and when Ralph passes by from first to\r\nfourth time. From the fifth time and later Ralph can\u2019t collect any\r\nmushrooms from the path (but still can pass it).Ralph decided to start\r\nfrom the tree . How many mushrooms can he collect using only described\r\npaths?\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 2333333\nEdgc int n,m;\nint st[SZ],sn=0,dfn[SZ],low[SZ],C=0,ins[SZ],Z=0,bl[SZ];\nvoid tj(int x)\n{\n\tdfn[x]=low[x]=++C; ins[x]=1; st[++sn]=x;\n\tfor esb(x,e,b)\n\t{\n\t\tif(!dfn[b]) tj(b),low[x]=min(low[x],low[b]);\n\t\telse if(ins[b]) low[x]=min(low[x],dfn[b]);\n\t}\n\tif(dfn[x]!=low[x]) return;\n\t++Z;\n\twhile(1)\n\t{\n\t\tint g=st[sn--];\n\t\tins[g]=0; bl[g]=Z;\n\t\tif(g==x) break;\n\t}\n}\nint X[SZ],Y[SZ],W[SZ];\nll vv[SZ],mx[SZ];\nbool vis[SZ];\nvoid dfs(int x)\n{\n\tvis[x]=1; mx[x]=0;\n\tfor esb(x,e,b)\n\t{\n\t\tif(!vis[b]) dfs(b);\n\t\tmx[x]=max(mx[x],mx[b]+vc[e]);\n\t}\n\tmx[x]+=vv[x];\n}\nll su[SZ];\nint main()\n{\n\tfor(int i=1;i<SZ;++i)\n\t\tsu[i]=su[i-1]+i*(ll)(i+1)/2;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y,w;i<=m;++i)\n\t\tscanf(\"%d%d%d\",&x,&y,&w),\n\t\tX[i]=x,Y[i]=y,W[i]=w,ad_de(x,y,w);\n\tint s; scanf(\"%d\",&s);\n\tfor(int i=1;i<=n;++i)\n\t\tif(!dfn[i]) tj(i);\n\tM=0;\n\tfor(int i=1;i<=Z;++i) fst[i]=0;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=X[i],y=Y[i],w=W[i];\n\t\tif(bl[x]!=bl[y]) ad_de(bl[x],bl[y],w);\n\t\telse\n\t\t{\n\t\t\tll l=0,r=w;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tll g=(l+r+1)>>1;\n\t\t\t\tif(g*(g+1)/2<=w) l=g; else r=g-1;\n\t\t\t}\n\t\t\tll rr=w*(l+1)-su[l];\n\t\t\tvv[bl[x]]+=rr;\n\t\t}\n\t}\n\tdfs(bl[s]); printf(\"%I64d\\n\",mx[bl[s]]);\n}\n"], "input": "", "output": "", "tags": ["dp", "graphs"], "dificulty": "2100", "interactive": false}