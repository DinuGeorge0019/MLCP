{
    "link": "https://codeforces.com//contest/1904/problem/D1",
    "problemId": "2374323",
    "problem_idx": "D1",
    "shortId": "1904D1",
    "contest_number": "1904",
    "problem_submissions": {
        "F": [
            236570080,
            236576621,
            236554431,
            236568040,
            236582005,
            236574981,
            236880626,
            236880480,
            236569573
        ],
        "E": [
            236554914,
            236578860,
            236576444,
            236573774,
            238458664,
            236560297,
            236558822,
            236558918,
            236569149,
            236563127,
            236567711,
            236569198,
            236566626,
            236565306,
            236568569,
            236566882,
            236569261,
            236579274,
            236552305,
            236552808,
            236798985
        ],
        "D1": [
            236545065,
            236536170,
            236543035,
            236535328,
            236546645,
            236545333,
            236534429,
            236543154,
            236535118,
            236545269,
            236548952,
            236561907,
            236552142,
            236547668,
            236547285,
            236579190,
            236560952,
            236535340,
            236566707
        ],
        "D2": [
            236544975,
            236536268,
            236547976,
            236535232,
            236546707,
            236545240,
            236539045,
            236543101,
            236535019,
            236550494,
            236549022,
            236539644,
            236552226,
            236551334,
            236547141,
            236579204,
            236562744,
            236535269,
            236566631
        ],
        "C": [
            236537578,
            236532163,
            236538305,
            236529701,
            236530813,
            236537981,
            236531278,
            236536485,
            236540998,
            236534952,
            236537201,
            236530975,
            236533757,
            236539773,
            236559221,
            236579140,
            236529162,
            236713604,
            236530644
        ],
        "B": [
            236533750,
            236526956,
            236527715,
            236527401,
            236528167,
            236531303,
            236527554,
            236530718,
            236528605,
            236528181,
            236531779,
            236528715,
            236530882,
            236530328,
            236531954,
            236579315,
            236527688,
            236526407,
            236558484,
            236528501
        ],
        "A": [
            236526415,
            236525678,
            236525809,
            236525816,
            236525646,
            236527341,
            236525550,
            236527627,
            236527718,
            236525848,
            236525742,
            236526468,
            236525731,
            236528067,
            236527808,
            236579299,
            236525701,
            236525590,
            236554437,
            236526433
        ]
    },
    "name": "D1. Set To Max  Easy Version ",
    "statement": "You are given two arrays a and b of length n.You can perform the\r\nfollowing operation some (possibly zero) times: choose l and r such that\r\n1\r\nleq l\r\nleq r\r\nleq n. let x=\r\nmax(a_l,a_{l+1},\r\nldots,a_r). for all l\r\nleq i\r\nleq r, set a_i := x. Determine if you can make array a equal to array b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nint T, n, a[N], b[N];\nint st[19][N];\n\ninline int ask(int l, int r) {\n\tint k = __lg(r - l + 1);\n\treturn max(st[k][l], st[k][r - (1 << k) + 1]);\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\t\tfor (int i = 1; i <= n; ++i) cin >> b[i];\n\t\tbool gg = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (b[i] < a[i]) {\n\t\t\t\tgg = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (gg) {\n\t\t\tcout << \"NO\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) st[0][i] = a[i];\n\t\tfor (int i = 1; (1 << i) <= n; ++i)\n\t\t\tfor (int j = 1; j + (1 << i) - 1 <= n; ++j)\n\t\t\t\tst[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\tfor (int i = 1, j = 1; i <= n; ++i) {\n\t\t\twhile (j <= n && (a[j] != b[i] || (j < i && ask(j, i) > b[i]))) ++j;\n\t\t\tif (j > n || (j >= i && ask(i, j) > b[i])) {\n\t\t\t\tgg = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gg) cout << \"NO\\n\";\n\t\telse cout << \"YES\\n\";\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Set To Max  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/123160",
    "editorial": "If for any , then it is clearly impossible.In order for to\nbecome , must be contained by an interval that also contains a where .\nNote that if there is a triple where , then it is never optimal to apply\nthe operation on interval , since applying the operation on interval\nwill be sufficient. Thus, for we only need to consider the closest to\nthe right or left of . Lets find the necessary conditions for us to\napply an operation on the interval . First of all, for . Second, for all\n. Turns out, these conditions are also sufficient, since we can apply\nthese operations in increasing order of without them interfering with\neach other. If we check for every there exists an interval or that\nsatisfies the necessary conditions, then there will exist a sequence of\noperations to transform into . Checking for the conditions can be done\nwith brute force for D1 or using monotonic stacks or segment trees for\nD2.\n",
    "hint": [
        "Hint 1 Can we reduce the number of intervals we want to apply an operation on?",
        "Hint 2 What is the necessary condition to perform an operation on an interval"
    ]
}