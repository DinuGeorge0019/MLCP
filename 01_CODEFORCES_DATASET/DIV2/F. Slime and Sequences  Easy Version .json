{
    "link": "https://codeforces.com//contest/1350/problem/F",
    "problemId": "619077",
    "problem_idx": "F",
    "shortId": "1350F",
    "contest_number": "1350",
    "problem_submissions": {
        "E": [
            79855181,
            79866892,
            79867578,
            79860431,
            79865664,
            79871653,
            79862377,
            79873286,
            79855797,
            79870095,
            79877566,
            79875250,
            79879082,
            79877229,
            79874099,
            79876185,
            79865098,
            79874891,
            79878375
        ],
        "D": [
            79841799,
            79863715,
            79838223,
            79843636,
            79845619,
            79851762,
            79859376,
            79851422,
            79856645,
            79867069,
            79852959,
            79854133,
            79862270,
            79854555,
            79857955,
            79860745,
            79863550,
            79877253,
            79858065,
            79853653
        ],
        "C": [
            79826908,
            79832989,
            79819179,
            79836044,
            79829980,
            79835199,
            79827905,
            79823236,
            79839284,
            79843003,
            79842971,
            79842595,
            79842398,
            79842899,
            79841428,
            79836029,
            79843846,
            79828517,
            79847123,
            79843527
        ],
        "B": [
            79820647,
            79822816,
            79842662,
            79823960,
            79824033,
            79823709,
            79822810,
            79820992,
            244797086,
            79824014,
            79827065,
            79834456,
            79825730,
            79829712,
            79832808,
            79831732,
            79824775,
            79833342,
            79819486,
            79827690,
            79827705
        ],
        "A": [
            79816852,
            79817819,
            79835688,
            79816825,
            79817311,
            79817807,
            79817556,
            79817787,
            79817609,
            79823750,
            79829915,
            79816664,
            79822342,
            79821478,
            79817922,
            79818871,
            79819448,
            79816826,
            79818898,
            79816798
        ],
        "F": [
            79877945
        ]
    },
    "name": "F. Slime and Sequences  Easy Version ",
    "statement": "Slime is interested in sequences. He defined positive integer sequences\r\np of length n as follows: For each k>1 that presents in p, there should\r\nbe at least one pair of indices i,j, such that 1\r\nleq i < j\r\nleq n, p_i = k - 1 and p_j = k.For the given integer n, the set of all\r\ngood sequences of length n is s_n. For the fixed integer k and the\r\nsequence p, let f_p(k) be the number of times that k appears in p. For\r\neach k from 1 to n, Slime wants to know the following value:\r\nleft(\r\nsum_{p\r\nin s_n} f_p(k)\r\nright)\r\ntextrm{mod}\r\n998\r\n,244\r\n,353\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nconst long long P = 998244353;\nint t[5100][5100];\nlong long a[5100];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\tt[1][1] = 1;\n\tfor (int n = 2; n <= 5000; ++n) {\n\t\tfor (int k = 1; k <= n; ++k) {\n\t\t\tt[n][k] = ((long long)(t[n - 1][k]) * (long long)(k)+(long long)(t[n - 1][k - 1]) * (long long)(n - k + 1)) % P;\n\t\t}\n\t}\n\n\tint n;\n\tcin >> n;\n\ta[1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\ta[j] = (a[j] * (long long)(i)) % P;\n\t\t\ta[j] += t[i][j];\n\t\t\ta[j] %= P;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcout << a[i] << \" \";\n\t}\n\tcout << endl;\n\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Slime and Sequences  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "Let Ex\n be the sum of probability times time when the game end up with all biscuits are owned by the x-th person (At here, the sum of probability is not 1, though the sum of probability in all Ex\n is 1). So the answer is ?i=1nEi\n\nLet E?x\n be the expectation of time when the game only ends when the x-th person own all the biscuits.\n\nLet Px\n be the probability that the game end up with all biscuits are owned by the x-th person. It's easy to find that ?i=1nPi=1\n?\n\nAnd we let constant C\n be the expect time from when all biscuits are owned by i-th person to when all biscuits are owned by j-th person (now the end condition is that all biscuits are owned by j-th person, is the same with E?x\n . And for all (i, j), the value of C\n is the same). So we have a identity:\n\nEx=E?x??i=1n[i?x](Pi?C+Ei)\n\nWe can get this by consider which people own all the biscuits when the game ends in all possible situation of E?x\n .\n\nThen we can get:\n\n?i=1nEi=E?x?C??i=1n[i?x]Pi\n\nSum it up for x=1,2,?,n\n , and we get:\n\nn?i=1nEi=?i=1nE?i?C(n?1)?i=1nPi\n\nMention that ans=?i=1nEi\n and ?i=1nPi=1\n , so we find that:\n\nn?ans=?i=1nE?i?C(n?1)\n\nWhen we find the value of E?x\n and C\n , we only want to know whether the biscuit is owned by the person we want or not, so we can let fm\n represent the expect time the person will own m+1\n biscuits when the person own m\n biscuits now. We can easily get f0\n and equation between fi\n and fi?1\n .\n\nSo we can get all fm\n and C\n in O(?i=1nai?log mod)\n time. And we can get the answer.\n\nThe overall complexity is O(?i=1nai?log mod)\n .",
    "hint": []
}