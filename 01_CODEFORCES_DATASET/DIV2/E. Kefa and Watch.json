{
    "link": "https://codeforces.com//contest/580/problem/E",
    "problemId": "35999",
    "problem_idx": "E",
    "shortId": "580E",
    "contest_number": "580",
    "problem_submissions": {
        "E": [
            13169027,
            13165630,
            13172362,
            13172239,
            13276228,
            13276220,
            13181451,
            13180453
        ],
        "D": [
            13158152,
            13153446,
            13153124,
            13152837,
            13153644,
            13153078,
            13152233,
            13150734,
            13158863,
            13154097,
            13154459,
            13155410,
            13154153,
            13153936,
            13153904,
            13151772,
            13154328,
            13155366
        ],
        "C": [
            13152496,
            13147124,
            13149562,
            13149833,
            13149612,
            13149260,
            13148537,
            13148215,
            13150353,
            13147522,
            13151581,
            13150500,
            13149659,
            13151388,
            13150099,
            13149113,
            13149776,
            13150107
        ],
        "B": [
            13148061,
            13167252,
            13146021,
            13147235,
            13171070,
            13146699,
            13146714,
            13146413,
            13145854,
            13146150,
            13150066,
            13148456,
            13146468,
            13147058,
            13148187,
            13147219,
            13146687,
            13147097,
            13148044
        ],
        "A": [
            13145130,
            13166155,
            13143931,
            13143879,
            13144120,
            13143774,
            13143862,
            13143852,
            13143834,
            13144014,
            13143978,
            13143875,
            13144293,
            13145295,
            13145825,
            13143916,
            13144739,
            13143807
        ]
    },
    "name": "E. Kefa and Watch",
    "statement": "One day Kefa the parrot was walking down the street as he was on the way\r\nhome from the restaurant when he saw something glittering by the road.\r\nAs he came nearer he understood that it was a watch. He decided to take\r\nit to the pawnbroker to earn some money. The pawnbroker said that each\r\nwatch contains a serial number represented by a string of digits from to\r\n, and the more quality checks this number passes, the higher is the\r\nvalue of the watch. The check is defined by three positive integers ,\r\nand . The watches pass a check if a substring of the serial number from\r\nto has period . Sometimes the pawnbroker gets distracted and Kefa\r\nchanges in some substring of the serial number all digits to in order to\r\nincrease profit from the watch. The seller has a lot of things to do to\r\nbegin with and with Kefa messing about, he gave you a task: to write a\r\nprogram that determines the value of the watch.Let us remind you that\r\nnumber is called a period of string (), if for all from 1 to .\r\n",
    "solutions": [
        "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<cassert>\n#include<bitset>\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1e5+100;\nint a[N],len[N*4];\nlong long biao[10][N][2],mi[N][2],MOD[2];\nchar ch[N];\nlong long tree[N*4][2],tag[N*4];\nvoid downtag(int x)\n{\n    if (tag[x]==-1) return;\n    tag[x*2]=tag[x];\n    tag[x*2+1]=tag[x];\n    for(int i=0;i<2;i++)\n    {\n        tree[x*2][i]=biao[tag[x]][len[x*2]][i];\n        tree[x*2+1][i]=biao[tag[x]][len[x*2+1]][i];\n    }\n    tag[x]=-1;\n}\nvoid calc(int x)\n{\n    for(int i=0;i<2;i++)\n        tree[x][i]=(tree[x*2][i]*mi[len[x*2+1]][i] + tree[x*2+1][i]) % MOD[i];\n}\nvoid build(int x,int l,int r)\n{\n    tag[x]=-1;\n    if (l+1==r)\n    {\n        //cout<<l<<' '<<a[l]<<endl;\n        tree[x][0]=biao[a[l]][1][0];\n        tree[x][1]=biao[a[l]][1][1];\n        len[x]=1;\n    } else\n    {\n        int mid=(l+r)/2;\n        build(x*2,l,mid);\n        build(x*2+1,mid,r);\n        len[x]=len[x*2]+len[x*2+1];\n        calc(x);\n        //cout<<l<<' '<<r-1<<' '<<tree[x][0]<<endl;\n    }\n}\nvoid change(int x,int l,int r,int ll,int rr,int k)\n{\n    if (l>=ll && r<=rr)\n    {\n        tag[x]=k;\n        for(int i=0;i<2;i++)\n            tree[x][i]=biao[k][len[x]][i];\n    }\n    else\n    {\n        downtag(x);\n        int mid=(l+r)/2;\n        if (mid>ll) change(x*2,l,mid,ll,rr,k);\n        if (mid<rr) change(x*2+1,mid,r,ll,rr,k);\n        calc(x);\n    }\n}\npair<long long,int> merge(pair<long long,int> a,pair<long long,int> b,int t)\n{\n    return make_pair((  a.first*mi[b.second][t]+b.first  ) % MOD[t],a.second+b.second);\n}\npair<long long,int> get(int x,int l,int r,int ll,int rr,int t)\n{\n    if (l>=ll && r<=rr) return (make_pair(tree[x][t],len[x]));else\n    {\n        downtag(x);\n        pair<long long,int> p=make_pair(0,0);\n        int mid=(l+r)/2;\n        if (mid>ll) p=merge(p,get(x*2,l,mid,ll,rr,t),t);\n        if (mid<rr) p=merge(p,get(x*2+1,mid,r,ll,rr,t),t);\n        return p;\n    }\n}\nint main() {\n    MOD[0]=998244353;\n    MOD[1]=1000000000+7;\n    int n,m1,m2;\n    cin>>n>>m1>>m2;\n    scanf(\"%s\",ch+1);\n    for(int i=1;i<=n;i++)\n        a[i]=ch[i]-'0';\n    for(int i=0;i<=9;i++)\n    {\n        biao[i][0][0]=0;\n        biao[i][0][1]=0;\n        for(int j=1;j<N;j++)\n            for(int k=0;k<2;k++)\n                biao[i][j][k]=(biao[i][j-1][k] * 10 +(long long)i ) % MOD[k];\n    }\n    mi[0][0]=1;\n    mi[0][1]=1;\n    for(int i=1;i<N;i++)\n        for(int j=0;j<2;j++)\n            mi[i][j]=(mi[i-1][j] * 10) % MOD[j];\n    build(1,1,n+1);\n    //cout<<tree[1][0]<<endl;\n    //cout<<\"OK\"<<endl;\n    for(int i=1;i<=m1+m2;i++)\n    {\n        int type,l,r,k;\n        scanf(\"%d%d%d%d\",&type,&l,&r,&k);\n        if (type==1) change(1,1,n+1,l,r+1,k);\n        else\n        {\n            if (k==r-l+1) puts(\"YES\");\n            else\n            {\n                //cout<<(get(1,1,n+1,l,r-k+1,0)).first<<' '<<(get(1,1,n+1,l+k,r+1,0)).first<<endl;\n                \n                \n                if (((get(1,1,n+1,l,r-k+1,0)).first==(get(1,1,n+1,l+k,r+1,0)).first) && \n                    ((get(1,1,n+1,l,r-k+1,1)).first==(get(1,1,n+1,l+k,r+1,1)).first))\n                   {\n                        puts(\"YES\");\n                   }\n                   else puts(\"NO\");\n                   \n                \n            }\n        }\n    }\n    return 0;\n}\n/*\n6 0 1\n121212\n2 1 6 2\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Kefa and Watch.json",
    "editorial_link": "https://codeforces.com//blog/entry/20468",
    "editorial": "At first, we calculate the hash for all line elements depending on their\r\npositions. That is, the hash of the number , standing on the -th\r\nposition will be equal to * , where is the base of the hash. We\r\nconstruct the segment tree of sums, which support a group modification,\r\nfor all hashes. Thus, we can perform queries for modification in . It\r\nremains to deal with the queries of the second type. Let us assume, that\r\nwe want to process the query 2 . Obviously, the substring from to have a\r\n-period, if a substring from to is equal to substring from to . We can\r\nfind out the sum of hashes at the subsegment with the help of the sums\r\ntree, so we can compare the two strings in . Asymptotics . Solution\r\n",
    "hint": []
}