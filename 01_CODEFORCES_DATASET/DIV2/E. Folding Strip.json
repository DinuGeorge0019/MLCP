{
    "link": "https://codeforces.com//contest/1966/problem/E",
    "problemId": "2615005",
    "problem_idx": "E",
    "shortId": "1966E",
    "contest_number": "1966",
    "problem_submissions": {
        "E": [
            258440120,
            258447865,
            258441495,
            258448292,
            258453329,
            258455007,
            258455562,
            258463703,
            258454902,
            258457920,
            258464021,
            258461311,
            258462638,
            258462895,
            258465595,
            258463312,
            258462674,
            258458699
        ],
        "B": [
            258438529,
            258422443,
            258424110,
            258425316,
            258424919,
            258422815,
            258422044,
            258421183,
            258426420,
            258424238,
            258425787,
            258424328,
            258425355,
            258428106,
            258426188,
            258424457,
            258424995,
            258442623
        ],
        "D": [
            258429599,
            258433739,
            258439478,
            258442551,
            258438117,
            258440328,
            258436731,
            258432022,
            258450610,
            258450325,
            258442193,
            258450098,
            258450833,
            258450813,
            258448974,
            258453024,
            258454359,
            258451828
        ],
        "C": [
            258425131,
            258429293,
            258430381,
            258430477,
            258430820,
            258432851,
            258429869,
            258440236,
            258434780,
            258430009,
            258432109,
            258435350,
            258435642,
            258434757,
            258435098,
            258436413,
            258434457,
            258433325
        ],
        "A": [
            258421447,
            258418791,
            258419370,
            258420086,
            258417776,
            258418880,
            258418284,
            258421321,
            258417852,
            258418112,
            258418571,
            258418222,
            258418421,
            258419544,
            258419765,
            258417953,
            258420988,
            258424462
        ],
        "F": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "Define the pattern of a (validly) folded strip to be the set of characters, in order, seen from above after all folds are made.\n\nIt is always possible to fold the strip in such a way that no two adjacent characters in the pattern are equal. If we fold in between every pair of equal characters, and don't fold in between every pair of distinct characters, we will achieve this. This diagram shows one example of this (the red lines indicate where to fold, and the final pattern is 10101\n):\n\n\nThis set of folds will always be valid because it ensures that all 1\ns in the original string are on odd indices and all 0\ns are on even indices (or vice versa).\n\nAlso, there is only one obtainable pattern (up to reversal) that is alternating in this way. It is never possible to fold in between two adjacent different characters, because that can never be part of a valid folding, and if there exists a pair of adjacent equal characters that you don't fold in between, the pattern will not be alternating.\n\nWe can also show that the pattern formed by this process is always optimal. Let t\n be any pattern obtained from a valid folding of s\n. Notice that if we perform a valid fold on t\n, that corresponds to a valid fold on s\n, because we can essentially \"compose\" the valid folding of s\n into t\n and the valid folding of t\n into one valid folding.\n\nSo we can fold t\n using the process above, which will yield a pattern with alternating characters of length at most len(t)\n. Because the alternating pattern is unique for a given s\n, it must be the same (up to reversal) as the one described above. So the above pattern is of size at most len(t)\n for any valid pattern t\n, and is therefore optimal.\n\nWe can simulate the folding process to determine the final length.",
    "name": "E. Folding Strip",
    "statement": "You have a strip of paper with a binary string s of length n. You can\r\nfold the paper in between any pair of adjacent digits.A set of folds is\r\nconsidered if after the folds, all characters that are on top of or\r\nbelow each other match. Note that all folds are made at the same time,\r\nso the characters don’t have to match in between folds.For example,\r\nthese are valid foldings of s =\r\nmathtt{110110110011} and s =\r\nmathtt{01110}: The length of the folded strip is the length seen from\r\nabove after all folds are made. So for the two above examples, after the\r\nfolds shown above, the lengths would be 7 and 3, respectively.Notice\r\nthat for the above folding of s =\r\nmathtt{01110}, if we made either of the two folds on their own, that\r\nwould not be a valid folding. However, because we don’t check for\r\nvalidity until all folds are made, this folding is valid.After\r\nperforming a set of valid folds, what is the minimum length strip you\r\ncan form?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair<int,int> pii;const int N=505,Inf=1e9;int n;signed main(){\tstd::ios::sync_with_stdio(false);\tcin.tie(0),cout.tie(0);\tint t;\tcin>>t;\twhile(t--){\t\tstring s;\t\tcin>>n>>s;\t\tfor(char &i:s)i-='0';\t\tint l=s[0],r=s[0],Cnt=1,len=1;\t\tfor(int i=1;i<n;++i){\t\t\tif(Cnt==len&&s[i]!=r)++len,++Cnt,r^=1;\t\t\telse if(!Cnt&&s[i]!=l)++len,l^=1;\t\t\telse if((Cnt&1)==(s[i]==l))--Cnt;\t\t\telse ++Cnt;\t\t}\t\tcout<<len<<\"\\n\";\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Folding Strip.json",
    "hint": []
}