{
    "link": "https://codeforces.com//contest/1858/problem/B",
    "problemId": "2166167",
    "problem_idx": "B",
    "shortId": "1858B",
    "contest_number": "1858",
    "problem_submissions": {
        "E1": [
            218971675,
            218948691,
            218950036,
            218981081,
            218981577,
            218982148,
            219044099,
            218987081,
            218959071,
            219043079,
            218997113,
            218975893,
            218978028,
            218974432,
            218978584,
            218984712,
            218984251,
            219051896,
            218984058,
            218985452,
            218989668,
            218998871,
            218971815
        ],
        "E2": [
            218971226,
            218946559,
            218949779,
            219003260,
            218981396,
            218982111,
            218983780,
            219043918,
            218987338,
            219043124,
            218997698,
            218975689,
            218977856,
            219035037,
            219051939,
            218998573
        ],
        "D": [
            218958822,
            218970595,
            218957970,
            218958903,
            218949856,
            218961365,
            218967040,
            218972943,
            219043010,
            218960726,
            218998607,
            218989664,
            218961840,
            218965618,
            218966574,
            218969464,
            218974328,
            218972414,
            218969139,
            218981714,
            218991387
        ],
        "C": [
            218944984,
            218929618,
            218962105,
            218928296,
            218926980,
            218941771,
            218950307,
            218944949,
            219042947,
            218946392,
            218934108,
            218941439,
            218951937,
            218933349,
            218935592,
            218942151,
            218948522,
            218948262,
            218943920,
            218947281,
            218951547
        ],
        "B": [
            218935374,
            218982876,
            218965626,
            218941114,
            218939372,
            218933262,
            218946217,
            218938100,
            219042924,
            218940019,
            218950811,
            218937233,
            218946328,
            218943500,
            218950259,
            218936903,
            218940772,
            218941478,
            218938583,
            218962280,
            218941262
        ],
        "A": [
            218918372,
            218920879,
            218959798,
            218918668,
            218919313,
            218918787,
            218926715,
            218920787,
            219043052,
            219042898,
            218921173,
            218920067,
            218918574,
            218919674,
            218918423,
            218919655,
            218919188,
            218922439,
            218922802,
            218918900,
            218943440,
            218921894
        ]
    },
    "name": "B. The Walkway",
    "statement": "There are n benches near the Main Walkway in Summer Infomatics School.\r\nThese benches are numbered by integers from 1 to n in order they follow.\r\nAlso there are m cookie sellers near the Walkway. The i-th (1\r\nle i\r\nle m) cookie sellers is located near the s_i-th bench.Petya is standing\r\nin the beginning of the Walkway. He will pass near all benches starting\r\nfrom the 1-st bench and ending with the n-th bench. Petya passes the\r\ndistance between two consecutive benches in 1 minute. He has a knapsack\r\nwith an infinite amount of cookies. Petya is going to eat cookies from\r\nhis knapsack and buy them from cookie sellers during the walk.Petya eats\r\ncookies only near the benches according to the following rule: he will\r\neat the cookie near the i-th (1\r\nle i\r\nle n) bench if and only if of the following conditions holds: There is a\r\ncookie seller near the i-th bench. Then Petya will buy a cookie from\r\ncookie seller and eat it immediately. Petya has not yet eaten a cookie.\r\nThen Petya will take a cookie from his knapsack and eat it immediately.\r\nAt least d minutes passed since Petya ate the previous cookie. In other\r\nwords, Petya has not eaten a cookie near the benches i-1, i-2,\r\nldots,\r\nmax(i-d+1, 1). Then Petya will take a cookie from his knapsack and eat\r\nit immediately. You may assume that Petya eats cookies instantly. Petya\r\nwill not eat two or more cookies near the same bench.You want to the\r\nnumber of cookies Petya will eat during his walk. In order to do this,\r\nyou will ask the administration of the Summer Informatics School to\r\nremove cookie seller from the Walkway before Petya starts his\r\nwalk.Please determine the minimum possible number of cookies Petya can\r\neat after removing exactly one cookie seller. Also determine the number\r\nof cookie sellers, such that if you remove one of them, Petya will eat\r\nthe minimum possible number of cookies.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...)\n#endif\n\nint n, m, d;\n\nint get(int l, int r) {\n  int sz = r - l - 1;\n  return sz >= 0 ? sz / d : 0;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> m >> d;\n    vector<int> s(m);\n    for (int i = 0; i < m; i++) {\n      cin >> s[i];\n    }\n    pair<int, int> ans = {INT_MAX, -1};\n    auto upd = [&](int x) {\n      if (x < ans.first) {\n        ans.first = x;\n        ans.second = 1;\n      } else if (x == ans.first) {\n        ans.second++;\n      }\n    };\n    int all = 1 + get(1, s[0]);\n    for (int i = 0; i < m - 1; i++) all += get(s[i], s[i + 1]);\n    all += get(s.back(), n + 1);\n    all += m;\n    all -= s[0] == 1;\n    debug(all);\n    upd(all - get(1, s[0]) - get(s[0], s[1]) - (s[0] != 1) + get(1, s[1]));\n    upd(all - get(s[m - 2], s[m - 1]) - get(s[m - 1], n + 1) +\n        get(s[m - 2], n + 1) - 1);\n    for (int i = 1; i < m - 1; i++)\n      upd(all - get(s[i - 1], s[i]) - get(s[i], s[i + 1]) +\n          get(s[i - 1], s[i + 1]) - 1);\n    cout << ans.first << \" \" << ans.second << \"\\n\";\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The Walkway.json",
    "editorial_link": "https://codeforces.com//blog/entry/119398",
    "editorial": "First, let\u00e2\u0080\u0099s calculate how many cookies Petya will eat if we don\u00e2\u0080\u0099t\r\nremove the cookie sellers at all (we will later refer to this value as\r\n). Note that since the cookie sellers reset the time elapsed since the\r\nlast eaten cookie, the number of cookies eaten on all segments between\r\nadjacent cookie sellers are counted independently. Therefore, we can\r\neasily calculate : let\u00e2\u0080\u0099s iterate through the cookie sellers from to .\r\nFor each of them, we should add the number to . We should also carefully\r\ntake into account the cookies that Petya will eat on the segments and\r\n(it might help to assume that there are two more cookie sellers at\r\npositions and ). In order to find the minimum possible number of cookies\r\neaten by Petya, we will fix the cookie seller that we remove. Let it be\r\nthe cookie seller . Then the number of cookies eaten by Petya will be\r\n(for the first and last cookie sellers, the formulas may differ\r\nslightly). Thus, we can find the number of cookies that Petya will eat\r\nif a certain cookie seller is removed in . After going through all\r\noptions, we will be able to find the answer to the problem.The final\r\ncomplexity of the solution is (because array is sorted in the input).\r\n"
}