{"link": "https://codeforces.com//contest/544/problem/D", "problemId": "27511", "problem_idx": "D", "shortId": "544D", "contest_number": "544", "problem_submissions": {"D": [11032012, 11030561, 11031995, 11031987, 11031076, 11733855, 11036523, 12308236], "C": [11028349, 11025550, 11028166, 11027513, 11029011, 11025883, 11023519, 11025660, 11026616, 11026912, 11027600, 11030213, 11026452, 11026673, 11028755, 18268210, 11027624, 11028873, 11029553, 11028365, 11029408], "B": [11024290, 11026185, 11025669, 11029854, 11029782, 11023653, 11026411, 11023531, 11024274, 11024308, 11023437, 11023757, 11024285, 11023489, 11023113, 11024136, 11023333, 11023666, 11026341, 11023637], "A": [11022935, 11033816, 11022995, 11025287, 11022840, 11023316, 11022775, 11022778, 11022845, 11022867, 11022763, 11022688, 11022879, 11022708, 11022881, 11023441, 11022791]}, "name": "D. Destroying Roads", "statement": "In some country there are exactly cities and bidirectional roads\r\nconnecting the cities. Cities are numbered with integers from to . If\r\ncities and are connected by a road, then in an hour you can go along\r\nthis road either from city to city , or from city to city . The road\r\nnetwork is such that from any city you can get to any other one by\r\nmoving along the roads.You want to destroy the largest possible number\r\nof roads in the country so that the remaining roads would allow you to\r\nget from city to city in at most hours and get from city to city in at\r\nmost hours.Determine what maximum number of roads you need to destroy in\r\norder to meet the condition of your plan. If it is impossible to reach\r\nthe desired result, print -1.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\nint n , m , s1 , t1 , l1 , s2 , t2 , l2 , ans=-1 , f[3001] , d[3001][3001] ;\nvector<int> a[3001] ;\n \nvoid BFS(int u){\n  queue<pii> Q ;\n  memset(f,0,sizeof(f)) ;\n  \n  Q.push(pii(u,0)) , f[u]=1 ;\n  while(!Q.empty()){\n    int v=Q.front().first , len=Q.front().second ;\n    d[u][v]=len ;\n    Q.pop() ;\n\n    for(int i=0 ; i<a[v].size() ; i++) if(!f[a[v][i]]){\n       Q.push(pii(a[v][i],len+1)) ;\n       f[a[v][i]]=1 ;\n    }      \n  } \n}\n\nint main(){\n  cin >> n >> m ;\n  for(int i=1 , u , v; i<=m ; i++){ \n    cin >> u >> v ;\n    a[u].push_back(v) ; a[v].push_back(u) ;\n  }\n  cin >> s1 >> t1 >> l1 >> s2 >> t2 >> l2 ;\n  \n  for(int i=1 ; i<=n ; i++) BFS(i) ; \n  \n  if(d[s1][t1]<=l1 && d[s2][t2]<=l2) ans = m - d[s1][t1] - d[s2][t2] ;\n  for(int u=1 ; u<=n ; u++) for(int v=1 ; v<=n ; v++){\n    if(d[s1][u] + d[u][v] + d[v][t1] > l1) continue ;  \n    if((d[s2][u] + d[u][v] + d[v][t2] > l2) && (d[t2][u] + d[u][v] + d[v][s2] > l2)) continue ;\n    int tmp = d[s1][u] + d[u][v] + d[v][t1] + d[s2][u] + d[v][t2] ; \n    tmp = min(tmp , d[s1][u] + d[u][v] + d[v][t1] + d[t2][u] + d[v][s2] ) ; \n    ans = max( ans , m-tmp ) ; \n  } \n  \n  cout << ans ;\n\n  return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "graphs", "shortest paths"], "dificulty": "2100", "interactive": false}