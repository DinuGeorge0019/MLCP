{
    "link": "https://codeforces.com//contest/2060/problem/D",
    "problemId": "3147473",
    "problem_idx": "D",
    "shortId": "2060D",
    "contest_number": "2060",
    "problem_submissions": {
        "G": [
            301873530,
            301859046,
            301852803,
            301886996,
            301829945,
            301884074,
            301865362,
            301944483,
            301877663
        ],
        "F": [
            301809977,
            301827952,
            301788384,
            301831904,
            301878286,
            301872767,
            301850953,
            301874252,
            301811774,
            301816800,
            301831940,
            301815743,
            301889712,
            301854030,
            301836262,
            301832755,
            301848647,
            301843962,
            301841616,
            301902407
        ],
        "E": [
            301780977,
            301790293,
            301841004,
            301786821,
            301854824,
            301815095,
            301816295,
            301758990,
            301799665,
            301795284,
            301801086,
            301920235,
            301889573,
            301794741,
            301799175,
            301804483,
            301807413,
            301794652,
            301768541
        ],
        "D": [
            301771562,
            301772155,
            301822748,
            301775745,
            301785461,
            301801939,
            301852011,
            301776457,
            301782878,
            301769755,
            301787487,
            301917787,
            301889434,
            301776569,
            301786371,
            301790878,
            301764610,
            301773754,
            301756989
        ],
        "C": [
            301748633,
            301761322,
            301773736,
            301772188,
            301769620,
            301776760,
            301770890,
            301782439,
            301749719,
            301754417,
            301759048,
            301774305,
            301916945,
            301889316,
            301755362,
            301775118,
            301772704,
            301748352,
            301760800,
            301753236
        ],
        "B": [
            301746021,
            301755202,
            301761527,
            301755925,
            301795537,
            301759408,
            301745641,
            301745397,
            301750029,
            301750098,
            301915984,
            301888995,
            301750358,
            301751304,
            301755984,
            301781169,
            301750274,
            301748735
        ],
        "A": [
            301739564,
            301739279,
            301761253,
            301738865,
            301749974,
            301743163,
            301743222,
            301739250,
            301739375,
            301743095,
            301739024,
            301915381,
            301888689,
            301739666,
            301739726,
            301746215,
            301745343,
            301738637,
            301738767
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/138342",
    "editorial": "For clarity, let's denote opi\n as an operation performed on ai\n and ai+1\n.\n\nClaim: if it is possible, then the sequence of operations op1,op2,\u0085,opn?1\n will sort the array.\n\nProof: Let b\n be any sequence of operations that will sort the array. Let's transform the sequence b\n such that it becomes [op1,op2,\u0085,opn?1]\n.\n\nFirst, let's note that an opi\n does nothing if ai=0\n or ai+1=0\n. Additionally, after opi\n, at least one of ai,ai+1\n will become zero. Thus, we can remove all duplicates in b\n without altering the result.\n\nNow, let x\n be the largest number such that opx\n is in b\n. Since at least one of ax,ax+1\n will be zero, operations must be performed such that each of a1,a2,\u0085,ax?1\n are zero. Let S\n be the set of indices with i<x\n such that opi\n is not in b\n. Note that we can simply append each operation in S\n at the end of b\n without altering the result, since all elements before ax\n are already zero.\n\nOur sequence of operations now contain a permutation of op1,op2,\u0085,opx\n, and we have ensured that all of a1,a2,\u0085,ax=0\n. Since the sequence is now sorted, we can in fact continue performing opx+1,opx+2,\u0085,opn?1\n in this order. Notice that this sequence of operations will keep our array sorted, as opy\n will make ay=0\n (since ay<ay+1\n).\n\nLet's show that we can rearrange our operations such that 1\n comes first. There are two cases: either op1\n comes before op2\n, or op2\n comes before op1\n. In the first case, notice that no operation done before op1\n will impact either the value of a1\n or a2\n, so rearranging such that op1\n comes first does not impact the final results. In the second case, notice that after op2\n is done, we must have a1=a2\n, as otherwise op1\n will not simultaneously make a1=a2=0\n. This implies that right before op2\n is performed, we must have a1+a3=a2\n. Then, rearranging the operations such that op1\n comes first will not impact the final result.\n\nUsing the same line of reasoning, we can make op2\n the second operation, then op3\n, and so on. To solve the problem, we can simply simulate the operations in this order, and then check if the array is sorted at the end.",
    "name": "D. Subtract Min Sort",
    "statement": "You are given a sequence a consisting of n positive integers.You can\r\nperform the following operation any number of times. Select an index i\r\n(1\r\nle i < n), and subtract\r\nmin(a_i,a_{i+1}) from both a_i and a_{i+1}. Determine if it is possible\r\nto make the sequence by using the operation any number of times.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\u00a0    int t;    cin >> t;    while(t--){        int n;         cin >> n;        vector<long long> a(n);        for(int i=0; i<n; i++){            cin >> a[i];        }\u00a0        bool possible = true;        for(int i=n-1; i>=1; i--){            if(a[i-1] > a[i]){                long long x = a[i-1] - a[i];                int leftIdx = i-2; // 0-based index for a[i-2]                if(leftIdx < 0){                    possible = false;                    break;                }                a[leftIdx] -= x;   // reduce the left neighbor                a[i-1] = a[i];     // fix a[i-1] down to a[i]                if(a[leftIdx] < 0){                    possible = false;                    break;                }            }        }        if(possible){            for(int i=0; i+1<n; i++){                if(a[i] > a[i+1]){                    possible = false;                    break;                }            }        }\u00a0        cout << (possible ? \"YES\\n\" : \"NO\\n\");    }\u00a0    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Subtract Min Sort.json"
}