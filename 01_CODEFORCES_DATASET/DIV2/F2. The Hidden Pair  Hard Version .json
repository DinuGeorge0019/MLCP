{
    "link": "https://codeforces.com//contest/1370/problem/F2",
    "problemId": "652389",
    "problem_idx": "F2",
    "shortId": "1370F2",
    "contest_number": "1370",
    "problem_submissions": {
        "F2": [
            84487930,
            84501037,
            84507034,
            84502122,
            84505842,
            84494417,
            84504172,
            84566845,
            84578526,
            84673821,
            84511966,
            84521155,
            84516268,
            84510958,
            84637167,
            84542732
        ],
        "F1": [
            84486378,
            84486419,
            84492617,
            84502436,
            84505676,
            84494227,
            84501907,
            84505799,
            84499630,
            84498065,
            84511746,
            84521030,
            84480006,
            84503644,
            84491858,
            84509184,
            84485122,
            84503318,
            84509115,
            84506881
        ],
        "E": [
            84464817,
            84468991,
            84473151,
            84479507,
            84475443,
            84500759,
            84489817,
            84460631,
            84470842,
            84474055,
            84482485,
            84496561,
            84465043,
            84479036,
            84484283,
            84492032,
            84480292,
            84478287,
            84477997
        ],
        "D": [
            84455500,
            84452319,
            84463814,
            84469488,
            84464677,
            84451453,
            84463855,
            84448741,
            84456676,
            84455689,
            84468315,
            84454815,
            84457156,
            84464597,
            84470092,
            84462687,
            84463427,
            84468065,
            84460953
        ],
        "C": [
            84440472,
            84440716,
            84454929,
            84448947,
            84446464,
            84442992,
            84450392,
            84441491,
            84448508,
            84447398,
            84459387,
            84446704,
            84452028,
            84452970,
            84461892,
            84451604,
            84450230,
            84447402,
            84456732
        ],
        "B": [
            84435577,
            84430992,
            84438860,
            84436667,
            84431532,
            84431988,
            84433331,
            84431260,
            84434049,
            84434058,
            84441995,
            84433852,
            84624590,
            84440409,
            84443832,
            84438516,
            84432500,
            84433721,
            84440325,
            84431147
        ],
        "A": [
            84423084,
            84423206,
            84424226,
            84425612,
            84423582,
            84423261,
            84424093,
            84424056,
            84423388,
            84425755,
            84429438,
            84426743,
            84423750,
            84423134,
            84428806,
            84425122,
            84423069,
            84423389,
            84423328
        ]
    },
    "name": "F2. The Hidden Pair  Hard Version ",
    "statement": "You are given a tree consisting of n nodes numbered with integers from 1\r\nto n. Ayush and Ashish chose two secret distinct nodes in the tree. You\r\nneed to find out both the nodes. You can make the following query:\r\nProvide a list of nodes and you will receive a node from that list whose\r\nsum of distances to both the hidden nodes is minimal (if there are\r\nmultiple such nodes in the list, you will receive any one of them). You\r\nwill also get the sum of distances of that node to the hidden nodes.\r\nRecall that a tree is a connected graph without cycles. The distance\r\nbetween two nodes is defined as the number of edges in the simple path\r\nbetween them.More formally, let\u2019s define two hidden nodes as s and f. In\r\none query you can provide the set of nodes\r\n{a_1, a_2,\r\nldots, a_c\r\n} of the tree. As a result, you will get two numbers a_i and dist(a_i,\r\ns) + dist(a_i, f). The node a_i is any node from the provided set, for\r\nwhich the number dist(a_i, s) + dist(a_i, f) is minimal.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvector < int > g[1005];\nvector < int > h[1005];\nint lst[1005];\n\npair < int, int > ask(vector < int > a) {\n    cout << \"? \";\n    cout << a.size() << \" \";\n    for (auto key : a) cout << key << \" \";\n    cout << endl;\n    int u, s;\n    cin >> u >> s;\n    return {u, s};\n}\n\nvoid dfs(int v, int p, int H) {\n    lst[v] = p;\n    h[H].push_back(v);\n    for (auto u : g[v]) if (u != p) dfs(u, v, H + 1);\n}\n\nmain() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, u, v;\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        for (int i = 0; i <= n; ++i) g[i] = {}, h[i] = {};\n        for (int i = 1; i < n; ++i) {\n            cin >> u >> v;\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n        vector < int > a = {};\n        for (int i = 1; i <= n; ++i) a.push_back(i);\n        pair < int, int > cur = ask(a);\n        int root = cur.first, s = cur.second;\n        dfs(root, -1, 0);\n        int mx = 0;\n        for (int i = 0; i <= n; ++i) if ((int)h[i].size() > 0) mx = i;\n        int lef = max(-1, s / 2 - 2), righ = min(mx + 1, s + 2);\n        int answer = -1;\n        while (righ - lef > 1) {\n            int mid = (righ + lef) / 2;\n            cur = ask(h[mid]);\n            if (cur.second == s) answer = cur.first, lef = mid;\n            else righ = mid;\n        }\n        assert(answer != -1);\n        int two = s - lef;\n        vector < int > q;\n        set < int > bad;\n        int node = answer;\n        while (node != -1) {\n            bad.insert(node);\n            node = lst[node];\n        }\n        for (auto key : h[two]) {\n            if (bad.find(key) == bad.end() || key == root) q.push_back(key);\n        }\n        cur = ask(q);\n        assert(cur.second == s);\n        cout << \"! \" << answer << \" \" << cur.first << endl;\n        string S;\n        cin >> S;\n    }\n    return 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "graphs",
        "interactive",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. The Hidden Pair  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/79107",
    "editorial": ":We can find out one of the nodes in the path between the two hidden\r\nnodes using a single query. We can then root the tree at this node find\r\none of the hidden nodes using binary search on its distance from the\r\nroot.:If we query all nodes in the tree, we will receive one of the\r\nnodes in the path between the two hidden nodes and also the distance\r\nbetween the two hidden nodes. Proof: Suppose the distance between the\r\nhidden nodes is equal to . All the nodes in the simple path between the\r\ntwo hidden nodes have the sum of distances equal to . For all other\r\nnodes, the sum of distances is .Now that we found a node in the path\r\nbetween the hidden nodes, we will root the tree at . If we can find one\r\nof the hidden nodes, we can easily find the other hidden node by\r\nquerying all nodes at distance from the first hidden node.We can find\r\none of the hidden nodes using binary search on its distance from the\r\nroot. Suppose we query all the nodes at distance from the root and\r\nreceive the minimum sum of distance as . If there is at least one hidden\r\nnode whose distance from the root is , then must be equal to .\r\nOtherwise, must be greater than . So we can binary search on and\r\nappropriately change the upper or lower bound of the binary search based\r\non the minimum sum of distances received for the query. This takes\r\nqueries as the maximum depth could be up to .Then we need one more query\r\nto find the other hidden node. This takes a total of queries. Note that\r\nthis is sufficient to pass the easy version.We can further reduce the\r\nnumber of queries by if we notice that at least one of the hidden nodes\r\nmust be at least at a distance of from the root. So we can set the lower\r\nbound of the binary search to .Note that if we discard the largest child\r\nsubtree of the root, it also reduces the number of queries by .Time\r\ncomplexity:\r\n"
}