{
    "link": "https://codeforces.com//contest/1501/problem/D",
    "problemId": "922989",
    "problem_idx": "D",
    "shortId": "1501D",
    "contest_number": "1501",
    "problem_submissions": {
        "E": [
            109941376,
            109875512,
            109883789,
            110105518,
            110105287
        ],
        "F": [
            109904857
        ],
        "A": [
            109878442,
            109847988,
            109846729,
            109846494,
            109846135,
            109845267,
            109845587,
            109847199,
            109845456,
            109847603,
            109846645,
            109853330,
            109847527,
            109845680,
            109862040,
            109861437,
            109857820,
            109847064,
            109879578,
            109846519
        ],
        "B": [
            109859119,
            109845806,
            109857469,
            109847916,
            109848937,
            109845741,
            109938795,
            109847183,
            109850677,
            109848222,
            109850447,
            109858630,
            109845453,
            109850407,
            109847950,
            109859017,
            109850474,
            109855074,
            109848387,
            109851675,
            109849198
        ],
        "D": [
            109857126,
            109874773,
            109867593,
            109877645,
            109872691,
            109883837,
            109870581,
            109889646,
            109873833,
            109880027,
            109879853,
            109876481,
            109884289,
            109877446,
            109871324,
            109884869,
            109884357,
            109879548,
            109886127,
            109876946,
            109883128
        ],
        "C": [
            109846358,
            109849688,
            109852611,
            109851798,
            109861330,
            109852150,
            109856203,
            109859435,
            109862259,
            109860307,
            109858003,
            109857809,
            109860809,
            109860157,
            109856014,
            109855070,
            109852660,
            109851031,
            109863843,
            109867505
        ]
    },
    "name": "D. Two chandeliers",
    "statement": "Vasya is a CEO of a big construction company. And as any other big boss\r\nhe has a spacious, richly furnished office with two crystal chandeliers.\r\nTo stay motivated Vasya needs the color of light at his office to change\r\nevery day. Thatâ€™s why he ordered both chandeliers that can change its\r\ncolor cyclically. For example: red brown yellow red brown yellow and so\r\non. There are many chandeliers that differs in color set or order of\r\ncolors. And the person responsible for the light made a critical mistake\r\nthey bought two different chandeliers.Since chandeliers are different,\r\nsome days they will have the same color, but some days different. Of\r\ncourse, it looks poor and only annoys Vasya. As a result, at the k-th\r\ntime when chandeliers will light with different colors, Vasya will\r\nbecome very angry and, most probably, will fire the person who bought\r\nchandeliers.Your task is to calculate the day, when it happens (counting\r\nfrom the day chandeliers were installed). You can think that Vasya works\r\nevery day without weekends and days off.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\nconst int N=1000005,E=524288;\nint x[N],y[N],i,mp,c;\nlong long n,m,k,a[N];\nlong long exgcd(long long a,long long b,long long &x,long long &y)\n{\n\tif(b==0)\n\t{\n\t\tx=1,y=0;\n\t\treturn a;\n\t}\n\tlong long g=exgcd(b,a%b,x,y);\n\tlong long tmp=x;\n\tx=y;\n\ty=tmp-a/b*y;\n\treturn g;\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n#endif\n\tscanf(\"%lld %lld %lld\",&n,&m,&k);\n\tlong long lc=n*m/__gcd(n,m);\n\tmemset(x,-1,sizeof(x));\n\tmemset(y,-1,sizeof(y));\n\tfor(i=0;i<n;++i)\n\t{\n\t\tscanf(\"%d\",&c);\n\t\tx[c]=i;\n\t}\n\tfor(i=0;i<m;++i)\n\t{\n\t\tscanf(\"%d\",&c);\n\t\ty[c]=i;\n\t}\n\tlong long g=__gcd(n,m);\n\tfor(i=1;i<=2*max(n,m);++i)\n\t\tif(x[i]!=-1&&y[i]!=-1&&(y[i]-x[i])%g==0)\n\t\t{\n\t\t\tlong long A,b;\n\t\t\texgcd(n/g,m/g,A,b);\n\t\t\tA*=(y[i]-x[i])/g;\n\t\t\tA%=lc;\n\t\t\tlong long t=A*n+x[i];\n\t\t\tt=(t%lc+lc)%lc;\n\t\t\ta[++mp]=t;\n\t\t\t//cout<<i<<' '<<t<<endl;\n\t\t}\n\tsort(a+1,a+1+mp);\n\tlong long s=k/(lc-mp)*lc;\n\tk%=(lc-mp);\n\tif(k==0)\n\t{\n\t\tint u=lc-1;\n\t\tfor(i=mp;i>=1;--i)\n\t\t\tif(a[i]==u)\n\t\t\t{\n\t\t\t\t--u;\n\t\t\t\t--s;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t}\n\ta[0]=-1;\n\tfor(i=1;i<=mp;++i)\n\t\tif(k-(a[i]-a[i-1]-1)<=0)\n\t\t{\n\t\t\ts+=k;\n\t\t\tk=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk-=a[i]-a[i-1]-1;\n\t\t\ts+=a[i]-a[i-1];\n\t\t}\n\ts+=k;\n\tcout<<s;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "chinese remainder theorem",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Two chandeliers.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "A formal statement of the problem: there are two sequences of distinct integers, whose are infinitely cycled. You need to find prefix of minimal length which contains exactly k\n positions i\n such that ai?bi\n.\n\nLet's notice that we can use binary search. So we need to count number of positions i\n such that ai?bi\n on prefix of length x\n.\n\nBecause all integers in ai\n are distinct (and also in bi\n), we need to calculate number of non-negative solutions:\n\n{pos?x(modn)pos?y(modm)\n\nIf n\n and m\n are coprime, the value can be calculated with Chinese remainder theorem. Solution's complexity will be O((n+m)?log(n+m)?log(k?(n+m))\n.\n\nIf n\n and m\n are not coprime, participant can make transition (n,m)?(ngcd(n,m),mgcd(n,m))\n, solve new equations, and then make reverse transition.\n\nAfter that, you need to optimize this solution. There are many ways to do this, for example, you can precalculate solutions of all equations. And complexity becomes O((n+m)?(log(k)+log(n+m)))",
    "hint": []
}