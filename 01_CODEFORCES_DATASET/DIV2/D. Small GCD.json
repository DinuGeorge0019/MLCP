{
    "link": "https://codeforces.com//contest/1900/problem/D",
    "problemId": "2348161",
    "problem_idx": "D",
    "shortId": "1900D",
    "contest_number": "1900",
    "problem_submissions": {
        "E": [
            234456838,
            234455027,
            234457931,
            234455766,
            234456771,
            234460502,
            234461970,
            234463093,
            234461258,
            234461626,
            235437599,
            234459471,
            234465112,
            234465941,
            234463278,
            234463477,
            234464668,
            234464310,
            234465647,
            234465136
        ],
        "D": [
            234442999,
            234445532,
            234447119,
            234444027,
            234448662,
            234449846,
            234450821,
            234448590,
            234544232,
            234544122,
            234453539,
            234456816,
            234449461,
            234446745,
            234447346,
            234455068,
            234451202,
            234455283,
            234455174,
            234452017,
            234447175
        ],
        "C": [
            234433856,
            234437020,
            234438208,
            234438984,
            234436746,
            234440214,
            234440440,
            234440880,
            234441500,
            234437974,
            234441984,
            234439314,
            234438351,
            234441349,
            234441838,
            234441318,
            234441667,
            234442122,
            234444120
        ],
        "B": [
            234430889,
            234432938,
            234432800,
            234433842,
            234432820,
            234435211,
            234434789,
            234436751,
            234434039,
            234432505,
            234436824,
            234433963,
            234433725,
            234434390,
            234437612,
            234436752,
            234436425,
            234432619,
            234438330
        ],
        "A": [
            234429140,
            234429060,
            234429292,
            234429383,
            234429959,
            234434373,
            234428876,
            234431698,
            234428932,
            234429000,
            234431129,
            234431009,
            234429251,
            234429090,
            234434493,
            234430325,
            234429412,
            234429176,
            234429387
        ],
        "F": [
            234821914,
            234821787
        ]
    },
    "name": "D. Small GCD",
    "statement": "Let a, b, and c be integers. We define function f(a, b, c) as\r\nfollows:Order the numbers a, b, c in such a way that a\r\nle b\r\nle c. Then return\r\ngcd(a, b), where\r\ngcd(a, b) denotes the greatest common divisor (GCD) of integers a and\r\nb.So basically, we take the\r\ngcd of the 2 smaller values and ignore the biggest one. You are given an\r\narray a of n elements. Compute the sum of f(a_i, a_j, a_k) for each i,\r\nj, k, such that 1\r\nle i < j < k\r\nle n. More formally, compute\r\nsum_{i = 1}^n\r\nsum_{j = i+1}^n\r\nsum_{k =j +1}^n f(a_i, a_j, a_k).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < '0' || c > '9') c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x;\n}\nint n, a[80005], f[100005], g[100005];\nlong long ans;\nstd::vector <int> fac[100005];\nvoid solve(){\n\tscanf(\"%d\", &n); ans = 0ll;\n\tfor(int i = 1; i <= 100000; ++i) f[i] = g[i] = 0;\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tstd::sort(a + 1, a + n + 1);\n\tlong long tmp = 0ll;\n\tfor(int i = 1; i <= n; ++i){\n\t\tans += tmp;\n\t\tfor(auto v : fac[a[i]]){\n\t\t\tf[v] = g[v];\n\t\t\tfor(auto u : fac[a[i] / v]) if(u != 1) f[v] -= f[v * u];\n\t\t\ttmp += 1ll * v * f[v];\n\t\t}\n\t\tfor(auto v : fac[a[i]]) ++g[v];\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn ;\n}\nint main(){\n\tfor(int i = 1; i <= 100000; ++i) for(int j = i; j <= 100000; j += i) fac[j].push_back(i);\n\tfor(int i = 1; i <= 100000; ++i) std::reverse(fac[i].begin(), fac[i].end()); \n\tint T = 1;\n\tscanf(\"%d\", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Small GCD.json",
    "editorial_link": "https://codeforces.com//blog/entry/122677",
    "editorial": "Solution part 1We calculate from to . For some , we can first calculate\r\nthe number of triples that have a value of function that is an integer\r\nmultiple of , and then from it subtract . Because of the previous hint,\r\nthe subtractions will be quite fast.Now the question is how to calculate\r\nthe number of triples that have a value of function that is an integer\r\nmultiple of .\r\n",
    "hint": [
        "Hint 1 Let be the biggest value in the array. Calculate array such that ( ) is the number of triples which have of . Then the answer is the sum of over all ( ).",
        "Hint 2 Value of is around .",
        "Hint 3 Numbers up to can have at most divisors."
    ]
}