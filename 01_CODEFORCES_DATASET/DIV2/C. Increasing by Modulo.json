{
    "link": "https://codeforces.com//contest/1169/problem/C",
    "problemId": "349595",
    "problem_idx": "C",
    "shortId": "1169C",
    "contest_number": "1169",
    "problem_submissions": {
        "E": [
            54684403,
            54675804,
            54682359,
            54685449,
            54689566,
            54686198,
            54691604,
            54688678,
            54690724,
            54691237,
            54681393,
            54688847,
            54690654,
            54694731,
            55081389
        ],
        "D": [
            54680905,
            54683986,
            54684817,
            54682317,
            54679635,
            54689466,
            54908772,
            54684679,
            54690915,
            54687442,
            54685809,
            54685924,
            54681653,
            54683168,
            54681797,
            54682416,
            54683266,
            54682426,
            54682731,
            54684851,
            54684352
        ],
        "C": [
            54678532,
            54681169,
            54677843,
            54687880,
            54675623,
            54679704,
            54681667,
            54677693,
            54680121,
            54682979,
            54690039,
            54678308,
            54675885,
            54677830,
            54678752,
            54677564,
            54679339,
            54676201
        ],
        "B": [
            54673457,
            54678799,
            54680269,
            54673253,
            54673012,
            54676449,
            54676258,
            54675058,
            54676915,
            54675666,
            54692780,
            54676719,
            54675276,
            54674258,
            54673558,
            54671616,
            54673955,
            54671622,
            54675590,
            54674178
        ],
        "A": [
            54670054,
            54677136,
            54670973,
            54669910,
            54670050,
            54670444,
            54671253,
            54670673,
            54669870,
            54694380,
            54670378,
            54670212,
            54670638,
            54670322,
            54670547,
            54670037,
            54669810,
            54671042,
            54669779
        ]
    },
    "name": "C. Increasing by Modulo",
    "statement": "Toad Zitz has an array of integers, each integer is between 0 and m-1\r\ninclusive. The integers are a_1, a_2,\r\nldots, a_n.In one operation Zitz can choose an integer k and k indices\r\ni_1, i_2,\r\nldots, i_k such that 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq n. He should then change a_{i_j} to ((a_{i_j}+1)\r\nbmod m) for each chosen integer i_j. The integer m is fixed for all\r\noperations and indices.Here x\r\nbmod y denotes the remainder of the division of x by y.Zitz wants to\r\nmake his array non-decreasing with the minimum number of such\r\noperations. Find this minimum number of operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\nint n, m;\nint t[300001];\nint a=-1, b=300001;\nbool ker(int c)\n{\n    if (c>m) {\n        return true;\n    }\n    int prev=0;\n    for (int i=1; i<=n; i++) {\n        int p=t[i];\n        if (prev-p>c) {\n            return false;\n        }\n        if (p>=prev) {\n            if (p+c<m ||(p+c)%m<prev) {\n                prev=p;\n            }\n        }\n\n    }\n    return true;\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i=1; i<=n; i++) {\n        cin >> t[i];\n    }\n    while(b-a>1) {\n        int c=(a+b)/2;\n        if (ker(c)) {\n            b=c;\n        } else {\n            a=c;\n        }\n    }\n    cout << b << endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Increasing by Modulo.json",
    "editorial_link": "https://codeforces.com//blog/entry/67241",
    "editorial": "Let\u00e2\u0080\u0099s check that the answer to the problem is .Then, for each element,\r\nyou have some interval (interval on the \"circle\" of remainders modulo )\r\nof values, that it can be equal to.So you need to check that you can\r\npick in each interval some point, to make all these values\r\nnon-decrease.You can do it with greedy! Each time, let\u00e2\u0080\u0099s take the\r\nsmallest element from the interval, that is at least the previously\r\nchosen value.And after this, let\u00e2\u0080\u0099s make the binary search on .So we have\r\nthe solution in .This solution\r\n"
}