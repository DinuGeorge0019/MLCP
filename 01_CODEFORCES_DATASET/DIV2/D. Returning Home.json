{
    "link": "https://codeforces.com//contest/1422/problem/D",
    "problemId": "748726",
    "problem_idx": "D",
    "shortId": "1422D",
    "contest_number": "1422",
    "problem_submissions": {
        "F": [
            94701883,
            94826866,
            94826835,
            94745688,
            94705379,
            94693551,
            94953245,
            94915043,
            94711007,
            94710952
        ],
        "D": [
            94689176,
            94687852,
            94699245,
            94700756,
            94730858,
            94685919,
            94687412,
            94684031,
            94691326,
            94692798,
            209847951,
            94692199,
            94693976,
            94690624,
            94695759,
            95022837,
            94688084,
            94690199
        ],
        "C": [
            94679953,
            94679288,
            94678596,
            94684155,
            94679523,
            94703846,
            94668997,
            94676012,
            94678225,
            94681262,
            94689674,
            94678418,
            94678427,
            94678143,
            94682123,
            94677251,
            94684478,
            94676757,
            94679761
        ],
        "B": [
            94670303,
            94669460,
            94669121,
            94671181,
            94667987,
            94697716,
            94673035,
            94667020,
            94667631,
            94669211,
            94678649,
            94671772,
            94672654,
            94668738,
            94675426,
            94669613,
            94671963,
            94668373,
            94672738
        ],
        "A": [
            94662989,
            94664962,
            97569670,
            94661799,
            94662880,
            94662335,
            94664103,
            94661944,
            94661473,
            94662039,
            94663061,
            94665832,
            94661500,
            94664606,
            94661429,
            94662035,
            94661746,
            94661457,
            94662741,
            94673552
        ],
        "E": [
            94701493,
            94708058,
            94709364,
            94747586,
            95060609,
            95041928,
            94699655,
            94723718,
            94704623
        ]
    },
    "name": "D. Returning Home",
    "statement": "Yura has been walking for some time already and is planning to return\r\nhome. He needs to get home as fast as possible. To do this, Yura can use\r\nthe instant-movement locations around the city.Letâ€™s represent the city\r\nas an area of n\r\ntimes n square blocks. Yura needs to move from the block with\r\ncoordinates (s_x,s_y) to the block with coordinates (f_x,f_y). In one\r\nminute Yura can move to any neighboring by side block; in other words,\r\nhe can move in four directions. Also, there are m instant-movement\r\nlocations in the city. Their coordinates are known to you and Yura. Yura\r\ncan move to an instant-movement location in no time if he is located in\r\na block with the same coordinate x or with the same coordinate y as the\r\nlocation.Help Yura to find the smallest time needed to get home.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch=='-')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\n//I S(int x){return 1ll*x*(x+1)/2%mod;}\nint n,m,ans;\nint Sx,Sy,Fx,Fy;\nint X[N],Y[N],tag[N];\nint idx[N],idy[N],posx[N],posy[N];\nI dis(int x,int y,int p){\n\treturn min(abs(X[p]-x),abs(Y[p]-y));\n}\n#define P pair<int,int>\npriority_queue<P>q;\nV input(){\n\tn=getint(),m=getint();\n\tSx=getint(),Sy=getint(),Fx=getint(),Fy=getint();\n\tFOR(i,1,m)X[i]=getint(),Y[i]=getint();\n\tans=abs(Fx-Sx)+abs(Fy-Sy);\n\tFOR(i,1,m)q.push(P(-dis(Sx,Sy,i),i));\n}\nI cmpx(int x,int y){return X[x]<X[y];}\nI cmpy(int x,int y){return Y[x]<Y[y];}\nV init(){\n\tFOR(i,1,m)idx[i]=i;\n\tsort(idx+1,idx+1+m,cmpx);\n\tFOR(i,1,m)posx[idx[i]]=i;\n\tFOR(i,1,m)idy[i]=i;\n\tsort(idy+1,idy+1+m,cmpy);\n\tFOR(i,1,m)posy[idy[i]]=i;\n}\nV work(){\n\tfor(int u,w,v;!q.empty();){\n\t\tw=-q.top().first,u=q.top().second,q.pop();\n\t\tif(tag[u])continue;\n\t\ttag[u]=1,ans=min(0ll+ans,0ll+w+abs(X[u]-Fx)+abs(Y[u]-Fy));\n\t\tif((v=idx[posx[u]-1])&&!tag[v])\n\t\t\tq.push(P(-w-X[u]+X[v],v));\n\t\tif((v=idx[posx[u]+1])&&!tag[v])\n\t\t\tq.push(P(-w-X[v]+X[u],v));\n\t\tif((v=idy[posy[u]-1])&&!tag[v])\n\t\t\tq.push(P(-w-Y[u]+Y[v],v));\n\t\tif((v=idy[posy[u]+1])&&!tag[v])\n\t\t\tq.push(P(-w-Y[v]+Y[u],v));\n\t}\n\tcout<<ans<<'\\n';\n}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//\tfor(scanf(\"%d\",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n//\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Returning Home.json",
    "editorial_link": "https://codeforces.com//blog/entry/83452",
    "editorial": "You can build a graph with vertices at the start point and all fast\r\ntravel points. The distance between the vertices and is calculated as .\r\nTo avoid drawing all edges in the graph, note that for a pair of points\r\nand such that , if there is a point with coordinate such that it is\r\nbetween and (), then the distance between the first and second point\r\nwill be equal to the sum of the distances between the first and third\r\nand between the third and second. In this case, the edge between the\r\nfirst and second points does not need to be drawn it will be\r\nunnecessary. It turns out that for each point of the graph it will be\r\nenough to draw the edges to the points nearest along the axis in both\r\ndirections. Similarly for . Next, in the constructed graph, we find the\r\nminimum distance from the starting point to each point of the graph and\r\nsum it up with the distance to the end point , which is equal to . Among\r\nall the distances, we choose the minimum one.\r\n",
    "hint": []
}