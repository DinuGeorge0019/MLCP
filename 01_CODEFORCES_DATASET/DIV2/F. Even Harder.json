{
    "link": "https://codeforces.com//contest/1453/problem/F",
    "problemId": "821027",
    "problem_idx": "F",
    "shortId": "1453F",
    "contest_number": "1453",
    "problem_submissions": {
        "E": [
            100380052,
            155118161,
            100374406,
            100382833,
            100376358,
            100380373,
            100377845,
            100376439,
            100372651,
            100372508,
            100374319,
            100375311,
            100361396,
            100374016,
            100375798,
            100374877,
            100376885,
            100376092,
            100374918,
            100369776
        ],
        "D": [
            100375780,
            155118139,
            100367299,
            100371256,
            100369898,
            100372322,
            100371648,
            100366312,
            100368463,
            100366176,
            100366391,
            100373742,
            100368086,
            100364639,
            100371848,
            100367162,
            100368628,
            100369799,
            100372351
        ],
        "C": [
            100370717,
            155118105,
            100363680,
            100365192,
            100365975,
            100366748,
            100365481,
            100362777,
            100362628,
            100362653,
            100362794,
            100366264,
            100365011,
            100362269,
            100364059,
            100363843,
            100363639,
            100365174,
            100365522,
            100366070
        ],
        "F": [
            100365572,
            155118244,
            100384810,
            100377057,
            100384158,
            100383537,
            100385977,
            100390112,
            100382350,
            100381472,
            100408619,
            100428520
        ],
        "B": [
            100359448,
            155118064,
            100359921,
            100359636,
            100358954,
            100362716,
            100359915,
            100357443,
            100358086,
            100356217,
            100356739,
            100370528,
            100358105,
            100356427,
            100359186,
            100359063,
            100373277,
            100358271,
            100360209,
            100363310
        ],
        "A": [
            100352068,
            155118022,
            100354202,
            100352085,
            100350847,
            100354848,
            100351796,
            100357299,
            100351053,
            100350650,
            100351488,
            100367409,
            100350533,
            100350757,
            100350887,
            100350551,
            100351187,
            100351697,
            100352074,
            100358933
        ]
    },
    "name": "F. Even Harder",
    "statement": "Gildong is now developing a puzzle game. The puzzle consists of n\r\nplatforms numbered from 1 to n. The player plays the game as a character\r\nthat can stand on each platform and the goal of the game is to move the\r\ncharacter from the 1-st platform to the n-th platform.The i-th platform\r\nis labeled with an integer a_i (0\r\nle a_i\r\nle n-i). When the character is standing on the i-th platform, the player\r\ncan move the character to any of the j-th platforms where i+1\r\nle j\r\nle i+a_i. If the character is on the i-th platform where a_i=0 and i\r\nne n, the player loses the game.Since Gildong thinks the current game is\r\nnot hard enough, he wants to make it even harder. He wants to change\r\nsome (possibly zero) labels to 0 so that there remains exactly one way\r\nto win. He wants to modify the game as little as possible, so he’s\r\nasking you to find the number of platforms that should have their labels\r\nchanged. Two ways are different if and only if there exists a platform\r\nthe character gets to in one way but not in the other way.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint _,n,dp[3005][3005],tot,a[3005],F[3005];\nint main(){\n    cin >> _;\n    while (_--){\n        cin >> n;\n        for (int i=1;i<=n;i++) cin >> a[i];\n        for (int i=1;i<=n+1;i++)\n        for (int j=1;j<=n+1;j++) dp[i][j]=n+1;\n        dp[1][1]=0;\n        F[1]=0;\n        for (int i=2;i<=n;i++) F[i]=n+1;\n        for (int i=2;i<=n;i++){\n            for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][i]);\n            tot=0;\n            for (int j=i-1;j;j--){\n                if (j+a[j]>=i){\n                    dp[i][j+a[j]+1]=min(dp[i][j+a[j]+1],F[j]+tot);\n                    ++tot;\n                }\n            }\n        }\n        for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][n+1]);\n        cout << F[n] << endl;\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Even Harder.json",
    "editorial_link": "https://codeforces.com//blog/entry/85288",
    "editorial": "Since there is at least one way to win initially, every platform is\r\nreachable from the start. Note that this condition should still hold\r\nafter we achieve what Gildong wants. Because of this, if there are\r\nmultiple âs where , there are at least two ways that can get to the -th\r\nplatform. Therefore, in order to leave only one way to get to the -th\r\nplatform, we need to change all âs where into except for one of them.\r\nWeâll call this process , and the platforms where we set are the\r\nplatforms.Let () be the minimum number of platforms that should be to\r\nleave only one way to get to the -th platform, where the only platform\r\nthat can directly move to the -th platform (i.e. the predecessor) has a\r\nvalue at most . In other words, only considers all âs where , and choose\r\nthe one that requires minimum number of platforms so far. Weâll\r\ndetermine in increasing order of .Now let be the number of âs where and\r\n. Initially is . Now for each from to (downwards), if , minimize with\r\nand then increase by . This means we all platforms between and to let\r\nthe -th platform be the predecessor of the -th platform, while it has\r\npossibility to reach the -th platform. Note that all âs where and are\r\nalready when calculating , so we only need to count the platforms\r\nbetween and for .Then we can prefix-minimize because the actual meaning\r\nof the is the minimum number of platforms that should be for the\r\npredecessor of the -th platform can reach the -th platform; i.e. it\r\nshould consider all cases where as well.After we repeat these processes\r\nfor all âs, the answer is . Though the explanation is quite complicated,\r\nthe code turns out to be very short.Time complexity: .\r\n",
    "hint": []
}