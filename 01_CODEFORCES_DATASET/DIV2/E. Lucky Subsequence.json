{
    "link": "https://codeforces.com//contest/146/problem/E",
    "problemId": "844",
    "problem_idx": "E",
    "shortId": "146E",
    "contest_number": "146",
    "problem_submissions": {
        "E": [
            1107649,
            1106940,
            1107025,
            1106110,
            1104912,
            1106705,
            1109524,
            1109375
        ],
        "D": [
            1105309,
            1104675,
            1105945,
            1107976,
            1106326,
            1106073,
            1105205,
            1106349,
            1104562,
            1105428,
            1106336,
            1105647,
            1104691,
            1106147,
            1106016,
            1105646,
            1105960
        ],
        "C": [
            1102780,
            1104080,
            1102877,
            1102469,
            1102797,
            1103007,
            1102279,
            1103376,
            1102389,
            1103154,
            1102564,
            1102512,
            1103182,
            1102102,
            1103314,
            1102745,
            1102381,
            1103228
        ],
        "B": [
            1102298,
            1104365,
            1102361,
            1102000,
            1102441,
            1102529,
            1101911,
            1102170,
            1101819,
            1102472,
            1102060,
            1102101,
            1102285,
            1105411,
            1102661,
            1102358,
            1103722,
            1102489
        ],
        "A": [
            1101303,
            1104909,
            1101580,
            1101222,
            1102090,
            1101773,
            1101311,
            1101481,
            1102909,
            1101618,
            1101388,
            1101178,
            1101582,
            1101659,
            1101533,
            1101613,
            1103048,
            1101789
        ]
    },
    "name": "E. Lucky Subsequence",
    "statement": "Petya has sequence consisting of integers.The subsequence of the\r\nsequence is such subsequence that can be obtained from by removing zero\r\nor more of its elements.Two sequences are considered different if index\r\nsets of numbers included in them are different. That is, the values of\r\nthe elements do not matter in the comparison of subsequences. In\r\nparticular, any sequence of length has exactly different subsequences\r\n(including an empty subsequence).A subsequence is considered lucky if it\r\nhas a length exactly and does not contain two identical lucky numbers\r\n(unlucky numbers can be repeated any number of times).Help Petya find\r\nthe number of different lucky subsequences of the sequence . As Petya’s\r\nparents don’t let him play with large numbers, you should print the\r\nresult modulo prime number .\r\n",
    "solutions": [
        "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int\tMAX_N\t= 100000 + 10;\nconst int\tMOD\t\t= 1000000007;\nint\t\t\tx, y;\nint\t\t\tN, K, M;\nint\t\t\ttot;\nint\t\t\ta\t\t[MAX_N];\nint\t\t\tw\t\t[MAX_N];\nll\t\t\tf\t\t[2][MAX_N];\n\nint Check_Lucky(int x)\n{\n\twhile (x) {\n\t\tif (x % 10 != 7 && x % 10 != 4) return 0;\n\t\tx /= 10;\n\t}\n\treturn 1;\n}\n\nvoid Init()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 1; i <= N; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + N + 1);\n\tfor(int i = 1; i <= N; ++ i) \n\t\tif ((i == 1 || a[i] != a[i - 1]) && Check_Lucky(a[i])) {\n\t\t\t++ tot;\n\t\t\tw[tot] ++;\n\t\t\twhile (i < N && a[i] == a[i + 1]) {\n\t\t\t\t++ w[tot];\n\t\t\t\t++ i;\n\t\t\t}\n\t\t} else ++ M;\n\t//cout << tot << ' ' << M;\n}\n\nvoid Ex_Gcd(ll a, ll b)\n{\n\tif (! b) {x = 1; y = 0; return; }\n\tEx_Gcd(b, a % b);\n\tll tmp = x;\n\tx = y;\n\ty = tmp - a / b * y;\n}\n\nll Get_Anti(ll a)\n{\n\tEx_Gcd(a, MOD);\n\tif (x < 0) x += MOD;\n\treturn x;\n}\n\nvoid Div(ll &t, int p)\n{\n\tll anti = Get_Anti(p);\n\tt = t * anti % MOD;\n}\n\nvoid Calc()\n{\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= min(K, M); ++ i) {\n\t\tf[0][i] = f[0][i - 1] * (M - i + 1) % MOD;\n\t\tDiv(f[0][i], i);\n\t}\n}\n\nvoid Solve()\n{\n\tCalc();\n\tint now = 0, pre;\n\tfor(int i = 1; i <= tot; ++ i) {\n\t\tpre = now; now ^= 1;\n\t\tf[now][0] = 1;\n\t\tfor(int j = 1; j <= K; ++ j)\n\t\t\tf[now][j] = (f[pre][j] + f[pre][j - 1] * w[i]) % MOD;\n\t}\n\tcout << f[now][K] << endl;\n}\n\nint main()\n{\n\tInit();\n\tSolve();\n\t//system(\"pause\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Lucky Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/3746",
    "editorial": "As you probably know, the number of lucky numbers in range [1;109] is 1022. We use this fact to solve problem. Let C[i] - number of occurrences of i-th lucky number in array a. Now we schould calculate DP with parameters DP[pos][cnt] - what is the number of subsequences that we use lucky numbers up to pos-th and our subsequence contains exactly cnt lucky number. If we are on state DP[pos][cnt] we can do two things: do not use pos-th lucky number (and do DP[pos+1][cnt] += DP[pos][cnt]) or use pos-th lucky (and do DP[pos+1][cnt+1] += DP[pos][cnt]*C[pos], because you have C[pos] of pos-th lucky number).\n\nNow we need to find total result. To do that we iterate through the number of lucky numbers in our subsequence i. Then you need to multiple that number by C(countunlucky,?k?-?i) (bin. coefficient), where countunlucky - number of unlucky numbers of sequence. Sum for all such i will be the total result.",
    "hint": []
}