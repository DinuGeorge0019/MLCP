{"link": "https://codeforces.com//contest/1417/problem/F", "problemId": "740376", "problem_idx": "F", "shortId": "1417F", "contest_number": "1417", "problem_submissions": {"D": [94021013, 93997987, 93994414, 94008928, 93994813, 93993974, 93997393, 93994886, 93995533, 94000707, 94022056, 93991179, 93997856, 94000293, 94004446, 94003381, 93990919, 93999146, 94004809, 93994289, 93993273], "C": [94008586, 93979621, 93985626, 93982539, 93981622, 93998363, 93982359, 93986555, 93983202, 93992239, 93983337, 93991411, 93986598, 93990140, 93991651, 94001522, 93986870, 93985359, 93998445, 93985761], "B": [94003048, 93973490, 93978330, 93975968, 93973585, 93982217, 93975658, 93979313, 93975689, 93981775, 93977350, 93981714, 93975469, 93979278, 93978354, 96285430, 93978356, 93980291, 93977440, 94041345, 93979236, 93977870], "A": [94001724, 93970294, 93970800, 93971885, 93969936, 93980954, 93971325, 93970349, 93971917, 93971289, 93969984, 93970972, 93971064, 93971068, 93971066, 96285403, 93971270, 93973889, 93971400, 94041333, 93974793, 93971921], "E": [94000180, 93995718, 94008025, 93998585, 94011058, 94003165, 94008902, 94012205, 94012202, 94009571, 94022535, 94014181, 94009089, 94015399, 94011955, 94009323, 94016150, 94015958, 94013413, 94011012, 94019762], "F": [93992993, 94142204, 94142122]}, "name": "F. Graph and Queries", "statement": "You are given an undirected graph consisting of n vertices and m edges.\r\nInitially there is a single integer written on every vertex: the vertex\r\ni has p_i written on it. All p_i are distinct integers from 1 to n.You\r\nhave to process q queries of two types: 1 v among all vertices reachable\r\nfrom the vertex v using the edges of the graph (including the vertex v\r\nitself), find a vertex u with the largest number p_u written on it,\r\nprint p_u and replace p_u with 0; 2 i delete the i-th edge from the\r\ngraph. Note that, in a query of the first type, it is possible that all\r\nvertices reachable from v have 0 written on them. In this case, u is not\r\nexplicitly defined, but since the selection of u does not affect\r\nanything, you can choose any vertex reachable from v and print its value\r\n(which is 0).\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = 2e5 + 25;\nconst int M = 3e5 + 35;\nconst int Q = 5e5 + 55;\n\nint n, m, q;\nvector<int> g[N];\nint a[M], b[M], p[N];\nint type[Q], ind[Q];\nvector<int> ord[N];\nint dsup[N], pos[N];\nint sz[N], ar[N], tr[N << 2];\n\nstruct DSU_Save{\n\tint u, v, pu, pv, szu, szv;\n};\n\nint find(int v){\n\tif(dsup[v] == v)return v;\n\treturn find(dsup[v]);\n}\n\nvector<DSU_Save> vds;\n\nvoid dsusave(int u, int v){\n\tvds.push_back({u, v, dsup[u], dsup[v], sz[u], sz[v]});\n}\n\nvoid rollback(){\n\tassert(!vds.empty());\n\tauto x = vds.back();\n\tvds.pop_back();\n\tdsup[x.u] = x.pu;\n\tdsup[x.v] = x.pv;\n\tsz[x.u] = x.szu;\n\tsz[x.v] = x.szv;\n}\n\nvoid combine(int u, int v){\n\tu = find(u);\n\tv = find(v);\n\tdsusave(u, v);\n\tif(u == v)return;\n\tif(ord[u].size() < ord[v].size())swap(u, v);\n\tfor(int x : ord[v]){\n\t\tord[u].push_back(x);\n\t}\n\tdsup[v] = u;\n\tsz[u] += sz[v];\n}\n\nvoid build(int v, int l, int r){\n\tif(l == r){\n\t\ttr[v] = ar[l];\n\t\treturn;\n\t}\n\tint m = (l + r)/2;\n\tint v1 = v << 1;\n\tint v2 = v1 | 1;\n\tbuild(v1, l, m);\n\tbuild(v2, m + 1, r);\n\tif(p[tr[v1]] > p[tr[v2]])tr[v] = tr[v1];\n\telse tr[v] = tr[v2];\n}\n\nvoid update(int v, int l, int r, int ii){\n\tif(l == r){\n\t\tp[tr[v]] = 0;\n\t\treturn;\n\t}\n\tint m = (l + r)/2;\n\tint v1 = v << 1;\n\tint v2 = v1 | 1;\n\tif(ii <= m)update(v1, l, m, ii);\n\telse update(v2, m + 1, r, ii);\n\tif(p[tr[v1]] > p[tr[v2]])tr[v] = tr[v1];\n\telse tr[v] = tr[v2];\n}\n\nint query(int v, int s, int e, int l, int r){\n\tif(l <= s && e <= r)return tr[v];\n\tint m = (s + e)/2;\n\tint v1 = v << 1;\n\tint v2 = v1 | 1;\n\tif(r <= m)return query(v1, s, m, l, r);\n\tif(m < l)return query(v2, m + 1, e, l, r);\n\tint x = query(v1, s, m, l, r);\n\tint y = query(v2, m + 1, e, l, r);\n\tif(p[x] > p[y])return x;\n\treturn y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout<<setprecision(32);\n\n\tcin >> n >> m >> q;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> p[i];\n\t\tord[i].push_back(i);\n\t\tdsup[i] = i;\n\t\tsz[i] = 1;\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> a[i] >> b[i];\n\t}\n\tset<int> remst;\n\tfor(int i = 1; i <= q; i++){\n\t\tcin >> type[i] >> ind[i];\n\t\tif(type[i] == 2)remst.insert(ind[i]);\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tif(remst.count(i))continue;\n\t\tcombine(a[i], b[i]);\n\t}\n\tfor(int i = q; i >= 1; i--){\n\t\tif(type[i] == 2){\n\t\t\tcombine(a[ind[i]], b[ind[i]]);\n\t\t}\n\t}\n\tint ptr = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(find(i) != i)continue;\n\t\tfor(auto x : ord[i]){\n\t\t\tar[ptr] = x;\n\t\t\tpos[x] = ptr;\n\t\t\tptr++;\n\t\t}\n\t}\n\tbuild(1, 1, n);\n\tfor(int i = 1; i <= q; i++){\n\t\tif(type[i] == 1){\n\t\t\tint u = ind[i];\n\t\t\tint l = pos[find(u)];\n\t\t\tint r = l + sz[find(u)] - 1;\n\t\t\tint x = query(1, 1, n, l, r);\n\t\t\t// cout << l << \" \" << r << \" \" << p[x] << '\\n';\n\t\t\tcout << p[x] << '\\n';\n\t\t\tupdate(1, 1, n, pos[x]);\n\t\t}else{\n\t\t\trollback();\n\t\t}\n\t}\n\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dsu", "trees"], "dificulty": "2600", "interactive": false}