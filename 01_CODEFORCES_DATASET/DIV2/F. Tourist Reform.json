{"link": "https://codeforces.com//contest/732/problem/F", "problemId": "76076", "problem_idx": "F", "shortId": "732F", "contest_number": "732", "problem_submissions": {"E": [21538888, 21537779, 21537129, 21537499, 21538134, 21538715, 21544444, 21539734, 21540059, 21536661, 21540840, 21542039, 21534910, 21538735, 21535519, 21536958, 21540398, 21538120, 21542707], "F": [21537120, 21540142, 21542965, 21544806, 21544597, 21545399, 21540042, 21543034, 21545483, 21656308, 21554885], "D": [21532629, 21525539, 21530620, 21528537, 21533913, 21534989, 21534469, 21531559, 21536597, 21530734, 21531936, 21535213, 21537946, 21531246, 21536546, 21534126, 21532973, 21532309, 21534225], "C": [21530647, 21529152, 21528463, 21531507, 21530354, 21530901, 21532584, 21527470, 21533687, 21527417, 21527627, 21531693, 21526633, 21526154, 21527731, 21528874, 21530241, 21527402, 21526262], "B": [21523702, 21526949, 21525416, 21523386, 21525291, 21525800, 21523178, 21524106, 21531342, 21523932, 21525092, 21525450, 21524463, 21523658, 21524734, 21525994, 21523984, 21522251, 21523311], "A": [21522134, 21538223, 21523250, 21522010, 21522393, 21523229, 21521947, 21521953, 21522096, 21522038, 21522617, 21523179, 21522061, 21522531, 21523191, 21523859, 21522155, 21528156, 21521893]}, "name": "F. Tourist Reform", "statement": "Berland is a tourist country! At least, it can become such the\r\ngovernment of Berland is confident about this. There are cities in\r\nBerland, some pairs of which are connected by two-ways roads. Each road\r\nconnects two different cities. In Berland there are no roads which\r\nconnect the same pair of cities. It is possible to get from any city to\r\nany other city using given two-ways roads. According to the reform each\r\nroad will become one-way. It will be oriented to one of two\r\ndirections.To maximize the tourist attraction of Berland, after the\r\nreform for each city the value will be calculated. It will equal to the\r\nnumber of cities for which there is an oriented path from the city to\r\nthe city . In other words, will equal the number of cities which can be\r\nreached from the city by roads. The government is sure that tourist\u2019s\r\nattention will be focused on the minimum value of .Help the government\r\nof Berland make the reform to maximize the minimum of .\r\n", "solutions": ["#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 404040;\nint n , m , u[N] , v[N];\nvector<pii> g[N];\npii ans[N];\n\nnamespace BCC{\n    vi key;\n    vector<pii> bcc[N];\n    int dfn[N] , low[N] , id[N] , st[N] , _st , _;\n    void dfs(int c,int dep,vector<pii> g[]){\n        int cc=0;st[_st++]=c;\n        dfn[c]=low[c]=dep;\n        //cout << c << \" \" << dep << endl;\n        for(auto e:g[c]){\n            int t=e.fi;\n            if(!dfn[t]){\n                ans[e.se] = mp(c,t);\n                dfs(t,dep+1,g);\n                low[c]=min(low[c],low[t]);\n                if(low[t]>dfn[c]) key.pb(e.se);\n            } else if(dfn[t] != dfn[c] - 1 || cc++){\n                low[c] = min(low[c] , dfn[t]);\n                if(dfn[t] < dfn[c]) ans[e.se] = mp(c , t);\n            }\n        }\n        if(low[c]==dfn[c]){\n            do{id[st[--_st]]=_;}while(st[_st]!=c);\n            _++;\n        }\n    }\n    int sz[N];\n    void dfs(int c,int fa){\n        for(auto t : bcc[c]) if(t.fi != fa){\n            int a = u[t.se] , b = v[t.se];\n            if(id[a] == c) swap(a , b);\n            ans[t.se] = mp(a , b);\n            //ans[t.se] = mp(0 , 0);\n            dfs(t.fi , c);\n        }\n    }\n    int solve(int n,vector<pii> g[]){\n        rep(i,0,n) if(!dfn[i]) dfs(i,1,g);\n        rep(i,0,n) sz[id[i]]++;\n        rep(i,0,n) for(auto j:g[i]) if(id[i]!=id[j.fi])\n            bcc[id[i]].pb(mp(id[j.fi],j.se));\n        int id = -1 , Max = -1;\n        rep(i,0,_) if(sz[i] > Max) Max = sz[i] , id = i;\n        dfs(id , -1);\n        printf(\"%d\\n\",Max);\n        rep(i,0,m) printf(\"%d %d\\n\",ans[i].fi + 1,ans[i].se + 1);\n        return _;\n    }\n};\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,m){\n        scanf(\"%d%d\",u + i , v + i);\n        --u[i];--v[i];\n        g[u[i]].pb(mp(v[i] , i));\n        g[v[i]].pb(mp(u[i] , i));\n    }\n    BCC::solve(n,g);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "2300", "interactive": false}