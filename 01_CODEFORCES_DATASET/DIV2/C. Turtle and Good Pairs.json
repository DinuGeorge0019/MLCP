{
    "link": "https://codeforces.com//contest/2003/problem/C",
    "problemId": "2836627",
    "problem_idx": "C",
    "shortId": "2003C",
    "contest_number": "2003",
    "problem_submissions": {
        "E2": [
            278341707,
            278455104,
            278330622,
            278179988,
            278257072,
            278360261,
            278589270
        ],
        "E1": [
            278142159,
            278142843,
            278147621,
            278145820,
            278139445,
            278118163,
            278284773,
            278152908,
            278522597
        ],
        "D2": [
            278115632,
            278124223,
            278116119,
            278123063,
            278131280,
            278090274,
            278184104,
            278101954,
            278115622,
            278113440,
            278105822,
            278109507,
            278111408,
            278106372,
            278109910,
            278114958,
            278113518,
            278109092
        ],
        "D1": [
            278092613,
            278095057,
            278099358,
            278106267,
            278123018,
            278076086,
            278136646,
            278080662,
            278086676,
            278089029,
            278091347,
            278090118,
            278085289,
            278096196,
            278091226,
            278088309,
            278092415,
            278094460
        ],
        "C": [
            278073298,
            278084142,
            278084204,
            278091216,
            278102032,
            278059873,
            278062388,
            278064696,
            278066407,
            278065300,
            278076163,
            278064469,
            278071045,
            278077312,
            278070267,
            278068388,
            278071776,
            278071322
        ],
        "B": [
            278057061,
            278062158,
            278060356,
            278059818,
            278072173,
            278051522,
            278051239,
            278054673,
            278056246,
            278057857,
            278063310,
            278056133,
            278051957,
            278062245,
            278058767,
            278054937,
            278067356,
            278063368
        ],
        "A": [
            278051014,
            278054951,
            278054980,
            278049465,
            278052299,
            278047930,
            278047962,
            278049334,
            278049908,
            278052979,
            278052705,
            278049194,
            278048004,
            278057248,
            278049244,
            278048425,
            278067001,
            278049077
        ],
        "F": [
            283415067,
            278185607,
            278644931
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/132953",
    "editorial": "Partition the string into several maximal contiguous segments of\r\nidentical characters, denoted as . For example, the string \"aabccc\" can\r\nbe divided into .We can observe that a pair is considered a \"good pair\"\r\nif and only if the segments containing and are non-adjacent.Let . Then,\r\nthe number of good pairs is . Hence, the task reduces to minimizing .If\r\nconsists of only one character, simply output the original string.\r\nOtherwise, for , it can be inductively proven that , and this minimum\r\nvalue of can be achieved.As for the construction, let the maximum\r\nfrequency of any character be , and the second-highest frequency be .\r\nBegin by placing instances of the most frequent character at the start.\r\nThen, there are remaining instances of both the most frequent and the\r\nsecond most frequent characters. Next, sort all characters by frequency\r\nin descending order and alternate between them when filling the\r\npositions (ignoring any character once itâs fully used). This guarantees\r\nthat, except for the initial segment of length , all other segments have\r\na length of exactly .Time complexity: per test case, where .\r\n",
    "name": "C. Turtle and Good Pairs",
    "statement": "Turtle gives you a string s, consisting of lowercase Latin\r\nletters.Turtle considers a pair of integers (i, j) (1\r\nle i < j\r\nle n) to be a if and only if there exists an integer k such that i\r\nle k < j and of the following two conditions hold: s_k\r\nne s_{k + 1}; s_k\r\nne s_i s_{k + 1}\r\nne s_j. Besides, Turtle considers a pair of integers (i, j) (1\r\nle i < j\r\nle n) to be a if and only if s_i = s_j (i, j) is a pleasant pair.Turtle\r\nwants to reorder the string s so that the number of good pairs is .\r\nPlease help him!\r\n",
    "solutions": [
        "#include <bits/stdc++.h> #define ranges std::ranges#define views std::views using u32 = unsigned;using i64 = long long;using u64 = unsigned long long; using pii = std::pair<int, char>;using a3 = std::array<int, 3>;using a4 = std::array<int, 4>; const int N = 1e6;const int MAXN = 1e6 + 10;const int inf = 1e9;// const int mod = 1e9 + 7;const int mod = 998244353; void solve() {    int n;std::cin >> n;    std::string s;std::cin >> s;    std::map<char, int> mp;    for (auto ch : s)mp[ch]++;    std::priority_queue<pii> pq;    for (auto [ch, cnt] : mp)pq.push({ cnt,ch });    std::string ans;    while (pq.size()) {        auto [cnt, ch] = pq.top();        pq.pop();        if (ans.empty() || ans.back() != ch || pq.empty()) {            ans += ch;            cnt--;            if (cnt)pq.push({ cnt,ch });        }        else {            auto [cnt2, ch2] = pq.top();            pq.pop();            pq.push({ cnt,ch });            ans += ch2;            cnt2--;            if (cnt2)pq.push({ cnt2,ch2 });        }    }    std::cout << ans;} signed main() {    std::ios::sync_with_stdio(false);    std::cin.tie(0), std::cout.tie(0);    int t;std::cin >> t;    while (t--) {        solve();        std::cout << '\\n';    }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings",
        "strings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Turtle and Good Pairs.json",
    "hint": [
        "Hint You should understand what is a good pair ."
    ]
}