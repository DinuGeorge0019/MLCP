{
    "link": "https://codeforces.com//contest/1982/problem/F",
    "problemId": "2717391",
    "problem_idx": "F",
    "shortId": "1982F",
    "contest_number": "1982",
    "problem_submissions": {
        "F": [
            267371295,
            267368983,
            267386192,
            267383481,
            267392812,
            267381747,
            267380349,
            267448537,
            267389268,
            267391412,
            267465375,
            267464196,
            267398754,
            267397907,
            267394247,
            267400370,
            267398779,
            267402058,
            267403186,
            267394811,
            267400611,
            267395899,
            267401217
        ],
        "E": [
            267356282,
            267356215,
            267370786,
            267372088,
            267363741,
            267371679,
            267383797,
            267376185,
            267367589,
            267367768,
            267377973,
            267379190,
            267379180,
            267375802,
            267376857,
            267377392,
            267370644,
            267387467,
            267382680,
            267383608
        ],
        "D": [
            267346551,
            267374785,
            267348133,
            267346019,
            267349259,
            267353213,
            267344889,
            267351505,
            267357173,
            267352582,
            267348135,
            267356257,
            267354124,
            267361818,
            267348920,
            267361280,
            267376940,
            267358334,
            267368263,
            267363956
        ],
        "C": [
            267340189,
            267360218,
            267340523,
            267338463,
            267344601,
            267345277,
            267337376,
            267446413,
            267343870,
            267348671,
            267345336,
            267334950,
            267349986,
            267345653,
            267351831,
            267339030,
            267352675,
            267359528,
            267350804,
            267359049,
            267348772
        ],
        "B": [
            267337179,
            267335525,
            267333706,
            267334809,
            267331361,
            267341628,
            267345760,
            267336279,
            267343504,
            267333937,
            267331022,
            267335181,
            267340882,
            267340337,
            267334531,
            267343773,
            267346672,
            267347539,
            267353296,
            267342437
        ],
        "A": [
            267328525,
            267326985,
            267328071,
            267327102,
            267327552,
            267328303,
            267347395,
            267326942,
            267331875,
            267328032,
            267327692,
            267327319,
            267328382,
            267327600,
            267327418,
            267330803,
            267331257,
            267327782,
            267348137,
            267328398
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130839",
    "editorial": "Let\u00e2\u0080\u0099s maintain a set of positions such that , and also a segment tree\r\n(or any other data structure that allows changing the value at a\r\nposition and finding the minimum/maximum on a segment). Recalculating\r\nthe set and the segment tree is quite simple for each change in the\r\narray .To answer a query, let\u00e2\u0080\u0099s notice a few facts: If is empty, then\r\nthe array is completely sorted. If is not empty, then we can find the\r\nminimum and maximum elements from this set, denote them as , . With\r\nthese elements, we can easily answer queries. Similarly to the previous\r\npoint, we can say that the prefix of size and the suffix of size are\r\nsorted in non-decreasing order. Now, at the very least, we need to sort\r\nthe segment such that , . How can we find exactly these and ? First,\r\nlet\u00e2\u0080\u0099s find . To do this, we find the minimum on the segment , this value\r\nwill be somewhere in the prefix of the entire array, so we need to find\r\nthe position in the prefix between which elements it should be inserted.\r\nBut we also know that the prefix is sorted, so we can use binary search\r\n(as in insertion sort) and find the position for this value. This\r\nposition will be our .For , everything is similar, we find the maximum\r\non the segment and also find its position in the sorted suffix.In\r\nconclusion, to find the answer after changing the array, we need to find\r\nthe maximum/minimum positions in , the maximum/minimum on the segment,\r\nand perform binary searches on the prefix and suffix. All of this works\r\nin .Complexity: It is also worth noting that some solutions with can\r\nalso fit within the time limit if they are very carefully written and\r\nuse a non-recursive segment tree.\r\n",
    "name": "F. Sorting Problem Again",
    "statement": "You have an array a of n elements. There are also q modifications of the\r\narray. Before the first modification and after each modification, you\r\nwould like to know the following:What is the minimum length subarray\r\nthat needs to be sorted in non-decreasing order in order for the array a\r\nto be completely sorted in non-decreasing order?More formally, you want\r\nto select a subarray of the array (l, r) with the minimum value of r -\r\nl + 1. After that, you will sort the elements a_{l}, a_{l + 1},\r\nldots, a_{r} and want the condition a_{i}\r\nle a_{i + 1} to hold for all 1\r\nle i < n. If the array is already sorted in non-decreasing order, then l\r\nand r should be considered as equal to -1.Note that finding such (l, r)\r\ndoes not change the array in any way. The modifications themselves take\r\nthe form: assign a_{pos} = x for given pos and x.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0#define ar array#define sz(v) int(v.size())typedef long long ll;\u00a0const int mxN=5e5, mxQ=mxN;\u00a0int N, Q;int a[mxN];ar<int, 2> qr[mxQ];vector<ar<int, 2>> v;\u00a0const int mxS=1<<20;struct info {    int lef, sz; bool inc;};info operator+(const info &a, const info &b) {    if (!a.sz) return b;    if (!b.sz) return a;    return info{a.lef, a.sz+b.sz, a.inc&&b.inc&&a.lef+a.sz==b.lef};}info st[mxS*2];int S;\u00a0void upd(int i, int x) {    i+=S;    st[i]=x?info{v[i-S][1],1,1}:info{-1,0,1};    while (i/=2) st[i]=st[i*2]+st[i*2+1];}int qry1() {    int i=1;    info x{-1,1,1};    if ((x+st[1]).inc) return N;    while (i<S) {        if ((x+st[i*2]).inc) {            x=x+st[i*2];            i=i*2+1;        } else i=i*2;    }    return x.sz-1;}int qry2() {    int i=1;    info x{N,1,1};    if ((st[1]+x).inc) return N;    while (i<S) {        if ((st[i*2+1]+x).inc) {            x=st[i*2+1]+x;            i=i*2;        } else i=i*2+1;    }    return x.sz-1;}void qry() {    int u=qry1(), w=qry2();    if (u==N) cout<<\"-1 -1\\n\";    else cout<<u+1<<' '<<N-w<<'\\n';}\u00a0void solve() {    cin>>N;    for (int i=0; i<N; i++) {        cin>>a[i];        v.push_back({a[i],i});    }    cin>>Q;    for (int q=0; q<Q; q++) {        cin>>qr[q][0]>>qr[q][1], qr[q][0]--;        v.push_back({qr[q][1],qr[q][0]});    }    sort(v.begin(),v.end());    v.erase(unique(v.begin(),v.end()),v.end());    for (int i=0; i<N; i++) {        a[i]=lower_bound(v.begin(),v.end(),ar{a[i],i})-v.begin();    }    for (int q=0; q<Q; q++) {        qr[q][1]=lower_bound(v.begin(),v.end(),ar{qr[q][1],qr[q][0]})-v.begin();    }    S=1;    while (S<sz(v)) S*=2;    for (int i=1; i<S*2; i++) st[i]=info{-1,0,1};    for (int i=0; i<N; i++) upd(a[i],1);    qry();    for (int q=0; q<Q; q++) {        auto [i,x]=qr[q];        upd(a[i],0);        upd(a[i]=x,1);        qry();    }    v={};}\u00a0int main() {    ios::sync_with_stdio(0); cin.tie(0);    int T=1;    cin>>T;    while (T--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "sortings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Sorting Problem Again.json"
}