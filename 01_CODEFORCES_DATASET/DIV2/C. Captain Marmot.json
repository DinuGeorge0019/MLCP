{"link": "https://codeforces.com//contest/474/problem/C", "problemId": "14847", "problem_idx": "C", "shortId": "474C", "contest_number": "474", "problem_submissions": {"F": [8116116, 8111347, 8114247, 8117109, 8119759, 8119274, 8115617, 8117848, 8117464, 8117692, 8128068, 8128022, 8117327, 8118237, 8119671, 8142598, 8120637, 8119403, 8120748, 8142553, 8142542, 8142530, 8124718], "E": [8115184, 8114217, 8112389, 8114867, 8116240, 8115244, 8120717, 8120099, 8115954, 8123772, 8128154, 8128134, 8116067, 8117086, 8119886, 8115878, 8118972, 8118469, 8118934, 8119664, 8118899, 8119466], "C": [8112567, 8114486, 8117872, 8117009, 8121035, 8124320, 8113338, 8116442, 8121988, 8120682, 8122009, 8128422, 8130552, 8113770, 8117339, 8116750], "D": [8110246, 8110989, 8115114, 8112497, 8111050, 8112447, 8109737, 8115431, 8111354, 8111585, 8113528, 8114235, 8114084, 8108822, 8113696, 8116276, 8114733, 8114795, 8112957, 8112642], "B": [8108782, 8109337, 8115774, 8108967, 8110289, 8109920, 8110734, 8108738, 8109834, 8112357, 8109436, 8112150, 8112245, 8109821, 8112135, 8108859, 8109140, 8108856, 8110418, 8108483], "A": [8107723, 8108745, 8116336, 8108373, 8107695, 8108517, 8107682, 8107784, 8107553, 8108585, 8107565, 8112928, 8110053, 8110849, 8110377, 8107596, 8107999, 8107713, 8108893, 8107595]}, "name": "C. Captain Marmot", "statement": "Captain Marmot wants to prepare a huge and important battle against his\r\nenemy, Captain Snake. For this battle he has regiments, each consisting\r\nof moles.Initially, each mole () is placed at some position in the\r\nCartesian plane. Captain Marmot wants to move some moles to make the\r\nregiments , if it\u2019s possible.Each mole has a home placed at the position\r\n. Moving this mole one time means rotating his position point degrees\r\ncounter-clockwise around it\u2019s home point .A regiment is only if the\r\nposition points of the moles form a square with non-zero area.Help\r\nCaptain Marmot to find out for each regiment the minimal number of moves\r\nrequired to make that regiment compact, if it\u2019s possible.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kInf = 0x3f3f3f3f;\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int _x, int _y) : x(_x), y(_y) {}\n    void read() {\n        scanf(\"%d%d\", &x, &y);\n    }\n    bool operator==(const Point &t) const {\n        return x == t.x && y == t.y;\n    }\n    Point operator-(const Point &t) const {\n        return Point(x - t.x, y - t.y);\n    }\n    int len2() const {\n        return x * x + y * y;\n    }\n    int dot(const Point &t) const {\n        return x * t.x + y * t.y;\n    }\n} p[4], q[4], o[4], v[4];\n\nint t[4];\n\nbool check() {\n    for (int i = 0; i < 4; ++ i) {\n        o[i] = p[i];\n        int k = t[i];\n        while (k > 0) {\n            -- k;\n            Point tmp = o[i] - q[i];\n            o[i].x = q[i].x - tmp.y;\n            o[i].y = q[i].y + tmp.x;\n        }\n    }\n    for (int i = 0; i < 3; ++ i)\n        for (int j = i + 1; j < 4; ++ j)\n            if (o[i] == o[j]) return false;\n    int seq[4];\n    for (int i = 0; i < 4; ++ i) seq[i] = i;\n    do {\n        bool chk = true;\n        int len = (o[seq[1]] - o[seq[0]]).len2();\n        for (int i = 1; i < 4; ++ i) {\n            int j = (i + 1) & 3;\n            int tmp = (o[seq[j]] - o[seq[i]]).len2();\n            if (tmp != len) {\n                chk = false;\n            }\n        }\n        for (int i = 0; i < 4; ++ i) {\n            int j = (i + 1) & 3;\n            v[i] = o[seq[j]] - o[seq[i]];\n        }\n        for (int i = 0; i < 4; ++ i) {\n            int j = (i + 1) & 3;\n            if (v[i].dot(v[j]) != 0) chk = false;\n        }\n        if (chk) return true;\n    } while (next_permutation(seq, seq + 4));\n    return false;\n}\n\nint main() {\n    int T;\n    for (scanf(\"%d\", &T); T --; ) {\n        for (int i = 0; i < 4; ++ i) {\n            p[i].read();\n            q[i].read();\n        }\n        int res = kInf;\n        for (t[0] = 0; t[0] < 4; ++ t[0])\n            for (t[1] = 0; t[1] < 4; ++ t[1])\n                for (t[2] = 0; t[2] < 4; ++ t[2])\n                    for (t[3] = 0; t[3] < 4; ++ t[3])\n                        if (check()) {\n                            res = min(res, t[0] + t[1] + t[2] + t[3]);\n                        }\n        if (res == kInf) {\n            res = -1;\n        }\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "geometry"], "dificulty": "2000", "interactive": false}