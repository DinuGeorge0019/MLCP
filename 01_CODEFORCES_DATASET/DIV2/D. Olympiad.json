{
    "link": "https://codeforces.com//contest/222/problem/D",
    "problemId": "1639",
    "problem_idx": "D",
    "shortId": "222D",
    "contest_number": "222",
    "problem_submissions": {
        "E": [
            2114302,
            2112427,
            2113769,
            2118198,
            2113138,
            2117211,
            2116587,
            2116925,
            2112376,
            2112549,
            2117600,
            2115393,
            2116550,
            2112090,
            2117599,
            2114599,
            2113354,
            2115001,
            2116489,
            2115394
        ],
        "D": [
            2113640,
            2115490,
            2114107,
            2114475,
            2116493,
            2113562,
            2117592,
            2115503,
            2114322,
            2113844,
            2115759,
            2116789,
            2117762,
            2114698,
            2116546,
            2115578,
            2112252,
            2113514,
            2111962,
            2114392
        ],
        "C": [
            2112582,
            2114175,
            2116212,
            2112540,
            2115296,
            2116020,
            2113930,
            2113022,
            2117883,
            2118828,
            2118364,
            2128042,
            2114721,
            2135487
        ],
        "B": [
            2110124,
            2110976,
            2110362,
            2110813,
            2111132,
            2110340,
            2110934,
            2114259,
            2110860,
            2110665,
            2111315,
            2113871,
            2110626,
            2110122,
            2112637,
            2111026,
            2115073,
            2109978,
            2113250,
            2110096
        ],
        "A": [
            2109295,
            2109423,
            2109374,
            2109339,
            2110128,
            2109729,
            2109986,
            2117404,
            2109976,
            2109443,
            2111894,
            2111710,
            2109696,
            2115927,
            2111503,
            2109885,
            2115483,
            2109309,
            2111536,
            2109416
        ]
    },
    "name": "D. Olympiad",
    "statement": "A boy named Vasya has taken part in an Olympiad. His teacher knows that\r\nin total Vasya got at least points for both tours of the Olympiad. The\r\nteacher has the results of the first and the second tour of the Olympiad\r\nbut the problem is, the results have only points, no names. The teacher\r\nhas to know Vasya\u2019s chances.Help Vasya\u2019s teacher, find two numbers the\r\nbest and the worst place Vasya could have won. Note that the total\r\nresults\u2019 table sorts the participants by the sum of points for both\r\ntours (the first place has the participant who has got the most points).\r\nIf two or more participants have got the same number of points, it\u2019s up\r\nto the jury to assign places to them according to their choice. It is\r\nguaranteed that each participant of the Olympiad participated in both\r\ntours of the Olympiad.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nmultiset<int> s;\nint a[ 100001 ], b[ 100001 ];\n\nint main( )\n{\n\tint n, p, i, t1, t2, q = 1000000000, ans = 1;\n\tmultiset<int>::iterator ii;\n\tscanf(\"%d%d\", &n, &p);\n\tfor ( i = 0; i < n; i++ ) scanf(\"%d\", &a[ i ]);\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tscanf(\"%d\", &b[ i ]);\n\t\ts.insert( b[ i ] );\n\t}\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tii = s.lower_bound( p - a[ i ] );\n\t\tif ( ii != s.end( ) )\n\t\t\tif ( q > *ii + a[ i ] )\n\t\t\t{\n\t\t\t\tq = *ii + a[ i ];\n\t\t\t\tt1 = *ii;\n\t\t\t\tt2 = i;\n\t\t\t}\n\t}\n\tii = s.find( t1 );\n\ts.erase( ii );\n\tfor ( i = 0; i < n; i++ )\n\t{\n\t\tif ( i == t2 ) continue;\n\t\tii = s.lower_bound( q - a[ i ] );\n\t\tif ( ii != s.end( ) )\n\t\t{\n\t\t\tans++;\n\t\t\ts.erase( ii );\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Olympiad.json",
    "editorial_link": "https://codeforces.com//blog/entry/5251",
    "editorial": "First of all, note that in any case the best place which Vasya can take is the first place for he can earn maximum points. Now we must find the worst place which Vasya can take. We need to find maximal matching in bipartite graph, where the edge between vertice i from the first part and vertice j from the second part exists if a[i] + b[j] >= x. To solve this task, it is enough just to sort the vertices in both parts of the graph by their weights and use two pointers method. Suppose that we have sorted all the vertices by non-increasing points (a1 >= a2 >= ... >= an). Let's take two pointers \u0097 L = 1 in the first part and R = N in the second part. While a[L] + b[R] < x we must decrease R to find the first vertice such a[L] + b[R] >= x. When we found such R, we must add this edge to the answer, i.e. increase the answer, increase L by 1, decrease R by 1. It is easy to show why this algo is correct and it finds the optimal solution. I have discovered a truly marvelous proof of this, but the margins of this analysis are too narrow to for him. Complexity \u0097 O(N log N) for sorting and O(N) for two pointers."
}