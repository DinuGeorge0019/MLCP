{
    "link": "https://codeforces.com//contest/276/problem/E",
    "problemId": "2661",
    "problem_idx": "E",
    "shortId": "276E",
    "contest_number": "276",
    "problem_submissions": {
        "E": [
            3187361,
            3187958,
            3187266,
            3188860,
            3188847,
            3189852,
            3189777,
            3189922,
            3189457,
            3190167,
            3186861,
            3189884,
            3191275,
            3193117
        ],
        "D": [
            3182892,
            3183526,
            3184256,
            3183830,
            3184596,
            3184640,
            3186374,
            3185199,
            3185759,
            3187754,
            3185579,
            3186224,
            3184708,
            3185151,
            3188148
        ],
        "C": [
            3182135,
            3182445,
            3183293,
            3183004,
            3183598,
            3183024,
            3180811,
            3183631,
            3182886,
            3184756,
            3183375,
            3183166,
            3181941,
            3184406,
            3183798,
            3183022
        ],
        "B": [
            3181517,
            3181475,
            3182700,
            3182413,
            3182645,
            3185448,
            3182835,
            3183061,
            3184639,
            3183463,
            3182154,
            3183111,
            3182195,
            3182637,
            3182319
        ],
        "A": [
            3180648,
            205334917,
            3180631,
            3180670,
            3181189,
            3180635,
            3180790,
            3181809,
            3180963,
            3183528,
            3181306,
            3190356,
            3180679,
            3180682,
            3181358,
            3180738
        ]
    },
    "name": "E. Little Girl and Problem on Trees",
    "statement": "A little girl loves problems on trees very much. Here\u2019s one of them.A\r\ntree is an undirected connected graph, not containing cycles. The degree\r\nof node in the tree is the number of nodes of the tree, such that each\r\nof them is connected with node by some edge of the tree. Let\u2019s consider\r\na tree that consists of nodes. We\u2019ll consider the tree\u2019s nodes indexed\r\nfrom 1 to . The cosidered tree has the following property: each node\r\nexcept for node number 1 has the degree of at most 2.Initially, each\r\nnode of the tree contains number 0. Your task is to quickly process the\r\nrequests of two types: Request of form: . In reply to the request you\r\nshould add to all numbers that are written in the nodes that are located\r\nat the distance of at most from node . The distance between two nodes is\r\nthe number of edges on the shortest path between them. Request of form:\r\n. In reply to the request you should print the current number that is\r\nwritten in node .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 200010\nint he[N],ne[N*2],ad[N*2],d[N],n,m,st[N],le[N],bl[N],w[N],a[N],L,S1;\nint f[N*2],g[N];\nvoid addE(int x,int y)\n{\n    static int t=0;\n    ++t,ne[t]=he[x],he[x]=t,ad[t]=y;\n    ++t,ne[t]=he[y],he[y]=t,ad[t]=x;\n}\ninline int lb(int x){return x&(x^(x-1));}\nvoid add(int *f,int n,int x,int y)\n{\n    x=n-x+1;\n    while(x<=n)f[x]+=y,x+=lb(x);\n}\nint ask(int *f,int n,int x)\n{\n    x=n-x+1;\n    int S=0;\n    while(x>0)S+=f[x],x-=lb(x);\n    return S;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1,x,y;i<n;i++)\n        scanf(\"%d%d\",&x,&y),addE(x,y);\n    int la=0;\n    for(int p=he[1];p;p=ne[p])\n    {\n        int c=ad[p];\n        st[L]=la;bl[c]=L,w[c]=la,a[la++]=c;le[L]=1;\n        int law=1;\n        while(true)\n        {\n            bool F=1;\n            for(int p=he[c];p;p=ne[p])\n                if(ad[p]!=law)\n                {\n                    int d=ad[p];law=c;c=d;\n                    le[L]++;w[c]=la,a[la++]=c;bl[c]=L;\n                    F=0;\n                    break;\n                }\n            if(F)break;\n        }\n        L++;la++;\n    }\n    for(int i=2;i<=n;i++)d[i]=w[i]-st[bl[i]]+1;\n    //for(int i=1;i<=n;i++)printf(\"%d %d\\n\",i,d[i]);\n    /*\n    for(int i=0;i<L;i++)\n        for(int j=st[i];j<st[i]+le[i];j++)\n            printf(\"%d%c\",a[j],j==st[i]+le[i]-1?'\\n':' ');\n    */\n    while(m--)\n    {\n        int z;scanf(\"%d\",&z);\n        if(z==0)\n        {\n            int x,y;scanf(\"%d%d%d\",&x,&y,&z);\n            if(z>=d[x])S1+=y;\n            if(z>d[x])add(g,n,z-d[x],y);\n            int l=max(d[x]-z,1),r=min(d[x]+z,le[bl[x]]);\n            add(f+st[bl[x]],le[bl[x]],l-1,-y);\n            add(f+st[bl[x]],le[bl[x]],r,y);\n            if(z>d[x])add(f+st[bl[x]],le[bl[x]],min(z-d[x],le[bl[x]]),-y);\n        }else\n        if(z==1)\n        {\n            int x;scanf(\"%d\",&x);\n            if(x==1){printf(\"%d\\n\",S1);continue;}\n            printf(\"%d\\n\",ask(g,n,d[x])+ask(f+st[bl[x]],le[bl[x]],d[x]));\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Little Girl and Problem on Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/6779",
    "editorial": "One can see, that our tree is a set of chains, each of which starts in\r\nthe root. First of all we need to decompose our tree in chains using,\r\nfor example, depth first search. For each vertex we should find out it s\r\ndepth and number of chain, which contain this vertex. For each chain we\r\nll use some data structure, which can fast enough change it s elements\r\nand fast enough answer to the range sum query. For example, we canuse\r\nBinary Indexed Tree (BIT). We also need to create one BIT for root. This\r\nBIT is global: it s information is actual for all the chains Let s\r\nremember problem . In that problem we used array for processing all the\r\nqueries. We need to know values of elements of array in that problem\r\nafter processing all the queries. In this problem queries are online.\r\nThat s why we need to use BIT; it allows to change element and answer\r\nrange sum query in time. Let s learn, how to process queries, which\r\nrequire modification and queries, which require finding the element,\r\nusing BIT. BIT can make two types of operations: add value to element\r\nwith index finds sum in range from to Let s consider, that we need to\r\nadd value to all elements in range from to . Than we should just make\r\noperations and . Let s consider, that we have query which require\r\nprinting the value of element with index . Then we should just make\r\noperation . Now let s go back to the initial problem. During the\r\nprocessing query of type we should check, if it affects the root. If\r\nquery affects the root, we should carefully process this query in our\r\nchain and make necessary changes in root s BIT. Otherwise we just\r\nprocess query in our chain. During the processing query of type we\r\nshould just find corresponding sums in root s BIT and in BIT for our\r\nchain. We should print the sum of this values. Time complexity of this\r\nsolution is C++ code Java code That s all. I ll be very glad to answer\r\nto your question in comments.\r\n"
}