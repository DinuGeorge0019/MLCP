{
    "link": "https://codeforces.com//contest/1983/problem/C",
    "problemId": "2739878",
    "problem_idx": "C",
    "shortId": "1983C",
    "contest_number": "1983",
    "problem_submissions": {
        "A": [
            269278635,
            269224195,
            269223849,
            269226514,
            269225288,
            269224120,
            269223887,
            269227486,
            269224712,
            269226231,
            269238169,
            269260779,
            269225102,
            269240926,
            269224023,
            269229049,
            269229008,
            269229437,
            269227958,
            269225179
        ],
        "B": [
            269278056,
            269230788,
            269229550,
            269238075,
            269239775,
            269233840,
            269232426,
            269237259,
            269236179,
            269236169,
            269241163,
            269259016,
            269240024,
            269241196,
            269235107,
            269248703,
            269237529,
            269237369,
            269239496,
            269241230
        ],
        "C": [
            269275559,
            269239407,
            269240124,
            269245784,
            269247404,
            269241159,
            269249194,
            269246484,
            269242664,
            269245963,
            269247870,
            269238276,
            269244413,
            269249774,
            269246281,
            269260121,
            269247344,
            269247358,
            269248698,
            269249698
        ],
        "D": [
            269272884,
            269243672,
            269246000,
            269251406,
            269251795,
            269246010,
            269251878,
            269256401,
            269252027,
            269252217,
            269233789,
            269246546,
            269246776,
            269243749,
            269249916,
            269266016,
            269254304,
            269252415,
            269266726,
            269258898
        ],
        "E": [
            269270622,
            269249510,
            269250892,
            269257523,
            269260300,
            269262071,
            269262617,
            269264482,
            269265164,
            269262684,
            269292411,
            269254378,
            269261706,
            269275920,
            269289749,
            269263092,
            269288046,
            269277163,
            269273777,
            269273251
        ],
        "F": [
            269262701,
            269255388,
            269260448,
            269269019,
            269272052,
            269277444,
            269269564,
            269275950,
            269279316,
            269281347,
            269264892,
            269293501,
            269287451,
            269340337,
            269340202,
            269285676,
            269275010,
            269281603,
            269272906,
            269290579,
            269289233,
            269284840
        ],
        "G": [
            269252950,
            269304269,
            269304164,
            269349906
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131268",
    "editorial": "There can be several correct answers. It is sufficient to find any\r\ncorrect answer.Although it is not necessary to finish the entire cake,\r\nwe can easily find a way such that the entire cake is given away.We can\r\nstart by trying to give a prefix to Alice. To determine if it is\r\npossible to divide the cake such that Alice gets at least one-third of\r\nthe total value by taking a prefix, and Bob and Charlie can split the\r\nremaining cake into two parts where each gets at least one-third of the\r\ntotal value, we can use the following approach:We start by calculating\r\nthe prefix sums for Alice, Bob, and Charlie. Using these prefix sums, we\r\niterate left to right to search for the minimum prefix size for Alice,\r\nwhere she gets at least one-third of the total value. Once we find an\r\nindex, we give that prefix to Alice and search again on array to check\r\nif we can give a prefix of the remaining cake to Bob such that Bob gets\r\nat least one-third of the total sum, and so does Charlie. If, after\r\nremoving the prefix of the remaining cake, the value left for Charlie is\r\nnot enough, we repeat the last step on array instead and check if the\r\nvalue of the cake left for Bob after Alice and Charlie get theirsâ is\r\nenough.If the above fails, we repeat the process starting with a prefix\r\nof . If that fails too, we try again, beginning with a prefix of . Here\r\nare the specific steps for each of the 6 permutations of Alice, Bob, and\r\nCharlie:1. Start with a prefix for Alice, then check Bobâs prefix and\r\nCharlie gets the rest of the cake.2. Start with a prefix for Alice, then\r\ncheck Charlieâs prefix and Bob gets the rest of the cake.3. Start with a\r\nprefix for Bob, then check Aliceâs prefix and Charlie gets the rest of\r\nthe cake.4. Start with a prefix for Bob, then check Charlieâs prefix and\r\nAlice gets the rest of the cake.5. Start with a prefix for Charlie, then\r\ncheck Aliceâs prefix and Bob gets the rest of the cake.6. Start with a\r\nprefix for Charlie, then check Bobâs prefix and Alice gets the rest of\r\nthe cake.If after trying all permutations, none of them work, the answer\r\nis \"-1\". Otherwise, print the respective indices for the subarrays.\r\n",
    "name": "C. Have Your Cake and Eat It Too",
    "statement": "Alice, Bob and Charlie want to share a rectangular cake cut into n\r\npieces. Each person considers every piece to be worth a different value.\r\nThe i-th piece is considered to be of value a_i by Alice, b_i by Bob and\r\nc_i by Charlie.The sum over all a_i, all b_i and all c_i individually is\r\nthe same, equal to tot.Given the values of each piece of the cake for\r\neach person, you need to give each person a contiguous slice of cake. In\r\nother words, the indices at the left and right ends of these subarrays\r\n(the slices given to each person) can be represented as (l_a, r_a),\r\n(l_b, r_b) and (l_c, r_c) respectively for Alice, Bob and Charlie. The\r\ndivision needs to satisfy the following constraints: No piece is\r\nassigned to more than one person, i.e., no two subarrays among [l_a,\r\nldots,r_a], [l_b,\r\nldots, r_b] and [l_c,\r\nldots, r_c] intersect.\r\nsum_{i = l_a}^{r_a} a_i,\r\nsum_{i = l_b}^{r_b} b_i,\r\nsum_{i = l_c}^{r_c} c_i\r\ngeq\r\nlceil\r\nfrac{tot}{3}\r\nrceil. Here, the notation\r\nlceil\r\nfrac{a}{b}\r\nrceil represents ceiling division. It is defined as the smallest integer\r\ngreater than or equal to the exact division of a by b. In other words,\r\nit rounds up the division result to the nearest integer. For instance\r\nlceil\r\nfrac{10}{3}\r\nrceil = 4 and\r\nlceil\r\nfrac{15}{3}\r\nrceil = 5.\r\n",
    "solutions": [
        "// Problem: C. Have Your Cake and Eat It Too// Contest: Codeforces - Codeforces Round #956 (Div. 2) and ByteRace 2024// URL: https://mirror.codeforces.com/contest/1983/problem/C// Memory Limit: 256 MB// Time Limit: 2000 ms// // Powered by CP Editor (https://cpeditor.org) // Author: EnucAI#include <bits/stdc++.h> #ifdef LOCAL#include \"debug.h\"#else#define D(...) ((void)0)#endif using ll = long long;using ull = unsigned long long;using ld = long double;using vi = std::vector<int>;using pii = std::pair<int, int>; constexpr int inf = std::numeric_limits<int>::max() / 2;constexpr ll infll = std::numeric_limits<ll>::max() / 2;constexpr ld eps = 1e-8l; #define all(x) (x).begin(), (x).end()#define sz(x) ((int)((x).size()))#define rep(i, j, k) for (int i = (j); i <= (k); i++)#define per(i, j, k) for (int i = (j); i >= (k); i--)#define fi first#define se second#define mp std::make_pair#define pb push_back#define ppb pop_back#define eb emplace_back template <class X, class Y> void chkmax(X &x, const Y &y) { if (x < y) x = y; }template <class X, class Y> void chkmin(X &x, const Y &y) { if (x > y) x = y; } constexpr int maxn = 2e5 + 5; int n, a[3][maxn]; void work() {  std::cin >> n;  rep(j, 0, 2) rep(i, 1, n) std::cin >> a[j][i];  ll need = (std::accumulate(a[0] + 1, a[0] + n + 1, 0ll) + 2) / 3;  int ord[] = {0, 1, 2};  do {    int p = 1, l[3], r[3];    bool ok = true;    rep(j, 0, 2) {      l[ord[j]] = p;      ll cur = 0;      while (p <= n && cur < need) cur += a[ord[j]][p++];      if (cur < need) {        ok = false;        break;      }      r[ord[j]] = p - 1;    }    if (ok) {      rep(j, 0, 2) std::cout << l[j] << ' ' << r[j] << \" \\n\"[j == 2];      return;    }  } while (std::next_permutation(ord, ord + 3));  std::cout << \"-1\\n\";} int main() {  std::cin.tie(nullptr)->sync_with_stdio(false);  int t;  std::cin >> t;  while (t--) work();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Have Your Cake and Eat It Too.json",
    "hint": []
}