{
    "link": "https://codeforces.com//contest/1152/problem/A",
    "problemId": "335380",
    "problem_idx": "A",
    "shortId": "1152A",
    "contest_number": "1152",
    "problem_submissions": {
        "C": [
            53244845,
            53230927,
            53233766,
            53235808,
            53234198,
            53234839,
            53238158,
            53233895,
            53244428,
            53238661,
            53245124,
            53237428,
            53241947,
            53255111,
            53240873,
            53232261,
            53233767,
            53232829
        ],
        "E": [
            53239734,
            53245640,
            53249082,
            53237299,
            53252319,
            53253962,
            53269982,
            53253449,
            53252636,
            53255804,
            53252841,
            53252353,
            53235804,
            53253519,
            53250724,
            53255613,
            53476482
        ],
        "D": [
            53233906,
            53239025,
            53240632,
            53250831,
            53239012,
            53242704,
            53250969,
            53239158,
            53239278,
            53243068,
            53249440,
            53254093,
            53239872,
            53249862,
            53242480,
            53247260,
            53236086,
            53237628,
            53240315
        ],
        "B": [
            53229253,
            53234506,
            53230572,
            53231304,
            53231144,
            53231405,
            53233565,
            53231636,
            53233110,
            53231852,
            53233634,
            53233426,
            53232376,
            53236011,
            53235559,
            53230731,
            53230129,
            53231640,
            53230247
        ],
        "A": [
            53226242,
            53226637,
            53226146,
            53227612,
            53226534,
            53227116,
            53228309,
            53228363,
            53226234,
            53226947,
            53228169,
            53229011,
            53227021,
            53226493,
            53226176,
            53226318,
            53226306,
            53226785
        ],
        "F2": [
            53255434,
            139447309
        ],
        "F1": [
            53255396
        ]
    },
    "name": "A. Neko Finds Grapes",
    "statement": "On a random day, Neko found n treasure chests and m keys. The i-th chest\r\nhas an integer a_i written on it and the j-th key has an integer b_j on\r\nit. Neko knows those chests contain the powerful mysterious green\r\nGrapes, thus Neko wants to open as many treasure chests as possible.The\r\nj-th key can be used to unlock the i-th chest if and only if the sum of\r\nthe key number and the chest number is an odd number. Formally, a_i +\r\nb_j\r\nequiv 1\r\npmod{2}. One key can be used to open at most one chest, and one chest\r\ncan be opened at most once.Find the maximum number of chests Neko can\r\nopen.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000003 \n#define N 100005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nint main() {\n\n\tint n,m;\n\n\tint cnt[2][2]={0};\n\n\tscanf(\"%d %d\",&n,&m);\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tint x;\n\n\t\tscanf(\"%d\",&x);\n\n\t\tcnt[0][x%2]++;\n\n\t}\n\n\tfor(int i=1;i<=m;i++) {\n\n\t\tint x;\n\n\t\tscanf(\"%d\",&x);\n\n\t\tcnt[1][x%2]++;\n\n\t}\n\n\tprintf(\"%d\",min(cnt[0][0],cnt[1][1])+min(cnt[0][1],cnt[1][0]));\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Neko Finds Grapes.json",
    "editorial_link": "https://codeforces.com/blog/entry/66696",
    "editorial": "The most important observation is that: Key with odd id can only be used\r\nto unlock chest with even id Key with even id can only be used to unlock\r\nchest with odd id Let: be the number of chests with even and odd id,\r\nrespectively be the number of keys with even and odd id, respectively\r\nWith even-id chests and odd-id keys, you can unlock at most chests.With\r\nodd-id chests and even-id keys, you can unlock at most chests.Therefore,\r\nthe final answer is .Complexity:\r\n",
    "hint": []
}