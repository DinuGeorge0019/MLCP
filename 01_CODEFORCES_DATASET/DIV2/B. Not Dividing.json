{
    "link": "https://codeforces.com//contest/1794/problem/B",
    "problemId": "1808456",
    "problem_idx": "B",
    "shortId": "1794B",
    "contest_number": "1794",
    "problem_submissions": {
        "E": [
            196467319,
            196091024,
            196065447,
            196027516,
            196045507,
            196044539,
            196049784,
            196043653,
            196050334,
            196053527,
            196054181,
            196051837,
            196052921,
            196053608,
            196051434,
            196129108,
            196055320,
            196058590,
            196049523,
            196042891,
            196053778,
            196054545,
            196037576,
            196074501,
            196074391
        ],
        "D": [
            196083505,
            196016109,
            196024909,
            196024858,
            196021434,
            196025217,
            196028904,
            196025001,
            196032867,
            196029336,
            196033933,
            196031399,
            196038559,
            196037652,
            196048488,
            196050480,
            196036074,
            196036926,
            208633215,
            196022650
        ],
        "C": [
            196008950,
            196011685,
            196013987,
            196009207,
            196010114,
            196018308,
            196011596,
            196011705,
            196015187,
            196016689,
            196011713,
            196018563,
            196020776,
            196010830,
            196012003,
            196018106,
            196018224,
            196016136,
            196008531
        ],
        "B": [
            196004154,
            196004594,
            196009639,
            196005082,
            196031084,
            196004622,
            196004148,
            196006017,
            196007935,
            196006213,
            196009047,
            196004027,
            196017820,
            196010698,
            196013843,
            196006494,
            196003310,
            196003871
        ],
        "A": [
            196003031,
            196003363,
            196007521,
            196004024,
            196002777,
            196003379,
            196002990,
            196004171,
            196003805,
            196004167,
            196007050,
            196002947,
            196003739,
            196007194,
            196008753,
            196020821,
            196002700,
            196002959
        ]
    },
    "name": "B. Not Dividing",
    "statement": "You are given an array of n positive integers a_1, a_2,\r\nldots, a_n. In one operation, you can choose any number of the array and\r\nadd 1 to it. Make at most 2n operations so that the array satisfies the\r\nfollowing property: a_{i+1} is divisible by a_i, for each i = 1, 2,\r\nldots, n-1. You do need to minimize the number of operations.\r\n",
    "solutions": [
        "#include <iostream>\nusing namespace std;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nstring read_s() {\n  string s;\n  char c = getchar();\n  while (isspace(c))\n    c = getchar();\n  while (c != EOF && !isspace(c))\n    s += c, c = getchar();\n  return s;\n}\n\nint main() {\n  int t = read();\n  while (t--) {\n    int n = read();\n    static int a[10000];\n    for (int i = 0; i < n; i++) {\n      a[i] = read();\n      if (a[i] == 1)\n        a[i]++;\n    }\n    for (int i = 1; i < n; i++)\n      if (a[i] % a[i - 1] == 0)\n        a[i]++;\n    for (int i = 0; i < n; i++)\n      printf(\"%d \", a[i]);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Not Dividing.json",
    "editorial_link": "https://codeforces.com//blog/entry/113500",
    "editorial": "First, we add one to all the numbers in the array equal to . This uses\r\nat most operations. Then, we iterate through the elements of the array\r\nfrom left to right, starting from the second element. At each step, let\r\nbe the element we are iterating. If is divisible by , we add one to .\r\nNow this element is not divisible by , because otherwise both and are\r\ndivisible by , but that means is also divisible by which cannot happen\r\nsince all the elements in the array are at least (because of the first\r\nstep we did). This part also uses at most operations, so we used at most\r\noperations in total. The resulting array will satisfy the statement\r\nproperty.Intended complexity: per test case.\r\n",
    "hint": []
}