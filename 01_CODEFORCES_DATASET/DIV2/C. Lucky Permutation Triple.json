{"link": "https://codeforces.com//contest/304/problem/C", "problemId": "2990", "problem_idx": "C", "shortId": "304C", "contest_number": "304", "problem_submissions": {"E": [3710988, 3969346, 3717245], "C": [3707907, 3707880, 3707375, 3708064, 3708230, 3707930, 3708271, 3707829, 3708408, 3708102, 3708024, 3708702, 3708560, 3707747, 3708435, 3708042, 3709902, 3708391], "B": [3707009, 3706928, 3706552, 3707725, 3706556, 3707415, 3707167, 3707382, 3707745, 3707406, 3707596, 3710142, 3707441, 3707495, 3707044], "A": [3706218, 3706352, 3706086, 3706215, 3706825, 3706168, 3706228, 3706531, 3706529, 3706177, 3706714, 3706908, 3972383, 3972353, 3972349, 3972342, 3706303, 3706339, 3707915, 3706673, 3706201, 3706866], "D": [3709528, 3708826, 3709122, 3710924, 3709477, 3709474, 3709569, 3709435, 3709766, 3709473, 3709794, 3709959, 3709120, 3710109, 3709844, 3709284, 3710737]}, "name": "C. Lucky Permutation Triple", "statement": "Bike is interested in permutations. A permutation of length is an\r\ninteger sequence such that each integer from 0 to appears exactly once\r\nin it. For example, is a permutation of length 3 while both and is not.A\r\npermutation triple of permutations of length is called a Lucky\r\nPermutation Triple if and only if . The sign denotes the -th element of\r\npermutation . The modular equality described above denotes that the\r\nremainders after dividing by and dividing by are equal.Now, he has an\r\ninteger and wants to find a Lucky Permutation Triple. Could you please\r\nhelp him?\r\n", "solutions": ["#include<cstdio>\n#include<cstring>\n#define MaxN 10010\nusing namespace std;\nint N;\nint stack[MaxN];\nbool Used[MaxN],vis[MaxN],flag;\nvoid Dfs(int now){\n    if(now>=N){\n        flag=1;\n        for(int i=0;i<N;++i)\n            printf(\"%d \",i);\n        puts(\"\");\n        for(int i=0;i<N;++i)\n            printf(\"%d \",stack[i]);\n        puts(\"\");\n        for(int i=0;i<N;++i)\n            printf(\"%d \",(i+stack[i])%N);\n        puts(\"\");\n        return;\n    }\n    for(int i=0;i<N;++i)\n        if(!vis[i]){\n            if(!Used[(now+i)%N]){\n                vis[i]=1;\n                Used[(now+i)%N]=1;\n                stack[now]=i;\n                Dfs(now+1);\n                vis[i]=0;\n                Used[(now+i)%N]=1;\n                if(flag)\n                    return;\n            }\n        }\n}\nint main(){\n    int i,j;\n    scanf(\"%d\",&N);\n    if(N&1){\n        for(i=0;i<N;++i)\n            printf(\"%d \",i);\n        puts(\"\");\n        for(i=0;i<N;++i)\n            printf(\"%d \",i);\n        puts(\"\");\n        for(i=0;i<N;++i)\n            printf(\"%d \",(i+i)%N);\n        puts(\"\");\n    }\n    else{\n        puts(\"-1\");\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1300", "interactive": false}