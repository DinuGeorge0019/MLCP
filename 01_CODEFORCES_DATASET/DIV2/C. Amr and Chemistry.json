{
    "link": "https://codeforces.com//contest/558/problem/C",
    "problemId": "31488",
    "problem_idx": "C",
    "shortId": "558C",
    "contest_number": "558",
    "problem_submissions": {
        "D": [
            12060370,
            12056527,
            12059090,
            12059491,
            12059065,
            12054778,
            12056387,
            12055925,
            12063869,
            12072214
        ],
        "C": [
            12053633,
            12055512,
            12048548,
            12064102,
            12052329,
            12052749,
            12048409,
            12055315,
            12050109,
            12052282,
            12069418,
            12069387,
            12050188,
            12050328,
            12050475,
            12050277
        ],
        "B": [
            12048746,
            12050659,
            12043934,
            12044434,
            12044575,
            12045422,
            12043956,
            12057039,
            12045386,
            12043738,
            12048369,
            12046762,
            12054080,
            12044823,
            12046619,
            12044825,
            12045463,
            12046006,
            12046134
        ],
        "A": [
            12047744,
            12049996,
            12057160,
            12043771,
            12049018,
            12043976,
            12045019,
            12057924,
            12043847,
            12045136,
            12045173,
            12044161,
            12052769,
            12050459,
            12044438,
            12043911,
            12044045,
            12043813,
            12044484
        ],
        "E": [
            12046569,
            12048494,
            12053809,
            12056713,
            12054492,
            12054844,
            12048063,
            12064379,
            12046497,
            12054488,
            12050859,
            12055637,
            12056916,
            12071603
        ]
    },
    "name": "C. Amr and Chemistry",
    "statement": "Amr loves Chemistry, and specially doing experiments. He is preparing\r\nfor a new interesting experiment.Amr has different types of chemicals.\r\nEach chemical has an initial volume of liters. For this experiment, Amr\r\nhas to mix all the chemicals together, but all the chemicals volumes\r\nmust be equal first. So his task is to make all the chemicals volumes\r\nequal.To do this, Amr can do two different kind of operations. Choose\r\nsome chemical and double its current volume so the new volume will be\r\nChoose some chemical and divide its volume by two (integer division) so\r\nthe new volume will be Suppose that each chemical is contained in a\r\nvessel of infinite volume. Now Amr wonders what is the minimum number of\r\noperations required to make all the chemicals volumes equal?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << \" --> \" << (x) << ' '\n#define dbg(x) cerr << (#x) << \" --> \" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl '\\n'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\nint i, j, k, n, m, a[N], x, y, h[N], temp, t, tt, c;\n\npii b[N];\n\nint main(){\n    \n    scanf(\"%d\",&n);\n\n    FOR(i,1,n) {\n        scanf(\"%d\",&a[i]);\n    \n    }\n\n    memset(h, -1, sizeof h);\n   \n    int t = a[1], ans = inf;\n    \n    vector< int > v;\n    \n    FOR(i,1,n) {\n        \n        v.clear();\n        \n        t = a[i], c = 0;\n        \n        while(1) {\n                    \n            temp = c;\n            \n            if(t == 0) {\n                h[0] = c;\n                v.pb(0);\n                break;\n            }\n               \n               \n            tt = t;\n                    \n            while(tt < 500000) {\n                if(h[tt] != -1 && h[tt] > temp) h[tt] = temp;\n               // else if(h[tt] != -1) break;\n                else if(h[tt] == -1){ h[tt] = temp; v.pb(tt); }\n                tt *= 2; temp++;\n            } c++; t /= 2; \n         \n        }\n        \n        foreach(it, v) {\n            b[*it].st++;b[*it].nd += h[*it];\n            h[*it] = -1;\n        }\n      }\n    \n    FOR(i,0,N-1) if(b[i].st == n) { ans = min(ans, b[i].nd); } \n    \n    cout << ans << endl;\n\n   return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "greedy",
        "math",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Amr and Chemistry.json",
    "editorial_link": "https://codeforces.com//blog/entry/19212",
    "editorial": "Let the maximum number in the array be . Clearly, changing the elements\r\nof the array to any element larger than wonât be optimal, because the\r\nlast operation is for sure multiplying all the elements of the array by\r\ntwo. And not doing this operation is of course a better answer. Now we\r\nwant to count the maximum number of distinct elements that can be\r\nreached from some element that are not larger than . Consider an element\r\nthat has a zero in the first bit of its binary representation. If we\r\ndivided the number by two and the multiplied it by two we will get the\r\noriginal number again. But if it has a one, the resulting number will be\r\ndifferent. So, for counting the maximum number of distinct elements we\r\nwill assume where has only ones in its binary representation. From we\r\ncan only reach elements that have a prefix of ones in its binary\r\nrepresentation, and the other bits zeros (e.g. ). Letâs assume has bits\r\nin its binary representation, then can reach exactly distinct elements.\r\nSo, from each element in the array we can reach at most elements. So,\r\nLetâs generate the numbers that can be reached from each element using\r\nbfs to get minimum number of operations. And between all the numbers\r\nthat are reachable from all the elements letâs minimize the total number\r\nof operations. Time complexity: Implementation\r\n",
    "hint": []
}