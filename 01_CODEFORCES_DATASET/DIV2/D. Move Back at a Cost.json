{
    "link": "https://codeforces.com//contest/2047/problem/D",
    "problemId": "3064636",
    "problem_idx": "D",
    "shortId": "2047D",
    "contest_number": "2047",
    "problem_submissions": {
        "F": [
            294576018
        ],
        "D": [
            294556181,
            294550999,
            294551362,
            294549113,
            294552457,
            294549132,
            294545443,
            294545413,
            294553157,
            294554253,
            294547704,
            294545194,
            294551491,
            294546981,
            294545215,
            294554235,
            294551596,
            294555080,
            294553722
        ],
        "E": [
            294553658,
            294561058,
            294564356,
            294560884,
            294607752,
            294607657,
            294607423,
            294566840,
            294564602,
            294566710,
            294567902,
            294566502,
            294566942,
            294570129,
            294573472,
            294575252,
            294574930,
            294577351,
            294571682,
            294573929,
            294572766,
            294572872
        ],
        "C": [
            294537935,
            294544794,
            294543033,
            294543024,
            294539849,
            294544621,
            294540793,
            294540644,
            294546521,
            294548997,
            294552751,
            294541180,
            294538453,
            294540477,
            294539426,
            294541750,
            294543785,
            294533886,
            294545247
        ],
        "B": [
            294536414,
            294542160,
            294535717,
            294539853,
            294536380,
            294540106,
            294537951,
            294533781,
            294538848,
            294537306,
            294538421,
            294536540,
            294535134,
            294536248,
            294536341,
            294535891,
            294535533,
            294543631,
            294541462
        ],
        "A": [
            294533410,
            294535816,
            294532913,
            294532916,
            294533402,
            294535536,
            294533238,
            294535567,
            294533545,
            294533451,
            294534370,
            294533884,
            294532708,
            294533038,
            294533136,
            294533187,
            294540270,
            294536728,
            294532860
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136908",
    "editorial": "The first idea is to notice, that each element is moved to the back at most once. Indeed, if we fix a subset of elements that we ever move to the back, we can perform the operation once on each of them in any order we like, and that becomes their final order with the smallest possible increase. The optimal order is, of course, the increasing order. The question is how to select this subset of elements to move to the back.\n\nSince we need the lexicographically smallest array, we're looking for some greedy approach that chooses the smallest possible element on the next position one by one, left to right.\n\nWhat's the smallest number our resulting array can start with? Of course, the minimum. That means, all the elements in front of the minimum have to be moved to the back and be increased by one.\nWhat's the smallest number we can have on the second place, given that we have the minimum in the first positions? Either the smallest element to the right of the minimum, or the smallest element among those already moved to the back.\n...\nAnalysing this approach, we see that as we go left to right, we keep picking elements from the suffix minima sequence, and keep growing the set of elements we have to move to the right to ''extract'' this sequence from the initial array. At one point, the next smallest element comes not from the suffix minima sequence, but from the pile of integers we move to the right. At this point, all the remaining elements have to be moved to the right once (that is, increased by 1\n), and then listed in sorted order.\n\nSo, the answer is always several first elements of the suffix minima sequence, starting from the global minimum, and then all other elements, increased by 1\n and sorted in increased order. To find the point where we switch from the suffix minima sequence to the moved elements, it is convenient to precomute the minima, and keep a set of those elements we already move to the right.",
    "name": "D. Move Back at a Cost",
    "statement": "You are given an array of integers a of length n. You can perform the\r\nfollowing operation zero or more times: In one operation choose an index\r\ni (1\r\nle i\r\nle n), assign a_i := a_i + 1, and then move a_i to the back of the array\r\n(to the rightmost position). For example, if a = [3, 5, 1, 9], and you\r\nchoose i = 2, the array becomes [3, 1, 9, 6]. Find the lexicographically\r\nsmallest^{\r\ntext{ }} array you can get by performing these operations.^{\r\ntext{ }}An array c is lexicographically smaller than an array d if and\r\nonly if one of the following holds: c is a prefix of d, but c\r\nne d; or in the first position where c and d differ, the array c has a\r\nsmaller element than the corresponding element in d.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"-Ofast\",\"-funroll-all-loops\",\"-ffast-math\")#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")//#pragma GCC target(\"avx,avx2,sse,sse2,sse3,ssse3,sse4,abm,popcnt,mmx\")#include <bits/stdc++.h>using namespace std;#define endl '\\n' mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());mt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count()); int rnd(int a, int b) {\treturn rng() % (b - a + 1) + a;} string to_string(string s) { return s; }template <typename T> string to_string(T v) {  bool first = true;  string res = \"[\";  for (const auto &x : v) {    if (!first)      res += \", \";    first = false;    res += to_string(x);  }  res += \"]\";  return res;} void dbg_out() { cerr << endl; }template <typename Head, typename... Tail> void dbg_out(Head H, Tail... T) {  cerr << ' ' << to_string(H);  dbg_out(T...);} #define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__) template<class T> inline void chkmin(T& x, T y) { if (y < x) x = y; }template<class T> inline void chkmax(T& x, T y) { if (y > x) x = y; } using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; const i64 INF = 1e18;const int oo = 1e9;const int mod = 1e9 + 7;const int MX = 200005;const int inf = 1e9; int a[MX], b[MX], vis[MX];void solve() {\tint n;\tcin >> n;\tfor (int i = 0; i < n; i ++) cin >> a[i];\tfor (int i = 0; i < n; i ++) b[i] = a[i];\tsort(b, b + n);\tint tot = 0;\tfor (int i = 0; i < n; i ++) vis[i] = 0;\tint id = -1;\tfor (int i = 0; i < n; i ++) {\t\tif (a[i] == b[tot]) {\t\t\tvis[i] = 1;\t\t\ttot ++;\t\t\tid = i;\t\t}\t}\tif (tot == n) {\t\tfor (int i = 0; i < n; i ++) cout << a[i] << \" \";\t\tcout << endl;\t\treturn;\t}\tfor (int i = id + 1; i < n; i ++) {\t\tif (a[i] == b[tot] + 1) {\t\t\tvis[i] = 1;\t\t}\t}\tfor (int i = 0; i < n; i ++) if (!vis[i]) a[i] ++;\tsort(a, a + n);\tfor (int i = 0; i < n; i ++) cout << a[i] << \" \";\tcout << endl;} int main() {#ifndef ONLINE_JUDGE\tfreopen(\"in.txt\", \"r\", stdin);#endif \tios::sync_with_stdio(0);\tcin.tie(0); cout.tie(0); \tint Tc = 1;\tcin >> Tc;\twhile (Tc --) {\t\tsolve();\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Move Back at a Cost.json",
    "hint": []
}