{
    "link": "https://codeforces.com//contest/1131/problem/E",
    "problemId": "302312",
    "problem_idx": "E",
    "shortId": "1131E",
    "contest_number": "1131",
    "problem_submissions": {
        "G": [
            50392574,
            50483553,
            50483191,
            50597351
        ],
        "E": [
            50370230,
            50377398,
            50376874,
            50374805,
            50370023,
            50374639,
            50376085,
            50370141,
            59337133,
            50372624,
            50376988,
            50380444,
            51393637,
            50379092,
            50379324,
            50375235,
            50378370,
            50376960,
            50378218,
            50375618,
            50380739,
            50377794
        ],
        "D": [
            50363533,
            50363627,
            50365255,
            50374692,
            50360365,
            50367830,
            50371553,
            50364690,
            59336364,
            50377671,
            50371391,
            50369645,
            51393629,
            50371580,
            50368694,
            50364122,
            50370641,
            50367474,
            50370633,
            50364697,
            50370324,
            50391827,
            50367431
        ],
        "F": [
            50359710,
            50366576,
            50362359,
            50363609,
            50372028,
            50364108,
            54391189,
            54391158,
            54391141,
            50775614,
            50775596,
            50775586,
            50775566,
            50775556,
            50366322,
            50374409,
            59338739,
            50364318,
            50366547,
            50364869,
            51393655,
            50365763,
            50362358,
            50366172,
            50366229,
            50370184,
            50365915,
            50363686,
            50365490,
            50370524
        ],
        "C": [
            50357039,
            50359567,
            50360582,
            50355123,
            50364439,
            50361693,
            50361183,
            50360745,
            50361372,
            50363542,
            50360374,
            50363293,
            50355730,
            50368491,
            50363309,
            50362385,
            50362421,
            50365348,
            50362731,
            50360623
        ],
        "B": [
            50355578,
            50356862,
            50357573,
            50357717,
            50364015,
            50361039,
            50356264,
            50358549,
            50359269,
            50359561,
            50357291,
            50358021,
            50372318,
            50359218,
            50357829,
            50359757,
            50364553,
            50364635,
            50358492,
            50357639
        ],
        "A": [
            50354897,
            50355112,
            50355078,
            50360224,
            50354946,
            50354851,
            50362936,
            50355762,
            50355563,
            50355186,
            50355036,
            50355259,
            50369979,
            50355032,
            50355231,
            50355565,
            50355478,
            50359515,
            50355346,
            50355260
        ]
    },
    "name": "E. String Multiplication",
    "statement": "Roman and Denis are on the trip to the programming competition. Since\r\nthe trip was long, they soon got bored, and hence decided to came up\r\nwith something. Roman invented a pizza’s recipe, while Denis invented a\r\nstring multiplication. According to Denis, the result of multiplication\r\n(product) of strings s of length m and t is a string t + s_1 + t + s_2 +\r\nldots + t + s_m + t, where s_i denotes the i-th symbol of the string s,\r\nand \"\" denotes string concatenation. For example, the product of strings\r\n\"\" and \"\" is a string \"\", while the product of the strings \"\" and \"\" is\r\na string \"\". Note, that unlike the numbers multiplication, the product\r\nof strings s and t is not necessarily equal to product of t and s.Roman\r\nwas jealous of Denis, since he invented such a cool operation, and hence\r\ndecided to invent something string-related too. Since Roman is\r\nbeauty-lover, he decided to define the of the string as the length of\r\nthe longest substring, consisting of only one letter. For example, the\r\nbeauty of the string \"\" is equal to 3, since there is a substring \"\",\r\nwhile the beauty of the string \"\" is equal to 1, since all neighboring\r\nsymbols in it are different.In order to entertain Roman, Denis wrote\r\ndown n strings p_1, p_2, p_3,\r\nldots, p_n on the paper and asked him to calculate the beauty of the\r\nstring (\r\nldots (((p_1\r\ncdot p_2)\r\ncdot p_3)\r\ncdot\r\nldots )\r\ncdot p_n, where s\r\ncdot t denotes a multiplication of strings s and t. Roman hasn’t fully\r\nrealized how Denis’s multiplication works, so he asked you for a help.\r\nDenis knows, that Roman is very impressionable, he guarantees, that the\r\nbeauty of the resulting string is at most 10^9.\r\n",
    "solutions": [
        "/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,\"r\",stdin);\n#define fpo(x) freopen(x,\"w\",stdout);\n#define fprio fpi(\"in.txt\");fpo(\"out.txt\");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==' ');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes(\"\");}\ninline void writei(int x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n//#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<\"No\";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 1000000000\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nint n,m,i,j,mx=1;\nstring st[100005];\nchar ss[100005];\nstruct nd\n{\n\tint sl,sr,sc,sum;\n\tchar cl,cr;\n}f,g,h;\nnd add(nd x,nd y)\n{\n\tnd ans;\n\tans.sum=min(x.sum+y.sum,inf);\n\tans.cl=x.cl;ans.cr=y.cr;\n\tif (x.sl==x.sum&&x.cl==y.cl) ans.sl=x.sum+y.sl; else ans.sl=x.sl;\n\tif (y.sr==y.sum&&x.cr==y.cr) ans.sr=y.sum+x.sr; else ans.sr=y.sr;\n\tans.sc=max(x.sc,y.sc);\n\tif (x.cr==y.cl) ans.sc=max(ans.sc,x.sr+y.sl);\n\tans.sl=min(ans.sl,inf);\n\tans.sr=min(ans.sr,inf);\n\tans.sc=min(ans.sc,inf);\n\tmx=max(mx,ans.sc);\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n)\n\t{\n\t\tscanf(\" %s\",ss);\n\t\tst[i]=ss;\n\t}\n\tfor (i=0;i<st[n].size();i++) if (st[n][i]!=st[n][0]) break;\n\tf.sl=i;\n\tint len=st[n].size()-1;\n\tfor (i=len;i>=0;i--)\n\t{\n\t\tif (st[n][i]!=st[n][len]) break;\n\t}\n\tf.sr=len-i;\n\tint sss=0;\n\tfor (i=0;i<st[n].size();i++)\n\t{\n\t\tif (i&&st[n][i]!=st[n][i-1])\n\t\t{\n\t\t\tsss=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsss++;\n\t\t}\n\t\tf.sc=max(f.sc,sss);\n\t}\n\tf.sum=st[n].size();\n\tf.cl=st[n][0];\n\tf.cr=st[n][len];\n\tmx=max(mx,f.sc);\n\trepd(i,n-1)\n\t{\n\t\th=f;\n\t\tfor (j=0;j<st[i].size();j++)\n\t\t{\n\t\t\tg=(nd){1,1,1,1,st[i][j],st[i][j]};\n\t\t\th=add(add(h,g),f);\n\t\t}\n\t\tf=h;\n\t}\n\tcout<<mx<<endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. String Multiplication.json",
    "editorial_link": "https://codeforces.com//blog/entry/65487",
    "editorial": "Letâs notice, that the string multiplication is associative, that is .\r\nSo instead of left \"\" given in statement, letâs use \"\" That is, we have\r\n, then go to , then and so on.One can also solve the problem without\r\nobserving the associativity property and going with and so on. However\r\nthere is one caveat. Since the string grows very fast, \"an answer\" will\r\ngrow as well.And while you are promised that the answer is at most ,\r\nobserve the following situtation: are \"\", which makes an answer quite\r\nlarge, but if you add a equal to \"\" it collides to a mere , so it\r\nrequires some careful handling, basically store for every value you want\r\nvalue . Going in another direction has an advantage, that if some value\r\nis large it will stay large for life, so since answer is no overflows\r\nwill happen.Now back to the suggested solution. Letâs proceed as and so\r\non.Note, that itâs enough to store not whole the current string , but\r\njust some basic information about. Letâs simply store: The length of the\r\nlargest substring of a single character Whether the string consists of\r\nthe single character or not The left and the right character of it The\r\nlength of the prefix, which consists of a single character and the same\r\nfor the suffix. Itâs easy to see that if you know such values for some\r\nstring , you can also compute it for (here, the brackets are assumed as\r\nin ).\r\n",
    "hint": []
}