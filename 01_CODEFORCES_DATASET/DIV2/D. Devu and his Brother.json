{
    "link": "https://codeforces.com//contest/439/problem/D",
    "problemId": "10097",
    "problem_idx": "D",
    "shortId": "439D",
    "contest_number": "439",
    "problem_submissions": {
        "D": [
            6805901,
            6804419,
            6803200,
            6805988,
            6804881,
            6805810,
            6805384,
            6806017,
            6807497,
            6805650,
            6808014,
            6804059,
            6806158,
            6805574,
            6805399,
            6806326,
            6804741,
            6806396,
            6808041
        ],
        "E": [
            6803795,
            6806475,
            6805122,
            6808945,
            6805874,
            6808804,
            6804029,
            6812447,
            6809672,
            6805934,
            7363028
        ],
        "C": [
            6800932,
            6800886,
            6803463,
            6802772,
            6807376,
            6802931,
            6803473,
            6802763,
            6804861,
            6803810,
            6804665,
            6808359,
            6803941,
            6812392,
            6803612,
            6803230
        ],
        "B": [
            6798509,
            6800129,
            6798401,
            6799435,
            6798872,
            6811724,
            6799339,
            6807876,
            6800630,
            6798132,
            6800776,
            6807661,
            6800880,
            6806303,
            6802646,
            6801021,
            6799365,
            6798816,
            6798888
        ],
        "A": [
            6798027,
            6801375,
            6797956,
            6798638,
            6798087,
            6798192,
            6808386,
            6799422,
            6799363,
            6798034,
            6798516,
            6806347,
            6798287,
            6808882,
            6801124,
            6798895,
            6798307,
            6798019,
            6798088
        ]
    },
    "name": "D. Devu and his Brother",
    "statement": "Devu and his brother love each other a lot. As they are super geeks,\r\nthey only like to play with arrays. They are given two arrays and by\r\ntheir father. The array is given to Devu and to his brother. As Devu is\r\nreally a naughty kid, he wants the minimum value of his array should be\r\nat least as much as the maximum value of his brother’s array . Now you\r\nhave to help Devu in achieving this condition. You can perform multiple\r\noperations on the arrays. In a single operation, you are allowed to\r\ndecrease or increase any element of any of the arrays by 1. Note that\r\nyou are allowed to apply the operation on any index of the array\r\nmultiple times.You need to find minimum number of operations required to\r\nsatisfy Devu’s condition so that the brothers can play peacefully\r\nwithout fighting.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<\"OK\";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 100100\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(\"a.in\");\nofstream g(\"a.out\");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nint a[N],b[N],p1,p2,n,m,val;\nll Sa[N],Sb[N],Ra[N],Rb[N],best,cost;\nint cbs(int val)\n{\n    int st=1,dr=n,mij,sol=0;\n    while(st<=dr)\n    {\n        mij=(st+dr)>>1;\n        if(a[mij]<=val)\n        {\n            sol=mij;\n            st=mij+1;\n        }\n        else\n            dr=mij-1;\n    }\n    return sol;\n}\nint cbd(int val)\n{\n    int st=1,dr=m,mij,sol=n+1;\n    while(st<=dr)\n    {\n        mij=(st+dr)>>1;\n        if(b[mij]>=val)\n        {\n            dr=mij-1;\n            sol=mij;\n        }\n        else\n            st=mij+1;\n    }\n    return sol;\n}\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(\"a.in\",\"r\",stdin);\n    freopen(\"a.out\",\"w\",stdout);\n    #endif\n    \n    f>>n>>m;\n    FOR(i,1,n)\n    f>>a[i];\n    FOR(i,1,m)\n    f>>b[i];\n    sort(a+1,a+n+1);\n    sort(b+1,b+m+1);\n    FOR(i,1,n)\n    {\n        Sa[i]=Sa[i-1]+a[i];\n    }\n    FOR(i,1,m)\n    {\n        Sb[i]=Sb[i-1]+b[i];\n    }\n    ROF(i,n,1)\n    {\n        Ra[i]=Ra[i+1]+a[i];\n    }\n    ROF(i,m,1)\n    {\n        Rb[i]=Rb[i+1]+b[i];\n    }\n    best=inf;\n    if(b[m]<=a[1])\n    {\n        g<<\"0\";\n        return 0;\n    }\n    FOR(i,1,n)\n    {\n        val=a[i];\n        p1=cbd(val);\n        p2=cbs(val);\n        cost=Rb[p1]-1LL*(m-p1+1)*a[i];\n        cost+=1LL*p2*a[i]-Sa[p2];\n        if(cost<best)\n            best=cost;\n    }\n    FOR(i,1,m)\n    {\n        val=b[i];\n        p1=cbd(val);\n        p2=cbs(val);\n        cost=Rb[p1]-1LL*(m-p1+1)*b[i];\n        cost+=1LL*p2*b[i]-Sa[p2];\n        if(cost<best)\n            best=cost;\n    }\n    g<<best;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "sortings",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Devu and his Brother.json",
    "editorial_link": "https://codeforces.com//blog/entry/12545",
    "editorial": "You can solve the problem in two ways. Let us define a function f.\r\nFunction f(k) = cost needed to make array a elements k + cost needed to\r\nmake array b elements k Instead of proving it formally, try checking the\r\nproperty on many random test cases. You will realize that f is convex.\r\nClaim: f is convex: Proof: It is fairly easy to prove. See the\r\nderivative of f. = ( of elements of b > k) + ( of elements of a < k) The\r\nfirst term (without sign) can only decrease as k increases whereas\r\nsecond term can only increase as k increases. So, All the extremum\r\npoints will lie in the elements from the any of the arrays because f is\r\nconvex and at the event points (or the points of array a and b). For\r\nlearning more about ternary search, you can see following topcoder\r\ndiscussion Another smart solution Please see following comment of goovie\r\nand proof is given in the reply by himank Solutions Code\r\n",
    "hint": []
}