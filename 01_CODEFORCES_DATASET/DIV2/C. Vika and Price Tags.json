{
    "link": "https://codeforces.com//contest/1848/problem/C",
    "problemId": "2046240",
    "problem_idx": "C",
    "shortId": "1848C",
    "contest_number": "1848",
    "problem_submissions": {
        "E": [
            214078806,
            214088202,
            214079632,
            214087057,
            214086323,
            214083544,
            214090057,
            214082643,
            214094277,
            214095285,
            214705225
        ],
        "F": [
            214070984,
            214075949,
            214084495,
            214080175,
            214065714,
            214087986,
            214082128,
            214076389,
            214084949,
            214073421,
            214060099,
            214088437,
            214086968,
            214091347,
            214089467,
            214079366
        ],
        "D": [
            214068277,
            214064922,
            214070767,
            214068735,
            214079075,
            214069131,
            214069700,
            214066329,
            214075678,
            214084591,
            214097754,
            214075100,
            214072308,
            214074287,
            214061875,
            214091346
        ],
        "C": [
            214056697,
            214056251,
            214061525,
            214059146,
            214071785,
            214061591,
            214056000,
            214073174,
            214063820,
            214060194,
            214078312,
            214056865,
            214065402,
            214062471,
            214092811,
            214062217
        ],
        "B": [
            214052297,
            214051762,
            214052731,
            214053122,
            214056975,
            214052187,
            214052073,
            214064615,
            214054312,
            214052430,
            214052268,
            214050368,
            214053885,
            214053048,
            214051754,
            214051131
        ],
        "A": [
            214049674,
            214048967,
            214049923,
            214049713,
            214052070,
            214049845,
            214048850,
            214050906,
            214049091,
            214049973,
            214049534,
            214049002,
            214049762,
            214049567,
            214049272,
            214049415
        ]
    },
    "name": "C. Vika and Price Tags",
    "statement": "Vika came to her favorite cosmetics store \"Golden Pear\". She noticed\r\nthat the prices of n items have changed since her last visit.She decided\r\nto analyze how much the prices have changed and calculated the\r\ndifference between the old and new prices for each of the n items.Vika\r\nenjoyed calculating the price differences and decided to continue this\r\nprocess.Let the old prices be represented as an array of non-negative\r\nintegers a, and the new prices as an array of non-negative integers b.\r\nBoth arrays have the same length n.In one operation, Vika constructs a\r\nnew array c according to the following principle: c_i = |a_i - b_i|.\r\nThen, array c renamed into array b, and array b renamed into array a at\r\nthe same time, after which Vika repeats the operation with them.For\r\nexample, if a = [1, 2, 3, 4, 5, 6, 7]; b = [7, 6, 5, 4, 3, 2, 1], then c\r\n= [6, 4, 2, 0, 2, 4, 6]. Then, a = [7, 6, 5, 4, 3, 2, 1]; b = [6, 4, 2,\r\n0, 2, 4, 6].Vika decided to call a pair of arrays a, b if after some\r\nnumber of such operations all elements of array a become zeros.Output \"\"\r\nif the original pair of arrays is dull, and \"\" otherwise.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int mod = 998244353, N = 100005;\nint n, a[N], b[N];\n\nint solve(int x, int y) {\n    if (x == 0) return 0;\n    if (y == 0) return 1;\n    if (y > x * 2) y = y % (x * 2);\n    return (solve(y, abs(x - y)) + 1) % 3;\n}\n \nvoid frank() {\n    cin >> n;\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    for (int i = 0; i < n; ++i) cin >> b[i];\n    int res = -1;\n    for (int i = 0; i < n; ++i) if (a[i] > 0 || b[i] > 0) {\n        int nw = solve(a[i], b[i]);\n        if (res != -1 && res != nw) {\n            cout << \"NO\\n\";\n            return;\n        }\n        res = nw;\n    }\n    cout << \"YES\\n\";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        frank();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Vika and Price Tags.json",
    "editorial_link": "https://codeforces.com//blog/entry/118333",
    "editorial": "First of all, if and are both zero, then all numbers in the sequence\r\nwill be zero.Otherwise, if one of the numbers is not zero, then if ,\r\nafter one operation, the sum will decrease relative to the original\r\nvalue, or if , after two operations, the sum will also decrease relative\r\nto the original value. Since the sum of non-negative integers cannot\r\ndecrease infinitely, eventually one of the numbers will become zero. Let\r\nthe first such moment occur after operations. Then, notice that now\r\nzeros will alternate with a period of . Therefore, in the problem, we\r\nneed to check that all have the same remainder when divided by . Thus,\r\nthe problem reduces to finding for each pair of non-zero modulo\r\n.Solution 1: Without loss of generality, assume , otherwise apply one\r\noperation. Then, the sequence of numbers will have the form: . Let .\r\nThen, using simple formulas, we can find the first moment when the\r\nneighboring pair of numbers becomes and in some order, and then simply\r\nfind the answer for them. Thus, the problem can be solved using the\r\ngeneralized Euclidean algorithm.Solution 2: We will build the sequence\r\nfrom the end. Let\u00e2\u0080\u0099s find the first moment when we obtain . Before this\r\nzero, there is some number . It can be easily proven that is exactly\r\nequal to . Now, let\u00e2\u0080\u0099s divide each number in the sequence by , and obtain\r\na new sequence of numbers, where the last number is zero and the\r\npenultimate number is . Then, let\u00e2\u0080\u0099s denote even numbers as and odd\r\nnumbers as . In this way, the sequence can be uniquely reconstructed\r\nfrom the end: . Thus, we can determine the remainder modulo by looking\r\nat the pair modulo .The complexity of both solutions will be .\r\n"
}