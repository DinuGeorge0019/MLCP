{
    "link": "https://codeforces.com//contest/250/problem/D",
    "problemId": "2294",
    "problem_idx": "D",
    "shortId": "250D",
    "contest_number": "250",
    "problem_submissions": {
        "D": [
            2661219,
            2661302,
            2661169,
            2662484,
            2661663,
            2661650,
            2663624,
            2661614,
            2662775,
            2662098,
            2661832,
            2662182,
            2662202,
            2662743,
            2662343,
            2662306
        ],
        "E": [
            2660453,
            2662495,
            2662431,
            2662896,
            2662159,
            2663414,
            2662356,
            2666687,
            2663326,
            3224559
        ],
        "C": [
            2659482,
            2660436,
            2660472,
            2658939,
            2660327,
            2660252,
            2659990,
            2660985,
            2659709,
            2660447,
            2660653,
            2678663,
            2660908,
            2661315,
            2660197,
            2661069,
            2661058
        ],
        "B": [
            2659124,
            2659956,
            2659963,
            2660324,
            2659809,
            2659468,
            2659350,
            2660518,
            2660539,
            2659612,
            2660025,
            2660108,
            2659586,
            2659566,
            2660019,
            2659920
        ],
        "A": [
            2658537,
            2658807,
            2658632,
            2658949,
            2658816,
            2658618,
            2658590,
            2658601,
            2658691,
            2658849,
            2658966,
            2659142,
            2658749,
            2658817,
            2659154,
            2658983
        ]
    },
    "name": "D. Building Bridge",
    "statement": "Two villages are separated by a river that flows from the north to the\r\nsouth. The villagers want to build a bridge across the river to make it\r\neasier to move across the villages.The river banks can be assumed to be\r\nvertical straight lines and ().The west village lies in a steppe at\r\npoint . There are pathways leading from the village to the river, they\r\nend at points . The villagers there are plain and simple, so their\r\npathways are straight segments as well.The east village has reserved and\r\ncunning people. Their village is in the forest on the east bank of the\r\nriver, but its exact position is not clear. There are twisted paths\r\nleading from this village to the river and ending at points . The\r\nlengths of all these paths are known, the length of the path that leads\r\nfrom the eastern village to point , equals .The villagers want to choose\r\nexactly one point on the left bank of river , exactly one point on the\r\nright bank and connect them by a straight-line bridge so as to make the\r\ntotal distance between the villages (the sum of , where is the Euclidean\r\ndistance between points and ) were minimum. The Euclidean distance\r\nbetween points and equals .Help them and find the required pair of\r\npoints.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define FOR(it,a) for (__typeof((a).begin()) it=(a).begin();it!=(a).end();++it)\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\ninline int sign(double x)\n{\n    if (x<-eps) return -1;\n    return x>eps;\n}\n\nstruct Tpoint\n{\n    double x,y;\n    int id;\n    Tpoint(){}\n    Tpoint(double x,double y):x(x),y(y){}\n    inline double norm(){return sqrt(x*x+y*y);}\n    inline void rotate(double ang)\n    {\n        double co=cos(ang),si=sin(ang);\n        double tx=x,ty=y;\n        x=tx*co-ty*si;\n        y=tx*si+ty*co;\n    }\n};\n\ninline Tpoint operator +(const Tpoint &a,const Tpoint &b){return Tpoint(a.x+b.x,a.y+b.y);}\ninline Tpoint operator -(const Tpoint &a,const Tpoint &b){return Tpoint(a.x-b.x,a.y-b.y);}\ninline Tpoint operator *(const Tpoint &a,const double &b){return Tpoint(a.x*b,a.y*b);}\ninline Tpoint operator /(const Tpoint &a,const double &b){return Tpoint(a.x/b,a.y/b);}\ninline double det(const Tpoint &a,const Tpoint &b){return a.x*b.y-a.y*b.x;}\ninline double dot(const Tpoint &a,const Tpoint &b){return a.x*b.x+a.y*b.y;}\n//================================\n\nconst int maxn  =   100005;\n\nTpoint p[maxn],q[maxn];\nint best[maxn],ansi,ansj;\ndouble ans,A[maxn],B[maxn];\n\ninline bool byY(const Tpoint &a,const Tpoint &b)\n{\n    return sign(a.y-b.y)<0;\n}\n\ninline void solve(Tpoint p[],int n,Tpoint q[],int m)\n{\n    int last=0,lastp=0;\n    for (int i=1;i<n;++i){\n        int l=last-1,r=m;\n        while (l+1<r){\n            int mid=(l+r)/2;\n            double l1=(p[i]-q[mid]).norm()+A[i];\n            double l2=(p[lastp]-q[mid]).norm()+A[lastp];\n            if (l1+eps<l2){\n                r=mid;\n            }else{\n                l=mid;\n            }\n        }\n        if (r!=m){\n            for (int j=last;j<r;++j){\n                best[j]=lastp;\n            }\n            last=r;\n            lastp=i;\n        }\n    }\n    for (int j=last;j<m;++j){\n        best[j]=lastp;\n    }\n    for (int i=0;i<m;++i){\n        double l=(q[i]-p[best[i]]).norm();\n        l+=A[p[best[i]].id]+B[q[i].id];\n        if (l+eps<ans){\n            ans=l;\n            ansi=p[best[i]].id;\n            ansj=q[i].id;\n        }\n    }\n}\n\nint main()\n{\n    int n,m,a,b;\n    scanf(\"%d%d%d%d\",&n,&m,&a,&b);\n    for (int i=0;i<n;++i){\n        scanf(\"%lf\",&p[i].y);\n        p[i].x=a;\n        p[i].id=i;\n        A[i]=p[i].norm();\n    }\n    for (int i=0;i<m;++i){\n        scanf(\"%lf\",&q[i].y);\n        q[i].x=b;\n        q[i].id=i;\n    }\n    for (int i=0;i<m;++i){\n        scanf(\"%lf\",&B[i]);\n    }\n    \n    sort(p,p+n,byY);\n    sort(q,q+m,byY);\n    \n    ans=1e100;\n    ansi=ansj=-1;\n    solve(p,n,q,m);\n    \n    reverse(p,p+n);\n    reverse(q,q+m);\n    solve(p,n,q,m);\n    \n    printf(\"%d %d\\n\",ansi+1,ansj+1);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Building Bridge.json",
    "editorial_link": "https://codeforces.com//blog/entry/5973",
    "editorial": "Well, let\u00e2\u0080\u0099s fix -th east point (). Now consider how changes total\r\ndistance depending on chosing the west point. The best point is\r\nintersection of lines : , but this point can be not present among all\r\nwest points. You can see that if you will move from point up or down,\r\ntotal distance will increase. So only nearest to points may be\r\nconsidered. You can find that points using binary search. Also you can\r\nobserve that after every increasing of point will move in same\r\ndirection; so you can support nearest points to usins some pointer. The\r\nthird way is using such fact that during moving point over the west bank\r\ntotal distance initially will decrease and then increase; so you can use\r\nternary search here. Considered solutions work in and . Author is\r\nRipatti.\r\n"
}