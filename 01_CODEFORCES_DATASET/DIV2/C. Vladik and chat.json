{
    "link": "https://codeforces.com//contest/754/problem/C",
    "problemId": "88002",
    "problem_idx": "C",
    "shortId": "754C",
    "contest_number": "754",
    "problem_submissions": {
        "C": [
            23598952,
            23602731,
            23600404,
            23598770,
            23595631,
            23604849,
            23604549,
            23600905,
            23597681,
            23600418,
            23605322,
            23605304,
            23598917,
            23597491,
            23604104,
            23598918,
            23606632
        ],
        "D": [
            23593184,
            23593323,
            23595150,
            23595085,
            23598162,
            23593559,
            23596735,
            23599764,
            23604175,
            23599201,
            23597364,
            23604779,
            23603085,
            23598699,
            23605480,
            23605421,
            23600608,
            23604207,
            23599681
        ],
        "B": [
            23588442,
            23588177,
            23589652,
            23588551,
            23588951,
            23588531,
            23591530,
            23589211,
            23589887,
            23588557,
            23594523,
            23590126,
            23593242,
            23593078,
            23590225,
            23588316,
            23588990,
            23589935,
            23595966
        ],
        "A": [
            23587499,
            23595001,
            23587629,
            23607118,
            23587407,
            23587483,
            23589634,
            23587559,
            23587954,
            23587405,
            23587857,
            23587707,
            23599756,
            23587979,
            23587428,
            23587560,
            23588096,
            23590086
        ],
        "E": [
            23607022,
            23650416,
            23650411,
            23650402,
            23621680,
            24024004,
            23676163
        ]
    },
    "name": "C. Vladik and chat",
    "statement": "Recently Vladik discovered a new entertainment coding bots for social\r\nnetworks. He would like to use machine learning in his bots so now he\r\nwant to prepare some learning data for them.At first, he need to\r\ndownload chats. Vladik coded a script which should have downloaded the\r\nchats, however, something went wrong. In particular, some of the\r\nmessages have no information of their sender. It is known that if a\r\nperson sends several messages in a row, they all are merged into a\r\nsingle message. It means that . Moreover, .Vladik wants to recover\r\nsenders of all the messages so that each two neighboring messages will\r\nhave different senders and no sender will mention himself in his\r\nmessages.He has no idea of how to do this, and asks you for help. Help\r\nVladik to recover senders in each of the chats!\r\n",
    "solutions": [
        "//No exams!\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back \n#define MP make_pair\nint Tn,n,m;\nstring name[111];\nchar ss[111];\nstring s;\nbool check(char c){return c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9';}\nvoid go(bool f[])\n{\n\ts=\" \"+s+\" \";\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint sz=name[i].size();\n\t\tf[i]=0;\n\t\tfor(int j=1;j+sz<s.size();j++)\n\t\t{\n\t\t\tif(!check(s[j-1])&&!check(s[j+sz])&&name[i]==s.substr(j,sz))\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nbool f[111][111];\nstring ms[111];\nint id[111];\nint dp[111][111];\nint main()\n{\n\tcin>>Tn;\n\twhile(Tn--)\n\t{\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++)cin>>name[i];\n\t\tcin>>m;\n\t\tgets(ss);\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tgets(ss);\n\t\t\tint l=strlen(ss);\n\t\t\ts=\"\";\n\t\t\tfor(int j=0;j<l;j++)s.PB(ss[j]);\n\t\t\tms[i]=s;\n\t\t\tint p;\n\t\t\tfor(int j=0;j<s.size();j++)\n\t\t\t{\n\t\t\t\tif(s[j]==':')\n\t\t\t\t{\n\t\t\t\t\tp=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring nm=s.substr(0,p);\n\t\t\tid[i]=0;\n\t\t\tif(nm!=\"?\")\n\t\t\t{\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(name[j]==nm)\n\t\t\t\t\t{\n\t\t\t\t\t\tid[i]=j;\n\t\t\t\t\t\tf[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse f[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts=s.substr(p+1);\n\t\t\t\tgo(f[i]);\n\t\t\t}\n\t\t}\n/*\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tcout<<f[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==-1)continue;\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(j==k||f[i+1][k])continue;\n\t\t\t\t\tif(id[i+1]==0||id[i+1]==k)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][k]=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tcout<<dp[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tint p=-1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(dp[m][i]!=-1)p=i;\n\t\t}\n\t\tif(p==-1)puts(\"Impossible\");\n\t\telse\n\t\t{\n\t\t\tint px=m;\n\t\t\twhile(px>0)\n\t\t\t{\n//\t\t\t\tcout<<px<<\" \"<<p<<endl;\n\t\t\t\tid[px]=p;\n\t\t\t\tp=dp[px][p];\n\t\t\t\tpx--;\n\t\t\t}\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tif(ms[i][0]=='?')\n\t\t\t\t{\n\t\t\t\t\tms[i]=name[id[i]]+ms[i].substr(1);\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",ms[i].c_str());\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "implementation",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Vladik and chat.json",
    "editorial_link": "https://codeforces.com//blog/entry/49637",
    "editorial": "Let\u00e2\u0080\u0099s number users from to . Let\u00e2\u0080\u0099s us know for every message users\r\nmentioned in message. Let\u00e2\u0080\u0099s define arrays and . index of sender of -th\r\nmessage, if sender of -th message is unknown, then . set of mentioned\r\nusers in -th message. Now for every message where sender is unknown we\r\nneed to restore sender. In other words for every , such that , we need\r\nto find number from to , such that for every , that , condition\r\nsatisfied.This can be solved using Dynamic Programming:, if over first\r\nmessages we can restore all unknown senders, and -th message has sender\r\nnumber , otherwise .There next transitions in DP:, where index of user,\r\nwho send -th message. should be not equals to and should be not equals\r\nto every number from set . Also if for -th message we know sender then\r\nshould be equals to .Time complexity of this DP is .Also there is exist\r\nanother solution. Greedy:While we have messages with unknown sender, for\r\nevery of which there is only one possible user, which can be put as\r\nsender not violating conditions described in statement, then put this\r\nuser as sender. If in one moment we will have a message with zero\r\npossible users, which can be put as sender not violating conditions in\r\nstatement, then we can\u00e2\u0080\u0099t restore senders of messages in chat. Otherwise\r\nif every message has two or more possible users which can be senders,\r\nthen we should choose any such message and put as sender any user, which\r\nis possible for this message.\r\n"
}