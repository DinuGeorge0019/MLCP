{
    "link": "https://codeforces.com//contest/1333/problem/C",
    "problemId": "586755",
    "problem_idx": "C",
    "shortId": "1333C",
    "contest_number": "1333",
    "problem_submissions": {
        "E": [
            75896339,
            75896565,
            75977605,
            75896691,
            75897517,
            75909706,
            75903789,
            75909595,
            75887158,
            75892751,
            75911705,
            75893605,
            75903871,
            75907577,
            75907287,
            75905980,
            75911364,
            102357635
        ],
        "F": [
            75886038,
            75883944,
            75977662,
            75881660,
            75879950,
            75880078,
            75883983,
            75889261,
            75893323,
            75897108,
            75891281,
            75909072,
            75894697,
            75898619,
            75885706,
            75889606,
            75886207,
            75876954,
            75881193
        ],
        "D": [
            75864744,
            75869369,
            75977526,
            75869421,
            75870061,
            75872281,
            75875027,
            75874985,
            75876429,
            75882167,
            75873219,
            75876350,
            75881516,
            75880068,
            75879600,
            75883836,
            75901469,
            75865548,
            75870511
        ],
        "C": [
            75852521,
            75859230,
            75977465,
            75850790,
            75858133,
            75853774,
            75862591,
            75860649,
            75860611,
            75873215,
            75852933,
            75864634,
            75853173,
            75865167,
            75868921,
            75862158,
            75875332,
            75854728,
            75853080
        ],
        "B": [
            75848076,
            75848553,
            75977412,
            75847691,
            75848476,
            75846675,
            75848813,
            75851794,
            75895723,
            75859034,
            75846157,
            75848508,
            75884037,
            75854691,
            75852331,
            75853099,
            75848989,
            75850255,
            75846775
        ],
        "A": [
            75845195,
            75845040,
            75977221,
            75844826,
            75845093,
            75844889,
            75845001,
            75846626,
            75847661,
            75851327,
            75844724,
            75845218,
            75845746,
            75850998,
            75847105,
            75848789,
            75855160,
            75846223,
            75844893
        ]
    },
    "name": "C. Eugene and an array",
    "statement": "Eugene likes working with arrays. And today he needs your help in\r\nsolving one challenging task.An array c is a subarray of an array b if c\r\ncan be obtained from b by deletion of several (possibly, zero or all)\r\nelements from the beginning and several (possibly, zero or all) elements\r\nfrom the end.Let\u2019s call a nonempty array if for every nonempty subarray\r\nof this array, sum of the elements of this subarray is nonzero. For\r\nexample, array [-1, 2, -3] is , as all arrays [-1], [-1, 2], [-1, 2,\r\n-3], [2], [2, -3], [-3] have nonzero sums of elements. However, array\r\n[-1, 2, -1, -3] isn\u2019t , as his subarray [-1, 2, -1] has sum of elements\r\nequal to 0.Help Eugene to calculate the number of nonempty subarrays of\r\na given array a.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\nmap<ll, int> frec;\nint const nmax = 200000;\n\nint main()\n{\n  int n;\n  cin >> n;\n  ll result = 0, sum = 0;\n  int st = 1;\n  frec[0] = 1;\n  for(int i = 1;i <= n; i++){\n    int val;\n    cin >> val;\n    sum += val;\n    st = max(st, frec[sum] + 1);\n    frec[sum] = i + 1;\n    result += (i + 1 - st);\n  }\n  cout << result;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Eugene and an array.json",
    "editorial_link": "https://codeforces.com//blog/entry/75802",
    "editorial": "Let\u00e2\u0080\u0099s solve this problem in for now.Note that if the subarray is good,\r\nthen the subarray is also good, and if the subset is not good, then the\r\nsubarray is not good either. Then for each left border we want to find\r\nthe rightmost border such that is good and add to the answer (subarrays\r\n) [1]. Let\u00e2\u0080\u0099s denote the rightmost border for border as .Let\u00e2\u0080\u0099s calculate\r\nthe prefix-sum of the array ..Note that a subset of has a zero sum iff .\r\nThen the subset is a good iff sum of prefixes has no duplicates\r\n[2].Using [1] and [2], we can simply iterate over from to and over from\r\nto and count the set of prefix sums . The first moment when this set\r\ncontains duplicates gives us the rightmost border , and we add (no ,\r\nbecause it is an array of prefix sums) to answer.To improve this\r\nsolution to , we need to note that is monotonous over . Now we can\r\niterate over from to and over from to uses a set of prefix sums from the\r\nprevious iteration. Thus we have a solution , because points to each\r\nelement of the array exactly once.If you code in C++, it is important\r\nnot to use std:: unordered_set in this task, but use std::set. One of\r\nthe participants hacked the solution using std:: unordered_set, using\r\ncollisions in this structure. I highly recommend you to read this blog\r\nfor more info https://codeforces.com/blog/entry/62393.Final time\r\ncomplexity:\r\n"
}