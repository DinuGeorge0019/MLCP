{
    "link": "https://codeforces.com//contest/1758/problem/C",
    "problemId": "1661250",
    "problem_idx": "C",
    "shortId": "1758C",
    "contest_number": "1758",
    "problem_submissions": {
        "F": [
            182540191,
            182568321
        ],
        "E": [
            182511822,
            182586636,
            182586387,
            182515621,
            182519585,
            182518611,
            182521484,
            182522469,
            182521201,
            182526835,
            182524445,
            182531747,
            182527370,
            182535662,
            182516659,
            182531389,
            182540195,
            182534906,
            182535704,
            182534874,
            182530934
        ],
        "D": [
            182500138,
            182501532,
            182504442,
            182507521,
            182511731,
            182494704,
            182508383,
            182512302,
            182512544,
            182503927,
            182510854,
            182528079,
            182501802,
            182493856,
            182514498,
            182506950,
            182513404,
            182511217,
            182525174,
            182492321
        ],
        "C": [
            182492468,
            182496509,
            182492305,
            182495507,
            182494119,
            182500722,
            182502459,
            182500806,
            182500441,
            182492103,
            182505245,
            182496553,
            182526899,
            182500230,
            182495864,
            182508565,
            182493170,
            182498448,
            182538442
        ],
        "B": [
            182487714,
            182492898,
            182486562,
            182485510,
            182487169,
            182486096,
            182487229,
            182491179,
            182486630,
            182482943,
            182485521,
            182488443,
            182519764,
            182489830,
            182487145,
            182487987,
            182502412,
            182487085,
            182484646
        ],
        "A": [
            182480951,
            182480859,
            182482976,
            182480629,
            182480620,
            182481772,
            182483562,
            182480441,
            182483772,
            182479955,
            182480275,
            182480273,
            182517991,
            182490014,
            182483571,
            182480580,
            182480710,
            182480601,
            182480454
        ]
    },
    "name": "C. Almost All Multiples",
    "statement": "Given two integers n and x, a permutation^{\r\ndagger} p of length n is called if p_i is a multiple of i for all 1\r\nleq i\r\nleq n - 1, p_n = 1, and p_1 = x.Find the lexicographically minimal^{\r\nddagger} funny permutation, or report that no such permutation exists.^{\r\ndagger} A permutation of length n is an array consisting of each of the\r\nintegers from 1 to n exactly once.^{\r\nddagger} Let a and b be permutations of length n. Then a is\r\nlexicographically smaller than b if in the first position i where a and\r\nb differ, a_i < b_i. A permutation is lexicographically minimal if it is\r\nlexicographically smaller than all other permutations.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch=='-')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=998244353;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n,a[N];\nV input(){\n\tint x;\n\tn = getint(), x = getint();\n\ta[1] = x, a[n] = 1;\n\tif(n%x!=0)\n\t\treturn void(cout<<\"-1\\n\");\n\tFOR(i,2,n-1)a[i] = i;\n\t// x 放 n -> x 放最小的 n 的约数\n\tint p = 2;\n\twhile(x!=n){\n\t\tint d= n/x;\n\t\twhile(d%p!=0)p++;\n\t\ta[x] = x *p, x*=p;\n\t}\n\tFOR(i,1,n)cout<<a[i]<<\" \\n\"[i==n];\n\n\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n\t// freopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tfor(scanf(\"%d\",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "number theory"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Almost All Multiples.json",
    "editorial_link": "https://codeforces.com//blog/entry/109438",
    "editorial": "We start by giving the answer for , : and for , : As you can see, the\r\narray is almost the identity permutation, with certain elements rotated\r\nto the left. In particular, these are the elements that you get when you\r\nfind the longest sequence such that (recall means divides ). For\r\nexample, and . To find this longest sequence, you need to prime\r\nfactorize . The complexity is .The main idea is intuitive, but the proof\r\nis rather long. We include it below.The idea is to look at cycles in the\r\npermutation. Consider any cycle of length greater than , say (that is, ,\r\n). We claim that for at least one element of the cycle, is a multiple of\r\n.In fact, weâll show a more general claim: for one element of the cycle\r\n, which implies that cannot be a multiple of . Indeed, letâs sum over\r\nall elements of the cycle. This sum is , because each element appears\r\nonce before the sign and once afterwards. Since none of these equal , it\r\nfollows that at least one of these terms is negative (and at least one\r\nis positive). If , then , as desired.So in each cycle, we must have at\r\nleast one element breaking the key claim in the problem. But this claim\r\nholds for all , so the only cycle we can have goes through ! Indeed,\r\nsince and , the cycle goes . For all arrows except the first one, we to\r\nwrite , because only can break the condition. Since we want the\r\npermutation to be lexicographically minimal, we want the longest such\r\nchain. So we should find the longest sequence of numbers from to , such\r\nthat each number divides the previous. If there are multiple such\r\nsequences, we need to pick the one that puts smaller numbers earlier,\r\nsince we want smaller elements earlier on in the sequence. To do this,\r\nwe can just find the prime factorization of (it is the longest, since\r\nthe primes cannot be broken up into smaller factors), sort it, and cycle\r\nit.\r\n",
    "hint": [
        "Hint Consider the cycles in the permutation. What cycles can there be?"
    ]
}