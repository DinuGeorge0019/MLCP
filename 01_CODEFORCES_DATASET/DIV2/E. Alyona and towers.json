{"link": "https://codeforces.com//contest/740/problem/E", "problemId": "81531", "problem_idx": "E", "shortId": "740E", "contest_number": "740", "problem_submissions": {"E": [22446990, 22448474, 22447966, 22448057, 22445073, 22450140], "D": [22439412, 22439501, 22441405, 22442158, 22441228, 22442043, 22444396, 22443003, 22443858, 22440389, 22438383, 22443141, 22440987, 22434772, 22440005, 22441561, 22440585, 22443581, 22437799, 22440799], "C": [22434901, 22433582, 22438379, 22436692, 22431072, 22432796, 22434051, 22436772, 22434191, 22433939, 22440329, 22437240, 22438204, 22444420, 22434561, 22436539, 22433220, 22434158, 22437987], "B": [22430518, 22430263, 22434039, 22433558, 22429147, 22430035, 22430933, 22430825, 22428254, 22429750, 22432572, 22434667, 22438582, 22431092, 22433538, 22429194, 22431254, 22430546, 22430025], "A": [22428386, 22434382, 22429601, 22432121, 22428085, 22439358, 22428434, 22428332, 22430743, 22428904, 22430234, 22432401, 22436992, 22429501, 22430090, 22427921, 22428402, 22428280]}, "name": "E. Alyona and towers", "statement": "Alyona has built towers by putting small cubes some on the top of\r\nothers. Each cube has size . A tower is a non-zero amount of cubes\r\nstanding on the top of each other. The towers are next to each other,\r\nforming a row.Sometimes Alyona chooses some segment towers, and put on\r\nthe top of each tower several cubes. Formally, Alyouna chooses some\r\nsegment of towers from to and adds cubes on the top of them.Let the\r\nsequence be the heights of the towers from left to right. Let\u2019s call as\r\na segment of towers a hill if the following condition holds: there is\r\ninteger () such that .After each addition of cubes on the top of the\r\ntowers from to , Alyona wants to know the maximum width among all hills.\r\nThe width of a hill is the number of towers in it.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std; \n\nconst int N=1e6;\nconst int Mod=1e9+7;\n\nint n,m,a[N];\nlong long b[N];\n\nstruct Node {\n\tint sl,sr,ml,mr,m,len;\n\tlong long v;\n\tNode(){} \n}tree[N<<2];\n\ninline Node merge(Node &a,Node &b) {\n\tNode res;\n\tres.m=max(a.m,b.m);\n\tif(a.sr!=0&&b.sl!=0&&a.sr>=b.sl) res.m=max(res.m,a.mr+b.ml);\n\tres.sl=a.sl; \n\tres.sr=b.sr;\n\tres.ml=a.ml;\n\tres.mr=b.mr;\n\tres.len=a.len+b.len;\n\tif(a.len==a.ml&&a.sr>=b.sl&&b.sl!=0&&a.sr!=0) res.ml+=b.ml;\n\tif(b.len==b.mr&&a.sr>=b.sl&&b.sl!=0&&a.sr!=0) res.mr+=a.mr;\n\tres.m=max(res.m,res.ml);\n\tres.m=max(res.m,res.mr);\n\treturn res;\n}\n\nvoid build(int k,int l,int r) {\n\ttree[k].len=r-l+1; \n\tif(l==r) {\n\t\tif(b[l]>0) tree[k].sl=tree[k].sr=1;\n\t\tif(b[l]==0) tree[k].sl=tree[k].sr=0;\n\t\tif(b[l]<0) tree[k].sl=tree[k].sr=-1;\n\t\ttree[k].ml=tree[k].mr=tree[k].m=1;\n\t\tif(b[l]==0) tree[k].ml=tree[k].mr=tree[k].m=0;\n\t\ttree[k].v=b[l];\n\t\treturn;\n\t}\t\n\tint mid=l+r>>1;\n\tbuild(k<<1,l,mid); build(k<<1|1,mid+1,r);\n\ttree[k]=merge(tree[k<<1],tree[k<<1|1]);\n}\n\nvoid Ins(int k,int l,int r,int p,int v) {\n\tif(l==r) {\n\t\tb[l]+=v;\n\t\tif(b[l]>0) tree[k].sl=tree[k].sr=1;\n\t\tif(b[l]==0) tree[k].sl=tree[k].sr=0;\n\t\tif(b[l]<0) tree[k].sl=tree[k].sr=-1;\n\t\ttree[k].ml=tree[k].mr=tree[k].m=1;\n\t\tif(b[l]==0) tree[k].ml=tree[k].mr=tree[k].m=0;\n\t\ttree[k].v=b[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(p<=mid) Ins(k<<1,l,mid,p,v);\n\telse Ins(k<<1|1,mid+1,r,p,v);\n\ttree[k]=merge(tree[k<<1],tree[k<<1|1]);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tn--;\n\tfor(int i=1;i<=n;i++) b[i]=a[i+1]-a[i];\n\tif(n) build(1,1,n);\n\tint l,r,d,tmp;\n\tscanf(\"%d\",&m);\n\tif(n==0) {\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tscanf(\"%d%d%d\",&l,&r,&d);\n\t\t\tputs(\"1\");\n\t\t}\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tscanf(\"%d%d%d\",&l,&r,&d);\n\t\tif(l>1)Ins(1,1,n,l-1,d);\n\t\tif(r<=n)Ins(1,1,n,r,-d);\n\t\ttmp=tree[1].m;\n\t\ttmp++;\n\t\tprintf(\"%d\\n\",tmp);\n\t}\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2500", "interactive": false}