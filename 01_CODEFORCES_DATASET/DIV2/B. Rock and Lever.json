{
    "link": "https://codeforces.com//contest/1420/problem/B",
    "problemId": "735850",
    "problem_idx": "B",
    "shortId": "1420B",
    "contest_number": "1420",
    "problem_submissions": {
        "E": [
            93699813,
            93707260,
            93695968,
            93707648,
            93705681,
            93709151,
            93715432,
            93730964,
            93708580,
            93714548,
            93716147,
            93715550,
            93736542,
            93717442,
            93710855,
            93715981,
            93697763,
            93711132,
            93762507
        ],
        "D": [
            93676952,
            93680084,
            93692950,
            93670877,
            93690670,
            93693136,
            93730971,
            93710781,
            93702357,
            93681953,
            93695104,
            93691378,
            93699248,
            93698024,
            93665582,
            93680861,
            93671056,
            93667892,
            93675623
        ],
        "C2": [
            93674880,
            93671167,
            93692067,
            93741708,
            93681627,
            93659881,
            93679255,
            93686831,
            93676610,
            93670869,
            93669089,
            93684016,
            93707465,
            93690589,
            93710188,
            93716769,
            93662876,
            93683514,
            93665601
        ],
        "C1": [
            93658399,
            93663408,
            93681461,
            93660059,
            93679792,
            93666232,
            93663489,
            93671318,
            93669597,
            93684191,
            93665522,
            93690460,
            93659663,
            93716842,
            93670252,
            93662639,
            93658224,
            93665421
        ],
        "B": [
            93652358,
            93659482,
            93658665,
            93669626,
            93664158,
            93660524,
            93657692,
            93655021,
            93655235,
            93677044,
            93656189,
            93674995,
            93653603,
            93704106,
            93656350,
            93653174,
            93653888,
            93653561
        ],
        "A": [
            93651966,
            93651886,
            93654562,
            93660205,
            93652727,
            93651674,
            93651632,
            93674907,
            93652710,
            93659767,
            93651617,
            93706046,
            93651985,
            93651435,
            93651489,
            93651367
        ]
    },
    "name": "B. Rock and Lever",
    "statement": "Danik urgently needs rock and lever! Obviously, the easiest way to get\r\nthese things is to ask Hermit Lizard for them.Hermit Lizard agreed to\r\ngive Danik the lever. But to get a stone, Danik needs to solve the\r\nfollowing task.You are given a positive integer n, and an array a of\r\npositive integers. The task is to calculate the number of such pairs\r\n(i,j) that i<j and a_i\r\n& a_j\r\nge a_i\r\noplus a_j, where\r\n& denotes the bitwise AND operation, and\r\noplus denotes the bitwise XOR operation.Danik has solved this task. But\r\ncan you solve it?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reverse_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 1e5;\nconst int lgN = 31;\nint n;\nllong cnt[lgN+3];\n\nint main()\n{\n\tint T = read(); while(T--)\n\t{\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tn = read(); for(int i=1; i<=n; i++)\n\t\t{\n\t\t\tllong x = read(); int y = 0;\n\t\t\twhile(x) {y++; x/=2ll;}\n\t\t\tcnt[y]++;\n\t\t}\n\t\tllong ans = 0ll;\n\t\tfor(int i=0; i<lgN; i++) ans += 1ll*cnt[i]*(cnt[i]-1ll)/2ll;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Rock and Lever.json",
    "editorial_link": "https://codeforces.com//blog/entry/82978",
    "editorial": "Let\u00e2\u0080\u0099s take a pair and see in which case will hold. For this we will\r\nfollow the bits and from highest to lowest. If we meet two zero bits,\r\nthe values of and will match in this bit, so we move on. If we meet a\r\nzero bit in and in one bit(or vice versa), then we get , and we can\r\nimmediately say that the required condition is false. And if we meet two\r\none bits, then the required condition is fulfilled, e. , and then the\r\nbits can no longer be considered.Now let\u00e2\u0080\u0099s consider the highest one bit\r\nin the number of (let it stand at position) and the highest single bit\r\nin the number of (let it stand at position). (Here, we consider that the\r\nbits are numbered in order of lowest to highest.) Then, must hold. If ,\r\nthen there is zero in the position and one unit in the position. But\r\nthen from the reasoning above we get that . The case of is treated in a\r\nsimilar way.It is also easy to see that if then we automatically get the\r\ncondition .From here the problem is solved. For each number we find the\r\nposition of the highest one bit . Then we need to calculate the number\r\nof pairs of numbers, for which . You may notice that the answer is ,\r\nwhere the number of numbers for which .The complexity of the solution is\r\n.\r\n"
}