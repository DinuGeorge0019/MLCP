{
    "link": "https://codeforces.com//contest/1247/problem/B2",
    "problemId": "451062",
    "problem_idx": "B2",
    "shortId": "1247B2",
    "contest_number": "1247",
    "problem_submissions": {
        "F": [
            63516585,
            63498066,
            63531653,
            63484717
        ],
        "E": [
            63466015,
            63473982,
            63472756,
            63472587,
            63477513,
            63473125,
            63474516,
            63476526,
            63478680,
            63473858,
            63480958,
            63481550,
            63481519,
            63482376,
            63483256,
            63481801,
            63480736,
            63482911,
            63484993
        ],
        "D": [
            63458462,
            63452186,
            63464452,
            63462467,
            63461642,
            63462284,
            63469112,
            63466038,
            63465533,
            63467098,
            63466913,
            63532659,
            63458800,
            63469138,
            63466028,
            63518059,
            63471109,
            63471871,
            63471893,
            63472863,
            63468681
        ],
        "C": [
            63451842,
            63448915,
            63446524,
            63452894,
            63453210,
            63465192,
            63456520,
            63458388,
            63455590,
            63458932,
            63454282,
            63457733,
            63453216,
            63464210,
            63454777,
            63455424,
            63462076,
            63462168,
            63461001
        ],
        "B1": [
            63441028,
            63445773,
            63455031,
            63446312,
            63447577,
            63448362,
            63448931,
            63448486,
            63445824,
            63453830,
            63446861,
            63447193,
            63445847,
            63460715,
            63448295,
            63449973,
            63454578,
            63450726,
            63449807
        ],
        "B2": [
            63440055,
            63445491,
            63454826,
            63446019,
            63446936,
            63447440,
            63449345,
            63447899,
            63445385,
            63454155,
            63447268,
            63446929,
            63448203,
            63460143,
            63447809,
            63449173,
            63454319,
            63450374,
            63450053
        ],
        "A": [
            63437545,
            63439551,
            63452092,
            63445337,
            63447252,
            63440937,
            63439822,
            63438397,
            63438564,
            63453424,
            63437913,
            63439495,
            63438907,
            63456486,
            63442538,
            63445415,
            63444316,
            63440390,
            63439231
        ]
    },
    "name": "B2. TV Subscriptions  Hard Version ",
    "statement": "The BerTV channel every day broadcasts one episode of one of the k TV\r\nshows. You know the schedule for the next n days: a sequence of integers\r\na_1, a_2,\r\ndots, a_n (1\r\nle a_i\r\nle k), where a_i is the show, the episode of which will be shown in i-th\r\nday.The subscription to the show is bought for the entire show (i.e. for\r\nall its episodes), for each show the subscription is bought\r\nseparately.How many minimum subscriptions do you need to buy in order to\r\nhave the opportunity to watch episodes of purchased shows d (1\r\nle d\r\nle n) days in a row? In other words, you want to buy the minimum number\r\nof TV shows so that there is some segment of d consecutive days in which\r\nall episodes belong to the purchased shows.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int maxn=(1e6)+10;\nint T,n,k,d;\nint a[maxn],cnt[maxn],tmp,ans;\nvoid insert(int x) {\n\tcnt[x]++;\n\tif (cnt[x]==1) tmp++;\n}\nvoid del(int x) {\n\tcnt[x]--;\n\tif (!cnt[x]) tmp--;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(T);\n\twhile (T--) {\n\t\tread(n); read(k); read(d);\n\t\tfor (int i=1;i<=n;i++) read(a[i]);\n\t\ttmp=0;\n\t\tfor (int i=1;i<=d;i++) insert(a[i]);\n\t\tans=tmp;\n\t\tfor (int i=d+1;i<=n;i++) {\n\t\t\tinsert(a[i]),del(a[i-d]);\n\t\t\tans=min(ans,tmp);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tfor (int i=1;i<=n;i++) cnt[a[i]]=0;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B2. TV Subscriptions  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/70898",
    "editorial": "In larger limitations we have to use two pointers to maintain the number of distinct elements between segments. We can store a map or an array that counts the number of occurences of each element, as well as the number of distinct elements (i.e. the number of non-zero entries in the map). Moving the segment to the right involves changing two entries of the map, keeping track of which entries become/cease to be non-zero. The complexity is O(nlogn)\n or O(n)\n (both are acceptable).",
    "hint": []
}