{"link": "https://codeforces.com//contest/459/problem/E", "problemId": "12588", "problem_idx": "E", "shortId": "459E", "contest_number": "459", "problem_submissions": {"A": [7465089, 7456885, 7454644, 7456768, 7455722, 7465524, 7454591, 7455615, 7455512, 7464131, 7465581, 7455579, 7454905, 7474523, 7454933, 7455010, 7455598, 7466267], "B": [7463181, 7454658, 7455082, 7459475, 7456945, 7463304, 7457262, 7454941, 7454662, 7457373, 7462108, 7454808, 7458807, 7456880, 7457346, 7458825, 7457232, 7457461, 7459089], "E": [7461438, 7462457, 7460022, 7462820, 7462880, 7468200, 7468253, 7466520, 7474444, 7467721, 7467381, 7470585, 7456554, 7470102, 7470346, 7467608, 7469521, 7472589, 7472680, 7473561, 7469671], "D": [7459251, 7457162, 7464074, 7461213, 7461612, 7464875, 7461670, 7461881, 7458376, 7461351, 7465461, 7458321, 7465138, 7462417, 7462812, 7468054, 7465094, 7468318, 7462068, 7467891], "C": [7456047, 7467837, 7462164, 7465696, 7466788, 7462918, 7459196, 7464484, 7473320, 7471339, 7461840, 7460617, 7467558, 7470365, 7465522, 7462231, 7464950, 7467163, 7471141]}, "name": "E. Pashmak and Graph", "statement": "Pashmak\u2019s homework is a problem about graphs. Although he always tries\r\nto do his homework completely, he can\u2019t solve this problem. As you know,\r\nhe\u2019s really weak at graph theory; so try to help him in solving the\r\nproblem.You are given a weighted directed graph with vertices and edges.\r\nYou need to find a path (perhaps, non-simple) with maximum number of\r\nedges, such that the weights of the edges increase along the path. In\r\nother words, each edge of the path must have strictly greater weight\r\nthan the previous edge in the path.Help Pashmak, print the number of\r\nedges in the required path.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define MAX   300300\n#define FOR(i,a,b) for (int i=(a);i<=(b);i=i+1)\n#define REP(i,n) for (int i=0;i<(n);i=i+1)\nusing namespace std;\nstruct edge {\n    int u,v,w;\n    edge() {\n        u=v=w=0;\n    }\n    void input(void) {\n        scanf(\"%d%d%d\",&u,&v,&w);\n    }\n    bool operator < (const edge &x) const {\n        return (w<x.w);\n    }\n};\ninline void maximize(int &x,const int &y) {\n    if (x<y) x=y;\n}\nedge e[MAX];\nint f[MAX],mf[MAX];\nint n,m;\nvoid loadgraph(void) {\n    scanf(\"%d%d\",&n,&m);\n    FOR(i,1,m) e[i].input();\n    sort(e+1,e+m+1);\n}\nvoid optimize(void) {\n    int j=1;\n    FOR(i,1,m) {\n        while (j<i && e[j].w<e[i].w) {\n            maximize(mf[e[j].v],f[j]);\n            j++;\n        }\n        f[i]=mf[e[i].u]+1;\n    }\n    int res=0;\n    FOR(i,1,m) maximize(res,f[i]);\n    printf(\"%d\",res);\n}\nint main(void) {\n    loadgraph();\n    optimize();\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "sortings"], "dificulty": "1900", "interactive": false}