{
    "link": "https://codeforces.com//contest/1867/problem/F",
    "problemId": "2204237",
    "problem_idx": "F",
    "shortId": "1867F",
    "contest_number": "1867",
    "problem_submissions": {
        "F": [
            222974823,
            222969528,
            222982087,
            222982811,
            222942381,
            222981865,
            222970849,
            223263369,
            222992160,
            222992118,
            222990610,
            223293875
        ],
        "E2": [
            222941139,
            222944891,
            222954532,
            222948444,
            222972148,
            222927706,
            222951442,
            222943457,
            222956697,
            222956351,
            222957299,
            222965859,
            222961624,
            222958308,
            222959237,
            222958461,
            222947616,
            222951450,
            222971686,
            222965055
        ],
        "E1": [
            222935951,
            222944650,
            222944932,
            222948245,
            222972552,
            222928046,
            222951818,
            222940287,
            222956433,
            222950145,
            222954065,
            222953208,
            222961246,
            222954058,
            222958971,
            222958084,
            222946896,
            222951047,
            222957812,
            222965382
        ],
        "D": [
            222929659,
            222935565,
            222933136,
            222933725,
            222959573,
            222947841,
            222976215,
            222934664,
            222934515,
            222943779,
            222942901,
            222940224,
            222926502,
            222939367,
            222939032,
            222944642,
            222964473,
            222961543,
            222946848,
            222932024
        ],
        "C": [
            222924786,
            222923447,
            222923495,
            222924317,
            222955570,
            222955063,
            222981892,
            222921233,
            222922345,
            222926941,
            222929128,
            222930091,
            222943796,
            222929098,
            222924664,
            222933035,
            222926807,
            222929365,
            222928181,
            222930087
        ],
        "B": [
            222916375,
            222917063,
            222916284,
            222918254,
            222947890,
            222958388,
            222980080,
            222916704,
            222917105,
            222917987,
            222920819,
            222919702,
            222916186,
            222917789,
            222919342,
            222922163,
            222919191,
            222921766,
            222918135,
            222919076
        ],
        "A": [
            222912165,
            222912569,
            222912487,
            222914168,
            222945721,
            222961169,
            222912375,
            222913097,
            222912526,
            222913140,
            222913385,
            222912716,
            222912425,
            222912955,
            222912750,
            222914115,
            222913574,
            222915575,
            222912204,
            222918270
        ]
    },
    "name": "F. Most Different Tree",
    "statement": "Given a tree with n vertices rooted at vertex 1, denote it as G. Also\r\ndenote P(G) as the multiset of subtrees of all vertices in tree G. You\r\nneed to find a tree G\u2019 of size n rooted at vertex 1 such that the number\r\nof subtrees in P(G\u2019) that are isomorphic to any subtree in P(G) is\r\nminimized.A subtree of vertex v is a graph that contains all vertices\r\nfor which vertex v lies on the path from the root of the tree to itself,\r\nas well as all edges between these vertices.Two rooted trees are\r\nconsidered isomorphic if it is possible to relabel the vertices of one\r\nof them so that it becomes equal to the other, with the root of the\r\nfirst tree receiving the number of the root of the second tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define pb push_back\nusing namespace std;\nusing pii=pair <int,int>;\nusing tii=pair <pii,int>;\nint h(int n){\n    return n*n*n*1234567+412269;\n}\nint f(int n){\n    return h(n&((1ll<<31LL)-1))+h(n>>31LL);\n}\nint N;\nvector <int> g[1000010];\nint hsh[1000010],sz[1000010];\nvoid dfs(int cur,int prv){\n    sz[cur]=1;\n    hsh[cur]=1;\n    for (int i:g[cur]){\n        if (i==prv) continue;\n        dfs(i,cur);\n        sz[cur]+=sz[i];\n        hsh[cur]+=f(h(hsh[i]));\n    }\n}\nvector <int> bruh[1000010];\nint bruh_hsh[1000010];\nvoid dfs2(int cur){\n    bruh_hsh[cur]=1;\n    for (int i:bruh[cur]){\n        dfs2(i);\n        bruh_hsh[cur]+=f(h(bruh_hsh[i]));\n    }\n}\nunordered_map <int,int> mp[1000010];\nvoid exhaust(int cur,int sz,int prv_pa){\n    if (cur>sz){\n        //try bruh it\n        dfs2(1);\n        if (mp[sz].count(bruh_hsh[1])) return;\n        for (int j=2; j<=N-sz+1; j++) cout<<j-1<<' '<<j<<'\\n';\n        for (int j=1; j<=sz; j++){\n            for (int k:bruh[j]) cout<<j+N-sz<<' '<<k+N-sz<<'\\n';\n        }\n        exit(0);\n    }\n    for (int i=prv_pa; i<cur; i++){\n        bruh[i].pb(cur);\n        exhaust(cur+1,sz,i);\n        bruh[i].pop_back();\n    }\n}\nvoid solve(){\n    int n;\n    cin>>n;\n    N=n;\n    for (int i=1; i<n; i++){\n        int u,v; cin>>u>>v;\n        g[u].pb(v); g[v].pb(u);\n    }\n    int fac[20];\n    fac[0]=1;\n    for (int i=1; i<20; i++) fac[i]=fac[i-1]*i;\n    dfs(1,0);\n    for (int i=1; i<=n; i++) mp[sz[i]][hsh[i]]=1;\n    int cnt=0;\n    for (int i=2; ; i++){\n        exhaust(2,i,1);\n        if (i==n){\n            for (int j=1; j<n; j++) cout<<j<<' '<<j+1<<'\\n';\n            return;\n        }\n    }\n}\nsigned main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint t=1;\n\t//cin>>t;\n\twhile (t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "hashing"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Most Different Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/120353",
    "editorial": "TutorialHere we say that the answer for tree is the number of subtrees\r\nin that have an isomorphic subtree in .Let\u00e2\u0080\u0099s find a tree of minimum size\r\nthat has no isomorphic tree in . Let the size of tree be . Then take a\r\nchain of size , and let the root of be the kid of the last vertex on the\r\nchain. We say that this is the tree we were looking for (with the root\r\nof being the first vertex of the chain). The number of matching subtrees\r\nwill be at most , since all subtrees of the vertices on the chain and\r\nthe subtree itself will not have isomorphic trees in , because lies\r\nentirely in them, and has no isomorphic tree in . Therefore, the answer\r\nis not greater than .Let\u00e2\u0080\u0099s prove why the answer cannot be less than :\r\nsuppose there exists a tree for which the answer is less than . Let\u00e2\u0080\u0099s\r\nfind a subtree of minimum size whose size is at least (it always exists,\r\nsince we can take the entire tree for example). In this subtree, there\r\nare at least other subtrees, whose sizes are less than (because in the\r\nprevious step we chose a subtree of minimum size not less than ). And\r\nsince all trees of size less than have isomorphic trees in (by\r\ndefinition is the tree of minimum size that has no isomorphic tree in\r\nand its size is ), the number of matching subtrees in tree is at least ,\r\nwhich is a contradiction.Therefore in our case the answer is .Now let\u00e2\u0080\u0099s\r\nsolve the second part of the problem finding . To do this, let\u00e2\u0080\u0099s first\r\nfind all trees of size 1, then of size 2, then 3, 4 and so on until we\r\nfind a tree that has no isomorphic subtree in . One can see that if we\r\ngenerate all trees of size up to 15 we will definitely find there.\r\nWithin each size, let\u00e2\u0080\u0099s number the trees in the order in which we\u00e2\u0080\u0099ve\r\ngenerated them. To find all trees of size if we are given all trees of\r\nsize and smaller, let\u00e2\u0080\u0099s say that the sizes of the children of the root\r\nof the tree we generate must not decrease, and if the sizes are the\r\nsame, their positions in the order must not decrease. Then, we can\r\niterate over the first child, then among the smaller and suitable ones,\r\nthe second child, then the third, and so on until the total size of the\r\ntree becomes exactly . This way, we will enumerate all trees of size in\r\ncomplexity of their total number (since we will not consider any tree\r\ntwice and will not consider any extra trees). Let\u00e2\u0080\u0099s do this until we\r\nfind a tree that is not in .Hashes can be used to compare trees for\r\nisomorphism. For more details, read the blog postTime Complexity: .\r\n"
}