{"link": "https://codeforces.com//contest/1929/problem/D", "problemId": "2478906", "problem_idx": "D", "shortId": "1929D", "contest_number": "1929", "problem_submissions": {"F": [246533325, 246531273, 246535602, 246537728, 248473670, 248472907, 246536511, 246538004, 246539955, 246545257, 246545291, 246547847, 246517420, 246543420, 246541449, 246549298, 246540895, 246550782, 246552572, 246538786, 246556383, 246551792], "E": [246526711, 246525335, 246529920, 246532407, 247710837, 246542700, 246542158, 246542829, 246536287, 246540991, 246540586, 246556061, 246534976, 246548547, 246541367, 246546569, 246545920, 246542715, 246562305, 246543807, 246546073], "D": [246514987, 246516364, 246523834, 246521878, 246527738, 246529658, 246525748, 246524974, 246530714, 246530595, 246536018, 246517832, 246533128, 246527574, 246529579, 246532376, 246528687, 246524837, 246531715, 246527894], "C": [246504265, 246506492, 246509311, 246511086, 246512939, 246522191, 246515413, 246514318, 246521012, 246518198, 246522829, 246597787, 246545456, 246513164, 246517021, 246521174, 246507321, 246517238, 246512362, 246508483, 246515953], "B": [246496908, 246510099, 246501616, 246503108, 246502307, 246506254, 246501930, 246507459, 246501810, 246507250, 246508662, 246503154, 246500767, 246506410, 246511238, 246501517, 246502536, 246501220, 246501502, 246503229], "A": [246490029, 246489425, 246489778, 246493551, 246491292, 246506396, 246489787, 246490848, 246490635, 246492686, 246490767, 246500334, 246491854, 246491116, 246490960, 246489189, 246491592, 246489513, 246489387, 246490308]}, "name": "D. Sasha and a Walk in the City", "statement": "Sasha wants to take a walk with his girlfriend in the city. The city\r\nconsists of n intersections, numbered from 1 to n. Some of them are\r\nconnected by roads, and from any intersection, there is exactly one\r\nsimple path^{\r\ndagger} to any other intersection. In other words, the intersections and\r\nthe roads between them form a tree.Some of the intersections are\r\nconsidered dangerous. Since it is unsafe to walk alone in the city,\r\nSasha does not want to visit three or more dangerous intersections\r\nduring the walk.Sasha calls a set of intersections if the following\r\ncondition is satisfied: If in the city only the intersections contained\r\nin this set are dangerous, then any simple path in the city contains\r\ndangerous intersections.However, Sasha does not know which intersections\r\nare dangerous, so he is interested in the number of different good sets\r\nof intersections in the city. Since this number can be very large,\r\noutput it modulo 998\r\n,244\r\n,353.^{\r\ndagger}A simple path is a path that passes through each intersection at\r\nmost once.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint dp[500005][3];\nint now[4][2],nex[4][2];\nvector<int>v[500005];\nvoid dfs(int x,int f)\n{\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==f)continue;\n\t\tdfs(v[x][i],x);\n\t}\n\tfor(int i=0;i<=2;i++)\n\t{\n\t\tnow[i][0]=now[i][1]=0;\n\t}\n\tnow[0][0]=1;\n\tnow[1][1]=1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==f)continue;\n\t\tfor(int j=0;j<=2;j++)\n\t\t{\n\t\t\tnex[j][0]=nex[j][1]=0;\n\t\t}\n\t\tfor(int j=0;j<=2;j++)\n\t\t{\n\t\t\tfor(int zt=0;zt<=1;zt++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=2;k++)\n\t\t\t\t{\n\t\t\t\t\tif(j+k>2)continue;\n\t\t\t\t\tnex[max(j,k+zt)][zt]=(nex[max(j,k+zt)][zt]+1LL*now[j][zt]*dp[v[x][i]][k])%mod; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=2;j++)now[j][0]=nex[j][0],now[j][1]=nex[j][1];\n\t}\n\tfor(int j=0;j<=2;j++)dp[x][j]=(now[j][0]+now[j][1])%mod;\n\t//printf(\"%d %d %d %d\\n\",x,dp[x][0],dp[x][1],dp[x][2]); \n}\nsigned main()\n{\n\tint t,n,x,y;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t\tdfs(1,0);\n\t\tprintf(\"%lld\\n\",(1LL*dp[1][0]+dp[1][1]+dp[1][2])%mod);\n\t} \n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "math", "trees"], "dificulty": "1900", "interactive": false}