{
    "link": "https://codeforces.com//contest/1516/problem/B",
    "problemId": "963907",
    "problem_idx": "B",
    "shortId": "1516B",
    "contest_number": "1516",
    "problem_submissions": {
        "D": [
            113744317,
            113734893,
            113732174,
            113735658,
            113736689,
            113753948,
            113752217,
            113742709,
            113733277,
            113772079,
            113758509,
            113765675,
            113749541,
            113745751,
            113782529,
            113747411,
            113750921,
            113756461
        ],
        "B": [
            113738828,
            113716225,
            113717222,
            113722044,
            113718441,
            113730595,
            113730731,
            113724024,
            113714979,
            113731503,
            113722149,
            113770715,
            113734481,
            113725894,
            113728293,
            113726022,
            113720823,
            113721935
        ],
        "A": [
            113731086,
            113713802,
            113713787,
            113716079,
            113713803,
            113733865,
            113718261,
            113723529,
            113713794,
            113715315,
            113715862,
            113721754,
            113725712,
            113721388,
            113714099,
            113715023,
            113714544
        ],
        "C": [
            113728258,
            113723880,
            113721257,
            113726835,
            113726539,
            113723017,
            113756433,
            113727327,
            113747091,
            113766829,
            113742469,
            113777547,
            113761975,
            113734529,
            113746406,
            113736795,
            113734065,
            113734539
        ],
        "E": [
            113723992,
            113762256,
            113769222,
            113761842,
            113767857,
            113776100,
            113769406,
            113784620,
            113781943,
            113761572,
            113785543,
            113747187,
            113860370,
            113784367,
            113787186,
            113776311,
            113821800
        ]
    },
    "name": "B. AGAGA XOOORRR",
    "statement": "Baby Ehab is known for his love for a certain operation. He has an array\r\na of length n, and he decided to keep doing the following operation on\r\nit: he picks 2 adjacent elements; he then removes them and places a\r\nsingle integer in their place: their bitwise XOR. Note that the length\r\nof the array decreases by one. Now he asks you if he can make all\r\nelements of the array equal. Since babies like to make your life harder,\r\nhe requires that you leave at least 2 elements remaining.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,k,a[2002],pos;\nint main(){\n\tint t=read();\n\twhile(t--){\n\t\tn=read();\n\t\tre int sum=0;\n\t\tfor(re int i=1;i<=n;++i)a[i]=read(),sum^=a[i];\n\t\tre int s=0;\n\t\tif(sum==0){\n\t\t\tputs(\"YES\");\n\t\t\tcontinue;\n\t\t}\n\t\tre bool ia=1;\n\t\tfor(re int i=1;i<n;++i){\n\t\t\ts^=a[i];\n\t\t\tif(s==sum){\n\t\t\t\tre bool ss=1;\n\t\t\t\tre int r=0;\n\t\t\t\tfor(re int j=n;j>i;--j){\n\t\t\t\t\tr^=a[j];\n\t\t\t\t\tif(r==sum){\n\t\t\t\t\t\tss=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ss)continue;\n\t\t\t\tia=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ia)puts(\"NO\");\n\t\telse puts(\"YES\");\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. AGAGA XOOORRR.json",
    "editorial_link": "https://codeforces.com//blog/entry/89846",
    "editorial": "So letâs try to understand what the final array looks like in terms of\r\nthe initial array. The best way to see this is to look at the process\r\nbackwards. Basically, start with the final array, and keep replacing an\r\nelement with the elements that xor-ed down to it, until you get the\r\ninitial array. Youâll see that the first element turns into a prefix,\r\nthe second element turns into a subarray that follows this prefix, and\r\nso on. Hence, the whole process of moving from the initial to the final\r\narray is like we divide the array into pieces, and then replace each\r\npiece with its xor, and we want these xors to be equal. A nice\r\nobservation is: we need at most pieces. Thatâs because if we have or\r\nmore pieces, we can take pieces and merge them into one. Its xor will be\r\nthe same, but the total piece count will decrease by . Now, checking if\r\nyou can divide it into or pieces is a simple task that can be done by\r\nbruteforce. You can iterate over the positions youâll split the array,\r\nand then check the xors are equal using a prefix-xor array or any other\r\nmethod you prefer. Additional idea: for pieces, you donât even need\r\nbruteforce. Itâs sufficient to check the xor of the whole array is .\r\nHint to see this: write the bruteforce. Code link:\r\nhttps://pastebin.com/tnLpW23C Bonus task: can you find an solution? What\r\nif I tell you at least elements have to remain instead of ?\r\n",
    "hint": []
}