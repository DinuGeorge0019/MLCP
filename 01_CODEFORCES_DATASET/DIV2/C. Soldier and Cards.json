{
    "link": "https://codeforces.com//contest/546/problem/C",
    "problemId": "28217",
    "problem_idx": "C",
    "shortId": "546C",
    "contest_number": "546",
    "problem_submissions": {
        "B": [
            11232801,
            11217801,
            11208207,
            15820713,
            11208988,
            11208163,
            11214179,
            11208024,
            11209235,
            11209062,
            11213108,
            11222587,
            11239965,
            11217308,
            11219421,
            11209692,
            11207894,
            11206528,
            11223244,
            11207437
        ],
        "E": [
            11215556,
            11217224,
            11218687,
            15820839,
            11219998,
            11219690,
            11217920,
            11221959,
            11219074,
            11220044,
            11233270,
            11220684,
            11220215,
            11213115,
            11219305,
            11221891,
            11216762
        ],
        "D": [
            11212652,
            11212575,
            11214113,
            15820823,
            11215486,
            11214182,
            11210539,
            11224701,
            11215757,
            11216672,
            11219688,
            11216346,
            11219045,
            11223515,
            11214913,
            11225307,
            11215385,
            11211036,
            11216929,
            11224645
        ],
        "C": [
            11210837,
            11219636,
            11212924,
            15820760,
            11214060,
            11211479,
            11223248,
            11214103,
            11217677,
            11214503,
            11218679,
            11212971,
            11216434,
            11218455,
            11225176,
            11213620,
            11212347,
            11214814,
            11211103
        ],
        "A": [
            11204918,
            11205173,
            11205306,
            15820687,
            11205477,
            11205623,
            11214865,
            11205868,
            11206683,
            11224290,
            11206459,
            11205182,
            11205880,
            11207069,
            11206553,
            11204997,
            11204938,
            11207566,
            11205034
        ]
    },
    "name": "C. Soldier and Cards",
    "statement": "Two bored soldiers are playing card war. Their card deck consists of\r\nexactly cards, numbered from to , . They divide cards between them in\r\nsome manner, it\u2019s possible that they have different number of cards.\r\nThen they play a \"war\"-like card game. The rules are following. On each\r\nturn a happens. Each of them picks card from the top of his stack and\r\nputs on the table. The one whose card value is bigger wins this and\r\ntakes both cards from the table to the bottom of his stack. More\r\nprecisely, he first takes his opponent\u2019s card and puts to the bottom of\r\nhis stack, and then he puts his card to the bottom of his stack. If\r\nafter some turn one of the player\u2019s stack becomes empty, he loses and\r\nthe other one wins. You have to calculate how many will happen and who\r\nwill win the game, or state that game won\u2019t end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\ntypedef pair<int,int> P;\nset<pair<deque<int>,int> >se;\nint win;\nint go(deque<int>a,deque<int>b,deque<int>c,int t){\n//rep(i,a.size()) cout << a[i] << \" \" ; cout << endl;\n\tif(se.find(make_pair(c,a.size())) != se.end()) return -1;\n\tse.insert(make_pair(c,a.size()));\n\tif(a.empty()){\n\t\twin = 2; return t;\n\t}\n\tif(b.empty()){\n\t\twin = 1; return t;\n\t}\n\tint x = a[0];\n\tint y = b[0];\n\tif(x < y){\n\t\ta.pop_front(); b.pop_front();\n\t\tb.push_back(x); b.push_back(y);\n\t\t//swap(b[b.size()-2],b[b.size()-1]);\n\t}\n\telse{\n\t\tb.pop_front(); a.pop_front();\n\t\ta.push_back(y); a.push_back(x);\n\t\t//swap(a[a.size()-2],a[a.size()-1]);\n\t}\n\tdeque<int>C;\n\trep(i,a.size()) C.push_back(a[i]);\n\trep(i,b.size()) C.push_back(b[i]);\n\treturn go(a,b,C,t+1);\n}\nint main(){\n    int n;\n    deque<int>va,vb,vc;\n    cin >> n;\n    int a; cin >> a; \n    rep(i,a){\n    \tint x; cin >> x; va.push_back(x); vc.push_back(x);\n    }\n    int b; cin >> b; \n    rep(i,b){\n    \tint x; cin >> x; vb.push_back(x); vc.push_back(x);\n    }\n    int p = go(va,vb,vc,0);\n    if(p==-1) cout << -1 << endl;\n    else cout << p << \" \" << win << endl;\n   }"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "games"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Soldier and Cards.json",
    "editorial_link": "https://codeforces.com//blog/entry/18034",
    "editorial": "It's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?\n\nFirstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n?+?1 places (because we can count the before and after deck case too).\n\nSo war has (n?+?1)! states. If we'd do (n?+?1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.\n\nAfter checking this game more accurately I can say that the longest path in the state-graph for n?=?10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.\n\nAlternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast."
}