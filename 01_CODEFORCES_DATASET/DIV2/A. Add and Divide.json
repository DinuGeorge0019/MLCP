{
    "link": "https://codeforces.com//contest/1485/problem/A",
    "problemId": "893884",
    "problem_idx": "A",
    "shortId": "1485A",
    "contest_number": "1485",
    "problem_submissions": {
        "F": [
            107209277,
            107219103,
            108814340,
            107211258,
            107197599,
            107216697,
            107217119,
            107223985,
            107214681,
            107225337,
            107211172,
            107212087,
            107214541,
            107225911,
            107220634,
            107211306,
            107210013,
            107218638,
            107648531,
            107215873,
            107226560
        ],
        "E": [
            107206284,
            107213007,
            108814429,
            107225053,
            107217938,
            107209463,
            107222855,
            107215802,
            107226662,
            107217485,
            107225279,
            107225123,
            107220161,
            107219375,
            107225854,
            107230167,
            107219696,
            107215124
        ],
        "C": [
            107199370,
            107197518,
            107195894,
            107212349,
            107194668,
            107198452,
            107203154,
            107405885,
            107204141,
            107200897,
            107195457,
            107204332,
            107206480,
            107202401,
            107199135,
            107196987,
            107201461,
            107206165,
            107648559,
            107207854,
            107199515
        ],
        "D": [
            107198594,
            107202657,
            108814890,
            107201144,
            107221310,
            107222056,
            107207281,
            107209220,
            107207652,
            107242764,
            107209063,
            107227592,
            107218419,
            107224633,
            107210347,
            107214905,
            107204658,
            107199967,
            107648549,
            107199904,
            107235149
        ],
        "B": [
            107193807,
            107194488,
            107194267,
            107201652,
            107196319,
            107195681,
            107197432,
            107195701,
            107196325,
            107193269,
            107196934,
            107197687,
            107195885,
            107193973,
            107195238,
            107214292,
            107194216,
            107202326,
            107195370
        ],
        "A": [
            107192260,
            107192259,
            107192294,
            107199267,
            107192201,
            107192549,
            107194901,
            107192510,
            107192573,
            107192159,
            107193301,
            107195540,
            107193638,
            107192240,
            107193340,
            107196993,
            107192336,
            107193653,
            107192814
        ]
    },
    "name": "A. Add and Divide",
    "statement": "You have two positive integers a and b.You can perform two kinds of\r\noperations: a =\r\nlfloor\r\nfrac{a}{b}\r\nrfloor (replace a with the integer part of the division between a and b)\r\nb=b+1 (increase b by 1) Find the minimum number of operations required\r\nto make a=0.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint t,x,y,ans;\nint get(int x,int y){\n\tif(y==1) return orz;\n\tint cnt=0;\n\twhile(x)x/=y,++cnt;\n\treturn cnt;\n}\nint main(){\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tans=orz;\n\t\tfor(int i=0;i<ans;++i)ans=min(ans,i+get(x,y+i));\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Add and Divide.json",
    "editorial_link": "https://codeforces.com//blog/entry/87470",
    "editorial": "SolutionNotice how it is never better to increase after dividing ().So\r\nwe can try to increase to a certain value and then divide by until it is\r\n. Being careful as not to do this with , the number of times we divide\r\nis going to be . In particular, if you reach (this requires at most\r\nmove), you need at most moves to finish.Let be the number of moves of\r\ntype ; we can try all values of () and, for each , check how many moves\r\nof type are necessary.Complexity: .If we notice that it is never\r\nconvenient to increase over , we can also achieve a solution with better\r\ncomplexity.\r\n"
}