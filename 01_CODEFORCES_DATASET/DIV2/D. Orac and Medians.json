{
    "link": "https://codeforces.com//contest/1350/problem/D",
    "problemId": "619074",
    "problem_idx": "D",
    "shortId": "1350D",
    "contest_number": "1350",
    "problem_submissions": {
        "E": [
            79855181,
            79866892,
            79867578,
            79860431,
            79865664,
            79871653,
            79862377,
            79873286,
            79855797,
            79870095,
            79877566,
            79875250,
            79879082,
            79877229,
            79874099,
            79876185,
            79865098,
            79874891,
            79878375
        ],
        "D": [
            79841799,
            79863715,
            79838223,
            79843636,
            79845619,
            79851762,
            79859376,
            79851422,
            79856645,
            79867069,
            79852959,
            79854133,
            79862270,
            79854555,
            79857955,
            79860745,
            79863550,
            79877253,
            79858065,
            79853653
        ],
        "C": [
            79826908,
            79832989,
            79819179,
            79836044,
            79829980,
            79835199,
            79827905,
            79823236,
            79839284,
            79843003,
            79842971,
            79842595,
            79842398,
            79842899,
            79841428,
            79836029,
            79843846,
            79828517,
            79847123,
            79843527
        ],
        "B": [
            79820647,
            79822816,
            79842662,
            79823960,
            79824033,
            79823709,
            79822810,
            79820992,
            244797086,
            79824014,
            79827065,
            79834456,
            79825730,
            79829712,
            79832808,
            79831732,
            79824775,
            79833342,
            79819486,
            79827690,
            79827705
        ],
        "A": [
            79816852,
            79817819,
            79835688,
            79816825,
            79817311,
            79817807,
            79817556,
            79817787,
            79817609,
            79823750,
            79829915,
            79816664,
            79822342,
            79821478,
            79817922,
            79818871,
            79819448,
            79816826,
            79818898,
            79816798
        ],
        "F": [
            79877945
        ]
    },
    "name": "D. Orac and Medians",
    "statement": "Slime has a sequence of positive integers a_1, a_2,\r\nldots, a_n.In one operation Orac can choose an arbitrary subsegment [l\r\nldots r] of this sequence and replace all values a_l, a_{l + 1},\r\nldots, a_r to the value of median of\r\n{a_l, a_{l + 1},\r\nldots, a_r\r\n}.In this problem, for the integer multiset s, the median of s is equal\r\nto the\r\nlfloor\r\nfrac{|s|+1}{2}\r\nrfloor-th smallest number in it. For example, the median of\r\n{1,4,4,6,5\r\n} is 4, and the median of\r\n{1,7,5,8\r\n} is 5.Slime wants Orac to make a_1 = a_2 =\r\nldots = a_n = k using these operations.Orac thinks that it is\r\nimpossible, and he does not want to waste his time, so he decided to ask\r\nyou if it is possible to satisfy the Slime’s requirement, he may ask you\r\nthese questions several times.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define N 100010\nusing namespace std;\nint t,n,k,a[N];\nbool ans;\nint main(){\n\tcin>>t;\n\twhile (t--){\n\t\tcin>>n>>k;ans=0;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tcin>>a[i];\n\t\t\tif (a[i]==k)ans=1;\n\t\t\tif (a[i]>=k)a[i]=1;else a[i]=0;\n\t\t}\n\t\tif (!ans)puts(\"no\");\n\t\telse{\n\t\t\ta[n+1]=a[n+2]=0;\n\t\t\tfor (int i=1;i<=n;i++)if (a[i]&&(a[i+1]|a[i+2]))ans=0;\n\t\t\tif (n==1&&a[1])ans=0;\n\t\t\tif (ans)puts(\"no\");else puts(\"yes\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Orac and Medians.json",
    "editorial_link": "https://codeforces.com//blog/entry/77284",
    "editorial": "Let Bi=???0,Ai<k1,Ai=k2,Ai>k\n?then just consider whether it can be done to make all elements in B\n become 1\n in a finite number of operations.\n\nIt can be proved that a solution exists if and only if ?1?i?n,s.t.Bi=1\n and ?1?i<j?n,s.t.j?i?2,Bi>0,Bj>0\n .\n\nThe necessity is obvious: if ?1?i?n,Bi?1\n , no elements in B\n can be transformed into 1\n; If there are at least two zeros between any two positive numbers, then the median of each interval equals to 0\n, no solution exists.\n\nConsider the sufficiency. If there are two adjacent elements in B\n both equals to 1\n , just select an interval which contains at least three elements and exact one element unequal to 1\n , and operate once on this interval. After this operation, there are still two adjacent elements in B\n both equals to 1\n, so we keep doing this until all elements are transformed into 1\n.\n\nTherefore, if there is a interval [l,r]\n which satisfies r?l+1?2\n and the median of {Bl,Bl+1,,Br}\n equals to 1\n, just perform an operation on [l,r]\n , then use the above strategy. It can be shown that such an interval can always be created in several operations with the condition.\n\nIf an interval [i,i+2]\n satisfies {Bi,Bi+1,Bi+2}={0,1,2}\n or {1,1,2}\n or {0,1,1}\n or {1,1,1}\n?just perform an operation on [i,i+2]\n .\nIf [i,i+2]\n satisfies {Bi,Bi+1,Bi+2}={1,2,2}\n , then {Bi,Bi+1}={1,2}\n or {Bi+1,Bi+2}={1,2}\n . Perform an operation on [i,i+1]\n or [i+1,i+2]\n .\nIf any interval with three elements doesn't satisfy the above conditions, because ?1?i<j?n,s.t.j?i?2,Bi>0,Bj>0\n ?there is an interval [i,i+2]\n which satisfies {Bi,Bi+1,Bi+2}={0,2,2}\n or {2,2,2}\n . Take such an interval [i,i+2]\n , perform an operation on [i,i+2]\n first, then select an interval which contains at least three elements and exact one element unequal to 2\n until two adjacent numbers equals to 1\n and 2\n respectively. Perform one operation on these two adjacent elements.\nTherefore, the sufficiency is proved. So just check whether there is an element in B\n equals to 1\n, and whether there is a pair of two positive integers (i,j)\n which satisfies 1?j?i?2,Bi>0,Bj>0\n . The complexity is O(n)\n.",
    "hint": []
}