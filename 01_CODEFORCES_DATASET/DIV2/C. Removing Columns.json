{
    "link": "https://codeforces.com//contest/496/problem/C",
    "problemId": "19578",
    "problem_idx": "C",
    "shortId": "496C",
    "contest_number": "496",
    "problem_submissions": {
        "D": [
            9176843,
            9169490,
            9172648,
            9169938,
            9173192,
            9179837,
            9174502,
            9174977,
            9172607,
            9170640,
            9175019,
            9174412,
            9173755,
            9175240,
            9175102,
            9175021,
            9194689,
            9175370
        ],
        "E": [
            9173226,
            9193133,
            9174734,
            14339417,
            9237849,
            9178765,
            9188533,
            9194680
        ],
        "C": [
            9169367,
            9166605,
            9167404,
            9165048,
            9168057,
            9167727,
            9166806,
            9167081,
            9169029,
            9167067,
            9167500,
            9168857,
            9168096,
            9168403,
            9167842,
            9167765,
            9194690,
            9167905
        ],
        "B": [
            9165977,
            9165371,
            9165516,
            9171586,
            9164457,
            9164520,
            9165537,
            9165229,
            9167890,
            9173609,
            9166677,
            9165999,
            9166755,
            9166602,
            9165952,
            9165871,
            9194688,
            9168604
        ],
        "A": [
            9164610,
            9164035,
            9164187,
            9170696,
            9163931,
            9163962,
            9163896,
            9164249,
            9166611,
            9174109,
            9164186,
            9164233,
            9164281,
            9163978,
            9164264,
            9163934,
            9194687,
            9165603
        ]
    },
    "name": "C. Removing Columns",
    "statement": "You are given an rectangular table consisting of lower case English\r\nletters. In one operation you can completely remove one column from the\r\ntable. The remaining parts are combined forming a new table. For\r\nexample, after removing the second column from the tableabcdedfghijk we\r\nobtain the table:acdefghjk A table is called if its rows are ordered\r\nfrom top to bottom lexicographically, i.e. each row is lexicographically\r\nno larger than the following one. Determine the minimum number of\r\noperations of removing a column needed to make a given table good.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nbool b[2000];\nstring t[2000];\nvector <int> l;\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"a.txt\", \"w\", stdout);\n    int n, m;\n    cin >> n >> m;\n    memset(b, 0, sizeof b);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> t[i];\n    }\n    int ans = 0;\n    for (int j = 0; j < m; j++)\n    {\n        l.clear();\n        bool er = false;\n        for (int i = 1; i < n; i++)\n        {\n            if (!b[i] && (t[i][j] - 'a') < (t[i - 1][j] - 'a'))\n            {\n                ans++;\n                er = true;\n                break;\n            }\n            else if (!b[i] && (t[i][j] - 'a') > (t[i - 1][j] - 'a'))\n            {\n                l.push_back(i);\n            }\n        }\n        if (er == false)\n        {\n            for (int x = 0; x < l.size(); x++)\n            {\n                b[l[x]] = true;\n            }\n        }\n    }\n    cout << ans << endl;\n    //system(\"pause\");\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Removing Columns.json",
    "editorial_link": "https://codeforces.com//blog/entry/15208",
    "editorial": "Let\u00e2\u0080\u0099s look at the first column of the table. If its letters are not\r\nsorted alphabetically, then in any valid choice of removing some columns\r\nit has to be removed. However, if its letters are sorted, then for every\r\nvalid choice that has this column removed it can be restored back to the\r\ntable; it is clear that the new choice is valid (that is, the rows of\r\nthe new table are sorted lexicographically) and the answer (that is, the\r\nnumber of removed columns) has just became smaller. Consider all columns\r\nfrom left to right. We have already chosen which columns to remove among\r\nall the columns to the left of the current one; if leaving the current\r\ncolumn in place breaks the lexicographical order of rows, then we have\r\nto remove it; otherwise, we may leave it in place to no harm. Arguing in\r\nthe way of the previous paragraph we can prove that this greedy method\r\nyields an optimal (moreover, the only optimal) solution. The complexity\r\nis . Challenge: compute how many (say, modulo ) tables are there for\r\nwhich the answer for this problem is ? The more efficient solution you\r\ncome up with, the better.\r\n"
}