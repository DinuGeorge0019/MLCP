{"link": "https://codeforces.com//contest/733/problem/F", "problemId": "78302", "problem_idx": "F", "shortId": "733F", "contest_number": "733", "problem_submissions": {"F": [21944181, 21943396, 21967823, 21944382, 21944760, 21938912, 21991227, 22059840, 21937562, 21938035, 21985645, 21991821, 21953425, 22015051, 21990688], "E": [21937191, 21938008, 21943531, 21943185, 21953321, 21943118, 21945071, 21961545], "D": [21929126, 21923181, 21934246, 21934699, 21930359, 21930083, 21921931, 21937281, 21933013, 21933051, 21930915, 21933717, 21930137, 21931610, 21929842, 21935332, 21929335, 21936423, 21930780, 21933993], "C": [21927957, 21950571, 21931020, 21929401, 21936037, 21935885, 21953665, 21934528, 21938848, 21929683, 21937215, 21940711, 21934393, 21928582, 21934351, 21931346, 21936860, 21931930], "B": [21922288, 21927937, 21923164, 21922462, 21923910, 21924025, 21925504, 21933294, 21928279, 21922570, 21924161, 21922272, 21921961, 21923577, 21924912, 21921350, 21922700, 21923311, 21923198, 21925029], "A": [21919764, 21920167, 21920208, 21919696, 21920676, 21920418, 21919388, 21932202, 21929074, 21920399, 21925006, 21920161, 21919497, 21919471, 21922256, 21919494, 21926774, 21920063, 21919707, 21927283]}, "name": "F. Drivers Dissatisfaction", "statement": "In one kingdom there are cities and two-way roads. Each road connects a\r\npair of cities, and for each road we know the level of drivers\r\ndissatisfaction the value .For each road we know the value how many\r\nlamziks we should spend to reduce the level of dissatisfaction with this\r\nroad by one. Thus, to reduce the dissatisfaction with the -th road by ,\r\nwe should spend lamziks. And .In accordance with the king\u2019s order, we\r\nneed to choose roads and make them the . An important condition must\r\nhold: it should be possible to travel from any city to any other by the\r\n.The road ministry has a budget of lamziks for the reform. The ministry\r\nis going to spend this budget for repair of some roads (to reduce the\r\ndissatisfaction with them), and then to choose the .Help to spend the\r\nbudget in such a way and then to choose the main roads so that the total\r\ndissatisfaction with the will be as small as possible. The\r\ndissatisfaction with some roads can become negative. It is not necessary\r\nto spend whole budget .It is guaranteed that it is possible to travel\r\nfrom any city to any other using existing roads. Each road in the\r\nkingdom is a two-way road.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define P(x,y) make_pair(x,y)\nusing namespace std;\nconst int MX=(1<<18) , MXL=18;\nint sz[MX] , P[MX] , val[MX];\nvoid init(int N){\n    for(int j=1;j<=N;j++)\n        sz[j]=1 , P[j]=j;\n}\nint find_(int x){\n    if(x!=P[x]) P[x]=find_(P[x]);\n    return P[x];\n}\nbool merge_(int x , int y){\n    int px=find_(x) , py=find_(y);\n    if(px==py) return false;\n    if(sz[px] < sz[py]) swap(px , py);\n    P[py]=px;\n    sz[px]+=sz[py];\n    return true;\n}\nint n , QN , m ;\nint depth[MX] , dp[MXL][MX] , par[MXL][MX];\nvector < pair < int ,int > > v[MX];\nvoid Pdfs(int x , int p){\n    int nxt , C , sz=v[x].size();\n    for(int j=0;j<sz;j++){\n        nxt=v[x][j].first , C=v[x][j].second;\n        if(nxt == p) continue;\n        depth[nxt]=depth[x]+1;\n        par[0][nxt]=x;\n        dp[0][nxt]=C;\n        Pdfs(nxt , x);\n    }\n}\nint Merge(int a , int b){\n    if(a == -1) return b;\n    if(b == -1) return a;\n    if(val[a] > val[b]) return a;\n    else return b;\n}\nvoid process(){\n    for(int j=1;j<MXL;j++)\n        for(int i=1;i<=n;i++){\n            par[j][i]=par[j-1][par[j-1][i]];\n            dp[j][i]=Merge(dp[j-1][i] , dp[j-1][par[j-1][i]]);\n        }\n}\nint Kth(int x , int K){\n    int node=x;\n    for(int j=0;j<MXL;j++)\n        if((K&(1<<j)))\n           node=par[j][node];\n    return node;\n}\nint LCA(int a , int b){\n    if(a==b) return a;\n    if(depth[a] > depth[b]) swap(a , b);\n    b=Kth(b , depth[b]-depth[a]);\n    if(a==b) return b;\n    for(int j=MXL-1;j>=0;j--)\n        if(par[j][a] != par[j][b])\n            a=par[j][a] , b=par[j][b];\n    return par[0][a];\n}\nint solve(int node , int K){\n    int ret=-1;\n    for(int j=0;j<MXL;j++){\n        if( (K&(1<<j)) == 0) continue;\n        ret=Merge(ret , dp[j][node]);\n        node=par[j][node];\n    }\n    return ret;\n}\nint query(int a , int b){\n    int lca=LCA(a , b);\n    return Merge(solve(a , depth[a]-depth[lca]) , solve(b , depth[b]-depth[lca]));\n}\npair < pair < int , int > , int > E[MX];\nstring sol;\nbool inmst[MX];\nlong long mst = 0;\nstruct Edge{\n    int cost , u , v , dec , idx;\n    Edge(){}\n    Edge(int cost , int u , int v , int dec , int idx):cost(cost) , u(u) , v(v) , dec(dec) , idx(idx){}\n}edge[MX];\nbool operator < (const Edge&A , const Edge&B){\n    return A.cost < B.cost;\n};\nint main(){\n    scanf(\"%d %d\",&n,&m);\n    memset(dp , -1 , sizeof(dp));\n    init(n);\n    for(int j=1;j<=m;j++){\n        scanf(\"%d\",&val[j]);\n        edge[j].cost = val[j];\n        edge[j].idx = j;\n    }\n    for(int j=1;j<=m;j++) scanf(\"%d\",&edge[j].dec);\n    for(int j=1;j<=m;j++) scanf(\"%d %d\",&edge[j].u,&edge[j].v);\n    sort(edge + 1 , edge + 1 + m);\n    long long mstcost = 0;\n    for(int j=1;j<=m;j++){\n        if(merge_(edge[j].u , edge[j].v)){\n            mstcost += edge[j].cost;\n            v[edge[j].u].push_back({edge[j].v , edge[j].idx});\n            v[edge[j].v].push_back({edge[j].u , edge[j].idx});\n            inmst[edge[j].idx] = 1;\n        }\n    }\n    int budget;\n    scanf(\"%d\",&budget);\n    depth[1] = 1; Pdfs(1 , -1);\n    process();\n    long long ans = mstcost , nak7 = -1 , mnko7 = -1;\n    for(int j=1;j<=m;j++){\n        int idx = edge[j].idx;\n        if(inmst[idx]){\n            long long theta = mstcost - budget / edge[j].dec;\n            if(theta < ans){\n                ans = theta;\n                nak7 = idx;\n                mnko7 = -1;\n            }\n        }\n        else{\n            long long theta = mstcost;\n            int ee = query(edge[j].u , edge[j].v);\n            theta -= val[ee];\n            theta += edge[j].cost;\n            theta -= budget/edge[j].dec;\n            if(theta < ans){\n                ans = theta;\n                nak7 = idx;\n                mnko7 = ee;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    for(int j=1;j<=m;j++){\n        int idx = edge[j].idx;\n        if(inmst[idx]){\n            if(nak7 == idx) edge[j].cost -= budget/edge[j].dec;\n            if(mnko7 != idx) printf(\"%d %d\\n\",idx,edge[j].cost);\n        }\n        else{\n            if(nak7 == idx){\n                edge[j].cost -= budget/edge[j].dec;\n                printf(\"%d %d\\n\",idx,edge[j].cost);\n            }\n        }\n    }\n\n}\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "graphs", "trees"], "dificulty": "2200", "interactive": false}