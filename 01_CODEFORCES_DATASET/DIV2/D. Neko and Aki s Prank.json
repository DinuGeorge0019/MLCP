{
    "link": "https://codeforces.com//contest/1152/problem/D",
    "problemId": "335383",
    "problem_idx": "D",
    "shortId": "1152D",
    "contest_number": "1152",
    "problem_submissions": {
        "C": [
            53244845,
            53230927,
            53233766,
            53235808,
            53234198,
            53234839,
            53238158,
            53233895,
            53244428,
            53238661,
            53245124,
            53237428,
            53241947,
            53255111,
            53240873,
            53232261,
            53233767,
            53232829
        ],
        "E": [
            53239734,
            53245640,
            53249082,
            53237299,
            53252319,
            53253962,
            53269982,
            53253449,
            53252636,
            53255804,
            53252841,
            53252353,
            53235804,
            53253519,
            53250724,
            53255613,
            53476482
        ],
        "D": [
            53233906,
            53239025,
            53240632,
            53250831,
            53239012,
            53242704,
            53250969,
            53239158,
            53239278,
            53243068,
            53249440,
            53254093,
            53239872,
            53249862,
            53242480,
            53247260,
            53236086,
            53237628,
            53240315
        ],
        "B": [
            53229253,
            53234506,
            53230572,
            53231304,
            53231144,
            53231405,
            53233565,
            53231636,
            53233110,
            53231852,
            53233634,
            53233426,
            53232376,
            53236011,
            53235559,
            53230731,
            53230129,
            53231640,
            53230247
        ],
        "A": [
            53226242,
            53226637,
            53226146,
            53227612,
            53226534,
            53227116,
            53228309,
            53228363,
            53226234,
            53226947,
            53228169,
            53229011,
            53227021,
            53226493,
            53226176,
            53226318,
            53226306,
            53226785
        ],
        "F2": [
            53255434,
            139447309
        ],
        "F1": [
            53255396
        ]
    },
    "name": "D. Neko and Aki s Prank",
    "statement": "Neko is playing with his toys on the backyard of Aki’s house. Aki\r\ndecided to play a prank on him, by secretly putting catnip into Neko’s\r\ntoys. Unfortunately, he went overboard and put an entire bag of catnip\r\ninto the toys...It took Neko an entire day to turn back to normal. Neko\r\nreported to Aki that he saw a lot of weird things, including a trie of\r\nall correct bracket sequences of length 2n.The definition of correct\r\nbracket sequence is as follows: The empty sequence is a correct bracket\r\nsequence, If s is a correct bracket sequence, then (\r\n,s\r\n,) is a correct bracket sequence, If s and t are a correct bracket\r\nsequence, then st is also a correct bracket sequence. For example, the\r\nstrings \"\", \"\" form a correct bracket sequence, while \"\" and \"\" not.Aki\r\nthen came up with an interesting problem: What is the size of the\r\nmaximum matching (the largest set of edges such that there are no two\r\nedges with a common vertex) in this trie? Since the answer can be quite\r\nlarge, print it modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000000007 \n#define N 1005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nint n;\npair<int,bool> dp[N][N<<1];\nint vis[N][N<<1];\n\nint add(int x,int y) {\n\n\tx+=y;\n\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n\n\treturn x;\n\n}\n\nvoid dfs(int bal,int rem) {\n\n\tif(bal-rem>0) return ;\n\n\tif(rem==0) {\n\n\t\tdp[bal][rem]={0,1};\n\n\t\treturn ;\n\n\t}\n\n\tif(vis[bal][rem]) return ;\n\n\tvis[bal][rem]=1;\n\n\tdp[bal][rem].nd=1;\n\n\tif(bal) {\n\n\t\tdfs(bal+1,rem-1);\n\t\tdfs(bal-1,rem-1);\n\n\t\tdp[bal][rem].st=add(dp[bal][rem].st,add(dp[bal+1][rem-1].st,dp[bal-1][rem-1].st));\n\n\t\tif(dp[bal-1][rem-1].nd || dp[bal+1][rem-1].nd) {\n\n\t\t\tdp[bal][rem].st=add(dp[bal][rem].st,1);\n\n\t\t\tdp[bal][rem].nd=0;\n\n\t\t}\n\n\t}\n\telse {\n\n\t\tdfs(bal+1,rem-1);\n\n\t\tdp[bal][rem].st=add(dp[bal][rem].st,dp[bal+1][rem-1].st);\n\n\t\tif(dp[bal+1][rem-1].nd) {\n\n\t\t\tdp[bal][rem].st=add(dp[bal][rem].st,1);\n\n\t\t\tdp[bal][rem].nd=0;\n\n\t\t}\n\n\t}\n\n}\n\nint main() {\n\n\tscanf(\"%d\",&n);\n\n\tdfs(1,2*n-1);\n\n\tprintf(\"%d\",dp[1][2*n-1].st);\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Neko and Aki s Prank.json",
    "editorial_link": "https://codeforces.com/blog/entry/66696",
    "editorial": "Note, that many subtrees of the trie are equal. Basically, if we\r\nconsider two vertices on the same depth and having the same balance from\r\nroot to them (that is, the number of opening brackets minus the number\r\nof closing brackets), than their subtrees will be entirely same. For\r\nexample, the subtrees after following , and are all the same.We will use\r\nthis observation to consider the tree in \"compressed\" form. Clearly,\r\nthis way there are only different vertices types (basically a vertex is\r\ndescribed by ).Now letâs get back to finding a maximum matching in the\r\ntree. There are two approaches to this problem. One of them is greedy.\r\nBasically if you find a matching in a tree you can always greedily take\r\nthe edge between a leaf and its parent (since this adds one edge to the\r\nanswer and destroys at most one edge you wouldâve chosen).This idea can\r\ntransform into the following algorithm (for the problem of the maximum\r\nmatching in the tree). Do a dynamic programming on the subtrees, the\r\nresult of is a pair of \"number of edges taken in subtree, whether the\r\nroot of this subtree is free (so we can start a new edge\r\nupwards)\".Combining this with the idea that there are little () number\r\nof vertex types, we get a dp solution.\r\n",
    "hint": []
}