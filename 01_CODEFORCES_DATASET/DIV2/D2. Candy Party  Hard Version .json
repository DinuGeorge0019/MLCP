{
    "link": "https://codeforces.com//contest/1869/problem/D2",
    "problemId": "2184995",
    "problem_idx": "D2",
    "shortId": "1869D2",
    "contest_number": "1869",
    "problem_submissions": {
        "E": [
            222790733,
            222755919,
            223014703,
            222844888,
            222822436,
            222820168
        ],
        "D2": [
            222751076,
            222765748,
            222762229,
            222767685,
            222770713,
            222771349,
            222774390,
            222781618,
            222778821,
            222788639,
            222773236,
            222775336,
            222775900,
            222778257,
            222775220,
            222773627,
            222771492
        ],
        "D1": [
            222743411,
            222768273,
            222754309,
            222754872,
            222757370,
            222757211,
            222762465,
            222761473,
            222755833,
            222757091,
            222752420,
            222764925,
            222765023,
            222761868,
            222761450,
            222761828,
            222765878,
            222760854
        ],
        "C": [
            222734213,
            222799024,
            222739072,
            222743933,
            222748797,
            222742198,
            222748357,
            222740791,
            222743470,
            222743624,
            222737636,
            222744668,
            222749662,
            222742346,
            222741675,
            222752222,
            222753724,
            222751049
        ],
        "B": [
            222728831,
            222759638,
            222728679,
            222733793,
            222732869,
            222730403,
            222734827,
            222731660,
            222733775,
            222732224,
            222728510,
            222735540,
            222734578,
            222733639,
            222729850,
            222736886,
            222733662,
            222738397
        ],
        "A": [
            222725390,
            222757999,
            222725599,
            222726282,
            222727750,
            222725856,
            222726824,
            222727514,
            222730110,
            222726868,
            222725449,
            222728462,
            222727639,
            222725642,
            222725871,
            222727421,
            222725878,
            222731354
        ],
        "F": [
            223418170
        ]
    },
    "name": "D2. Candy Party  Hard Version ",
    "statement": "After Zhongkao examination, Daniel and his friends are going to have a\r\nparty. Everyone will come with some candies.There will be n people at\r\nthe party. Initially, the i-th person has a_i candies. During the party,\r\nthey will swap their candies. To do this, they will line up and everyone\r\nwill do the following : Choose an integer p (1\r\nle p\r\nle n) and a integer x, then give his 2^{x} candies to the p-th person.\r\nNote that one give more candies than currently he has (he might receive\r\ncandies from someone else before) and he give candies to himself. Daniel\r\nlikes fairness, so he will be happy if and only if everyone receives\r\ncandies from . Meanwhile, his friend Tom likes average, so he will be\r\nhappy if and only if all the people have the same number of candies\r\nafter all swaps.Determine whether there exists a way to swap candies, so\r\nthat both Daniel and Tom will be happy after the swaps.\r\n",
    "solutions": [
        "// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2\")\n#include <bits/stdc++.h>\n#define int long long\n#define i64 long long\n#define pii pair <int, int> \nusing namespace std;\ninline int read(void) {\n    int x=0,sgn=1; char ch=getchar();\n    while(ch<48||57<ch) {if(ch==45)sgn=0;ch=getchar();}\n    while(47<ch&&ch<58) {x=x*10+ch-48;   ch=getchar();}\n    return sgn? x:-x;\n}\nvoid write(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\n#define lowbit(x) (x&(-x))\nint n,sum,avg;\nint a[200005];\nint cnt[40],cnt2[40];\ninline int f(int x) { return __builtin_ctzll(x); }\ninline void work() {\n    n=read(); sum=0;\n    memset(cnt,0,sizeof cnt);\n    memset(cnt2,0,sizeof cnt2);\n    for(int i=1; i<=n; ++i) sum+=(a[i]=read());\n    if(sum%n) return puts(\"No\"),void();\n    avg=sum/n;\n    for(int i=1; i<=n; ++i) {\n        int del=abs(a[i]-avg);\n        if(del==0) continue;\n        if(lowbit(del)==del) {\n            if(a[i]<avg) ++cnt[f(del)+1],--cnt[f(del)];\n            else         --cnt[f(del)];\n            ++cnt2[f(del)];\n            continue;\n        }\n        int cur=del+lowbit(del);\n        if(lowbit(cur)!=cur) return puts(\"No\"),void();\n        if(a[i]<avg) cnt[f(cur)]++,cnt[f(lowbit(del))]--;\n        else cnt[f(lowbit(del))]++,cnt[f(cur)]--;\n    }\n    for(int i=35; i>=1; --i) if(cnt[i]!=0) {\n        if(cnt[i]<0||cnt[i]>cnt2[i-1]) return puts(\"No\"),void();\n        cnt[i-1]+=2*cnt[i];\n        cnt[i]=0;\n    }\n    if(cnt[0]!=0) return puts(\"No\"),void();\n    else return puts(\"Yes\"),void();\n}\nsigned main() {\n    int T=read();\n    while(T--) work();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. Candy Party  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116642",
    "editorial": "Read the tutorial for D1 first.\n\nConsider the graph we built in this version. It should only consist of chains and cycles.\n\nFor the start nodes of chains and the end nodes of chains, |ai?s|=2d\n must hold.\n\nThus, for |ai?s|?2d\n, we sill have only one way to decide the number of candies given away and received (the same as D1). However, for |ai?s|=2d\n, we have two ways:\n\nthe same way as D1 (use the equation ai?2xi+2yi=s\n);\nlet this person be the start or end node of chains, that is, ai?2xi=s\n or ai?2xi=s\n. (Suppose 2xi\n is the number of candies he gives away or receives)\nAgain, let's omit those nodes with |ai?s|=2d\n first. Then we can similarly maintain two sets S\n and T\n to D1.\n\nLet cntSi\n be the number of i\n-s in set S\n and cntTi\n be the number of i\n-s in T\n. Note that now we omit nodes with |s?ai|=2d\n when maintaining both sets.\n\nLet cntDSk\n be the number of nodes with ai?s=2k\n and cntDTi\n be the number of nodes with s?ai=2k\n.\n\nFor nodes with |ai?s|=2xi\n, the two ways are:\n\nai?2xi=s\n, or ai+2xi=s\n;\nai+2xi?2xi+1=s\n, or ai?2xi?1+2xi\n.\nTo make the two sets S\n and T\n equal, we must make cntSk=cntTk\n for all 0?k?30\n.\n\nNow consider nodes with |ai?s|=2d\n. We can determine bit-by-bit. Let's start from the first bit.\n\nConsider cntDSi\n: if we choose x?cntDSi\n elements to use the first way, then:\n\ncntSi:=cntSi+x\n;\ncntSi+1:=cntSi+1+x\n;\ncntTi:=cntTi+(cntDSi?x)\n.\nConsider cntDTi\n: if we choose x?cntDTi\n elements to use the first way, then:\n\ncntTi:=cntTi+x\n;\ncntTi?1:=cntTi?1+x\n;\ncntTi:=cntTi+(cntDTi?x)\n.\nLet's consider the highest bit. All elements in cntDSi\n must be chosen the second way (x=0\n), otherwise, it will influence cntSi+1\n. Then we can determine the x\n for cntDTi\n, then cntDSi?1,cntDTi?1,...,cntDS0,cntDT0\n.\n\nAt last, we check if cntS0=cntT0\n (we have made cntSi=cntTi\n for all i>0\n). If so, the answer is \"Yes\", otherwise the answer is \"No\".",
    "hint": []
}