{
    "link": "https://codeforces.com//contest/404/problem/C",
    "problemId": "7290",
    "problem_idx": "C",
    "shortId": "404C",
    "contest_number": "404",
    "problem_submissions": {
        "B": [
            6081380,
            6071583,
            6070927,
            6071339,
            6070454,
            6070614,
            6072572,
            6071620,
            6071224,
            6072980,
            6072201,
            6072080,
            6071625,
            6070557,
            6072898,
            6071106,
            6072617,
            6072939
        ],
        "A": [
            6081009,
            6068298,
            6068430,
            6069127,
            6068593,
            6068443,
            6069041,
            6068506,
            6069739,
            6068994,
            6068641,
            6068845,
            6068699,
            6071140,
            6069542,
            6069802,
            6068288
        ],
        "E": [
            6077708,
            6078243,
            6080273,
            6089004,
            6098326,
            6095224,
            6104347
        ],
        "D": [
            6074157,
            6076415,
            6075648,
            6078211,
            6077330,
            6077784,
            6078940,
            6079076,
            6079336,
            6078890,
            6080135,
            6077817,
            6078043,
            6080355,
            6079190,
            6077371
        ],
        "C": [
            6072624,
            6074366,
            6073677,
            6073792,
            6072756,
            6073958,
            6074499,
            6073931,
            6073038,
            6075180,
            6075460,
            6076470,
            6074776,
            6073618,
            6075857,
            6074780,
            6076291,
            6078785
        ]
    },
    "name": "C. Restore Graph",
    "statement": "Valera had an undirected connected graph without self-loops and multiple\r\nedges consisting of vertices. The graph had an interesting property:\r\nthere were at most edges adjacent to each of its vertices. For\r\nconvenience, we will assume that the graph vertices were indexed by\r\nintegers from 1 to .One day Valera counted the shortest distances from\r\none of the graph vertices to all other ones and wrote them out in array\r\n. Thus, element of the array shows the shortest distance from the vertex\r\nValera chose to vertex number .Then something irreparable terrible\r\nhappened. Valera lost the initial graph. However, he still has the array\r\n. Help him restore the lost graph.\r\n",
    "solutions": [
        "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define lx x + x\n#define rx lx + 1\n#define ly y + y\n#define ry ly + 1\ntypedef long long LL;\n\nconst int N = 100005;\nconst int M = 1005;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\ntypedef double DB;\nint n, k, x;\nvector <int> v[N], ans, res;\n\nvoid add(int x, int y){\n    ans.PB(x), res.PB(y);\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d\", &x);\n        v[x].PB(i);\n    }\n    if (v[0].size() != 1){\n        puts(\"-1\");\n        return 0;\n    }\n    int cnt = 1;\n    for (int i = 1; i < n; i++){\n        int x = v[i - 1].size();\n        int y = v[i].size();\n        if (!y){\n            puts(\"-1\");\n            return 0;\n        }\n        if (i == 1 && y > k){\n            puts(\"-1\");\n            return 0;\n        }\n        if (i != 1){\n            if (k == 1 || ((LL)x * (k - 1) < y)){\n                puts(\"-1\");\n                return 0;\n            }\n        }\n        for (int j = 0; j < y; j++){\n            if (i == 1) add(v[0][0], v[i][j]); else\n            add(v[i - 1][j / (k - 1)], v[i][j]);\n        }\n        cnt += y;\n        if (cnt == n) break;\n    }\n    cout << ans.size() << endl;\n    for (int i = 0; i < ans.size(); i++)\n        printf(\"%d %d\\n\", ans[i], res[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Restore Graph.json",
    "editorial_link": "https://codeforces.com/blog/entry/11095",
    "editorial": "First of all let us notice that it must be only one in . Also means that\r\nis the vertex from which Valera calculated the distance to the other\r\nvertices. Letâs notice that every vertex with must be adjacent only to\r\nthe vertices such that . Besides there is always must be such neighboor\r\nof , that . Letâs build sought graph by adding one vertex to the\r\nexisting graph. We will add vertex in order of increasing their distance\r\nto . Initially, we have one vertex with number in our graph. When we add\r\nvertex with letâs consider such vertices that . Letâs choose the vertex\r\nwith minimal degree among them. If this value is equal to , then there\r\nis no solution. In other case letâs add to our graph and add the edge to\r\nthe answer. If there are no vertices with distance to then the answer is\r\nalso . If everything fine we will get the answer which is tree, so the\r\nnumber of edges in it equals .\r\n",
    "hint": []
}