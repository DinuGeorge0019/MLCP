{"link": "https://codeforces.com//contest/1867/problem/D", "problemId": "2204234", "problem_idx": "D", "shortId": "1867D", "contest_number": "1867", "problem_submissions": {"F": [222974823, 222969528, 222982087, 222982811, 222942381, 222981865, 222970849, 223263369, 222992160, 222992118, 222990610, 223293875], "E2": [222941139, 222944891, 222954532, 222948444, 222972148, 222927706, 222951442, 222943457, 222956697, 222956351, 222957299, 222965859, 222961624, 222958308, 222959237, 222958461, 222947616, 222951450, 222971686, 222965055], "E1": [222935951, 222944650, 222944932, 222948245, 222972552, 222928046, 222951818, 222940287, 222956433, 222950145, 222954065, 222953208, 222961246, 222954058, 222958971, 222958084, 222946896, 222951047, 222957812, 222965382], "D": [222929659, 222935565, 222933136, 222933725, 222959573, 222947841, 222976215, 222934664, 222934515, 222943779, 222942901, 222940224, 222926502, 222939367, 222939032, 222944642, 222964473, 222961543, 222946848, 222932024], "C": [222924786, 222923447, 222923495, 222924317, 222955570, 222955063, 222981892, 222921233, 222922345, 222926941, 222929128, 222930091, 222943796, 222929098, 222924664, 222933035, 222926807, 222929365, 222928181, 222930087], "B": [222916375, 222917063, 222916284, 222918254, 222947890, 222958388, 222980080, 222916704, 222917105, 222917987, 222920819, 222919702, 222916186, 222917789, 222919342, 222922163, 222919191, 222921766, 222918135, 222919076], "A": [222912165, 222912569, 222912487, 222914168, 222945721, 222961169, 222912375, 222913097, 222912526, 222913140, 222913385, 222912716, 222912425, 222912955, 222912750, 222914115, 222913574, 222915575, 222912204, 222918270]}, "name": "D. Cyclic Operations", "statement": "Egor has an array a of length n, initially consisting of zeros. However,\r\nhe wanted to turn it into another array b of length n.Since Egor doesn\u2019t\r\ntake easy paths, only the following operation can be used (possibly zero\r\nor several times): choose an array l of length k (1\r\nleq l_i\r\nleq n, all l_i are ) and change each element a_{l_i} to l_{(i\r\n", "solutions": ["#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define pb push_back\nusing namespace std;\nusing pii=pair <int,int>;\nusing tii=pair <pii,int>;\nconst int MXN=100010;\nvector <int> in[MXN],out[MXN];\nbool visited[MXN];\nvector <int> scc[MXN];\nint cnt;\nstack <int> st;\nvoid dfs1(int cur){\n\tvisited[cur]=1;\n\tfor (int i:out[cur]){\n\t\tif (!visited[i]) dfs1(i);\n\t}\n\tst.push(cur);\n}\nvoid dfs2(int cur){\n\tvisited[cur]=1;\n\tscc[cnt].pb(cur);\n\tfor (int i:in[cur]){\n\t\tif (!visited[i]) dfs2(i);\n\t}\n}\nvoid solve(){\n    int n,k; cin>>n>>k;\n    int a[n+1];\n    for (int i=1; i<=n; i++) cin>>a[i];\n    if (k==1){\n        for (int i=1; i<=n; i++){\n            if (i!=a[i]){\n                cout<<\"NO\\n\";\n                return;\n            }\n        }\n        cout<<\"YES\\n\";\n        return;\n    }\n    for (int i=1; i<=n; i++){\n        visited[i]=0;\n        out[i].clear(); in[i].clear();\n        scc[i].clear();\n    }\n    cnt=0;\n    for (int i=1; i<=n; i++){\n        out[i].pb(a[i]);\n        in[a[i]].pb(i);\n    }\n    for (int i=1; i<=n; i++){\n        if (!visited[i]) dfs1(i);\n    }\n    for (int i=1; i<=n; i++) visited[i]=0;\n    while (!st.empty()){\n        int tp=st.top(); st.pop();\n        if (!visited[tp]){\n            cnt++;\n            dfs2(tp);\n        }\n    }\n    for (int i=1; i<=cnt; i++){\n        if (scc[i].size()==1&&a[scc[i][0]]==scc[i][0]){\n            cout<<\"NO\\n\";\n            return;\n        }\n        if (scc[i].size()>1&&scc[i].size()!=k){\n            cout<<\"NO\\n\";\n            return;\n        }\n    }\n    cout<<\"YES\\n\";\n}\nsigned main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint t=1;\n\tcin>>t;\n\twhile (t--) solve();\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "dfs and similar", "graphs", "greedy", "implementation"], "dificulty": "1800", "interactive": false}