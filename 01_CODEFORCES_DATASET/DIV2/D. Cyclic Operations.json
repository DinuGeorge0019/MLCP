{
    "link": "https://codeforces.com//contest/1867/problem/D",
    "problemId": "2204234",
    "problem_idx": "D",
    "shortId": "1867D",
    "contest_number": "1867",
    "problem_submissions": {
        "F": [
            222974823,
            222969528,
            222982087,
            222982811,
            222942381,
            222981865,
            222970849,
            223263369,
            222992160,
            222992118,
            222990610,
            223293875
        ],
        "E2": [
            222941139,
            222944891,
            222954532,
            222948444,
            222972148,
            222927706,
            222951442,
            222943457,
            222956697,
            222956351,
            222957299,
            222965859,
            222961624,
            222958308,
            222959237,
            222958461,
            222947616,
            222951450,
            222971686,
            222965055
        ],
        "E1": [
            222935951,
            222944650,
            222944932,
            222948245,
            222972552,
            222928046,
            222951818,
            222940287,
            222956433,
            222950145,
            222954065,
            222953208,
            222961246,
            222954058,
            222958971,
            222958084,
            222946896,
            222951047,
            222957812,
            222965382
        ],
        "D": [
            222929659,
            222935565,
            222933136,
            222933725,
            222959573,
            222947841,
            222976215,
            222934664,
            222934515,
            222943779,
            222942901,
            222940224,
            222926502,
            222939367,
            222939032,
            222944642,
            222964473,
            222961543,
            222946848,
            222932024
        ],
        "C": [
            222924786,
            222923447,
            222923495,
            222924317,
            222955570,
            222955063,
            222981892,
            222921233,
            222922345,
            222926941,
            222929128,
            222930091,
            222943796,
            222929098,
            222924664,
            222933035,
            222926807,
            222929365,
            222928181,
            222930087
        ],
        "B": [
            222916375,
            222917063,
            222916284,
            222918254,
            222947890,
            222958388,
            222980080,
            222916704,
            222917105,
            222917987,
            222920819,
            222919702,
            222916186,
            222917789,
            222919342,
            222922163,
            222919191,
            222921766,
            222918135,
            222919076
        ],
        "A": [
            222912165,
            222912569,
            222912487,
            222914168,
            222945721,
            222961169,
            222912375,
            222913097,
            222912526,
            222913140,
            222913385,
            222912716,
            222912425,
            222912955,
            222912750,
            222914115,
            222913574,
            222915575,
            222912204,
            222918270
        ]
    },
    "name": "D. Cyclic Operations",
    "statement": "Egor has an array a of length n, initially consisting of zeros. However,\r\nhe wanted to turn it into another array b of length n.Since Egor doesn\u2019t\r\ntake easy paths, only the following operation can be used (possibly zero\r\nor several times): choose an array l of length k (1\r\nleq l_i\r\nleq n, all l_i are ) and change each element a_{l_i} to l_{(i\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define pb push_back\nusing namespace std;\nusing pii=pair <int,int>;\nusing tii=pair <pii,int>;\nconst int MXN=100010;\nvector <int> in[MXN],out[MXN];\nbool visited[MXN];\nvector <int> scc[MXN];\nint cnt;\nstack <int> st;\nvoid dfs1(int cur){\n\tvisited[cur]=1;\n\tfor (int i:out[cur]){\n\t\tif (!visited[i]) dfs1(i);\n\t}\n\tst.push(cur);\n}\nvoid dfs2(int cur){\n\tvisited[cur]=1;\n\tscc[cnt].pb(cur);\n\tfor (int i:in[cur]){\n\t\tif (!visited[i]) dfs2(i);\n\t}\n}\nvoid solve(){\n    int n,k; cin>>n>>k;\n    int a[n+1];\n    for (int i=1; i<=n; i++) cin>>a[i];\n    if (k==1){\n        for (int i=1; i<=n; i++){\n            if (i!=a[i]){\n                cout<<\"NO\\n\";\n                return;\n            }\n        }\n        cout<<\"YES\\n\";\n        return;\n    }\n    for (int i=1; i<=n; i++){\n        visited[i]=0;\n        out[i].clear(); in[i].clear();\n        scc[i].clear();\n    }\n    cnt=0;\n    for (int i=1; i<=n; i++){\n        out[i].pb(a[i]);\n        in[a[i]].pb(i);\n    }\n    for (int i=1; i<=n; i++){\n        if (!visited[i]) dfs1(i);\n    }\n    for (int i=1; i<=n; i++) visited[i]=0;\n    while (!st.empty()){\n        int tp=st.top(); st.pop();\n        if (!visited[tp]){\n            cnt++;\n            dfs2(tp);\n        }\n    }\n    for (int i=1; i<=cnt; i++){\n        if (scc[i].size()==1&&a[scc[i][0]]==scc[i][0]){\n            cout<<\"NO\\n\";\n            return;\n        }\n        if (scc[i].size()>1&&scc[i].size()!=k){\n            cout<<\"NO\\n\";\n            return;\n        }\n    }\n    cout<<\"YES\\n\";\n}\nsigned main(){\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint t=1;\n\tcin>>t;\n\twhile (t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Cyclic Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/120353",
    "editorial": "TutorialIf , then we can change to , so the answer is YES only if ,\r\notherwise the answer is NO.Otherwise, let\u00e2\u0080\u0099s build an undirected graph\r\nwith vertices and edges (). Any component of this graph will look like a\r\ncycle (possibly of size ) to each vertex of which a tree is attached\r\n(possibly empty). ProofLet\u00e2\u0080\u0099s assume that there are vertices in a\r\ncomponent, then there are also edges in it (since each vertex has\r\nexactly one outgoing edge). We can construct a depth-first search (DFS)\r\ntree for this component, which will have edges. Now, when we add the\r\nremaining edge (), a cycle is formed in the component (formed by the\r\nedge () and the path between and in the DFS tree). Each vertex will have\r\na tree attached to it, because before adding the edge, we had a tree.Now\r\nit is claimed that if the cycle in each component has a size exactly ,\r\nthen the answer is YES, otherwise NO. ProofLet\u00e2\u0080\u0099s first consider the\r\nsituation where the size of the cycle in some component is not . Let the\r\ncycle contain vertices in that order. Now let\u00e2\u0080\u0099s look at the last\r\noperation in which one of the was equal to some element from the cycle.\r\nIf the size of the cycle is less than , then in the last operation there\r\nwill be at least one vertex not from the cycle, which means that at\r\nleast one vertex from the cycle will be replaced by a number that is not\r\nthe next vertex in the cycle, which is incorrect because each vertex\r\nfrom the cycle should be replaced by the next vertex after it. If the\r\nsize of the cycle is greater than , then we will have a vertex from the\r\ncycle that will be replaced by a vertex that is not the next vertex in\r\nthe cycle (otherwise we would have used all the vertices of the cycle,\r\nand there are more than of them). Therefore, in any case, there is no\r\nvalid last operation with vertices from the cycle, so the answer is\r\nNO.If the size of the cycle in a component is equal to , then we can\r\napply the following algorithm:While there is at least one vertex in the\r\ncomponent that is a leaf, we will perform the operation with (all\r\nelements are distinct because we will enter the cycle and it has a size\r\nof ). After this operation, we will have , and we can remove vertex (it\r\nhad only outgoing edge).When only the cycle remains, we can apply the\r\noperation for the vertices in the cycle, preserving the order, and then\r\nfor all vertices in the component, we will have . By doing this for all\r\ncomponents, we will get , which is what we wanted, so the answer is\r\nYES.Time Complexity: per test case.\r\n"
}