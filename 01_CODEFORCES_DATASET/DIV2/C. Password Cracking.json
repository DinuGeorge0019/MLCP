{
    "link": "https://codeforces.com//contest/2013/problem/C",
    "problemId": "2890588",
    "problem_idx": "C",
    "shortId": "2013C",
    "contest_number": "2013",
    "problem_submissions": {
        "F1": [
            282085508,
            282091649,
            282097681,
            282062964,
            282097010,
            282094496,
            282096102,
            282130493,
            282100468,
            282110907,
            282110226,
            282977558
        ],
        "E": [
            282061833,
            282080813,
            282051849,
            282086247,
            282037391,
            282057195,
            282050812,
            282047875,
            282387310,
            282046660,
            282057981,
            282053861,
            282054405,
            282061649,
            282089310,
            282054594,
            282061765,
            282060270,
            282065503,
            282063375
        ],
        "D": [
            282053393,
            282148584,
            282052109,
            282042335,
            282076655,
            282080799,
            282065676,
            282079143,
            282037385,
            282054240,
            282041005,
            282045620,
            282047474,
            282043487,
            282073249,
            282022525,
            282048467,
            282042436,
            282046096,
            282048201
        ],
        "C": [
            282036735,
            282027206,
            282070402,
            282021424,
            282027464,
            282026938,
            282063555,
            282026144,
            282031663,
            282027005,
            282037319,
            282027256,
            282027279,
            282046717,
            282066980,
            282036015,
            282031256,
            282038898,
            282038980
        ],
        "B": [
            282022099,
            282013728,
            282015453,
            282011770,
            282018552,
            282009811,
            282027915,
            282017479,
            282013009,
            282018195,
            282019086,
            282010905,
            282014462,
            282037982,
            282022835,
            282017402,
            282018955,
            282018976,
            282023313
        ],
        "A": [
            282014277,
            282006421,
            282026971,
            282006385,
            282008034,
            282005836,
            282006296,
            282008704,
            282006066,
            282010046,
            282006523,
            282005614,
            282006702,
            282035715,
            282023370,
            282007442,
            282014269,
            282005794,
            282006570
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/134170",
    "editorial": "SolutionWe will initially maintain an empty string such that appears as\r\na substring in .We will increase the string by one character until its\r\nlength is less than .We will perform iterations. In each iteration, we\r\nwill check the strings and . If one of them appears in as a substring,\r\nwe will add the appropriate character to the end of and proceed to the\r\nnext iteration.If neither of these two strings appears in , it means\r\nthat the string is a suffix of the string . After this iteration, we\r\nwill check the string . If it appears in , we will add to ; otherwise,\r\nwe will add .Thus, in each iteration, we perform 2 queries, except for\r\none iteration in which we perform 3 queries. However, after this\r\niteration, we will make only 1 query, so the total number of queries\r\nwill not exceed .\r\n",
    "name": "C. Password Cracking",
    "statement": "Dimash learned that Mansur wrote something very unpleasant about him to\r\na friend, so he decided to find out his password at all costs and\r\ndiscover what exactly he wrote.Believing in the strength of his\r\npassword, Mansur stated that his password is a binary string of length\r\nn. He is also ready to answer Dimash’s questions of the following\r\ntype:Dimash says a binary string t, and Mansur replies whether it is\r\ntrue that t is a substring of his password.Help Dimash find out the\r\npassword in no more than 2n operations; otherwise, Mansur will\r\nunderstand the trick and stop communicating with him.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; typedef long long ll;using vi = vector<int>;using vvi = vector<vector<int>>;using vll = vector<ll>;using vvll = vector<vector<ll>>; #define all(x) x.begin(), x.end()#define ckmin(a,b) a = min(a,b)#define ckmax(a,b) a = max(a,b) void solve() {    int N;    cin >> N;     auto do_query = [&](const string& str) {        cout << \"? \" << str << endl;        int resp;        cin >> resp;        return (resp == 1);    };     auto report_string = [&](const string& str) {        cout << \"! \" << str << endl;    };     if (N == 1) {        bool ans = do_query(\"1\");        if (ans) report_string(\"1\");        else report_string(\"0\");         return;    } else if (N == 2) {        bool ans = do_query(\"0\");        if (!ans) {            report_string(\"11\");            return;        }         if (do_query(\"00\")) report_string(\"00\");        else if (do_query(\"01\")) report_string(\"01\");        else report_string(\"10\");        return;    }     // N > 2    // save query on first run    if (!do_query(\"0\")) {        string ans = \"\";        for (int i=0;i<N;i++) ans += \"1\";        report_string(ans);        return;    }     string cur = \"0\";    bool grow_right = true;     while (cur.length() < N) {        if (grow_right) {            if (do_query(cur + \"0\")) {                cur += \"0\";            } else if (do_query(cur + \"1\")) {                cur += \"1\";            } else {                grow_right = false;            }        } else {            if (do_query(\"0\" + cur)) {                cur = \"0\" + cur;            } else {                cur = \"1\" + cur;            }        }    }     report_string(cur);} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(NULL);     int T;    cin >> T;     for (int t=0;t<T;t++) solve();     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Password Cracking.json",
    "hint": []
}