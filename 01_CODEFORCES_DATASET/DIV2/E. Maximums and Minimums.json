{
    "link": "https://codeforces.com//contest/1730/problem/E",
    "problemId": "1555173",
    "problem_idx": "E",
    "shortId": "1730E",
    "contest_number": "1730",
    "problem_submissions": {
        "F": [
            173481312,
            173482867,
            173478875,
            173582676
        ],
        "D": [
            173464501,
            173463845,
            173492235,
            173460042,
            173462224,
            173461894,
            173462011,
            173463683,
            173464123,
            173466252,
            173465903,
            173465820,
            173472784,
            173476685,
            173475004,
            173471558,
            173472223
        ],
        "C": [
            173450456,
            173450157,
            173457042,
            173452649,
            173450776,
            173453445,
            173454802,
            173455629,
            173456866,
            173446752,
            173444646,
            173455631,
            173457312,
            173447641,
            173447077,
            173451017,
            173452623,
            173453329
        ],
        "B": [
            173445492,
            173444904,
            173458756,
            173449524,
            173445632,
            173448108,
            173451808,
            173449142,
            173453555,
            173457120,
            173455134,
            173451905,
            173454521,
            173452227,
            173444715,
            173446889,
            173447944,
            173446921
        ],
        "A": [
            173439407,
            173438936,
            173438879,
            173443820,
            173439220,
            173439980,
            173443156,
            173443507,
            173445064,
            173455369,
            173446952,
            173439340,
            173447666,
            173440064,
            173438737,
            173441530,
            173439874,
            173440797
        ],
        "E": [
            173564584,
            173477480,
            173568880
        ]
    },
    "name": "E. Maximums and Minimums",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n of positive integers.Find the number of pairs of indices (l,\r\nr), where 1\r\nle l\r\nle r\r\nle n, that pass the check. The check is performed in the following\r\nmanner: The minimum and maximum numbers are found among a_l, a_{l+1},\r\nldots, a_r. The check is passed if the maximum number is divisible by\r\nthe minimum number.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nconst int N = 1e6 + 5;\nint a[N];\nint n;\nint smallL[N];\nint smallR[N];\nint bigeqL[N];\nint bigeqR[N];\n\nvector<int> divs[N];\nvector<int> occ[N];\n\nvoid prep(){\n    for(int i=1;i<N;i++){\n        for(int j=i;j<N;j+=i){\n            if(i != j) divs[j].pb(i);\n        }\n    }\n}\n\nint last[N];\nint nxt[N];\n\nint give_next(int who, int value){\n    if(occ[who].back() <= value) return -1;\n    int low = 0;\n    int high = (int)occ[who].size() - 1;\n    while(low < high){\n        int mid = (low + high) / 2;\n        if(occ[who][mid] > value) high = mid;\n        else low = mid + 1;\n    }\n    return occ[who][low];\n}\n\nvector<int> bounds;\n\nvoid solve(){\n    cin >> n;\n    for(int i=0;i<N;i++) occ[i].clear();\n    for(int i=1;i<=n;i++) cin >> a[i];\n    for(int i=1;i<=n;i++){\n        smallL[i] = -1;\n        smallR[i] = -1;\n        bigeqL[i] = -1;\n        bigeqR[i] = -1;\n        occ[a[i]].pb(i);\n    }\n\n    stack<int> alive;\n    alive.push(1);\n    for(int i=2;i<=n;i++){\n        while(!alive.empty() && a[alive.top()] >= a[i]) alive.pop();\n        if(!alive.empty()) smallL[i] = alive.top();\n        alive.push(i);\n    }\n    while(!alive.empty()) alive.pop();\n    alive.push(n);\n    for(int i=n-1;i>=1;i--){\n        while(!alive.empty() && a[alive.top()] >= a[i]) alive.pop();\n        if(!alive.empty()) smallR[i] = alive.top();\n        alive.push(i);\n    }\n    while(!alive.empty()) alive.pop();\n    alive.push(1);\n    for(int i=2;i<=n;i++){\n        while(!alive.empty() && a[alive.top()] <= a[i]) alive.pop();\n        if(!alive.empty()) bigeqL[i] = alive.top();\n        alive.push(i);\n    }\n    while(!alive.empty()) alive.pop();\n    alive.push(n);\n    for(int i=n-1;i>=1;i--){\n        while(!alive.empty() && a[alive.top()] < a[i]) alive.pop();\n        if(!alive.empty()) bigeqR[i] = alive.top();\n        alive.push(i);\n    }\n    while(!alive.empty()) alive.pop();\n\n    fill(last, last + N, -1);\n    fill(nxt, nxt + N, -1);\n    for(int i=0;i<N;i++){\n        if(!occ[i].empty()) nxt[i] = occ[i][0];\n    }\n\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        int from = 1;\n        int to = n;\n        if(bigeqL[i] != -1) from = bigeqL[i] + 1;\n        if(bigeqR[i] != -1) to = bigeqR[i] - 1;\n        for(int j=0;j<divs[a[i]].size();j++){\n            int di = divs[a[i]][j];\n            int L = last[di];\n            int R = nxt[di];\n            if(L < from) L = -1;\n            if(R > to) R = -1;\n            bounds.clear();\n            if(L != -1){\n                if(smallL[L] >= from) bounds.pb(smallL[L]);\n                if(smallR[L] <= to) bounds.pb(smallR[L]);\n            }\n            if(R != -1){\n                if(smallL[R] >= from) bounds.pb(smallL[R]);\n                if(smallR[R] <= to) bounds.pb(smallR[R]);\n            }\n\n            int rlFrom = from;\n            int rlTo = to;\n            for(int x : bounds){\n                if(x == -1) continue;\n                if(x < i) rlFrom = max(rlFrom, x + 1);\n                if(x > i) rlTo = min(rlTo, x - 1);\n            }\n\n            if(rlFrom > i || rlTo < i) continue;\n            if(L < rlFrom) L = -1;\n            if(R > rlTo) R = -1;\n            if(L == -1 && R == -1) continue;\n            else if(L != -1 && R != -1){\n                ll all_ways = (ll)(i - rlFrom + 1) * (ll)(rlTo - i + 1);\n                ll bad_ways = (ll)(i - L) * (ll)(R - i);\n                ans += all_ways - bad_ways;\n            }\n            else if(L != -1){\n                ll ways = (ll)(L - rlFrom + 1) * (ll)(rlTo - i + 1);\n                ans += ways;\n            }\n            else if(R != -1){\n                ll ways = (ll)(rlTo - R + 1) * (ll)(i - rlFrom + 1);\n                ans += ways;\n            }\n        }\n        last[a[i]] = i;\n        nxt[a[i]] = give_next(a[i], i);\n    }\n    for(int i=1;i<=n;i++){\n        int j = i;\n        while(j + 1 <= n && a[j + 1] == a[j]) j++;\n        ll len = (j - i + 1);\n        ll c = (ll)len * (ll)(len + 1) / 2;\n        ans += c;\n        i = j;\n    }\n\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    prep();\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "divide and conquer",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Maximums and Minimums.json",
    "editorial_link": "https://codeforces.com//blog/entry/107293",
    "editorial": "Let\u00e2\u0080\u0099s introduce some new variables: - the position of the nearest left\r\ngreater or equal than ( if there is none). - position of the nearest\r\nright greater than ( if there is none). - position of the nearest left\r\nlower than ( if there is none). - position of the nearest right lower\r\nthan ( if there is none). All this can be calculated, for example, using\r\na stack in or using binary search and sparse table in Let\u00e2\u0080\u0099s iterate over\r\nthe position of the leftmost maximum of the good segment. Then the -th\r\nelement will be the maximum on the segment [l, r] if and . For the\r\nsegment to pass the test, the minimum must be a divisor of the maximum.\r\nLet\u00e2\u0080\u0099s iterate over this divisor and find the number of segments where\r\nthe maximum is and the minimum is . Consider positions of occurrence of\r\nand the nearest left and right to (they can be found using two\r\npointers). Let\u00e2\u0080\u0099s find the number of segments satisfying the condition ,\r\nin which the element is a minimum. To do this, similar conditions must\r\nbe added to : and . Intersecting these conditions, we obtain independent\r\nsegments of admissible values of the left and right boundaries of the\r\ndesired segment. Multiplying their lengths, we get the number of\r\nrequired segments. Similarly, the number of segments satisfying , in\r\nwhich is the minimum, is found, but in order not to count 2 times one\r\nsegment, one more condition must be added: . The sum of these quantities\r\nover all and divisors of will give the answer to the problem.To\r\nenumerate divisors, it is better to precompute the divisors of all\r\nnumbers in , where is the constraint on . So the whole solution runs in\r\n, where is the maximum number of divisors.\r\n"
}