{"link": "https://codeforces.com//contest/454/problem/D", "problemId": "11931", "problem_idx": "D", "shortId": "454D", "contest_number": "454", "problem_submissions": {"E": [7317497], "D": [7315165, 7316655, 7315850, 7316966, 7316988, 7316976, 7317778, 7318354, 7318456, 7317666, 7317555, 7318543, 7319222, 7318726, 7317841, 7320896, 7320849, 7319120, 7319784, 7318403, 7318794], "C": [7312738, 7311706, 7313880, 7309986, 7311157, 7313294, 7311115, 7311374, 7312788, 7314689, 7313048, 7310594, 7313465, 7311432, 7315295, 7315016, 7313938, 7313281, 7316560], "B": [7309947, 7310409, 7311046, 7311468, 7312031, 7310861, 7312086, 7311916, 7309623, 7310693, 7312314, 7312987, 7310239, 7313802, 7311790, 7310408, 7312163, 7311161, 7312424], "A": [7308622, 7310283, 7309770, 7312107, 7308641, 7308657, 7312828, 7309446, 7308673, 7309245, 7309405, 7313814, 7308860, 7311907, 7309469, 7311125, 7309147, 7309374, 7309615]}, "name": "D. Little Pony and Harmony Chest", "statement": "Princess Twilight went to Celestia and Luna\u2019s old castle to research the\r\nchest from the Elements of Harmony. A sequence of positive integers is\r\nharmony if and only if for every two elements of the sequence their\r\ngreatest common divisor equals 1. According to an ancient book, the key\r\nof the chest is a harmony sequence which minimizes the following\r\nexpression:You are given sequence , help Princess Twilight to find the\r\nkey.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n\n#define inf 0x3f3f3f3f\n#define Inf 0x3FFFFFFFFFFFFFFFLL\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define Rep(i, n) for (int i = 1; i <= (n); ++i)\n#define clr(x, a) memset(x, (a), sizeof x)\nusing namespace std;\ntypedef long long ll;\nint pri[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 };\nint dp[101][1 << 16];\nint a[111];\nint msk[62];\nint pre[101][1 << 16][2];\n\nint main() {\n\tRep(i, 60) {\n\t\trep(j, 16) {\n\t\t\tif (i % pri[j] == 0) msk[i] |= 1 << j;\n\t\t}\n\t}\n\tint n; scanf(\"%d\", &n); Rep(i, n) scanf(\"%d\", &a[i]);\n\tclr(dp, 0x3f);\n\tdp[0][0] = 0;\n\tint m = 1 << 16;\n\tRep(i, n) {\n\t\trep(j, m) if (dp[i - 1][j] != inf) {\n\t\t\tRep(k, 58) if ((j & msk[k]) == 0) {\n\t\t\t\tint t = j | msk[k];\n\t\t\t\tint z = dp[i - 1][j] + abs(k - a[i]);\n\t\t\t\tif (z < dp[i][t]) {\n\t\t\t\t\tdp[i][t] = z;\n\t\t\t\t\tpre[i][t][0] = k;\n\t\t\t\t\tpre[i][t][1] = j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\t\n\tint ret = inf, rc;\n\trep(i, m) {\n\t\tif (dp[n][i] < ret) {\n\t\t\tret = dp[n][i];\n\t\t\trc = i;\n\t\t}\n\t}\n\tvector <int> ans;\n\tfor (int i = n; i >= 1; --i) {\n\t\tans.push_back(pre[i][rc][0]);\n\t\trc = pre[i][rc][1];\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp"], "dificulty": "2000", "interactive": false}