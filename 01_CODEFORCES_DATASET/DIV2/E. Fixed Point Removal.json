{
    "link": "https://codeforces.com//contest/1405/problem/E",
    "problemId": "718470",
    "problem_idx": "E",
    "shortId": "1405E",
    "contest_number": "1405",
    "problem_submissions": {
        "E": [
            92059741,
            92058133,
            92062156,
            92060968,
            92062924,
            92067408,
            92066292,
            92068112,
            92062237,
            92066773,
            92068775,
            92072009,
            92069079,
            92061737,
            92074033,
            92066427,
            92074374,
            92065015
        ],
        "D": [
            92042902,
            92049954,
            92043014,
            92049578,
            92048487,
            92047077,
            92051858,
            92049539,
            92053114,
            92052985,
            92055807,
            92047137,
            92054061,
            92071019,
            92059215,
            92073091,
            92059129,
            92044558,
            92094648,
            92049569
        ],
        "C": [
            92035786,
            92037182,
            92033713,
            92034576,
            92036286,
            92037578,
            92036561,
            92039390,
            92037184,
            92039374,
            92039602,
            92033076,
            92045285,
            92037821,
            92043997,
            92035004,
            92050607,
            92038515,
            92037672,
            92034975
        ],
        "B": [
            92025229,
            92029135,
            92026910,
            92025507,
            92028947,
            92031236,
            92029110,
            92028870,
            92041377,
            92032881,
            92030734,
            92026455,
            92038256,
            92044134,
            92038934,
            92028794,
            92045596,
            92031141,
            92026747,
            92029131
        ],
        "A": [
            92023093,
            92025469,
            92023871,
            92023042,
            92024363,
            92027769,
            92023712,
            92023043,
            92039754,
            92024522,
            92027108,
            92023087,
            92026674,
            92024071,
            92047223,
            92036791,
            92039497,
            92023146,
            92023754
        ]
    },
    "name": "E. Fixed Point Removal",
    "statement": "Let a_1,\r\nldots, a_n be an array of n positive integers. In one operation, you can\r\nchoose an index i such that a_i = i, and remove a_i from the array\r\n(after the removal, the remaining parts are concatenated).The weight of\r\na is defined as the maximum number of elements you can remove.You must\r\nanswer q independent queries (x, y): after replacing the x first\r\nelements of a and the y last elements of a by n+1 (making them\r\nimpossible to remove), what would be the weight of a?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define fef(i,a,b) for(ll i=a;i<=b;i++)\n#define rer(i,a,b) for(ll i=b;i>=a;i--)\n#define wew while(true)\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define FILE_IN \"cseq.inp\"\n#define FILE_OUT \"cseq.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n#define fio ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define nfio cin.tie(0);cout.tie(0)\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define ord(a,b,c) ((a>=b)and(b>=c))\n#define MOD (ll(1000000007))\n#define MAX 1000000017\n#define mag 320\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define X first\n#define Y second\n#define pow2(x) (ll(1)<<x)\n#define pii pair<int,int>\n#define piii pair<int,pii>\n#define For(i,__,___) for(int i=__;i<=___;i++)\n#define Rep(i,__,___) for(int i=__;i>=___;i--)\n#define ordered_set tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update>\n#define endl \"\\n\"\n#define bi BigInt\ntypedef long long ll;\n//---------END-------//\nconst int maxn = 3e5 + 17;\n\nint n, q;\n\nstruct BIT {\n    long long bit[maxn];\n \n    void add(int x, long long val) {\n        for(int i = x; i <= n; i += i & -i){\n            bit[i] += val;\n        }\n    }\n \n    long long get(int x) {\n        long long res = 0;\n        for(int i = x; i > 0; i -= i & -i){\n            res += bit[i];\n        }\n        return res;\n    }\n} bit;\n\nint a[maxn];\nvector <pii> query[maxn];\nint ans[maxn];\n\nint main(){\n    nfio;\n    cin >> n >> q;\n    For(i, 1, n){\n        cin >> a[i];\n        a[i] = i - a[i];\n        if (a[i] < 0){\n            a[i] = MAX;\n        }\n    }\n    For(i, 1, q){\n        int x, y;\n        cin >> x >> y;\n        x++;\n        y = n - y;\n        query[y].push_back(make_pair(x, i));\n    }\n    For(i, 1, n){\n        if (bit.get(1) >= a[i]){\n            int L = 1, R = n;\n            while (L < R){\n                int mid = (L + R + 1) / 2;\n                if (bit.get(mid) >= a[i]){\n                    L = mid;\n                }\n                else{\n                    R = mid - 1;\n                }\n            }\n            L = min(L, i);\n            bit.add(1, 1);\n            bit.add(L + 1, -1);\n        }\n        for (int j = 0; j < (int)query[i].size(); j++){\n            ans[query[i][j].Y] = bit.get(query[i][j].X);\n        }\n    }\n    For(i, 1, q){\n        cout << ans[i] << '\\n';\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Fixed Point Removal.json",
    "editorial_link": "https://codeforces.com//blog/entry/82366",
    "editorial": "Replace by . The new operation becomes: remove a zero, and decrement all\r\nelements after by one.For each query, note and the endpoints of the\r\nnon-protected subarray.The main idea of the solution is iterating over ,\r\nmaintaining answers for each in a BIT (increment on prefix) and answer\r\nqueries offline (when we meet a right endpoint). What follows is a\r\ndetailed explanation of this idea.Letâs suppose that holds for all\r\nqueries.We can intuitively see that is removable iff and we can remove\r\nat least elements before. Weâre going to rewrite this more formally.Let\r\nbe the maximum number of elements we can remove in the subarray . If or\r\n, then itâs obviously impossible to remove and in that case, .Otherwise,\r\nif , then . We can reach this with the following strategy: Perform the\r\nfirst steps in the prefix Remove (which is equal to at that moment)\r\nPerform the remaining steps in the prefix . Hence, we can compute\r\nsuccessively with a single loop: maintain current in a variable , and at\r\neach iteration increment if and only if .Note the maximum number of\r\nelements we can remove in the subarray (zero if ). During our iteration\r\nover , weâre going to maintain the answers for each : When the iteration\r\ncontinues, discovering a new element , what happens? If , nothing\r\nhappens. Otherwise, is incremented by one if and only if .Let be the\r\ngreatest such that and . We should increment the prefix ending here by\r\none:A binary indexed tree (aka Fenwick tree) is obviously the structure\r\nwe need in order to maintain , since it allows to add on segment and get\r\none element in (segment tree could work, but is slower in practice).In\r\norder to find , the easiest solution is to binary search, it takes time\r\nwhich is fast enough to get AC. We can also use binary lifting in order\r\nto optimize the search in . This technique is explained in this blog.We\r\nhave to read all queries in advance (offline algorithm). When the\r\niteration over meets the right endpoint of a query, we set its answer to\r\nthe current weight of .Final complexity: with low constant factor.Under\r\ngiven time limit, solutions with reasonable constant factor could also\r\npass.\r\n",
    "hint": []
}