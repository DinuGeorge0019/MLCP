{
    "link": "https://codeforces.com//contest/1717/problem/C",
    "problemId": "1527571",
    "problem_idx": "C",
    "shortId": "1717C",
    "contest_number": "1717",
    "problem_submissions": {
        "F": [
            170628195,
            170631297,
            170636621,
            170638786,
            170642998,
            170642114,
            170636113,
            170640846,
            170643077,
            170643996,
            170641292,
            170639769,
            170690219,
            170646621,
            170646461,
            170679476,
            170679133,
            170639635
        ],
        "E": [
            170609804,
            170616589,
            170615870,
            170622633,
            170610853,
            170628228,
            170623924,
            170617172,
            170622667,
            170627714,
            170627468,
            170624918,
            170630751,
            170634625,
            170598060,
            170611863,
            170622101,
            170626877,
            170623213,
            170615426
        ],
        "D": [
            170607171,
            170605005,
            170609922,
            170610949,
            170622497,
            170609050,
            170615733,
            170627107,
            170617123,
            170612935,
            170623602,
            170628949,
            170618958,
            170628847,
            170611626,
            170607221,
            170605022,
            170607463,
            170648316,
            170620005
        ],
        "C": [
            170601766,
            170595872,
            170600515,
            170604005,
            170603370,
            170603689,
            170597455,
            170603675,
            170604089,
            170603783,
            170612791,
            170614880,
            170609148,
            170602273,
            170598587,
            170598491,
            170604850,
            170597420
        ],
        "B": [
            170595706,
            170594734,
            170596230,
            170601030,
            170598846,
            170599230,
            170600372,
            170596828,
            170597841,
            170615090,
            170608022,
            170603542,
            170597876,
            170599659,
            170595411,
            170595780,
            170599224,
            170595920
        ],
        "A": [
            170594341,
            170594250,
            170594713,
            170598166,
            170594912,
            170595202,
            170594533,
            170594589,
            170594840,
            170594292,
            170596316,
            170595526,
            170594805,
            170598577,
            170594243,
            170594388,
            170596942,
            170594653
        ]
    },
    "name": "C. Madoka and Formal Statement",
    "statement": "Given an array of integer a_1, a_2,\r\nldots, a_n. In one operation you can make a_i := a_i + 1 if i < n and\r\na_i\r\nleq a_{i + 1}, or i = n and a_i\r\nleq a_1.You need to check whether the array a_1, a_2,\r\nldots, a_n can become equal to the array b_1, b_2,\r\nldots, b_n in some number of operations (possibly, zero). Two arrays a\r\nand b of length n are called equal if a_i = b_i for all integers i from\r\n1 to n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nint n, a[N], b[N];\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        cin >> b[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (b[i] < a[i]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        if (b[i] > a[i]) {\n            int j = i == n ? 1 : (i + 1);\n            if (b[j] < b[i] - 1) {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Madoka and Formal Statement.json",
    "editorial_link": "https://codeforces.com//blog/entry/106553",
    "editorial": "Firstly, we obviously require ai?bi\n to hold for all i\n. With that out of our way, let's consider non-trivial cases. Also let an+1=a1,bn+1=b1\n cyclically.\n\nFor each i\n, we require that either ai=bi\n or bi?bi+1+1\n holds. That's because if we increment ai\n at least once, we had ai=bi?1\n and ai+1?bi+1\n before the last increment of ai\n, and from here it's just a matter of simple algebraic transformations.\n\nNow let's prove these two conditions are enough. Let i\n be the index of the minimal element of a\n such that ai<bi\n (i.e. the smallest element that's not ready yet). Notice that in this case we can, in fact, assign ai:=ai+1\n, because ai?bi?bi+1+1\n holds, and now we're one step closer to the required array. It's easy to continue this proof by induction.",
    "hint": []
}