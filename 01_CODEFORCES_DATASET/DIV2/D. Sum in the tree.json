{
    "link": "https://codeforces.com//contest/1099/problem/D",
    "problemId": "278504",
    "problem_idx": "D",
    "shortId": "1099D",
    "contest_number": "1099",
    "problem_submissions": {
        "E": [
            48000148,
            48008414,
            48015162,
            48015155,
            47998674,
            68679965,
            48055305,
            48002816,
            48005156,
            48004046
        ],
        "F": [
            47993398,
            48000668,
            47998030,
            47996940,
            48003129,
            48002459,
            48000786,
            48002880,
            48003524,
            48001521,
            48002772,
            48065469,
            48065253,
            48007017,
            48004595,
            48004955,
            48023235,
            48006181,
            48008407
        ],
        "D": [
            47985584,
            47989615,
            47984416,
            47978723,
            47985339,
            47986984,
            47992304,
            47990729,
            47990739,
            47992156,
            47990766,
            47987456,
            47986225,
            47993500,
            47991322,
            47992653,
            47992397,
            47991707,
            47988171,
            47987589
        ],
        "C": [
            47981176,
            47983527,
            47980104,
            47987818,
            47981157,
            47982699,
            47982090,
            47982267,
            47986173,
            47985738,
            47981653,
            47982375,
            47988366,
            47985929,
            47986209,
            47986811,
            47984704,
            47981818,
            47983683
        ],
        "B": [
            47976890,
            47977488,
            47975669,
            47984516,
            47975576,
            47975800,
            47977583,
            47977135,
            47978430,
            47982162,
            47977417,
            47977771,
            47981576,
            47979226,
            47979187,
            47980494,
            47977529,
            47975997,
            47978338
        ],
        "A": [
            47974401,
            47973914,
            47973933,
            47982820,
            47974013,
            47974051,
            47974701,
            47974488,
            47974881,
            47974319,
            47973925,
            47973908,
            47975086,
            47976101,
            47974397,
            47974659,
            47974316,
            47973944,
            47974200
        ]
    },
    "name": "D. Sum in the tree",
    "statement": "Mitya has a rooted tree with n vertices indexed from 1 to n, where the\r\nroot has index 1. Each vertex v initially had an integer number a_v\r\nge 0 written on it. For every vertex v Mitya has computed s_v: the sum\r\nof all values written on the vertices on the path from vertex v to the\r\nroot, as well as h_v the depth of vertex v, which denotes the number of\r\nvertices on the path from vertex v to the root. Clearly, s_1=a_1 and\r\nh_1=1.Then Mitya erased all numbers a_v, and by accident he also erased\r\nall values s_v for vertices with even depth (vertices with even h_v).\r\nYour task is to restore the values a_v for every vertex, or determine\r\nthat Mitya made a mistake. In case there are multiple ways to restore\r\nthe values, you\u2019re required to find one which minimizes the total sum of\r\nvalues a_v for all vertices in the tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nint n;\nvector<int> adj[MAXN];\nint64_t s[MAXN];\nint64_t value[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\tadj[p].pb(i + 2);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> s[i];\n}\n\nint64_t answer = 0;\n\nvoid dfs(int u, int pr = 0)\n{\n\tif(s[u] == -1)\n\t{\n\t\tint64_t mn = (int64_t)1e18;\n\t\tfor(int v: adj[u])\n\t\t\tchkmin(mn, s[v]);\n\n\t\tif(adj[u].empty())\n\t\t\ts[u] = s[pr], value[u] = 0;\n\t\telse\n\t\t{\n\t\t\tif(s[pr] > mn)\n\t\t\t{\n\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\tvalue[u] = mn - s[pr];\n\t\t\ts[u] = mn;\n\t\t}\n\t}\n\telse value[u] = s[u] - s[pr];\n\n\tanswer += value[u];\n\tfor(int v: adj[u])\n\t\tdfs(v, u);\n}\n\nvoid solve()\n{\n\tdfs(1, 0);\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Sum in the tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/64331",
    "editorial": "To achieve the minimum possible sum of values in the tree, for vertices\r\nwith even depth we need to put 0 for leaves and the maximum value\r\npossible for other vertices, because increasing the value does not make\r\nthe resulting sum worse our children would compensate for it. Since ,\r\nit\u00e2\u0080\u0099s obvious that . For every child of vertex it\u00e2\u0080\u0099s also true that ,\r\nhence . From this one can derive that the maximum possible for vertices\r\nwith even equals .Given the values in the vertices of even depth, we can\r\nrestore the values in the vertices of odd depth using the formula . This\r\nrequires a simple DFS (which translated to a for-loop given the tree\r\nrepresentation in the problem statement).\r\n"
}