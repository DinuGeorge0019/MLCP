{
    "link": "https://codeforces.com//contest/1858/problem/D",
    "problemId": "2166169",
    "problem_idx": "D",
    "shortId": "1858D",
    "contest_number": "1858",
    "problem_submissions": {
        "E1": [
            218971675,
            218948691,
            218950036,
            218981081,
            218981577,
            218982148,
            219044099,
            218987081,
            218959071,
            219043079,
            218997113,
            218975893,
            218978028,
            218974432,
            218978584,
            218984712,
            218984251,
            219051896,
            218984058,
            218985452,
            218989668,
            218998871,
            218971815
        ],
        "E2": [
            218971226,
            218946559,
            218949779,
            219003260,
            218981396,
            218982111,
            218983780,
            219043918,
            218987338,
            219043124,
            218997698,
            218975689,
            218977856,
            219035037,
            219051939,
            218998573
        ],
        "D": [
            218958822,
            218970595,
            218957970,
            218958903,
            218949856,
            218961365,
            218967040,
            218972943,
            219043010,
            218960726,
            218998607,
            218989664,
            218961840,
            218965618,
            218966574,
            218969464,
            218974328,
            218972414,
            218969139,
            218981714,
            218991387
        ],
        "C": [
            218944984,
            218929618,
            218962105,
            218928296,
            218926980,
            218941771,
            218950307,
            218944949,
            219042947,
            218946392,
            218934108,
            218941439,
            218951937,
            218933349,
            218935592,
            218942151,
            218948522,
            218948262,
            218943920,
            218947281,
            218951547
        ],
        "B": [
            218935374,
            218982876,
            218965626,
            218941114,
            218939372,
            218933262,
            218946217,
            218938100,
            219042924,
            218940019,
            218950811,
            218937233,
            218946328,
            218943500,
            218950259,
            218936903,
            218940772,
            218941478,
            218938583,
            218962280,
            218941262
        ],
        "A": [
            218918372,
            218920879,
            218959798,
            218918668,
            218919313,
            218918787,
            218926715,
            218920787,
            219043052,
            219042898,
            218921173,
            218920067,
            218918574,
            218919674,
            218918423,
            218919655,
            218919188,
            218922439,
            218922802,
            218918900,
            218943440,
            218921894
        ]
    },
    "name": "D. Trees and Segments",
    "statement": "The teachers of the Summer Informatics School decided to plant n trees\r\nin a row, and it was decided to plant only oaks and firs. To do this,\r\nthey made a plan, which can be represented as a binary string s of\r\nlength n. If s_i = 0, then the i-th tree in the row should be an oak,\r\nand if s_i = 1, then the i-th tree in the row should be a fir.The day of\r\ntree planting is tomorrow, and the day after tomorrow an inspector will\r\ncome to the School. The inspector loves nature very much, and he will\r\nevaluate the beauty of the row as follows: First, he will calculate l_0\r\nas the maximum number of consecutive oaks in the row (the maximum\r\nsubstring consisting of zeros in the plan s). If there are no oaks in\r\nthe row, then l_0 = 0. Then, he will calculate l_1 as the maximum number\r\nof consecutive firs in the row (the maximum substring consisting of ones\r\nin the plan s). If there are no firs in the row, then l_1 = 0. Finally,\r\nhe will calculate the of the row as a\r\ncdot l_0 + l_1 for some a the inspector’s favourite number. The teachers\r\nknow the value of the parameter a, but for security reasons they cannot\r\ntell it to you. They only told you that a is an integer from 1 to\r\nn.Since the trees have not yet been planted, the teachers decided to\r\nchange the type of no more than k trees to the opposite (i.e., change\r\ns_i from 0 to 1 or from 1 to 0 in the plan) in order to maximize the\r\nbeauty of the row of trees according to the inspector.For each integer j\r\nfrom 1 to n answer the following question : What is the maximum beauty\r\nof the row of trees that the teachers can achieve by changing the type\r\nof no more than k trees if the inspector’s favourite number a is equal\r\nto j?\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...)\n#endif\n\nconst int N = 3005;\n\nint n, k;\nstring s;\nint mx1[N + 1];\nint ps[N + 1];\nint f[N + 1][N];\nint g[N + 1][N];\n\nint sum(int l, int r) { return ps[r + 1] - ps[l]; }\n\nvoid solve() {\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == '1');\n  for (int op = 0; op <= k; op++) {\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n      while (j <= i && sum(j, i) > op) j++;\n      if (j <= i) {\n        f[op][i] = i - j + 1;\n      } else {\n        f[op][i] = -1e9;\n      }\n      if (i > 0) f[op][i] = max(f[op][i], f[op][i - 1]);\n    }\n  }\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == '0');\n  for (int op = 0; op <= k; op++) {\n    int j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n      while (j >= i && sum(i, j) > op) j--;\n      if (j >= i) {\n        g[op][i] = j - i + 1;\n      } else {\n        g[op][i] = -1e9;\n      }\n      if (i < n - 1) g[op][i] = max(g[op][i], g[op][i + 1]);\n    }\n  }\n  for (int u = 0; u <= k; u++) {\n    if (f[u][n - 1] >= 0) {\n      mx1[f[u][n - 1]] = max(mx1[f[u][n - 1]], 0);\n    }\n    if (g[u][0] >= 0) {\n      mx1[0] = max(mx1[0], g[u][0]);\n    }\n    for (int i = 0; i < n - 1; i++) {\n      if (f[u][i] >= 0) {\n        mx1[f[u][i]] = max(mx1[f[u][i]], g[k - u][i + 1]);\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    cin >> s;\n    for (int i = 0; i <= n; i++) {\n      mx1[i] = -1e9;\n    }\n    solve();\n    reverse(s.begin(), s.end());\n    solve();\n    for (int a = 1; a <= n; a++) {\n      int ans = 0;\n      for (int i = 0; i <= n; i++) ans = max(ans, i * a + mx1[i]);\n      cout << ans << \" \\n\"[a == n];\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Trees and Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/119398",
    "editorial": "There are many various dynamic programming solutions of this problem. We\r\nwill describe one of them. Letâs calculate the dynamics = the length of\r\nthe longest subsegment of zeros that can be obtained on the prefix up to\r\n, which ends at index and costs exactly operations. Similarly, is the\r\nlength of the longest subsegment of zeros on the suffix starting at ,\r\nwhich starts at index and costs exactly operations. Such dynamics can be\r\neasily computed: In the first case, we simply prolong the existing\r\nsubsegment of zeros, in the second case, we change the current to ,\r\nspending one operation on it (so if have operations left (), we cannot\r\ndo anything and the value of the dynamics is , meaning the segment has\r\nended). can be calculated similarly. Letâs update both dynamics in such\r\na way that will mean the maximum length of a subsegment of zeros that\r\nends no later than and costs no more than operations. This can be easily\r\ndone by updating with the value of , and then with . Similarly, we\r\nupdate the second dynamics. Now letâs consider a subsegment [ that we\r\nwant to convert into a segment of ones. We can easily calculate the\r\nnumber of operations that we will need (weâll just need to calculate the\r\nnumber of zeros in such a segment). Now, calculate the new dynamics for\r\nthe length of the segment of ones, which equals the maximum length of a\r\nsubsegment of zeros that we can obtain. Update this value with . Then,\r\nto answer the question for a fixed number , we can iterate over the\r\nlength of the segment of ones that will be in our answer and update the\r\nanswer with the value , if there exists a value for in the dynamics .\r\nThe complexity is . Solutions with complexity and using various\r\noptimizations of the dynamics () also exist.\r\n",
    "hint": []
}