{"link": "https://codeforces.com//contest/1106/problem/F", "problemId": "290935", "problem_idx": "F", "shortId": "1106F", "contest_number": "1106", "problem_submissions": {"F": [49265817, 49264923, 49266558, 49269257, 49271213, 49272184, 49272969, 49267903, 49273554, 49895559, 49298045, 49263114, 49273336, 49274102, 49274867, 49300428, 49276394, 49277229, 49269016, 49266937, 49277423, 49277280, 49269846], "E": [49261808, 49267815, 49266852, 49261526, 49261539, 49258516, 49262159, 49269184, 49261973, 49895562, 49273364, 49263914, 49261370, 49261525, 49300401, 49261737, 49261915, 49273907, 49276075, 49262981, 49266273, 49276021], "B": [49257277, 49252209, 49248876, 49251236, 49256788, 49251411, 49251144, 49255473, 49251954, 49895487, 49263583, 49254902, 49252783, 49253845, 49300101, 49250570, 49252035, 49259947, 49251497, 49253887, 49260721, 49251319], "D": [49252880, 49254281, 49252504, 49255122, 49251697, 49253429, 49254193, 49257749, 49255378, 49895514, 49296674, 49250135, 49257979, 49256084, 49256833, 49300300, 49255435, 49255524, 49255367, 49255410, 49258191, 49255067, 49255106], "C": [49249200, 49252258, 49250171, 49253405, 49249251, 49247144, 49252242, 49250452, 49253463, 49895495, 49252232, 49249038, 49255058, 49255040, 49300208, 49300199, 49252907, 49253665, 49252133, 49253357, 49255807, 49250684, 49253071], "A": [49246544, 49245865, 49245896, 49246235, 49246566, 49245858, 49246274, 49248820, 49246242, 49895480, 49249300, 49246352, 49247004, 49246275, 49300057, 49300056, 49246548, 49246161, 49246888, 49246017, 49246734, 49261784, 49245817]}, "name": "F. Lunar New Year and a Recursive Sequence", "statement": "He loves this sequence very much and wants to play with it.Let f_1, f_2,\r\nldots, f_i,\r\nldots be an infinite sequence of positive integers. Bob knows that for\r\ni > k, f_i can be obtained by the following recursive equation:f_i =\r\nleft(f_{i - 1} ^ {b_1}\r\ncdot f_{i - 2} ^ {b_2}\r\ncdot\r\ncdots\r\ncdot f_{i - k} ^ {b_k}\r\nright)\r\nbmod p,which in short isf_i =\r\nleft(\r\nprod_{j = 1}^{k} f_{i - j}^{b_j}\r\nright)\r\nbmod p,where p = 998\r\n,244\r\n,353 (a widely-used prime), b_1, b_2,\r\nldots, b_k are known integer constants, and x\r\nbmod y denotes the remainder of x divided by y.Bob lost the values of\r\nf_1, f_2,\r\nldots, f_k, which is extremely troublesome these are the basis of the\r\nsequence! Luckily, Bob remembers the first k - 1 elements of the\r\nsequence: f_1 = f_2 =\r\nldots = f_{k - 1} = 1 and the n-th element: f_n = m. Please find any\r\npossible value of f_k. If no solution exists, just tell Bob that it is\r\nimpossible to recover his favorite sequence, regardless of Bob\u2019s\r\nsadness.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110;\nconst int P = 998244353;\n\nint D[N][N], E[N][N], F[N][N];\n\nint k;\n\nvoid mul(int A[N][N], int B[N][N], int C[N][N]) {\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = 0; j < k; j++) D[i][j] = A[i][j], E[i][j] = B[i][j];\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tlong long val = 0;\n\t\t\tfor (int l = 0; l < k; l++) {\n\t\t\t\tval += 1LL * D[i][l] * E[l][j];\n\t\t\t\tval %= (P - 1);\n\t\t\t}\n\t\t\tC[i][j] = val;\n\t\t}\n\t}\n}\n\nvoid pow(int A[N][N], int n, int B[N][N]) {\n\tif (n == 0) {\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (i == j) B[i][j] = 1;\n\t\t\t\telse B[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint hn = n / 2;\n\tpow(A, hn, B);\n\tmul(B, B, B);\n\tif (n & 1) mul(B, A, B);\n}\n\nint modExp(int a, long long n, int p) {\n\tint ret = 1; ((a %= p) < 0) && (a += p);\n\tfor (; n; n >>= 1, a = (long long)a * a % p)\n\t\tif (n & 1) ret = (long long)ret * a % p;\n\treturn ret;\n}\n\nmap<int, int> M;\n\ntemplate<typename T>\nT mod_inv(T a, T mod) {\n\tif (__gcd(a, mod) != 1) return -1;\n\tT b = mod, s = 1, t = 0;\n\twhile (b) {\n\t\tT q = a / b;\n\t\tswap(a -= q * b, b);\n\t\tswap(s -= q * t, t);\n\t}\n\treturn s < 0 ? s + mod : s;\n}\n\nint L = 100000;\n\nint A[N][N], B[N][N];\nint b[N];\n\nint main() {\n\tcin >> k;\n\tfor (int i = 0; i < k; i++) cin >> b[i];\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0, j = 1; i < L; i++, j = 1LL * j * 3 % P) {\n\t\tM[j] = i;\n\t}\n\tint PJ = modExp(3, P-1-L, P);\n\tint pm;\n\tfor (int add = 0, cur = m; ; add += L, cur = 1LL * cur * PJ % P) {\n\t\tif (M.count(cur)) {\n\t\t\tpm = M[cur] + add;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(modExp(3, pm, P) == m);\n\tmemset(A, 0, sizeof A);\n\tfor (int i = 0; i < k; i++) A[0][i] = b[i];\n\tfor (int i = 1; i < k; i++) {\n\t\tA[i][i-1] = 1;\n\t}\n\tpow(A, n - k, B);\n\tint a = B[0][0];\n\tint d = __gcd(a, P - 1);\n\tif (pm % d != 0) return puts(\"-1\"), 0;\n\ta /= d, pm /= d;\n\tint p = (P - 1) / d;\n\tint x = 1LL * mod_inv(a, p) * pm % p;\n\tcout << modExp(3, x, P) << endl;\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["math", "matrices", "number theory"], "dificulty": "2400", "interactive": false}