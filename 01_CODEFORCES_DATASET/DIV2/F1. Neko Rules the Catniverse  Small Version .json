{"link": "https://codeforces.com//contest/1152/problem/F1", "problemId": "335385", "problem_idx": "F1", "shortId": "1152F1", "contest_number": "1152", "problem_submissions": {"C": [53244845, 53230927, 53233766, 53235808, 53234198, 53234839, 53238158, 53233895, 53244428, 53238661, 53245124, 53237428, 53241947, 53255111, 53240873, 53232261, 53233767, 53232829], "E": [53239734, 53245640, 53249082, 53237299, 53252319, 53253962, 53269982, 53253449, 53252636, 53255804, 53252841, 53252353, 53235804, 53253519, 53250724, 53255613, 53476482], "D": [53233906, 53239025, 53240632, 53250831, 53239012, 53242704, 53250969, 53239158, 53239278, 53243068, 53249440, 53254093, 53239872, 53249862, 53242480, 53247260, 53236086, 53237628, 53240315], "B": [53229253, 53234506, 53230572, 53231304, 53231144, 53231405, 53233565, 53231636, 53233110, 53231852, 53233634, 53233426, 53232376, 53236011, 53235559, 53230731, 53230129, 53231640, 53230247], "A": [53226242, 53226637, 53226146, 53227612, 53226534, 53227116, 53228309, 53228363, 53226234, 53226947, 53228169, 53229011, 53227021, 53226493, 53226176, 53226318, 53226306, 53226785], "F2": [53255434, 139447309], "F1": [53255396]}, "name": "F1. Neko Rules the Catniverse  Small Version ", "statement": ".Aki is playing a new video game. In the video game, he will control\r\nNeko, the giant cat, to fly between planets in the Catniverse.There are\r\nn planets in the Catniverse, numbered from 1 to n. At the beginning of\r\nthe game, Aki chooses the planet where Neko is initially located. Then\r\nAki performs k - 1 moves, where in each move Neko is moved from the\r\ncurrent planet x to some other planet y such that: Planet y is not\r\nvisited yet. 1\r\nleq y\r\nleq x + m (where m is a fixed constant given in the input) This way,\r\nNeko will visit exactly k different planets. Two ways of visiting\r\nplanets are called different if there is some index i such that the i-th\r\nplanet visited in the first way is different from the i-th planet\r\nvisited in the second way.What is the total number of ways to visit k\r\nplanets this way? Since the answer can be quite large, print it modulo\r\n10^9 + 7.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007;\nll cc[105][15];\nll modpow(ll a, int b) {\n\tll res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn res;\n}\nint dis[20], arr[20], K, n, m;\nll f[4100][12];\nvector<int> bt[4100];\nstruct HashMap {\n\tstatic const int N = 1 << 20, B = N - 1;\n\tll key[N], sz; bool vis[N];\n\tll val[N];\n\tint hash(ll x) { return (x << 16 ^ x >> 6 ^ x << 1) & B; }\n\tint khash(ll x) { return (x << 15 ^ x >> 5 ^ x << 2) & B; }\n\tvoid ins(ll x, int y) {\n\t\tint t = hash(x), s = khash(x) | 1;\n\t\twhile (vis[t]) {\n\t\t\tif (key[t] == x) { val[t] += y; return; }\n\t\t\tt = (t + s) & B;\n\t\t}\n\t\tvis[t] = true, key[t] = x, ++sz, val[t] = y;\n\t}\n\tint query(ll x) {\n\t\tint t = hash(x), s = khash(x) | 1;\n\t\twhile (vis[t]) {\n\t\t\tif (key[t] == x) return val[t];\n\t\t\tt = (t + s) & B;\n\t\t}\n\t\treturn 0;\n\t}\n} hm, hn;\nvoid dfs(int k) {\n\tif (dis[k] >= K) return;\n\tif (k == n) {\n\t\tint mul = 0, cnt = 1;\n\t\tfor (int i = 1; i < k; i++) {\n\t\t\tint f = 0;\n\t\t\tfor (int j = i + 1; j <= k; j++)\n\t\t\t\tif (dis[j] - dis[i] <= m) f = j - i;\n\t\t\t\telse break;\n\t\t\tmul = mul * (m + 1) + f;\n\t\t\tif (dis[i + 1] - dis[i] > m) ++cnt;\n\t\t}\n\t\thm.ins(mul, cc[dis[k] + 1 - cnt][cnt]);\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= m + 1; i++) {\n\t\tdis[k + 1] = dis[k] + i;\n\t\tdfs(k + 1);\n\t}\n}\nint brr[20];\nint calc(int n) {\n\tif (n == 1) return 1;\n\tint nn = (1 << n) - 1;\n\tfor (int i = 1; i <= nn; i++)\n\tfor (int j : bt[i]) f[i][j] = 0;\n\tfor (int i = 0; i < n; i++) f[1 << i][i] = 1;\n\tfor (int i = 1; i < nn; i++)\n\tfor (int j : bt[i]) if (f[i][j])\n\tfor (int k : bt[nn ^ i]) {\n\t\tif (k > j + brr[j]) break;\n\t\tf[i | 1 << k][k] += f[i][j];\n\t}\n\tll res = 0;\n\tfor (int i = 0; i < n; i++) res += f[nn][i];\n\treturn res % MOD;\n}\nint main() {\n\tscanf(\"%d%d%d\", &K, &n, &m);\n\tfor (int i = 0; i <= K && i <= 100; i++) {\n\t\tint nn = K - i;\n\t\tcc[i][0] = 1;\n\t\tfor (int j = 1; j <= nn && j <= n; j++)\n\t\t\tcc[i][j] = cc[i][j - 1] * (nn - j + 1) % MOD * modpow(j, MOD - 2) % MOD;\n\t}\n\tdfs(1);\n\t/*printf(\"%d\\n\", hm.sz);\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = 0; k < n; k++, j /= m + 1) printf(\"%d \", j % 5);\n\t\tputs(\"\");\n\t}*/\n\tfor (int i = 0; i < 1 << n; i++)\n\tfor (int j = 0; j < n; j++) if (i >> j & 1) bt[i].push_back(j);\n\tll ans = 0;\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);\n\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\tint k = j;\n\t\t\twhile (k < n - 1 && arr[k]) ++k;\n\t\t\tfor (int l = j; l <= k; l++) brr[l - j] = arr[l];\n\t\t\tint temp = 0;\n\t\t\tfor (int l = 0; l <= k - j; l++) temp = temp * (m + 1) + brr[l];\n\t\t\thn.ins((ll)temp << 5 | (k - j + 1), 0);\n\t\t\tj = k;\n\t\t}\n\t}\n\tfor (int i = 0; i < hn.N; i++) if (hn.vis[i]) {\n\t\tint now = hn.key[i] & 31, num = hn.key[i] >> 5;\n\t\tfor (int j = num, k = now - 1; k >= 0; k--, j /= m + 1) brr[k] = j % (m + 1);\n\t\thn.val[i] = calc(now);\n\t}\n\tfor (int i = 0; i < hm.N; i++) if (hm.vis[i]) {\n\t\tfor (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);\n\t\tll mul = hm.val[i] % MOD, ss = mul;\n\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\tint k = j;\n\t\t\twhile (k < n - 1 && arr[k]) ++k;\n\t\t\tfor (int l = j; l <= k; l++) brr[l - j] = arr[l];\n\t\t\tint temp = 0;\n\t\t\tfor (int l = 0; l <= k - j; l++) temp = temp * (m + 1) + brr[l];\n\t\t\tmul = mul * hn.query((ll)temp << 5 | (k - j + 1)) % MOD;\n\t\t\tj = k;\n\t\t}\n\t\tans += mul;\n\t}\n\tprintf(\"%lld\\n\", ans % MOD);\n\treturn 0;\n}//for (int j = hm.key[i], k = n - 2; k >= 0; k--, j /= m + 1) arr[k] = j % (m + 1);"], "input": "", "output": "", "tags": ["bitmasks", "dp", "matrices"], "dificulty": "2800", "interactive": false}