{
    "link": "https://codeforces.com//contest/1539/problem/E",
    "problemId": "1021674",
    "problem_idx": "E",
    "shortId": "1539E",
    "contest_number": "1539",
    "problem_submissions": {
        "F": [
            120107348,
            120107649,
            120097977,
            120099320,
            120098312,
            120109635,
            120105864,
            120629204,
            120113433,
            120106419,
            120104986,
            120113014,
            120101930,
            120110658,
            120109502,
            120113744,
            120116844,
            120114654,
            120115147
        ],
        "E": [
            120093781,
            120079364,
            120114726,
            120122564,
            120207189,
            120197883,
            120200475,
            120100072,
            120098623,
            120171381
        ],
        "B": [
            120070630,
            120060349,
            120061059,
            120060386,
            120060622,
            120062253,
            120060692,
            120629156,
            120061053,
            120062981,
            120062418,
            120061602,
            120061888,
            120061204,
            120064416,
            120067261,
            120060854,
            120063414,
            120061859,
            120065691,
            120065164
        ],
        "A": [
            120069368,
            120076735,
            120060240,
            120061153,
            120060245,
            120060841,
            120071571,
            120629142,
            120063706,
            120061645,
            120060943,
            120060282,
            120060860,
            120060194,
            120061081,
            120066922,
            120060268,
            120061240,
            120060385,
            120063176,
            120063285
        ],
        "D": [
            120067082,
            120090685,
            120072966,
            120078507,
            120084869,
            120076433,
            120086821,
            120629190,
            120078363,
            120083343,
            120083998,
            120082921,
            120077950,
            120072171,
            120081856,
            120078775,
            120086440,
            120082002,
            120072832,
            120082004,
            120079880
        ],
        "C": [
            120060552,
            120063745,
            120065169,
            120065204,
            120062357,
            120065301,
            120066339,
            120629175,
            120060313,
            120068918,
            120065740,
            120065066,
            120069921,
            120064011,
            120071005,
            120066689,
            120063119,
            120073312,
            120065303,
            120071920,
            120069029
        ]
    },
    "name": "E. Game with Cards",
    "statement": "The Alice\u2019s computer is broken, so she can\u2019t play her favorite card game\r\nnow. To help Alice, Bob wants to answer n her questions. Initially, Bob\r\nholds one card with number 0 in the left hand and one in the right hand.\r\nIn the i-th question, Alice asks Bob to replace a card in the left or\r\nright hand with a card with number k_i (Bob chooses which of two cards\r\nhe changes, Bob must replace exactly one card).After this action, Alice\r\nwants the numbers on the left and right cards to belong to given\r\nsegments (segments for left and right cards can be different). Formally,\r\nlet the number on the left card be x, and on the right card be y. Then\r\nafter the i-th swap the following conditions must be satisfied: a_{l, i}\r\nle x\r\nle b_{l, i}, and a_{r, i}\r\nle y\r\nle b_{r,i}.Please determine if Bob can answer all requests. If it is\r\npossible, find a way to do it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-'0');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\nconst int MAXN=100005;\n\nint n,m,a[MAXN];\npii r[MAXN][2];\npii f[MAXN][2];\nint to[MAXN][2];\npii onion(pii a,pii b){return mp(max(a.x,b.x),min(a.y,b.y));}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n),readint(m);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\treadint(a[i]);\n\t\tfor(int j=0;j<2;++j)readint(r[i][j].x),readint(r[i][j].y);\n\t}\n\tf[n+1][0]=f[n+1][1]=mp(-m,m);\n\tfor(int i=n;i;--i)\n\t{\n\t\tfor(int j=0;j<2;++j)\n\t\t\tif(a[i]>=r[i][j].x && a[i]<=r[i][j].y)\n\t\t\t{\n\t\t\t\tif(a[i]>=f[i+1][j].x && a[i]<=f[i+1][j].y)f[i][j^1]=r[i][j^1],to[i][j]=j^1;\n\t\t\t\telse f[i][j^1]=onion(f[i+1][j^1],r[i][j^1]),to[i][j]=j;\n\t\t\t}\n\t\t\telse f[i][j^1]=mp(m,-m),to[i][j]=-1;\n\t}\n\tint t=-1;\n\tfor(int j=0;j<2;++j)\n\t\tif(0>=f[1][j].x && 0<=f[1][j].y)\n\t\t\t{t=j^1;break;}\n\tif(t<0)return 0*printf(\"No\\n\");\n\tprintf(\"Yes\\n\");\n\tfor(int i=1;i<=n;++i)printf(\"%d \",t),t=to[i][t];\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Game with Cards.json",
    "editorial_link": "https://codeforces.com//blog/entry/91906",
    "editorial": "Let\u00e2\u0080\u0099s use dynamic programming to solve the problem. is equal to 1 if we\r\ncan correcly answer queries on suffix the way that -th card is taken in\r\nleft hand and -th card is taken in right hand. is equal to 1 if we can\r\ncorrecly answer queries on suffix the way that -th card is taken in\r\nright hand and -th card is taken in left hand. Let\u00e2\u0080\u0099s consider\r\ntransitions to count . Let\u00e2\u0080\u0099s suppose we have such that .Then we can tell\r\nthat , if these 2 conditions hold: We can take all cards with indexes in\r\nright hand. Card in query fits constraints on value written on card in\r\nleft hand in queries with indexes . This way we got solution which works\r\nin . Let\u00e2\u0080\u0099s notice that if there exists , that then its optimal to\r\nconsider such smallest because it has less strict constraints. We will\r\nuse the same approach to count values of . This way we get soluton which\r\nuses time and memory.\r\n"
}