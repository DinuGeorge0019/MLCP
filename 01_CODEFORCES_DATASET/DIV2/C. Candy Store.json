{
    "link": "https://codeforces.com//contest/1798/problem/C",
    "problemId": "1849269",
    "problem_idx": "C",
    "shortId": "1798C",
    "contest_number": "1798",
    "problem_submissions": {
        "F": [
            199301449,
            199635259,
            199378902,
            199319392,
            199574998,
            200590796,
            199735470,
            201129046,
            199317594
        ],
        "E": [
            199292979,
            199351345,
            199287102,
            199284185,
            199288971,
            199287988,
            199287959,
            199291669,
            199576167,
            199283535,
            199289650,
            199290902,
            199290821,
            199293377,
            199290100,
            199289126,
            199294280,
            199294488,
            199296355,
            199291720,
            199292702,
            199291551
        ],
        "C": [
            199282234,
            199260342,
            199262167,
            199263273,
            199268067,
            199264515,
            199261766,
            199308981,
            199268218,
            199266685,
            199267420,
            199260005,
            199259528,
            199264427,
            199273339,
            199266427,
            199263028,
            199263300,
            199265190,
            199268521,
            199269803
        ],
        "D": [
            199278441,
            199265876,
            199269760,
            199267498,
            199271957,
            199278028,
            199268206,
            199270707,
            199275816,
            199273016,
            199267038,
            199269245,
            199274308,
            199265125,
            199274313,
            199269059,
            199272118,
            199273321,
            199275125,
            199279668
        ],
        "B": [
            199256261,
            199253517,
            199260386,
            199254659,
            199254149,
            199255531,
            199254513,
            199253333,
            199254612,
            199260900,
            199256259,
            199253472,
            199256316,
            199258434,
            199255694,
            199256525,
            199257662,
            199261042,
            199260517
        ],
        "A": [
            199251141,
            199251302,
            199252305,
            199251756,
            199251041,
            199252000,
            199251140,
            199251087,
            199251123,
            199252263,
            199256364,
            199250912,
            199252253,
            199253426,
            199251686,
            199251495,
            199253540,
            199253141,
            199252510
        ]
    },
    "name": "C. Candy Store",
    "statement": "The store sells n types of candies with numbers from 1 to n. One candy\r\nof type i costs b_i coins. In total, there are a_i candies of type i in\r\nthe store.You need to pack all available candies in packs, each pack\r\nshould contain only one type of candies. Formally, for each type of\r\ncandy i you need to choose the integer d_i, denoting the number of type\r\ni candies in one pack, so that a_i is divided without remainder by\r\nd_i.Then the cost of one pack of candies of type i will be equal to b_i\r\ncdot d_i. Let’s denote this cost by c_i, that is, c_i = b_i\r\ncdot d_i.After packaging, packs will be placed on the shelf. Consider\r\nthe cost of the packs placed on the shelf, in order c_1, c_2,\r\nldots, c_n. Price tags will be used to describe costs of the packs. One\r\nprice tag can describe the cost of all packs from l to r inclusive if\r\nc_l = c_{l+1} =\r\nldots = c_r. Each of the packs from 1 to n must be described by at least\r\none price tag. For example, if c_1,\r\nldots, c_n = [4, 4, 2, 4, 4], to describe all the packs, a 3 price tags\r\nwill be enough, the first price tag describes the packs 1, 2, the\r\nsecond: 3, the third: 4, 5.You are given the integers a_1, b_1, a_2,\r\nb_2,\r\nldots, a_n, b_n. Your task is to choose integers d_i so that a_i is\r\ndivisible by d_i for all i, and the required number of price tags to\r\ndescribe the values of c_1, c_2,\r\nldots, c_n is the minimum possible.For a better understanding of the\r\nstatement, look at the illustration of the first test case of the first\r\ntest: Let’s repeat the meaning of the notation used in the problem:a_i\r\nthe number of candies of type i available in the store.b_i the cost of\r\none candy of type i.d_i the number of candies of type i in one pack.c_i\r\nthe cost of one pack of candies of type i is expressed by the formula\r\nc_i = b_i\r\ncdot d_i.\r\n",
    "solutions": [
        "#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"Ofast,unroll-loops\")\n \n#include <bits/stdc++.h>   \n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;   \nusing namespace std;  \n#define ll long long  \nconst ll INF_MUL=1e13;\nconst ll INF_ADD=1e18;    \n#define pb push_back                 \n#define mp make_pair          \n#define nline \"\\n\"                           \n#define f first                                          \n#define s second                                             \n#define pll pair<ll,ll> \n#define all(x) x.begin(),x.end()     \n#define vl vector<ll>           \n#define vvl vector<vector<ll>>    \n#define vvvl vector<vector<vector<ll>>>          \n#ifndef ONLINE_JUDGE    \n#define debug(x) cerr<<#x<<\" \"; _print(x); cerr<<nline;\n#else\n#define debug(x);  \n#endif       \nvoid _print(ll x){cerr<<x;}  \nvoid _print(char x){cerr<<x;}   \nvoid _print(string x){cerr<<x;}    \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());   \ntemplate<class T,class V> void _print(pair<T,V> p) {cerr<<\"{\"; _print(p.first);cerr<<\",\"; _print(p.second);cerr<<\"}\";}\ntemplate<class T>void _print(vector<T> v) {cerr<<\" [ \"; for (T i:v){_print(i);cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T>void _print(set<T> v) {cerr<<\" [ \"; for (T i:v){_print(i); cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T>void _print(multiset<T> v) {cerr<< \" [ \"; for (T i:v){_print(i);cerr<<\" \";}cerr<<\"]\";}\ntemplate<class T,class V>void _print(map<T, V> v) {cerr<<\" [ \"; for(auto i:v) {_print(i);cerr<<\" \";} cerr<<\"]\";} \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;\ntypedef tree<pair<ll,ll>, null_type, less<pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nconst ll MOD=1e9+7;      \nconst ll MAX=200200;\nvoid solve(){   \n    ll n; cin>>n;\n    vector<pair<ll,ll>> a(n);\n    for(auto &it:a){\n        cin>>it.f>>it.s;\n    }\n    ll ans=1;\n    ll num=a[0].f*a[0].s,den=a[0].f;\n    for(ll i=1;i<n;i++){\n        auto it=a[i];\n        ll now_num=it.f*it.s,now_den=it.f;\n        ll cur_check=__gcd(num,now_num);\n        ll lft=num/cur_check,rght=now_num/cur_check;\n        ll valid=1;\n        if(den%lft){\n            valid=0;\n        }\n        if(now_den%rght){  \n            valid=0;\n        }\n        if(valid){\n            den/=lft;\n            now_den/=rght;\n            den=__gcd(den,now_den);\n            num=cur_check;\n        }\n        else{\n            ans++;\n            num=now_num;\n            den=now_den;\n        }\n    }\n    cout<<ans<<nline; \n    return;                                  \n}                                                   \nint main()                                                                                                \n{      \n    ios_base::sync_with_stdio(false);                          \n    cin.tie(NULL);    \n    #ifndef ONLINE_JUDGE                    \n    freopen(\"input.txt\", \"r\", stdin);                                              \n    freopen(\"output.txt\", \"w\", stdout);  \n    freopen(\"error.txt\", \"w\", stderr);                        \n    #endif                          \n    ll test_cases=1;               \n    cin>>test_cases;\n    while(test_cases--){\n        solve();\n    } \n    cout<<fixed<<setprecision(10);\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Candy Store.json",
    "editorial_link": "https://codeforces.com//blog/entry/114208",
    "editorial": "To begin with, letâs understand when 1 price tag will be enough.Let the\r\ntotal cost of all packs of candies be . Two conditions are imposed on\r\n:The first condition: must be divided by each of the numbers , because .\r\nThis is equivalent to the fact that is divided by , where denotes the\r\nleast common multiple.The second condition: is divided by . We want to\r\nsomehow appear in this condition. Therefore, multiply both parts by ,\r\nand we get that is divisible by . That is, is divided by . This is\r\nequivalent to is divided by .Thus, if one price tag is enough, it is\r\nnecessary that was divided by and was divided by .So a necessary and\r\nsufficient condition for one price tag will be \" is divided by \".It is\r\nnot difficult to understand that if one price tag is enough for a set of\r\ncandies, then if you remove any type of candy from this set, one price\r\ntag will still be enough.This means that a simple greedy algorithm will\r\nwork. Letâs select the largest prefix of candies such that one price tag\r\nis enough for it, \"paste\" a price tag on this prefix, and repeat for the\r\nremaining candies until the array ends.\r\n",
    "hint": [
        "Hint 1 In which case 1 price tag is enough?",
        "Hint 1.1 For any positive integers , the statement `` is divisible by '' equivalent to the statement `` is divisible by '",
        "Hint 1.2 Let's denote the total cost of all packs of candies for . Rewrite all the conditions given in the problem so that they become conditions only for the number . Hint1.1 will help in this.",
        "Hint 2 If one price tag is enough for a set of candies, then if you remove any type of candy from this set, one price tag will still be enough. This is a reason to think about greedy."
    ]
}