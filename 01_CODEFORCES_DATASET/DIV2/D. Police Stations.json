{
    "link": "https://codeforces.com//contest/796/problem/D",
    "problemId": "102475",
    "problem_idx": "D",
    "shortId": "796D",
    "contest_number": "796",
    "problem_submissions": {
        "D": [
            26270676,
            26268879,
            26272464,
            26267846,
            26271244,
            26271502,
            26279976,
            26280757,
            26270905,
            26273570,
            26272084,
            26278210,
            26277165,
            26274914,
            26273555,
            26270674,
            26274828,
            26272225,
            26276256,
            26275870
        ],
        "C": [
            26266928,
            26275839,
            26289710,
            26263867,
            26268031,
            26268145,
            26268959,
            26275805,
            26276716,
            26267202,
            26282722,
            26266268,
            26273046,
            26271604,
            26307139,
            26307124,
            26307117,
            26306972,
            26268576,
            26276501,
            26270809,
            26275985,
            26270211,
            26272901
        ],
        "B": [
            26260444,
            26260714,
            26260928,
            26268179,
            26259754,
            26260202,
            26259813,
            26260983,
            26261840,
            26260679,
            26259761,
            26261074,
            26260940,
            26259972,
            26266557,
            26259771,
            26262157,
            26259891,
            26263590,
            26260396
        ],
        "A": [
            26258377,
            26258938,
            26258411,
            26258195,
            26258231,
            26258560,
            26258094,
            26258499,
            26258460,
            26258203,
            26258087,
            26258420,
            26258693,
            26258275,
            26258381,
            26258161,
            26258669,
            26258379,
            26260347,
            26258265
        ],
        "E": [
            26280397,
            26347598,
            26308967,
            26308953
        ],
        "F": [
            58542353
        ]
    },
    "name": "D. Police Stations",
    "statement": "Inzane finally found Zane with a lot of money to spare, so they together\r\ndecided to establish a country of their own.Ruling a country is not an\r\neasy job. Thieves and terrorists are always ready to ruin the country’s\r\npeace. To fight back, Zane and Inzane have enacted a very effective law:\r\nfrom each city it must be possible to reach a police station by\r\ntraveling at most kilometers along the roads. There are cities in the\r\ncountry, numbered from to , connected only by exactly roads. All roads\r\nare kilometer long. It is initially possible to travel from a city to\r\nany other city using these roads. The country also has police stations\r\nlocated in some cities. In particular, the city’s structure satisfies\r\nthe requirement enforced by the previously mentioned law. Also note that\r\nthere can be multiple police stations in one city.However, Zane feels\r\nlike having as many as roads is unnecessary. The country is having\r\nfinancial issues, so it wants to minimize the road maintenance cost by\r\nshutting down as many roads as possible.Help Zane find the maximum\r\nnumber of roads that can be shut down without breaking the law. Also,\r\nhelp him determine such roads.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > a[300020];\nqueue<int> q;\nbool v[300020];\nbool f[300020];\nint n, k, d, x, y;\nint main() {\n\tscanf(\"%d%d%d\", &n, &k, &d);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tq.push(x);\n\t\tv[x] = true;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x].push_back(make_pair(y, i));\n\t\ta[y].push_back(make_pair(x, i));\n\t}\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < a[u].size(); i++) {\n\t\t\tif (!v[a[u][i].first]) {\n\t\t\t\tf[a[u][i].second] = true;\n\t\t\t\tq.push(a[u][i].first);\n\t\t\t\tv[a[u][i].first] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint nitamashabiba = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (!f[i]) {\n\t\t\tnitamashabiba++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", nitamashabiba);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (!f[i]) {\n\t\t\tprintf(\"%d \", i);\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Police Stations.json",
    "editorial_link": "https://codeforces.com/blog/entry/51527",
    "editorial": "A greedy solution shutting down either every d roads or when a police\r\nstation is encountered, although seems pretty nice, turns out to be\r\nincorrect.Consider performing a breadth first search (BFS) with cities\r\nwith a police station as starting vertices, and shutting down the road\r\nwhen it leads to a visited vertex (city). This will leave every bad city\r\nconnected (either directly or indirectly) with one of its nearest police\r\nstations, and thus will not break the law.With this method, you can see\r\nthat exactly roads will be shut down (where is the number of cities that\r\nhave a police station in them). Suppose this is not optimal, and ()\r\nroads can be shut down. The tree will break into components, while there\r\nare only cities with a police station, so this is a contradiction, since\r\nthere will be at least one component without any police station. Hence,\r\nshutting down roads is optimal.\r\n",
    "hint": []
}