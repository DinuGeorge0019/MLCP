{
    "link": "https://codeforces.com//contest/1501/problem/B",
    "problemId": "922987",
    "problem_idx": "B",
    "shortId": "1501B",
    "contest_number": "1501",
    "problem_submissions": {
        "E": [
            109941376,
            109875512,
            109883789,
            110105518,
            110105287
        ],
        "F": [
            109904857
        ],
        "A": [
            109878442,
            109847988,
            109846729,
            109846494,
            109846135,
            109845267,
            109845587,
            109847199,
            109845456,
            109847603,
            109846645,
            109853330,
            109847527,
            109845680,
            109862040,
            109861437,
            109857820,
            109847064,
            109879578,
            109846519
        ],
        "B": [
            109859119,
            109845806,
            109857469,
            109847916,
            109848937,
            109845741,
            109938795,
            109847183,
            109850677,
            109848222,
            109850447,
            109858630,
            109845453,
            109850407,
            109847950,
            109859017,
            109850474,
            109855074,
            109848387,
            109851675,
            109849198
        ],
        "D": [
            109857126,
            109874773,
            109867593,
            109877645,
            109872691,
            109883837,
            109870581,
            109889646,
            109873833,
            109880027,
            109879853,
            109876481,
            109884289,
            109877446,
            109871324,
            109884869,
            109884357,
            109879548,
            109886127,
            109876946,
            109883128
        ],
        "C": [
            109846358,
            109849688,
            109852611,
            109851798,
            109861330,
            109852150,
            109856203,
            109859435,
            109862259,
            109860307,
            109858003,
            109857809,
            109860809,
            109860157,
            109856014,
            109855070,
            109852660,
            109851031,
            109863843,
            109867505
        ]
    },
    "name": "B. Napoleon Cake",
    "statement": "This week Arkady wanted to cook some pancakes (to follow ancient\r\ntraditions) and make a problem about that. But then he remembered that\r\none can’t make a problem about stacking pancakes without working at a\r\nspecific IT company, so he decided to bake the Napoleon cake instead.To\r\nbake a Napoleon cake, one has to bake n dry layers first, and then put\r\nthem on each other in one stack, adding some cream. Arkady started with\r\nan empty plate, and performed the following steps n times: place a new\r\ncake layer on the top of the stack; after the i-th layer is placed, pour\r\na_i units of cream on top of the stack. When x units of cream are poured\r\non the top of the stack, top x layers of the cake get drenched in the\r\ncream. If there are less than x layers, all layers get drenched and the\r\nrest of the cream is wasted. If x = 0, no layer gets drenched. Help\r\nArkady determine which layers of the cake eventually get drenched when\r\nthe process is over, and which don’t.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\nconst int N=1000005,E=524288;\nint x[N],y[N],i,mp,c,t,f[N],a[N];\nlong long n,m,k;\nlong long exgcd(long long a,long long b,long long &x,long long &y)\n{\n\tif(b==0)\n\t{\n\t\tx=1,y=0;\n\t\treturn a;\n\t}\n\tlong long g=exgcd(b,a%b,x,y);\n\tlong long tmp=x;\n\tx=y;\n\ty=tmp-a/b*y;\n\treturn g;\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"a.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tf[i]=0;\n\t\tfor(i=1;i<=n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\t++f[max(i-a[i]+1,1)];\n\t\t\t--f[i+1];\n\t\t}\n\t\tfor(i=1;i<=n;++i)\n\t\t\tf[i]+=f[i-1];\n\t\tfor(i=1;i<=n;++i)\n\t\t\tprintf(\"%d \",f[i]?1:0);\n\t\tprintf(\"\\n\");\n\t}\n\t\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "sortings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Napoleon Cake.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "The -th layer is drenched in cream if there is such that . Then we can\r\ncalculate answers for all layers in reverse order (from to ) and\r\nmaintain minimum over all values as some variable .As a result, when we\r\nmove from to , we update and then check that .\r\n",
    "hint": []
}