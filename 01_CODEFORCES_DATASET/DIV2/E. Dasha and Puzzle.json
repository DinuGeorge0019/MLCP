{
    "link": "https://codeforces.com//contest/761/problem/E",
    "problemId": "90962",
    "problem_idx": "E",
    "shortId": "761E",
    "contest_number": "761",
    "problem_submissions": {
        "E": [
            24312697,
            24311709,
            24310168,
            24311976,
            24311188,
            24315381,
            24312128,
            24315134,
            24315757,
            24315051,
            24311586,
            24318302,
            24316465,
            24310698,
            24314080,
            24317203,
            24314720,
            24307483,
            24315644,
            24308867
        ],
        "D": [
            24308080,
            24302806,
            24306764,
            24303840,
            24312711,
            24310952,
            24308712,
            24308632,
            24304486,
            24318361,
            24305083,
            24314765,
            24313344,
            24306662,
            24308564,
            24311519,
            24304640,
            24301778,
            24312201,
            24302140
        ],
        "C": [
            24304705,
            24303281,
            24303086,
            24315151,
            24314006,
            24300409,
            24305328,
            24308132,
            24307670,
            24308073,
            24301179,
            24311655,
            24307103,
            24301133,
            24303312,
            24299854,
            24299226,
            24307641,
            24303935
        ],
        "A": [
            24296943,
            24297317,
            24293268,
            24295355,
            24314899,
            24301549,
            24295024,
            24293258,
            24293478,
            24294436,
            24294254,
            24298618,
            24301924,
            24304008,
            24305575,
            24293046,
            24297813
        ],
        "B": [
            24295947,
            24297573,
            24299480,
            24314233,
            24314669,
            24296673,
            24301229,
            24303624,
            24311945,
            24304611,
            24297096,
            24300811,
            24301955,
            24297423,
            24296616,
            24298776,
            24296843,
            24310580,
            24301114,
            24295172
        ],
        "F": [
            24322841,
            24309197,
            24319670
        ]
    },
    "name": "E. Dasha and Puzzle",
    "statement": "Dasha decided to have a rest after solving the problem. She had been\r\nready to start her favourite activity origami, but remembered the puzzle\r\nthat she could not solve. The tree is a non-oriented connected graph\r\nwithout cycles. In particular, there always are edges in a tree with\r\nvertices.The puzzle is to position the vertices at the points of the\r\nCartesian plane with integral coordinates, so that the segments between\r\nthe vertices connected by edges are parallel to the coordinate axes.\r\nAlso, the intersection of segments is allowed only at their ends.\r\nDistinct vertices should be placed at different points. Help Dasha to\r\nfind any suitable way to position the tree vertices on the plane.It is\r\nguaranteed that if it is possible to position the tree vertices on the\r\nplane without violating the condition which is given above, then you can\r\ndo it by using points with integral coordinates which don’t exceed in\r\nabsolute value.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == '-')\n\t\t\ts = -1, c = getChar();\n\t\twhile ('0' <= c && c <= '9')\n\t\t\tx = x * 10 + c - '0', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar('-'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)('0' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 100;\n\nvector <int> g[N];\n\nlong long location[N][2];\n\nlong long cur[2] = { 0LL, 0LL };\nlong long dirx[4] = { -1, 0, 1, 0 };\nlong long diry[4] = { 0, 1, 0, -1 };\nlong long step = 1LL << 30;\n\nvoid dfs(int v, int p = -1, int dirfrom = -1)\n{\n\tlocation[v][0] = cur[0];\n\tlocation[v][1] = cur[1];\n\tvector <int> havedirs;\n\tfor (int i = 0; i < 4; ++i)\n\t\tif (i != dirfrom)\n\t\t\thavedirs.push_back(i);\n\tint id = 0;\n\tfor (int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tif (g[v][i] == p)\n\t\t\tcontinue;\n\t\tint dir = havedirs[id++];\n\n\t\tcur[0] += dirx[dir] * step;\n\t\tcur[1] += diry[dir] * step;\n\t\tstep >>= 1;\n\n\t\tdfs(g[v][i], v, (dir + 2) % 4);\n\n\t\tstep <<= 1;\n\t\tcur[0] -= dirx[dir] * step;\n\t\tcur[1] -= diry[dir] * step;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tn = readInt();\n\tfor (int i = 0; i < n - 1; ++i)\n\t{\n\t\tint a = readInt(), b = readInt();\n\t\t--a, --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tif (g[i].size() > 4)\n\t\t{\n\t\t\twriteWord(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\tdfs(rand() % n);\n\twriteWord(\"YES\\n\");\n\tfor (int i = 0; i < n; ++i)\n\t\twriteInt(location[i][0], ' '),\n\t\twriteInt(location[i][1], '\\n');\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Dasha and Puzzle.json",
    "editorial_link": "https://codeforces.com//blog/entry/50179",
    "editorial": "The answer doesnât exist, when there is a vertex with degree > . Weâll\r\nuse power of two as length of each edge in the tree. Letâs dfs our tree\r\nand store in the recursion: the direction, where our parent is located\r\n(one of four possible), and the length of the edge weâll build from\r\ncurrent vertex. Then iterate the new direction, some neighbour of the\r\nvertex and continue recursion. The edges will not intersect, except in\r\nthe verteces, because . Itâs worth noting that it is possible to solve\r\nproblem for greater , using the fact that nothing depends on the\r\ncoordinates, only ratios between X and Y coordinates seperatly, so we\r\ncan compress them.\r\n",
    "hint": []
}