{
    "link": "https://codeforces.com//contest/1453/problem/B",
    "problemId": "821023",
    "problem_idx": "B",
    "shortId": "1453B",
    "contest_number": "1453",
    "problem_submissions": {
        "E": [
            100380052,
            155118161,
            100374406,
            100382833,
            100376358,
            100380373,
            100377845,
            100376439,
            100372651,
            100372508,
            100374319,
            100375311,
            100361396,
            100374016,
            100375798,
            100374877,
            100376885,
            100376092,
            100374918,
            100369776
        ],
        "D": [
            100375780,
            155118139,
            100367299,
            100371256,
            100369898,
            100372322,
            100371648,
            100366312,
            100368463,
            100366176,
            100366391,
            100373742,
            100368086,
            100364639,
            100371848,
            100367162,
            100368628,
            100369799,
            100372351
        ],
        "C": [
            100370717,
            155118105,
            100363680,
            100365192,
            100365975,
            100366748,
            100365481,
            100362777,
            100362628,
            100362653,
            100362794,
            100366264,
            100365011,
            100362269,
            100364059,
            100363843,
            100363639,
            100365174,
            100365522,
            100366070
        ],
        "F": [
            100365572,
            155118244,
            100384810,
            100377057,
            100384158,
            100383537,
            100385977,
            100390112,
            100382350,
            100381472,
            100408619,
            100428520
        ],
        "B": [
            100359448,
            155118064,
            100359921,
            100359636,
            100358954,
            100362716,
            100359915,
            100357443,
            100358086,
            100356217,
            100356739,
            100370528,
            100358105,
            100356427,
            100359186,
            100359063,
            100373277,
            100358271,
            100360209,
            100363310
        ],
        "A": [
            100352068,
            155118022,
            100354202,
            100352085,
            100350847,
            100354848,
            100351796,
            100357299,
            100351053,
            100350650,
            100351488,
            100367409,
            100350533,
            100350757,
            100350887,
            100350551,
            100351187,
            100351697,
            100352074,
            100358933
        ]
    },
    "name": "B. Suffix Operations",
    "statement": "Gildong has an interesting machine that has an array a with n integers.\r\nThe machine supports two kinds of operations: Increase all elements of a\r\nsuffix of the array by 1. Decrease all elements of a suffix of the array\r\nby 1. A suffix is a subsegment (contiguous elements) of the array that\r\ncontains a_n. In other words, for all i where a_i is included in the\r\nsubsegment, all a_j\u2019s where i\r\nlt j\r\nle n must also be included in the subsegment.Gildong wants to make all\r\nelements of a equal he will always do so using the minimum number of\r\noperations necessary. To make his life even easier, before Gildong\r\nstarts using the machine, you have the option of changing one of the\r\nintegers in the array to any other integer. You are allowed to leave the\r\narray unchanged. You want to minimize the number of operations Gildong\r\nperforms. With your help, what is the minimum number of operations\r\nGildong will perform?Note that even if you change one of the integers in\r\nthe array, you should count that as one of the operations because\r\nGildong did not perform it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nconst ll INF=1e18;\nconst int N=200005;\nint n,_;\nll a[N];\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\",\"r\",stdin);\n        freopen(\"out.txt\",\"w\",stdout);\n    #endif\n    read(_);\n    while(_--){\n    \tread(n);\n    \tF(i,1,n)read(a[i]);\n    \tll Res=0,res,ans=INF;\n    \tF(i,1,n-1)Res+=abs(a[i]-a[i+1]);\n    \tans=min(ans,Res);\n\t\tF(i,1,n){\n\t\t\tres=Res;\n    \t\tif(i==1){\n    \t\t\tres-=abs(a[i]-a[i+1]); \n\t\t\t}\n    \t\telse if(i==n){\n    \t\t\tres-=abs(a[i]-a[i-1]);\n\t\t\t}\n    \t\telse {\n    \t\t\tres-=abs(a[i]-a[i-1]);\n    \t\t\tres-=abs(a[i]-a[i+1]);\n    \t\t\tres+=abs(a[i-1]-a[i+1]);\n\t\t\t}\n\t\t\tans=min(ans,res);\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Suffix Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/85288",
    "editorial": "First, let\u00e2\u0080\u0099s find the optimal strategy for Gildong to follow to make all\r\nelements of the array equal.It\u00e2\u0080\u0099s obvious that there is no need to\r\nperform any operation on the suffix starting at , since that operation\r\nchanges all the integers in the array. For to , the only way for to have\r\nequal value to is to perform one of the operations on the suffix\r\nstarting at times. This is because all operations starting at other\r\npositions do not change the difference between and . Therefore, the\r\nminimum number of operations Gildong has to perform is .How should we\r\nchange one element so that we can minimize this value? Let\u00e2\u0080\u0099s take care\r\nof some special cases first. The optimal way to change is to make it\r\nequal to , and then the minimum number of operations Gildong has to\r\nperform is decreased by . Similarly, the optimal way to change is to\r\nmake it equal to , and then the minimum number of operations Gildong has\r\nto perform is decreased by .For the rest of the elements, changing\r\naffects both and . Here, we need to observe an important fact: This\r\nvalue is minimized when is between and , inclusive. Intuitively, if ,\r\nGildong has to perform one or more -nd operations on the suffix starting\r\nat , and then one or more -st operations on the suffix starting at to\r\ncompensate for the extra -nd operations. This applies to the scenario\r\nwhere as well. If is between and , these additional operations are\r\nunnecessary. In fact, the number of operations is decreased from to\r\n.Therefore, we can decrease the number of operations needed by:The\r\nanswer is where is the minimum number of operations Gildong needs to\r\nperform on the initial array, and is the maximum number of operations we\r\ncan decrease by changing exactly one element.Time complexity: .\r\n"
}