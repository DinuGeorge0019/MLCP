{
    "link": "https://codeforces.com//contest/1498/problem/B",
    "problemId": "939723",
    "problem_idx": "B",
    "shortId": "1498B",
    "contest_number": "1498",
    "problem_submissions": {
        "F": [
            111387402,
            111392757,
            111390775,
            111403691,
            111584572,
            111473088,
            111426854,
            111399920,
            111425764,
            111390588,
            111477247,
            111409684
        ],
        "E": [
            111380663,
            111380198,
            111394052,
            111391669,
            111387992,
            111389314,
            111390832,
            111389181,
            111394144,
            111392605,
            111394352,
            111387457,
            111380754,
            111393900,
            111397027,
            111441836,
            111441307,
            111400155,
            111385873,
            111395643
        ],
        "D": [
            111375931,
            111387383,
            111378758,
            111377203,
            111379613,
            111383007,
            111378160,
            111383542,
            111383036,
            111382698,
            111387981,
            111395336,
            111398482,
            111384225,
            111554241,
            111398142,
            111389221
        ],
        "C": [
            111364680,
            111369793,
            111370806,
            111367823,
            111370857,
            111369057,
            111366879,
            111378226,
            111375527,
            111375807,
            111372267,
            111374177,
            111372378,
            111369667,
            111372541,
            111380311,
            111372933,
            111374210
        ],
        "B": [
            111358809,
            111373602,
            111364638,
            111359716,
            111363279,
            111361795,
            111359400,
            111362980,
            111362321,
            111366507,
            111367101,
            111362617,
            111361122,
            111360963,
            111365072,
            111367219,
            111360331,
            111363745
        ],
        "A": [
            111356336,
            111356639,
            111356331,
            111356474,
            111357691,
            111356258,
            111356269,
            111358101,
            111357535,
            111358945,
            111356500,
            111356580,
            111356352,
            111356349,
            111359311,
            111357626,
            111356520,
            111357210
        ]
    },
    "name": "B. Box Fitting",
    "statement": "You are given n rectangles, each of height 1. Each rectangle\u2019s width is\r\na power of 2 (i. e. it can be represented as 2^x for some non-negative\r\ninteger x). You are also given a two-dimensional box of width W. Note\r\nthat W may or may not be a power of 2. Moreover, W is at least as large\r\nas the width of the largest rectangle.You have to find the smallest\r\nheight of this box, such that it is able to fit all the given\r\nrectangles. It is allowed to have some empty space left in this box\r\nafter fitting all the rectangles.You cannot rotate the given rectangles\r\nto make them fit into the box. Moreover, any two distinct rectangles\r\nmust not overlap, i. e., any two distinct rectangles must have zero\r\nintersection area.See notes for visual explanation of sample input.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\ninline int gcd(re int x,re int y){return y?gcd(y,x%y):x;}\ninline bool check(re int x){\n\tre int y=x,s=0;\n\twhile(x)s+=x%10,x/=10;\n\tif(gcd(y,s)>1)return 1;\n\treturn 0;\n}\nsigned main(){\n\tt=read();a[0]=-1;\n\tfor(re int i=1;i<=1000000;++i)a[i]=a[i>>1]+1;\n\twhile(t--){\n\t\tn=read(),ans=0,m=read();\n\t\tfor(re int i=0;i<=20;++i)b[i]=0;\n\t\tfor(re int i=1;i<=n;++i)++b[a[read()]];\n\t\twhile(n){\n\t\t\tre int s=m;\n\t\t\tfor(re int i=20;~i;--i){\n\t\t\t\twhile(s>=(1<<i)&&b[i])s-=(1<<i),--b[i],--n;\n\t\t\t}\n\t\t\t++ans;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Box Fitting.json",
    "editorial_link": "https://codeforces.com//blog/entry/89137",
    "editorial": "We follow a greedy strategy:\n\nInitialize height of box as 1.\nInitialize current layer size as W\n.\nPick the largest available rectangle that can fit into the current layer, and place it there. Repeat until this layer cannot fit any more rectangles.\nIf more rectangles remain, increment height by 1 and now repeat the last three steps. Else, output the current value of height."
}