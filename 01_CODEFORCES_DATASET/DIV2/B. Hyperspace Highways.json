{"link": "https://codeforces.com//contest/1046/problem/B", "problemId": "223474", "problem_idx": "B", "shortId": "1046B", "contest_number": "1046", "problem_submissions": {"B": [43252358, 43255928], "A": [43250309, 43254410, 43250987], "H": [43247639, 43245779, 43247215, 43247770], "F": [43246486, 43244046, 43246380, 43248077], "C": [43245566, 43247893, 43247771, 43244424, 43243585], "I": [43253744, 43258105, 43258173], "G": [43269050]}, "name": "B. Hyperspace Highways", "statement": "In an unspecified solar system, there are N planets. A space government\r\ncompany has recently hired space contractors to build M bidirectional\r\nHyperspace highways, each connecting two different planets. The primary\r\nobjective, which was to make sure that every planet can be reached from\r\nany other planet taking only Hyperspace highways, has been completely\r\nfulfilled. Unfortunately, lots of space contractors had friends and\r\ncousins in the Space Board of Directors of the company, so the company\r\ndecided to do much more than just connecting all planets. In order to\r\nmake spending enormous amounts of space money for Hyperspace highways\r\nlook neccessary, they decided to enforce a strict rule on the Hyperspace\r\nhighway network: whenever there is a way to travel through some planets\r\nand return to the starting point without travelling through any planet\r\ntwice, every pair of planets on the itinerary should be directly\r\nconnected by a Hyperspace highway. You are designing a Hyperspace\r\nnavigational app, and the key technical problem you are facing is\r\nfinding the minimal number of Hyperspace highways one needs to use to\r\ntravel from planet A to planet B. As this problem is too easy for Bubble\r\nCup, here is a harder task: your program needs to do it for Q pairs of\r\nplanets.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\nconst int N = 1e5 + 100, K = 18;\nint up[N][K];\nint lvl[N];\nvector <int> g[N];\nint n, m, q;\n\ninline int dist(int x, int y) {\n\tif (binary_search(g[x].begin(), g[x].end(), y))\n\t\treturn 1;\n\tif (lvl[x] < lvl[y])\n\t\tswap(x, y);\n\n\tint res = 0;\n\t//cerr << res << \" \";\n\tfor (int i = K - 1; i >= 0; --i)\n\t\tif (lvl[x] - (1 << i) >= lvl[y])\n\t\t\tx = up[x][i], res += (1 << i);\n\t//cerr << res << \" \";\n\tif (x == y)\n\t\treturn res;\n\tfor (int i = K - 1; i >= 0; --i) {\n\t\tif (up[x][i] != up[y][i])\n\t\t\tx = up[x][i], y = up[y][i], res += (1 << (i + 1));\n\t}\n\t//cerr << res << \" \";\n\tif (binary_search(g[x].begin(), g[x].end(), y))\n\t\treturn res + 1;\n\treturn res + 2;\n}\n\ninline void bfs() {\n\tint st[N], stb = 0, ste = 0;\n\tst[ste++] = 1;\n\tlvl[1] = 1;\n\tfor (int i = 0; i < K; ++i)\n\t\tup[1][i] = 1;\n\n\twhile (stb != ste) {\n\t\tint v = st[stb++];\n\t\tfor (auto to : g[v]) {\n\t\t\tif (!lvl[to]) {\n\t\t\t\tlvl[to] = lvl[v] + 1;\n\t\t\t\tup[to][0] = v;\n\t\t\t\tfor (int i = 1; i < K; ++i)\n\t\t\t\t\tup[to][i] = up[up[to][i - 1]][i - 1];\n\t\t\t\tst[ste++] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t#ifdef LOCAL\n\tfreopen(\"in\", \"r\", stdin);\n\t#endif\n\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> m >> q;\n\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tg[x].emplace_back(y);\n\t\tg[y].emplace_back(x);\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i)\n\t\tsort(g[i].begin(), g[i].end());\n\n\tbfs();\n\n\twhile(q--) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tcout << dist(a, b) << \"\\n\";\n\t}\n\t\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "trees"], "dificulty": "2300", "interactive": false}