{"link": "https://codeforces.com//contest/791/problem/C", "problemId": "98946", "problem_idx": "C", "shortId": "791C", "contest_number": "791", "problem_submissions": {"E": [25623822, 25707525, 25637756, 25686811], "D": [25619687, 25615888, 25616164, 25617170, 25877940, 25623254, 25619752, 25619476, 25621260, 25621091, 25621698, 25621432, 25634938, 25621485, 25620131, 25687920, 25622200, 25621928, 25620558, 25624599, 25620325, 25621555], "C": [25614829, 25610721, 25612354, 25611470, 25609920, 25609700, 25612129, 25612423, 25609930, 25611851, 25612109, 25634522, 25612617, 25613540, 25612121, 25613013, 25613533, 25611359, 25612919, 25614171], "B": [25607382, 25608951, 25608908, 25606986, 25611482, 25608509, 25609856, 25607620, 25608196, 25608851, 25634368, 25608159, 25610124, 25608652, 25608764, 25608051, 25608470, 25615071, 25609116], "A": [25604642, 25605072, 25605943, 25604441, 25605687, 25604865, 25604575, 25604516, 25605765, 25605230, 25634308, 25604731, 25605413, 25604932, 25605388, 25604873, 25604460, 25606109, 25605955]}, "name": "C. Bear and Different Names", "statement": "In the army, it isn\u2019t easy to form a group of soldiers that will be\r\neffective on the battlefield. The communication is crucial and thus no\r\ntwo soldiers should share a name (what would happen if they got an order\r\nthat Bob is a scouter, if there are two Bobs?).A group of soldiers is\r\neffective if and only if their names are different. For example, a group\r\n(John, Bob, Limak) would be effective, while groups (Gary, Bob, Gary)\r\nand (Alice, Alice) wouldn\u2019t.You are a spy in the enemy\u2019s camp. You\r\nnoticed soldiers standing in a row, numbered through . The general wants\r\nto choose a group of consecutive soldiers. For every consecutive\r\nsoldiers, the general wrote down whether they would be an effective\r\ngroup or not.You managed to steal the general\u2019s notes, with strings ,\r\neach either \"\" or \"\". The string describes a group of soldiers through\r\n(\"\" if the group is effective, and \"\" otherwise). The string describes a\r\ngroup of soldiers through . And so on, till the string that describes a\r\ngroup of soldiers through . Your task is to find possible names of\r\nsoldiers. Names should match the stolen notes. Each name should be a\r\nstring that consists of between and English letters, inclusive. The\r\nfirst letter should be uppercase, and all other letters should be\r\nlowercase. Names don\u2019t have to be existing names it\u2019s allowed to print\r\n\"\" or \"\" for example.Find and print any solution. It can be proved that\r\nthere always exists at least one solution.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int l, int r, string prefix, vector<string>& names) {\n\tif (l == r) {\n\t\treturn;\n\t}\n\tnames[l] = prefix;\n\tl = l + 1;\n\tint m = (l + r) / 2;\n\tdfs(l, m, prefix + 'a', names);\n\tdfs(m, r, prefix + 'b', names);\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tvector<string> names(n);\n\tdfs(0, n, \"A\", names);\n\tfor (int i = 0; i < n - k + 1; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s[0] == 'N') {\n\t\t\tnames[i+k-1] = names[i];\n\t\t}\n\t}\n\tcout << names[0];\n\tfor (int i = 1; i < n; ++i) {\n\t\tcout << \" \" << names[i];\n\t}\n\tcout << endl;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "1500", "interactive": false}