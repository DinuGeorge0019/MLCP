{
    "link": "https://codeforces.com//contest/1806/problem/F2",
    "problemId": "1836412",
    "problem_idx": "F2",
    "shortId": "1806F2",
    "contest_number": "1806",
    "problem_submissions": {
        "F2": [
            197973089,
            198042031,
            198041907
        ],
        "F1": [
            197947040,
            197980157,
            198042001,
            198041678
        ],
        "C": [
            197937230,
            197916115,
            197928489,
            197944944,
            197938210,
            197926089,
            197926689,
            197929494,
            197933106,
            197948564,
            197926881,
            197937572,
            197932222,
            197941848,
            199801603,
            197957943,
            197942490,
            197930745,
            197946610,
            197928372,
            197924952
        ],
        "E": [
            197933006,
            197929125,
            197915365,
            197935988,
            197962774,
            197948774,
            197963264,
            197949722,
            197943372,
            197943303,
            197949562,
            197950582,
            197950806,
            240170072,
            197967439,
            199801822,
            199801762,
            197952145,
            197987791,
            197987740,
            197972228,
            201450127,
            197970212,
            197959737,
            197938806,
            197943810
        ],
        "B": [
            197912589,
            197908884,
            197909602,
            197911369,
            197910208,
            197914190,
            197910559,
            197911156,
            197917129,
            197921982,
            197914483,
            197917557,
            197912987,
            197915302,
            197915210,
            197914864,
            197912863,
            197911859,
            197911664,
            197911113
        ],
        "A": [
            197912419,
            197906490,
            197911639,
            197906984,
            197907218,
            197908571,
            197907286,
            197906740,
            197907744,
            197907020,
            197928349,
            197908011,
            197912765,
            197906883,
            197908367,
            197906657,
            197906703,
            197906672,
            197907002,
            197906587
        ],
        "D": [
            197942295,
            197971270,
            197966565,
            197946069,
            197958331,
            197952013,
            197968711,
            197966060,
            197967070,
            197965611,
            197969051,
            197967288,
            197953250,
            199801511,
            197971493,
            197965795,
            197972473,
            197971611,
            198035510,
            198035241
        ]
    },
    "name": "F2. GCD Master  hard version ",
    "statement": "You are given an array a of length n and two integers m and k. Each\r\nelement in a satisfies 1\r\nle a_i\r\nle m.In one operation, you choose two indices i and j such that 1\r\nle i < j\r\nle |a|, then append\r\ngcd(a_i,a_j) to the back of the array and delete a_i and a_j from the\r\narray. Note that the length of the array decreases by one after this\r\noperation.Find the maximum possible sum of the array after performing k\r\noperations.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define ll __int128\n#define int ll\ninline char gc(){static char buf[1000000],*p1=buf,*p2=buf;return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;}\n#define gc getchar\ninline ll read(){char c=gc();ll su=0,f=1;\nfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\nfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\nreturn su*f;}\ninline void write(ll x){if (x<0){putchar('-');\nwrite(-x);return;}if (x>=10) write(x/10);putchar(x%10+'0');}\ninline void writesp(ll x){write(x),putchar(' ');}\ninline void writeln(ll x){write(x);putchar('\\n');}\nll n,x,m,K;\nint k;\nconst __int128 MAXEL = (__int128)9000 * (__int128)1000 * (__int128)1000 * \n(__int128)1000* (__int128)1000* (__int128)1000;\n__int128 nwd(__int128 a, __int128 b)\n{\n    while (a != 0)\n    {\n        b %= a;\n        std::swap(a, b);\n    }\n    return b;\n}\nvoid work()\n{\n\t// writeln(MAXEL);\n\tn=read(),m=read(),K=read();\n\tstd::vector<__int128> li, result;\n\tstd::vector<std::pair<__int128, int>> kro;\n    result.resize(n + 2);\n    for (int i = 0; i < n; i++)\n    {\n    \tx=read();\n        li.emplace_back(x);\n    }\n    sort(li.begin(), li.end());\n    int ile = 0;\n    __int128 last = li.front();\n    for (auto l : li)\n    {\n        if (l == last)\n        {\n            ile++;\n        }\n        else\n        {\n            kro.emplace_back(last, ile);\n            ile = 1;\n            last = l;\n        }\n    }\n    kro.emplace_back(last, ile);\n    __int128 nw = 0;\n    __int128 sum = 0;\n    for (auto x : kro)\n        sum += x.first;\n    for (std::size_t i = 0; i < kro.size(); i++)\n    {\n        __int128 tmp = nwd(nw, kro[i].first);\n        if (tmp != nw)\n        {\n            __int128 max = -MAXEL;\n            for (std::size_t j = i; j < kro.size(); j++)\n                max = std::max(max, nwd(nw, kro[j].first) - kro[j].first);\n            __int128 sum2 = sum + max;\n            int ite = 0;\n            int poz = kro.size() - 1;\n            std::vector<__int128> str;\n            while (true)\n            {\n                result[kro.size() - i + ite] = \n                std::max(result[kro.size() - i + ite], sum2);\n                result[kro.size() - i + ite + 1] =\n                 std::max(result[kro.size() - i + ite + 1], sum2 - max + nw);\n                while (poz >= (i) && kro[poz].second == 1)\n                    poz--;\n                if (poz < (i))\n                    break;\n                kro[poz].second--;\n                str.emplace_back(poz);\n                ite++;\n                sum2 += kro[poz].first;\n            }\n            for (auto x : str)\n                kro[x].second++;\n            nw = tmp;\n        }\n        sum -= kro[i].first;\n    }\n    sum = 0;\n    for (auto x : li)\n        sum += x;\n    nw = 0;\n    for (std::size_t i = 0; i < li.size(); i++)\n    {\n\n        __int128 tmp = nwd(nw, li[i]);\n        sum -= li[i];\n\n        if (tmp != nw)\n        {\n            __int128 max = -MAXEL;\n            for (std::size_t j = i; j < li.size(); j++)\n                max = std::max(max, nwd(li[i], nw));\n            result[li.size() - i] = std::max(result[li.size() - i], sum + max);\n        }\n        else\n        {\n            result[li.size() - i] = std::max(result[li.size() - i], sum + nw);\n        }\n\n        nw = tmp;\n    }\n\n    writeln(result[n-K]);\n}\nsigned main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\twork();\n\t}\n}\n\t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. GCD Master  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/114048",
    "editorial": "Hint 1: There is a easy strategy for dealing with repeated elements.\r\nSuppose that all elements in are pairwise distinct in the following\r\nhints.Hint 2: We will always perform an operation on the minimum\r\nelement.Hint 3: The best way is to choose elements, delete them, and add\r\nthe gcd of them to the sequence.Hint 4: After sorting the sequence, you\r\nmay guess that choosing a prefix is optimal. But actually it is wrong.\r\nTry fixing the strategy!The problem can be rewritten as: Divide the\r\nsequence into groups to maximize the sum of the gcd of each group. Let\r\nrepresent the elements of a group.: When , the group which the minimum\r\nelement of the original sequence belongs to satisfies .Proof:If , we can\r\nfind a group such that . Then replacing the maximum element of with the\r\nminimum element of the original sequence makes the answer greater. Let\r\nbe the minimum of the sequence and be the maximum of . the original\r\nanswer is . replacing the maximum element of with the minimum element,\r\nthe answer is . , so . Q.E.D.Tips: When , . Thatâs why all elements in\r\nneed to be pairwise distinct.: When , thereâs only one such that\r\nProof:Let be the group with the minimum element.Referring to Lemma , we\r\nknow . Then we remove all the elements of from the sequence, add to the\r\nsequence and subtract from . Itâs obvious that is the minimum element of\r\nthe newly formed sequence. We can continue the process until , which\r\ntells us that only . Q.E.D.We can enumerate to solve it in so far.How\r\nabout repeated elements?We can find that for those repeated elements,\r\nthe best strategy is to merge them with the same element. In other word,\r\na repeated element only decreases the answer by . So itâs independent of\r\nthe previous part. We just need to enumerate the number of operations we\r\nperform for repeated elements.Suppose is sorted.: When , we will choose\r\nthe first elements, and an element from the remaining elements.That is,\r\n, where , is the only group with more than one element.Proof:Suppose ,\r\nwhere , and . Then we can prove that is always a better choice.Let and .\r\nWe have . .So repeating the process, finally we will know that , where .\r\nQ.E.D.When thereâre repeated elements, we need to calculate the answer\r\nfor prefixes. Note that thereâre only different prefix gcd. So we can do\r\nit in (another comes from calculating gcd). Let be the prefix gcd. When\r\nfinding the best pair, we calculate , which leads to . , so . The gcd is\r\nnon-increasing so the total complexity is .\r\n",
    "hint": []
}