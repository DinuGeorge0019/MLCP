{"link": "https://codeforces.com//contest/1364/problem/D", "problemId": "647245", "problem_idx": "D", "shortId": "1364D", "contest_number": "1364", "problem_submissions": {"E": [83685190, 83684728, 83670044, 83708391, 86874545, 83727888, 94916861, 83733626, 83892588], "D": [83674039, 83643909, 83643324, 83650173, 83654530, 83655343, 83656667, 83658116, 83652702, 83655398, 83657128, 83655879, 83656798, 83659303, 83654673, 83652945, 83654032, 83654691, 83660980, 84168459, 83653853], "C": [83641956, 83631075, 83632825, 83637025, 83635932, 83634309, 83632050, 83634741, 83637967, 83633786, 83640244, 83634458, 83638454, 83638371, 83638980, 83647774, 83644474, 83643505, 83634306, 83639352], "B": [83634593, 83624903, 83627972, 83631302, 83628554, 83625631, 83625293, 83627339, 83628623, 83628644, 83625351, 83628184, 83628428, 83624769, 83633106, 83628572, 83637716, 83626469, 83630293], "A": [83629697, 83628427, 83623168, 83625873, 83624275, 83623298, 83623685, 83623482, 83625309, 83624536, 83623274, 83624381, 83624214, 83623297, 83623701, 83625943, 83623507, 83625742]}, "name": "D. Ehab s Last Corollary", "statement": "Given a connected undirected graph with n vertices and an integer k, you\r\nhave to either: either find an independent set that has\r\nlceil\r\nfrac{k}{2}\r\nrceil vertices. or find a cycle of length k. An independent set is a set\r\nof vertices such that no two of them are connected by an edge. A simple\r\ncycle is a cycle that doesn\u2019t contain any vertex twice. I have a proof\r\nthat for any input you can always solve at least one of these problems,\r\nbut it\u2019s left as an exercise for the reader.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, k;\nint cycle_st, cycle_end;\nvector<vector<int>> g;\nvector<char> cl;\nvector<int> p;\n\nbool dfs(int v) {\n  cl[v] = 1;\n  for (size_t i = 0; i < g[v].size(); ++i) {\n    int to = g[v][i];\n    if (cl[to] == 0) {\n      p[to] = v;\n      if (dfs(to))\n        return true;\n    } else if (cl[to] == 1 && p[v] != to) {\n      cycle_end = v;\n      cycle_st = to;\n      return true;\n    }\n  }\n  cl[v] = 2;\n  return false;\n}\n\nint main() {\n  cin >> n >> m >> k;\n  n = min(n, k);\n  g.resize(n);\n  p.resize(n, -1);\n  cl.resize(n, 0);\n  cycle_st = -1;\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    if (u > k || v > k) {\n      continue;\n    }\n    u--, v--;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    if (dfs(i)) {\n      break;\n    }\n  }\n\n  if (cycle_st == -1) {\n    vector<char> part(n, -1);\n    bool ok = true;\n    vector<int> q(n);\n    for (int st = 0; st < n; ++st) {\n      if (part[st] == -1) {\n        int h = 0, t = 0;\n        q[t++] = st;\n        part[st] = 0;\n        while (h < t) {\n          int v = q[h++];\n          for (size_t i = 0; i < g[v].size(); ++i) {\n            int to = g[v][i];\n            if (part[to] == -1) {\n              part[to] = !part[v], q[t++] = to;\n            } else {\n              ok &= part[to] != part[v];\n            }\n          }\n        }\n      }\n    }\n    cout << 1 << '\\n';\n    int x = 0, y = 0;\n    for (int i = 0; i < n; ++i) {\n      if (part[i] == 1) {\n        x++;\n      } else {\n        y++;\n      }\n    }\n    for (int i = 0, j = 0; i < n && j < (n + 1) / 2; ++i) {\n      if (x >= y && part[i] == 1) {\n        j++;\n        cout << i + 1 << ' ';\n      }\n      if (y > x && part[i] == 0) {\n        j++;\n        cout << i + 1 << ' ';\n      }\n    }\n  } else {\n    cout << 2 << '\\n';\n    vector<int> cycle;\n    cycle.push_back(cycle_st);\n    for (int v = cycle_end; v != cycle_st; v = p[v]) {\n      cycle.push_back(v);\n    }\n    cycle.push_back(cycle_st);\n    reverse(cycle.begin(), cycle.end());\n    cout << cycle.size() - 1 << '\\n';\n    for (size_t i = 0; i < cycle.size() - 1; ++i) {\n      cout << cycle[i] + 1 << ' ';\n    }\n  }\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "greedy", "implementation", "trees"], "dificulty": "2100", "interactive": false}