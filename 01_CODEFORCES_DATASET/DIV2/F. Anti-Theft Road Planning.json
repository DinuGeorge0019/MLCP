{
    "link": "https://codeforces.com//contest/1673/problem/F",
    "problemId": "1385668",
    "problem_idx": "F",
    "shortId": "1673F",
    "contest_number": "1673",
    "problem_submissions": {
        "E": [
            155426965,
            155417061,
            155442389,
            155435971,
            155444716,
            155445002,
            155444871,
            155514328,
            155514309,
            155514225,
            155443263,
            155444297,
            155443581,
            155433854
        ],
        "F": [
            155419208,
            155424822,
            155430193,
            155426235,
            155421394,
            155428770,
            155436120,
            155468393,
            155433714,
            155432038,
            155436911,
            155434672,
            155436663,
            155437291,
            155437403,
            155444380,
            155421502,
            155466705,
            155436336
        ],
        "D": [
            155415117,
            155435345,
            155420108,
            155439489,
            155431441,
            155419630,
            155415726,
            155421120,
            155422405,
            155419806,
            155421729,
            155424346,
            155424705,
            155419720,
            155443639,
            155434940,
            155418827,
            155423765
        ],
        "C": [
            155404978,
            155404876,
            155407310,
            155404678,
            155403723,
            155410318,
            155407177,
            155407649,
            155410425,
            155412404,
            155411432,
            155412241,
            155405106,
            155408638,
            155409170,
            155443684,
            155416480,
            155405320,
            155408554
        ],
        "B": [
            155402768,
            155402072,
            155401370,
            155411423,
            155405962,
            155405267,
            155404158,
            155402546,
            155402518,
            155406241,
            155407263,
            155417097,
            155402117,
            155403200,
            155414493,
            155417214,
            155402941,
            155413813
        ],
        "A": [
            155398139,
            155398122,
            155398102,
            155398465,
            155398314,
            155398797,
            155398162,
            155398613,
            155398972,
            155398376,
            155400350,
            155398178,
            155398450,
            155400124,
            155418014,
            155398258,
            155398425
        ]
    },
    "name": "F. Anti-Theft Road Planning",
    "statement": "A city has n^2 buildings divided into a grid of n rows and n columns.\r\nYou need to build a road of some length D(A,B) of your choice between\r\neach pair of adjacent by side buildings A and B. Due to budget\r\nlimitations and legal restrictions, the length of each road must be a\r\npositive integer and .There is a thief in the city who will start from\r\nthe topmost, leftmost building (in the first row and the first column)\r\nand roam around the city, occasionally stealing artifacts from some of\r\nthe buildings. He can move from one building to another adjacent\r\nbuilding by travelling through the road which connects them.You are\r\nunable to track down what buildings he visits and what path he follows\r\nto reach them. But there is one tracking mechanism in the city. The\r\ntracker is capable of storing a single integer x which is initially 0.\r\nEach time the thief travels from a building A to another adjacent\r\nbuilding B through a road of length D(A,B), the tracker changes x to x\r\noplus D(A,B). Each time the thief steals from a building, the tracker\r\nreports the value x stored in it and resets it back to 0.It is known\r\nbeforehand that the thief will steal in exactly k buildings but you will\r\nknow the values returned by the tracker only after the thefts actually\r\nhappen. Your task is to choose the lengths of roads in such a way that\r\nno matter what strategy or routes the thief follows, you will be able to\r\nexactly tell the location of all the buildings where the thefts occurred\r\nfrom the values returned by the tracker.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nint a[555],b[555];\nint n,q,X=1,Y=1;\n\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    rep(i,1,n-1){\n        a[i]=1<<(__builtin_ctz(i)*2);\n    }\n    rep(j,1,n-1){\n        b[j]=1<<(__builtin_ctz(j)*2+1);\n        // printf(\"b[%d]=%d\\n\",j,b[j]);\n    }\n    rep(i,1,n){\n        rep(j,1,n-1)printf(\"%d \",b[j]);\n        puts(\"\");\n    }\n    rep(i,1,n-1){\n        rep(j,1,n)printf(\"%d \",a[i]);\n        puts(\"\");\n    }\n    fflush(stdout);\n    while(q--){\n        int pt=read();\n        bool ok=1;\n        rep(i,1,n){\n            rep(j,1,n){\n                int qwq=pt;\n                int t1=min(X,i),t2=max(X,i);\n                int s1=min(Y,j),s2=max(Y,j);\n                rep(k,t1,t2-1)qwq^=a[k];\n                rep(k,s1,s2-1)qwq^=b[k];\n                if(qwq==0){\n                    X=i,Y=j;\n                    printf(\"%d %d\\n\",i,j);\n                    fflush(stdout);\n                    goto end;\n                }\n            }\n        }\n        end:;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "divide and conquer",
        "greedy",
        "interactive",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Anti-Theft Road Planning.json",
    "editorial_link": "https://codeforces.com//blog/entry/102389",
    "editorial": "TutorialFor now, lets ignore and assume .Letâs try to build the roads in\r\nsuch a way that no matter what path the thief takes to reach building ,\r\nthe tracker will always return a fixed value such that all are distinct.\r\nThen by knowing the values returned by the tracker, one can easily find\r\nwhich building the theft occurred in. The main problem here is not to\r\nchoose the lengths of the roads, since by choosing the length of road\r\nbetween buildings and as , one can always achieve this property. But\r\nthere is a constraint which needs to be satisfied: The total length of\r\nall roads must not exceed . This is, in fact, a tight constraint (model\r\nsolution uses ) due to which one needs to choose the values of very\r\nefficiently.Consider this problem Find a permutation of numbers from to\r\nsuch that the sum of XOR of consecutive integers is minimized. The\r\nanswer to this is Gray Code or Reflected Binary Code. In the standard\r\nGray Code, bit is flipped times, bit is flipped times, bit is flipped\r\ntimes, , bit is flipped time. The idea is to use small bits more number\r\nof times compared to the larger ones. Our task is to implement this idea\r\nin -dimensions. Letâs look at the algorithm used to build Gray Code. If\r\nwe have the Gray Code for bits, it can be extended to bits by taking a\r\ncopy of it, reflecting it and appending to the beginning of the\r\nreflected code and to the beginning of the original one. Here, if we\r\nhave the Gray Code for matrix, it can be first extended to a Gray Code\r\nfor matrix and this can further be extended to a Gray Code for matrix.\r\nIf we build a matrix using this algorithm, the total length of roads\r\nused will be . In this problem, . So, total length of roads used = .Once\r\nthis construction is complete, finding the buildings where thefts\r\noccurred is elementary since there can now be only one building\r\ncorresponding to each value returned by the tracker.Now, coming back to\r\nthe original problem, we can simply take the first rows and the first\r\ncolumns from the constructed matrix. The cost wonât increase and the\r\nproperties still hold.\r\n",
    "hint": []
}