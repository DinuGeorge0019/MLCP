{"link": "https://codeforces.com//contest/1673/problem/F", "problemId": "1385668", "problem_idx": "F", "shortId": "1673F", "contest_number": "1673", "problem_submissions": {"E": [155426965, 155417061, 155442389, 155435971, 155444716, 155445002, 155444871, 155514328, 155514309, 155514225, 155443263, 155444297, 155443581, 155433854], "F": [155419208, 155424822, 155430193, 155426235, 155421394, 155428770, 155436120, 155468393, 155433714, 155432038, 155436911, 155434672, 155436663, 155437291, 155437403, 155444380, 155421502, 155466705, 155436336], "D": [155415117, 155435345, 155420108, 155439489, 155431441, 155419630, 155415726, 155421120, 155422405, 155419806, 155421729, 155424346, 155424705, 155419720, 155443639, 155434940, 155418827, 155423765], "C": [155404978, 155404876, 155407310, 155404678, 155403723, 155410318, 155407177, 155407649, 155410425, 155412404, 155411432, 155412241, 155405106, 155408638, 155409170, 155443684, 155416480, 155405320, 155408554], "B": [155402768, 155402072, 155401370, 155411423, 155405962, 155405267, 155404158, 155402546, 155402518, 155406241, 155407263, 155417097, 155402117, 155403200, 155414493, 155417214, 155402941, 155413813], "A": [155398139, 155398122, 155398102, 155398465, 155398314, 155398797, 155398162, 155398613, 155398972, 155398376, 155400350, 155398178, 155398450, 155400124, 155418014, 155398258, 155398425]}, "name": "F. Anti-Theft Road Planning", "statement": "A city has n^2 buildings divided into a grid of n rows and n columns.\r\nYou need to build a road of some length D(A,B) of your choice between\r\neach pair of adjacent by side buildings A and B. Due to budget\r\nlimitations and legal restrictions, the length of each road must be a\r\npositive integer and .There is a thief in the city who will start from\r\nthe topmost, leftmost building (in the first row and the first column)\r\nand roam around the city, occasionally stealing artifacts from some of\r\nthe buildings. He can move from one building to another adjacent\r\nbuilding by travelling through the road which connects them.You are\r\nunable to track down what buildings he visits and what path he follows\r\nto reach them. But there is one tracking mechanism in the city. The\r\ntracker is capable of storing a single integer x which is initially 0.\r\nEach time the thief travels from a building A to another adjacent\r\nbuilding B through a road of length D(A,B), the tracker changes x to x\r\noplus D(A,B). Each time the thief steals from a building, the tracker\r\nreports the value x stored in it and resets it back to 0.It is known\r\nbeforehand that the thief will steal in exactly k buildings but you will\r\nknow the values returned by the tracker only after the thefts actually\r\nhappen. Your task is to choose the lengths of roads in such a way that\r\nno matter what strategy or routes the thief follows, you will be able to\r\nexactly tell the location of all the buildings where the thefts occurred\r\nfrom the values returned by the tracker.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nint a[555],b[555];\nint n,q,X=1,Y=1;\n\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    rep(i,1,n-1){\n        a[i]=1<<(__builtin_ctz(i)*2);\n    }\n    rep(j,1,n-1){\n        b[j]=1<<(__builtin_ctz(j)*2+1);\n        // printf(\"b[%d]=%d\\n\",j,b[j]);\n    }\n    rep(i,1,n){\n        rep(j,1,n-1)printf(\"%d \",b[j]);\n        puts(\"\");\n    }\n    rep(i,1,n-1){\n        rep(j,1,n)printf(\"%d \",a[i]);\n        puts(\"\");\n    }\n    fflush(stdout);\n    while(q--){\n        int pt=read();\n        bool ok=1;\n        rep(i,1,n){\n            rep(j,1,n){\n                int qwq=pt;\n                int t1=min(X,i),t2=max(X,i);\n                int s1=min(Y,j),s2=max(Y,j);\n                rep(k,t1,t2-1)qwq^=a[k];\n                rep(k,s1,s2-1)qwq^=b[k];\n                if(qwq==0){\n                    X=i,Y=j;\n                    printf(\"%d %d\\n\",i,j);\n                    fflush(stdout);\n                    goto end;\n                }\n            }\n        }\n        end:;\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "divide and conquer", "greedy", "interactive", "math"], "dificulty": "2400", "interactive": false}