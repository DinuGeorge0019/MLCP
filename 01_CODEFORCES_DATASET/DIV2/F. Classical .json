{
    "link": "https://codeforces.com//contest/1285/problem/F",
    "problemId": "512931",
    "problem_idx": "F",
    "shortId": "1285F",
    "contest_number": "1285",
    "problem_submissions": {
        "F": [
            68545833,
            68535522,
            68573334,
            96999211,
            96999146,
            68573161,
            69098509,
            68626658,
            68682994
        ],
        "E": [
            68524941,
            68518417,
            68530554,
            68529308,
            68531407,
            68531344,
            68531615,
            68534357,
            68534051,
            68529832,
            68540790,
            68535869,
            68541711,
            68538608,
            68538163,
            68537974,
            68541963,
            68539842,
            68536496,
            68538129
        ],
        "D": [
            68507082,
            68557516,
            68506902,
            68508017,
            68510947,
            68510777,
            68514189,
            68853550,
            68517438,
            68515728,
            68517316,
            68510494,
            68517322,
            68513984,
            68513219,
            68519377,
            68516492,
            68513650,
            68514808,
            68520824,
            68521323
        ],
        "C": [
            68504523,
            68504942,
            68504769,
            68508581,
            68506887,
            68517568,
            68507055,
            68509904,
            68509741,
            68512066,
            68504310,
            68506343,
            68505577,
            68506877,
            68502537,
            68507690,
            68510042,
            68506486,
            68506105,
            68511726
        ],
        "B": [
            68502726,
            68503606,
            68501596,
            68503575,
            68503622,
            68503646,
            68503039,
            68505606,
            68503233,
            68506583,
            68503941,
            68502210,
            68503653,
            68503110,
            68508414,
            68502653,
            68505318,
            68503675,
            68512385,
            68505519
        ],
        "A": [
            68497804,
            68499469,
            68497513,
            68497595,
            68499958,
            68498702,
            68497961,
            68500159,
            68498048,
            68499346,
            68497975,
            68497626,
            68497817,
            68498423,
            68498520,
            68497604,
            68497745,
            68497829,
            68499449,
            68499473
        ]
    },
    "name": "F. Classical ",
    "statement": "Given an array a, consisting of n integers, find:\r\nmax\r\nlimits_{1\r\nle i < j\r\nle n} LCM(a_i,a_j),where LCM(x, y) is the smallest positive integer that\r\nis divisible by both x and y. For example, LCM(6, 8) = 24, LCM(4, 12) =\r\n12, LCM(2, 3) = 6.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nint gcd(int a, int b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nlong long lcm(int a, int b){\n\treturn 1ll * a / gcd(a, b) * b;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; \n\tcin >> n;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.begin(), a.end());\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tlong long ans = a.back();\n\tconst int magic = 150;\n\tauto lookup = create<int>(magic, n + 1);\n\tfor(int i = 1; i < magic; i++){\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tlookup[i][j] = -1;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tint p = a[j] % i;\n\t\t\tif(p) lookup[i][j] = j;\n\t\t\telse if(j) lookup[i][j] = lookup[i][j - 1];\n\t\t}\n\t}\n\tint iter = 0;\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tunordered_set<int> dont;\n\t\titer = 0;\n\t\tfor(int j = i - 1; j >= 0 && iter <= 250; ){\n\t\t\tlong long m = 1ll * a[i] * a[j];\n\t\t\tif(m < ans) break;\n\t\t\tint g = gcd(a[i], a[j]);\n\t\t\tans = max(ans, m / g);\n\t\t\titer++;\n\t\t\tif(g >= magic) j--;\n\t\t\telse {\n\t\t\t\tdont.insert(g);\n\t\t\t\tint nj = j - 1;\n\t\t\t\twhile(nj >= 0){\n\t\t\t\t\tbool ch = false;\n\t\t\t\t\tfor(int v : dont) if(nj != lookup[v][nj]){\n\t\t\t\t\t\tnj = lookup[v][nj];\n\t\t\t\t\t\tch = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!ch) break;\n\t\t\t\t}\n\t\t\t\tj = nj;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Classical .json",
    "editorial_link": "https://codeforces.com//blog/entry/72950",
    "editorial": "Since , it makes sense to try and fix . Let\u00e2\u0080\u0099s call it . Now, let\u00e2\u0080\u0099s only\r\ncare about the multiples of in the input. Assume we divide them all by .\r\nWe now want the maximum product of 2 numbers in this new array.Let\u00e2\u0080\u0099s\r\nsort the numbers and iterate from the biggest to the smallest, keeping a\r\nstack. Assume the current number you\u00e2\u0080\u0099re iterating on is . While there is\r\na number in the stack coprime to , you can actually pop the top of the\r\nstack; you\u00e2\u0080\u0099ll never need it again. That\u00e2\u0080\u0099s because this number together\r\nwith a number smaller than can never give a better product than that of\r\na greater, or equal, number together with ! Now, we just need to figure\r\nout whether there\u00e2\u0080\u0099s a number coprime to in the stack. This could be\r\neasily done with inclusion-exclusion. Assume the number of multiples of\r\nin the stack is ; the number of elements in the stack coprime to is:\r\nWhere is the Mobius function. So we\u00e2\u0080\u0099ll just iterate on the integers from\r\ngreatest to smallest, and while there\u00e2\u0080\u0099s a number coprime to in the\r\nstack, we\u00e2\u0080\u0099ll keep maximizing the answer, popping, and updating the array\r\n. Then, we\u00e2\u0080\u0099ll push to the stack and also update .The complexity is where\r\nis the divisor count function. That\u00e2\u0080\u0099s because each number enters the\r\nroutine of calculating the maximum product of a coprime pair times, and\r\nwe iterate through its divisors in this routine.\r\n"
}