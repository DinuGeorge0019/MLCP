{
    "link": "https://codeforces.com//contest/777/problem/E",
    "problemId": "95273",
    "problem_idx": "E",
    "shortId": "777E",
    "contest_number": "777",
    "problem_submissions": {
        "A": [
            24966990,
            24969452,
            24968363,
            24961059,
            24970780,
            24961457,
            24961212,
            24964368,
            24961021,
            24961075,
            24961276,
            24968207,
            24961160,
            24961145,
            24961597,
            24961088,
            24961260,
            24961357,
            24961505
        ],
        "E": [
            24964879,
            24966304,
            24963804,
            24968582,
            24963318,
            24970420,
            24969486,
            24969542,
            24970873,
            24970390,
            24974213,
            24970580,
            24968519,
            24973982,
            24970975,
            24971187,
            24963290,
            24970842,
            24971523
        ],
        "B": [
            24964009,
            24967778,
            24967683,
            24963456,
            24969920,
            24963117,
            24963334,
            24963518,
            24962640,
            24962082,
            24964002,
            24966808,
            24963703,
            24964670,
            24963319,
            24962925,
            24965213,
            24963141,
            24964096
        ],
        "D": [
            24963351,
            24963866,
            24965089,
            24966596,
            24965947,
            24966910,
            24968904,
            24967595,
            24967923,
            24969584,
            24969186,
            24965258,
            24970085,
            24968109,
            24969127,
            24967832,
            24973541,
            24967166,
            24969092
        ],
        "C": [
            24962594,
            24962120,
            24965927,
            24965332,
            24967533,
            24965029,
            24965533,
            24961512,
            24966207,
            24962969,
            24966524,
            24962408,
            24965583,
            24963130,
            24965668,
            24964725,
            24967206,
            24965425,
            24966427
        ]
    },
    "name": "E. Hanoi Factory",
    "statement": "Of course you have heard the famous task about Hanoi Towers, but did you\r\nknow that there is a special factory producing the rings for this\r\nwonderful game? Once upon a time, the ruler of the ancient Egypt ordered\r\nthe workers of Hanoi Factory to create as high tower as possible. They\r\nwere not ready to serve such a strange order so they had to create this\r\nnew tower using already produced rings.There are rings in factory’s\r\nstock. The -th ring has inner radius , outer radius and height . The\r\ngoal is to select some subset of rings and arrange them such that the\r\nfollowing conditions are satisfied: Outer radiuses form a non-increasing\r\nsequence, i.e. one can put the -th ring on the -th ring only if . Rings\r\nshould not fall one into the the other. That means one can place ring on\r\nthe ring only if . The total height of all rings used should be maximum\r\npossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n#define N 401000\n#define LL long long\nstruct node\n{\n    int a, b, h;\n} S[N];\nint comp (node x, node y)\n{\n    return x.b != y.b? x.b > y.b: x.a > y.a;\n}\nint tot;\nint p[N];\nint lb[N], rb[N], lc[N], rc[N]; LL mx[N], tg[N];\nLL f[N], ans;\nint psdw(int t)\n{\n    tg[lc[t]] = max(tg[t], tg[lc[t]]);\n    tg[rc[t]] = max(tg[t], tg[rc[t]]);\n        mx[lc[t]] = max(tg[t], mx[lc[t]]);\n        mx[rc[t]] = max(tg[t], mx[rc[t]]);\n        tg[t] = 0;\n}\nvoid upd(int t)\n{\n    mx[t] = max(mx[lc[t]], mx[rc[t]]);\n}\nint build(int l, int r)\n{\n    int t = ++ tot;\n    lb[t] = l; rb[t] = r;\n    if (l != r)\n    {\n        lc[t] = build(l, (l + r) / 2);\n        rc[t] = build((l + r) / 2 + 1, r);\n    }\n    return t;\n}\nLL ask(int t, int l, int r)\n{\n    if (l > r) return 0;\n    if (l <= lb[t] && rb[t] <= r) return mx[t];\n    psdw(t);\n    LL mm = 0;\n    if (l <= rb[lc[t]]) mm = max(mm, ask(lc[t], l, r));\n    if (r >= lb[rc[t]]) mm = max(mm, ask(rc[t], l, r));\n    return mm;\n}\nvoid put(int t, int l, int r, LL d)\n{\n    if (l > r) return;\n    if (l <= lb[t] && rb[t] <= r)\n    {\n        tg[t] = max(tg[t], d);\n        mx[t] = max(mx[t], d);\n        return;\n    }\n    psdw(t);\n    if (l <= rb[lc[t]]) put(lc[t], l, r, d);\n    if (r >= lb[rc[t]]) put(rc[t], l, r, d);\n    upd(t);\n}\nint P[N];\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        cin >> S[i].a >> S[i].b >> S[i].h,\n        p[i] = S[i].a, p[i + n] = S[i].b;\n    int tot = 0;\n    sort(p + 1, p + n * 2 + 1);\n    tot = unique(p + 1, p + n * 2 + 1) - p - 1;\n    for (int i = 1; i <= n; ++ i)\n        S[i].a = lower_bound(p + 1, p + tot + 1, S[i].a) - p,\n        S[i].b = lower_bound(p + 1, p + tot + 1, S[i].b) - p;\n    sort(S + 1, S + n + 1, comp);\n    build(1, tot);\n    for (int i = 1; i <= n; ++ i)\n    {\n        f[i] = ask(1, S[i].b, S[i].b) + S[i].h;\n        put(1, S[i].a + 1, S[i].b, f[i]);\n        ans = max(ans, f[i]);\n    }\n    cout << ans;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hanoi Factory.json",
    "editorial_link": "https://codeforces.com//blog/entry/50670",
    "editorial": "To start with make the following observation: if two rings and have\r\nequal outer radiuses they can be merged in one ring of the same outer\r\nradius, inner radius equal to and height equal to .Using the observation\r\nwe transform our problem to the one with distinct outer radiuses. Sort\r\nring by this radius in descending order. From this point we consider for\r\nall . For each ring we want to compute value maximum height of the tower\r\nthat ends with the ring . This dynamic programming can be computed in\r\ntime using the following formula: .There are two different ways to speed\r\nup the calculation of this dp: Keep rings sorted by inner radius in a\r\nseparate array. For each ring store its value of there and for others.\r\nTo get we have to query maximum on some suffix of this array: from the\r\none hand only rings with original index will be non-zero, from the other\r\nhand this will suffice the condition . This can be done using segment\r\ntree or binary indexed tree. Note that if and itâs possible to place\r\nring on ring and ring on ring , then itâs possible to place ring on ring\r\n. Indeed, from and follows . That means we only need to compute for each\r\nmaximum value such that . This can be done using data structures listed\r\nabove or just with a single pass over array with a stack. Go from left\r\nto right and keep indexes of all valid positions in increasing order.\r\nPop elements while they do not suffice condition and then put on the\r\ntop. For clarifications, check the following code: stack <int> opt;for\r\n(int i = 0; i < n; i++) { while (!opt.empty() && r[opt.back()].inner >=\r\nr[i].outer) opt.pop(); if (!opt.empty()) ans[i] = ans[opt.back()];\r\nans[i] += r[i].height; opt.push(i);}\r\n",
    "hint": []
}