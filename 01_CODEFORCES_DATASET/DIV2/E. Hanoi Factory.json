{"link": "https://codeforces.com//contest/777/problem/E", "problemId": "95273", "problem_idx": "E", "shortId": "777E", "contest_number": "777", "problem_submissions": {"A": [24966990, 24969452, 24968363, 24961059, 24970780, 24961457, 24961212, 24964368, 24961021, 24961075, 24961276, 24968207, 24961160, 24961145, 24961597, 24961088, 24961260, 24961357, 24961505], "E": [24964879, 24966304, 24963804, 24968582, 24963318, 24970420, 24969486, 24969542, 24970873, 24970390, 24974213, 24970580, 24968519, 24973982, 24970975, 24971187, 24963290, 24970842, 24971523], "B": [24964009, 24967778, 24967683, 24963456, 24969920, 24963117, 24963334, 24963518, 24962640, 24962082, 24964002, 24966808, 24963703, 24964670, 24963319, 24962925, 24965213, 24963141, 24964096], "D": [24963351, 24963866, 24965089, 24966596, 24965947, 24966910, 24968904, 24967595, 24967923, 24969584, 24969186, 24965258, 24970085, 24968109, 24969127, 24967832, 24973541, 24967166, 24969092], "C": [24962594, 24962120, 24965927, 24965332, 24967533, 24965029, 24965533, 24961512, 24966207, 24962969, 24966524, 24962408, 24965583, 24963130, 24965668, 24964725, 24967206, 24965425, 24966427]}, "name": "E. Hanoi Factory", "statement": "Of course you have heard the famous task about Hanoi Towers, but did you\r\nknow that there is a special factory producing the rings for this\r\nwonderful game? Once upon a time, the ruler of the ancient Egypt ordered\r\nthe workers of Hanoi Factory to create as high tower as possible. They\r\nwere not ready to serve such a strange order so they had to create this\r\nnew tower using already produced rings.There are rings in factory\u2019s\r\nstock. The -th ring has inner radius , outer radius and height . The\r\ngoal is to select some subset of rings and arrange them such that the\r\nfollowing conditions are satisfied: Outer radiuses form a non-increasing\r\nsequence, i.e. one can put the -th ring on the -th ring only if . Rings\r\nshould not fall one into the the other. That means one can place ring on\r\nthe ring only if . The total height of all rings used should be maximum\r\npossible.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint n;\n#define N 401000\n#define LL long long\nstruct node\n{\n    int a, b, h;\n} S[N];\nint comp (node x, node y)\n{\n    return x.b != y.b? x.b > y.b: x.a > y.a;\n}\nint tot;\nint p[N];\nint lb[N], rb[N], lc[N], rc[N]; LL mx[N], tg[N];\nLL f[N], ans;\nint psdw(int t)\n{\n    tg[lc[t]] = max(tg[t], tg[lc[t]]);\n    tg[rc[t]] = max(tg[t], tg[rc[t]]);\n        mx[lc[t]] = max(tg[t], mx[lc[t]]);\n        mx[rc[t]] = max(tg[t], mx[rc[t]]);\n        tg[t] = 0;\n}\nvoid upd(int t)\n{\n    mx[t] = max(mx[lc[t]], mx[rc[t]]);\n}\nint build(int l, int r)\n{\n    int t = ++ tot;\n    lb[t] = l; rb[t] = r;\n    if (l != r)\n    {\n        lc[t] = build(l, (l + r) / 2);\n        rc[t] = build((l + r) / 2 + 1, r);\n    }\n    return t;\n}\nLL ask(int t, int l, int r)\n{\n    if (l > r) return 0;\n    if (l <= lb[t] && rb[t] <= r) return mx[t];\n    psdw(t);\n    LL mm = 0;\n    if (l <= rb[lc[t]]) mm = max(mm, ask(lc[t], l, r));\n    if (r >= lb[rc[t]]) mm = max(mm, ask(rc[t], l, r));\n    return mm;\n}\nvoid put(int t, int l, int r, LL d)\n{\n    if (l > r) return;\n    if (l <= lb[t] && rb[t] <= r)\n    {\n        tg[t] = max(tg[t], d);\n        mx[t] = max(mx[t], d);\n        return;\n    }\n    psdw(t);\n    if (l <= rb[lc[t]]) put(lc[t], l, r, d);\n    if (r >= lb[rc[t]]) put(rc[t], l, r, d);\n    upd(t);\n}\nint P[N];\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        cin >> S[i].a >> S[i].b >> S[i].h,\n        p[i] = S[i].a, p[i + n] = S[i].b;\n    int tot = 0;\n    sort(p + 1, p + n * 2 + 1);\n    tot = unique(p + 1, p + n * 2 + 1) - p - 1;\n    for (int i = 1; i <= n; ++ i)\n        S[i].a = lower_bound(p + 1, p + tot + 1, S[i].a) - p,\n        S[i].b = lower_bound(p + 1, p + tot + 1, S[i].b) - p;\n    sort(S + 1, S + n + 1, comp);\n    build(1, tot);\n    for (int i = 1; i <= n; ++ i)\n    {\n        f[i] = ask(1, S[i].b, S[i].b) + S[i].h;\n        put(1, S[i].a + 1, S[i].b, f[i]);\n        ans = max(ans, f[i]);\n    }\n    cout << ans;\n}\n"], "input": "", "output": "", "tags": ["brute force", "data structures", "dp", "greedy", "sortings"], "dificulty": "2000", "interactive": false}