{
    "link": "https://codeforces.com//contest/1855/problem/E",
    "problemId": "2119328",
    "problem_idx": "E",
    "shortId": "1855E",
    "contest_number": "1855",
    "problem_submissions": {
        "D": [
            216333466,
            216282930,
            216304321,
            216288702,
            216315573,
            216283245,
            216277730,
            216313898,
            216306202,
            216314199,
            216313213,
            216292626,
            216312027,
            216805668,
            216805337,
            216315274,
            216317158,
            216319074,
            216320064,
            216332564,
            216313414
        ],
        "C1": [
            216327527,
            216265798,
            216278749,
            216252157,
            216263595,
            216261550,
            216296642,
            216259910,
            216265017,
            216265900,
            216266262,
            216246799,
            216254795,
            216264575,
            216271415,
            216266184,
            216256689,
            216266334,
            216273339,
            216281116
        ],
        "C2": [
            216327433,
            216333169,
            216278334,
            216276389,
            216290961,
            216261266,
            216308671,
            216288782,
            216279381,
            216300131,
            216292122,
            216299685,
            216284770,
            216286877,
            216294260,
            216296589,
            216302878,
            216296848,
            216273167,
            216291700
        ],
        "B": [
            216319187,
            216239575,
            216251320,
            216239516,
            216251539,
            216242319,
            216247221,
            216244993,
            216252246,
            216251732,
            216255891,
            216249364,
            216243332,
            216244237,
            216260716,
            216245518,
            216240380,
            216281460,
            216248098,
            216245806
        ],
        "A": [
            216318294,
            216235675,
            216247364,
            216235951,
            216238094,
            216238019,
            216237152,
            216237362,
            216248778,
            216237335,
            216241402,
            216238578,
            216237824,
            216238112,
            216254438,
            216237599,
            216236030,
            216240134,
            216239210,
            216238506
        ],
        "E": [
            216307488,
            216320937,
            216323420,
            216339638,
            216487251,
            216321175,
            216593212,
            216352369
        ],
        "F": [
            216295921,
            216331597,
            216627506
        ]
    },
    "name": "E. Expected Destruction",
    "statement": "You have a set S of n distinct integers between 1 and m.Each second you\r\ndo the following steps: Pick an element x in S uniformly at random.\r\nRemove x from S. If x+1\r\nleq m and x+1 is not in S, add x+1 to S. What is the expected number of\r\nseconds until S is empty?Output the answer modulo 1\r\n,000\r\n,000\r\n,007.Formally, let P = 1\r\n,000\r\n,000\r\n,007. It can be shown that the answer can be expressed as an irreducible\r\nfraction\r\nfrac{a}{b}, where a and b are integers and b\r\nnot\r\nequiv 0\r\npmod{P}. Output the integer equal to a\r\ncdot b^{-1}\r\nbmod P. In other words, output an integer z such that 0\r\nle z < P and z\r\ncdot b\r\nequiv a\r\npmod{P}.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n// #pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int N=507;\nconst int INF=1e9;\nconst int mod=1e9+7;\nconst double pi=acos(-1);\nmt19937_64 rng(time(NULL));\n \nint n,m;\nint dp[N][N];\nint a[N];\nint inv2=(mod+1)/2;\nint solve(int u,int v){\n  if (u==v) return 0;\n  if (dp[u][v]!=-1) return dp[u][v];\n  if (v==m+1) return m+1-u;\n  return dp[u][v]=(1+solve(u+1,v)+solve(u,v+1))*inv2%mod;\n}\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin>>n>>m;\n  for (int i=1;i<=m+1;++i){\n    for (int j=1;j<=m+1;++j) dp[i][j]=-1;\n  }\n  for (int i=1;i<=m;++i){\n    for (int j=i+1;j<=m;++j) solve(i,j);\n  }\n  for (int i=0;i<n;++i) cin>>a[i];\n  int ans=0;\n  ans=m+1-a[n-1];\n  // cerr<<dp[2][3]<<endl;\n  for (int i=0;i+1<n;++i) ans=(ans+dp[a[i]][a[i+1]])%mod;\n  cout<<ans%mod;\n}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Expected Destruction.json",
    "editorial_link": "https://codeforces.com//blog/entry/118540",
    "editorial": "Consider an (n+1)\u00d7(m+1)\n grid, where the i\n-th row initially contains a block in column Si\n, and row n+1\n contains a block in column m+1\n.\n\nThe set is empty if all the blocks are in column m+1\n; i.e., if every block has reached the block in the following row.\nEvery \"connected component\" of blocks (except the last one) represents an element in the set. These components move equiprobably.\nLet's calculate the expected time required for the block in row x\n to \"reach\" the block in row x+1\n. If you consider a single pair of blocks, every block moves with probability 1/2\n, unless block x+1\n is in column m+1\n.\n\nSo, you can calculate dpi,j=\n expected number of moves of the block x\n before it reaches the block x+1\n, if the block x\n is in position i\n and the block x+1\n is in position j\n.\n\nThe base cases are dpi,m+1=(m+1)?i\n (because only the block x\n can move) and dpi,i=0\n (because block x\n has already reached block x+1\n). In the other cases, dpi,j=((dpi+1,j+1)+dpi,j+1)/2\n.\n\nBy linearity of expectation, the answer is the sum of dpSi,Si+1\n."
}