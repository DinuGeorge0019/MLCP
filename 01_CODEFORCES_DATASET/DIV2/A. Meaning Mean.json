{
    "link": "https://codeforces.com//contest/2021/problem/A",
    "problemId": "2929691",
    "problem_idx": "A",
    "shortId": "2021A",
    "contest_number": "2021",
    "problem_submissions": {
        "D": [
            284590256,
            284590001,
            284586301,
            284623851,
            284569171,
            284578878,
            284712748,
            284578625,
            284581515,
            284581353,
            284637993
        ],
        "E3": [
            284578176,
            284565599,
            284600842,
            284850992,
            284584216,
            284618196,
            284597636,
            284599022,
            284585148,
            286020331,
            284745105
        ],
        "E1": [
            284577293,
            284599054,
            284566976,
            284599574,
            284568532,
            284584477,
            284579805,
            284586608,
            284600476,
            284585423,
            284594051,
            284576473,
            284592731,
            284581221,
            284582830,
            284576965,
            286020463,
            284573682,
            284745154,
            284585073
        ],
        "E2": [
            284576481,
            284599368,
            284566551,
            284571784,
            284584447,
            284580377,
            284586193,
            284585357,
            284576258,
            284585492,
            284583546,
            284582548,
            286020438,
            284593395,
            284766277,
            284587863
        ],
        "C2": [
            284552959,
            284550125,
            284578847,
            284570668,
            284557743,
            284572571,
            284559765,
            284559531,
            284592443,
            284564745,
            284553608,
            284551809,
            284555032,
            284564040,
            284565535,
            284591262,
            284564727,
            284560092
        ],
        "C1": [
            284543395,
            284545189,
            284579118,
            284555011,
            284551439,
            284544381,
            284549845,
            284558858,
            284582609,
            284556392,
            284545368,
            284554154,
            284545358,
            284546156,
            284555833,
            284553560,
            284550666,
            284546712,
            284545533,
            284552561
        ],
        "B": [
            284537997,
            284541648,
            284545572,
            284550280,
            284536827,
            284538339,
            284543136,
            284541306,
            284577835,
            284541582,
            284538597,
            284539525,
            284540971,
            284538476,
            284541915,
            284545007,
            284543924,
            284540121,
            284540098,
            284544260
        ],
        "A": [
            284536034,
            284541336,
            284535964,
            284545882,
            284543072,
            284535980,
            284537720,
            284537149,
            284572305,
            284541440,
            284535781,
            284536205,
            284539247,
            284535865,
            284537520,
            284541705,
            284541775,
            284537231,
            284537773,
            284536991
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134873",
    "editorial": "For now, let\u00e2\u0080\u0099s ignore the floor operation, so an operation is merging\r\ntwo elements and into one element .Consider the end result. Each initial\r\nelement in must contribute a fractional coefficient to the final result.\r\nIt turns out that the sum of the coefficients is fixed (it must be ).\r\nThat means we can greedily give the biggest values in the biggest\r\ncoefficients.One way to do this is by sorting in ascending order. We\r\nmerge and , then merge that result with , then merge that result with ,\r\nand so on until . If we do this, contributes times, contributes times,\r\ncontributes times, and so on. This is the optimal way to get the maximum\r\nfinal result.It turns out that the strategy above is also the optimal\r\nstrategy for the original version of the problem. So we can simulate\r\nthat process to get the answer.Time complexity for each test case:\r\n",
    "name": "A. Meaning Mean",
    "statement": "Pak Chanek has an array a of n positive integers. Since he is currently\r\nlearning how to calculate the floored average of two numbers, he wants\r\nto practice it on his array a.While the array a has at least two\r\nelements, Pak Chanek will perform the following three-step operation:\r\nPick two different indices i and j (1\r\nleq i, j\r\nleq |a|; i\r\nneq j), note that |a| denotes the current size of the array a. Append\r\nlfloor\r\nfrac{a_i+a_j}{2}\r\nrfloor^{\r\ntext{ }} to the end of the array. Remove elements a_i and a_j from the\r\narray and concatenate the remaining parts of the array. For example,\r\nsuppose that a=[5,4,3,2,1,1]. If we choose i=1 and j=5, the resulting\r\narray will be a=[4,3,2,1,3]. If we choose i=4 and j=3, the resulting\r\narray will be a=[5,4,1,1,2].After all operations, the array will consist\r\nof a single element x. Find the maximum possible value of x if Pak\r\nChanek performs the operations optimally.^{\r\ntext{ }}\r\nlfloor x\r\nrfloor denotes the floor function of x, which is the greatest integer\r\nthat is less than or equal to x. For example,\r\nlfloor 6\r\nrfloor = 6,\r\nlfloor 2.5\r\nrfloor=2,\r\nlfloor -3.6\r\nrfloor=-4 and\r\nlfloor\r\npi\r\nrfloor=3\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;int Qread(){\tint x=0;bool f=false;char ch=getchar();\twhile(ch<'0'||ch>'9') f|=(ch=='-'),ch=getchar();\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\treturn f?-x:x;}int n;int a[100];void solve(){\tn=Qread();\tfor(int i=1;i<=n;i++) a[i]=Qread();\tsort(a+1,a+n+1);\tfor(int i=2;i<=n;i++)\t\ta[i]=(a[i-1]+a[i])>>1;\tprintf(\"%d\\n\",a[n]);}int main(){\tint T=Qread();\twhile(T--) solve();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Meaning Mean.json"
}