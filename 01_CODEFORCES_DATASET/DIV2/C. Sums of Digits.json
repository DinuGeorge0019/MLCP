{
    "link": "https://codeforces.com//contest/509/problem/C",
    "problemId": "21539",
    "problem_idx": "C",
    "shortId": "509C",
    "contest_number": "509",
    "problem_submissions": {
        "F": [
            9650295,
            9648525,
            9652941,
            66412652,
            9656510,
            9654779,
            9656634
        ],
        "D": [
            9649357,
            9654774,
            17987388,
            9655232,
            9650962,
            9652519,
            9653543,
            9654747,
            9652061,
            9654982,
            9653984,
            9647661,
            9657026,
            9650855
        ],
        "E": [
            9647331,
            9646822,
            9648254,
            9648062,
            9650747,
            9650969,
            9652383,
            9648899,
            9651327,
            9650674,
            9650867,
            9649973,
            9651180,
            9649729,
            9651615,
            9648041,
            9654967,
            9654814,
            9654669,
            9653966,
            9647539
        ],
        "C": [
            9645828,
            9652330,
            9645693,
            9644588,
            9646725,
            9649235,
            9647186,
            9656672,
            9648094,
            9645838,
            9646105,
            9648771,
            9647552,
            9649596,
            9652387,
            9650184,
            9650446
        ],
        "B": [
            9642318,
            9650812,
            9644457,
            9646310,
            9647229,
            9643332,
            9648725,
            9645322,
            9642950,
            9643872,
            9643385,
            9643757,
            9643187,
            9643245,
            9644721,
            9645020,
            9642364,
            9643723,
            9651476
        ],
        "A": [
            9640468,
            9644536,
            9640418,
            9640550,
            9640578,
            9642285,
            9643656,
            9644283,
            9640433,
            9640454,
            9641139,
            9641249,
            9640654,
            9640465,
            9642716,
            9641084,
            9640702,
            9640994,
            9640877
        ]
    },
    "name": "C. Sums of Digits",
    "statement": "Vasya had a sequence of positive integers , ..., . Vasya used it to\r\nbuild a new sequence , ..., , where is the sum of digits of ’s decimal\r\nrepresentation. Then sequence got lost and all that remained is sequence\r\n.Vasya wonders what the numbers could be like. Of all the possible\r\noptions he likes the one sequence with the minimum possible last number\r\n. Help Vasya restore the initial sequence.It is guaranteed that such a\r\nsequence always exists.\r\n",
    "solutions": [
        "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\nint n,a[110000],b[110000],sum;\nvoid work(int x,int y,int z){\n     if(x==0)return;\n     for(int i=z;i<=9;i++)\n       if(y-i>=0 && y-i<=(x-1)*9){\n         b[x]=i;\n         work(x-1,y-i,0);\n         break;\n       }\n}\nint main(){\n    scanf(\"%d\",&n);\n    a[0]=0;sum=0;\n    for(int zz=1;zz<=n;zz++){\n      int x;\n      scanf(\"%d\",&x);\n      int tt=x;\n      bool pd=0;x-=sum;\n      sum=tt;\n      for(int i=0;i<=a[0];i++)b[i]=a[i];\n      for(int i=1;i<=a[0];i++){\n        x+=a[i];\n        for(int j=a[i]+1;j<=9;j++)\n          if(x-j>=0 && x-j<=(i-1)*9){\n            b[i]=j;\n            work(i-1,x-j,0);\n            for(int k=a[0];k>0;k--)printf(\"%d\",b[k]),a[k]=b[k];\n            printf(\"\\n\");\n            pd=1;\n            break;\n          }\n        if(pd)break;\n        }\n      if(!pd){\n        for(int i=a[0]+1;;i++)\n          if(i*9>=x){\n          work(i,x,1);\n          a[0]=i;\n          for(int k=a[0];k;k--)printf(\"%d\",b[k]),a[k]=b[k];\n          printf(\"\\n\");\n          break;\n        }\n      }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Sums of Digits.json",
    "editorial_link": "https://codeforces.com//blog/entry/16119",
    "editorial": "The algorithm is greedy: first, take the minimal number with sum of\r\ndigits call it . Then, on the -th step take as the minimal number with\r\nsum of digits , which is more than . It can be easily proven that this\r\nalgorithm gives an optimal answer. But how to solve the subproblem:\r\ngiven and , find the minimal number with sum of digits , which is more\r\nthan ? We use a standard approach: iterate through the digits of from\r\nright to left, trying to increase the current digit and somehow change\r\nthe digits to the right in order to reach the sum of digits equal to .\r\nNote that if we are considering the -th digit from the right and\r\nincrease it, we can make the sum of least significant digits to be any\r\nnumber between and . When we find such position, that increasing a digit\r\nin it and changing the least significant digits gives us a number with\r\nsum of digits , we stop the process and obtain the answer. Note that if\r\nleast significant digits should have sum (where ), we should obtain the\r\nanswer greedily, going from the right to the left and putting to the\r\nposition the largest digit we can. Let us bound the maximal length of\r\nthe answer, i.e. of . If some has at least digits, than we take the\r\nminimal such that . Than between and there exist numbers with any sum of\r\ndigits between and . If , than , which is the upper bound of all . So,\r\nin the constraints of the problem, will be less than . Than, similarly,\r\nand so on. So, the length of the answer increases by no more than one\r\nafter reaching the length of . Consequently, the maximal length of the\r\nanswer canât be more than . The complexity of solution is . Since , ,\r\nthe solution runs much faster the time limit. Prepared by:\r\nEndagorionAuthor of editorial: Kostroma\r\n",
    "hint": []
}