{
    "link": "https://codeforces.com//contest/1042/problem/E",
    "problemId": "220709",
    "problem_idx": "E",
    "shortId": "1042E",
    "contest_number": "1042",
    "problem_submissions": {
        "F": [
            42987714,
            42984651,
            42989319,
            42983649,
            42989168,
            42989334,
            42988495,
            42988621,
            42990991,
            42984782,
            42991318,
            42984734,
            42989762,
            42989508,
            42989199,
            42985445,
            42984262,
            42986731
        ],
        "A": [
            42984167,
            42973725,
            42974031,
            42973482,
            42973429,
            42973632,
            42973538,
            42974330,
            42975529,
            42973708,
            42993729,
            42975026,
            42986836,
            42989940,
            42973749,
            42992518,
            42973915,
            42973554,
            42973556,
            42973468
        ],
        "E": [
            42983656,
            42983448,
            42981915,
            42988922,
            42984518,
            42985483,
            42983668,
            42985621,
            42980250,
            42987926,
            42982614,
            42990994,
            42986527,
            42985364,
            42983020,
            42986197,
            42989170,
            42987817,
            42982499
        ],
        "C": [
            42982112,
            42977810,
            42976676,
            42978400,
            42979933,
            42981591,
            42978723,
            42979152,
            42981616,
            43020286,
            42983391,
            42977530,
            42987879,
            42980102,
            42982752,
            42979907,
            42979506,
            42982122,
            42993016,
            42980948,
            42977178
        ],
        "B": [
            42975906,
            42974331,
            42974910,
            42974847,
            42974321,
            42975176,
            42975023,
            42975453,
            42976952,
            42975043,
            42975357,
            42976939,
            42975515,
            42976516,
            42974965,
            42975963,
            42975276,
            42974792,
            42974885,
            42974787
        ],
        "D": [
            42975097,
            42975491,
            42978165,
            42980511,
            42976657,
            42978683,
            42980559,
            42982541,
            42983622,
            43020160,
            42982284,
            42979330,
            42979227,
            42983154,
            42978119,
            42977687,
            42982730,
            42983764,
            42980017,
            42976894,
            42978512
        ]
    },
    "name": "E. Vasya and Magic Matrix",
    "statement": "Vasya has got a magic matrix a of size n\r\ntimes m. The rows of the matrix are numbered from 1 to n from top to\r\nbottom, the columns are numbered from 1 to m from left to right. Let\r\na_{ij} be the element in the intersection of the i-th row and the j-th\r\ncolumn.Vasya has also got a chip. Initially, the chip is in the\r\nintersection of the r-th row and the c-th column (that is, in the\r\nelement a_{rc}). Vasya performs the following process as long as\r\npossible: among all elements of the matrix having their value less than\r\nthe value of the element with the chip in it, Vasya randomly and\r\nequiprobably chooses one element and moves his chip to this\r\nelement.After moving the chip, he adds to his score the square of the\r\nEuclidean distance between these elements (that is, between the element\r\nin which the chip is now and the element the chip was moved from). The\r\nprocess ends when there are no elements having their values less than\r\nthe value of the element with the chip in it.Euclidean distance between\r\nmatrix elements with coordinates (i_1, j_1) and (i_2, j_2) is equal to\r\nsqrt{(i_1-i_2)^2 + (j_1-j_2)^2}.Calculate the expected value of the\r\nVasya\u2019s final score.It can be shown that the answer can be represented\r\nas\r\nfrac{P}{Q}, where P and Q are coprime integer numbers, and Q\r\nnot\r\nequiv 0\u00a0(mod \u00a0 998244353). Print the value P\r\ncdot Q^{-1} modulo 998244353.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cstdio>\n// Linsanity is back \n// Who\u2019s Kobe? \n// Fisherman can\u2019t stop us\n// Average ABCDE on a good day\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nint N, M, R, C;\npair<int, pair<int, int> > A[1000005];\n\nll expo(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    if (b == 1)\n        return a % MOD;\n    if (b % 2 == 0)\n        return expo(a*a % MOD, b/2);\n    return a*expo(a*a % MOD, (b-1)/2) % MOD;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n\n    cin >> N >> M;\n    for (int i = 0; i < N; i++)\n        for (int j = 0, a; j < M; j++)\n        {\n            cin >> a;\n            A[M*i + j] = make_pair(a, make_pair(i + 1, j + 1));\n        }\n    cin >> R >> C;\n\n    sort(A, A + N*M);\n    ll sumsq = 0, sumx = 0, sumy = 0, totale = 0;\n    for (int i = 0; i < N*M;)\n    {\n        int j = i;\n        ll sumsq1 = 0, sumx1 = 0, sumy1 = 0, e1 = 0;\n        while (j < N*M && A[i].first == A[j].first)\n        {\n            ll x = A[j].second.first, y = A[j].second.second;\n            ll e = (sumsq + i*(x*x % MOD + y*y % MOD) % MOD) % MOD;\n            e = (e - 2*x*sumx % MOD) % MOD;\n            e = (e - 2*y*sumy % MOD) % MOD;\n            e = (e + totale) % MOD;\n            e = e*expo(i, MOD - 2) % MOD;\n            if (x == R && y == C)\n            {\n                if (e < 0)\n                    e += MOD;\n                cout << e << \"\\n\";\n                return 0;\n            }\n            sumsq1 = (sumsq1 + x*x % MOD + y*y % MOD) % MOD;\n            sumx1 = (sumx1 + x) % MOD;\n            sumy1 = (sumy1 + y) % MOD;\n            e1 = (e1 + e) % MOD;\n            j++;\n        }\n        sumsq = (sumsq + sumsq1) % MOD;\n        sumx = (sumx + sumx1) % MOD;\n        sumy = (sumy + sumy1) % MOD;\n        totale = (totale + e1) % MOD;\n        i = j;\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Vasya and Magic Matrix.json",
    "editorial_link": "https://codeforces.com/blog/entry/61891",
    "editorial": "Let\u00e2\u0080\u0099s iterate over all the elements of the matrix in order of increasing\r\ntheir values and calculate the expected value for these elements to\r\nsolve the problem. Suppose that now we consider the element at\r\nintersection of the -th row and the -th column. Let the elements having\r\nvalue less than the value of the current element be , where is the row\r\nof the -th element and is the column of the -th element.Then the\r\nexpected value for the current element can be calculated as follows: ,\r\nwhere is the expected value of the -th element. We can rewrite the\r\nformula to the following form using equivalent transforms: .So we need\r\nto maintain five sums for the elements having value less than current\r\nelement: sum of their values, sum of their row indices, sum of their\r\ncolumn indices, sum of squares of their row indices and sum of squares\r\nof their column indices. We can maintain all these sums if we will\r\niterate over all the elements continuously in order of increasing their\r\nvalues.It is also necessary to note that we need to process all the\r\nelements having equal values at once and recalculate all the sums right\r\nafter calculating the expected values for these elements.\r\n"
}