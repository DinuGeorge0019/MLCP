{
    "link": "https://codeforces.com//contest/1549/problem/C",
    "problemId": "1062376",
    "problem_idx": "C",
    "shortId": "1549C",
    "contest_number": "1549",
    "problem_submissions": {
        "F2": [
            124954760
        ],
        "B": [
            124947565,
            124545808,
            124541593,
            124946530,
            124553166,
            124545711,
            124536914,
            124556540,
            124566832,
            124527986,
            124941325,
            124545594,
            124575237,
            124552639,
            124521339,
            124527240,
            124534396,
            124536389,
            124529098,
            124547548,
            124525326,
            124539590,
            124546541
        ],
        "A": [
            124947501,
            124518305,
            124519670,
            124946570,
            124520785,
            124519203,
            124517993,
            124517559,
            124518317,
            124518952,
            124941237,
            124534955,
            124569653,
            124519648,
            124517299,
            124518094,
            124521899,
            124520868,
            124518074,
            124519228,
            124517443,
            124519076,
            124518992
        ],
        "F1": [
            124584680,
            124595832,
            124599734,
            124593371,
            124597616,
            124593738,
            124591194,
            124592802,
            124602219,
            124602384,
            124588472,
            124753532,
            124592653,
            124603568,
            124595865
        ],
        "E": [
            124572687,
            124578681,
            124586160,
            124580564,
            124586278,
            124587026,
            124603080,
            124600315,
            124577736,
            124595081,
            124580521,
            124597748,
            124594829,
            124597255,
            124685628,
            124601974
        ],
        "D": [
            124558908,
            124554190,
            124550650,
            124565038,
            124571505,
            124565266,
            124557657,
            124634855,
            124586699,
            124566420,
            124566608,
            124571026,
            124544812,
            124558707,
            124568055,
            124617780,
            124551649,
            124555888,
            124569746,
            124549100,
            124571724,
            124554851
        ],
        "C": [
            124534727,
            124537090,
            124536290,
            124552036,
            124551687,
            124549175,
            124538153,
            124547780,
            124552849,
            124553941,
            124540508,
            124527050,
            124538078,
            124556164,
            124573095,
            124538823,
            124554597,
            124536966,
            124553733,
            124540516
        ]
    },
    "name": "C. Web of Lies",
    "statement": "Cersei Lannister, by George R. R. MartinThere are n nobles, numbered\r\nfrom 1 to n. Noble i has a power of i. There are also m \"friendships\". A\r\nfriendship between nobles a and b is always mutual.A noble is defined to\r\nbe if both of the following conditions are satisfied: the noble has at\r\nleast one friend, and of that noble’s friends have a higher power. You\r\nwill have to process the following three types of queries. Add a\r\nfriendship between nobles u and v. Remove a friendship between nobles u\r\nand v. Calculate the answer to the following process. The process: all\r\nvulnerable nobles are simultaneously killed, and all their friendships\r\nend. Then, it is possible that new nobles become vulnerable. The process\r\nrepeats itself until no nobles are vulnerable. It can be proven that the\r\nprocess will end in finite time. After the process is complete, you need\r\nto calculate the number of remaining nobles.Note that the results of the\r\nprocess are carried over between queries, that is, every process starts\r\nwith all nobles being alive!\r\n",
    "solutions": [
        "// Problem: C. Web of Lies\n// Contest: Codeforces - Codeforces Round #736 (Div. 2)\n// URL: https://codeforces.com/contest/1549/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define chkmx(a,b) ((a)=max((a),(b)))\n#define chkmn(a,b) ((a)=min((a),(b)))\nusing namespace std;\ntemplate<typename T>\ninline void read(T &x){x=0;char c=getchar();bool f=false;for(;!isdigit(c);c=getchar())f|=c=='-';for(;isdigit(c);c=getchar())x=x*10+c-'0';if(f)x=-x;}\ntemplate<typename T ,typename ...Arg>inline void read(T &x,Arg &...args){read(x);read(args...);}\ntemplate<typename T>inline void write(T x){if(x<0)putchar('-'),x=-x;if(x>=10)write(x/10);putchar(x%10+'0');}\n//#define int long long\ntypedef long long ll;\nconst int N=2e5+100;\nint n,m;int deg[N];int ans;\nvoid add(int u,int v){\n\tif(u>v)swap(u,v);\n\tans-=deg[u]==0;\n\tdeg[u]++;\n}\nvoid del(int u,int v){\n\tif(u>v)swap(u,v);\n\tdeg[u]--;\n\tans+=deg[u]==0;\n}\nsigned main(){\n\tread(n,m);ans=n;\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;read(u,v);add(u,v);\n\t}\n\tint q;read(q);\n\twhile(q--){\n\t\tint op,u,v;read(op);\n\t\tif(op==1)read(u,v),add(u,v);\n\t\telse if(op==2)read(u,v),del(u,v);\n\t\telse write(ans),putchar('\\n');\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Web of Lies.json",
    "editorial_link": "https://codeforces.com//blog/entry/93586",
    "editorial": "SolutionDue to the queries, actually simulating the process each time\r\nwill be too expensive.Proof that the Process will End: Assume after\r\nround , nobles are killed. If , then the state of the graph doesnât\r\nchange, so the process will have ended. If , then the number of nobles\r\ndecreases. Thus, the maximum number of rounds the process can last is ,\r\nso it must end. At the end of the process, no two nobles will still be\r\nfriends.Proof by Contradiction: Assume that nobles and (assume WLOG that\r\n) are still friends and the process is over. In order for to avoid being\r\nkilled, there must be a noble weaker than that is also a friend of . The\r\nsame logic then applies to , and we have an infinite descent argument.\r\nThere are only a finite number of nobles weaker than , so there will be\r\na contradiction. If all of a nobleâs friends are weaker than it, that\r\nnoble cannot be killed.Direct Proof: Since none of the nobleâs friends\r\nare stronger than it, it is impossible for of them to be stronger at any\r\npoint in the process. By combining Lemmas 1 and 2, we can prove that if\r\nALL of a nobleâs friends are weaker than it, that noble survives,\r\notherwise it will die. This leads to the solution.Maintain in an array\r\nthe number of nobles weaker than noble . Since the updates guarantee\r\nthat the edge being removed/added does/doesnât exist respectively, we\r\nonly need to keep track of the number of edges of each noble.\r\nEssentially, a noble survives if and only if weaker[i]==edges[i]. After\r\nlinear precomputation, updates and queries take constant time.The time\r\ncomplexity is .\r\n",
    "hint": [
        "Hint 1 For various graphs, try and simulate the process. Determine a rule to figure out whether a noble survives or not.",
        "Hint 2 When you add or remove a single edge, how much can the answer change by? Try and recalculate the answer in ."
    ]
}