{
    "link": "https://codeforces.com//contest/1688/problem/D",
    "problemId": "1419362",
    "problem_idx": "D",
    "shortId": "1688D",
    "contest_number": "1688",
    "problem_submissions": {
        "F": [
            159410825,
            159527472,
            159472113
        ],
        "C": [
            159404501,
            159365159,
            159366341,
            159373586,
            159362776,
            159370629,
            159370154,
            159369677,
            159381261,
            159374462,
            159381251,
            159381152,
            159372318,
            159366961,
            159376004,
            159380988,
            159381329,
            159386074
        ],
        "E": [
            159391189,
            159380776,
            159384621,
            159398500,
            159397765,
            159404212,
            159394358,
            159393997,
            159399468,
            159392431,
            159395743,
            159400327,
            159402238,
            159399827,
            159395270,
            159393471,
            159393150,
            159396147
        ],
        "B": [
            159388484,
            159355530,
            159354509,
            159357638,
            159355802,
            159358715,
            159358570,
            159355775,
            159357680,
            159365471,
            159355946,
            159360943,
            159358134,
            159356079,
            159356249,
            159358267,
            159364146,
            159357603
        ],
        "D": [
            159372838,
            159371621,
            159377503,
            159382209,
            159381068,
            159378580,
            159379984,
            159378382,
            159374943,
            159383837,
            159371975,
            159370185,
            159380593,
            159384944,
            159388687,
            159386205,
            159385205,
            159378922
        ],
        "A": [
            159357586,
            159352248,
            159352639,
            159352936,
            159353828,
            159354431,
            159354424,
            159352341,
            159352633,
            159353673,
            159352511,
            159354887,
            159354866,
            159352629,
            159352715,
            159358063,
            159357871,
            159353570
        ]
    },
    "name": "D. The Enchanted Forest",
    "statement": "The enchanted forest got its name from the magical mushrooms growing\r\nhere. They may cause illusions and generally should not be approached.\r\nMarisa comes to pick mushrooms in the Enchanted Forest. The Enchanted\r\nforest can be represented by n points on the X-axis numbered 1 through\r\nn. Before Marisa started, her friend, Patchouli, used magic to detect\r\nthe initial number of mushroom on each point, represented by a_1,a_2,\r\nldots,a_n.Marisa can start out at point in the forest on minute 0. Each\r\nminute, the followings happen in order: She moves from point x to y\r\n(|x-y|\r\nle 1, possibly y=x). She collects all mushrooms on point y. A new\r\nmushroom appears on each point in the forest. Note that she collect\r\nmushrooms on minute 0.Now, Marisa wants to know the maximum number of\r\nmushrooms she can pick after k minutes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline int calc(int x)\n{\n  return x * (x - 1) / 2;\n}\n\ninline void solve()\n{\n  int n, k, sum = 0; cin >> n >> k;\n  vector<int> a(n);\n  for (int &x : a)\n  {\n    cin >> x;\n    sum += x;\n  }\n  if (k > n)\n    cout << sum + n * k - n - calc(n) << '\\n';\n  else\n  {\n    int tot = 0;\n    for (int i = 0; i < k; i ++)\n      tot += a[i];\n    int ans = tot;\n    for (int i = k; i < n; i ++)\n    {\n      tot += a[i] - a[i - k];\n      ans = max(tot, ans);\n    } \n    ans += calc(k);\n    cout << ans << '\\n';\n  }\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. The Enchanted Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/103493",
    "editorial": "If k?n\n:\n\nConsider how to maximize the initial mushrooms she collects. Obviously she will not walk into one position more than one times, and the answer is maxk?i?n?j=i?k+1iaj\n.\n\nConsider how to maximize the additional mushrooms she collects. Obviously she will not walk into one position more than one times, and the answer is k(k+1)2\n.\n\nWe can find that maximizing the two parts shares the same strategy. So add up the answers of the two parts.\nIf k>n\n:\n\nConsider how to maximize the initial mushrooms she collects. Obviously she can collect all of them. The answer is ?i=1nai\n.\nConsider how to maximize the additional mushrooms she collects. Let bi\n be her position on minute k?i\n (0?i<n\n). After she collects the mushrooms on position bi\n, a mushroom appears on each point, and she can not collect more than i\n of them. In other words, she leaves at least ?i=0n?1(n?i)=n(n+1)2\n mushrooms in the forest. Let bi=i+1\n, she will leave exactly ?i=0n?1(n?i)=n(n+1)2\n mushrooms in the forest.\nWe can find that maximizing the two parts shares the same strategy. So add up the answers of the two parts.\nThe time complexity is O(n)\n."
}