{
    "link": "https://codeforces.com//contest/1993/problem/E",
    "problemId": "2795985",
    "problem_idx": "E",
    "shortId": "1993E",
    "contest_number": "1993",
    "problem_submissions": {
        "C": [
            274402188,
            274358757,
            274374996,
            274374747,
            274368652,
            274357644,
            274365562,
            274356432,
            274379356,
            274367132,
            274372055,
            274371076,
            274363983,
            274370693,
            274369864,
            274367679,
            274363345,
            274405366,
            274364436
        ],
        "B": [
            274397223,
            274346884,
            274361191,
            274359127,
            274350863,
            274346370,
            274355668,
            274347298,
            274365588,
            274350765,
            274364310,
            274350846,
            274352824,
            274355191,
            274352816,
            274350915,
            274351222,
            274395841,
            274351441
        ],
        "A": [
            274391220,
            274335769,
            274358967,
            274335712,
            274338856,
            274337195,
            274340094,
            274335737,
            274356689,
            274336110,
            274349520,
            274336792,
            274342378,
            274342208,
            274335539,
            274352863,
            274335926,
            274386754,
            274342173
        ],
        "D": [
            274387898,
            274378476,
            274479687,
            274386087,
            274394516,
            274379793,
            274384145,
            274380644,
            274383004,
            274432739,
            274365274,
            274383568,
            274381874,
            274380805,
            274387445,
            274383605,
            274390133,
            275106936,
            274388789,
            274469604,
            274391022,
            274416385,
            274388682
        ],
        "E": [
            274380482,
            274416572,
            274415942,
            274406977,
            274400748,
            275106863,
            274409594,
            281997956,
            274569827
        ],
        "F2": [
            274361444,
            274397454,
            274414076,
            274417256,
            274415219,
            276095739,
            274383447
        ],
        "F1": [
            274349830,
            274385685,
            274402182,
            274415340,
            274413779,
            274417154,
            274400648,
            274391762,
            274403361,
            274395449,
            274405171,
            274404884,
            274415155,
            274426602,
            274426556,
            274426256,
            274400601,
            274403335,
            274384119,
            274407161
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132185",
    "editorial": "SolutionFirst, let\u00e2\u0080\u0099s extend the original matrix by one unit in rows and\r\ncolumns (which means there\u00e2\u0080\u0099s an additional -th row and -th column).\r\nThen, assign (xorsum of the -th row) and (xorsum of the -th column).\r\nThat way, the operation is simplified as follows: The first-type\r\noperation becomes swapping the -th row with the -th row. The second-type\r\noperation becomes swapping the -th column with the -th column. Why?As we\r\nknow, the first-type operation is to select any row , then assign for\r\nall index . But after the matrix extension, the value of is also so it\r\nmeans replacing the -th row with the -th one.But we also need to care\r\nabout the new value of for future operations right? Surprisingly, the\r\nnew value of is nowhere strange, just the old value of element being\r\nreplaced right before! This takes advantage of the fact that if we\r\nperform the operation on the same row twice, the row become unchanged.\r\nAfter swapping two rows, the value of then again become of the new\r\nmatrix.The change of the second-type operation can be proven the same\r\nway.That way, the matrix can be constructed by the permutation of rows,\r\nand the permutation of columns (as we can swap them however we want).\r\nAfter all operations, let\u00e2\u0080\u0099s say the rows ordered from the top to the\r\nbottom are . Similarly, the columns ordered from the left to the right\r\nare .Next thing to consider is: the beauty of the matrix, where: sum of\r\nadjacent cells on the same row. sum of adjacent cells on the same\r\ncolumn. Note that we include neither the -th row nor the -th column when\r\ncalculating and . That being said, after all operations, the -th row and\r\nthe -th column is excluded and do not make any effect in further\r\ncalculations anymore.After that, we calculate two arrays: sum of\r\ndifferences between -th row and -th row. sum of differences between -th\r\ncolumn and -th column. Then, we\u00e2\u0080\u0099ll rewrite the formulas of and as: and .\r\nFrom now on, calculating and is as easy as solving the Travelling\r\nSalesman Problem: finding a good permutation that produces the minimum ,\r\nand a good permutation that produces the minimum . At the end, by\r\nsumming we got the for a fixed excluded row and column for the matrix\r\n.Time complexity: , or just .\r\n",
    "name": "E. Xor-Grid Problem",
    "statement": "Given a matrix a of size n\r\ntimes m, each cell of which contains a non-negative integer. The integer\r\nlying at the intersection of the i-th row and the j-th column of the\r\nmatrix is called a_{i,j}.Let\u2019s define f(i) and g(j) as the XOR of all\r\nintegers in the i-th row and the j-th column, respectively. In one\r\noperation, you can either: Select any row i, then assign a_{i,j} := g(j)\r\nfor each 1\r\nle j\r\nle m; or Select any column j, then assign a_{i,j} := f(i) for each 1\r\nle i\r\nle n. In this example, as we apply an operation on column 2, all\r\nelements in this column are changed: a_{1,2} := f(1) = a_{1,1}\r\noplus a_{1,2}\r\noplus a_{1,3}\r\noplus a_{1,4} = 1\r\noplus 1\r\noplus 1\r\noplus 1 = 0 a_{2,2} := f(2) = a_{2,1}\r\noplus a_{2,2}\r\noplus a_{2,3}\r\noplus a_{2,4} = 2\r\noplus 3\r\noplus 5\r\noplus 7 = 3 a_{3,2} := f(3) = a_{3,1}\r\noplus a_{3,2}\r\noplus a_{3,3}\r\noplus a_{3,4} = 2\r\noplus 0\r\noplus 3\r\noplus 0 = 1 a_{4,2} := f(4) = a_{4,1}\r\noplus a_{4,2}\r\noplus a_{4,3}\r\noplus a_{4,4} = 10\r\noplus 11\r\noplus 12\r\noplus 16 = 29 You can apply the operations any number of times. Then, we\r\ncalculate the\r\ntextit{beauty} of the final matrix by summing the absolute differences\r\nbetween all pairs of its adjacent cells.More formally,\r\ntextit{beauty}(a) =\r\nsum|a_{x,y} - a_{r,c}| for all cells (x, y) and (r, c) if they are\r\nadjacent. Two cells are considered adjacent if they share a side.Find\r\nthe minimum\r\ntextit{beauty} among all obtainable matrices.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}#pragma GCC optimize(3)int dp[1<<15][15],to[15][15];int calc(int n){\trep(i,1<<n)rep(j,n)dp[i][j]=INF;\trep(i,n)dp[1<<i][i]=0;\trep(i,1<<n)rep(j,n)if((i>>j)&1){\t\trep(k,n)if(!((i>>k)&1)){\t\t\tMi(dp[i|(1<<k)][k],dp[i][j]+to[j][k]);\t\t}\t}\tint ans=INF;\trep(i,n)Mi(ans,dp[(1<<n)-1][i]);\tre ans;}int calc(vector<vi>vec){\tint n=sz(vec),m=sz(vec[0]);\trep(i,n)rep(j,n)to[i][j]=0;\trep(i,n)rep(j,n)if(i!=j){\t\trep(k,m)to[i][j]+=abs(vec[i][k]-vec[j][k]);\t}\tint r1=calc(n);\trep(i,m)rep(j,m)to[i][j]=0;\trep(i,m)rep(j,m)if(i!=j){\t\trep(k,n)to[i][j]+=abs(vec[k][i]-vec[k][j]);\t}\tre r1+calc(m);}void run(){\tint n,m;\tcin>>n>>m;\tvector<vi>vec(n,vi(m,0));//\trep(i,n)rep(j,m)vec[i][j]=rand();\trep(i,n)rep(j,m)cin>>vec[i][j];\tint ans=calc(vec);\trep(i,n){\t\tauto vec2=vec;\t\trep(j,m){\t\t\trep(k,n)if(k!=i)vec2[i][j]^=vec2[k][j];\t\t}\t\tMi(ans,calc(vec2));\t}\trep(i,m){\t\tauto vec2=vec;\t\trep(j,n){\t\t\trep(k,m)if(k!=i)vec2[j][i]^=vec2[j][k];\t\t}\t\tMi(ans,calc(vec2));\t}\trep(i,n)rep(j,m){\t\t\t\tauto vec2=vec;\t\trep(k,m){\t\t\trep(l,n)if(l!=i)vec2[i][k]^=vec2[l][k];\t\t}\t\trep(k,n){\t\t\trep(l,m)if(l!=j)vec2[k][j]^=vec2[k][l];\t\t}\t\tMi(ans,calc(vec2));\t}\tcout<<ans<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Xor-Grid Problem.json"
}