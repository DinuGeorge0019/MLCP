{"link": "https://codeforces.com//contest/1443/problem/B", "problemId": "782900", "problem_idx": "B", "shortId": "1443B", "contest_number": "1443", "problem_submissions": {"E": [97479008, 97463874, 97472949, 97473286, 97487113, 97488045, 97486166, 97476252, 97478630, 97480716, 97490445, 97476097, 97488738, 97464168, 97555991], "F": [97460046, 97473751, 97478449, 97476188, 97462886, 97474310, 97471259, 97485398, 97484880, 97484851, 97468431, 97488926, 97474162, 97475321, 97468012, 97469440, 97469949, 97471221, 97476338], "D": [97449970, 97452529, 97448801, 97451458, 97457913, 97450140, 97460851, 97464538, 97461062, 97461575, 97462995, 97457291, 97463830, 97445940, 97440477, 97450609, 97454248, 97454363, 97451402], "C": [97446822, 97447346, 97445981, 97456389, 97449931, 97440784, 97450744, 97451450, 97452292, 97453518, 97445817, 97450898, 97452522, 97482896, 97454120, 97445630, 97448847, 97449032, 97447678], "B": [97441553, 97442295, 97440785, 97445825, 97444717, 97438484, 97446039, 97444727, 97445047, 97449854, 97441444, 97445824, 97447507, 97480278, 97451969, 97439859, 97445039, 97443901, 97442892], "A": [97436052, 97437399, 97436737, 97450327, 97435696, 97435892, 97436303, 97436014, 97436718, 97440450, 97436088, 97443518, 97437941, 97485420, 97446520, 97435902, 97436062, 97436356, 97436417]}, "name": "B. Saving the City", "statement": "Bertown is a city with n buildings in a straight line.The city\u2019s\r\nsecurity service discovered that some buildings were mined. A map was\r\ncompiled, which is a string of length n, where the i-th character is \"\"\r\nif there is a mine under the building number i and \"\"\r\notherwise.Bertown\u2019s best sapper knows how to activate mines so that the\r\nbuildings above them are not damaged. When a mine under the building\r\nnumbered x is activated, it explodes and activates two adjacent mines\r\nunder the buildings numbered x-1 and x+1 (if there were no mines under\r\nthe building, then nothing happens). Thus, it is enough to activate any\r\none mine on a continuous segment of mines to activate all the mines of\r\nthis segment. For manual activation of one mine, the sapper takes a\r\ncoins. He can repeat this operation as many times as you want.Also, a\r\nsapper can place a mine under a building if it wasn\u2019t there. For such an\r\noperation, he takes b coins. He can also repeat this operation as many\r\ntimes as you want.The sapper can carry out operations in any order.You\r\nwant to blow up all the mines in the city to make it safe. Find the\r\nminimum number of coins that the sapper will have to pay so that after\r\nhis actions there are no mines left in the city.\r\n", "solutions": ["#include<bits/stdc++.h>\n\nnamespace mem{ //v2.8.3 => size: 15.62KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)      \\\n      func(float)                   \\\n      func(double)                  \\\n      func(long double)\n  \n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n  \n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n  }\n  \n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori's Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    \n    template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n    template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  }\n  \n  namespace modint{\n    template<const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x<0&&(x+=mod);}\n      \n      inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n      \n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n    };\n    \n    template<const int mod> inline Z<mod> finv(Z<mod> x){\n      if(x.x<2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n      Z<mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&1)s=s*a;\n      return s;\n    }\n    \n    template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n  \n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template<class T> inline T abs(T x){return x<0?-x:x;}\n    template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n    \n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n      \n      inline bool divide(u64 n){return n*i<=t;}\n      inline bool divide(i64 n){return u64(n<0?-n:n)*i<=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i<5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n  \n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)<<64)/b)),b(b){}\n      \n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n  \n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::unordered_set;\n    using std::map;\n    using std::unordered_map;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    \n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n    \n    template<class T> struct vector:std::vector<T>{\n      using std::vector<T>::vector;\n      using iterator=typename std::vector<T>::iterator;\n      using const_iterator=typename std::vector<T>::const_iterator;\n      vector():std::vector<T>(){}\n      explicit vector(const std::vector<T> &plain):std::vector<T>(plain){}\n      \n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n      \n      inline iterator lower_bound(const T &x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &x)const{return std::upper_bound(this->begin(),this->end(),x);}\n      \n      inline void sort(){std::sort(this->begin(),this->end());}\n      template<class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n      \n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n        vector<int> rsp=(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set<T> &src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template<class R,class Function> inline vector<R> _map(Function func) const{\n        vector<R> res(this->size());\n        for(size_t i=0;i<this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n      template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n    };\n    \n    struct string:std::string{\n      using std::string::string;\n      string():std::string(\"\"){}\n      string(const std::string &plain):std::string(plain){}\n      \n      template<class T> inline string join(const vector<T> &vet) const;\n      \n      vector<string> split(const string &dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector<string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n      \n      template<class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template<class... Args> static inline string format(const string &fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n  \n  #define __to_string(T)                   \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n    \n    inline string to_string(const string &s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &s){return string(s);}\n    template<const int mod> inline string to_string(const modint::Z<mod> &v){return std::to_string(v.x);}\n    \n    template<class T> inline string to_string(const vector<T> &ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n    template<class T> inline string to_string(const set<T> &ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+\"}\";\n    }\n    template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it.first)+\":\"+to_string(it.second);\n      }\n      return result+\"}\";\n    }\n    \n    template<class T> inline string string::join(const vector<T> &vet) const{\n      if(!vet.size())return \"\";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i<vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n    \n    inline string operator \"\" _s(const char *s){return string(s);}\n    inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator \"\" _s(long double x){return to_string(x);}\n    inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  }\n  \n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1<<18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n  #endif\n    \n    template<class T> inline void read_digit(T &x){x=getc(); while(!isdigit(x))x=getc();}\n    template<class T> inline void read_alpha(T &x){x=getc(); while(!isalpha(x))x=getc();}\n    template<class T> inline void read_lower(T &x){x=getc(); while(!islower(x))x=getc();}\n    template<class T> inline void read_upper(T &x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n  \n  #define __read(T)                             \\\n      inline void read(T &x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c=='-',c=getc();   \\\n        while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n  #undef __read\n    \n    inline void read(char &x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&&!isspace(c))*s++=c,c=getc();\n      *s++='\\0';\n    }\n    inline void read(container::string &s){\n      char c=getc();\n      s=\"\";\n      while(~c&&!isspace(c))s+=c,c=getc();\n    }\n    template<const int mod> inline void read(const modint::Z<mod> &x){read(x.x);}\n    \n    template<class T=int> inline T read(){T x; read(x); return x;}\n    template<class T,class... Args> inline void read(T &x,Args &... args){\n      read(x),read(args...);\n    }\n  \n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x<0)putc('-'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc('0'+x%10);        \\\n      }\n    __integer_mapper(__print)\n  #undef __print\n    \n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i<len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &s){\n      for(size_t i=0;i<s.length();i++)putc(s[i]);\n    }\n    template<const int mod> inline void print(const modint::Z<mod> &x){print(x.x);}\n    \n    template<class T,class... Args> inline void print(const T &x,Args... args){\n      print(x),print(args...);\n    }\n    template<class... Args> inline void println(Args... args){\n      print(args...),putc('\\n');\n    }\n    \n    template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n  \n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\\n\");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n    template<class T> inline void logs(const T &x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template<class T,class... Args> inline void logs(const T &x,Args... args){\n      logs(x),logs(args...);\n    }\n    template<class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,\"\\n\");\n  #endif\n    }\n  }\n  \n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,\"r\",stdin);}\n    inline void file_output(const char *dir){freopen(dir,\"w\",stdout);}\n    inline void file_input(const std::string &dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &dir){file_output(dir.c_str());}\n\n    template<class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+\".in\"_s);\n      file_output(name+\".out\"_s);\n    }\n\n  #ifdef memset0\n    template<class T> inline void local_file_io(T name){file_io(name);}\n    template<class T> inline void local_file_input(T dir){file_input(dir);}\n    template<class T> inline void local_file_output(T dir){file_output(dir);}\n    template<class T> inline void judge_file_io(T name){}\n    template<class T> inline void judge_file_input(T dir){}\n    template<class T> inline void judge_file_output(T dir){}\n  #else\n    template<class T> inline void local_file_io(T name){}\n    template<class T> inline void local_file_input(T dir){}\n    template<class T> inline void local_file_output(T dir){}\n    template<class T> inline void judge_file_io(T name){file_io(name);}\n    template<class T> inline void judge_file_input(T dir){file_input(dir);}\n    template<class T> inline void judge_file_output(T dir){file_output(dir);}\n  #endif\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\nusing namespace mem;\n\nconst int N=1e5+10;\nint T,n,a,b;\nchar s[N];\nlong long ans;\n\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(T);\n\twhile(T--){\n\t\tread(a,b,s),n=strlen(s);\n\t\tint t=0;\n\t\twhile(t<n&&s[t]=='0')t++;\n\t\tif(t==n){\n\t\t\tans=0;\n\t\t}else{\n\t\t\tans=0;\n\t\t\twhile(s[n-1]=='0')n--;\n\t\t\tfor(int l=t,r=l;l<n;l=r+1,r=l)\n\t\t\t\tif(s[l]=='0'){\n\t\t\t\t\twhile(r+1<n&&s[r+1]=='0')r++;\n\t\t\t\t\t// log<BLUE>(\"%d %d\\n\",l,r);\n\t\t\t\t\tif((long long)b*(r-l+1)<a){\n\t\t\t\t\t\tans+=b*(r-l+1)-a;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twhile(r+1<n&&s[r+1]=='1')r++;\n\t\t\t\t\t// log<RED>(\"%d %d\\n\",l,r);\n\t\t\t\t\tans+=a;\n\t\t\t\t}\n\t\t}\n\t\tprint(ans,'\\n');\n\t}\n}"], "input": "", "output": "", "tags": ["dp", "greedy", "math", "sortings"], "dificulty": "1300", "interactive": false}