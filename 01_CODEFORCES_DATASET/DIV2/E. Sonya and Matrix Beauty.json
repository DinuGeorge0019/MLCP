{
    "link": "https://codeforces.com//contest/1080/problem/E",
    "problemId": "260447",
    "problem_idx": "E",
    "shortId": "1080E",
    "contest_number": "1080",
    "problem_submissions": {
        "F": [
            46161976,
            46162778,
            46160192,
            46159146,
            46160650,
            46161330,
            46177225,
            46181279,
            46177040,
            46159242,
            46165879,
            46244094
        ],
        "E": [
            46159833,
            46158289,
            46156414,
            46159947,
            46162060,
            46170130,
            46156194,
            46160134,
            46157810,
            46160983,
            46162313,
            46162730,
            46268200,
            46162883,
            46161436,
            46165893,
            46162523,
            46157004,
            46162154
        ],
        "D": [
            46156149,
            46155986,
            46154022,
            46155513,
            46158228,
            46156068,
            46156726,
            46159618,
            46156456,
            46155088,
            46157318,
            46173998,
            46159164,
            46155242,
            46156719,
            46155734,
            46161044,
            46159764
        ],
        "C": [
            46152444,
            46149941,
            46152568,
            46150576,
            46153451,
            46151555,
            46151650,
            46150697,
            46153316,
            46152202,
            46153935,
            46150267,
            46152022,
            46151720,
            46151339,
            46154831,
            46152462,
            46152573,
            46153346,
            46152817
        ],
        "B": [
            46149045,
            46145345,
            46149235,
            46146926,
            46149668,
            46147319,
            46152091,
            46147240,
            46146639,
            46147840,
            46147532,
            46146841,
            46147485,
            46146840,
            46146905,
            46150391,
            46147300,
            46147235,
            46147802,
            46148682
        ],
        "A": [
            46146332,
            46144961,
            46147960,
            46145347,
            46146629,
            46145256,
            46151812,
            46146189,
            46145164,
            46147556,
            46144974,
            46145039,
            46145991,
            46145058,
            46145185,
            46149238,
            46145401,
            46145176,
            46145572,
            46145659
        ]
    },
    "name": "E. Sonya and Matrix Beauty",
    "statement": "Sonya had a birthday recently. She was presented with the matrix of size\r\nn\r\ntimes m and consist of lowercase Latin letters. We assume that the rows\r\nare numbered by integers from 1 to n from bottom to top, and the columns\r\nare numbered from 1 to m from left to right. Let\u2019s call a submatrix\r\n(i_1, j_1, i_2, j_2) (1\r\nleq i_1\r\nleq i_2\r\nleq n; 1\r\nleq j_1\r\nleq j_2\r\nleq m) elements a_{ij} of this matrix, such that i_1\r\nleq i\r\nleq i_2 and j_1\r\nleq j\r\nleq j_2. Sonya states that a submatrix is beautiful if we can reorder\r\nthe characters in each (not in column) so that all of this submatrix\r\nform palidroms. Let\u2019s recall that a string is called palindrome if it\r\nreads the same from left to right and from right to left. For example,\r\nstrings abacaba, bcaacb, a are palindromes while strings abca, acbba, ab\r\nare not.Help Sonya to find the number of beautiful submatrixes.\r\nSubmatrixes are different if there is an element that belongs to only\r\none submatrix.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nconst int N = 300;\n\nchar A[N][N];\nint n, m, B[N], C[N];\nint p[N], c[N][26];\n\nbool ck(int i, int j) {\n  if (C[i] != C[j]) return false;\n  if (i == j) return true;\n  for (int k = 0; k < 26; ++k)\n    if (c[i][k] != c[j][k]) return false;\n  return true;\n}\n\nint get() {\n  p[0] = 1;\n  int mx = 1, id = 0, k = 2 * n - 1, ans = C[0] >= 0;\n  for (int i = 1; i < k; ++i) {\n    int i0 = i / 2, i1 = (i + 1) / 2;\n    if (mx > i1) p[i] = std::min(mx - i1, p[2 * id - i]);\n    else p[i] = 0;\n    if (mx <= i1 || mx - i1 <= p[2 * id - i])\n      while (i0 - p[i] >= 0 && i1 + p[i] < n && ck(i0 - p[i], i1 + p[i])) ++p[i];\n    if (i1 + p[i] > mx) mx = i1 + p[i], id = i;\n    if (C[i1] >= 0) ans += p[i];\n  }\n  return ans;\n}\n\nint main(){\n  scanf(\"%d%d\", &n, &m);\n  LL ans = 0;\n  for (int i = 0; i < n; ++i) scanf(\"%s\", A[i]);\n  for (int l = 0; l < m; ++l) {\n    memset(B, 0, sizeof B);\n    memset(c, 0, sizeof c);\n    for (int r = l; r < m; ++r) {\n      for (int i = 0; i < n; ++i) {\n        B[i] ^= 1 << (A[i][r] - 'a');\n        C[i] = B[i] & (B[i] - 1) ? -i-1 : B[i];\n        ++c[i][A[i][r] - 'a'];\n      }\n      int k = get();\n      //printf(\"%d %d %d\\n\", l, r, k);\n      ans += k;\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sonya and Matrix Beauty.json",
    "editorial_link": "https://codeforces.com//blog/entry/63436",
    "editorial": "Suppose we have a submatrix and we want to check whether it is\r\nbeautiful. First, each line must have a maximum of one character that\r\noccurs an odd number of times. Why is this enough to ensure that each\r\nline can be made a palindrome by reordering the characters in it? If\r\nthere is exactly one character that occurs an odd number of times, then\r\nthe string has an odd length and we can swap it with characters that\r\nstand in the central position of the string. All remaining characters\r\ncan be paired and placed in opposite positions relative to the center of\r\nthe line. Obviously, this condition is necessary. Also, in order for the\r\nsubmatrix to be beautiful, the following property must be satisfied: the\r\nopposing lines of the submatrix, relative to the central lines, must\r\nhave the same content of characters, possibly in a different order. In\r\nother words, if the number of the first line of the submatrix is , and\r\nthe number of the last line of the submatrix is , then for any integer\r\nand for any character from \u00e2\u0080\u0099a\u00e2\u0080\u0099 to \u00e2\u0080\u0099z\u00e2\u0080\u0099 should be true, that the number of\r\ntimes that the character occurs in the line with the number coincides\r\nwith the number of times the character occurs in the line with the\r\nnumber . The necessity of this condition is based on the fact that after\r\nreordering characters independently in each row, our columns should turn\r\nout to be palindromes. To better understand this, see the explanation of\r\nthe third example from the problem statement.Let us proceed to the\r\nsolution of the problem: find the number of submatrices for which both\r\nof the above conditions are fulfilled. Fix the number of the first\r\ncolumn of our submatrix. We will move the right column from the left one\r\nto the last one. So, what to do when we have two columns fixed. Let\u00e2\u0080\u0099s\r\ndefine which strings can be palindromes, and which ones can\u00e2\u0080\u0099t. To do\r\nthis, we can support the auxiliary array how many times the character\r\nappears in the row with the number . If the submatrix is beautiful, then\r\neach of its rows can be a palindrome, which means we can break our lines\r\ninto groups of maximum size from consecutive lines that can be\r\npalindromes, and solve the puzzle for each group independently.Now we\r\nhave the left and right columns of our submatrix, as well as a segment\r\nof consecutive lines, all of which can be palindromes. Then if we select\r\nany two rows and form a submatrix from these columns, rows and all rows\r\nbetween them, each row can be a palindrome, which means the first rule\r\nwill always be fulfilled. It remains only to ensure that the second rule\r\nwill be fulfilled.Let\u00e2\u0080\u0099s break all strings into equivalence classes. In\r\nother words, we will give each line some number that will characterize\r\nthe content of this line the number of times how many letters each occur\r\nin this line. If two lines coincide in content, then they will have the\r\nsame equivalence class, otherwise their classes will be different. For\r\nexample, if we have a set of lines , then their classes will be ,\r\nrespectively. How can you find these classes? Previously, we created an\r\narray of , which stores the number of occurrences of each character in\r\neach row. We can encode this array with a single number hash. What to do\r\nwhen we find equivalence class for each line? Let\u00e2\u0080\u0099s look at some\r\nsub-line from a row of lines. More precisely, we will be interested only\r\nin the sequence of their equivalence classes. If our submatrix (formed\r\nby all elements on this segment and between the fixed columns) is good,\r\nthen the equivalence classes of opposite rows are equal. So the sequence\r\nof classes on this segment will be a palindrome. So, we reduced the task\r\nto finding the number of palindromes on some sequence. This can be done\r\nusing the Manacher\u00e2\u0080\u0099s algorithm for for each fixed pair of columns, or\r\nfor using binary search and one more auxiliary array of hashes.More\r\ninformation about the mentioned topics can be found at the links listed\r\nbelow: Manacher\u00e2\u0080\u0099s algorithm:\r\nhttps://cp-algorithms.com/string/manacher.html; Hashes:\r\nhttps://cp-algorithms.com/string/string-hashing.html; Equivalence\r\nclasses: https://en.wikipedia.org/wiki/Equivalence_class;\r\n"
}