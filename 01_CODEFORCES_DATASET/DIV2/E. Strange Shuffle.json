{
    "link": "https://codeforces.com//contest/1471/problem/E",
    "problemId": "855312",
    "problem_idx": "E",
    "shortId": "1471E",
    "contest_number": "1471",
    "problem_submissions": {
        "E": [
            103450052,
            103527230,
            103525401,
            103598525
        ],
        "F": [
            103434846,
            103427866,
            103439415,
            103444744,
            103449013,
            103443306,
            103451232,
            103449545,
            103450844,
            103457122,
            103444374,
            103429431,
            103453099,
            103450549,
            103452495,
            103451463,
            103455883,
            103458926,
            103459110,
            103458706
        ],
        "D": [
            103430457,
            103433587,
            103415562,
            103429984,
            103422346,
            103434860,
            103464447,
            103432755,
            103438270,
            103433203,
            103429688,
            103431896,
            103454609,
            103429555,
            103432993,
            103431363,
            103439051,
            103433971,
            103434798,
            103443976,
            103435625
        ],
        "C": [
            103407997,
            103401931,
            103402977,
            103409572,
            103406225,
            103408555,
            103406435,
            103414503,
            103418347,
            103405513,
            103405296,
            103416304,
            103408620,
            103413240,
            103409443,
            103419306,
            103414842,
            103414451,
            103407384,
            103412728
        ],
        "B": [
            103396816,
            103402555,
            103399513,
            103402026,
            103401651,
            103404250,
            103396796,
            103402859,
            103407240,
            103400401,
            103398000,
            103404884,
            103399937,
            103406757,
            103403051,
            103411496,
            103400880,
            103401862,
            103399435,
            103395040
        ],
        "A": [
            103391504,
            103392070,
            103391475,
            103392431,
            103397645,
            103392332,
            103392672,
            103392165,
            103392211,
            103391494,
            103393909,
            103392635,
            103393542,
            103391831,
            103396953,
            103391758,
            103391661,
            103393211,
            103391536
        ]
    },
    "name": "E. Strange Shuffle",
    "statement": "n people sitting in a circle are trying to shuffle a deck of cards. The\r\nplayers are numbered from 1 to n, so that players i and i+1 are\r\nneighbours (as well as players 1 and n). Each of them has exactly k\r\ncards, where k is . The left neighbour of a player i is player i - 1,\r\nand their right neighbour is player i + 1 (except for players 1 and n,\r\nwho are respective neighbours of each other).Each turn the following\r\nhappens: if a player has x cards, they give\r\nlfloor x / 2\r\nrfloor to their neighbour on the left and\r\nlceil x / 2\r\nrceil cards to their neighbour on the right. This happens for all\r\nplayers simultaneously.However, one player p is the impostor and they\r\njust give all their cards to their neighbour on the right. You know the\r\nnumber of players n and the number of cards k each player has initially,\r\nbut p is unknown to you. Your task is to determine the value of p, by\r\nasking questions like \"how many cards does player q have?\" for an index\r\nq of your choice. After each question all players will make exactly one\r\nmove and give their cards to their neighbours. You need to find the\r\nimpostor by asking no more than 1000 questions.\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\n\nconst int N = 100005;\n\nint ask(int x) {\n  printf(\"? %d\\n\", x), fflush(stdout);\n  int xx; scanf(\"%d\", &xx);\n  return xx;\n}\nint n, k; \nint main() {\n  scanf(\"%d%d\", &n, &k);\n  ask(1);\n  int cur = 1;\n  for (int i = 1; i <= n; i++) {\n    cur = (cur + i - 1) % n + 1;\n    int t = ask(cur);\n    if (t != k) {\n      if (t > k) {\n        while (true) {\n          cur = (cur == 1 ? n : cur - 1);\n          if (ask(cur) == k) {\n            printf(\"! %d\\n\", cur);\n            fflush(stdout);\n            return 0;\n          }\n        }\n      } else {\n        while (true) {\n          cur = (cur == n ? 1 : cur + 1);\n          if (ask(cur) == k) {\n            printf(\"! %d\\n\", cur);\n            fflush(stdout);\n            return 0;\n          }\n        }\n      }\n    } \n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Strange Shuffle.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "Short version: note that, during the first n2\n iterations the number of people with more than k\n cards, increases. Let's find at least one such person. To do this, let's wait for n???\n iterations. After this there is always a continuous segment of length n???\n with elements >k\n. To find it, we can split the array into blocks of size n???\n, ask one element from each block, and find the desired integer >k\n. Then we can use binary search to find the position p\n. In total we need 2n???+logn\n queries.\n\nMore detailed version: let's use induction to prove that players that are located from the same distance from the player p\n always have 2k\n cards in total. It is obviously true initially. After one operation, when the array a\n is transformed to the array b\n, and let's consider a pair of elements located on the same distance from position p\n: i\n and j\n. Note that, bi+bj=(?ai?12?+?ai+12?)+(?aj?12?+?aj+12?)=(?ai?12?+?aj+12?)+(?ai+12?+?aj?12?)=k+k=2k\n (excluding the neighbours of p\n). It proves that the player p\n will always have k\n cards.\n\nNow let's prove that the number of cards that players p+1,p+2,\u0085,n,1,\u0085p?1\n have is not increasing. Again, if we consider a single step: bi+1=?ai2?+?ai+22???ai?12?+?ai+12?=bi\n.\n\nDuring the first n2\n iterations, the number of elements that are greater than k\n, is increasing. Before i\n-th iteration we have ap+i?1>k,ap+i=k\n. After i\n-th iteration ap+i=?ap+i?12?+k2>k\n, because k\n is even.\n\nThe rest of the solution is described in the \u00abshort\u00bb version of the solution above."
}