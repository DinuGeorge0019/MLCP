{
    "link": "https://codeforces.com//contest/1838/problem/B",
    "problemId": "1951235",
    "problem_idx": "B",
    "shortId": "1838B",
    "contest_number": "1838",
    "problem_submissions": {
        "E": [
            208486336,
            208494772,
            208495329,
            208495228,
            208504838,
            208502550,
            208502081,
            208506624,
            208501784,
            208497568,
            208484754,
            208502274,
            208506982,
            208508861,
            208509587
        ],
        "D": [
            208474393,
            208472020,
            208475917,
            208474806,
            208470276,
            208484610,
            208476486,
            208481947,
            208484438,
            208492182,
            208509562,
            208485512,
            208497675,
            208502977,
            208488728,
            208469550,
            208477928,
            208461571
        ],
        "C": [
            208459822,
            208460902,
            208460156,
            208459254,
            208459677,
            208455873,
            208462517,
            208452784,
            208459736,
            208463220,
            208467092,
            208460581,
            208458526,
            208468810,
            208477568,
            208454310,
            208448256,
            208470265
        ],
        "B": [
            208453654,
            208447995,
            208452616,
            208450470,
            208449926,
            208446381,
            208454035,
            208446799,
            208444336,
            208450882,
            208456322,
            208448611,
            208449662,
            208456059,
            208462080,
            208447155,
            208442110,
            208452374
        ],
        "A": [
            208438767,
            208438058,
            208439478,
            208435532,
            208440850,
            208437783,
            208437196,
            208435664,
            208435519,
            208435964,
            208439335,
            208440976,
            208441596,
            208440802,
            208440409,
            208436085,
            208439210,
            208439722
        ],
        "F": [
            209584777,
            208548659
        ]
    },
    "name": "B. Minimize Permutation Subarrays",
    "statement": "You are given a permutation p of size n. You want to minimize the number\r\nof subarrays of p that are permutations. In order to do so, you must\r\nperform the following operation once: Select integers i, j, where 1\r\nle i, j\r\nle n, then Swap p_i and p_j. For example, if p = [5, 1, 4, 2, 3] and we\r\nchoose i = 2, j = 3, the resulting array will be [5, 4, 1, 2, 3]. If\r\ninstead we choose i = j = 5, the resulting array will be [5, 1, 4, 2,\r\n3].Which choice of i and j will minimize the number of subarrays that\r\nare permutations?A permutation of length n is an array consisting of n\r\ndistinct integers from 1 to n in arbitrary order. For example,\r\n[2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2\r\nappears twice in the array), and [1,3,4] is also not a permutation (n=3\r\nbut there is 4 in the array).An array a is a subarray of an array b if a\r\ncan be obtained from b by the deletion of several (possibly, zero or\r\nall) elements from the beginning and several (possibly, zero or all)\r\nelements from the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t; cin>>t;\n    for (int ti = 0; ti < t; ++ti) {\n        int n; cin>>n;\n        int _1,_2,_n;\n        for (int i = 1; i <= n; ++i) {\n            int p; cin>>p;\n            if (p == 1) {\n                _1 = i;\n            } else if (p == 2) {\n                _2 = i;\n            } else if (p == n) {\n                _n = i;\n            }\n        }\n        if (_1 > _2) swap(_1,_2);\n        if (_1 < _n && _n < _2) {\n            cout << \"1 1\\n\";\n        } else if (_n < _1) {\n            cout << _1 << \" \" << _n << \"\\n\";\n        } else {\n            cout << _2 << \" \" << _n << \"\\n\";\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Minimize Permutation Subarrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/116995",
    "editorial": "Let be the position of the element in , and consider what happens if is\r\nin between and . Notice that any subarray of size greater than that is a\r\npermutation must contain and . So it must also contain every index in\r\nbetween, including . Therefore, is an element of the permutation\r\nsubarray, so it must be of size at least , and therefore must be the\r\nwhole array. Therefore, if is in between and , the only subarrays that\r\nare permutations are and . These two subarrays will always be\r\npermutations, so this is minimal.To achieve this, we have 3 cases: If\r\nlies in between and , swap and . If , swap with the smaller of , . If ,\r\nswap with the larger of , . In all three of these cases, after the swap,\r\nwill lie in between and , minimizing the number of permutation\r\nsubarrays.Complexity:\r\n",
    "hint": []
}