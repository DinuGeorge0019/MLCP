{
    "link": "https://codeforces.com//contest/1789/problem/F",
    "problemId": "1798642",
    "problem_idx": "F",
    "shortId": "1789F",
    "contest_number": "1789",
    "problem_submissions": {
        "F": [
            194969357,
            195749340,
            195084999,
            195084860,
            195102578,
            194979229,
            194979047,
            194978962,
            194975838,
            194975550,
            194975302,
            194975124,
            194974900,
            194974650,
            194974382
        ],
        "D": [
            194964382,
            194946537,
            194952763,
            194935429,
            194953178,
            194957319,
            194960327,
            194955667,
            194955471,
            194960858,
            194960296,
            194949046,
            194949101,
            194950239,
            194953216,
            194952742,
            194952699,
            194953612
        ],
        "E": [
            194946702,
            194955457,
            194962685,
            194950894,
            194964730,
            194965836,
            229633905,
            194969144,
            194969007,
            194970553,
            194969010,
            194970681,
            194953500,
            194973828,
            198576217,
            194953882
        ],
        "C": [
            194930840,
            194935056,
            194937930,
            194962744,
            194937423,
            194944977,
            194941284,
            194940844,
            194947791,
            194945071,
            194938899,
            194933727,
            194937235,
            194936393,
            194947382,
            194937385,
            194938714,
            194934789,
            194942194,
            194939314
        ],
        "B": [
            194927201,
            194928996,
            194933855,
            194950809,
            194928726,
            194933032,
            194930991,
            194927953,
            194937472,
            194934025,
            194928695,
            194928070,
            194927782,
            194930745,
            194932397,
            194929156,
            194930083,
            194929116,
            194929527,
            194930695
        ],
        "A": [
            194926083,
            194926207,
            194930860,
            194952002,
            194926224,
            194926968,
            194926650,
            194926242,
            194934078,
            194927544,
            194926614,
            194926667,
            194926050,
            194926065,
            194927300,
            194926584,
            194927455,
            194927037,
            194926659,
            194927083
        ]
    },
    "name": "F. Serval and Brain Power",
    "statement": "Serval loves Brain Power and his brain power problem.Serval defines that\r\na string T is iff T can be obtained by concatenating some string T’\r\nmultiple times. Formally speaking, T is powerful iff there exist a\r\nstring T’ and an integer k\r\ngeq 2 such that T=\r\nunderbrace{T’+T’+\r\ndots+T’}_{k\r\ntext{ times}}For example, is powerful because it can be obtained by\r\nconcatenating three times, but is not powerful.Serval has a string S\r\nconsists of lowercase English letters. He is curious about the longest\r\npowerful subsequence of S, and he only needs you to find out the length\r\nof it. If all the non-empty subsequences of S is not powerful, the\r\nanswer is considered to be 0.A string a is a subsequence of a string b\r\nif a can be obtained from b by the deletion of several (possibly, zero\r\nor all) characters.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\nstring s;\nint n;\nstring cur;\nint ans = 0;\nconst int K = 16;\n\nbool check() {\n    if (cur.empty()) return true;\n    int j = 0;\n    int sz = (int) cur.size();\n    int cnt = 0;\n    for (auto &x: s) {\n        if (x == cur[j]) {\n            j++;\n            if (j == sz) {\n                cnt++;\n                j = 0;\n            }\n        }\n    }\n    if (cnt >= 2) {\n        ans = max(ans, cnt * sz);\n        return true;\n    }\n    return false;\n}\n\nvoid chkmx(int &x, int y) { x = max(x, y); }\n\nvoid relax(string x, string y, string z) {\n    int nx = x.size();\n    int ny = y.size();\n    int nz = z.size();\n    vector<vector<vector<int>>> dp(nx + 1, vector<vector<int>>(ny + 1, vector<int>(nz + 1)));\n    int res = 0;\n    for (int i = 0; i <= nx; ++i) {\n        for (int j = 0; j <= ny; ++j) {\n            for (int e = 0; e <= nz; ++e) {\n                if (i + 1 <= nx) chkmx(dp[i + 1][j][e], dp[i][j][e]);\n                if (j + 1 <= ny) chkmx(dp[i][j + 1][e], dp[i][j][e]);\n                if (e + 1 <= nz) chkmx(dp[i][j][e + 1], dp[i][j][e]);\n                if (i < nx && j < ny && e < nz && x[i] == y[j] && x[i] == z[e])\n                    chkmx(dp[i + 1][j + 1][e + 1], dp[i][j][e] + 1);\n                chkmx(res, dp[i][j][e]);\n            }\n        }\n    }\n    ans = max(ans, res * 3);\n}\n\n\nvoid relax(string x, string y) {\n    int nx = x.size();\n    int ny = y.size();\n    vector<vector<int>> dp(nx + 1, vector<int>(ny + 1));\n    int res = 0;\n    for (int i = 0; i <= nx; ++i) {\n        for (int j = 0; j <= ny; ++j) {\n            if (i + 1 <= nx) chkmx(dp[i + 1][j], dp[i][j]);\n            if (j + 1 <= ny) chkmx(dp[i][j + 1], dp[i][j]);\n            if (i < nx && j < ny && x[i] == y[j])\n                chkmx(dp[i + 1][j + 1], dp[i][j] + 1);\n            chkmx(res, dp[i][j]);\n        }\n    }\n    ans = max(ans, res * 2);\n}\n\nvoid solve() {\n    cin >> s;\n    n = (int) s.size();\n    for (int i = 0; i < n; ++i) {\n        for (int mask = 1; mask < (1 << K); mask += 2) {\n            for (int j = 0; j < K; ++j) {\n                if (mask & (1 << j)) cur.push_back(s[i + j]);\n            }\n            check();\n            cur.clear();\n        }\n    }\n    // 3\n    for (int l = K + 1; l < n; ++l) {\n        for (int r = l + K + 1; r + K < n; ++r) {\n            relax(s.substr(0, l), s.substr(l, r - l), s.substr(r, n));\n        }\n        relax(s.substr(0, l), s.substr(l, n));\n    }\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Serval and Brain Power.json",
    "editorial_link": "https://codeforces.com//blog/entry/113246",
    "editorial": "Assume that the longest powerful\nsubsequence of the given string is , which can be obtained by\nconcatenating copies of string . Noticing that , we have the observation\nthat , so it is impossible that both and is large.When , we only need to\nconsider the case and the case. The case is covered by case, since .For\nthe case, we split into two parts , then calculate the maximal length of\nby dynamic programming over all the possible splits. This case can be\nsolved in time, where is a small constant.It is similar to solve the\ncase. We split into three parts , then calculate the maximal length of\nover all the possible splits. This case can be solved in time, where is\na small constant. We will estimate later.When , we have . It can be\nshown that, if we split into parts, will be the subsequence of at least\none of them. We can split into equal lengths, then enumerate all the\nsubsequences of these substrings as the possible . For a possible , we\ncan find out corresponding by matching and greedily. This case can be\nsolved in .Now let us roughly estimate how small could be. The time that\ndynamic programming consumed for certain is . Since , we have . Recall\nthat there are possible splits, then holds.Time complexity: .\n",
    "hint": []
}