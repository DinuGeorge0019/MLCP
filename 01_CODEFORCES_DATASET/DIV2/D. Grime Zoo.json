{"link": "https://codeforces.com//contest/1465/problem/D", "problemId": "839219", "problem_idx": "D", "shortId": "1465D", "contest_number": "1465", "problem_submissions": {"E": [101889759, 101886960, 101897712, 101902339, 101902023, 101893375, 101904494, 101923462, 101931929], "D": [101878329, 101896950, 101887109, 101890727, 101895696, 101885523, 101894957, 101880576, 101882575, 101881809, 101885768, 101882968, 101886357, 101886080, 101886656, 101892161, 101888774, 101888604, 101893836], "C": [101871373, 101877108, 101882389, 101882084, 101878736, 101900776, 101880965, 101870960, 101875344, 101876806, 101873569, 101877324, 101877029, 101878345, 101879371, 101871187, 101877833, 101880185, 101881011], "A": [101864398, 101862566, 101860401, 101860285, 101860331, 101864535, 101864517, 101859464, 101860720, 101859587, 101863596, 101859867, 101864237, 101862483, 101863218, 101860139, 101863738, 101864046, 101859532], "B": [101860078, 101873103, 101866758, 101865847, 101869239, 101868793, 101871794, 101862334, 101865531, 101862067, 101867494, 101865697, 101867821, 101870548, 101867113, 101866220, 101870657, 101871916, 101866936], "F": [101998980]}, "name": "D. Grime Zoo", "statement": "Currently, XXOC\u2019s rap is a string consisting of zeroes, ones, and\r\nquestion marks. Unfortunately, haters gonna hate. They will write x\r\nangry comments for every occurrence of and y angry comments for every\r\noccurrence of . You should replace all the question marks with or in\r\nsuch a way that the number of angry comments would be as small as\r\npossible.String b is a subsequence of string a, if it can be obtained by\r\nremoving some characters from a. Two occurrences of a subsequence are\r\nconsidered distinct if sets of positions of remaining characters are\r\ndistinct.\r\n", "solutions": ["#include<bits/stdc++.h>\nnamespace mem{ //v2.10.1 => size: 15.80KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)        \\\n      func(float)                     \\\n      func(double)                    \\\n      func(long double)\n  \n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n  \n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::find;\n    using std::copy;\n    using std::fill;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n    using std::next_permutation;\n  }\n  \n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori's Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    \n    template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n    template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  }\n  \n  namespace modint{\n    template<const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x<0&&(x+=mod);}\n      \n      inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n      \n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n    };\n    \n    template<const int mod> inline Z<mod> finv(Z<mod> x){\n      if(x.x<2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n      Z<mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&1)s=s*a;\n      return s;\n    }\n    \n    template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n  \n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template<class T> inline T abs(T x){return x<0?-x:x;}\n    template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n    \n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n      \n      inline bool divide(u64 n){return n*i<=t;}\n      inline bool divide(i64 n){return u64(n<0?-n:n)*i<=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i<5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n  \n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)<<64)/b)),b(b){}\n      \n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n  \n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::multiset;\n    using std::unordered_set;\n    using std::unordered_multiset;\n    using std::map;\n    using std::multimap;\n    using std::unordered_map;\n    using std::unordered_multimap;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    using std::deque;\n    using std::bitset;\n    \n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n    \n    template<class T> struct vector:std::vector<T>{\n      using std::vector<T>::vector;\n      using iterator=typename std::vector<T>::iterator;\n      using const_iterator=typename std::vector<T>::const_iterator;\n      vector():std::vector<T>(){}\n      explicit vector(const std::vector<T> &plain):std::vector<T>(plain){}\n      \n      inline void reverse(){std::reverse(this->begin(),this->end());}\n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n      \n      inline iterator find(const T &x){return std::find(this->begin(),this->end(),x);}\n      inline iterator lower_bound(const T &x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator find(const T &x)const{return std::find(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &x)const{return std::upper_bound(this->begin(),this->end(),x);}\n\n      inline void sort(){std::sort(this->begin(),this->end());}\n      template<class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n      \n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n        vector rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set<T> &src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template<class R,class Function> inline vector<R> _map(Function func) const{\n        vector<R> res(this->size());\n        for(size_t i=0;i<this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n      template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n    };\n    \n    struct string:std::string{\n      using std::string::string;\n      string():std::string(\"\"){}\n      string(const std::string &plain):std::string(plain){}\n      \n      template<class T> inline string join(const vector<T> &vet) const;\n            \n      inline string slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return string(this->begin()+l,this->begin()+r);\n        string rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n      \n      vector<string> split(const string &dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector<string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n      \n      template<class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template<class... Args> static inline string format(const string &fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n  \n  #define __to_string(T)                   \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n    \n    inline string to_string(const string &s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &s){return string(s);}\n    template<const int mod> inline string to_string(const modint::Z<mod> &v){return std::to_string(v.x);}\n    \n    template<class T> inline string to_string(const vector<T> &ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n    template<class T> inline string to_string(const set<T> &ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+\"}\";\n    }\n    template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it.first)+\":\"+to_string(it.second);\n      }\n      return result+\"}\";\n    }\n    \n    template<class T> inline string string::join(const vector<T> &vet) const{\n      if(!vet.size())return \"\";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i<vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n    \n    inline string operator \"\" _s(const char *s){return string(s);}\n    inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator \"\" _s(long double x){return to_string(x);}\n    inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  }\n  \n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1<<18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n    inline void flush(){fastio::flush(),fflush(stdout);}\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n    inline void flush(){fflush(stdout);}\n  #endif\n    \n    template<class T> inline void read_digit(T &x){x=getc(); while(!isdigit(x))x=getc();}\n    template<class T> inline void read_alpha(T &x){x=getc(); while(!isalpha(x))x=getc();}\n    template<class T> inline void read_lower(T &x){x=getc(); while(!islower(x))x=getc();}\n    template<class T> inline void read_upper(T &x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n  \n  #define __read(T)                             \\\n      inline void read(T &x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c=='-',c=getc();   \\\n        while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n    #ifdef MEM_INT128\n      __read(__int128_t)\n      __read(__uint128_t)\n    #endif\n  #undef __read\n    \n    inline void read(char &x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&&!isspace(c))*s++=c,c=getc();\n      *s++='\\0';\n    }\n    inline void read(container::string &s){\n      char c=getc();\n      s=\"\";\n      while(~c&&!isspace(c))s+=c,c=getc();\n    }\n    template<const int mod> inline void read(const modint::Z<mod> &x){read(x.x);}\n    \n    template<class T=int> inline T read(){T x; read(x); return x;}\n    template<class T,class... Args> inline void read(T &x,Args &... args){\n      read(x),read(args...);\n    }\n  \n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x<0)putc('-'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc('0'+x%10);        \\\n      }\n    __integer_mapper(__print)\n    #ifdef MEM_INT128\n      __print(__int128_t)\n      __print(__uint128_t)\n    #endif\n  #undef __print\n    \n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i<len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &s){\n      for(size_t i=0;i<s.length();i++)putc(s[i]);\n    }\n    template<const int mod> inline void print(const modint::Z<mod> &x){print(x.x);}\n    \n    template<class T,class... Args> inline void print(const T &x,Args... args){\n      print(x),print(args...);\n    }\n    template<class... Args> inline void println(Args... args){\n      print(args...),putc('\\n');\n    }\n    \n    template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n  \n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\\n\");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n    template<class T> inline void logs(const T &x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template<class T,class... Args> inline void logs(const T &x,Args... args){\n      logs(x),logs(args...);\n    }\n    template<class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,\"\\n\");\n  #endif\n    }\n  }\n  \n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,\"r\",stdin);}\n    inline void file_output(const char *dir){freopen(dir,\"w\",stdout);}\n    inline void file_input(const std::string &dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &dir){file_output(dir.c_str());}\n\n    template<class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+\".in\"_s);\n      file_output(name+\".out\"_s);\n    }\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\nusing namespace mem;\nconst int N=1e5+10;\nint n,x,y,a[N],pre[N][3],suf[N][3];\nchar s[N];\nlong long cur,ans=LLONG_MAX;\nvoid solve(){\n  cur=0;\n  for(int i=1;i<=n;i++){\n    pre[i][0]=pre[i-1][0];\n    pre[i][1]=pre[i-1][1];\n    pre[i][2]=pre[i-1][2];\n    pre[i][a[i]]++;\n  }\n  for(int i=n;i>=1;i--){\n    suf[i][0]=suf[i+1][0];\n    suf[i][1]=suf[i+1][1];\n    suf[i][2]=suf[i+1][2];\n    suf[i][a[i]]++;\n  }\n  for(int i=1;i<=n;i++)\n    if(a[i]==1||a[i]==2){\n      cur+=(long long)x*pre[i-1][0];\n    }else{\n      cur+=(long long)y*(pre[i-1][1]+pre[i-1][2]);\n    }\n  // log(\"! %lld\\n\",cur);\n  ans=min(ans,cur);\n  for(int i=1;i<=n;i++)\n    if(a[i]==2){\n      cur-=(long long)x*pre[i-1][0];\n      cur-=(long long)y*suf[i+1][0];\n      cur+=(long long)y*pre[i-1][1];\n      cur+=(long long)x*suf[i+1][1];\n      cur-=(long long)x*pre[i-1][2];\n      cur+=(long long)x*suf[i+1][2];\n      ans=min(ans,cur);\n    }\n}\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read((char*)s+1);\n  read(x,y);\n  n=strlen(s+1);\n  for(int i=1;i<=n;i++){\n    a[i]=s[i]=='0'?0:(s[i]=='1'?1:2);\n  }\n  solve();\n  swap(x,y);\n  for(int i=1;i<=n;i++)\n    if(a[i]<2){\n      a[i]^=1;\n    }\n  solve();\n  println(ans);\n}"], "input": "", "output": "", "tags": ["dp", "greedy", "implementation", "math", "ternary search"], "dificulty": "2100", "interactive": false}