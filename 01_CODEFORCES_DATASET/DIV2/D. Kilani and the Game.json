{
    "link": "https://codeforces.com//contest/1105/problem/D",
    "problemId": "284897",
    "problem_idx": "D",
    "shortId": "1105D",
    "contest_number": "1105",
    "problem_submissions": {
        "E": [
            48620322,
            48620801,
            48627331,
            48625937,
            48626240,
            48621486,
            48622249,
            48628056,
            48633102,
            48628188,
            48631669,
            48628460,
            48634987,
            48628398,
            48633326,
            48655121,
            48633590,
            48617721,
            48626954,
            48628874,
            48630576
        ],
        "D": [
            48616818,
            48615146,
            48617750,
            48616118,
            48617724,
            48622970,
            48619041,
            48619086,
            48622750,
            48620456,
            48624388,
            48621628,
            48623556,
            48621076,
            48620990,
            48622287,
            48622764,
            48624162,
            48623494,
            48618308
        ],
        "C": [
            48610690,
            48610244,
            48611290,
            48612291,
            48612786,
            48613707,
            48615573,
            48612747,
            48614232,
            48613816,
            48615442,
            48612205,
            48616806,
            48617252,
            48615059,
            48613686,
            48623666,
            48614080,
            48615466,
            48612894
        ],
        "B": [
            48609141,
            48608646,
            48609160,
            48610767,
            48610712,
            48609901,
            48611122,
            48609473,
            48610473,
            48609258,
            48611792,
            48609717,
            48612036,
            48610022,
            48609557,
            48611005,
            48624281,
            48610791,
            48613028,
            48610193
        ],
        "A": [
            48608469,
            48608122,
            48608173,
            48608145,
            48608339,
            48608495,
            48609263,
            48608223,
            48608574,
            48608192,
            48608757,
            48608186,
            48608633,
            48608202,
            48608401,
            48608383,
            48625139,
            48608354,
            48609689,
            48608198
        ]
    },
    "name": "D. Kilani and the Game",
    "statement": "Kilani is playing a game with his friends. This game can be represented\r\nas a grid of size n\r\ntimes m, where each cell is either empty or blocked, and every player\r\nhas one or more castles in some cells (there are no two castles in one\r\ncell).The game is played in rounds. In each round players expand turn by\r\nturn: firstly, the first player expands, then the second player expands\r\nand so on. The expansion happens as follows: for each castle the player\r\nowns now, he tries to expand into the empty cells nearby. The player i\r\ncan expand from a cell with his castle to the empty cell if it’s\r\npossible to reach it in at most s_i (where s_i is player’s expansion\r\nspeed) moves to the left, up, right or down without going through\r\nblocked cells or cells occupied by some other player’s castle. The\r\nplayer examines the set of cells he can expand to and builds a castle in\r\neach of them at once. The turned is passed to the next player after\r\nthat. The game ends when no player can make a move. You are given the\r\ngame field and speed of the expansion for each player. Kilani wants to\r\nknow for each player how many cells he will control (have a castle\r\ntheir) after the game ends.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\nvector<pair<int,int> > v[10],t;\nint n,m,p,s[10],a[1011][1101],ans[10],tn,d[4][2];\nchar str[1101];\n\nbool bfs(int x)\n{\n\tt.clear(),tn=v[x].size();\n\tfor (int i=0; i<tn; i++) t.pb(v[x][i]);\n\tv[x].clear();\n\tfor (int i=0; i<tn; i++)\n\t{\n\t\tint X=t[i].first,Y=t[i].second;\n\t\tfor (int j=0; j<4; j++)\n\t\t\tif (a[X+d[j][0]][Y+d[j][1]]==0) \n\t\t\t\ta[X+d[j][0]][Y+d[j][1]]=x,v[x].pb(mp(X+d[j][0],Y+d[j][1]));\n\t}\n\tif (!v[x].size()) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor (int i=0; i<=1001; i++)\n\t\tfor (int j=0; j<=1001; j++) a[i][j]=-1;\n\td[0][0]=d[1][0]=d[2][1]=d[3][1]=0;\n\td[0][1]=d[2][0]=1; d[1][1]=d[3][0]=-1;\n\tscanf(\"%d%d%d\",&n,&m,&p);\n\tfor (int i=1; i<=p; i++) scanf(\"%d\",&s[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\",str+1);\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (str[j]=='#') a[i][j]=-1; else\n\t\t\tif (str[j]=='.') a[i][j]=0; else\n\t\t\ta[i][j]=str[j]-'0',v[a[i][j]].pb(mp(i,j));\n\t}\n\twhile (1)\n\t{\n\t\tbool bo=0;\n\t\tfor (int i=1; i<=p; i++)\n\t\t\tfor (int j=1; j<=s[i]; j++) \n\t\t\t\tif (!bfs(i)) break; else bo=1;\n\t\tif (!bo) break;\n\t}\n\tmemset(ans,0,sizeof(ans));\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (a[i][j]>0) ans[a[i][j]]++;\n\tfor (int i=1; i<=p; i++) printf(\"%d \",ans[i]); puts(\"\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Kilani and the Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/64664",
    "editorial": "This problem can be solved in many ways, one of them uses a bfs.Letâs\r\nprocess the first round.Iterate over players and use a multi-source bfs\r\nfor each player from his starting castles to find cells reachable in at\r\nmost moves. A multi-source bfs works just like regular one, except you\r\npush more vertices in the queue in the beginning. While moving, we canât\r\nenter a blocked cell or an already controlled cell.And in the each\r\nfollowing turn do the same, but start from the cells we stopped on the\r\nprevious turn, instead of starting castles.Keep doing this until no\r\nplayer can move anymore.Complexity:\r\n",
    "hint": []
}