{
    "link": "https://codeforces.com//contest/1903/problem/F",
    "problemId": "2355507",
    "problem_idx": "F",
    "shortId": "1903F",
    "contest_number": "1903",
    "problem_submissions": {
        "D2": [
            235128331,
            235435764,
            235183865,
            235116126,
            235121557,
            235122165,
            236143935,
            235115553,
            235129873,
            235119268
        ],
        "F": [
            235111543,
            235102179,
            235105725,
            235099949,
            235124718,
            235126382,
            235187626,
            235129442,
            235218441,
            235126934,
            235133564,
            235146171,
            235141771,
            235179210
        ],
        "E": [
            235106076,
            235104135,
            235115833,
            235114935,
            235102473,
            235112204,
            235107850,
            235103854,
            235111843,
            235109842,
            235115868,
            235124408,
            235114753,
            235126753,
            235108387,
            235107433,
            235107971,
            235105219,
            235108510,
            235108333
        ],
        "D1": [
            235093312,
            235109270,
            235095674,
            235117999,
            235091603,
            235099696,
            235100348,
            235094032,
            235098578,
            235098148,
            235119995,
            235115692,
            235105537,
            235119353,
            235094232,
            235095613,
            235096813,
            235097844,
            235096074,
            235099176
        ],
        "C": [
            235088892,
            235089084,
            235089891,
            235103743,
            235087836,
            235093791,
            235088528,
            235088785,
            235092085,
            235091882,
            235086000,
            235089517,
            235099201,
            235093455,
            235087482,
            235090537,
            235090823,
            235091561,
            235089639,
            235091936
        ],
        "B": [
            235086528,
            235084790,
            235086716,
            235102627,
            235086465,
            235090208,
            235086073,
            235088901,
            235087776,
            235087683,
            235089557,
            235084538,
            235096155,
            235090241,
            235085240,
            235087001,
            235086944,
            235087486,
            235086654,
            235088684
        ],
        "A": [
            235083574,
            235084421,
            235082280,
            235100671,
            235083954,
            235085469,
            235082350,
            235089029,
            235082379,
            235083014,
            235084518,
            235090802,
            235083842,
            235083352,
            235082144,
            235082627,
            235082396,
            235082150,
            235082134,
            235082717
        ]
    },
    "name": "F. Babysitting",
    "statement": "Theofanis wants to play video games, however he should also take care of\r\nhis sister. Since Theofanis is a CS major, he found a way to do both. He\r\nwill install some cameras in his house in order to make sure his sister\r\nis okay.His house is an undirected graph with n nodes and m edges. His\r\nsister likes to play at the edges of the graph, so he has to install a\r\ncamera to at least one endpoint of every edge of the graph. Theofanis\r\nwants to find a vertex cover that maximizes the minimum difference\r\nbetween indices of the chosen nodes.More formally, let a_1, a_2,\r\nldots, a_k be a vertex cover of the graph. Let the minimum difference\r\nbetween indices of the chosen nodes be the minimum\r\nlvert a_i - a_j\r\nrvert (where i\r\nneq j) out of the nodes that you chose. . Can you find the maximum\r\npossible minimum difference between indices of the chosen nodes over all\r\nvertex covers?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 20;\n\nstruct SAT {\n  vector <int> g[N << 1], stk;\n  int dep[N << 1], low[N << 1], scc_id[N << 1];\n  int n, _id, _t;\n  bool is[N];\n  SAT() {}\n  void init(int _n) {\n    n = _n, _id = _t = 0;\n    for (int i = 0; i < 2 * n; ++i)\n      g[i].clear(), dep[i] = scc_id[i] = -1;\n    stk.clear();\n  }\n  void add_edge(int x, int y) { g[x].push_back(y); }\n  int rev(int i) { return i < n ? i + n : i - n; }\n  void add_ifthen(int x, int y)\n  { add_clause(rev(x), y); }\n  void add_clause(int x, int y)\n  { add_edge(rev(x), y), add_edge(rev(y), x); }\n  void dfs(int i) {\n    dep[i] = low[i] = _t++, stk.push_back(i);\n    for (int j : g[i]) if (scc_id[j] == -1) {\n      if (dep[j] == -1) dfs(j);\n      low[i] = min(low[i], low[j]);\n    }\n    if (low[i] == dep[i]) {\n      int id = _id++, x;\n      do {\n        x = stk.back(), stk.pop_back(), scc_id[x] = id;\n      } while (x != i);\n    }\n  }\n  bool solve() {\n    // is[i] = true -> i, is[i] = false -> -i\n    for (int i = 0; i < 2 * n; ++i) if (dep[i] == -1)\n      dfs(i);\n    for (int i = 0; i < n; ++i) {\n      if (scc_id[i] == scc_id[i + n]) return false;\n      if (scc_id[i] < scc_id[i + n]) is[i] = true;\n      else is[i] = false;\n    }\n    return true;\n  }\n} sat;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        vector <pair <int, int>> edge(m);\n        for (auto &[u, v] : edge) {\n            cin >> u >> v, --u, --v;\n        }\n        auto add = [&](int l, int r, int id) {\n            for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n                if (l & 1) {\n                    sat.add_clause(sat.rev(id), sat.rev(l)), l++;\n                }\n                if (r & 1) {\n                    --r, sat.add_clause(sat.rev(id), sat.rev(r));\n                }\n            }\n        };\n        auto ask = [&](int num) {\n            sat.init(2 * n);\n            for (int i = 1; i < n; ++i) {\n                sat.add_ifthen(i << 1, i);\n                sat.add_ifthen(i << 1 | 1, i);\n            }\n            for (auto [u, v] : edge) {\n                sat.add_clause(u + n, v + n);\n            }\n            for (int i = 0; i < n; ++i) {\n                add(max(i - num + 1, 0), i, i + n);\n                add(i + 1, min(i + num, n), i + n);\n            }\n            return sat.solve();\n        };\n        int l = 1, r = n + 1;\n        while (r - l > 1) {\n            (ask(l + r >> 1) ? l : r) = l + r >> 1;\n        }\n        cout << l << '\\n';\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "binary search",
        "data structures",
        "graphs",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Babysitting.json",
    "editorial_link": "https://codeforces.com//blog/entry/122820",
    "editorial": "We can solve this problem using 2-sat and binary search the answer. In\r\norder to have a vertex cover we should have . And if we want to check if\r\nthe answer is greater or equal to we want to have for all pairs such\r\nthat .However, this way we will have too many edges. To fix this problem\r\nwe can create some helping nodes and edges in a similar structure of a\r\nsegment tree.In 2-sat when we connect two nodes there are two\r\npossibilities for each (taken or not taken). If we have an edge from to\r\nit means that when holds then definitely also holds. So, we build a\r\nbinary tree in a similar structure to a segment tree so that each node\r\nis connected to two children creating a binary-directed tree and each\r\nnode corresponds to a range. When we want to have edges from to and we\r\njust choose the nodes in this binary tree that are needed to make the\r\nrange (they are at most ).So that makes the total time complexity to:\r\nThere is also an solution. Shootout to jeroenodb for pointing it out.The\r\nidea is similar. We use 2-sat and binary search the answer, however,\r\nthis time we do 2-sat differently. In our graph, we will have the edges\r\nto have a vertex cover. So we should have . We add those edges and then\r\nwe should also have the edges corresponding to for all pairs such that .\r\nBut we don\u00e2\u0080\u0099t need all of them. We can just only go to first to the left\r\nand first to the right by storing the set of unvisited nodes and doing\r\nlower bound with dsu.\r\n"
}