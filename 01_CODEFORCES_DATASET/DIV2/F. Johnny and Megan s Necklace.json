{
    "link": "https://codeforces.com//contest/1362/problem/F",
    "problemId": "640967",
    "problem_idx": "F",
    "shortId": "1362F",
    "contest_number": "1362",
    "problem_submissions": {
        "E": [
            82533242,
            82534444,
            82537740,
            82514250,
            82533930,
            82533069,
            82537596,
            82539990,
            82540242,
            82538471,
            82539682,
            82530965,
            82542614,
            82539643,
            82539283,
            82546202,
            82528337,
            82546467
        ],
        "D": [
            82510668,
            82507788,
            82509488,
            82531898,
            82514757,
            82515389,
            82522345,
            82516278,
            82518522,
            82519426,
            82519224,
            82768835,
            82595629,
            82522253,
            82524305,
            82523832,
            82521456,
            82543796,
            82520171
        ],
        "C": [
            82499455,
            82498958,
            82501198,
            82493857,
            82499687,
            82506922,
            82499891,
            82507219,
            82505247,
            82500067,
            82504471,
            82506074,
            82507172,
            82504835,
            82510757,
            82507288,
            82510259
        ],
        "B": [
            82495744,
            82495722,
            82497194,
            82492324,
            82495262,
            82500116,
            82495247,
            82495676,
            82498396,
            82494894,
            82501982,
            82494238,
            82501685,
            82493927,
            82498961,
            82504636,
            82504999
        ],
        "A": [
            82492673,
            82492696,
            82492707,
            82492807,
            82492452,
            82496773,
            82492476,
            82492710,
            82493556,
            82492430,
            82494321,
            82492417,
            82493444,
            82492319,
            82493342,
            82492942,
            82498191
        ],
        "F": [
            99790549,
            99789950,
            99789855,
            99786615,
            99786490,
            99783918,
            99783396,
            99783108,
            99779312,
            99779011,
            99778620,
            99777308,
            99776727,
            99776430,
            99776080,
            99775979,
            99775398,
            99023034,
            99020809,
            99014011,
            99012603,
            82568961,
            82562279,
            82589807
        ]
    },
    "name": "F. Johnny and Megan s Necklace",
    "statement": "Johnny\u2019s younger sister Megan had a birthday recently. Her brother has\r\nbought her a box signed as \"\". It contains many necklace parts and some\r\nmagic glue. The necklace part is a chain connecting two pearls. Color of\r\neach pearl can be defined by a non-negative integer. The magic glue\r\nallows Megan to merge two pearls (possibly from the same necklace part)\r\ninto one. The beauty of a connection of pearls in colors u and v is\r\ndefined as follows: let 2^k be the greatest power of two dividing u\r\noplus v exclusive or of u and v. Then the beauty equals k. If u = v, you\r\nmay assume that beauty is equal to 20.Each pearl can be combined with\r\nanother at most once. Merging two parts of a necklace connects them.\r\nUsing the glue multiple times, Megan can finally build the necklace,\r\nwhich is a cycle made from connected necklace parts (so every pearl in\r\nthe necklace is combined with precisely one other pearl in it). The\r\nbeauty of such a necklace is the minimum beauty of a single connection\r\nin it. The girl wants to use all available necklace parts to build\r\nnecklace consisting of with the largest possible beauty. Help her!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = (1<<20)+5;\nbool used[MAXN];\nlist<int> adj[MAXN];\nint a[MAXN];\nint n;\nvoid dfs() {\n    stack<int> st;\n    st.push(1);\n    while(!st.empty()) {\n        int next = a[st.top()^1];\n        while(!adj[next].empty() and used[adj[next].back()/2]) {\n            adj[next].pop_back();\n        }\n        // case 1: we are done\n        if(adj[next].empty()) {\n            int p = st.top();\n            if(st.size()>1) {\n                cout << 1+(p^1) << \" \" << 1+p << \" \";\n            }\n            st.pop();\n        } else {\n            // case 2: actually needs to advance\n            int p = adj[next].back();\n            adj[next].pop_back();\n            st.push(p);\n            used[p/2] = true;\n        }\n    }\n}\nint pt[1<<20];\nbool occ[1<<20];\nint findset(int x) {\n    while(x!=pt[x]) {\n        pt[x] = pt[pt[x]];\n        x = pt[x];\n    }\n    return x;\n}\nint component = 0;\nvoid onion(int x, int y) {\n    x = findset(x);\n    y = findset(y);\n    if(x!=y) {\n        pt[x] = y;\n        component--;\n    }\n}\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(false);\n    cin>>n;\n    for(int i=0; i<2*n; i++) {cin>>a[i]; used[a[i]]=!used[a[i]];}\n\n    for(int i=0; i<n; i++) onion(a[2*i], a[2*i+1]);\n    int k;\n    for(k=20; k>=0; k--) {\n        bool good = true;\n        for(int i=0; i<(1<<k); i++) {\n            if(used[i]) {good = false; break;}\n        }\n\n        if(good) break;\n        for(int i=0; i<(1<<(k-1)); i++) {\n            used[i] = used[i]^used[i+(1<<(k-1))];\n        }\n    }\n    for(; k>=0; k--) {\n        component = 0;\n        for(int i=0; i<2*n; i++) {\n            a[i] = a[i]%(1<<k);\n            if(!occ[a[i]]) {\n                occ[a[i]] = true;\n                pt[a[i]] = a[i];\n                component++;\n            }\n        }\n        for(int i=0; i<n; i++) onion(a[2*i], a[2*i+1]);\n        for(int i=0; i<2*n; i++) {\n            occ[a[i]] = false;\n        }\n        if(component==1) break;\n    }\n    for(int i=0; i<n; i++) {used[i]=false;}\n    for(int i=0; i<2*n; i++) {a[i] = a[i]%(1<<k);}\n    for(int i=0; i<n; i++) {\n        adj[a[2*i]].push_back(2*i);\n        adj[a[2*i+1]].push_back(2*i+1);\n    }\n\n\n    cout << k << \"\\n\";\n    dfs();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Johnny and Megan s Necklace.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "Say that we want to check if it is possible to construct a necklace with beauty at least b\n. To this end, we will construct a graph of 2b\n vertices. For a necklace part with pearls in colors u\n and v\n there will be an edge in this graph between vertices with zero-based indices v & (2b?1)\n and u & (2b?1)\n. In a necklace with beauty (at least) b\n, only pearl with colors having last b\n bits the same can be glued together. Note that this is the exact condition that the edge endpoints have to satisfy to be in the same vertex. Since all the necklace parts have to be used, a necklace of beauty at least b\n is an Euler cycle of this graph.\n\nThe solution will construct the graph mentioned above for all possible values of b\n (we can iterate over all of them since there are only 21\n of them). If the constructed graph is Eulerian, it is possible to achieve the current value of b\n.\n\nIn order to find a sample necklace with the optimal beauty, one has to find the Euler cycle in the graph corresponding to the optimal value.\n\nChallenge: In another version of this task you are not allowed to glue pearls of the same color together. There is also a guarantee that there are no three pearls of the same color. Time complexity of the solution is the same."
}