{
    "link": "https://codeforces.com//contest/313/problem/E",
    "problemId": "3097",
    "problem_idx": "E",
    "shortId": "313E",
    "contest_number": "313",
    "problem_submissions": {
        "E": [
            3802009,
            3802725,
            3801964,
            3805353
        ],
        "D": [
            3797720,
            3799986,
            3798627,
            3799192,
            3799268,
            3799353,
            3800711,
            3799866,
            3801002,
            3801699,
            3801627,
            3801742,
            3801622,
            3802083,
            3801117,
            3802360,
            3801613,
            3801908,
            3802535
        ],
        "A": [
            3802962,
            3795436,
            3795102,
            3797387,
            3795045,
            3798014,
            3794999,
            3795409,
            3795792,
            3794982,
            3795227,
            3795063,
            4322018,
            3795032,
            3797305,
            3795417,
            3795327,
            3795051,
            3795267
        ],
        "B": [
            3801577,
            3795995,
            3795723,
            3796954,
            3795477,
            3797148,
            3795579,
            3796367,
            3796731,
            3795434,
            3796152,
            3795631,
            4322027,
            3795692,
            3798022,
            3795515,
            3796167,
            3796035,
            3796153,
            3796081
        ],
        "C": [
            3797963,
            3797299,
            3796705,
            3796548,
            3798340,
            3796144,
            3800856,
            3799056,
            3797632,
            3798099,
            3797857,
            3799305,
            3796795,
            3796746,
            3807119,
            3797868,
            3799430,
            3798657,
            3798471,
            3797214
        ]
    },
    "name": "E. Ilya and Two Numbers",
    "statement": "Ilya has recently taken up archaeology. Heâ€™s recently found two numbers,\r\nwritten in the -based notation. Each of the found numbers consisted of\r\nexactly digits. Ilya immediately started looking for information about\r\nthose numbers. He learned that the numbers are part of a cyphered code\r\nand the one who can decypher it can get the greatest treasure.After\r\nconsiderable research Ilya understood that to decypher the code, he\r\nshould do the following: Rearrange digits in the first number in some\r\nmanner. Similarly, rearrange digits in the second number in some manner.\r\nAs a result of this operation, the numbers can get leading zeroes. Add\r\nnumbers, digit by digit, modulo . In other words, we need to get the\r\nthird number of length , each digit of the number is the sum of the\r\nrespective numbers of the found numbers. For example, suppose there are\r\ntwo numbers recorded in the ternary notation, 001210 and 012111, then if\r\nyou add them to each other digit by digit modulo 3, you will get number\r\n010021. The key to the code is the maximum possible number that can be\r\nobtained in the previous step. Help Ilya, find the key to the code.\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nint a[111111], b[111111];\nint la[111111], ra[111111];\nint Next[111111], Prev[111111];\nbool ma[111111], mb[111111];\n\nstruct data {\n    int i, j;\n    data (int _i, int _j) {\n        i = _i; j = _j;\n    }\n    inline friend bool operator < (data x, data y) {\n        return (a[x.i] + b[x.j]) % m < (a[y.i] + b[y.j]) % m;\n    }\n};\n\npriority_queue<data> f;\nset<int> idx;\n\nint main() {\n    // freopen(\"E.in\", \"r\", stdin);\n\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", a+i);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", b+i);\n\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+n);\n    b[n+1] = m;\n    for(int i = 1; i <= n; i++)\n        idx.insert(-i);\n\n    memset(ma, 0, sizeof ma);\n    memset(mb, 0, sizeof mb);\n\n    for(int i = 1; i <= n; i++) {\n        int need = m-a[i]-1;\n        int l = 1, r = n+1;\n        while (l < r) {\n            int mid = (l+r)/2;\n            if (b[mid] <= need) l = mid+1;\n            else r = mid;\n        }\n        l--;\n        if (l) f.push(data(i, l));\n        if (l < n) f.push(data(i, n));\n    }\n\n    while (!f.empty()) {\n        data t = f.top(); f.pop();\n        if (!ma[t.i]) {\n            if (!mb[t.j]) {\n                printf(\"%d \", (a[t.i] + b[t.j]) % m);\n                ma[t.i] = 1;\n                mb[t.j] = 1;\n                idx.erase(-t.j);\n            }\n            else {\n                set<int>::iterator it = idx.lower_bound(-t.j);\n                if (it != idx.end()) {\n                    t.j = -(*it);\n                    f.push(t);  \n                }\n                \n            }\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dsu",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ilya and Two Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/7826",
    "editorial": " 1) Get the number of our sequences in sorted by\nfrequencies. Thus from the first sequence (hereinafter the first type)\nin a direct order from the second to the contrary. 2) These numbers are\nput on the stack, where if, recording onto the stack of the second type,\nwe find the number at the top of the first type, then this pair of\nextract and add to the answer. 3) At the end, obviously the stack we can\nfind a number of properties of the second type and the first bottom on.\nThen their grouping in response pairs with the start and end. For better\nunderstanding you can look at solution. .\n",
    "hint": []
}