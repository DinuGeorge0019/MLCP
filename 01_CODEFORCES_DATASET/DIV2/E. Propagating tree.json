{"link": "https://codeforces.com//contest/384/problem/E", "problemId": "5721", "problem_idx": "E", "shortId": "384E", "contest_number": "384", "problem_submissions": {"E": [5754820, 5756457, 5757218, 5768768, 5754973, 5757082, 5757773, 5753824, 5757669, 5759993, 5759984, 5759937], "C": [5752253, 5751497, 5752881, 5756887, 5754090, 5753464, 5757534, 5753590, 5750204, 5750062, 5751623, 5750722, 5749880, 5751415, 5751385, 5750837, 5751269, 5751529, 5751672, 5751983], "B": [5748010, 5749890, 5748064, 5751405, 5751229, 5751814, 5754578, 5753247, 5749239, 5750952, 5748962, 5749250, 5750859, 5749807, 5750164, 5749512, 5750591, 5750157, 5750184, 5749558], "A": [5747255, 5747392, 5747271, 5747721, 5748251, 5749148, 5747297, 5749334, 5748038, 5747882, 5747312, 5747613, 5747325, 5747593, 5747897, 5747709, 5747419, 5747633, 5747362, 5747257], "D": [5759668, 5766263]}, "name": "E. Propagating tree", "statement": "Iahub likes trees very much. Recently he discovered an interesting tree\r\nnamed propagating tree. The tree consists of nodes numbered from to ,\r\neach node having an initial value . The root of the tree is node .This\r\ntree has a special property: when a value is added to a value of node ,\r\nthe value - is added to values of all the children of node . Note that\r\nwhen you add value - to a child of node , you also add -(-) to all\r\nchildren of the child of node and so on. Look an example explanation to\r\nunderstand better how it works.This tree supports two types of queries:\r\n\" \" is added to the value of node ; \" \" print the current value of node\r\n. In order to help Iahub understand the tree better, you must answer\r\nqueries of the preceding type.\r\n", "solutions": ["//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname \"\"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(\"%d\" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(\"%d\" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint n, m, z[sz], v, u, T, p[sz], l[sz], r[sz], c, t[2][sz], x, H, h[sz];\nVI a[sz];\n\nvoid upd(int g, int v, int tl, int tr, int l, int r, int x)\n{\n\tif (l > r)\n\t\treturn;\n\t//cerr << l << \" \" << r << \" \" << tl << \" \" << tr << endl;\n\tif (tl == l && tr == r)\n\t\tt[g][v] += x;\n\telse\n\t{\n\t\tint m = (tl + tr) >> 1;\n\t\tupd(g, v + v, tl, m, l, min(r, m), x);\n\t\tupd(g, v + v + 1, m + 1, tr, max(m + 1, l), r, x);\n\t}\n}\n\nvoid dfs(int v, int pr = -1)\n{\n\th[v] = H;\n\tH++;\n\tl[v] = c;\n\tc++;\n\tfor (0, int(a[v].size()) - 1, i)\n\t{\n\t\tif (a[v][i] != pr)\n\t\t\tdfs(a[v][i], v);\n\t}\n\tH--;\n\tr[v] = c - 1;\n}\n\nvoid push(int g, int v)\n{\n\tif (t[g][v])\n\t{\n\t\tt[g][v + v] += t[g][v];\n\t\tt[g][v + v + 1] += t[g][v];\n\t\tt[g][v] = 0;\t\n\t}\n\n}\n\nint get(int g, int v, int l, int r, int p)\n{\n\tif (l == r)\n\t\treturn t[g][v];\n\tpush(g, v);\n\tint m = (l + r) >> 1;\n\tif (p <= m)\n\t\treturn get(g, v + v, l, m, p);\n\telse\n\t\treturn get(g, v + v + 1, m + 1, r, p);\n}\n\nint main(){\n\t//freopen(fname\"in\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\tcin >> n >> m;\n\n\tc = 1;\n\tfor (1, n, i)\n\t\tcin >> z[i];\n\tfor (1, n - 1, i)\n\t{\n\t\tcin >> v >> u;\n\t\ta[v].pb(u);\n\t\ta[u].pb(v);\n\t}\n\n\tH = 0;\n\tdfs(1);\n\tfor (1, m, i)\n\t{\n\t\tcin >> T >> v;\n\t\tif (T == 1)\n\t\t{\n\t\t\tcin >> u;\n\t\t\tupd(h[v] % 2, 1, 1, n, l[v], r[v], u);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (h[v] % 2 == 0)\n\t\t\t\tcout << z[v] + get(0, 1, 1, n, l[v]) - get(1, 1, 1, n, l[v]) << \"\\n\";\n\t\t\telse\n\t\t\t\tcout << z[v] + get(1, 1, 1, n, l[v]) - get(0, 1, 1, n, l[v]) << \"\\n\";\n\t\t}\n\t}\n    \treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "trees"], "dificulty": "2000", "interactive": false}