{
    "link": "https://codeforces.com//contest/384/problem/E",
    "problemId": "5721",
    "problem_idx": "E",
    "shortId": "384E",
    "contest_number": "384",
    "problem_submissions": {
        "E": [
            5754820,
            5756457,
            5757218,
            5768768,
            5754973,
            5757082,
            5757773,
            5753824,
            5757669,
            5759993,
            5759984,
            5759937
        ],
        "C": [
            5752253,
            5751497,
            5752881,
            5756887,
            5754090,
            5753464,
            5757534,
            5753590,
            5750204,
            5750062,
            5751623,
            5750722,
            5749880,
            5751415,
            5751385,
            5750837,
            5751269,
            5751529,
            5751672,
            5751983
        ],
        "B": [
            5748010,
            5749890,
            5748064,
            5751405,
            5751229,
            5751814,
            5754578,
            5753247,
            5749239,
            5750952,
            5748962,
            5749250,
            5750859,
            5749807,
            5750164,
            5749512,
            5750591,
            5750157,
            5750184,
            5749558
        ],
        "A": [
            5747255,
            5747392,
            5747271,
            5747721,
            5748251,
            5749148,
            5747297,
            5749334,
            5748038,
            5747882,
            5747312,
            5747613,
            5747325,
            5747593,
            5747897,
            5747709,
            5747419,
            5747633,
            5747362,
            5747257
        ],
        "D": [
            5759668,
            5766263
        ]
    },
    "name": "E. Propagating tree",
    "statement": "Iahub likes trees very much. Recently he discovered an interesting tree\r\nnamed propagating tree. The tree consists of nodes numbered from to ,\r\neach node having an initial value . The root of the tree is node .This\r\ntree has a special property: when a value is added to a value of node ,\r\nthe value - is added to values of all the children of node . Note that\r\nwhen you add value - to a child of node , you also add -(-) to all\r\nchildren of the child of node and so on. Look an example explanation to\r\nunderstand better how it works.This tree supports two types of queries:\r\n\" \" is added to the value of node ; \" \" print the current value of node\r\n. In order to help Iahub understand the tree better, you must answer\r\nqueries of the preceding type.\r\n",
    "solutions": [
        "//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname \"\"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(\"%d\" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(\"%d\" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint n, m, z[sz], v, u, T, p[sz], l[sz], r[sz], c, t[2][sz], x, H, h[sz];\nVI a[sz];\n\nvoid upd(int g, int v, int tl, int tr, int l, int r, int x)\n{\n\tif (l > r)\n\t\treturn;\n\t//cerr << l << \" \" << r << \" \" << tl << \" \" << tr << endl;\n\tif (tl == l && tr == r)\n\t\tt[g][v] += x;\n\telse\n\t{\n\t\tint m = (tl + tr) >> 1;\n\t\tupd(g, v + v, tl, m, l, min(r, m), x);\n\t\tupd(g, v + v + 1, m + 1, tr, max(m + 1, l), r, x);\n\t}\n}\n\nvoid dfs(int v, int pr = -1)\n{\n\th[v] = H;\n\tH++;\n\tl[v] = c;\n\tc++;\n\tfor (0, int(a[v].size()) - 1, i)\n\t{\n\t\tif (a[v][i] != pr)\n\t\t\tdfs(a[v][i], v);\n\t}\n\tH--;\n\tr[v] = c - 1;\n}\n\nvoid push(int g, int v)\n{\n\tif (t[g][v])\n\t{\n\t\tt[g][v + v] += t[g][v];\n\t\tt[g][v + v + 1] += t[g][v];\n\t\tt[g][v] = 0;\t\n\t}\n\n}\n\nint get(int g, int v, int l, int r, int p)\n{\n\tif (l == r)\n\t\treturn t[g][v];\n\tpush(g, v);\n\tint m = (l + r) >> 1;\n\tif (p <= m)\n\t\treturn get(g, v + v, l, m, p);\n\telse\n\t\treturn get(g, v + v + 1, m + 1, r, p);\n}\n\nint main(){\n\t//freopen(fname\"in\", \"r\", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\tcin >> n >> m;\n\n\tc = 1;\n\tfor (1, n, i)\n\t\tcin >> z[i];\n\tfor (1, n - 1, i)\n\t{\n\t\tcin >> v >> u;\n\t\ta[v].pb(u);\n\t\ta[u].pb(v);\n\t}\n\n\tH = 0;\n\tdfs(1);\n\tfor (1, m, i)\n\t{\n\t\tcin >> T >> v;\n\t\tif (T == 1)\n\t\t{\n\t\t\tcin >> u;\n\t\t\tupd(h[v] % 2, 1, 1, n, l[v], r[v], u);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (h[v] % 2 == 0)\n\t\t\t\tcout << z[v] + get(0, 1, 1, n, l[v]) - get(1, 1, 1, n, l[v]) << \"\\n\";\n\t\t\telse\n\t\t\t\tcout << z[v] + get(1, 1, 1, n, l[v]) - get(0, 1, 1, n, l[v]) << \"\\n\";\n\t\t}\n\t}\n    \treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Propagating tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/10476",
    "editorial": "This is kind of task that needs to be break into smaller subproblems\r\nthat you can solve independently, then put them together and get\r\nsolution. Let s define level of a node the number of edges in the path\r\nfrom root to the node. Root (node 1) is at level 0, sons of root are at\r\nlevel 1, sons of sons of root are at level 2 and so on. Now suppose you\r\nwant to do an operation of type 1 to a node x. What nodes from subtree\r\nof x will be added +val (a positive value)? Obviously, x will be first,\r\nbeing located at level L. Sons of x, located at level L + 1 will be\r\nadded val. Sons of sons, located at level L + 2, will be added value\r\n+val again. So, nodes from subtree of x located at levels L, L + 2, L +\r\n4, ... will be added a +val, and nodes located at levels L + 1, L + 3,\r\nL + 5 will be added a val. Let s take those values of L modulo 2. All\r\nnodes having remainder L modulo 2 will be added a +val, and nodes having\r\nreminder (L + 1) modulo 2 will be added val. In other words, for a fixed\r\nx, at a level L, let y a node from subtree of x, at level L2. If L and\r\nL2 have same parity, +val will be added to y. Otherwise, -val will be\r\nadded to y. From here we have the idea to split nodes of tree in 2 sets\r\nthose being located at even level and those being located at odd level.\r\nWhat still makes the problem hard to solve? The fact that we have a\r\ntree. If nodes from a subtree would be a contiguous sequence instead of\r\nsome nodes from a tree, problem would be simpler: the problem would\r\nreduce to add / subtract values to all elements of a subarray and query\r\nabout a current value of an element of array. So, how can we transform\r\ntree to an array, such as for a node x, all nodes from subtree of x to\r\nbe a subarray of array? The answer is yes. We can do this by properties\r\nof DFS search. Before reading on, make sure that you know what is\r\ndiscovery time and finish time in a DFS search. Let s build 3 arrays now\r\ndiscover[], representing nodes in order of their discover times (a node\r\nis as before in discover as it has a small discover time), begin[] = for\r\na node, in which time it was discovered and end[] = what s last time of\r\na discovered node before this node finishes. For a subtree of x, all\r\nnodes in the subtree are nodes in discover from position begin[x] to\r\nend[x]. Example: suppose you have tree 1-5; 1-6; 6-7; 6-4; 4-2; 4-3\r\nDiscover is {1, 5, 6, 7, 4, 2, 3}. begin is {1, 6, 7, 5, 2, 3, 4}. end\r\nis {7, 6, 7, 7, 2, 7, 4}. What s subtree of node 6? elements of discover\r\nfrom position begin[6] to end[6]. In this case, from 3 to 7, so elements\r\n{6, 7, 4, 2, 3}. You can see it s correct and take more examples if you\r\nwant :) Now, we reduced problem to: you re given an array A. you can\r\nperform 2 operations: 1/ increase all elements from a range [x, y] to a\r\nvalue val (val can be negative, to treat subtractions) 2/ what s current\r\nvalue of an element from position pos. Those who solved Iahub and Xors\r\nfrom my last round, CF 198, should probably say they saw something\r\nsimilar before. If you didn t solve problem before, I encourage you to\r\ndo it after you solve this one, it uses a similar idea to what will\r\nfollow now. Also, if you don t know Fenwick trees, please read them\r\nbefore moving on. An alternative would be for this task using segment\r\ntrees with lazy update, but I see this one more complicated than needed.\r\nI ll use now a not so common approach when dealing with data structures.\r\nInstead of keeping in a node the result, like you usually do, I ll keep\r\njust an auxiliary information. So what algorithm proposed does: Let A an\r\narray, initially with all elements 0. When you need to update range [x,\r\ny] with value val, you simply do A[x] += val and A[y + 1] -= val. When\r\nyou need to answer a query about position pos, you output A[1] + A[2] +\r\n... + A[pos]. Implemented brute force, you get O(1) per update and O(N)\r\nper query. However, these both are operations supported by a Fenwick\r\ntree, so you can get O(logN) per operation. It may not be very clear why\r\nthis algorithm works. Let s take a closer look: an update needs to add\r\nvalue val only to range [x, y]. When you query a position pos, let s see\r\nif algorithm handles it correctly: 1/ pos < x. In this case, result must\r\nnot be affected by my update. Since pos < x and I only updated 2 values\r\nwith indices >= x, when doing A[1] + A[2] + ... + A[pos] it won t matter\r\nat all I did that update at least not for this query. 2/ x <= pos <= y.\r\nHere, for a pos, I need to add value val only once. We add it only at\r\nA[x] in this way it will be counted once, and it will be considered for\r\neach elements from range [x, y] (since an element at position p from\r\nrange [x, y] has p >= x, in A[1] + A[2] + ... + A[p] I ll have to\r\nconsider A[x]). 3/ pos > y. Here I don t have to consider the query. But\r\nit would be considered when processing A[x]. But if I add to A[y + 1]\r\nvalue val I ll just cancel the value previously added. Code (actually we\r\nuse just one Fenwick tree instead of 2, can you think why it works? :) )\r\n: http://pastie.org/8651824\r\n"
}