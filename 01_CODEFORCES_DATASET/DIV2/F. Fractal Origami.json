{
    "link": "https://codeforces.com//contest/1925/problem/F",
    "problemId": "2447856",
    "problem_idx": "F",
    "shortId": "1925F",
    "contest_number": "1925",
    "problem_submissions": {
        "F": [
            243635672,
            243648922,
            243652277,
            243654463,
            243696386
        ],
        "E": [
            243616564,
            243621263,
            243626621,
            243628373,
            243642423,
            243636417,
            243643693,
            243633557,
            243638778,
            243637771,
            243645710,
            243648841,
            243629267,
            243713101,
            243632960,
            243654973,
            243648168,
            243647861,
            243652611,
            243647183,
            243650906
        ],
        "D": [
            243592234,
            243594869,
            243599958,
            243596486,
            243624513,
            243610640,
            243600801,
            243608352,
            243605500,
            243665895,
            243608581,
            243587140,
            243614894,
            243606314,
            243649266,
            243604378,
            243609277,
            243609750,
            243623206,
            243609456,
            249399690,
            243606073
        ],
        "C": [
            243570353,
            243577698,
            243576709,
            243576761,
            243588406,
            243564488,
            243578879,
            243585269,
            243576848,
            243595639,
            243608536,
            243585312,
            243573744,
            243571216,
            243580792,
            243582138,
            243591440,
            243576695,
            243587225,
            249717100,
            243587500
        ],
        "B": [
            243565143,
            243557943,
            243563278,
            243563287,
            243557566,
            243563680,
            243568156,
            243559337,
            243561416,
            243559345,
            243566711,
            243558705,
            243561296,
            243561403,
            243570584,
            243570498,
            243563900,
            243563678,
            243565505
        ],
        "A": [
            243556584,
            243556225,
            243557446,
            243557520,
            243556082,
            243557771,
            243560727,
            243556392,
            243556560,
            243556879,
            243556644,
            243556058,
            243556214,
            243556452,
            243557610,
            243558322,
            243556372,
            243556420,
            243556133
        ]
    },
    "name": "F. Fractal Origami",
    "statement": "You have a square piece of paper with a side length equal to 1 unit. In\r\none operation, you fold each corner of the square to the center of the\r\npaper, thus forming another square with a side length equal to\r\ndfrac{1}{\r\nsqrt{2}} units. By taking this square as a new square, you do the\r\noperation again and repeat this process a total of N times. After\r\nperforming the set of operations, you open the paper with the same side\r\nup you started with and see some crease lines on it. Every crease line\r\nis one of two types: a mountain or a valley. A mountain is when the\r\npaper folds outward, and a valley is when the paper folds inward.You\r\ncalculate the sum of the length of all mountain crease lines on the\r\npaper and call it M. Similarly, you calculate for valley crease lines\r\nand call it V. You want to find the value of\r\ndfrac{M}{V}.It can be proved that this value can be represented in the\r\nform of A + B\r\nsqrt{2}, where A and B are rational numbers. Let this B be represented\r\nas an irreducible fraction\r\ndfrac{p}{q}, your task is to print p*inv(q) modulo 999\r\n,999\r\n,893 , where inv(q) is the modular inverse of q.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cassert>\n\nint64_t MOD = 999999893LL;\n\nusing namespace std;\n\nbool __hack = ios::sync_with_stdio(false);\nauto __hack1 = cin.tie(nullptr);\n\ntemplate<typename T>\nT next() {\n    T x;\n    cin >> x;\n    return x;\n}\n\nstruct Val {\n    int64_t a, b;\n\n    Val(int64_t a, int64_t b) : a(a), b(b) {\n    }\n};\n\nVal operator+(const Val& a, const Val& b) {\n    return Val((a.a + b.a) % MOD, (a.b + b.b) % MOD);\n}\n\nVal operator-(const Val& a, const Val& b) {\n    return Val((a.a - b.a + MOD) % MOD, (a.b - b.b + MOD) % MOD);\n}\n\nVal operator*(const Val& u, const Val& v) {\n    return Val((u.a * v.a + u.b * v.b * 2) % MOD, (u.a * v.b + u.b * v.a) % MOD);\n}\n\nVal& operator+=(Val& a, const Val& b) {\n    a = a + b;\n    return a;\n}\n\nVal& operator-=(Val& a, const Val& b) {\n    a = a - b;\n    return a;\n}\n\nVal& operator*=(Val& a, const Val& b) {\n    a = a * b;\n    return a;\n}\n\nint64_t mod_pow(int64_t a, int64_t b) {\n    a %= MOD;\n    int64_t r = 1;\n    while (b) {\n        if (b & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return r;\n}\n\nint64_t mod_inv(int64_t a) {\n    return mod_pow(a, MOD - 2);\n}\n\nVal inv(const Val& a) {\n    int64_t r = mod_inv(a.a * a.a + (MOD - 2) * a.b % MOD * a.b);\n    return Val(a.a * r % MOD, (MOD - a.b) * r % MOD);\n}\n\nostream& operator<<(ostream& os, const Val& a) {\n    return os << '(' << a.a << ',' << a.b << ')';\n}\n\nVal pow(Val a, int64_t b) {\n    Val r = Val{1, 0};\n    while (b) {\n        if (b & 1) {\n            r = r * a;\n        }\n        a = a * a;\n        b >>= 1;\n    }\n    return r;\n}\n\nint main() {\n    int tests = next<int>();\n    int64_t inv2 = (MOD + 1) / 2;\n    for (int test = 0; test < tests; ++test) {\n        int n = next<int>();\n        // Val l1{0, 0}, l2{0, 0}, side{1, 0}, d1{0, 0}, d2{1, 0};\n        // for (int i = 0; i < n; ++i) {\n        //     Val r{0, 1};\n        //     l1 += d1 * side * r;\n        //     l2 += d2 * side * r;\n        //     d1 = d2 = d1 + d2;\n        //     side = side * Val{0, inv2};\n        // }\n        // cerr << l1 << ' ' << l2 << ' ' << side << ' ' << d1 << ' ' << d2 << '\\n';\n        Val l1 = (pow(Val{0, 1}, n - 1) - Val{1, 0}) * inv(Val{MOD - 1, 1});\n        Val l2 = l1 + Val{0, 1};\n        // cerr << l2 << '\\n';\n        Val ans = l1 * inv(l2);\n        cout << ans.b << '\\n';\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Fractal Origami.json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "Let there be an upside of the paper and a downside of the paper, initially the upside of the paper is facing up. With a little imagination, we can see that the mountain crease lines on the upside of the paper will be valley crease lines on the downside of the paper, and vice versa.\n\n\n\nGrey is the upside and orange is the downside\n\nAfter the first operation, what once was a single layer of square paper turns into a square with two overlapping layers of paper. The layer at the bottom has its upside facing up, and the layer at the top has its downside facing up.\n\nAfter this first operation, whatever crease lines are formed on the upside of the bottom layer will be the same as the ones formed on the bottom layer of the top layer, which means when the paper is unfolded and the upside of the entire paper is facing up, the mountain crease lines and the valley crease lines created after the first operation will be equal.\n\nLet M\n be the length of mountain crease lines and V\n be the length of valley crease lines after N\n moves, and the side of the square paper is 1\n.\n\nLet diff=V?M=\n Length of valley crease lines created in the first operation =22?\n.\n\nIt is easy to calculate the total crease lines that are created (mountain and valley) in N\n operations. It is the sum of a GP.\n\nLet sum=V+M=?i=1N2i?1?22??(12?)i?1=?i=1N(2?)i+2\n\nNow to find MV\n, we use the age-old componendo and dividendo.\n\nMV=sum?diffsum+diff\n\nAnd then rationalize it to find the coefficient of 2?\n.",
    "hint": []
}