{
    "link": "https://codeforces.com//contest/381/problem/D",
    "problemId": "5527",
    "problem_idx": "D",
    "shortId": "381D",
    "contest_number": "381",
    "problem_submissions": {
        "E": [
            5672312,
            5673890,
            5672640,
            5674012,
            5673942,
            5674064,
            5674158,
            5672887,
            5675816,
            6481132,
            5673153,
            5673647,
            5675440,
            5675508,
            5675052,
            5675464,
            5674370,
            5675251,
            5675100
        ],
        "C": [
            5670620,
            5670357,
            5670156,
            5670230,
            5670852,
            5670514,
            5671644,
            5674896,
            5670687,
            5671510,
            5675154,
            5675589,
            5672130,
            5672003,
            5672276,
            5673101,
            5671653,
            5677587,
            5672482,
            5672754
        ],
        "B": [
            5667383,
            5667530,
            5668160,
            5667526,
            5667221,
            5667323,
            5682800,
            5668514,
            5668603,
            5667280,
            5667809,
            5667640,
            5668168,
            5667958,
            5667727,
            5669465,
            5669171,
            5672704,
            5667775,
            5671101
        ],
        "A": [
            5666172,
            5666328,
            5667263,
            5666342,
            5666147,
            5666449,
            5680004,
            5666226,
            5667506,
            5666221,
            5666521,
            5666215,
            5667030,
            5667212,
            5666641,
            5666780,
            5667112,
            5671987,
            5666602,
            5667129
        ],
        "D": [
            5677146,
            5673435,
            6765447
        ]
    },
    "name": "D. Sereja and Tree",
    "statement": "Sereja adores trees. Today he came up with a revolutionary new type of\r\nbinary root trees.His new tree consists of levels, each vertex is\r\nindexed by two integers: the number of the level and the number of the\r\nvertex on the current level. The tree root is at level , its index is .\r\nHere is a pseudo code of tree construction.//the global data are integer\r\narrays cnt[], left[][], right[][]cnt[1] = 1;fill arrays left[][],\r\nright[][] with values -1;for(level = 1; level < n; level = level + 1){\r\ncnt[level + 1] = 0; for(position = 1; position <= cnt[level]; position =\r\nposition + 1){ if(the value of position is a power of two){ // that is,\r\n1, 2, 4, 8... left[level][position] = cnt[level + 1] + 1;\r\nright[level][position] = cnt[level + 1] + 2; cnt[level + 1] =\r\ncnt[level + 1] + 2; }else{ right[level][position] = cnt[level + 1] + 1;\r\ncnt[level + 1] = cnt[level + 1] + 1; } }}After the pseudo code is run,\r\ncell contains the number of vertices on level . Cell contains the number\r\nof the vertex on the level , which is the left child of the vertex with\r\nindex , or it contains -1, if the vertex doesn\u2019t have a left child.\r\nSimilarly, cell is responsible for the right child. You can see how the\r\ntree with looks like in the notes.Serja loves to make things\r\ncomplicated, so he first made a tree and then added an empty set for\r\neach vertex. Then Sereja executes operations. Each operation is of one\r\nof the two following types: The format of the operation is \" \". For all\r\nvertices add value to set . The format of the operation is \" \". For\r\nvertex , find the union of all sets of vertices that are in the subtree\r\nof vertex . Print the size of the union of these sets. Help Sereja\r\nexecute the operations. In this problem a set contains only distinct\r\nvalues like std::set in C++.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define mp(a,b) make_pair(a, b)\n\n#define RD(x) scanf(\"%d\", &x)\n#define RDD(x, y) scanf(\"%d%d\", &x, &y)\n#define FOR(i, n) for(int i = 0; i < n; ++i)\n#define CLR(A, V) memset(A, V, sizeof A)\n#define PD(x) printf(\"%d\\n\", x)\n\nint nxt(int a, int b) {\n    int tmp = a;\n    if(b) tmp++;\n    int r = 0, t = 1;\n    while(t < tmp) t <<= 1, r++;\n    return a+r;\n}\n\nstruct S {\n    int a, b, c;\n};\nvector<S> a[7010];\nint n, m;\nint solve(int t, int v) {\n    int l = v, r = v;\n    set<int> res;\n    for(int i = t; i <= n; ++i) {\n        for(int j = 0; j < a[i].size(); ++j) {\n            S &s = a[i][j];\n            if(s.a <= l && s.b >= l) res.insert(s.c);\n            else if(l <= s.a && r >= s.a) res.insert(s.c);\n        }\n        l = nxt(l, 0);\n        r = nxt(r, 1);\n    }\n    return res.size();\n}\n\nint main() {\n    RDD(n, m);\n    while(m--) {\n        int o; RD(o);\n        if(o == 1) {\n            int t, l, r, x;\n            RDD(t, l); RDD(r, x);\n            a[t].push_back((S){l, r, x});\n        }\n        else {\n            int t, v; RDD(t, v);\n            PD(solve(t, v));\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Sereja and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/10363",
    "editorial": "Lets generate a tree as described in the statment. For each request to add items we just add a segment for a certain level. At the request of the number of items we just go through all the lower levels, considering the leftmost and the rightmost vertex in the subtree. To each level will take all intervals that it owns and for each check \u0097 whether it intersects with the interval that we have generated in the current stage. If so, simply add items to the set. The complexity of solving O(n\u00b7m).\n"
}