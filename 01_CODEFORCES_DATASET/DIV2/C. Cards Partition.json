{
    "link": "https://codeforces.com//contest/2019/problem/C",
    "problemId": "2905355",
    "problem_idx": "C",
    "shortId": "2019C",
    "contest_number": "2019",
    "problem_submissions": {
        "F": [
            283223839,
            283223286,
            283233615,
            283232657,
            283229948,
            283240516,
            283246459,
            283246565,
            283251452,
            283250505,
            283246427,
            283244651,
            283250557,
            283250319,
            283249369,
            283252799,
            283231473,
            283385869
        ],
        "D": [
            283212674,
            283217889,
            283216603,
            283210525,
            283219753,
            283227849,
            283216187,
            283224832,
            283209439,
            283233196,
            283224958,
            283235552,
            283222166,
            283223408,
            283233229,
            283225040,
            283257759,
            283214659,
            283210870,
            283212555
        ],
        "C": [
            283205819,
            283208819,
            283200046,
            283197191,
            283204787,
            283192339,
            283195887,
            283200218,
            283196222,
            283200867,
            283211801,
            283203783,
            283208730,
            283210534,
            283225468,
            283214456,
            283200932,
            283202854,
            283202139,
            283199131
        ],
        "B": [
            283197247,
            283193710,
            283188887,
            283186540,
            283192007,
            283185443,
            283202984,
            283190900,
            283188420,
            283188733,
            283190635,
            283190801,
            283197405,
            283188473,
            283191300,
            283202121,
            283194633,
            283194452,
            283194664,
            283188555
        ],
        "A": [
            283194983,
            283181021,
            283181315,
            283181373,
            283182984,
            283180436,
            283198713,
            283181153,
            283180882,
            283182334,
            283181092,
            283183886,
            283188674,
            283181377,
            283181185,
            283196847,
            283190061,
            283183844,
            283182154,
            283180956
        ],
        "E": [
            283192360,
            283198927,
            283209740,
            283216991,
            283212803,
            283197800,
            283209059,
            283219624,
            283225534,
            283213304,
            283232353,
            283227746,
            283232779,
            283233925,
            283218649,
            283231587,
            283221137,
            283211364,
            283219849,
            283218893
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "Note that there are n\n types of cards, so the subsets have size at most n\n, and the answer is at most n\n.\n\nIf k=0\n, you can make subsets of size s\n if and only if the following conditions are true:\n\nthe number of cards (m\n) is a multiple of s\n;\nthe maximum number of cards of some type (x\n) is ?m/s\n.\nProof:\n\nm\n is the number of decks times s\n.\nThe number of decks is m/s\n. Each deck can contain at most 1\n card of each type, so there are at most m/s\n cards of each type in total.\nIf the two conditions above hold, you can make a deck containing the s\n types of cards with maximum frequency. You can show with some calculations that the conditions still hold after removing these cards. So you can prove by induction that the two conditions are sufficient to make decks of size s\n.\nThe same idea is used in problems like 1954D - Colored Balls and abc227_d - Project Planning.\n\nFor a generic k\n, the answer is n\n if you can make the number of cards of type 1,,n\n equal. Otherwise, for any choice of number of cards to buy, you can buy them without changing x\n. It means that you need x?s\n cards in total:\n\nif you have less than x?s\n cards, you have to check if you can reach x?s\n cards by buying at most k\n new cards;\nif you already have x?s\n or more cards at the beginning, you have to check if you can make m\n a multiple of s\n.\nComplexity: O(n)",
    "name": "C. Cards Partition",
    "statement": "You have some cards. An integer between 1 and n is written on each card:\r\nspecifically, for each i from 1 to n, you have a_i cards which have the\r\nnumber i written on them.There is also a shop which contains unlimited\r\ncards of each type. You have k coins, so you can buy k new cards in\r\ntotal, and the cards you buy can contain any integer , inclusive.After\r\nbuying the new cards, you must partition your cards into decks,\r\naccording to the following rules: all the decks must have the same size;\r\nthere are no pairs of cards with the same value in the same deck. Find\r\nthe maximum possible size of a deck after buying cards and partitioning\r\nthem optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define int long longconst int N=2e5+7;int T,n,k,a[N],ans;signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n>>k;\t\tans=1;\t\tint maxn=0,sum=0;\t\tfor(int i=1;i<=n;i++){\t\t\tcin>>a[i];\t\t\tmaxn=max(maxn,a[i]);\t\t\tsum+=a[i];\t\t}\t\tfor(int i=1;i<=n;i++){\t\t\t//每堆为i\t\t\tint minn=max(maxn*i,(sum+i-1)/i*i);\t\t\tif(minn<=sum+k)\t\t\t\tans=max(ans,i); \t\t}\t\tcout<<ans<<\"\\n\";\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Cards Partition.json",
    "hint": []
}