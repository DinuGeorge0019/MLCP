{
    "link": "https://codeforces.com//contest/980/problem/D",
    "problemId": "181717",
    "problem_idx": "D",
    "shortId": "980D",
    "contest_number": "980",
    "problem_submissions": {
        "E": [
            38038539,
            38045785,
            38060701,
            38046614,
            38041883,
            38044896,
            38156095,
            38156078,
            38156061,
            38156040,
            38072066,
            38047353,
            38038047,
            38043388,
            38111608,
            38111590,
            38045284,
            38042270,
            38038266,
            38035504,
            38040125,
            38049313,
            38049169,
            38042734,
            38048647,
            38040602,
            38042070,
            38043155
        ],
        "D": [
            38033907,
            38032813,
            38038724,
            38038674,
            38041057,
            38038837,
            38034371,
            38046473,
            38049113,
            38037846,
            38051369,
            38051240,
            38044218,
            38039452,
            38054307,
            38079043,
            38079024,
            38043863,
            38813838
        ],
        "C": [
            38031306,
            38038468,
            38034397,
            38032152,
            38033603,
            38033400,
            38059857,
            38035211,
            38035303,
            38033154,
            38031809,
            38032840,
            38031754,
            38036211,
            38036608,
            38032601,
            38035163,
            38031869,
            38035397,
            38029282
        ],
        "B": [
            38028530,
            38048301,
            38030919,
            38029470,
            38030897,
            38030105,
            38029818,
            38031146,
            38060661,
            38028845,
            38030045,
            38037463,
            38028546,
            38038973,
            38029430,
            38050585,
            38032687,
            38031932
        ],
        "A": [
            38024341,
            38025152,
            38027637,
            38026879,
            38024463,
            38025009,
            38024567,
            38024355,
            38024220,
            38024988,
            38024959,
            38024227,
            38024460,
            38024685,
            38024924,
            38024456,
            38024718,
            38025274,
            38024545
        ],
        "F": [
            138375213
        ]
    },
    "name": "D. Perfect Groups",
    "statement": "SaMer has written the greatest test case of all time for one of his\r\nproblems. For a given array of integers, the problem asks to find the\r\nminimum number of groups the array can be divided into, such that the\r\nproduct of any pair of integers in the same group is a perfect square.\r\nEach integer must be in exactly one group. However, integers in a group\r\ndo not necessarily have to be contiguous in the array.SaMer wishes to\r\ncreate more cases from the test case he already has. His test case has\r\nan array A of n integers, and he needs to find the number of contiguous\r\nsubarrays of A that have an answer to the problem equal to k for each\r\ninteger k between 1 and n (inclusive).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 5e3 + 5;\nint n;\nint a[maxn];\nint g[maxn];\n\nvoid phongthan() {\n    cin >> n;\n    vi dc;\n    FOR(i, 0, n) {\n        cin >> a[i];\n        for (int j = 2; j * j <= abs(a[i]); j++) if (a[i] % (j * j) == 0) {\n            while (a[i] % (j * j) == 0) a[i] /= j * j;\n        }\n        dc.pb(a[i]);\n    }\n    sort(all(dc)), uni(dc);\n    FOR(i, 0, n) a[i] = lower_bound(all(dc), a[i]) - dc.begin();\n    FOR(i, 0, n) {\n        static int f[maxn];\n        int num = 0;\n        fill_n(f, maxn, 0);\n        FOR(j, i, n) {\n            if (dc[a[j]]) {\n                if (!f[a[j]]) {\n                    num++;\n                }\n                f[a[j]]++;\n            }\n            g[max(1, num)]++;\n        }\n    }\n    FOR(i, 1, n + 1) cout << g[i] << \" \\n\"[i == n];\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    phongthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Perfect Groups.json",
    "editorial_link": "https://codeforces.com//blog/entry/59350",
    "editorial": "First let us examine perfect squares; a perfect square is a number that\r\ncan be written as the product of an integer and itself . This means that\r\nfor each prime factor of the number , the frequency of that factor must\r\nbe even so it can be distributed evenly between each of the two \u00e2\u0080\u0099s.This\r\nleads to the idea that for every two numbers and in a group, for a prime\r\nfactor , either both and have an even frequency of , or they both have\r\nan odd frequency of it.So using that observation, for each number in the\r\narray we can discard all pairs of equal prime factors (keeping one copy\r\nof each factor with an odd frequency).For example, number has factors ,\r\nso we can just ignore the first pair of because they\u00e2\u0080\u0099re redundant and\r\ntransform it into , which is the number .Now after replacing each number\r\nwith the product of its odd factors, we can just count the number of\r\ndistinct elements in each subarray as each element can be only grouped\r\nwith its copies. This can be done by checking all possible subarrays and\r\nkeeping a frequency array to count the number of distinct elements in\r\nit.- Elements need to be mapped to non-negative integers between and so\r\nwe don\u00e2\u0080\u0099t use a set to count them.- Need to be careful in case there\u00e2\u0080\u0099s a\r\nzero in the subarray. Zeros can join any group, so unless the subarray\r\ncontains only zeros, we can ignore them.Solution Complexity:\r\n"
}