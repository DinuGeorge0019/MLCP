{
    "link": "https://codeforces.com//contest/1277/problem/F",
    "problemId": "495586",
    "problem_idx": "F",
    "shortId": "1277F",
    "contest_number": "1277",
    "problem_submissions": {
        "F": [
            66866628,
            66860664,
            66862829,
            66860439,
            66977841,
            66899469,
            66863808,
            92979782,
            92978994,
            92978960,
            92978865,
            66891528,
            66889235,
            66866269,
            67019482
        ],
        "D": [
            66856749,
            66864218,
            66854207,
            66847715,
            66844420,
            66847306,
            66854098,
            66848610,
            66848065,
            66848280,
            66844474,
            66849217,
            66848886,
            66864076,
            66847735
        ],
        "E": [
            66850123,
            66849554,
            66847076,
            66854313,
            66848191,
            66853241,
            66855295,
            66853466,
            66848425,
            66855580,
            66855848,
            66853292,
            66856132,
            92977693,
            66856983,
            66854785,
            125051093,
            66850783,
            66861075
        ],
        "C": [
            66841382,
            66842457,
            66841119,
            66845741,
            66837706,
            66839907,
            66838468,
            66840457,
            66839782,
            66840815,
            66841610,
            66843424,
            66846378,
            66837428,
            66844848,
            66841436,
            66840246,
            66839763
        ],
        "B": [
            66837718,
            66838330,
            66834438,
            66842100,
            66834455,
            66836147,
            66833752,
            66836537,
            66835874,
            66836673,
            66837137,
            66837196,
            66974853,
            66841617,
            66834535,
            66838161,
            66835795,
            66834507,
            66836405
        ],
        "A": [
            66834598,
            66836237,
            66833655,
            66838372,
            66833757,
            66834211,
            66833507,
            66833800,
            66834296,
            66834715,
            66834270,
            66834723,
            66974834,
            66839401,
            66833706,
            66836909,
            66833653,
            66833594,
            66833715
        ]
    },
    "name": "F. Beautiful Rectangle",
    "statement": "You are given n integers. You need to choose a subset and put the chosen\r\nnumbers in a beautiful rectangle (rectangular matrix). Each chosen\r\nnumber should occupy one of its rectangle cells, each cell must be\r\nfilled with exactly one chosen number. Some of the n numbers may not be\r\nchosen.A rectangle (rectangular matrix) is called beautiful if in each\r\nrow and in each column all values are different.What is the largest (by\r\nthe total number of cells) beautiful rectangle you can construct? Print\r\nthe rectangle itself.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  int n;\n  cin>>n;\n  map<ll,ll> mp;\n  rep(i,n){\n    ll a;\n    cin>>a;\n    if(mp.count(a) == 0){\n      mp[a] = 0;\n    }\n    mp[a]++;\n  }\n  vector<pair<ll,ll>> nums;\n  for(auto itr = mp.begin(); itr != mp.end(); itr++){\n    nums.push_back({itr->second, itr->first});\n  }\n  sort(all(nums));\n  int ni = 0;\n  ll ans = 0, ans_h=-1;\n  ll sum = 0;\n  for(ll h=1; h<sqrt(n)+10; h++){\n    while(ni < nums.size() && nums[ni].first < h){\n      sum += nums[ni].first;\n      ni++;\n    }\n    ll col = (sum + (nums.size()-ni)*h)/h;\n    //cout<<h<<\" \"<<col<<endl;\n    if(col < h) continue;\n    if(ans < h*col){\n      ans = h*col;\n      ans_h = h;\n    }\n  }\n\n  reverse(all(nums));\n  vector<vector<ll>> ANS;\n  rep(i,ans_h){\n    ANS.push_back(vector<ll>());\n    rep(j,ans/ans_h){\n      ANS[i].push_back(0);\n    }\n  }\n  rep(i,nums.size()){\n    if(nums[i].first > ans_h){\n      nums[i].first = ans_h;\n    }\n  }\n\n  ni = 0;\n  rep(j,ans/ans_h){\n    rep(i,ans_h){\n      ANS[i][j] = nums[ni].second;\n      nums[ni].first--;\n      if(nums[ni].first == 0) ni++;\n    }\n  }\n  \n  cout<<ans<<endl;\n  cout<<ans_h<<\" \"<<ans/ans_h<<endl;\n  rep(i,ans_h){\n    rep(j,ans/ans_h){\n      cout<<ANS[i][(j-i+ans/ans_h)%(ans/ans_h)]<<\" \";\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Beautiful Rectangle.json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "First, let's formulate the criteria that from the given set of numbers x1,x2,,xk\n we can create a beautiful rectangle a×b\n (where a?b=k,a?b\n). Obviously, if some number occurs more than a\n times, then among a\n rows there will be such row that will contain two or more occurrences of the number (pigeonhole principle).\n\nLet's prove that if all numbers in x[1k]\n occur no more than a\n times, we can create a beautiful rectangle a×b\n (where a?b=k,a?b\n).\n\nWe will numerate cells from the upper left corner in the order from one, moving diagonally each time. Assume rows are numerated from 0\n to a?1\n and columns are numerated from 0\n to b?1\n. Let's begin from the cell (0,0\n) and move right-down each time. If we face to a border, we will move cyclically. Thus, from the cell (i,j\n) we will move to the cell ((i+1)moda,(j+1)modb)\n each time (where pmodq\n is the remainder when divided p\n by q\n). If we are going to move to a visited cell, before moving let's assign i:=(i+1)moda\n.\n\nExample of the numeration for rectangles 3×3\n and 4×6\n.\nWe can also prove that while such numeration each row and each column contain numbers that differ by no less than a?1\n (if we are on a row/column, we will make a turn before we will be on the row/column again). Moreover, the difference reaches a?1\n (not a\n) when we move to the previously visited cell and assign i:=(i+1)moda\n. So, we can prove that the lengths of such orbits are equal lcm(a,b)\n (lcm\n is a least common multiple). Consequently, they are divided by a\n. It means that if we will arrange the numbers from x\n in the order from the most common (at worst case those that meet a\n times) to the least common, each row and each column will always contain different numbers.\n\nThus, we have a plan of the solution: find optimal a\n and b\n so that the answer is the largest rectangle a×b\n (a?b\n). For this we will iterate over all possible candidates in a\n and for each candidate each number v\n from x\n we will use it no more than min(cv,a)\n times where cv\n is a number of occurrences v\n in the given sequence. So, if we choose a\n, the upper bound of a rectangle area is ?min(cv,a)\n for all possible different numbers v\n from the given sequence. Consequently, the maximal value of b\n is ?min(cv,a)/a\n. And let's update the answer if for current iteration a?b\n is larger than previously found answer (still consider that a?b\n).\n\nWe can maintain the value ?min(cv,a)\n while a\n is incremented by one. For doing this we should each time add geq[a]\n to this value, where geq[a]\n is a number of different numbers in the given sequence, which occurs at least a\n times (we can precalculate this array).",
    "hint": []
}