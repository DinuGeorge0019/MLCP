{"link": "https://codeforces.com//contest/1159/problem/E", "problemId": "343496", "problem_idx": "E", "shortId": "1159E", "contest_number": "1159", "problem_submissions": {"F": [54044898, 54053832, 54040772, 54080509, 54040513, 54052332, 54089294], "E": [54043384, 54040516, 54045368, 54044519, 54046071, 54039628, 54039102, 54040677, 54042415, 54058636, 54048968, 54034868, 54042017, 54050776], "D": [54042721, 54041943, 54035580, 54042572, 54080606, 54038146, 54052354, 54091059, 54040030, 54037911, 54039545, 54040731, 54042578], "B": [54036094, 54030149, 54029931, 54034799, 54032077, 54030372, 54032226, 54030581, 54037312, 54032827, 54030507, 54030402, 54031286, 54036701, 54030641, 54031474, 54030960, 54031607], "C": [54036012, 54033415, 54031953, 54037681, 54035770, 54032952, 54035496, 54033625, 54035290, 54036048, 54033635, 54032111, 54035844, 54040001, 54036873, 54037164, 54036330, 54033726], "A": [54032465, 54028777, 54028614, 54031427, 54028774, 54028660, 54029725, 54028649, 54036064, 54028741, 54029512, 54028702, 54028642, 54035314, 54028987, 54028902, 54028641, 54029509]}, "name": "E. Permutation recovery", "statement": "Vasya has written some permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n, so for all 1\r\nleq i\r\nleq n it is true that 1\r\nleq p_i\r\nleq n and all p_1, p_2,\r\nldots, p_n are different. After that he wrote n numbers next_1, next_2,\r\nldots, next_n. The number next_i is equal to the minimal index i < j\r\nleq n, such that p_j > p_i. If there is no such j let\u2019s let\u2019s define as\r\nnext_i = n + 1.In the evening Vasya went home from school and due to\r\nrain, his notebook got wet. Now it is impossible to read some written\r\nnumbers. Permutation and some values next_i are completely lost! If for\r\nsome i the value next_i is lost, let\u2019s say that next_i = -1.You are\r\ngiven numbers next_1, next_2,\r\nldots, next_n (maybe some of them are equal to -1). Help Vasya to find\r\nsuch permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n, that he can write it to the notebook\r\nand all numbers next_i, which are not equal to -1, will be correct.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 550000;\n\nint nxt[N], que[N], val[N];\nvector<int> prv[N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint tcase; cin >> tcase;\n\twhile (tcase--) {\n\t\tint n; cin >> n;\n\t\tfor (int i = 1; i <= n; i++) cin >> nxt[i];\n\t\tfor (int i = 0; i <= n + 1; i++) prv[i].clear();\n\t\tset<int> S;\n\t\tS.insert(n + 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (nxt[i] != -1) S.insert(nxt[i]);\n\t\t\telse nxt[i] = *S.upper_bound(i);\n\t\t\tprv[nxt[i]].push_back(i);\n\t\t}\n\t\tS.clear();\n\t\tint good = 1;\n\t\tS.insert(n + 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (S.size() && *S.lower_bound(i) == i) S.erase(i);\n\t\t\tif (S.size() && nxt[i] > *S.begin()) {\n\t\t\t\tgood = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tS.insert(nxt[i]);\n\t\t}\n\t\tif (!good) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint hd = 0, tl = 0;\n\t\tque[tl++] = n + 1;\n\t\twhile (hd < tl) {\n\t\t\tint cur = que[hd++];\n\t\t\tfor (auto it : prv[cur]) que[tl++] = it;\n\t\t}\n\t\tint id = n + 1;\n\t\tfor (int i = 0; i < tl; i++) val[que[i]] = id--;\n\t\tfor (int i = 1; i <= n; i++) cout << val[i] << \" \\n\"[i == n];\n\t}\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "math"], "dificulty": "2100", "interactive": false}