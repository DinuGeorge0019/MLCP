{
    "link": "https://codeforces.com//contest/1159/problem/E",
    "problemId": "343496",
    "problem_idx": "E",
    "shortId": "1159E",
    "contest_number": "1159",
    "problem_submissions": {
        "F": [
            54044898,
            54053832,
            54040772,
            54080509,
            54040513,
            54052332,
            54089294
        ],
        "E": [
            54043384,
            54040516,
            54045368,
            54044519,
            54046071,
            54039628,
            54039102,
            54040677,
            54042415,
            54058636,
            54048968,
            54034868,
            54042017,
            54050776
        ],
        "D": [
            54042721,
            54041943,
            54035580,
            54042572,
            54080606,
            54038146,
            54052354,
            54091059,
            54040030,
            54037911,
            54039545,
            54040731,
            54042578
        ],
        "B": [
            54036094,
            54030149,
            54029931,
            54034799,
            54032077,
            54030372,
            54032226,
            54030581,
            54037312,
            54032827,
            54030507,
            54030402,
            54031286,
            54036701,
            54030641,
            54031474,
            54030960,
            54031607
        ],
        "C": [
            54036012,
            54033415,
            54031953,
            54037681,
            54035770,
            54032952,
            54035496,
            54033625,
            54035290,
            54036048,
            54033635,
            54032111,
            54035844,
            54040001,
            54036873,
            54037164,
            54036330,
            54033726
        ],
        "A": [
            54032465,
            54028777,
            54028614,
            54031427,
            54028774,
            54028660,
            54029725,
            54028649,
            54036064,
            54028741,
            54029512,
            54028702,
            54028642,
            54035314,
            54028987,
            54028902,
            54028641,
            54029509
        ]
    },
    "name": "E. Permutation recovery",
    "statement": "Vasya has written some permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n, so for all 1\r\nleq i\r\nleq n it is true that 1\r\nleq p_i\r\nleq n and all p_1, p_2,\r\nldots, p_n are different. After that he wrote n numbers next_1, next_2,\r\nldots, next_n. The number next_i is equal to the minimal index i < j\r\nleq n, such that p_j > p_i. If there is no such j let\u2019s let\u2019s define as\r\nnext_i = n + 1.In the evening Vasya went home from school and due to\r\nrain, his notebook got wet. Now it is impossible to read some written\r\nnumbers. Permutation and some values next_i are completely lost! If for\r\nsome i the value next_i is lost, let\u2019s say that next_i = -1.You are\r\ngiven numbers next_1, next_2,\r\nldots, next_n (maybe some of them are equal to -1). Help Vasya to find\r\nsuch permutation p_1, p_2,\r\nldots, p_n of integers from 1 to n, that he can write it to the notebook\r\nand all numbers next_i, which are not equal to -1, will be correct.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 550000;\n\nint nxt[N], que[N], val[N];\nvector<int> prv[N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint tcase; cin >> tcase;\n\twhile (tcase--) {\n\t\tint n; cin >> n;\n\t\tfor (int i = 1; i <= n; i++) cin >> nxt[i];\n\t\tfor (int i = 0; i <= n + 1; i++) prv[i].clear();\n\t\tset<int> S;\n\t\tS.insert(n + 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (nxt[i] != -1) S.insert(nxt[i]);\n\t\t\telse nxt[i] = *S.upper_bound(i);\n\t\t\tprv[nxt[i]].push_back(i);\n\t\t}\n\t\tS.clear();\n\t\tint good = 1;\n\t\tS.insert(n + 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (S.size() && *S.lower_bound(i) == i) S.erase(i);\n\t\t\tif (S.size() && nxt[i] > *S.begin()) {\n\t\t\t\tgood = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tS.insert(nxt[i]);\n\t\t}\n\t\tif (!good) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint hd = 0, tl = 0;\n\t\tque[tl++] = n + 1;\n\t\twhile (hd < tl) {\n\t\t\tint cur = que[hd++];\n\t\t\tfor (auto it : prv[cur]) que[tl++] = it;\n\t\t}\n\t\tint id = n + 1;\n\t\tfor (int i = 0; i < tl; i++) val[que[i]] = id--;\n\t\tfor (int i = 1; i <= n; i++) cout << val[i] << \" \\n\"[i == n];\n\t}\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Permutation recovery.json",
    "editorial_link": "https://codeforces.com/blog/entry/66993?locale=en",
    "editorial": "Note that if there are indices for which the values and are defined and\r\nare satisfied, then there is no answer. Suppose that this is not true\r\nand there exists permutation . Note that since we get that (otherwise\r\nwould not be the minimum position in which the number is greater than ).\r\nBut then , so is not the minimum position for . Contradiction.Now we\r\nprove that if for any pair of indices such condition is not satisfied,\r\nthen the permutation always exists.First, let\u00e2\u0080\u0099s get rid of . If let\u00e2\u0080\u0099s\r\nsay . Note that for any pair the condition is still not satisfied (since\r\ncannot take part in such inequality).Consider the following rooted tree\r\nwith vertices: the vertex with index will be the root, and the ancestor\r\nof the vertex with index will be . Since it is always we get the rooted\r\ntree. Let\u00e2\u0080\u0099s run the depth first search algorithm () from the vertex in\r\nthis tree. In this case, we will bypass the sons of each vertex in order\r\nfrom the smaller number to the larger one. Let\u00e2\u0080\u0099s make some global\r\nvariable . Each time we come to the vertex , we will make and reduce by\r\n. Note that will form a permutation of numbers from to .We prove that\r\nthis permutation is the answer.First of all, for all due to was the\r\nancestor of , we\u00e2\u0080\u0099ll go there early and so . Let . We need to prove that\r\nwe will come to the vertex later than to the vertex . Note that then the\r\nvertex will be a descendant of in the tree, because if you start go from\r\nby , you cannot jump over , because otherwise there is an index , for\r\nwhich the inequality is satisfied. But such pair of indexes , cannot\r\nexist. We\u00e2\u0080\u0099ll get to later because the son of , which is the ancestor of\r\nwill be , and thus . That is, we understood what is the criterion of the\r\nanswer and learned how to quickly build an answer, if this criterion is\r\nsatisfied. But we still need to check that this criterion is satisfied.\r\nThis can be done by some simple linear algorithm. But we will do this:\r\nlet\u00e2\u0080\u0099s make an algorithm for constructing the answer (without checking\r\nthe criterion) and find the permutation . Now, using the stack and the\r\nstandard algorithm, we find the values for it. If they match the given ,\r\nthen we have found the answer, otherwise, let\u00e2\u0080\u0099s say that there is no\r\nanswer. If the criterion is satisfied we will find the answer and if not\r\nsatisfied after checking we will say there are no answers.Complexity:\r\ntime and memory.\r\n"
}