{
    "link": "https://codeforces.com//contest/1471/problem/A",
    "problemId": "855308",
    "problem_idx": "A",
    "shortId": "1471A",
    "contest_number": "1471",
    "problem_submissions": {
        "E": [
            103450052,
            103527230,
            103525401,
            103598525
        ],
        "F": [
            103434846,
            103427866,
            103439415,
            103444744,
            103449013,
            103443306,
            103451232,
            103449545,
            103450844,
            103457122,
            103444374,
            103429431,
            103453099,
            103450549,
            103452495,
            103451463,
            103455883,
            103458926,
            103459110,
            103458706
        ],
        "D": [
            103430457,
            103433587,
            103415562,
            103429984,
            103422346,
            103434860,
            103464447,
            103432755,
            103438270,
            103433203,
            103429688,
            103431896,
            103454609,
            103429555,
            103432993,
            103431363,
            103439051,
            103433971,
            103434798,
            103443976,
            103435625
        ],
        "C": [
            103407997,
            103401931,
            103402977,
            103409572,
            103406225,
            103408555,
            103406435,
            103414503,
            103418347,
            103405513,
            103405296,
            103416304,
            103408620,
            103413240,
            103409443,
            103419306,
            103414842,
            103414451,
            103407384,
            103412728
        ],
        "B": [
            103396816,
            103402555,
            103399513,
            103402026,
            103401651,
            103404250,
            103396796,
            103402859,
            103407240,
            103400401,
            103398000,
            103404884,
            103399937,
            103406757,
            103403051,
            103411496,
            103400880,
            103401862,
            103399435,
            103395040
        ],
        "A": [
            103391504,
            103392070,
            103391475,
            103392431,
            103397645,
            103392332,
            103392672,
            103392165,
            103392211,
            103391494,
            103393909,
            103392635,
            103393542,
            103391831,
            103396953,
            103391758,
            103391661,
            103393211,
            103391536
        ]
    },
    "name": "A. Strange Partition",
    "statement": "You are given an array a of length n, and an integer x. You can perform\r\nthe following operation as many times as you would like (possibly zero):\r\nreplace two adjacent elements of the array by their sum. For example, if\r\nthe initial array was [3, 6, 9], in a single operation one can replace\r\nthe last two elements by their sum, yielding an array [3, 15], or\r\nreplace the first two elements to get an array [9, 9]. Note that the\r\nsize of the array decreases after each operation.The of an array b=[b_1,\r\nldots, b_k] is defined as\r\nsum_{i=1}^k\r\nleft\r\nlceil\r\nfrac{b_i}{x}\r\nright\r\nrceil, which means that we divide each element by x, round it up to the\r\nnearest integer, and sum up the resulting values. For example, if x = 3,\r\nand the array is [4, 11, 6], the beauty of the array is equal to\r\nleft\r\nlceil\r\nfrac{4}{3}\r\nright\r\nrceil +\r\nleft\r\nlceil\r\nfrac{11}{3}\r\nright\r\nrceil +\r\nleft\r\nlceil\r\nfrac{6}{3}\r\nright\r\nrceil = 2 + 4 + 2 = 8.Please determine the minimum and the maximum\r\nbeauty you can get by performing some operations on the original array.\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\nint main() {\n  int T=read();\n  while(T--){\n    int n=read(),k=read();\n    ll ans1=0,ans2=0;\n    rep(i,1,n){\n      int x=read();\n      ans1+=(x+k-1)/k;\n      ans2+=x;\n    }\n    ans2=(ans2+k-1)/k;\n    printf(\"%lld %lld\\n\",ans2,ans1);\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Strange Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "Note that, . It means that the maximal sum is attained if we do not\r\napply any operations, and the minimal one is attained if we replace all\r\nthe element with a single one, equal to the sum of all elements.\r\n",
    "hint": []
}