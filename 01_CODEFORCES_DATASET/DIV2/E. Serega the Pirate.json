{
    "link": "https://codeforces.com//contest/1700/problem/E",
    "problemId": "1433686",
    "problem_idx": "E",
    "shortId": "1700E",
    "contest_number": "1700",
    "problem_submissions": {
        "F": [
            161204184,
            161175037,
            161206125,
            161212939,
            161208920,
            161208613,
            161221499,
            161209546
        ],
        "E": [
            161198687,
            161196286,
            161355967,
            161718414,
            161625123,
            161210058,
            161186427,
            161205675,
            161211460,
            161212251,
            161209815,
            161226432,
            161215179,
            161212687,
            161209759,
            161208133,
            161212427
        ],
        "D": [
            161181899,
            161187142,
            161172748,
            161191235,
            161182477,
            161193166,
            161184771,
            161194388,
            161383056,
            161196489,
            161188119,
            161188891,
            161183798,
            161190373,
            161201766,
            161189358,
            161191653,
            161196390,
            161376237,
            161189700,
            161191427
        ],
        "C": [
            161179311,
            161183541,
            161180380,
            161184212,
            161718390,
            161184885,
            161181511,
            161178526,
            161188654,
            161193034,
            161183225,
            161183002,
            161175389,
            161193124,
            161191878,
            161177816,
            161183179,
            161187003,
            161183522,
            161177845
        ],
        "B": [
            161174411,
            161180612,
            161180415,
            161180363,
            161174680,
            161179087,
            161174700,
            161180026,
            161190959,
            161175925,
            161173974,
            161173339,
            161174147,
            161181560,
            161181382,
            161172925,
            161174110
        ],
        "A": [
            161167944,
            161176736,
            161168168,
            161168440,
            161176515,
            161168925,
            161168213,
            161168654,
            161187609,
            161168766,
            161168663,
            161168483,
            161168047,
            161169513,
            161168007,
            161168296,
            161173279,
            161168814,
            161167994
        ]
    },
    "name": "E. Serega the Pirate",
    "statement": "Little pirate Serega robbed a ship with puzzles of different kinds.\r\nAmong all kinds, he liked only one, the hardest.A puzzle is a table of n\r\nrows and m columns, whose cells contain each number from 1 to n\r\ncdot m exactly once.To solve a puzzle, you have to find a sequence of\r\ncells in the table, such that any two consecutive cells are adjacent by\r\nthe side in the table. The sequence can have arbitrary length and should\r\nvisit each cell one or more times. For a cell containing the number i,\r\ndenote the position of the first occurrence of this cell in the sequence\r\nas t_i. The sequence solves the puzzle, if t_1 < t_2 <\r\ndots < t_{nm}. In other words, the cell with number x should be first\r\nvisited before the cell with number x + 1 for each x.Let\u2019s call a puzzle\r\nsolvable, if there exists at least one suitable sequence.In one move\r\nSerega can choose two arbitrary cells in the table (not necessarily\r\nadjacent by the side) and swap their numbers. He would like to know the\r\nminimum number of moves to make his puzzle solvable, but he is too\r\nimpatient. Thus, please tell if the minimum number of moves is 0, 1, or\r\nat least 2. In the case, where 1 move is required, please also find the\r\nnumber of suitable cell pairs to swap.\r\n",
    "solutions": [
        "/*\n\n_/      _/       _/_/_/      _/      _/    _/           _/_/_/_/_/\n _/    _/      _/      _/     _/    _/     _/           _/\n  _/  _/      _/               _/  _/      _/           _/\n   _/_/       _/                 _/        _/           _/_/_/_/\n  _/  _/      _/                 _/        _/           _/\n _/    _/      _/      _/        _/        _/           _/\n_/      _/       _/_/_/          _/        _/_/_/_/_/   _/_/_/_/_/\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\n#define maxn 400005\nusing namespace std;\ninline int read()\n{\n\tint x = 0, w = 0; char ch = getchar();\n\twhile(!isdigit(ch)) {w |= ch == '-'; ch = getchar();}\n\twhile(isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\treturn w ? -x : x;\n}\nint n, m;\nvector<int> a[maxn];\nint nx[5] = {-1, 1, 0, 0, 0}, ny[5] = {0, 0, -1, 1, 0};\nstruct node\n{\n\tint x, y;\n};\nvector<node> pos;\ninline int check(int x, int y)\n{\n\tif(a[x][y] == n * m + 1 || a[x][y] == 1) return 1;\n\treturn a[x - 1][y] < a[x][y] || a[x + 1][y] < a[x][y] || a[x][y - 1] < a[x][y] || a[x][y + 1] < a[x][y];\n}\ninline ll H(int a1, int b1, int a2, int b2)\n{\n\treturn (ll)(a1 * m + b1) * (n * m) + (a2 * m + b2);\n}\nunordered_map<ll, int> vis;\nint work(int a1, int b1, int a2, int b2)\n{\n\tif(a[a1][b1] == n * m + 1 || a[a2][b2] == n * m + 1) return 0;\n\tif(vis[H(a1, b1, a2, b2)]) return 0;\n\tif(vis[H(a2, b2, a1, b1)]) return 0;\n\tvis[H(a1, b1, a2, b2)] = 1;\n\tswap(a[a1][b1], a[a2][b2]);\n\tru(i, 0, 4) if(!check(a1 + nx[i], b1 + ny[i])) {swap(a[a1][b1], a[a2][b2]); return 0;}\n\tru(i, 0, 4) if(!check(a2 + nx[i], b2 + ny[i]))  {swap(a[a1][b1], a[a2][b2]); return 0;}\n\tfor (auto v: pos) if(!check(v.x, v.y))  {swap(a[a1][b1], a[a2][b2]); return 0;}\n\tswap(a[a1][b1], a[a2][b2]);\n\treturn 1;\n}\nint main()\n{\n\tn = read(), m = read();\n\tru(i, 0, n + 1) a[i].resize(m + 2, n * m + 1);\n\tru(i, 1, n) ru(j, 1, m) a[i][j] = read(); \n\tru(i, 1, n)\n\t{\n\t\tru(j, 1, m)\n\t\t{\n\t\t\tif(!check(i, j)) pos.push_back({i, j});\n\t\t}\n\t}\n\tif(pos.empty()) {printf(\"0\\n\"); return 0;}\n\tif(pos.size() > 6) {printf(\"2\\n\"); return 0;} \n\tint ans = 0;\n\tru(k, 0, 4) ru(i, 1, n) ru(j, 1, m) ans += work(i, j, pos[0].x + nx[k], pos[0].y + ny[k]);\n\tif(ans) {printf(\"1 %d\\n\", ans); return 0;}\n\tprintf(\"2\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Serega the Pirate.json",
    "editorial_link": "https://codeforces.com//blog/entry/103978",
    "editorial": "We need to find a simple criteria of a solvable puzzle. It can be shown\r\nthat for every cell, except cell with value , it should have a neighbour\r\nwith a smaller value. Indeed, if the puzzle is solvable, a cell going\r\nbefore the first occurence of our cell always has the smaller value.\r\nConversely, if each cell has a smaller neighbor, one can list cells one\r\nat a time, and there will always be a path to the next cell along\r\nalready visited cells with lower numbers.Let\u00e2\u0080\u0099s call a cell bad, if it\u00e2\u0080\u0099s\r\nvalue is not and it doesn\u00e2\u0080\u0099t have a neighbour with a smaller value.\r\nConsider any bad cell. Let\u00e2\u0080\u0099s notice, that the pair that we swap should\r\ncontain either the bad cell itself, or its neighbour, otherwise that bad\r\ncell will stay bad. That way we have pairs of candidates, for each of\r\nwhich we\u00e2\u0080\u0099ll run a check if the resulting puzzle is solvable.Now we\u00e2\u0080\u0099ll\r\nlearn how to quickly understand, if the puzzle became solvable after a\r\nswap. For this we\u00e2\u0080\u0099ll keep the amount of bad cells. After the swap, the\r\nstate can be changed only for these cells and their neighbours. Let\u00e2\u0080\u0099s\r\nrecalc the amount of bad cells and check if it\u00e2\u0080\u0099s zero.The resulting\r\ncomplexity is\r\n"
}