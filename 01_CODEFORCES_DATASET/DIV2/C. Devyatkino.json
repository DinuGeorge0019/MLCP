{
    "link": "https://codeforces.com//contest/2067/problem/C",
    "problemId": "3199297",
    "problem_idx": "C",
    "shortId": "2067C",
    "contest_number": "2067",
    "problem_submissions": {
        "F": [
            305685907,
            305692347,
            305698935,
            305692774,
            305676497,
            305698856,
            306077498,
            305705678,
            305756151,
            305704889
        ],
        "E": [
            305658599,
            305672236,
            305683533,
            305683773,
            305656801,
            305645614,
            305696470,
            305667416,
            305664383,
            305673487,
            305670822,
            305677487,
            305670853,
            305673781,
            305671527,
            305669540,
            305677992,
            305669569
        ],
        "D": [
            305649366,
            305681166,
            305653626,
            305674453,
            305643643,
            305729660,
            305688166,
            305650701,
            305653886,
            305650207,
            305654910,
            305651908,
            305655288,
            305746455,
            305655141,
            305660113,
            305659896,
            305656329,
            305714910,
            305658443
        ],
        "C": [
            305636369,
            305648878,
            305666557,
            305665235,
            305625887,
            305647363,
            305654112,
            305631231,
            305632643,
            305629967,
            305634943,
            305636497,
            305638128,
            305637135,
            305643511,
            305643488,
            305640674,
            305635570
        ],
        "B": [
            305619994,
            305628659,
            305625583,
            305654171,
            305618751,
            305619632,
            305656230,
            305622837,
            305619493,
            305623632,
            305626730,
            305624964,
            305625007,
            305622467,
            305622926,
            305630860,
            305620471,
            305624035
        ],
        "A": [
            305614513,
            305615491,
            305614195,
            305613169,
            305612940,
            305612785,
            305651426,
            305615731,
            305613408,
            305616051,
            305615564,
            305614161,
            305613236,
            305614353,
            305613295,
            305614069,
            305612838,
            305613240
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139415?locale=en",
    "editorial": "The first idea: the answer does not exceed , since we can add and keep\r\ntrack of the last digit; with each addition, it will decrease by (going\r\nfrom to ), so after additions, the last digit will complete a full cycle\r\nand will be exactly once during the process.The second idea: it is quite\r\ndifficult to briefly answer how adding a number like will affect the\r\ndigits of an arbitrary number. However, there is an arithmetically\r\nsimilar operation, adding a number of the form , which affects the\r\ndigits in a much more predictable way. It would be nice if we could add\r\npowers of ten in the operation instead of .The combination of these two\r\nideas solves the problem.Let’s iterate through the possible values of\r\nthe answer. For each from to , we want to determine: is it possible to\r\nadd exactly numbers made up of nines to produce a digit ? One operation\r\nis adding a number of the form . Since we know we will perform exactly\r\noperations, we can view this process as adding powers of ten to the\r\nnumber .Adding a power of ten increases one of the digits of the number\r\nby (including leading zeros). It may also replace some s with s, which\r\neffectively is also an increase of the digit by , modulo . Therefore, it\r\nis not difficult to understand that the minimum number of additions of\r\npowers of ten needed to introduce a digit into the number is across all\r\ndigits from the number, including leading zeros.In summary, we need to\r\niterate from to and compare with (where is any digit from the number ,\r\nincluding leading zeros), and output the minimum suitable .From\r\ninteresting facts: during the solution process, it becomes clear that\r\nthe answer is , since can always be . However, this is only true under\r\nthe constraints , as in the solution we implicitly rely on the fact that\r\nthe number does not go negative! For and , the answer is actually\r\n.Additionally, the solution presented above serves as a proof of another\r\nsolution that one could believe with sufficient intuition. Let’s say\r\nthat in the optimal answer we add the same number, meaning we never mix\r\nadding and . Believing this, we can iterate through the number being\r\nadded and keep adding it until we encounter the digit . We then take the\r\nminimum of all options for the answer.\r\n",
    "name": "C. Devyatkino",
    "statement": "You are given a positive integer n. In one operation, you can add to n\r\nany positive integer whose decimal representation contains only the\r\ndigit 9, possibly repeated several times.What is the minimum number of\r\noperations needed to make the number n contain at least one digit 7 in\r\nits decimal representation?For example, if n = 80, it is sufficient to\r\nperform one operation: you can add 99 to n, after the operation n = 179,\r\nwhich contains the digit 7.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "greedy",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Devyatkino.json",
    "hint": []
}