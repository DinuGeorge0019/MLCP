{"link": "https://codeforces.com//contest/322/problem/D", "problemId": "3271", "problem_idx": "D", "shortId": "322D", "contest_number": "322", "problem_submissions": {"A": [3981623, 3973095, 3973865, 3973090, 3972819, 3972791, 3973637, 3972934, 3972906, 3972918, 3973641, 3972985, 3973091, 3972935, 3972929, 3973182, 3972893], "B": [3981333, 3975842, 3976873, 3974714, 3975747, 3973669, 3974548, 3974146, 3977509, 3974324, 3974761, 3974551, 3974557, 3976086, 3974559, 3974642], "C": [3980891, 3983597, 3976039, 3978515, 3978858, 3978735, 3977369, 3982226, 3976048, 3983804, 3979009, 3978590, 3980069, 3985116, 3977870, 3978375, 3975800], "D": [3978233, 3979300, 3979714, 3982078, 3981365, 3983063, 3981155, 3982692, 3980839, 3983851, 3983012, 3984085, 3984750, 3982466], "E": [3976453, 3981756, 3983016, 3990331, 3980078]}, "name": "D. Ciel and Duel", "statement": "Fox Ciel is playing a card game with her friend Jiro.Jiro has cards,\r\neach one has two attributes: (Attack or Defense) and . Fox Ciel has\r\ncards, each one has these two attributes too. It\u2019s known that position\r\nof all Ciel\u2019s cards is Attack.Now is Ciel\u2019s battle phase, Ciel can do\r\nthe following operation many times: Choose one of her cards . This card\r\nmustn\u2019t be chosen before. If Jiro has no alive cards at that moment, he\r\ngets the damage equal to (\u2019s strength). Otherwise, Ciel needs to choose\r\none Jiro\u2019s alive card , then: If \u2019s position is Attack, then (\u2019s\r\nstrength) (\u2019s strength) must hold. After this attack, card dies, and\r\nJiro gets the damage equal to (\u2019s strength) - (\u2019s strength). If \u2019s\r\nposition is Defense, then (\u2019s strength) (\u2019s strength) must hold. After\r\nthis attack, card dies, but Jiro gets no damage. Ciel can end her battle\r\nphase at any moment (so, she can use not all her cards). Help the Fox to\r\ncalculate the maximal sum of damage Jiro can get.\r\n", "solutions": ["#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\n#define inf 1023456789\n#define linf 1023456789123456789ll\n#define pii pair<int,int>\n#define pipii pair<int, pii >\n#define pll pair<long long,long long>\n#define vint vector<int>\n#define vvint vector<vector<int> >\n\n#define DEBUG\n#ifdef DEBUG\n#define db(x) cerr << #x << \" = \" << x << endl\n#else\n#define db(x)\n#endif\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tvint att, def, my(m);\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tchar a,b,c;\n\t\tint s;\n\t\tscanf(\" %c%c%c %d\",&a,&b,&c,&s);\n\t\tif(a == 'A')att.push_back(s);\n\t\telse def.push_back(s);\n\t}\n\tfor(int i=0; i<m; i++)\n\t{\n\t\tscanf(\"%d\",&my[i]);\n\t}\n\tsort(att.begin(),att.end());\n\tsort(def.begin(), def.end());\n\tsort(my.begin(), my.end());\n\tint res = 0;\n\t\n\tvint used(m,0);\n\tint pres = 0;\n\tint cm = 0;\n\tfor(int i=0; i<def.size(); i++)\n\t{\n\t\twhile(my[cm] <= def[i] || used[cm])\n\t\t{\n\t\t\tcm++;\n\t\t\tif(cm >= m)\n\t\t\t{\n\t\t\t\tpres = -inf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(cm < m)\n\t\t{\n\t\t\tused[cm] = 1;\n\t\t}\n\t\telse break;\n\t}\n\tif(pres > -inf)\n\t{\n\t\tcm = 0;\n\t\tfor(int i=0; i<att.size(); i++)\n\t\t{\n\t\t\twhile(my[cm] < att[i] || used[cm])\n\t\t\t{\n\t\t\t\tcm++;\n\t\t\t\tif(cm >= m)\n\t\t\t\t{\n\t\t\t\t\tpres = -inf;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cm < m)\n\t\t\t{\n\t\t\t\tused[cm] = 1;\n\t\t\t\tpres += my[cm] - att[i];\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tif(pres > -inf)\n\t{\n\t\tfor(int i=0; i<m; i++)if(!used[i])pres += my[i];\n\t}\n\t\n\tres = max(res,pres);\n\t\n\tfor(int i=1; i<=min(m,(int)(att.size())); i++)\n\t{\n\t\tint suc = 0;\n\t\tfor(int j=0; j<i; j++)\n\t\t{\n\t\t\tif(my[m-i+j] >= att[j])\n\t\t\t{\n\t\t\t\tsuc+= my[m-i+j] - att[j];\n\t\t\t}\n\t\t\telse suc = -inf;\n\t\t}\n\t\tres = max(res,suc);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dp", "flows", "greedy", "two pointers"], "dificulty": "1900", "interactive": false}