{
    "link": "https://codeforces.com//contest/1304/problem/D",
    "problemId": "540880",
    "problem_idx": "D",
    "shortId": "1304D",
    "contest_number": "1304",
    "problem_submissions": {
        "F2": [
            71153662,
            71152758,
            71152225,
            71157272,
            71159942,
            71160337,
            71152268,
            71164565,
            71154293,
            71154692,
            71162717,
            71159530,
            71162560,
            71166676,
            71162579,
            71158531,
            71165317,
            71164377,
            71163973
        ],
        "F1": [
            71153447,
            71152867,
            71152180,
            71151661,
            71153091,
            71154085,
            71149583,
            71154537,
            71154276,
            71154806,
            71156318,
            71151191,
            71154828,
            71149041,
            71160757,
            71162740,
            71158430,
            71158819,
            71164218,
            71159683
        ],
        "A": [
            71141804,
            71123780,
            71124247,
            71124384,
            71123709,
            71123734,
            71133014,
            71123605,
            71123682,
            71125835,
            71124122,
            71125469,
            71123778,
            71125797,
            71123883,
            71124957,
            71124272,
            71124584,
            71125887
        ],
        "B": [
            71141077,
            71127745,
            71130904,
            71129813,
            71129002,
            71129323,
            71131933,
            71128951,
            71128799,
            71129490,
            71131971,
            71130601,
            71128231,
            71131633,
            71131054,
            71131655,
            71131218,
            71131770,
            71130665
        ],
        "C": [
            71139292,
            71131382,
            71132670,
            71132117,
            71132267,
            71132849,
            71127878,
            71132933,
            71133726,
            71136633,
            71134870,
            71133707,
            71131661,
            71135936,
            71133295,
            71134276,
            71135200,
            71134880,
            71134692
        ],
        "D": [
            71135174,
            71139070,
            71140467,
            71140425,
            71138874,
            71140258,
            71140794,
            71137521,
            71136980,
            71141949,
            71140004,
            71141241,
            71141696,
            71140892,
            71143691,
            71147524,
            71140481,
            71142776,
            71142040
        ],
        "E": [
            71129417,
            71143322,
            71144172,
            71144650,
            71144907,
            71145653,
            71155565,
            71142523,
            71145871,
            71145649,
            71146288,
            71152807,
            71148538,
            71135583,
            71146697,
            71149801,
            71151693,
            71149896,
            71147231,
            71153923
        ]
    },
    "name": "D. Shortest and Longest LIS",
    "statement": "Gildong recently learned how to find the longest increasing subsequence\r\n(LIS) in O(n\r\nlog{n}) time for a sequence of length n. He wants to test himself if he\r\ncan implement it correctly, but he couldn\u2019t find any online judges that\r\nwould do it (even though there are actually many of them). So instead\r\nhe\u2019s going to make a quiz for you about making permutations of n\r\ndistinct integers between 1 and n, inclusive, to test his code with your\r\noutput.The quiz is as follows.Gildong provides a string of length n-1,\r\nconsisting of characters \u201d and \u201d only. The i-th (1-indexed) character is\r\nthe comparison result between the i-th element and the i+1-st element of\r\nthe sequence. If the i-th character of the string is \u201d, then the i-th\r\nelement of the sequence is less than the i+1-st element. If the i-th\r\ncharacter of the string is \u201d, then the i-th element of the sequence is\r\ngreater than the i+1-st element.He wants you to find two possible\r\nsequences (not necessarily distinct) consisting of n distinct integers\r\nbetween 1 and n, inclusive, each satisfying the comparison results,\r\nwhere the length of the LIS of the first sequence is minimum possible,\r\nand the length of the LIS of the second sequence is maximum possible.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint T , x , L; char str[2000003];\n\nint main(){\n\tfor(scanf(\"%d\" , &T); T ; --T){\n\t\tscanf(\"%d %s\" , &L , str + 1); int p = 1 , now = L;\n\t\twhile(p <= L){\n\t\t\tint p1 = p; while(p1 < L && str[p1] == '<') ++p1;\n\t\t\tfor(int i = L - p1 + 1 ; i <= L - p + 1 ; ++i) printf(\"%d \" , i);\n\t\t\tnow -= p1 - p + 1; p = p1 + 1;\n\t\t}\n\t\tputchar('\\n'); p = 1;\n\t\twhile(p <= L){\n\t\t\tint p1 = p; while(p1 < L && str[p1] == '>') ++p1;\n\t\t\tfor(int i = p1 ; i >= p ; --i) printf(\"%d \" , i);\n\t\t\tp = p1 + 1;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Shortest and Longest LIS.json",
    "editorial_link": "https://codeforces.com//blog/entry/73934",
    "editorial": "There are various strategies to solve each part. I\u00e2\u0080\u0099ll explain one of\r\nthem for each. It would be fun to come up with your own strategy as well\r\n:)Let\u00e2\u0080\u0099s group each contiguously part. We can easily see that we cannot\r\nmake the LIS shorter than the maximum size among these groups. It can be\r\nshown that we can make the length of the LIS not longer than that as\r\nwell.One strategy is to fill the largest unused numbers in increasing\r\norder for each group from left to right. There will be no indices and ()\r\nsuch that < where and are in different groups. Therefore the maximum\r\nsize among the groups will be the length of the LIS.Let\u00e2\u0080\u0099s group each\r\ncontiguously part. We can easily see that there can be at most one\r\nelement from each group that is included in any possible LIS. It can be\r\nshown that we can make a sequence that takes one element from every\r\ngroups to form the LIS.One strategy is to fill the smallest unused\r\nnumbers in decreasing order for each group from left to right. Then for\r\nevery indices and () where and are in different groups, will be always\r\ngreater than . Thus, we can take any one element from each and every\r\ngroups to form the LIS.Time complexity: for each test case.Here\u00e2\u0080\u0099s a\r\nlittle challenge for people who want harder things: Can you make a\r\nsequence that has the length of its LIS exactly ?\r\n"
}