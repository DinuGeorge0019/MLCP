{
    "link": "https://codeforces.com//contest/2063/problem/F1",
    "problemId": "3154907",
    "problem_idx": "F1",
    "shortId": "2063F1",
    "contest_number": "2063",
    "problem_submissions": {
        "F2": [
            302425610,
            302451940,
            302442929,
            302441504,
            302438014,
            302448830,
            302447651,
            302449239,
            302451441,
            302441520,
            302449441,
            302462040,
            302527079
        ],
        "C": [
            302417331,
            302388966,
            302380666,
            302386796,
            302391515,
            302388488,
            302384390,
            302383854,
            302392461,
            302390039,
            302389493,
            302385787,
            302379767,
            302392628,
            302382228,
            302388334,
            302383676,
            302394839,
            302388632,
            302391072
        ],
        "D": [
            302412152,
            302402949,
            302396428,
            302402633,
            302409161,
            302404535,
            302411549,
            302409325,
            302409501,
            302412675,
            302403620,
            302420625,
            302411254,
            302422339,
            302414704,
            302406132,
            302417532,
            302411171,
            302418058,
            302418384
        ],
        "E": [
            302404720,
            302395352,
            302418668,
            302414791,
            302422680,
            302426848,
            302421742,
            302427528,
            302428407,
            302458083,
            302451720,
            302434097,
            302422758,
            302403323,
            302431883,
            302433354,
            302432981,
            302436125,
            302427678,
            302431985
        ],
        "F1": [
            302388355,
            302424887,
            302442481,
            302433761,
            302438421,
            302445686,
            302447198,
            302443757,
            302450796,
            302427723,
            302449982,
            302451319,
            302436505,
            302455100,
            302448501,
            302454721,
            302454623,
            302448067,
            302454995,
            302448498
        ],
        "B": [
            302385897,
            302389386,
            302371425,
            302391237,
            302379321,
            302378690,
            302373741,
            302377026,
            302378459,
            302385735,
            302370221,
            302376737,
            302372000,
            302386149,
            302374530,
            302374437,
            302376025,
            302383492,
            302381557,
            302378496
        ],
        "A": [
            302374954,
            302366962,
            302363313,
            302365021,
            302366134,
            302366042,
            302365897,
            302366966,
            302363934,
            302362493,
            302362600,
            302366245,
            302365093,
            302367784,
            302363061,
            302365428,
            302365621,
            302368569,
            302369401,
            302377605
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138593",
    "editorial": "To solve the easy subtask, you can derive some helpful properties from\r\nthe usual stack-based algorithm to determine whether a bracket sequence\r\nis balanced. Note the following well-known fact. : The good pairs are\r\nexactly the pairs of brackets that are popped \"together\" in the\r\nstack-based algorithm. Considering this, we can observe these two facts.\r\nThe subsequence inside the good pair must be balanced, or otherwise the\r\ntwo brackets would not be popped together. The subsequence outside the\r\ngood pair must be balanced, or otherwise the entire string won’t be\r\nbalanced. Then, given good pairs, you will find \"minimal subsequences\"\r\nthat you know are balanced, defined by this information. (In fact, it is\r\nmore correct to define \"minimal balanced subsequences\" to include the\r\ngood pairs themselves, but in the easy subtask we ignore this to get an\r\neasier explanation by sacrificing details.)In fact, these minimal\r\nbalanced subsequences are just the subsequences found by the following\r\nmodification to the stack-based algorithm: In the usual stack-based\r\nalgorithm, instead of pushing only brackets into the stack, push\r\neverything on the way into the stack. When you pop a closing bracket,\r\npop everything until you find an opening bracket. Then, the popped\r\nsubsequences, and the subsequence outside the outermost good pairs, are\r\nminimal balanced subsequences. It is known that there are different\r\nbalanced bracket sequences of length , where is the -th Catalan number.\r\nSo for each of the minimal balanced subsequences, you can multiply to\r\nthe answer, given that the minimal balanced subsequence has length .\r\nThis is the answer we needed to know.Therefore, you can simply update\r\nthe string and re-run the stack-based algorithm everytime. Each run of\r\nthe stack-based algorithm takes time, so the problem is solved in time\r\ncomplexity. For the easy subtask, the Catalan numbers can be\r\npreprocessed in time, and it was not necessary to use the combinatorial\r\ndefinition. However, if you compute Catalan numbers on the fly instead\r\nof preprocessing, or construct a tree explicitly, the time limit may be\r\na little tight for you as the solution will have an extra log factor. Do\r\nkeep this in mind when you implement the solution.\r\n",
    "name": "F1. Counting Is Not Fun  Easy Version ",
    "statement": "A bracket sequence is called if it can be constructed by the following\r\nformal grammar. The empty sequence\r\nvarnothing is balanced. If the bracket sequence A is balanced, then\r\nmathtt{(}A\r\nmathtt{)} is also balanced. If the bracket sequences A and B are\r\nbalanced, then the concatenated sequence A B is also balanced. For\r\nexample, the sequences \"\", \"\", \"\", and the empty sequence are balanced,\r\nwhile \"\" and \"\" are not.Given a balanced bracket sequence s, a pair of\r\nindices (i,j) (i<j) is called a if s_i is ”, s_j is ”, and the two\r\nbrackets are added simultaneously with respect to Rule 2 while\r\nconstructing the sequence s. For example, the sequence \"\" has three\r\ndifferent good pairs, which are (1,4), (2,3), and (5,6). One can show\r\nthat any balanced bracket sequence of 2n brackets contains exactly n\r\ndifferent good pairs, and using any order of rules to construct the same\r\nbracket sequence will yield the same set of good pairs.Emily will play a\r\nbracket guessing game with John. The game is played as\r\nfollows.Initially, John has a balanced bracket sequence s containing n\r\ndifferent good pairs, which is not known to Emily. John tells Emily the\r\nvalue of n and asks Emily to guess the sequence.Throughout n turns, John\r\ngives Emily the following kind of clue on each turn. l\r\n;r: The sequence s contains a good pair (l,r). The clues that John gives\r\nEmily are pairwise distinct and do not contradict each other.At a\r\ncertain point, Emily can be certain that the balanced bracket sequence\r\nsatisfying the clues given so far is unique. For example, assume Emily\r\nknows that s has 3 good pairs, and it contains the good pair (2,5). Out\r\nof 5 balanced bracket sequences with 3 good pairs, there exists only one\r\nsuch sequence \"\" with the good pair (2,5). Therefore, one can see that\r\nEmily does not always need n turns to guess s.To find out the content of\r\ns as early as possible, Emily wants to know the number of different\r\nbalanced bracket sequences that match the clues after each turn. Surely,\r\nthis is not an easy job for Emily, especially when she is given so many\r\ngood pairs. Now it is your turn to help Emily. Given the clues, you must\r\nfind the answer before and after each turn. As the answers may be huge,\r\nyou need to find them modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "bool M1;#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<\" MB\\n\"#define look_time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\\n'#include <cstdio>#include <cmath>#include <iomanip>#include <iostream>#include <cstring>#include <array>#include <algorithm>#include <queue>#include <vector>#include <bitset>#include <ctime>#include <cstdlib>#include <random>#include <set>#include <ctime>#include <map>#include <stack>#include <unordered_map>#include <assert.h>#include <unordered_set>#define i128 __int128#define ll long long#define uint unsigned#define ull unsigned long long#define ld long double#define fo(a,b,c) for(ll a=b;a<=c;++a)#define re(a,b,c) for(ll a=b;a>=c;--a)#define pii pair<ll,ll>#define pdd pair<db,db>#define fi first#define pb push_back#define se second#define ite set<array<ll,3>> ::iterator#define vite vector<ll> ::iterator#define mite map<ll,ll> ::iteratorusing namespace std;const ll mod=998244353;inline ll gi(){\tll x = 0, f = 1;\tchar ch = getchar();\twhile(ch < '0' || ch > '9')\t{\t\tif (ch == '-')\t\t\tf = -1;\t\tch = getchar();\t}\twhile(ch >= '0' && ch <= '9')\t{\t\tx = (x<<1) + (x<<3) + (ch^48);\t\tch = getchar();\t}\treturn x * f;}ll _=1;const ll inf=2e17+5,iinf=1e9+5;const ll N=500005;ll ksm(ll a,ll b){\tll c=1;\twhile(b)\t{\t\tif(b&1) c=c*a%mod;\t\ta=a*a%mod;\t\tb/=2;\t}\treturn c;}ll fac[N],ifac[N],cat[N];ll C(ll a,ll b){\treturn fac[a]*ifac[b]%mod*ifac[a-b]%mod;}void init(ll n){\tfac[0]=1;\tfo(i,1,n) fac[i]=fac[i-1]*i%mod;\tifac[n]=ksm(fac[n],mod-2);\tre(i,n-1,0) ifac[i]=ifac[i+1]*(i+1)%mod;}ll vis[N];ll stk[N],top;void sol(){\tll n=gi();\tfo(i,1,n*2) vis[i]=0;\tinit(n*2);\tcat[0]=1;\tfo(i,1,n) cat[i]=(C(2*i,i)-C(2*i,i-1)+mod)%mod;\tcout<<cat[n]<<\" \";\tfo(o,1,n)\t{\t\tll x=gi(),y=gi();\t\tvis[x]++;\t\tvis[y]--;\t\tll ans=1,num=0;\t\ttop=0;\t\tfo(i,1,n*2)\t\t{\t\t\tif(vis[i]==1)\t\t\t{\t\t\t\ttop++;\t\t\t\tstk[top]=num;\t\t\t\tnum=1;\t\t\t\tcontinue;\t\t\t}\t\t\tif(vis[i]==-1)\t\t\t{\t\t\t\tnum++;\t\t\t\tans=ans*cat[(num-2)/2]%mod;\t\t\t\tnum=stk[top];\t\t\t\ttop--;\t\t\t\tcontinue;\t\t\t}\t\t\tnum++;\t\t}\t\tans=ans*cat[num/2]%mod;\t\tcout<<ans<<\" \";\t}}bool M2;int main(){\tint Time=clock();\tlook_memory;\t_=gi();\twhile(_--)\t{\t\tsol();\t\tprintf(\"\\n\");\t}\tlook_time;\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Counting Is Not Fun  Easy Version .json",
    "hint": [
        "Hint The subproblem where you find the number of different balanced bracket sequences of length is already well-known. Now recall everyone's favorite data structure to solve problems related to balanced bracket sequences — the stack !"
    ]
}