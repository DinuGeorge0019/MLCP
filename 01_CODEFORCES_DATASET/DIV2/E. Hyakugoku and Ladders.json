{
    "link": "https://codeforces.com//contest/1245/problem/E",
    "problemId": "456078",
    "problem_idx": "E",
    "shortId": "1245E",
    "contest_number": "1245",
    "problem_submissions": {
        "F": [
            64010477,
            64009886,
            64014319,
            64150819,
            64002324,
            64004647,
            64015739,
            64002490,
            64015888,
            64014383,
            64013493,
            64015031,
            64011720,
            64026953,
            64021476,
            64018260,
            64031462,
            64031970,
            64021775,
            64023172
        ],
        "E": [
            64006910,
            64015295,
            64016337,
            64021964,
            64020329,
            64023633,
            64021101,
            64021058,
            64022796,
            64020913,
            64022965,
            64022978,
            64020972,
            64029225,
            64026181,
            64018441,
            64017598,
            64027038,
            64029618
        ],
        "D": [
            64002898,
            64003958,
            64002526,
            64016634,
            64013877,
            64004966,
            64016399,
            64011069,
            64010801,
            64007938,
            64006781,
            64015310,
            64008535,
            64005186,
            64010692,
            64009342,
            64009799,
            64014521,
            64014195
        ],
        "C": [
            63999164,
            64000498,
            64005851,
            64003393,
            64010042,
            64000573,
            64010656,
            64003837,
            64005015,
            63999349,
            64002111,
            63996519,
            64003084,
            64000048,
            64002428,
            64002402,
            63999517,
            64005913,
            64002319
        ],
        "B": [
            63997617,
            63998088,
            64001465,
            63998805,
            64003870,
            63998306,
            64008480,
            64001186,
            63999749,
            64027106,
            64016776,
            64027202,
            64000627,
            64000016,
            64005778,
            63999988,
            64002993,
            63999540,
            63999182
        ],
        "A": [
            63995951,
            63995957,
            63997656,
            63996018,
            63998793,
            63996004,
            64003787,
            63998279,
            63996658,
            64024063,
            63995955,
            63998248,
            63997191,
            63996609,
            63995990,
            63996228,
            63999456,
            63996540,
            63996316
        ]
    },
    "name": "E. Hyakugoku and Ladders",
    "statement": "Hyakugoku has just retired from being the resident deity of the South\r\nBlack Snail Temple in order to pursue her dream of becoming a\r\ncartoonist. She spent six months in that temple just playing \"Cat\u2019s\r\nCradle\" so now she wants to try a different game \"Snakes and Ladders\".\r\nUnfortunately, she already killed all the snakes, so there are only\r\nladders left now. The game is played on a 10\r\ntimes 10 board as follows: At the beginning of the game, the player is\r\nat the bottom left square. The objective of the game is for the player\r\nto reach the Goal (the top left square) by following the path and\r\nclimbing vertical ladders. Once the player reaches the Goal, the game\r\nends. The path is as follows: if a square is not the end of its row, it\r\nleads to the square next to it along the direction of its row; if a\r\nsquare is the end of its row, it leads to the square above it. The\r\ndirection of a row is determined as follows: the direction of the bottom\r\nrow is to the right; the direction of any other row is opposite the\r\ndirection of the row below it. See Notes section for visualization of\r\npath. During each turn, the player rolls a standard six-sided dice.\r\nSuppose that the number shown on the dice is r. If the Goal is less than\r\nr squares away on the path, the player doesn\u2019t move (but the turn is\r\nperformed). Otherwise, the player advances exactly r squares along the\r\npath and then stops. If the player stops on a square with the bottom of\r\na ladder, the player that ladder. If she chooses not to climb, then she\r\nstays in that square for the beginning of the next turn. Some squares\r\nhave a ladder in them. Ladders are only placed vertically each one leads\r\nto the same square of some of the upper rows. In order for the player to\r\nclimb up a ladder, after rolling the dice, she must stop at the square\r\ncontaining the bottom of the ladder. After using the ladder, the player\r\nwill end up in the square containing the top of the ladder. She cannot\r\nleave the ladder in the middle of climbing. And if the square containing\r\nthe top of the ladder also contains the bottom of another ladder, she is\r\nnot allowed to use that second ladder. The numbers on the faces of the\r\ndice are 1, 2, 3, 4, 5, and 6, with each number having the same\r\nprobability of being shown. Please note that: it is possible for ladders\r\nto overlap, but the player cannot switch to the other ladder while in\r\nthe middle of climbing the first one; it is possible for ladders to go\r\nstraight to the top row, but not any higher; it is possible for two\r\nladders to lead to the same tile; it is possible for a ladder to lead to\r\na tile that also has a ladder, but the player will not be able to use\r\nthat second ladder if she uses the first one; the player can only climb\r\nup ladders, not climb down. Hyakugoku wants to finish the game as soon\r\nas possible. Thus, on each turn she chooses whether to climb the ladder\r\nor not optimally. Help her to determine the minimum expected number of\r\nturns the game will take.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint p2i(int x, int y)\n{\n    if(x%2 == 0) return x*10+y;\n    return x*10+9-y;\n}\nint arr[10][10];\nint flatten[100];\ndouble dp[100];\nint main()\n{\n    for(int i=0; i<10; ++i)\n        for(int j=0; j<10; ++j)\n        {\n            scanf(\"%d\", &arr[i][j]);\n            int c = p2i(i, j);\n            flatten[c] = -1;\n            if(arr[i][j])\n            {\n                int ni = i-arr[i][j];\n                int nj = j;\n                flatten[c] = p2i(ni, nj);\n            }\n        }\n    dp[0] = 0;\n    for(int i=1; i<100; ++i)\n    {\n        double ans = 0;\n        int pass = 0;\n        for(int j=1; j<=6; ++j)\n        {\n            if(j>i)\n            {\n                ++pass; continue;\n            }\n            int dest = i-j;\n            double cost = dp[dest];\n            \n            if(flatten[dest] != -1)\n                cost = min(cost, dp[flatten[dest]]);\n            ans += cost;\n        }\n        dp[i] = (ans+6)/(6-pass);\n    }\n    printf(\"%.12f\\n\", dp[99]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hyakugoku and Ladders.json",
    "editorial_link": "https://codeforces.com/blog/entry/71080",
    "editorial": "To make implementation easier, flatten the board into an array such that\r\nthe -th tile on the path is . Define a function as follows: if has no\r\nladder, otherwise where is such that the ladder from leads to . Then, do\r\ndp.Define to be the minimum expected number of turns before the game\r\nends when the player is at . Then, since is the Goal. Next, use the\r\nformula where if and otherwise. Thus, for , transition should be . And\r\nfor , transition is the same as the formula. Answer is .Alternatively,\r\ninstead of doing dp, we can use numerical methods. Initialize and .\r\nThen, repeat the following several times: from to , assign to . After\r\neach iteration, will get closer to the answer. For this problem, 1000\r\niterations is more than enough to get AC using this method.\r\n"
}