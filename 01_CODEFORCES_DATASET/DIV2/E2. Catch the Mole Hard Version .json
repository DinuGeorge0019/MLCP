{
    "link": "https://codeforces.com//contest/1990/problem/E2",
    "problemId": "2766781",
    "problem_idx": "E2",
    "shortId": "1990E2",
    "contest_number": "1990",
    "problem_submissions": {
        "E2": [
            271608671,
            271607138,
            271614388,
            271623848,
            271611159,
            271612390,
            271624654,
            271606284,
            271618767,
            271968367,
            271632009,
            271670295,
            271670041,
            271669953,
            271631571,
            271628300,
            271628735,
            271594502,
            271625522,
            271630429,
            271657508,
            271657312,
            271656848,
            271656620,
            271656329,
            271656057,
            271655884,
            271651026,
            271650811,
            271629403,
            271633667
        ],
        "E1": [
            271608290,
            271606824,
            271613580,
            271620803,
            271612480,
            271607245,
            271626074,
            271605565,
            271618674,
            271617329,
            271631880,
            271630922,
            271628223,
            271626847,
            271593184,
            271625989,
            271629147,
            271621610,
            271633499
        ],
        "D": [
            271584964,
            271585839,
            271588228,
            271580018,
            271775642,
            271574070,
            271621395,
            271597835,
            276025328,
            271618139,
            271579386,
            271580161,
            271592306,
            271593113,
            271583094,
            271588957,
            271599530,
            271586840,
            271606900,
            271582390,
            271597556,
            271601916
        ],
        "C": [
            271573202,
            271574801,
            271573394,
            271562726,
            271563640,
            271558919,
            271563245,
            276025316,
            271572711,
            271573247,
            271567920,
            271567517,
            271556748,
            271561905,
            271578677,
            271614383,
            271580098,
            271585887,
            271628007,
            271582340,
            271582612
        ],
        "B": [
            271544838,
            271560423,
            271562782,
            271545814,
            271553448,
            271544083,
            271550614,
            271557693,
            271552078,
            271550946,
            271576591,
            271554451,
            271552855,
            271607828,
            271555492,
            271573754,
            271547063,
            271567926,
            271553335
        ],
        "A": [
            271536644,
            271538330,
            271540486,
            271536626,
            271537675,
            271536719,
            271540682,
            271537637,
            271536282,
            271542554,
            271544093,
            271538945,
            271539444,
            271610786,
            271544740,
            271545994,
            271537196,
            271539275,
            271540687
        ],
        "F": [
            271738112,
            271736701,
            271736437,
            271736279,
            271732364,
            271623141
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131716",
    "editorial": "hint1Consider querying a subtree. If the jury returns , we can delete\r\nthe entire subtree.\r\n",
    "name": "E2. Catch the Mole Hard Version ",
    "statement": "You are given a tree of n nodes with node 1 as its root node.There is a\r\nhidden mole in one of the nodes. To find its position, you can pick an\r\ninteger x (1\r\nle x\r\nle n) to make an inquiry to the jury. Next, the jury will return 1 when\r\nthe mole is in subtree x. Otherwise, the judge will return 0. If the\r\njudge returns 0 and the mole is not in root node 1, the mole will move\r\nto the parent node of the node it is currently on.Use at most 160\r\noperations to find the node where the mole is located.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0using ll = long long;// #define int ll\u00a0#define pb push_backusing pi = array<int, 2>;\u00a0const int S = 70;const int MAXQ = 160;\u00a0int queries_made_no = 0;bool ask(int u) {  cout << \"? \" << u << endl;  bool yes;  cin >> yes;  queries_made_no += !yes;  return yes;}void answer(int u) {  cout << \"! \" << u << endl;}\u00a0void skibidi_sigma() {  queries_made_no = 0;    int n;  cin >> n;    vector<vector<int>> adj(n + 1);  for (int i = 0; i < n - 1; ++i) {    int u, v;    cin >> u >> v;    adj[u].pb(v);    adj[v].pb(u);  }    int leaf = 0;  vector<int> max_depth(n + 1);  auto dfs = [&](auto &self, int u, int p) -> void {    if (u != 1 && (int)adj[u].size() == 1) {      leaf = u;    }        max_depth[u] = 1;    for (int v : adj[u]) {      if (v == p) {        continue;      }      self(self, v, u);      max_depth[u] = max(max_depth[u], max_depth[v] + 1);    }  };  dfs(dfs, 1, 0);    vector<int> path;  auto make_path = [&](auto &self, int u, int p) -> void {    path.pb(u);        vector<int> good;    for (int v : adj[u]) {      if (v == p) {        continue;      }            if (max_depth[v] >= S) {        good.pb(v);      }    }        if ((int)good.size() == 1) { // oops      self(self, good[0], u);      return;    }    for (int v : good) {      if (ask(v)) {        self(self, v, u);        break;      }    }  };  make_path(make_path, 1, 0);    if (ask(leaf)) {    answer(leaf);    return;  }  while (queries_made_no < S + 10) {    ask(leaf);  }    int k = path.size();  int st = 0, dr = k - 1;  while (st < dr) {    int mid = (st + dr + 1) / 2;        if (ask(path[mid])) {      st = mid;    } else {      dr = max(mid - 2, 0);      st = max(st - 1, 0);    }  }    answer(path[st]);}\u00a0int32_t main() {  int T;  cin >> T;    while (T--) {    skibidi_sigma();    cout << endl;  }}\u00a0/*\u00a0*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "interactive",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. Catch the Mole Hard Version .json"
}