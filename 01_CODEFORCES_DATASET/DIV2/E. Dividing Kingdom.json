{
    "link": "https://codeforces.com//contest/260/problem/E",
    "problemId": "2469",
    "problem_idx": "E",
    "shortId": "260E",
    "contest_number": "260",
    "problem_submissions": {
        "E": [
            2841488
        ],
        "B": [
            2838739,
            2837191,
            2837768,
            2838150,
            2837744,
            2838786,
            2837047,
            2839010,
            2837833,
            2838337,
            2844158,
            2838983,
            2837520,
            2838783,
            2837827,
            2837919,
            2837792
        ],
        "C": [
            2837179,
            2838563,
            2839071,
            2839576,
            2840298,
            2840963,
            2838247,
            2841633,
            2838738,
            2839728,
            2840997,
            2840780,
            2840234,
            2841680,
            2838985,
            2837535,
            2840027,
            2839622,
            2839935
        ],
        "A": [
            2836127,
            2836200,
            2836494,
            2836347,
            2836171,
            2836837,
            2836322,
            2836732,
            2836174,
            2844801,
            2836481,
            2836407,
            2837519,
            2836145,
            2836199,
            2840135,
            2836459,
            2836219
        ],
        "D": [
            2839564,
            2841151,
            2841269,
            2843347,
            2843581,
            2843906,
            2843880,
            2840859,
            2843218,
            2849694,
            2842890,
            2847485
        ]
    },
    "name": "E. Dividing Kingdom",
    "statement": "A country called Flatland is an infinite two-dimensional plane. Flatland\r\nhas cities, each of them is a point on the plane.Flatland is ruled by\r\nking Circle IV. Circle IV has 9 sons. He wants to give each of his sons\r\npart of Flatland to rule. For that, he wants to draw four straight\r\nlines, such that two of them are parallel to the axis, and two others\r\nare parallel to the axis. At that, no straight line can go through any\r\ncity. Thus, Flatland will be divided into 9 parts, and each son will be\r\ngiven exactly one of these parts. Circle IV thought a little, evaluated\r\nhis sons\u2019 obedience and decided that the -th son should get the part of\r\nFlatland that has exactly cities.Help Circle find such four straight\r\nlines that if we divide Flatland into 9 parts by these lines, the\r\nresulting parts can be given to the sons so that son number got the part\r\nof Flatland which contains cities.\r\n",
    "solutions": [
        "//program 260-E\n\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point\n{\n  int X,Y;\n};\n\nbool operator <(Point A,Point B)\n{\n  return (A.X==B.X)?(A.Y<B.Y):(A.X<B.X);\n}\n\nstruct Node\n{\n  int Left,Right,Count;\n  Node *Lc,*Rc;\n};\n\nint Get()\n{\n  char c;\n  while(c=getchar(),(c<'0'||c>'9')&&(c!='-'));\n  bool Flag=(c=='-');\n  if(Flag)\n    c=getchar();\n  int X=0;\n  while(c>='0'&&c<='9')\n    {\n      X=X*10+c-48;\n      c=getchar();\n    }\n  return Flag?-X:X;\n}\n\nconst int inf=1000000000;\n\nbool Used[9];\nint DataY[100000];\nint Data[9],S[9];\nPoint P[100000];\nNode *Tree[100001];\n\nNode *Build(int L,int R)\n{\n  Node *P=new Node;\n  P->Left=L;\n  P->Right=R;\n  P->Count=0;\n  if(L<R)\n    {\n      int Mid=(L+R)/2;\n      P->Lc=Build(L,Mid);\n      P->Rc=Build(Mid+1,R);\n    }\n  return P;\n}\n\nNode *Insert(Node *P,int X)\n{\n  Node *Q=new Node;\n  *Q=*P;\n  Q->Count++;\n  if(Q->Left<Q->Right)\n    {\n      int Mid=(Q->Left+Q->Right)/2;\n      if(X<=Mid)\n        Q->Lc=Insert(Q->Lc,X);\n      else\n        Q->Rc=Insert(Q->Rc,X);\n    }\n  return Q;\n}\n\nint Query(Node *L,Node *R,int K)\n{\n  if(L->Left==L->Right)\n    return L->Left;\n  int Left=R->Lc->Count-L->Lc->Count;\n  if(K<=Left)\n    return Query(L->Lc,R->Lc,K);\n  else\n    return Query(L->Rc,R->Rc,K-Left);\n}\n\nint GetKth(int LB,int UB,int K)\n{\n  return Query(Tree[LB],Tree[UB],K);\n}\n\nbool Check()\n{\n  int Left=S[0]+S[1]+S[2];\n  int Mid=Left+S[3]+S[4]+S[5];\n  int N=Mid+S[6]+S[7]+S[8];\n  if(P[Left-1].X==P[Left].X)\n    return false;\n  if(P[Mid-1].X==P[Mid].X)\n    return false;\n  int LB_0=-inf,UB_0=inf;\n  LB_0=max(LB_0,GetKth(0,Left,S[0]));\n  UB_0=min(UB_0,GetKth(0,Left,S[0]+1));\n  if(UB_0-LB_0<1)\n    return false;\n  LB_0=max(LB_0,GetKth(Left,Mid,S[3]));\n  UB_0=min(UB_0,GetKth(Left,Mid,S[3]+1));\n  if(UB_0-LB_0<1)\n    return false;\n  LB_0=max(LB_0,GetKth(Mid,N,S[6]));\n  UB_0=min(UB_0,GetKth(Mid,N,S[6]+1));\n  if(UB_0-LB_0<1)\n    return false;\n  int LB_1=-inf,UB_1=inf;\n  LB_1=max(LB_1,GetKth(0,Left,S[0]+S[1]));\n  UB_1=min(UB_1,GetKth(0,Left,S[0]+S[1]+1));\n  if(UB_1-LB_1<1)\n    return false;\n  LB_1=max(LB_1,GetKth(Left,Mid,S[3]+S[4]));\n  UB_1=min(UB_1,GetKth(Left,Mid,S[3]+S[4]+1));\n  if(UB_1-LB_1<1)\n    return false;\n  LB_1=max(LB_1,GetKth(Mid,N,S[6]+S[7]));\n  UB_1=min(UB_1,GetKth(Mid,N,S[6]+S[7]+1));\n  if(UB_1-LB_1<1)\n    return false;\n  printf(\"%0.6lf %0.6lf\\n\",(P[Left-1].X+P[Left].X)*0.5,(P[Mid-1].X+P[Mid].X)*0.5);\n  printf(\"%0.6lf %0.6lf\\n\",(DataY[LB_0]+DataY[UB_0])*0.5,(DataY[LB_1]+DataY[UB_1])*0.5);\n  return true;\n}\n\nbool DFS(int Depth)\n{\n  if(Depth==9)\n    return Check();\n  for(int i=0;i<9;i++)\n    if(!Used[i])\n      {\n        Used[i]=true;\n        S[Depth]=Data[i];\n        if(DFS(Depth+1))\n          return true;\n        Used[i]=false;\n      }\n  return false;\n}\n\nint main()\n{\n  int N=Get();\n  for(int i=0;i<N;i++)\n    {\n      P[i].X=Get();\n      P[i].Y=Get();\n    }\n  sort(P,P+N);\n  for(int i=0;i<N;i++)\n    DataY[i]=P[i].Y;\n  sort(DataY,DataY+N);\n  int Total=1;\n  for(int i=1;i<N;i++)\n    if(DataY[i-1]!=DataY[i])\n      DataY[Total++]=DataY[i];\n  for(int i=0;i<N;i++)\n    {\n      int Left=0,Right=Total-1;\n      while(Left<Right)\n        {\n          int Mid=(Left+Right)/2;\n          if(DataY[Mid]==P[i].Y)\n            Left=Right=Mid;\n          else if(DataY[Mid]<P[i].Y)\n            Left=Mid+1;\n          else\n            Right=Mid-1;\n        }\n      P[i].Y=Left;\n    }\n  Tree[0]=Build(0,Total-1);\n  for(int i=0;i<N;i++)\n    Tree[i+1]=Insert(Tree[i],P[i].Y);\n  for(int i=0;i<9;i++)\n    Data[i]=Get();\n  memset(Used,0,sizeof(Used));\n  if(!DFS(0))\n    printf(\"-1\\n\");\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Dividing Kingdom.json",
    "editorial_link": "https://codeforces.com//blog/entry/6263",
    "editorial": "Consider variants of location of integers on areas. When we consider\r\nsome location (some grid), we can easily find amount of cities to the\r\nleft of the left vertical line, to the right of the right vertical line,\r\nbelow the lower horizontal line and above the upper horizontal line. All\r\nthese numbers is sum of three values . We assume that the lines of the\r\nanswer are always in half-integer coordinates. Then, knowing the above\r\nnumbers, we can uniquely determine separately for and how to accommodate\r\nall the lines. It remains only to check that in all areas there is\r\ndesired number of points. For each of four zones (to the left of the\r\nleft vertical line, to the right of the right vertical line, below the\r\nlower horizontal line and above the upper horizontal line) separately\r\ncheck, that all three areas have correct number of cities. It can be\r\ndone offline using scan-line and segment-tree, which can find sum on\r\ninterval and change value in some point. You should put all queries in\r\nsome array, sort them and process from left to right. Note, when you\r\ncheck from areas for every variants of location, the last area (central)\r\ncould not be checked, it will be correct automatically.\r\n"
}