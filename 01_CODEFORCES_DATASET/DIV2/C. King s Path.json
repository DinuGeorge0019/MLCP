{
    "link": "https://codeforces.com//contest/242/problem/C",
    "problemId": "2149",
    "problem_idx": "C",
    "shortId": "242C",
    "contest_number": "242",
    "problem_submissions": {
        "D": [
            2537952,
            2537942,
            2539339,
            2539698,
            2539156,
            2539580,
            2537494,
            2542278,
            2538787,
            2539905,
            2536184,
            2537759,
            2542044,
            2538066,
            2564424
        ],
        "C": [
            2537373,
            2537268,
            2536519,
            2536785,
            2537810,
            2537116,
            2537792,
            2536568,
            2536898,
            2537580,
            2536958,
            2536262,
            2537263,
            2538218,
            2536235,
            2542015,
            2536779,
            2536389,
            2538664,
            2537599
        ],
        "B": [
            2536607,
            2534065,
            2534724,
            2534650,
            2534927,
            2535116,
            2534461,
            2535027,
            2534468,
            2533804,
            2535897,
            2534112,
            2534107,
            2535117,
            2534450,
            2534923,
            2542000,
            2534963,
            2534474,
            2534940,
            2535281
        ],
        "A": [
            2536206,
            2533805,
            2533960,
            2533930,
            2534212,
            2534073,
            2533868,
            2533943,
            2533896,
            2534746,
            2535180,
            2533808,
            2533814,
            2534432,
            2533857,
            2533887,
            2541991,
            2534152,
            2533996,
            2533848,
            2534557
        ],
        "E": [
            2535640,
            2536427,
            2538447,
            2538483,
            2538649,
            2538639,
            2537907,
            2539042,
            2537371,
            2537776,
            2539203,
            2536140,
            2538840,
            2538202,
            2564479,
            2541961,
            2541948,
            2542249,
            2542247,
            2542240,
            2539344,
            9226579,
            2538102,
            2538950
        ]
    },
    "name": "C. King s Path",
    "statement": "The black king is standing on a chess field consisting of rows and\r\ncolumns. We will consider the rows of the field numbered with integers\r\nfrom to from top to bottom. The columns are similarly numbered with\r\nintegers from to from left to right. We will denote a cell of the field\r\nthat is located in the -th row and -th column as .You know that some\r\nsquares of the given chess field are . All allowed cells of the chess\r\nfield are given as segments. Each segment is described by three integers\r\n, denoting that cells in columns from number to number inclusive in the\r\n-th row are allowed.Your task is to find the minimum number of moves the\r\nking needs to get from square to square , provided that he only moves\r\nalong the allowed cells. In other words, the king can be located only on\r\nallowed cells on his way.Let us remind you that a chess king can move to\r\nany of the neighboring cells in one move. Two cells of a chess field are\r\nconsidered neighboring if they share at least one point.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define A first\n#define B second\n#define MP make_pair\n\ntypedef pair<int, int> PII;\n\nset<PII> pool;\nmap<PII, int> f;\n\nconst int dx[8] = {1, 0, -1, 1, -1, 1, 0, -1},\n\t\t  dy[8] = {1, 1, 1, 0, 0, -1, -1, -1};\n\nint main() {\n\tPII st, ed; scanf(\"%d%d%d%d\", &st.A, &st.B, &ed.A, &ed.B);\n\tpool.insert(st); pool.insert(ed);\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint r, a, b; scanf(\"%d%d%d\", &r, &a, &b);\n\t\tfor (int j = a; j <= b; ++j)\n\t\t\tpool.insert(MP(r, j));\n\t}\n\n\tfor (set<PII>::iterator iter = pool.begin(); iter != pool.end(); ++iter) f[*iter] = -1;\n\tf[st] = 0;\n\tqueue<PII> q; while (!q.empty()) q.pop();\n\tq.push(st); f[st] = 0;\n\twhile (!q.empty()) {\n\t\tPII now = q.front(); q.pop();\n\n\t\tfor (int a = 0; a < 8; ++a) {\n\t\t\tint x = now.A + dx[a], y = now.B + dy[a];\n\t\t\tPII to = MP(x, y);\n\t\t\tif (f[to] == -1) {\n\t\t\t\tf[to] = f[now] + 1; q.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[ed]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "hashing",
        "shortest paths"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. King s Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/5837",
    "editorial": "The most important thing for accepted solution is that it is guaranteed\r\nthat the total length of all given segments doesnât exceed . We should\r\nuse this feature, letâs number allowed cells and found shortest path by\r\nBFS. Itâs easiest to use associative array such as map in C++ for\r\nnumbering. The time is .\r\n",
    "hint": []
}