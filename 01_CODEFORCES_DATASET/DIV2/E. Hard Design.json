{
    "link": "https://codeforces.com//contest/1884/problem/E",
    "problemId": "2278163",
    "problem_idx": "E",
    "shortId": "1884E",
    "contest_number": "1884",
    "problem_submissions": {
        "E": [
            229182998,
            232047287,
            229184537,
            229188100,
            229407530,
            229406745,
            229186340,
            229191046,
            229193161
        ],
        "D": [
            229158633,
            232074380,
            229168220,
            229164508,
            229173176,
            229157255,
            229153443,
            229155494,
            229159386,
            229160353,
            229156733,
            229156643,
            229161617,
            229157357,
            229162436,
            229158936,
            229165915,
            229162999,
            229162965,
            229163918,
            229164809
        ],
        "C": [
            229155589,
            229160960,
            229166024,
            229166680,
            229154105,
            229157494,
            229160291,
            229153826,
            229157399,
            229163211,
            229163270,
            229157632,
            229164398,
            229157764,
            229156973,
            229156300,
            229158818,
            229157218,
            229159145,
            229159718
        ],
        "B": [
            229151946,
            229151614,
            229152037,
            229164652,
            229149397,
            229159327,
            229149698,
            229150790,
            229150442,
            229150480,
            229151756,
            229152335,
            229149090,
            229150117,
            229151229,
            229150183,
            229155852,
            229153843,
            229154670,
            229153764
        ],
        "A": [
            229147132,
            229147400,
            229147746,
            229153787,
            229147017,
            229146825,
            229146890,
            229146981,
            229146866,
            229148682,
            229147191,
            229148012,
            229146920,
            229147887,
            229146935,
            229147042,
            229146861,
            229146944,
            229147243,
            229148319
        ]
    },
    "name": "E. Hard Design",
    "statement": "Consider an array of integers b_0, b_1,\r\nldots, b_{n-1}. Your goal is to make all its elements equal. To do so,\r\nyou can perform the following operation several (possibly, zero) times:\r\nPick a pair of indices 0\r\nle l\r\nle r\r\nle n-1, then for each l\r\nle i\r\nle r increase b_i by 1 (i. e. replace b_i with b_i + 1). After\r\nperforming this operation you receive (r - l + 1)^2 coins. The value\r\nf(b) is defined as a pair of integers (cnt, cost), where cnt is the\r\nnumber of operations required to make all elements of the array equal,\r\nand cost is the total number of coins you can receive among all possible\r\nways to make all elements equal within cnt operations. In other words,\r\nfirst, you need to minimize the number of operations, second, you need\r\nto maximize the total number of coins you receive.You are given an array\r\nof integers a_0, a_1,\r\nldots, a_{n-1}. Please, find the value of f for all cyclic shifts of\r\na.Formally, for each 0\r\nle i\r\nle n-1 you need to do the following: Let c_j = a_{(j + i)\r\npmod{n}} for each 0\r\nle j\r\nle n-1. Find f(c). Since cost can be very large, output it modulo\r\n(10^9 + 7).Please note that under a fixed cnt you need to maximize the\r\ntotal number of coins cost, not its remainder modulo (10^9 + 7).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 65536, stdin), p1 == p2) ? EOF : *p1 ++)\n#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++\n#define putchar(x) (p3 - obuf < 1000000) ? (*p3++ = x) : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3++ = x)\nusing namespace std;\nstatic char buf[29999999], *p1 = buf, *p2 = buf, obuf[29999999], *p3 = obuf;\ntemplate <typename item>\ninline void read (register item &x) {\n    x = 0;\n\tregister char c = getchar();\n    while (c < '0' || c > '9') c = getchar();\n    while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n}\nstatic char cc[15];\ntemplate <typename item>\ninline void print (register item x) {\n\tregister int len = 0;\n\tdo cc[len++] = x % 10 + '0', x /= 10; while (x);\n\twhile (len--) putchar(cc[len]);\n}\nint N;ll A[2000006];\nconst ll inf=1e16,mod=1e9+7;\nstruct node{int x,y;ll cnt;}B[4000006];\nint tot;ll d[2000006];\nint stk[2000005],tail;\nvoid add(ll &x,const ll y){\n\tif((x+=y)>=mod)x-=mod;\n}\nbool cmp(node a,node b){\n\treturn a.x<b.x;\n}\nbool cmp1(node a,node b){\n\treturn a.y>b.y;\n}\nstruct BIT{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tv%=mod;\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))add(val[i],v);\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))add(res,val[i]);\n\t\treturn res;\n\t}\n}b0,b2,b3;\nstruct BIT1{\n\tll val[2000005];\n\tvoid init(){\n\t\tfor(int i=0;i<=2*N;++i)val[i]=0ll;\n\t}\n\tint lowbit(int x){\n\t\treturn x&(-x);\n\t}\n\tvoid modify(int pos,ll v){\n\t\tfor(int i=pos;i<=2*N;i+=lowbit(i))val[i]+=v;\n\t}\n\tll query(int pos){\n\t\tll res=0ll;\n\t\tfor(int i=pos;i;i-=lowbit(i))res+=val[i];\n\t\treturn res;\n\t}\n}B1;\nll res1[1000005],res2[1000005],sum[2000005];\nvoid solve(){\n\tread(N);ll mx=0ll;tot=0;\n\tfor(int i=1;i<=N;++i)read(A[i]),mx=max(mx,A[i]),res1[i]=res2[i]=0ll;\n\tif(N==1){print(0);putchar(' ');print(0);putchar('\\n');return ;}\n\tA[0]=inf;for(int i=N+1;i<=2*N;++i)A[i]=A[i-N];\n\tfor(int i=1;i<2*N;++i){\n\t\tsum[i]=sum[i-1];\n\t\tif(A[i+1]<A[i])sum[i]+=A[i]-A[i+1];\n\t}\n    for(int i=0;i<2*N;++i)d[i]=A[i]-A[i+1];tail=0;\n    for(int i=0;i<2*N;++i){\n    \tif(d[i]<0ll){\n    \t\twhile(d[i]<0ll){\n    \t\t\tif(d[stk[tail]]<-d[i]){\n    \t\t\t\tB[++tot]=node{stk[tail],i,d[stk[tail]]};\n    \t\t\t\td[i]+=d[stk[tail]];d[stk[tail--]]=0ll;\n\t\t\t\t}else {\n\t\t\t\t\tB[++tot]=node{stk[tail],i,-d[i]};\n\t\t\t\t\td[stk[tail]]+=d[i];d[i]=0ll;\n\t\t\t\t\tif(!d[stk[tail]])--tail;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d[i]>0ll)stk[++tail]=i; \n\t}\n\twhile(tail){\n\t\tB[++tot]=node{stk[tail],2*N,d[stk[tail]]};\n\t\td[stk[tail--]]=0ll;\n\t}\n    for(int i=1;i<=N;++i)res1[i]=sum[i+N-2]-sum[i-1]+mx-A[i];\n    b0.init();b2.init();b3.init();B1.init();\n\tsort(B+1,B+tot+1,cmp);int nd=1;\n    for(int i=0;i<=2*N;++i){\n    \twhile(nd<=tot&&B[nd].x<=i){\n    \t\tb0.modify(B[nd].y,1ll*(B[nd].y-B[nd].x)*(B[nd].y-B[nd].x)%mod*(B[nd].cnt%mod)%mod);\n    \t\tB1.modify(B[nd].y,B[nd].cnt);b2.modify(B[nd].y,1ll*B[nd].y*B[nd].cnt%mod);\n    \t\tb3.modify(B[nd].y,1ll*B[nd].y*B[nd].y%mod*B[nd].cnt%mod); ++nd;\n\t\t}\n    \tif(i+1<=N){\n    \t\tres2[i+1]=(res2[i+1]+mod-(b0.query(i+N-1)+mod-b0.query(i))%mod)%mod;\n    \t\tll allcnt=B1.query(i+N-1)-B1.query(i);res2[i+1]=(res2[i+1]+1ll*N*N%mod*((mx-A[i+1]-allcnt)%mod)%mod)%mod;\n\t\t\tallcnt%=mod;res2[i+1]=(res2[i+1]+1ll*i*i%mod*allcnt)%mod;\n\t\t\tll c3=b3.query(i+N-1)-b3.query(i)+mod,c2=b2.query(i+N-1)-b2.query(i)+mod;c3%=mod;c2%=mod;\n\t\t\tres2[i+1]=(res2[i+1]+mod-2ll*i*c2%mod)%mod;\n\t\t\tres2[i+1]=(res2[i+1]+c3)%mod;   \n\t\t} \n\t\tif(i-(N-2)<=N&&i-(N-2)>=1)res2[i-(N-2)]=(res2[i-(N-2)]+b0.query(i)-b0.query(i-(N-2)-1)+mod)%mod;\n\t} nd=1;B1.init();b2.init();b3.init();sort(B+1,B+tot+1,cmp1);\n\tfor(int i=2*N;i>=1;--i){\n\t\twhile(nd<=tot&&B[nd].y>=i){\n\t\t\tif(B[nd].x){\n\t\t\t\tB1.modify(B[nd].x,B[nd].cnt); b2.modify(B[nd].x,1ll*B[nd].x*B[nd].cnt%mod);\n\t\t\t    b3.modify(B[nd].x,1ll*B[nd].x*B[nd].x%mod*B[nd].cnt%mod);\n\t\t\t}\n\t\t\t++nd; \n\t\t}\n\t\tif(i-(N-1)<=N&&i-(N-1)>=1){\n\t\t\tint l=i-(N-1);\n\t\t\tll c1=B1.query(i-1)-B1.query(l-1),c2=b2.query(i-1)-b2.query(l-1)+mod,c3=b3.query(i-1)-b3.query(l-1)+mod;\n\t\t//\tcout<<l<<\" \"<<c1<<endl;\n\t\t\tc2%=mod;c3%=mod;c1%=mod;\n\t\t    res2[l]=(res2[l]+1ll*i*i%mod*c1%mod)%mod;\n\t\t    res2[l]=(res2[l]-2ll*i*c2%mod+mod)%mod;\n\t\t    res2[l]=(res2[l]+c3)%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;++i){\n\t\tprint(res1[i]);putchar(' ');\n\t\tprint(res2[i]);putchar('\\n');\n\t}\n}\nint main(){\n\tint t;read(t);\n\twhile(t--)solve(); \n\tfwrite(obuf, p3 - obuf, 1, stdout);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hard Design.json",
    "editorial_link": "https://codeforces.com//blog/entry/121618",
    "editorial": "Letâs learn how to solve a problem for a given array. Notice that we\r\nwant to make all elements equal to the maximum value in the array. For\r\nconvenience, letâs solve a similar problem that is easier to implement.\r\nWeâll create an array . Then, instead of performing an addition\r\noperation, weâll perform a subtraction operation by on a range, aiming\r\nto make all elements of the array equal to .Let be the position of the\r\nminimum element in the array . We can apply the operation times on the\r\nentire array, and then recursively solve the problem for the left and\r\nright parts relative to the position . However, this doesnât help us\r\nsolve the problem for all shifts. Letâs find the nearest element less\r\nthan or equal to each element on the left (denoted as ) and the nearest\r\nelement less than each element on the right (denoted as ) - this can be\r\ndone using linear algorithms. Then, we can observe that when we consider\r\nthe subarray in our recursive solution, we add to the answer a value\r\nequal to . We have found a solution to the problem in time for a fixed\r\narray .If we consider all shifts of the array, the nearest elements on\r\nthe left/right either remain unchanged or simply do not exist, in which\r\ncase we consider their values to be . Therefore, if we fix the position\r\n(want to determine how much it affects the answer for each position in\r\nthe array), we have three shift ranges for which we can add different\r\nvalues. Hence, we have ranges on which we need to add certain values.\r\nSince we donât have to make these additions immediately, we can create\r\nan array - the value that needs to be added to all elements starting\r\nfrom position . Then, adding the number on the range changes this array\r\nas follows: , . The answer to the problem is . This subproblem can be\r\nsolved in time.Next, we need to learn how to calculate the total cost.\r\nThe approach will be similar, but now we need to add a more complex\r\nfunction. If both nearest elements are within a shift range, we will\r\nadd - a fixed number. If there is no nearest element on the left/right,\r\nwe will add a value of the form or , where is the index of the start of\r\nthe shift position. Both cases can be solved similarly. If we expand the\r\nbrackets, we get an expression of the form , where are known\r\ncoefficients. Letâs represent the answer for a fixed shift in this form,\r\nand we need to find the value of each coefficient, which is simply\r\nadding a fixed number on a range, as we discussed in the previous\r\nparagraph. This can also be solved in time.\r\n",
    "hint": []
}