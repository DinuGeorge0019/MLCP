{
    "link": "https://codeforces.com//contest/1632/problem/D",
    "problemId": "1278698",
    "problem_idx": "D",
    "shortId": "1632D",
    "contest_number": "1632",
    "problem_submissions": {
        "E1": [
            144553548,
            144546555,
            144538505,
            144560614,
            144555177,
            144570181,
            144567095,
            144564117,
            144551128,
            144572195,
            144551374,
            144572612,
            144560176,
            144549481,
            144570313,
            144572945,
            144573371,
            144573243,
            144781904,
            144570037,
            144576051
        ],
        "E2": [
            144553397,
            144546628,
            144538238,
            144560696,
            144576825,
            144570290,
            144567223,
            144574776,
            144578234,
            144577114,
            144552629,
            144572667,
            144560118,
            144548760,
            144782104
        ],
        "D": [
            144544326,
            144548567,
            144544619,
            144545949,
            144545344,
            144546263,
            144548360,
            144547457,
            144566603,
            144552042,
            144576325,
            144552296,
            144564979,
            144562009,
            144548406,
            144547745,
            144554067,
            144547333,
            144551486,
            144552100
        ],
        "C": [
            144532256,
            144532333,
            144552739,
            144539867,
            144537184,
            144535548,
            144541623,
            144538433,
            144533445,
            144536971,
            144534634,
            144543706,
            144539573,
            144565645,
            144540061,
            144544063,
            144537135,
            144540356,
            144543986,
            144538265
        ],
        "B": [
            144523270,
            144523937,
            144553855,
            144517645,
            144517755,
            144524308,
            144521003,
            144519652,
            144518659,
            144523687,
            144526327,
            144529945,
            144526501,
            144567195,
            144520516,
            144517692,
            144524688,
            144521488,
            144525583,
            144520661
        ],
        "A": [
            144513769,
            144520637,
            144555034,
            144512533,
            144512726,
            144517704,
            144512723,
            144512551,
            144512467,
            144515604,
            144512655,
            144515813,
            144521079,
            144555040,
            144512525,
            144512590,
            144514275,
            144515034,
            144512507,
            144513160
        ]
    },
    "name": "D. New Year Concert",
    "statement": "New Year is just around the corner, which means that in School 179,\r\npreparations for the concert are in full swing.There are n classes in\r\nthe school, numbered from 1 to n, the i-th class has prepared a scene of\r\nlength a_i minutes.As the main one responsible for holding the concert,\r\nIdnar knows that if a concert has k scenes of lengths b_1, b_2,\r\nldots, b_k minutes, then the audience will get bored if there exist two\r\nintegers l and r such that 1\r\nle l\r\nle r\r\nle k and\r\ngcd(b_l, b_{l + 1},\r\nldots, b_{r - 1}, b_r) = r - l + 1, where\r\ngcd(b_l, b_{l + 1},\r\nldots, b_{r - 1}, b_r) is equal to the greatest common divisor (GCD) of\r\nthe numbers b_l, b_{l + 1},\r\nldots, b_{r - 1}, b_r.To avoid boring the audience, Idnar can ask any\r\nnumber of times (possibly zero) for the t-th class (1\r\nle t\r\nle k) to make a new scene d minutes in length, where d can be . Thus,\r\nafter this operation, b_t is equal to d. Note that t and d can be\r\ndifferent for each operation.For a sequence of scene lengths b_1, b_2,\r\nldots, b_{k}, let f(b) be the minimum number of classes Idnar has to ask\r\nto change their scene if he wants to avoid boring the audience.Idnar\r\nhasn’t decided which scenes will be allowed for the concert, so he wants\r\nto know the value of f for each non-empty prefix of a. In other words,\r\nIdnar wants to know the values of f(a_1), f(a_1,a_2),\r\nldots, f(a_1,a_2,\r\nldots,a_n).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\n\nint gcd(int x,int y){\n    return __gcd(x,y);\n}\n\nint n, a[202000], g[202000][18];\n\nbool check(int las,int n){\n    int p=n, now=a[n];\n    while (1){\n        int orgp=p;\n        for (int j=17;j>=0;--j)\n            if (p-(1<<j)>=0){\n                if (g[p][j]%now==0){\n                    p-=1<<j;\n                }\n            }\n        p=max(p,las);\n        int l=n-orgp+1, r=n-p;\n        if (l<=now&&now<=r) return 1;\n        if (p==las) return 0;\n        now=gcd(now,a[p]);\n    }\n}\n\nint main(){\n    cin>>n;\n    int las=0, ans=0;\n    for (int i=1;i<=n;++i){\n        scanf(\"%d\",&a[i]);\n        g[i][0]=a[i];\n        for (int j=1;j<=17;++j){\n            if (i-(1<<j)>=0) g[i][j]=gcd(g[i][j-1],g[i-(1<<j-1)][j-1]);\n        }\n        int fl=check(las,i);\n        if (fl){\n            ++ans; las=i;\n        }\n        printf(\"%d \",ans);\n    }\n    puts(\"\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. New Year Concert.json",
    "editorial_link": "https://codeforces.com//blog/entry/99442",
    "editorial": "Read the hints above.Letâs find all of the bad segments. For a\nfixed , letâs find the largest that has . This can be done with binary\nsearch and a sparse table / segment tree. If , then the segment is bad.\nIf we change into a big prime, no new bad segments will appear. And all\nbad segments that have inside of them will disappear. So we have to find\nthe minimum number of points to cover all of them. This is a standard\nproblem, which can be solved greedily: choose the segment with the\nsmallest , delete all segments that have in them, and repeat. In our\ncase, this is easy to do because our segments are not nested.Time\ncomplexity: with a sparse table, where is the maximum value of .Notes:\nThere are many different modifications to the previous solution, some of\nthem use two pointers (since segments are not nested) and some of them\nupdate the answer on the fly while searching for the bad segments. Using\na segment tree and two pointers you can get the complexity . You can\nalso use the fact that for a prefix, there at most different suffix\nvalues. This leads to another way to find the bad segments.\n",
    "hint": [
        "Hint 1 Let's call a segment bad if . There at most bad segments.",
        "Hint 2 For a fixed , as increases, does not increase.",
        "Hint 3 Suppose you change into a big prime. How does this affect the bad segments?"
    ]
}