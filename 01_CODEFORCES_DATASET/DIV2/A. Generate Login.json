{
    "link": "https://codeforces.com//contest/909/problem/A",
    "problemId": "142267",
    "problem_idx": "A",
    "shortId": "909A",
    "contest_number": "909",
    "problem_submissions": {
        "D": [
            33703562,
            33684475,
            33687934,
            33679960,
            33681845,
            33678239,
            33681778,
            33682813,
            33684628,
            33683979,
            33684264,
            33683734,
            33682267,
            33684172,
            33684972,
            33684951,
            37837707,
            33689232,
            33685173
        ],
        "C": [
            33702243,
            33685781,
            33688791,
            33678737,
            33677527,
            33680778,
            33679730,
            33677867,
            33678218,
            33679090,
            33681226,
            33679711,
            33679799,
            33678914,
            33682105,
            33681294,
            33679526,
            33680909
        ],
        "F": [
            33682616,
            33683222,
            33692268,
            33694692,
            33695944
        ],
        "E": [
            33680057,
            33686075,
            33684461,
            33682298,
            33685101,
            33681929,
            33683773,
            33684555,
            33682566,
            33680995,
            33686514,
            33687842,
            33689439,
            33687234,
            33687184,
            33690952,
            33683720,
            33689497
        ],
        "B": [
            33678984,
            33689620,
            33681003,
            33675642,
            33677938,
            33674594,
            33675218,
            33675981,
            33675928,
            33676067,
            33676981,
            33677469,
            33675490,
            33680062,
            33675898,
            33676219,
            33677187
        ],
        "A": [
            33675962,
            33690137,
            33674036,
            33674451,
            33674005,
            33674337,
            33674208,
            33673945,
            33674163,
            33674088,
            33674166,
            33675518,
            33673927,
            33674572,
            33673981,
            33673915,
            33676471
        ]
    },
    "name": "A. Generate Login",
    "statement": "The preferred way to generate user login in Polygon is to concatenate a\r\nprefix of the user’s first name and a prefix of their last name, in that\r\norder. Each prefix must be non-empty, and any of the prefixes can be the\r\nfull name. Typically there are multiple possible logins for each\r\nperson.You are given the first and the last name of a user. Return the\r\nalphabetically earliest login they can get (regardless of other\r\npotential Polygon users).As a reminder, a prefix of a string is its\r\nsubstring which occurs at the beginning of : \"\", \"\", \"\" etc. are\r\nprefixes of string \"{abcdef}\" but \"\" and ’\" are not. A string is\r\nalphabetically earlier than a string , if is a prefix of , or and\r\ncoincide up to some position, and then has a letter that is\r\nalphabetically earlier than the corresponding letter in : \"\" and \"\" are\r\nalphabetically earlier than \"\" but \"\" and \"\" are alphabetically later\r\nthan \"\".\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint la,lb;\nstring a,b,tmp,ans=\"zzzzzzzzzzzzzzzzzzzzzz\";\n\nint main()\n{\n\tcin>>a>>b;\n\tla=a.length(),lb=b.length();\n\tfor(int i=1;i<=la;i++)\n\t\tfor(int j=1;j<=lb;j++)\n\t\t\ttmp=a.substr(0,i)+b.substr(0,j),ans=min(ans,tmp);\n\tcout<<ans;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Generate Login.json",
    "editorial_link": "https://codeforces.com//blog/entry/56666",
    "editorial": "The most straightforward solution is to generate all possible logins (by\r\ntrying all non-empty prefixes of first and last names and combining\r\nthem) and find the alphabetically earliest of them. To get a faster\r\nsolution, several observations are required. First, in the\r\nalphabetically earliest login the prefix of the last name is always one\r\nletter long; whatever login is generated using two or more letter of the\r\nlast name, can be shortened further by removing extra letter to get an\r\nalphabetically earlier login. Second, the prefix of the first name\r\nshould not contain any letter greater than or equal to the first letter\r\nof the last name, other than the first letter. Thus, a better solution\r\nis: iterate over letter of the first name, starting with the second one.\r\nOnce a letter which is greater than or equal to the first letter of the\r\nlast name is found, stop, and return all letter until this one plus the\r\nfirst letter of the last name. If such a letter is not found, return the\r\nwhole first name plus the first letter of the last name.\r\n",
    "hint": []
}