{
    "link": "https://codeforces.com//contest/1228/problem/E",
    "problemId": "424246",
    "problem_idx": "E",
    "shortId": "1228E",
    "contest_number": "1228",
    "problem_submissions": {
        "F": [
            61496806,
            61502870,
            61502190,
            61505436,
            61526774,
            61501386,
            61506794,
            61506003,
            61507242,
            61528062,
            61506930,
            61504933,
            61527679,
            61758392,
            61506804,
            61501659
        ],
        "E": [
            61487066,
            61484839,
            61491424,
            61489793,
            61526757,
            61494082,
            61491501,
            61493504,
            61494383,
            61528054,
            61491524,
            61495860,
            61488344,
            61491222,
            61486950,
            61487675,
            61498567,
            61492377,
            61492698,
            61509475,
            61488264
        ],
        "D": [
            61485310,
            61482745,
            61489582,
            61486586,
            61526744,
            61490366,
            61487311,
            61489384,
            61491690,
            61528041,
            61498727,
            61505643,
            61485067,
            61484265,
            61490334,
            61491347,
            61491538,
            61486214,
            61487124,
            61487752,
            61482893
        ],
        "C": [
            61480399,
            61479345,
            61481687,
            61481376,
            61526733,
            61486187,
            61481654,
            61482779,
            61486226,
            61528029,
            61481914,
            61486289,
            61481778,
            61480281,
            61475855,
            61480938,
            61484833,
            61479319,
            61482763,
            61482555,
            61495805
        ],
        "B": [
            61476242,
            61476828,
            61478048,
            61477189,
            61526720,
            61483135,
            61479399,
            61477633,
            61477664,
            61528022,
            61483663,
            61478266,
            61477452,
            61477008,
            61479768,
            61476788,
            61509875,
            61476696,
            61478410,
            61478919,
            61476259
        ],
        "A": [
            61473188,
            61476420,
            61473176,
            61473720,
            61526708,
            61477230,
            61473216,
            61473745,
            61473523,
            61528006,
            61479593,
            61475038,
            61472935,
            61473261,
            61477228,
            61473405,
            61476821,
            61473215,
            61474472,
            61475483,
            61474687
        ]
    },
    "name": "E. Another Filling the Grid",
    "statement": "You have n\r\ntimes n square grid and an integer k. Put an integer in each cell while\r\nsatisfying the conditions below. All numbers in the grid should be\r\nbetween 1 and k inclusive. Minimum number of the i-th row is 1 (1\r\nle i\r\nle n). Minimum number of the j-th column is 1 (1\r\nle j\r\nle n). Find the number of ways to put integers in the grid. Since the\r\nanswer can be very large, find the answer modulo (10^{9} + 7). These are\r\nthe examples of valid and invalid grid when n=k=2.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int P = 1000000007;\n\nstruct Simple {\n  int n;\n  vector<int> fac, ifac, inv;\n\n  void build(int n) {\n    this->n = n;\n    fac.resize(n + 1);\n    ifac.resize(n + 1);\n    inv.resize(n + 1);\n    fac[0] = 1;\n    for (int x = 1; x <= n; ++x)\n      fac[x] = fac[x - 1] * (ll)x % P;\n    inv[1] = 1;\n    for (int x = 2; x <= n; ++x)\n      inv[x] = -(P / x) * (ll)inv[P % x] % P + P;\n    ifac[0] = 1;\n    for (int x = 1; x <= n; ++x)\n      ifac[x] = ifac[x - 1] * (ll)inv[x] % P;\n  }\n\n  Simple() {\n    build(1);\n  }\n\n  void check(int k) {\n    int nn = n;\n    if (k > nn) {\n      while (k > nn)\n        nn <<= 1;\n      build(nn);\n    }\n  }\n\n  int gfac(int k) {\n    check(k);\n    return fac[k];\n  }\n\n  int gifac(int k) {\n    check(k);\n    return ifac[k];\n  }\n\n  int ginv(int k) {\n    check(k);\n    return inv[k];\n  }\n\n  int binom(int n, int m) {\n    if (m < 0 || m > n)\n      return 0;\n    return gfac(n) * (ll)gifac(m) % P * gifac(n - m) % P;\n  }\n} simp;\n\nint mpow(int x, int k, int p = P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll)x % p;\n    x = x * (ll)x % p;\n    k >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  int ans = 0;\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= n; ++j) {\n      int res = mpow(k, (n - i) * (n - j)) * (ll)mpow(k - 1, n * n - (n - i) * (n - j)) % P * simp.binom(n, i) % P * simp.binom(n, j) % P;\n      if ((i + j) & 1) {\n        ans = (P + ans - res) % P;\n      } else {\n        ans = (ans + res) % P;\n      }\n    }\n  printf(\"%d\\n\", ans);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Another Filling the Grid.json",
    "editorial_link": "https://codeforces.com//blog/entry/70162",
    "editorial": "solution:Let to be the number of filling grids of rows, incomplete\r\ncolumns, and complete columns. Incomplete columns means which doesn\u00e2\u0080\u0099t\r\ncontain in already filled part, and complete columns means opposite. Now\r\nyou can see that the formula can be described as below; (), because we\r\ndon\u00e2\u0080\u0099t have to care about minimum value of columns. However, there should\r\nbe at least one cell which has . (), because we have to fill in all\r\nincomplete columns in that row. But, other cells are free. (, ). Each\r\npart means number of cases when you select incomplete columns to be\r\ncomplete column in this row. The answer is . and solution:Let be the\r\nrestriction of the i-th row having some value <= 1 and the same but for\r\ncolumns. We want .Negate that expression twice, and we\u00e2\u0080\u0099ll get . Using\r\ninclusion-exclusion this is:This is enough for with fast exponentiation\r\nor precomputing the needed powers. To get note that we the second sum is\r\na binomial expansion so the answer can be simplified to:\r\n"
}