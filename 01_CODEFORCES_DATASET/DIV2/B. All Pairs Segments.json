{
    "link": "https://codeforces.com//contest/2019/problem/B",
    "problemId": "2905354",
    "problem_idx": "B",
    "shortId": "2019B",
    "contest_number": "2019",
    "problem_submissions": {
        "F": [
            283223839,
            283223286,
            283233615,
            283232657,
            283229948,
            283240516,
            283246459,
            283246565,
            283251452,
            283250505,
            283246427,
            283244651,
            283250557,
            283250319,
            283249369,
            283252799,
            283231473,
            283385869
        ],
        "D": [
            283212674,
            283217889,
            283216603,
            283210525,
            283219753,
            283227849,
            283216187,
            283224832,
            283209439,
            283233196,
            283224958,
            283235552,
            283222166,
            283223408,
            283233229,
            283225040,
            283257759,
            283214659,
            283210870,
            283212555
        ],
        "C": [
            283205819,
            283208819,
            283200046,
            283197191,
            283204787,
            283192339,
            283195887,
            283200218,
            283196222,
            283200867,
            283211801,
            283203783,
            283208730,
            283210534,
            283225468,
            283214456,
            283200932,
            283202854,
            283202139,
            283199131
        ],
        "B": [
            283197247,
            283193710,
            283188887,
            283186540,
            283192007,
            283185443,
            283202984,
            283190900,
            283188420,
            283188733,
            283190635,
            283190801,
            283197405,
            283188473,
            283191300,
            283202121,
            283194633,
            283194452,
            283194664,
            283188555
        ],
        "A": [
            283194983,
            283181021,
            283181315,
            283181373,
            283182984,
            283180436,
            283198713,
            283181153,
            283180882,
            283182334,
            283181092,
            283183886,
            283188674,
            283181377,
            283181185,
            283196847,
            283190061,
            283183844,
            283182154,
            283180956
        ],
        "E": [
            283192360,
            283198927,
            283209740,
            283216991,
            283212803,
            283197800,
            283209059,
            283219624,
            283225534,
            283213304,
            283232353,
            283227746,
            283232779,
            283233925,
            283218649,
            283231587,
            283221137,
            283211364,
            283219849,
            283218893
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134420",
    "editorial": "SolutionFirst, letâs focus on determining how many intervals contain\r\nsome point . These intervals are the ones with and .So a point satisfies\r\n, and . It means that you have found points contained in exactly\r\nintervals (because there are possible left endpoints and possible right\r\nendpoints).Similarly, the point is contained in intervals (you have to\r\nremove interval , which you do not draw).So you can use a map that\r\nstores how many points are contained in exactly intervals, and update\r\nthe map in the positions and .Complexity:\r\n",
    "name": "B. All Pairs Segments",
    "statement": "You are given n points on the x axis, at increasing positive integer\r\ncoordinates x_1 < x_2 <\r\nldots < x_n.For each pair (i, j) with 1\r\nleq i < j\r\nleq n, you draw the segment [x_i, x_j]. The segments are closed, i.e., a\r\nsegment [a, b] contains the points a, a+1,\r\nldots, b.You are given q queries. In the i-th query, you are given a\r\npositive integer k_i, and you have to determine how many points with\r\ninteger coordinates are contained in exactly k_i segments.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;#define int long longconst int N=1e5+7;int T,n,q,x[N];map<int,int>mp;signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);\tcin>>T;\twhile(T--){\t\tcin>>n>>q;\t\tfor(int i=1;i<=n;i++){\t\t\tcin>>x[i];\t\t\tint cnt=(n-1)+(i-1)*(n-i);\t\t\tmp[cnt]++;\t\t}\t\tfor(int i=1;i<n;i++){\t\t\tint cnt=i*(n-i);\t\t\tmp[cnt]+=(x[i+1]-x[i]-1);\t\t}\t\twhile(q--){\t\t\tint x;\t\t\tcin>>x;\t\t\tcout<<mp[x]<<\" \";\t\t\t}\t\tcout<<\"\\n\";\t\tmp.clear();\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. All Pairs Segments.json",
    "hint": [
        "Hint 1 Can you determine fast how many intervals contain point ?",
        "Hint 2 The intervals that contain point are the ones with and .",
        "Hint 3 Determine how many intervals contain: point ; points ; point ; point .",
        "Hint 1 The answer is at most .",
        "Hint 2 Solve the problem with .",
        "Hint 3 When is the answer ?",
        "Hint 4 If the answer is not , how can you buy cards?",
        "Hint 1 When is the answer ?",
        "Hint 2 Starting from city is equivalent to setting .",
        "Hint 1 Solve for a fixed final depth of the leaves.",
        "Hint 2 Which nodes are \"alive\" if all leaves are at depth at the end?",
        "Hint 1 The optimal subsequence must contain at least one occurrence of the maximum.",
        "Hint 2 Iterate over the minimum, in decreasing order.",
        "Hint 3 You have some \"connected components\". How many elements can you pick from each component? How to make sure you have picked at least one occurrence of the maximum?",
        "Hint 1 Solve for a fixed (size of the subsets).",
        "Hint 2 is easy. Can you do something similar for other ?",
        "Hint 3 Solve for a fixed (number of subsets).",
        "Hint 4 If you have a solution for a fixed , note that there exists a faster solution!",
        "Hint 1 Suppose you are given a starting city and you want to win. Find several strategies to win (if possible) and try to work with the simplest ones.",
        "Hint 2 The valid starting cities are either zero, or all the cities in .",
        "Hint 3 Now you have some bounds on the .",
        "Hint 4 Fix the interval and try to find a (slow) DP.",
        "Hint 5 Counting paths seems easier than counting arrays. Make sure that, for each array, you make exactly one path (or a number of paths which is easy to handle).",
        "Hint 6 How many distinct states do you calculate in your DP?",
        "Hint 1 Think, how can we use the fact that we have to perform all the operations before seeing the array.",
        "Hint 2 Instead of just looping over to , we instead want to pass this information and get the real value later."
    ]
}