{
    "link": "https://codeforces.com//contest/1493/problem/E",
    "problemId": "916232",
    "problem_idx": "E",
    "shortId": "1493E",
    "contest_number": "1493",
    "problem_submissions": {
        "E": [
            109300691,
            109266485,
            109271539,
            109262971,
            109276076,
            109269136,
            109397471,
            109327948,
            109273809,
            109280460,
            109407951,
            109291144
        ],
        "B": [
            109260545,
            109239746,
            109254991,
            109270234,
            109241243,
            109242522,
            109253609,
            109252334,
            109327832,
            109233296,
            109238405,
            109249942,
            109232284,
            109235737,
            109235442,
            109237822,
            109237430,
            109234756,
            109237333,
            109236735
        ],
        "C": [
            109257705,
            109251136,
            109251134,
            109246054,
            109250920,
            109266513,
            109273162,
            109327814,
            109245427,
            109240048,
            109234896,
            109238348,
            109245265,
            109246216,
            109245882,
            109254906,
            109244489,
            109256285,
            109246006
        ],
        "F": [
            109251446,
            109300451,
            109300023,
            109263743,
            109278727,
            109492473,
            109395367,
            109755119
        ],
        "D": [
            109250583,
            109257293,
            109245697,
            109282268,
            109255131,
            109236733,
            109257985,
            109245022,
            109241096,
            109327857,
            109262894,
            109249582,
            109243883,
            109253883,
            109249816,
            109255048,
            109252679,
            109247391,
            109256541,
            109248836,
            109257345
        ],
        "A": [
            109228407,
            109230343,
            109243099,
            109232737,
            109227629,
            109231368,
            109228074,
            109228388,
            109327785,
            109227973,
            109230330,
            109252518,
            109227990,
            109230461,
            109228220,
            109228782,
            109229679,
            109227822,
            109229042,
            109229707
        ]
    },
    "name": "E. Enormous XOR",
    "statement": "You are given two integers l and r in binary representation. Let g(x, y)\r\nbe equal to the bitwise XOR of all integers from x to y inclusive (that\r\nis x\r\noplus (x+1)\r\noplus\r\ndots\r\noplus (y-1)\r\noplus y). Let’s define f(l, r) as the maximum of all values of g(x, y)\r\nsatisfying l\r\nle x\r\nle y\r\nle r.Output f(l, r).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,\"r\",stdin)\n#define Fout(s) freopen(s,\"w\",stdout)\n#define file(s) Fin(s\".in\"),Fout(s\".out\")\n#define INF ((1<<30)-1)\n#define int long long\nconst int P=1e9+7; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\n//inline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline void fprint(const vector<int> &f) {for(int i=0;i<f.size();i++) fprintf(stderr,\"%d \",f[i]); fprintf(stderr,\"\\n\");}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]='0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\nconst int MN=1e6+5;\nstring L,R; int n;\nstring add(string s) {\n\tint i=n-1;\n\twhile(s[i]=='1') {\n\t\ts[i]='0'; i--;\t\n\t}\n\ts[i]='1'; return s;\n}\nsigned main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"pro.in\",\"r\",stdin);\n\t\tfreopen(\"pro.out\",\"w\",stdout);\n\t#endif\n\tcin>>n>>L>>R;\n\tif(L[0]!=R[0]) {\n\t\tFor(i,1,n) cout<<'1';\n\t\treturn cout<<endl,0;\n\t}\t\n\tif(R[n-1]=='1'||L==R||(add(L)==R)) cout<<R<<endl;\n\telse {\n\t\tR[n-1]='1';\n\t\tcout<<R<<endl;\t\n\t}\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy",
        "math",
        "strings",
        "two pointers"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Enormous XOR.json",
    "editorial_link": "https://codeforces.com//blog/entry/88422",
    "editorial": "Letâs numerate bits from to from the least significant bit to the most\r\nsignificant (from the end of the representation). If -st bits of numbers\r\nand differ, then there is a power transition between numbers and , and\r\nthe answer to the problem is (the number contains ones).Otherwise it can\r\nbe shown that if bit of the number is equal to , then the answer is\r\nitself. If bit of the number is equal to and , the answer is , otherwise\r\nthe answer is .Proof.Firstly, if there is a power transition between and\r\n, then we can take a segment [; ] ( ones; and zero), and get on it of\r\nones. It is not hard to show that it will be the maximal possible.Letâs\r\nprove that for odd without power transition the answer is . That answer\r\ncan be reached if we take a segment consisting of one number . Letâs\r\nprove that the answer if maximal using induction. Base: for segments , ,\r\nis odd, the answer is (in the first case there is no other segments, in\r\nthe second case subsegments and have less -s).Letâs take induction step\r\nfrom to . The answer on segment is obviously , remaining subsegments can\r\nbe split into three groups: with right bound , with right bound , and\r\nlying inside the segment , with that all the left bounds of the\r\nsubsegments are lying inside . The answer on the segments of third group\r\nis (proved by induction). The segments of the first group contain\r\nsubsegment , which has equal to , and some segment ending at . Notice\r\nthat that way we can increase the answer of the segment not more by ,\r\ni.e. the answer for the segments of the first group is not greater than\r\n.Now letâs consider the segments of the second group. Suppose that we\r\ncould find the segment from that group with on it greater than . Then\r\nsome bit which was in , became in that , with that it is not the bit\r\n(since is odd). Letâs find the amount of numbers from (inclusively) to\r\nthe nearest having in that bit (non-inclusively). It is not hard to show\r\nthat that amount is odd (from even to zero inclusively). In order to\r\nmake the bit , we need to take an odd amount of numbers with in that\r\nbit. Since the blocks (among consecutive numbers blocks with in that bit\r\nand blocks with in that bit) have even length (, , and so on), we need\r\nto take an odd amount of numbers in total to take an odd amount of\r\nnumbers with in that bit. Then the whole segment will contain odd odd\r\neven amount of numbers (the first summand is the amount of numbers from\r\nto the nearest having in that bit, the second summand is the amount of\r\nnumbers we will take to make that bit equal to ), but then the most\r\nsignificant (-st) bit will become equal to , therefore we will get less\r\nthan . It means that among segments of the second group there is no\r\nsegment with greater than as well. So, is the answer for .Now letâs\r\nconsider even right bounds. If the length of the segment is less than\r\n(), then it is simple to show that the right bound will be the answer.\r\nOtherwise is the answer. It can be reached on the segment and is the\r\nmaximal possible, because we can increase the right bound of the segment\r\nby (it will become odd), with that the answer surely wonât decrease, and\r\nthe answer on is proven to be .\r\n",
    "hint": []
}