{
    "link": "https://codeforces.com//contest/767/problem/E",
    "problemId": "94684",
    "problem_idx": "E",
    "shortId": "767E",
    "contest_number": "767",
    "problem_submissions": {
        "E": [
            24773688,
            24758593,
            24766542,
            24771366,
            24781051,
            24771141,
            24779799,
            24793086,
            24815876,
            24813453,
            24777026
        ],
        "D": [
            24763626,
            24761005,
            24762891,
            24764024,
            24762582,
            24766354,
            24757953,
            24768943,
            24767743,
            24772654,
            24771704,
            24762285,
            24776438,
            24769130,
            24767445,
            24768099,
            24766844,
            24758983,
            24768020,
            24763075,
            24760035
        ],
        "C": [
            24761320,
            24765332,
            24760448,
            24761283,
            24759373,
            24763235,
            24759987,
            24766222,
            24769355,
            24767653,
            24765828,
            24761673,
            24774191,
            24769625,
            24760821,
            24762590,
            24762307,
            24759906,
            24765569
        ],
        "B": [
            24759162,
            24783957,
            24766261,
            24758310,
            24773199,
            24761589,
            24765216,
            24759680,
            24761807,
            24765169,
            24760359,
            24760779,
            24771356,
            24771320,
            24788532
        ],
        "A": [
            24756659,
            24769945,
            24755736,
            24756082,
            24755178,
            24755290,
            24755126,
            24755429,
            24755320,
            24755950,
            24755426,
            24755130,
            24770401,
            24755414,
            24755517,
            24761778,
            24755322,
            24757132,
            24755145,
            24761825
        ]
    },
    "name": "E. Change-free",
    "statement": "Student Arseny likes to plan his life for days ahead. He visits a\r\ncanteen every day and he has already decided what he will order in each\r\nof the following days. Prices in the canteen do not change and that\r\nmeans Arseny will spend rubles during the -th day.There are -ruble coins\r\nand -ruble notes in circulation. At this moment, Arseny has coins and a\r\nsufficiently large amount of notes (you can assume that he has an\r\ninfinite amount of them). Arseny loves modern technologies, so he uses\r\nhis credit card everywhere except the canteen, but he has to pay in cash\r\nin the canteen because it does not accept cards.Cashier always asks the\r\nstudent to pay change-free. However, it\u2019s not always possible, but\r\nArseny tries to minimize the of the cashier. Cashier\u2019s dissatisfaction\r\nfor each of the days is determined by the total amount of notes and\r\ncoins in the change. To be precise, if the cashier gives Arseny notes\r\nand coins on the -th day, his dissatisfaction for this day equals .\r\nCashier always gives change using as little coins and notes as possible,\r\nhe always has enough of them to be able to do this. Arseny wants to pay\r\nin such a way that the total dissatisfaction of the cashier for days\r\nwould be as small as possible. Help him to find out how he needs to pay\r\nin each of the days!Note that Arseny always has enough money to pay,\r\nbecause he has an infinite amount of notes. Arseny can use notes and\r\ncoins he received in change during any of the following days.\r\n",
    "solutions": [
        "#include<queue>\n#include<cstdio>\nusing namespace std;\n#define ran 1111111\nint n;\nlong long int m;\nlong long int c[ran],w[ran],d[ran];\npriority_queue<pair<long long int,int> > q;\nbool f[ran];\nint main(){\n\tscanf(\"%d%I64d\",&n,&m);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%I64d\",&c[i]);\n\t\td[i] = c[i] % 100;\n\t\tf[i] = false;\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tscanf(\"%I64d\",&w[i]);\n\twhile(!q.empty())q.pop();\n\tlong long int res = 0;\n\tfor(int i=0; i<n; i++){\n\t\tif(d[i] != 0){\n\t\t\tq.push(make_pair(-w[i] * (100 - d[i]),i));\n\t\t}\n\t\tm -= d[i];\n\t\tif(m < 0){\n\t\t\tm += 100;\n\t\t\tres -= q.top().first;\n\t\t\tf[q.top().second] = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\",res);\n\tfor(int i=0; i<n; i++)\n\t\tif(!f[i])\n\t\t\tprintf(\"%I64d %I64d\\n\",c[i]/100,c[i]%100);\n\t\telse\n\t\t\tprintf(\"%I64d %I64d\\n\",c[i]/100+1,0);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Change-free.json",
    "editorial_link": "https://codeforces.com//blog/entry/50498",
    "editorial": "The first thing to note is that during day it makes sense to either pay\r\nnotes coins (in this case, the cashier\u00e2\u0080\u0099s dissatisfaction would be equal\r\nto ), or just notes (in that case, the cashier\u00e2\u0080\u0099s dissatisfaction would\r\nbe equal to )/ Moreover, the second case is impossible if , so in that\r\ncase you just have to pay the required amount of notes.In order to solve\r\nthe problem, we have to note the additional fact. Let\u00e2\u0080\u0099s suppose Arseny\r\npaid change-free during the -th day and gave the cashier coins. Then, if\r\nwe change the payment way this day, the amount of coins availible to\r\nArseny would increase by regardless of the ! Indeed, Arseny wouldn\u00e2\u0080\u0099t\r\nspend those coins, and he would aso receive coins in change, which adds\r\nup to exactly coins. Let\u00e2\u0080\u0099s build the optimal solution day-by-day\r\nbeginning from day one, trying to pay change-free every time to minimize\r\nthe cashier\u00e2\u0080\u0099s dissatisfaction. Let -th day be the first one when Arseny\r\nwouldn\u00e2\u0080\u0099t be able to pay change-free. It means that Arseny has to get\r\nsome change at least once during days from first to -th. But, regardless\r\nof the day, after -th day he would have the same amount of coins! It\r\nmeans that the optimal way is to get change during the day when the\r\ncashier\u00e2\u0080\u0099s dissatisfaction would be minimal. Then, let\u00e2\u0080\u0099s continue to pay\r\nchange-free whenever we can. If Arseny again can\u00e2\u0080\u0099t pay change-free\r\nduring day , there must be a day from first to -th when he got change.\r\nUsing similiar considerations, whe should choose the day with the\r\nminimal cashier\u00e2\u0080\u0099s dissatisfaction (except the first one). We should do\r\nthese operations until we process all days.The simple implementation of\r\nthis process works in time and hits TLE. But if you use any structure of\r\ndata which allows you to add or delete element or find minimum in time,\r\nfor example, heap or binary seach tree, we can save all previous days\r\ninto it and find a day with the minimal cashier\u00e2\u0080\u0099s dissatisfaction faster\r\nthan . The final time is .\r\n"
}