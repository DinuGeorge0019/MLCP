{
    "link": "https://codeforces.com//contest/1658/problem/F",
    "problemId": "1344628",
    "problem_idx": "F",
    "shortId": "1658F",
    "contest_number": "1658",
    "problem_submissions": {
        "E": [
            151138530,
            151146869,
            151142274,
            151156891,
            151144475,
            151131245,
            151198774,
            151154302,
            151144731,
            151157692,
            151159508,
            151140462,
            151148647,
            151219181,
            151219025,
            151218886,
            151218748,
            151155148,
            152719328,
            151158378,
            151155247,
            151203772,
            151170614,
            151170291,
            151155048
        ],
        "F": [
            151130100,
            151137469,
            151160433,
            151144944,
            151156580,
            151159798,
            151232291,
            151153413,
            151160992,
            151158393,
            151217808,
            152719401,
            151235290,
            152865004
        ],
        "D2": [
            151123118,
            151134040,
            151133854,
            151166091,
            151125130,
            151122133,
            151139222,
            151137227,
            151134065,
            151132282,
            151133698,
            151133407,
            151162997,
            151131356,
            151134494,
            151138728,
            151139132,
            151136153,
            151141865
        ],
        "D1": [
            151120822,
            151134118,
            151121251,
            151137456,
            151136457,
            151124968,
            151116539,
            151125380,
            151137042,
            151133981,
            151132184,
            151133795,
            151129157,
            151129385,
            151111426,
            151134591,
            151138886,
            151137815,
            151136213,
            151141775
        ],
        "C": [
            151112073,
            151128253,
            151116864,
            151133478,
            151123922,
            151138412,
            151133817,
            151115900,
            151129938,
            151123515,
            151127137,
            151121616,
            151119175,
            151124585,
            151140674,
            151128907,
            151118670,
            151122285,
            151130110,
            151124708
        ],
        "A": [
            151108745,
            151108766,
            151108093,
            151108539,
            151109707,
            151108138,
            151108257,
            151108228,
            151115578,
            151108352,
            151109887,
            151109318,
            151108285,
            151118389,
            151117355,
            151113770,
            151108678,
            151108356,
            151114275,
            151108304
        ],
        "B": [
            151108090,
            151111195,
            151109084,
            151117990,
            151113182,
            151110666,
            151109661,
            151112815,
            151110325,
            151119421,
            151112382,
            151112621,
            151125884,
            151123923,
            151121603,
            151111889,
            151111865,
            151121448,
            151110901
        ]
    },
    "name": "F. Juju and Binary String",
    "statement": "The of a binary string is the number of\r\ntexttt{1}s divided by the length of the string. For example, the of\r\ntexttt{01101} is\r\nfrac{3}{5}.Juju has a binary string s of length n. She wants to choose\r\nsome non-intersecting subsegments of s such that their concatenation has\r\nlength m and it has the same as the string s. More specifically, she\r\nwants to find two arrays l and r of equal length k such that 1\r\nleq l_1\r\nleq r_1 < l_2\r\nleq r_2 <\r\nldots < l_k\r\nleq r_k\r\nleq n, and also:\r\nsum\r\nlimits_{i=1}^k (r_i - l_i + 1) = m; The of s[l_1,r_1]+s[l_2,r_2]+\r\nldots+s[l_k,r_k] is equal to the of s, where s[x, y] denotes the\r\nsubsegment s_x s_{x+1}\r\nldots s_y, and + denotes string concatenation. Juju does not like\r\nsplitting the string into many parts, so she also wants to the value of\r\nk. Find the minimum value of k such that there exist l and r that\r\nsatisfy the constraints above or determine that it is impossible to find\r\nsuch l and r for any k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint sum[500005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint cnt1=0,cnt0=0;\n\t\tfor(auto t:s)\n\t\t\tcnt1+=t=='1',cnt0+=t=='0';\n\t\tcnt1*=m,cnt0*=m;\n\t\tif(cnt1%n||cnt0%n)\n\t\t{\n\t\t\tcout << \"-1\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\ts=' '+s+s;\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t{\n\t\t\tif(s[i]=='1') sum[i]=cnt0;\n\t\t\telse sum[i]=-cnt1;\n\t\t}\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t\tsum[i]+=sum[i-1];\n\t\tint pos=0;\n\t\tfor(int i=m;i<=n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << \"1\\n\";\n\t\t\tcout << pos-m+1 << \" \" << pos << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=n+1;i<=n+n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << \"2\\n\";\n\t\t\tint l=pos-m+1,r=pos;\n\t\t\tcout << 1 << \" \" << r-n << \"\\n\";\n\t\t\tcout << l << \" \" << n << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\texit(1);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Juju and Binary String.json",
    "editorial_link": "https://codeforces.com//blog/entry/101302",
    "editorial": "ObservationIt is easy to show that the cuteness of is .What is the\r\nnumber of in the concatenated string needed so that the answer exists?\r\n",
    "hint": [
        "Hint 1 Let be the number of black balls and be the number of white balls. The answer will be impossible if is not a multiple of . Observation It is easy to show that the cuteness of is . What is the number of in the concatenated string needed so that the answer exists? Proof The cuteness of is by definition. Now consider , the cuteness of the concatenated string. The cuteness of is , so the number of needed is . If is not an integer then there will be no answer, so must be a multiple of .",
        "Hint 2 We don't need more than 2 parts, or to say is needed in this problem. Observation Let (the number of in ). For convenient, from now let assume the array and string is wrapped around: and . We have and there exists for all that . Contestant's Proof GM+ smax provides a simple and clean answer here . Author's Proof Let , and we are doing with wrap around arrays for convenient. We want to prove that for any that there will be some . Let for is the minimal position that . Let is the first position starting that , we have [1] Since and, we have . [2] Since we can show that. [3] Since , we also have From [1], [2], [3], if there is then there will be for some that ."
    ]
}