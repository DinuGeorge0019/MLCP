{
    "link": "https://codeforces.com//contest/760/problem/C",
    "problemId": "89818",
    "problem_idx": "C",
    "shortId": "760C",
    "contest_number": "760",
    "problem_submissions": {
        "F": [
            24048996,
            24334592,
            24109967
        ],
        "D": [
            24042480,
            24043732,
            24050024,
            24046176,
            24044696,
            24045116,
            24042014,
            24043570,
            24047853,
            24043885,
            24739234,
            24045094,
            24044167,
            24044943,
            24049808,
            24041812,
            24045235
        ],
        "C": [
            24040885,
            24041111,
            24041193,
            24043138,
            24047007,
            24043013,
            24038951,
            24041237,
            24046096,
            24041744,
            24041798,
            24042387,
            24042705,
            24049213,
            24042229,
            24044994,
            24042730
        ],
        "B": [
            24039488,
            24039342,
            24037031,
            24040294,
            24041983,
            24041211,
            24039467,
            24039465,
            24039319,
            24038489,
            24040344,
            24039097,
            24039942,
            24040090,
            24041062
        ],
        "A": [
            24036025,
            24035890,
            24035872,
            24036889,
            24036131,
            24037811,
            24035954,
            24036348,
            24036507,
            24036069,
            24036108,
            24036146,
            24036211,
            24041066,
            24035881,
            24035886,
            24036867
        ],
        "E": [
            24050782,
            24048436,
            24049579,
            24049178,
            24050210,
            24052439,
            24072140,
            24052585,
            24324528,
            24324402,
            24048812,
            24049062,
            24108774
        ]
    },
    "name": "C. Pavel and barbecue",
    "statement": "Pavel cooks barbecue. There are skewers, they lay on a brazier in a row,\r\neach on one of positions. Pavel wants each skewer to be cooked some time\r\nin every of positions in two directions: in the one it was directed\r\noriginally and in the reversed direction.Pavel has a plan: a permutation\r\nand a sequence , consisting of zeros and ones. Each second Pavel move\r\nskewer on position to position , and if equals then he reverses it. So\r\nhe hope that every skewer will visit every position in both\r\ndirections.Unfortunately, not every pair of permutation and sequence\r\nsuits Pavel. What is the minimum total number of elements in the given\r\npermutation and the given sequence he needs to change so that every\r\nskewer will visit each of placements? Note that after changing the\r\npermutation should remain a permutation as well.There is no problem for\r\nPavel, if some skewer visits some of the placements several times before\r\nhe ends to cook. In other words, a permutation and a sequence suit him\r\nif there is an integer (), so that after seconds each skewer visits each\r\nof the placements.It can be shown that some suitable pair of permutation\r\nand sequence exists for any .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 2e5 + 100;\n\nbool vis[N];\nint p[N], b[N];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcout.tie(0); cin.tie(0);\n\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> p[i], p[i]--;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> b[i], sum += b[i];\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!vis[i]){\n\t\tcnt++;\n\t\tfor (int j = i; !vis[j]; j = p[j]) vis[j] = true;\n\t}\n\n\tint ans = cnt;\n\tif (ans == 1) ans = 0;\n\tif (sum % 2 == 0) ans++;\n\n\tcout << ans << endl;\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Pavel and barbecue.json",
    "editorial_link": "https://codeforces.com//blog/entry/49946",
    "editorial": "At first, let's deal with the permutation. We can see that p should have exactly one cycle to suit Pavel. The minimum number of changes is 0 if there is only one cycle, and the number of cycles if there is more than one cycle.\n\nWhat should we do with b? We can see that the skewers visit a particular position x in the same direction again and again if and only if the total number of ones in b is even. If the total number of ones in b is odd, then each time a skewer visits a particular position x, it has direction different from the previous time. Thus, the condition is satisfied if and only if the number of ones in b is odd. We should add 1 to the answer if it isn't.",
    "hint": []
}