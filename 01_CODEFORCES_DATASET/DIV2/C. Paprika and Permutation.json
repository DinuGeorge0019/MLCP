{
    "link": "https://codeforces.com//contest/1617/problem/C",
    "problemId": "1229932",
    "problem_idx": "C",
    "shortId": "1617C",
    "contest_number": "1617",
    "problem_submissions": {
        "D2": [
            139528258,
            139511137,
            139522542,
            139519708,
            139520670,
            139523783,
            139518761,
            139530052,
            139554537,
            139536292,
            139522659,
            139517981,
            139512155,
            139519772,
            139538893,
            139543913,
            139531998
        ],
        "E": [
            139517842,
            139538424,
            139497648,
            139535975,
            139534847,
            139545980,
            139543568,
            139544780,
            139542416,
            139541142,
            139546720,
            139613086,
            139612916
        ],
        "D1": [
            139501429,
            139511244,
            139522629,
            139519806,
            139515622,
            139513160,
            139518872,
            139525357,
            139508478,
            139513182,
            139525031,
            139501096,
            139517883,
            139503934,
            139519698,
            139505351,
            139502672,
            139513862
        ],
        "C": [
            139489946,
            139490132,
            139526014,
            139489601,
            139500619,
            139496413,
            139508980,
            139499423,
            139495044,
            139500428,
            139504938,
            139495573,
            139492326,
            139510250,
            139491535,
            139494498,
            139495193,
            139495421
        ],
        "B": [
            139486471,
            139485548,
            139527692,
            139491898,
            139493048,
            139490679,
            139500877,
            139490165,
            139489596,
            139492975,
            139498385,
            139485704,
            139488427,
            139502448,
            139486742,
            139489499,
            139488312,
            139490271
        ],
        "A": [
            139485264,
            139485036,
            139530317,
            139495566,
            139490417,
            139485662,
            139494269,
            139485815,
            139485225,
            139486039,
            139485608,
            139487143,
            139485767,
            139485406,
            139485431,
            139485561,
            139486024,
            139485975
        ]
    },
    "name": "C. Paprika and Permutation",
    "statement": "Paprika loves permutations. She has an array a_1, a_2,\r\ndots, a_n. She wants to make the array a of integers 1 to n.In order to\r\nachieve this goal, she can perform operations on the array. In each\r\noperation she can choose two integers i (1\r\nle i\r\nle n) and x (x > 0), then perform a_i := a_i\r\nbmod x (that is, replace a_i by the remainder of a_i divided by x). In\r\ndifferent operations, the chosen i and x .Determine the minimum number\r\nof operations needed to make the array a permutation of integers 1 to n.\r\nIf it is impossible, output -1.A permutation is an array consisting of n\r\ndistinct integers from 1 to n in arbitrary order. For example,\r\n[2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2\r\nappears twice in the array) and [1,3,4] is also not a permutation (n=3\r\nbut there is 4 in the array).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\t//b < a / 2\n\t\tint n;\n\t\tcin >> n;\n\t\tset<int> s;\n\t\tfor (int i = 1; i <= n; i += 1) s.insert(i);\n\t\tvector<int> v;\n\t\tfor (int i = 1, a; i <= n; i += 1) {\n\t\t\tcin >> a;\n\t\t\tif (s.contains(a)) s.erase(a);\n\t\t\telse v.push_back(a);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ok = 1;\n\t\tfor (int i = 0; int x : s)\n\t\t\tif (x * 2 >= v[i ++]) ok = 0;\n\t\tif (ok) cout << v.size() << \"\\n\";\n\t\telse cout << \"-1\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Paprika and Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/97920",
    "editorial": "SolutionKey observation: if , and if . Notice that the bigger the , the\r\nbigger the range of values that can be obtained after one operation. So,\r\nintuitively, we want to assign smaller to smaller numbers in the\r\nresulting permutation.However, if satisfies , we can just leave it there\r\nand use it in the resulting permutation (if multiple satisfy and have\r\nthe same value, just choose one). Let\u00e2\u0080\u0099s suppose in the optimal solution,\r\nwe change to and change to for some (, , are values, not indices). Then\r\nchanging to (i.e. doing nothing) and changing to uses less operation.\r\nAnd, if it is possible to change to , then it must be possible to change\r\nto . However, if it is not possible to change to , it might still be\r\npossible to change to .Therefore, the solution is as follows: Sort the\r\narray. For each element in the sorted array: If and it is the first\r\noccurrence of element with value , leave it there. Else, let the current\r\nleast unassigned value in the resulting permutation be , if , we can\r\nassign the current element to value and add the number of operations by\r\n. Else, output directly. The solution works in .\r\n"
}