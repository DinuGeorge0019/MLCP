{
    "link": "https://codeforces.com//contest/1447/problem/E",
    "problemId": "797266",
    "problem_idx": "E",
    "shortId": "1447E",
    "contest_number": "1447",
    "problem_submissions": {
        "F1": [
            98482074,
            98493054,
            99700638,
            99700288,
            98507770,
            98535197
        ],
        "E": [
            98471672,
            98487762,
            98462641,
            98467656,
            98474856,
            98475468,
            98466748,
            98471089,
            98474335,
            98473016,
            98472819,
            98475501,
            98476100,
            98473152,
            98480927,
            98480063,
            98483273,
            98472232,
            98484816
        ],
        "D": [
            98465943,
            98460161,
            98460032,
            98460272,
            98457345,
            98456392,
            98459724,
            98462491,
            98458555,
            98456607,
            98463156,
            98464783,
            98463338,
            98468636,
            98460203,
            98469147,
            98464911,
            98463572,
            98466107
        ],
        "C": [
            98461616,
            98454149,
            98456198,
            98455102,
            98451609,
            98450909,
            98449636,
            98454179,
            98454951,
            98450139,
            98456033,
            98456615,
            98452367,
            98462699,
            98462915,
            98451741,
            98459164,
            98457799,
            98456088
        ],
        "B": [
            98459424,
            98448840,
            98451090,
            98683205,
            98449593,
            98453136,
            98446655,
            98474948,
            98449629,
            98450999,
            98461566,
            98449722,
            98448167,
            106347351,
            98672986,
            98448001,
            98455222,
            98451056,
            98457032,
            98449675,
            98477349,
            98451673
        ],
        "A": [
            98453484,
            98445641,
            98444797,
            98683165,
            98445393,
            98446357,
            98444563,
            98446885,
            98447224,
            98445951,
            98458580,
            98444650,
            98444710,
            135934878,
            135934648,
            135925416,
            135925369,
            135925314,
            135925279,
            135925096,
            135925047,
            135924862,
            135924832,
            135924797,
            135924764,
            135924707,
            135924661,
            135924602,
            135924566,
            135924526,
            135924432,
            135924298,
            135924179,
            106344775,
            98672850,
            98445798,
            98445995,
            98446080,
            98454545,
            98452405,
            98445713,
            98447399
        ],
        "F2": [
            100134501,
            99704090
        ]
    },
    "name": "E. Xor Tree",
    "statement": "For a given sequence of non-negative integers (b_1, b_2,\r\ndots, b_k) we determine if it is in the following way: Consider a graph\r\non k nodes, with numbers from b_1 to b_k written on them. For every i\r\nfrom 1 to k: find such j (1\r\nle j\r\nle k, j\r\nneq i), for which (b_i\r\noplus b_j) among all such j, where\r\noplus denotes the operation of bitwise XOR\r\n(https://en.wikipedia.org/wiki/Bitwise_operationXOR). Next, draw an edge\r\nbetween vertices with numbers b_i and b_j in this graph. We say that the\r\nsequence is if and only if the resulting graph forms a (is connected and\r\ndoesn\u2019t have any simple cycles). It is possible that for some numbers\r\nb_i and b_j, you will try to add the edge between them twice.\r\nNevertheless, you will add this edge only once.You can find an example\r\nbelow (the picture corresponding to the first test case). Sequence (0,\r\n1, 5, 2, 6) good as we reach 1 from 5.However, sequence (0, 1, 5, 2)\r\ngood. You are given a sequence (a_1, a_2,\r\ndots, a_n) of non-negative integers. You would like to remove some of\r\nthe elements (possibly none) to make the sequence good. What is the\r\nminimum possible number of removals required to achieve this goal?It can\r\nbe shown that for any sequence, we can remove some number of elements,\r\nleaving at least 2, so that the remaining sequence is good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, a[200010];\nconst int W = 31;\nconst int MAXNODE = (W + 1) * 200010;\nint ch[MAXNODE][2], cnt[MAXNODE];\nint M = 1;\n\nvoid ins(int v) {\n    //printf(\"ins %d\\n\",v);\n    int now = 1;\n    cnt[1]++;\n    for (int i=W;i>=0;i--) {\n        int dir = ((v >> i) & 1);\n        int &nxt = ch[now][dir];\n        if (!nxt) nxt = ++M;\n        cnt[nxt]++;\n        now = nxt;\n        //printf(\"now = %d\\n\",now);\n    }\n}\n\nint dfs(int x) {\n    if (x == 0) return 0;\n    if (!ch[x][0] && !ch[x][1]) return 1;\n    return max(dfs(ch[x][0]) + (!!ch[x][1]), dfs(ch[x][1]) + (!!ch[x][0]));\n}\n\nint main() {\n    scanf(\"%d\",&N);\n    for (int i=1;i<=N;i++) {\n        scanf(\"%d\",&a[i]);\n    }\n    for (int i=1;i<=N;i++) {\n        ins(a[i]);\n    }\n    printf(\"%d\\n\",N - dfs(1));\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "divide and conquer",
        "dp",
        "graphs",
        "string suffix structures",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Xor Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/82067",
    "editorial": "Small hintsIs it possible that the graph formed has a cycle? How to\r\nevaluate whether a sequence is good?\r\n"
}