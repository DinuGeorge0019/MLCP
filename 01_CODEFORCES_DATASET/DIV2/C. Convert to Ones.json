{
    "link": "https://codeforces.com//contest/998/problem/C",
    "problemId": "194447",
    "problem_idx": "C",
    "shortId": "998C",
    "contest_number": "998",
    "problem_submissions": {
        "E": [
            39844279,
            39844719,
            39842563,
            39860454,
            39860368
        ],
        "D": [
            39839915,
            39841332,
            39842999,
            39838622,
            39833588,
            39834360,
            39835519,
            39835358,
            39836436,
            39839136,
            39835483,
            39834881,
            39832459,
            39838234,
            39834518,
            39836090,
            39838820,
            39836619
        ],
        "B": [
            39829464,
            39826160,
            39828535,
            39827534,
            39825326,
            39826819,
            39826965,
            39827064,
            39824985,
            39826413,
            39828466,
            39828134,
            39827004,
            39829078,
            39829375,
            39828106,
            39826996,
            39829712
        ],
        "C": [
            39826150,
            39829299,
            39830565,
            39832057,
            39827518,
            39829277,
            39828734,
            39829936,
            39831699,
            39829124,
            39832064,
            39831642,
            39829279,
            39831274,
            39831057,
            39831568,
            39830502,
            39831907
        ],
        "A": [
            39824455,
            39823644,
            39825721,
            39823552,
            39823494,
            39823346,
            39825072,
            39824102,
            39823293,
            39823771,
            39825353,
            39823995,
            39824239,
            39823343,
            39835371,
            39823495,
            39823392,
            39823469
        ]
    },
    "name": "C. Convert to Ones",
    "statement": "You’ve got a string a_1, a_2,\r\ndots, a_n, consisting of zeros and ones.Let’s call a sequence of\r\nconsecutive elements a_i, a_{i + 1},\r\nldots, a_j (1\r\nleq i\r\nleq j\r\nleq n) a of string a. You can apply the following operations any number\r\nof times: Choose some substring of string a (for example, you can choose\r\nentire string) and reverse it, paying x coins for it (for example,\r\nto ); Choose some substring of string a (for example, you can choose\r\nentire string or just one symbol) and replace each symbol to the\r\nopposite one (zeros are replaced by ones, and ones by zeros), paying y\r\ncoins for it (for example,\r\nto ). You can apply these operations in any order. It is allowed to\r\napply the operations multiple times to the same substring.What is the\r\nminimum number of coins you need to spend to get a string consisting\r\nonly of ones?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B> inline ostream& operator<<(ostream&os, const pair<A, B> &v) {return os << v.first << ' ' << v.second;}\ntemplate <typename A> inline ostream& operator<<(ostream&os, const vector<A> &v){\n    auto it = v.begin(); os << *it;for (++it; it != v.end(); os << ' ' << *it++); return os;\n}\n#ifdef Wavator\n#define de(...) cout << #__VA_ARGS__ << \" = \", W(__VA_ARGS__)\n#else\n#define de(...) 42\n#define cerr if (false) cout\n#endif\nvoid W(){cout<<endl;}\ntemplate <typename H, typename...T> inline void W(H head, T... tail){\n    cout << head << ' ';\n    W(tail...);\n}\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define per(i, a, b) for (int i = (b) - 1, i##_end_ = (a); i >= i##_end_; --i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst db eps = 1e-9, PI = acos(-1);\nconst ll mod = (ll)1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nmt19937 rnd((ull)time(0));\nll pow_mod(ll a, ll b) {\n    assert(b >= 0); ll res = 1;\n    for (a %= mod; b; b >>= 1, a = a * a % mod) if (b & 1)res = res * a % mod;\n    return res;\n}\n/////////////////////////////////////////////////////////////////////////\nvoid solve();\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    solve();\n    return 0;\n}\n\nvoid solve() {\n    int n, x, y;\n    string str;\n    cin >> n >> x >> y >> str;\n    ll cnt=0;\n    bool f=false;\n    for(auto &c: str) {\n        if(c=='0') {\n            if(!f) {\n                cnt++;\n                f=true;\n            }\n        }\n        if(c != '0')\n            f = false;\n    }\n    if(!cnt) {\n        cout << 0 << endl;\n        return;\n    }\n    cnt--;\n    ll ans = y;\n    ans += cnt * min(1ll * x, 1ll * y);\n    cout << ans << endl;\n    return;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Convert to Ones.json",
    "editorial_link": "https://codeforces.com//blog/entry/60357",
    "editorial": "Let's partite consecutive elements of the same color into groups.\n\nFor example, we will split «00011001110» into «000» + «11» + «00» + «111» + «0».\n\nThen it is obvious that it is useless to make moves within one group, and then (if we have at least two groups of color 0\n) for one move we can reduce by one (and can't reduce by two) the number of segments of color 0\n, paying for it either x\n or y\n (whatever).\n\nLet's consider, for example, if we have a string «11001100», we can flip the segment [58]\n, and turn it into a string «11000011», or, for example, invert the segment [34]\n, turning the string into «111111111100> (Then the number of color groups 0\n decreased from two to one).\n\nBut in the end you still need to do at least one inverting of the segment (which will be one at the end).\n\nThen let p\n  number of groups of color 0\n.\n\nIf p=0\n, the answer is 0\n.\n\nOtherwise, the answer is (p?1)?min(x,y)+y",
    "hint": []
}