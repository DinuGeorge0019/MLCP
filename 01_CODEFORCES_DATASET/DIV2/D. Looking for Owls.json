{
    "link": "https://codeforces.com//contest/350/problem/D",
    "problemId": "3565",
    "problem_idx": "D",
    "shortId": "350D",
    "contest_number": "350",
    "problem_submissions": {
        "E": [
            4631521,
            4627481,
            4627736,
            4628109,
            4628919,
            4627306,
            4629552,
            4630396,
            4630738,
            4630557,
            4631036,
            4630307,
            4628626,
            4630765,
            4631090,
            4631222,
            4631307
        ],
        "D": [
            4631384,
            4632639,
            4630471
        ],
        "C": [
            4623828,
            4624599,
            4624536,
            4622933,
            4624699,
            4624176,
            4626336,
            4621951,
            4625656,
            4625740,
            4626157,
            4624456,
            4625990,
            4625202,
            4624685,
            4626744,
            4623856,
            4627186
        ],
        "B": [
            4622942,
            4623430,
            4623053,
            4625927,
            4623752,
            4628716,
            4624114,
            4623578,
            4624072,
            4624239,
            4624594,
            4626727,
            4624251,
            4624259,
            4627379,
            4623391,
            4627529,
            4625315
        ],
        "A": [
            4621532,
            4621502,
            4623629,
            4621549,
            4621709,
            4622086,
            4622630,
            4621567,
            4621446,
            4621939,
            4622148,
            4623843,
            4622109,
            4621409,
            4622118,
            4621840
        ]
    },
    "name": "D. Looking for Owls",
    "statement": "Emperor Palpatine loves owls very much. The emperor has some blueprints\r\nwith the new Death Star, the blueprints contain distinct segments and\r\ndistinct circles. We will consider the segments indexed from to in some\r\nway and the circles indexed from to in some way. Palpatine defines an\r\nowl as a set of a pair of distinct circles () and one segment , such\r\nthat: circles and are symmetrical relatively to the straight line\r\ncontaining segment ; circles and don’t have any common points; circles\r\nand have the same radius; segment intersects the segment that connects\r\nthe centers of circles and . Help Palpatine, count the number of\r\ndistinct owls on the picture.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MMax=1500;\nint N,M;\ntypedef pair<pair<int,int>,long long> ltype;\ntypedef pair<vector<long long>,vector<long long> > segs;\nmap<ltype,segs> Map;\nint X[MMax],Y[MMax],R[MMax];\nlong long gcd(long long a,long long b){\n\treturn a?gcd(b%a,a):b;\n}\nltype getline(int x1,int y1,int x2,int y2){\n\tint A=x2-x1,B=y2-y1;\n\tlong long C=(long long)x1*y2-(long long)y1*x2;\n\tint g=gcd(gcd(A,B),C);\n\tA/=g;B/=g;C/=g;\n\tif (A<0){\n\t\tA=-A;\n\t\tB=-B;\n\t\tC=-C;\n\t}\n\tif (A==0 && B<0){\n\t\tB=-B;\n\t\tC=-C;\n\t}\n\treturn make_pair(make_pair(A,B),C);\n}\nlong long getpos(ltype & l,int x,int y){\n\treturn l.first.first*(long long)x+l.first.second*(long long)y;\n}\nint getsmall(vector<long long> & v,long long x){\n\treturn lower_bound(v.begin(),v.end(),x)-v.begin();\n}\nint getbig(vector<long long> &v,long long x){\n\treturn v.end()-upper_bound(v.begin(),v.end(),x);\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor (int i=0;i<N;i++){\n\t\tint x1,y1,x2,y2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tltype line=getline(x1*2,y1*2,x2*2,y2*2);\n\t\tlong long p1=getpos(line,x1*2,y1*2);\n\t\tlong long p2=getpos(line,x2*2,y2*2);\n\t\tMap[line].first.push_back(min(p1,p2));\n\t\tMap[line].second.push_back(max(p1,p2));\n\t}\n\tfor (map<ltype,segs>::iterator it=Map.begin();it!=Map.end();it++){\n\t\tsort(it->second.first.begin(),it->second.first.end());\n\t\tsort(it->second.second.begin(),it->second.second.end());\n\t}\n\tfor (int i=0;i<M;i++)\n\t\tscanf(\"%d%d%d\",X+i,Y+i,R+i);\n\tlong long ret=0;\n\tfor (int i=0;i<M;i++)\n\t\tfor (int j=0;j<i;j++)\n\t\t\tif (R[i]==R[j] && (X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j])>4*R[i]*R[i]){\n\t\t\t\tint mx=X[i]+X[j],my=Y[i]+Y[j];\n\t\t\t\tltype line=getline(\n\t\t\t\t\tmx+(Y[j]-Y[i]),my-(X[j]-X[i]),\n\t\t\t\t\tmx-(Y[j]-Y[i]),my+(X[j]-X[i]));\n\t\t\t\tmap<ltype,segs>::iterator it=Map.find(line);\n\t\t\t\tif (it!=Map.end()){\n\t\t\t\t\tlong long pos1=getpos(line,X[i]*2,Y[i]*2);\n\t\t\t\t\tlong long pos2=getpos(line,X[j]*2,Y[j]*2);\n\t\t\t\t\tif (pos1!=pos2)\n\t\t\t\t\t\tputs(\"WA\");\n\t\t\t\t\tret+=it->second.first.size()-getsmall(it->second.second,min(pos1,pos2))-getbig(it->second.first,max(pos1,pos2));\n\t\t\t\t}\n\t\t\t}\n\tcout<<ret<<endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "geometry",
        "hashing",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Looking for Owls.json",
    "editorial_link": "https://codeforces.com//blog/entry/9042",
    "editorial": "Itâs possible to solve this problem by using only integer calculations.\r\nNormalization of the line is following operation: we multiply our\r\nequation on the value , where , if then equals to , else sgn equals to .\r\nNow the solution. We will have two maps (map<> in ++, TreeMap(HashMap)\r\nin Java) to a set of points (itâs possible that some points will have\r\nmultiply occurrence into the set). In first map we will store right\r\nboundaries of the segments, in second left boundaries (in increasing\r\norder). In advance for every segment we will build a normalized line,\r\nand for this normalized line we will put in our maps left and right\r\nsegments of the segment. After all, for every fixed line letâs sort our\r\nsets. Letâs fix two different circles. After that, letâs check that\r\ndistance beetween them is greater then sum their radiuses, also you\r\nshould check that circles has same radius. We can assume that we builded\r\na line between centers of circles and . Perpendicular to this line will\r\nhave next coefficients (center of the segment also will belong to the\r\nnext line) , , . After that you need to calculate values , by using\r\nbinary search on set of points that lie on this line. amount of left\r\nboundaries that lie on the right side of point , â amount of right\r\nboundaries that lie on the left side of the point . After that you\r\nshould add to answer value ,l where amount of segments, that lie on the\r\nnolmalized line. Total complexity: . solution: 4632546\r\n",
    "hint": []
}