{
    "link": "https://codeforces.com//contest/1670/problem/E",
    "problemId": "1390325",
    "problem_idx": "E",
    "shortId": "1670E",
    "contest_number": "1670",
    "problem_submissions": {
        "E": [
            156100998,
            156104485,
            156108916,
            156107756,
            156100648,
            156100656,
            156115463,
            156115332,
            156106434,
            156105992,
            156106756,
            156102783,
            156095228,
            156095823,
            156107708,
            156123887
        ],
        "D": [
            156095484,
            156091337,
            156102106,
            156097049,
            156094743,
            156093318,
            156097826,
            156112660,
            156093899,
            156099166,
            156101898,
            156095357,
            156101001,
            156110723,
            156092669,
            156094972,
            156093548,
            156098200
        ],
        "B": [
            156093818,
            156081627,
            156082334,
            156089012,
            156085695,
            156086167,
            156087956,
            156081931,
            156124817,
            156088947,
            156092504,
            156086895,
            156084557,
            156119888,
            156124153,
            156082723,
            156086168,
            156084111,
            156087742
        ],
        "F": [
            156092264,
            156098593,
            156099277,
            156103760,
            156113156,
            156116884,
            156103788,
            156096373,
            156116972,
            156112838,
            156904481,
            156114948,
            156119689,
            156110847,
            156129976,
            156106292,
            156119874,
            156103026,
            156115147,
            156111724,
            156108733
        ],
        "C": [
            156085904,
            156084420,
            156090953,
            156093920,
            156089470,
            156090841,
            156091539,
            156092125,
            156083813,
            156094804,
            156089625,
            156091655,
            156117087,
            156087179,
            156096140,
            156089472,
            156123873,
            156087762,
            156092456
        ],
        "A": [
            156079702,
            156080088,
            156079627,
            156079602,
            158677746,
            156079680,
            156081873,
            156080010,
            156079669,
            156079762,
            156080064,
            156079483,
            156080211,
            156085709,
            156079540,
            156080023,
            156096396,
            156080412,
            156082179
        ]
    },
    "name": "E. Hemose on the Tree",
    "statement": "You are given a tree of n vertices where n is a power of 2. You have to\r\ngive each node and edge an integer value in the range [1,2n -1]\r\n(inclusive), where all the values are distinct.After giving each node\r\nand edge a value, you should select some root for the tree such that the\r\nmaximum cost of any simple path starting from the root and ending at any\r\nis minimized.The cost of the path between two nodes u and v or any node\r\nu and edge e is defined as the bitwise XOR of all the node\u2019s and edge\u2019s\r\nvalues between them, including the endpoints (note that in a tree there\r\nis only one simple path between two nodes or between a node and an\r\nedge).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector <pair<int,int> > e[500005];\nint n;\nint a[500005],id[500005],dep[500005],b[500005];\ninline void dfs(int u,int f)\n{\n\tfor(auto x:e[u])\n\t{\n\t\tint v=x.first,i=x.second;\n\t\tif(v==f) continue;\n\t\tid[v]=i,dep[v]=dep[u]+1,dfs(v,u);\n\t}\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tcin >> n;\n\t\tn=1<<n;\n\t\tfor(int i=1;i<=n;i++) e[i].clear(),dep[i]=0,a[i]=b[i]=0,id[i]=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tcin >> u >> v;\n\t\t\te[u].push_back({v,i});\n\t\t\te[v].push_back({u,i}); \n\t\t}\n\t\tdfs(1,0);\n\t\tcout << 1 << \"\\n\";\n\t\ta[1]=n;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\ta[i]=i-1,b[id[i]]=i-1+n;\n\t\t\tif(dep[i]%2==0) swap(a[i],b[id[i]]);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcout << a[i] << \" \";\n\t\tcout << \"\\n\";\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout << b[i] << \" \";\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hemose on the Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/102579",
    "editorial": "Let\u00e2\u0080\u0099s look at the minimum maximum value that we can get if we have an\r\narray of numbers from and we are trying to get any prefix xor, the\r\nanswer will be because you can stop at the first integer that will have\r\nthe bit so the answer will be . We can apply the same concept here, for\r\nany arrangement we can start at the root and stop at the first node/edge\r\nthat has the bit on. Let\u00e2\u0080\u0099s try to find a construction that will make our\r\nanswer always . This is one of the valid ways. Select an arbitrary root.\r\nPut at the root. Create pairs from the remaining numbers of the form\r\nwhere For every node we will do the following: If its parent has the bit\r\nin its value the node will take the value and the edge to the parent\r\nwill take . If its parent doesn\u00e2\u0080\u0099t have the bit in its value the node\r\nwill take the value and the edge to the parent will take . Using this\r\nconstruction you will find that the xor value form the root will\r\nalternate between and and which is always .\r\n"
}