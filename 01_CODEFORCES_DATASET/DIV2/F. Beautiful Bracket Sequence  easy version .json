{
    "link": "https://codeforces.com//contest/1265/problem/F",
    "problemId": "486714",
    "problem_idx": "F",
    "shortId": "1265F",
    "contest_number": "1265",
    "problem_submissions": {
        "F": [
            66347509,
            66356863,
            66557730,
            66442620,
            66596419
        ],
        "D": [
            66340623,
            66367551,
            66338719,
            66334115,
            66337781,
            66335412,
            66337141,
            66346278,
            66339422,
            66338547,
            66341148,
            66339217,
            66340066,
            66341959,
            66331621,
            66342018,
            66346489,
            66340801,
            66342356,
            66342319,
            66343587
        ],
        "E": [
            66334163,
            66342621,
            66338591,
            66341637,
            66343875,
            66343996,
            66335345,
            66344209,
            66345114,
            66344975,
            66347923,
            66349901,
            66349558,
            66353633,
            66348910,
            66344231,
            66352728,
            66349177,
            66344898,
            66345749
        ],
        "C": [
            66327706,
            66330775,
            66334663,
            66328752,
            66329873,
            66333663,
            66331630,
            66332247,
            66329421,
            66334491,
            66334922,
            66330433,
            66331509,
            66336687,
            66333340,
            66334139,
            66330672,
            66335469,
            66331275,
            66338262
        ],
        "B": [
            66327279,
            66324231,
            66324702,
            66323571,
            66323717,
            66325187,
            66324433,
            66325466,
            66331477,
            66327697,
            66323823,
            66325202,
            66325641,
            66327180,
            66324867,
            66325852,
            66324365,
            66328628,
            66324650,
            66332154
        ],
        "A": [
            66323436,
            66367023,
            66322763,
            66325795,
            66322545,
            66322720,
            66322849,
            66322611,
            66322846,
            66324460,
            66323395,
            66326356,
            66322526,
            66323577,
            66323841,
            66322634,
            66323094,
            66322910,
            66325754,
            66323461,
            66323023
        ]
    },
    "name": "F. Beautiful Bracket Sequence  easy version ",
    "statement": "Let’s define a correct bracket sequence and its depth as follow: An\r\nempty string is a correct bracket sequence with depth 0. If \"\" is a\r\ncorrect bracket sequence with depth d then \"\" is a correct bracket\r\nsequence with depth d + 1. If \"\" and \"\" are both correct bracket\r\nsequences then their concatenation \"\" is a correct bracket sequence with\r\ndepth equal to the maximum depth of s and t. For a (not necessarily\r\ncorrect) bracket sequence s, we define its depth as the maximum depth of\r\nany bracket sequence induced by removing some characters from s\r\n(possibly zero). For example: the bracket sequence s = \"\" has depth 2,\r\nbecause by removing the third character we obtain a correct bracket\r\nsequence \"\" with depth 2.Given a string a consists of only characters ”,\r\n” and ”. Consider all (not necessarily correct) bracket sequences\r\nobtained by replacing all characters ” in a by either ” or ”. Calculate\r\nthe sum of all the depths of all these bracket sequences. As this number\r\ncan be large, find it modulo 998244353. in this problem in the first\r\ndivision can be done only if easy and hard versions of this problem was\r\nsolved.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<ctime>\nusing namespace std;\n#define ll long long\n#define pb(x) push_back(x)\n#define mp(a,b) make_pair(a,b)\n#define fi first\n#define se second\n#define pr(x) cerr<<#x<<\"=\"<<(x)<<endl\n#define pri(x,lo) {cerr<<#x<<\"={\";for (int ol=0;ol<=lo;ol++)cerr<<x[ol]<<\",\";cerr<<\"}\"<<endl;}\n#define inf 100000000\n#define N 2010\n#define md 998244353\nchar ch[N];\nint i,j,n,g[N][N],f[N][N],ans;\nint main()\n{\n\tscanf(\"%s\",ch+1);\n\tn=strlen(ch+1);\n\tfor (i=0;i<=n+1;i++)\n\t{\n\t\tif (ch[i]=='(') break;\n\t\tf[i][0]=1;\n\t}\n\tfor (i=n+1;i>=1;i--)\n\t{\n\t\tif (ch[i]==')') break;\n\t\tg[i][0]=1;\n\t}\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=i;j++)\n\t\t{\n\t\t\tif (ch[i]=='(') f[i][j]=f[i-1][j-1];\n\t\t\telse if (ch[i]==')') f[i][j]=f[i-1][j];\n\t\t\telse f[i][j]=(f[i-1][j]+f[i-1][j-1])%md;\n\t\t}\n\tfor (i=n;i>=1;i--)\n\t\tfor (j=1;j<=n-i+1;j++)\n\t\t{\n\t\t\tif (ch[i]==')') g[i][j]=g[i+1][j-1];\n\t\t\telse if (ch[i]=='(') g[i][j]=g[i+1][j];\n\t\t\telse g[i][j]=(g[i+1][j]+g[i+1][j-1])%md;\n\t\t//\tprintf(\"g[%d][%d]=%d\\n\",i,j,g[i][j]);\n\t\t}\n\tfor (i=1;i<n;i++)\n\t{\n\t\tfor (j=1;j<=min(i,n-i);j++)\n\t\t{\n\t\t\tans+=1ll*f[i][j]*g[i+1][j]%md*j%md;\n\t\t\tans%=md;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Beautiful Bracket Sequence  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/71995",
    "editorial": "We calculate the depth of a sequence as follow: Let two pointers at each\r\nend of the sequence. If character at the left pointer is â, we move the\r\nleft pointer one position to the right. If character at the right\r\npointer is â, we move the right pointer one position to the left. If the\r\ncharacter at the left pointer is â and the right pointer is â we\r\nincrease our result and move the left pointer to the right and the right\r\none to the left each with one position. We repeat while the left one is\r\nat the left of the right one. After that, we can use dynamic programming\r\nto solve the problem. Let be total number of depth of all sequences\r\ninduced by subsequence . We have following transitives: if â. if â. if â\r\nand â. if â and â, where is the number of â character in .\r\n",
    "hint": []
}