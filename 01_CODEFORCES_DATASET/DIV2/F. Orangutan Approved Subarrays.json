{
    "link": "https://codeforces.com//contest/2030/problem/F",
    "problemId": "2962993",
    "problem_idx": "F",
    "shortId": "2030F",
    "contest_number": "2030",
    "problem_submissions": {
        "D": [
            286870605,
            286870097,
            286766067,
            286743790,
            286749704,
            286752517,
            286743540,
            286763694,
            286769489,
            286762215,
            286755968,
            286807582,
            286774479,
            286755264,
            286748829,
            286762354,
            286767397,
            286766307,
            286775817,
            286773805,
            286867460,
            286806694,
            286757030
        ],
        "C": [
            286860734,
            286764785,
            286775512,
            286732737,
            286735870,
            286731279,
            286736529,
            286759035,
            286741312,
            286740209,
            286770332,
            286732276,
            286730948,
            286749099,
            286748589,
            286737019,
            286738816,
            286732618,
            286746919,
            286735952,
            286744382
        ],
        "B": [
            286858184,
            286726117,
            286721582,
            286722000,
            286722997,
            286722179,
            286731090,
            286742656,
            286728669,
            286721456,
            286721616,
            286722634,
            286723485,
            286723817,
            286722712,
            286723090,
            286725291,
            286719819,
            286727047,
            286721215,
            286722880
        ],
        "A": [
            286857205,
            286716570,
            286716508,
            286717068,
            286716187,
            286716722,
            286727391,
            286716522,
            286715165,
            286715628,
            286715445,
            286716659,
            286717260,
            286715083,
            286717340,
            286715258,
            286718621,
            286715888,
            286722488,
            286715834,
            286716388
        ],
        "G1": [
            286855127,
            286854605,
            287072911,
            286866647
        ],
        "F": [
            286768609,
            286793091,
            286802410,
            286804764,
            286807723,
            286808203,
            286799478,
            286806636,
            286814242,
            286786481,
            286811066,
            286813827,
            286813676,
            286816754,
            286814190,
            286813606,
            286813682,
            286795825,
            286808765,
            286817519
        ],
        "E": [
            286766337,
            286759349,
            286779444,
            286786742,
            286788454,
            286791781,
            286783999,
            286800776,
            286780259,
            286764648,
            286793854,
            286792948,
            286789703,
            286779768,
            286799721,
            286794191,
            286791806,
            286816988,
            286786381,
            286789315
        ],
        "G2": [
            287138384
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135218",
    "editorial": "Problem Credits: Proof_by_QED, satyam343 Analysis: Proof_by_QED Solution\r\nFirst, let\u00e2\u0080\u0099s try to find whether a single array is orangutan-approved or\r\nnot.Claim: The array of size is not orangutan-approved if and only if\r\nthere exists indices such that , , and .Proof: Let\u00e2\u0080\u0099s prove this with\r\nstrong induction. For , the claim is true because the empty array is\r\norangutan-approved. Now, let\u00e2\u0080\u0099s suppose that the claim is true for all .\r\nNow, let be a sorted sequence such that is in if and only if . Suppose\r\nis length . We can split the array into disjoint subarrays such that is\r\nthe subarray for all and That is, is the subarray that lies between each\r\noccurrence of in the array .First, we note that the set of unique\r\nelements of and cannot contain any elements in common for all . This is\r\nbecause suppose that there exists and such that and the set of unique\r\nvalues in and both contain . Then, in the original array , there must\r\nexist a subsequence . This makes our premise false.By our inductive\r\nclaim, each of the arrays must be orangutan-approved. Since there are no\r\noverlapping elements, we may delete each of the arrays separately.\r\nFinally, the array is left with copies of , and we can use one operation\r\nto delete all remaining elements in the array .Now, how do we solve for\r\nall queries? First, precompute the array , which is the array containing\r\nfor each the largest index such that . Let\u00e2\u0080\u0099s then use two pointers to\r\ncompute the last element such that is orangutan-approved but is not, and\r\nstore this in an array called . Let\u00e2\u0080\u0099s also keep a maximum segment tree\r\nsuch that is the first element such that . As we sweep from to , we do\r\nthe following: Set Otherwise, while and ), increment by . Set When the\r\narray is fully calculated, we can solve each query in .\r\n",
    "name": "F. Orangutan Approved Subarrays",
    "statement": "Suppose you have an array b. Initially, you also have a set S that\r\ncontains all distinct elements of b. The array b is called if it can be\r\nby repeatedly performing the following operation: In one operation,\r\nselect indices l and r (1\r\nleq l\r\nleq r\r\nleq |b|) such that v = b_l = b_{l+1} =\r\nldots = b_r and v is present in S. Remove v from S, and simultaneously\r\nremove all b_i such that l\r\nleq i\r\nleq r. Then, reindex the elements b_{r+1}, b_{r+2},\r\nldots as b_l, b_{l+1},\r\nldots accordingly. You are given an array a of length n and q queries.\r\nEach query consists of two indices l and r (1\r\nle l\r\nle r\r\nle n), and you need to determine whether or not the subarray a_{l},\r\na_{l+1},\r\nldots, a_r is .\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;\u00a0using ll = long long;using vi = vector<int>;\u00a0#define endl '\\n'#define pb emplace_back#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()#define make_unique(x) sort(all(x)), x.resize(unique(all(x)) - begin(x))#define debug(x) cerr << \"[\" << __LINE__ << \"] \"#x\" = \" << (x) << endl\u00a0template<typename X> using vc = vector<X>;template <class Info, class Tag>class SegmentTree {/********************************  Coded: 2024.08.01*  Author: jhs430*  TL: 100000 -> 150ms*  init O(n)*  modify, update O(log n)*  get O(log n)*  findFirst, findLast O(log n)*  Space Complexity O(n) x3*******************************/public:\tvoid init(int _n = 0, const Info& _init = Info{}) {\t\tinit(vc<Info>(_n, _init));\t}\tvoid init(const vc<Info>& _init) {\t\tn = _init.size();\t\tif (!n) return;\t\tv.assign(4 << __lg(n), Info{});\t\td.assign(4 << __lg(n), Tag{});\t\tbuild(1, 0, n, _init);\t}\tvoid modify(int k, const Info& dd) { modify(1, 0, n, k, dd); } // a[k] = dd\tvoid update(int l, int r, const Tag& dd) { updateRange(1, 0, n, l, r, dd); }\tvoid update(int k, const Tag& dd) { updateRange(1, 0, n, k, k + 1, dd); }\tInfo get(int l, int r) { return getRange(1, 0, n, l, r); }\tInfo get(int k) { return getRange(1, 0, n, k, k + 1); }\tint findFirst(int l, int r, const function<bool(Info)>& op) { return findFirst(1, 0, n, l, r, op); }\tint findLast(int l, int r, const function<bool(Info)>& op) { return findLast(1, 0, n, l, r, op); }\tint size() { return n; }\tprivate:\tint n;\tvc<Info> v;\tvc<Tag> d;\tvoid up(int u) {\t\tv[u] = v[u << 1] + v[u << 1 | 1];\t}\tvoid apply(int u, const Tag& dd) {\t\tv[u].apply(dd);\t\td[u].apply(dd);\t}\tvoid down(int u) {\t\tapply(u << 1, d[u]);\t\tapply(u << 1 | 1, d[u]);\t\td[u] = Tag();\t}\tvoid build(int u, int st, int en, const vc<Info>& _init) {\t\td[u] = Tag{};\t\tif (st == en - 1) {\t\t\tv[u] = _init[st];\t\t\treturn;\t\t}\t\tint md = st + en >> 1;\t\tbuild(u << 1, st, md, _init);\t\tbuild(u << 1 | 1, md, en, _init);\t\tup(u);\t}\tvoid updateRange(int u, int st, int en, int l, int r, const Tag& dd) {\t\tif (r <= st || en <= l) return;\t\tif (l <= st && en <= r) {\t\t\tapply(u, dd);\t\t\treturn;\t\t}\t\tint md = st + en >> 1;\t\tdown(u);\t\tif (l < md) updateRange(u << 1, st, md, l, r, dd);\t\tif (r > md) updateRange(u << 1 | 1, md, en, l, r, dd);\t\tup(u);\t}\tvoid modify(int u, int st, int en, int k, const Info& dd) {\t\tif (k < st || en <= k) return;\t\tif (st == en - 1) {\t\t\tv[u] = dd;\t\t\treturn;\t\t}\t\tint md = st + en >> 1;\t\tdown(u);\t\tif (k < md) modify(u << 1, st, md, k, dd);\t\telse modify(u << 1 | 1, md, en, k, dd);\t\tup(u);\t}\tInfo getRange(int u, int st, int en, int l, int r) {\t\tif (r <= st || en <= l) return Info{};\t\tif (l <= st && en <= r) return v[u];\t\tint md = st + en >> 1;\t\tdown(u);\t\tif (r <= md) return getRange(u << 1, st, md, l, r);\t\tif (l >= md) return getRange(u << 1 | 1, md, en, l, r);\t\treturn getRange(u << 1, st, md, l, r) + getRange(u << 1 | 1, md, en, l, r);\t}\tint findFirst(int u, int st, int en, int l, int r, const function<bool(Info)>& op) {\t\tif (r <= st || en <= l || !op(v[u])) return -1;\t\tif (st == en - 1) return st;\t\tint md = st + en >> 1;\t\tdown(u);\t\tint ret = findFirst(u << 1, st, md, l, r, op);\t\tif (ret == -1) ret = findFirst(u << 1 | 1, md, en, l, r, op);\t\treturn ret;\t}\tint findLast(int u, int st, int en, int l, int r, const function<bool(Info)>& op) {\t\tif (r <= st || en <= l || !op(v[u])) return -1;\t\tif (st == en - 1) return st;\t\tint md = st + en >> 1;\t\tdown(u);\t\tint ret = findLast(u << 1 | 1, md, en, l, r, op);\t\tif (ret == -1) ret = findLast(u << 1, st, md, l, r, op);\t\treturn ret;\t}};\u00a0struct Tag {\tvoid apply(const Tag& dd) { // down Operator\t}};struct Info {\tint mn = INT_MAX;\tvoid apply(const Tag& dd) { // down Operator\t}};Info operator + (Info a, Info b) { // up Operator\tif (a.mn > b.mn) a.mn = b.mn;\treturn a;}SegmentTree<Info, Tag> ST;\u00a0void solve() {    int n, k;    cin >> n >> k;    vector<int> a(n);    for (int i = 0; i < n; i ++) cin >> a[i];    ST.init(n);    vector<int> maxr(n);    int cu = 0;    vector pos(n + 1, vector<int>(0));    vector cp(n + 1, 0);    for (int i = 0; i < n; i ++) {        while (cu < n) {            if (pos[a[cu]].size() == cp[a[cu]]) {                pos[a[cu]].push_back(cu);                ST.modify(cu, {cu});                cu ++;            } else {                int l = pos[a[cu]][cp[a[cu]]];                int r = cu;                if (ST.get(l, r).mn < l) break;                ST.modify(pos[a[cu]].back(), {INT_MAX});                pos[a[cu]].push_back(cu);                ST.modify(r, {l});                cu ++;            }        }        maxr[i] = cu;        if (pos[a[i]].size() == cp[a[i]] + 1) {            ST.modify(pos[a[i]].back(), {INT_MAX});            cp[a[i]] ++;        } else {            cp[a[i]] ++;            ST.modify(pos[a[i]].back(), {pos[a[i]][cp[a[i]]]});        }    }    while (k --) {        int l, r;        cin >> l >> r;        l --;        if (r <= maxr[l]) cout << \"YES\" << endl;        else cout << \"NO\" << endl;    }}\u00a0int main() {#ifndef ONLINE_JUDGE\tfreopen(\"in.txt\", \"r\", stdin);//\tfreopen(\"out.txt\", \"w\", stdout);#endif\u00a0\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\u00a0\tint tc = 1;\tcin >> tc;\twhile (tc --) solve();\u00a0\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Orangutan Approved Subarrays.json"
}