{"link": "https://codeforces.com//contest/224/problem/C", "problemId": "1793", "problem_idx": "C", "shortId": "224C", "contest_number": "224", "problem_submissions": {"E": [2198165, 2196819, 2198259, 2236128, 2197194, 2200952, 2199765, 2195540, 2194183, 2196229], "C": [2195830, 2191477, 2193694, 2193617, 2194313, 2194223, 2191815, 2195143, 2193986, 2195829, 2195362], "D": [2194352, 2195373, 2196141, 2197876, 2197375, 2196987, 2196590, 2197417, 2196810, 2194187], "B": [2190018, 2189879, 2191189, 2191665, 2190694, 2191086, 2195134, 2190875, 2194168, 2191594, 2190136, 2191734, 2190832, 2194600, 2190752, 2190993], "A": [2189231, 2189100, 2189357, 2190553, 2189190, 2189439, 2189115, 2189932, 2190812, 2189456, 2189202, 2189505, 2195692, 2189110, 2189926, 2189167]}, "name": "C. Bracket Sequence", "statement": "A is a string, containing only characters \"\", \"\", \"\" and \"\".A is a\r\nbracket sequence that can be transformed into a correct arithmetic\r\nexpression by inserting characters \"\" and \"\" between the original\r\ncharacters of the sequence. For example, bracket sequences \"\", \"\" are\r\ncorrect (the resulting expressions are: \"\", \"\"), and \"\" and \"\" are not.\r\nA of string (where is the length of string ) is the string . .You are\r\ngiven a bracket sequence, not necessarily correct. Find its substring\r\nwhich is a correct bracket sequence and contains as many opening square\r\nbrackets as possible.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#define Eo(x) {cerr << #x << \" = \" << (x) << endl;}\n#define E(x) {cerr << #x << \" = \" << (x) << ' ';}\n#define mp make_pair\n\nusing namespace std;\nconst int N = 100005;\nchar data[N];\n\nvector<pair<char,int> > st;\nint bestcnt = -1, beststart = -1, bestend = -1;\nint ending[N];\n\nvoid clr(int pos){\n\tst.clear();\n\tst.push_back(make_pair('*',pos-1));\n}\n\nint cntit(int from, int to){\n\tint res = 0;\n\tfor (int i=from; i<=to; ++i){\n\t\tif (data[i] == '[') ++res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%100003s\", data);\n\tint l = strlen(data);\n\n\tclr(0);\n\tfor (int i=0; i<l; ++i){\n\t\tswitch (data[i]){\n\t\t\tcase '(': st.push_back(mp(data[i],i)); break;\n\t\t\tcase '[': st.push_back(mp(data[i],i)); break;\n\t\t\tcase ')': if (st.back().first == '('){\n\t\t\t\t\t  st.pop_back();\n\t\t\t\t\t  ending[st.back().second+1] = i;\n\t\t\t\t  } else {\n\t\t\t\t\t  clr(i+1);\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\tcase ']': if (st.back().first == '['){\n\t\t\t\t\t  st.pop_back();\n\t\t\t\t\t  ending[st.back().second+1] = i;\n\t\t\t\t  } else {\n\t\t\t\t\t  clr(i+1);\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\tdefault: cerr<<i<<endl; assert(0); break;\n\t\t}\n\t}\n\n\tfor (int i=0; i<l; ++i){\n\t\tint e = ending[i];\n\t\tif (e){\n\t\t\tint cnt = cntit(i, e);\n\t\t\tif (cnt > bestcnt){\n\t\t\t\tbestcnt = cnt;\n\t\t\t\tbeststart = i;\n\t\t\t\tbestend = e;\n\t\t\t}\n\t\t\ti = e;\n\t\t}\n\t}\n\n\tif (bestcnt == -1){\n\t\tprintf(\"%d\\n\\n\", 0);\n\t} else {\n\t\tdata[bestend+1] = '\\0';\n\t\tprintf(\"%d\\n%s\\n\", bestcnt, data+beststart);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "1700", "interactive": false}