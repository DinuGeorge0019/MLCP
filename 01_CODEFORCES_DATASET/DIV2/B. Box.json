{"link": "https://codeforces.com//contest/1262/problem/B", "problemId": "479738", "problem_idx": "B", "shortId": "1262B", "contest_number": "1262", "problem_submissions": {"F1": [65643346, 65653823, 65643705, 65644730, 65690605, 65651588, 65651277, 66034817, 65646761, 65654524, 65651505, 65653937, 65645081, 65645973, 65647100, 65654475, 65687063, 65647622, 65647339, 65645959], "F2": [65643279, 65653692, 65828965, 65686253, 65649254, 65653062, 65651757, 71816951, 71815917, 71815485, 71815448, 71815068, 71814941, 71814802, 65654320, 65687047, 65652597, 65652697, 65651173], "E": [65639530, 65645042, 65648892, 65652057, 65690596, 65647275, 65647634, 65653097, 65651461, 65648284, 65647900, 97249054, 97246746, 65648360, 65650087, 65951237, 65651779], "D1": [65634593, 65638676, 65638313, 65637479, 65640274, 65640849, 65636529, 65639533, 65642238, 65648533, 65640691, 65638549, 65642536, 65639709, 65635698, 65639724, 65643528, 65642432, 65642224, 65638684], "D2": [65634523, 65638577, 65638418, 65637413, 65640211, 65640949, 65642851, 65639443, 65642574, 65642451, 65640796, 65638763, 65642667, 65639589, 65635638, 65639633, 65643328, 65643512, 65642176, 65638616], "C": [65629762, 65634294, 65634237, 65633719, 65632321, 65635540, 65633375, 65635292, 65633541, 65633864, 65634698, 65633061, 65637189, 65634072, 65640938, 65633298, 65638202, 65638218, 65637587, 65633967], "B": [65627254, 65629631, 65628216, 65627679, 65628556, 65630807, 65628279, 65630765, 65628901, 65628780, 65629802, 65628147, 65626929, 65628945, 65629119, 65627530, 65632823, 65631394, 65633894, 65629398], "A": [65626237, 65626820, 65626466, 65626311, 65627028, 65627733, 65626343, 65627142, 65629675, 65626752, 65627572, 65626402, 65628146, 65626239, 65626787, 65626257, 65626896, 65628642, 65626213, 65626672]}, "name": "B. Box", "statement": "p is a sequence of integers p=[p_1, p_2,\r\ndots, p_n], consisting of n distinct (unique) positive integers between\r\n1 and n, inclusive. For example, the following sequences are\r\npermutations: [3, 4, 1, 2], [1], [1, 2]. The following sequences are not\r\npermutations: [0], [1, 2, 1], [2, 3], [0, 1, 2].The important key is in\r\nthe locked box that you need to open. To open the box you need to enter\r\nsecret code. Secret code is a permutation p of length n. You don\u2019t know\r\nthis permutation, you only know the array q of prefix maximums of this\r\npermutation. Formally: q_1=p_1, q_2=\r\nmax(p_1, p_2), q_3=\r\nmax(p_1, p_2,p_3), ... q_n=\r\nmax(p_1, p_2,\r\ndots,p_n). You want to construct any possible suitable permutation (i.e.\r\nany such permutation, that calculated q for this permutation is equal to\r\nthe given array).\r\n", "solutions": ["//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        set<int> poss;\n        rep(i, 0, n) {\n            poss.insert(i + 1);\n        }\n        vector<int> ans;\n        int cur = 0;\n        bool ok = true;\n        vector<int> a(n);\n        rep(i, 0, n) {\n            cin >> a[i];\n        }\n        rep(i, 0, n) {\n            int x = a[i];\n            if (x > cur) {\n                if (!poss.count(x)) {\n                    ok = false;\n                    break;\n                }\n                ans.push_back(x);\n                poss.erase(x);\n                cur = x;\n            } else {\n                int v = *poss.begin();\n                if (v <= x) {\n                    ans.push_back(v);\n                    poss.erase(v);\n                } else {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            cout << -1 << \"\\n\";\n        } else {\n            for (int i : ans) {\n                cout << i << \" \";\n            }\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1200", "interactive": false}