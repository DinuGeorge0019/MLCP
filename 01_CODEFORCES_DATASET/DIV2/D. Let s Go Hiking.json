{
    "link": "https://codeforces.com//contest/1496/problem/D",
    "problemId": "920583",
    "problem_idx": "D",
    "shortId": "1496D",
    "contest_number": "1496",
    "problem_submissions": {
        "F": [
            109600097,
            109581929,
            109701845,
            109708534
        ],
        "E": [
            109587933,
            109610222,
            109608454,
            109612058,
            109612949,
            109605701,
            109611256,
            109601895,
            109607479,
            109590869,
            109581873,
            109617376,
            109612836,
            109603776,
            109607771,
            109615091,
            109621693,
            109607007,
            109612110
        ],
        "D": [
            109574269,
            109586906,
            109615783,
            109591994,
            109595781,
            109595004,
            109597342,
            109595134,
            109597199,
            109607603,
            109613355,
            109601453,
            109603848,
            109608996,
            109594798,
            109603592,
            109595206,
            109599096,
            109606151
        ],
        "C": [
            109563290,
            109569588,
            109622116,
            109569355,
            109568236,
            109577979,
            109569127,
            109575607,
            109576268,
            109595113,
            109564920,
            109572405,
            109579560,
            109574270,
            109579379,
            109566209,
            109579522,
            109590691,
            109576003
        ],
        "B": [
            109560788,
            109561989,
            109564644,
            109562884,
            109568206,
            109558921,
            109564927,
            109564756,
            109563955,
            109591099,
            109565717,
            109571876,
            109565751,
            109575174,
            110006204,
            109577208,
            109569275,
            109582678,
            109569576
        ],
        "A": [
            109557542,
            109557346,
            109557850,
            109557700,
            109558786,
            109562504,
            109557384,
            109557861,
            109558109,
            109557501,
            109558770,
            109559819,
            109560297,
            109564819,
            110006201,
            109569370,
            109558966,
            109557973,
            109559619
        ]
    },
    "name": "D. Let s Go Hiking",
    "statement": "On a weekend, Qingshan suggests that she and her friend Daniel go\r\nhiking. Unfortunately, they are busy high school students, so they can\r\nonly go hiking on scratch paper.A permutation p is written from left to\r\nright on the paper. First Qingshan chooses an integer index x (1\r\nle x\r\nle n) and tells it to Daniel. After that, Daniel chooses another integer\r\nindex y (1\r\nle y\r\nle n, y\r\nne x).The game progresses turn by turn and as usual, Qingshan moves\r\nfirst. The rules follow: If it is Qingshan\u2019s turn, Qingshan must change\r\nx to such an index x\u2019 that 1\r\nle x\u2019\r\nle n, |x\u2019-x|=1, x\u2019\r\nne y, and p_{x\u2019}<p_x at the same time. If it is Daniel\u2019s turn, Daniel\r\nmust change y to such an index y\u2019 that 1\r\nle y\u2019\r\nle n, |y\u2019-y|=1, y\u2019\r\nne x, and p_{y\u2019}>p_y at the same time. The person who can\u2019t make her or\r\nhis move loses, and the other wins. You, as Qingshan\u2019s fan, are asked to\r\ncalculate the number of possible x to make Qingshan win in the case both\r\nplayers play optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,a[N],L[N],R[N],ans,cnt,flag,Max;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tL[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (a[i]>a[i-1])L[i]=L[i-1]+1;\n\t\telse L[i]=1;\n\tR[n]=1;\n\tfor (int i=n-1;i;i--)\n\t\tif (a[i]>a[i+1])R[i]=R[i+1]+1;\n\t\telse R[i]=1;\n\tfor (int i=1;i<=n;i++)Max=max(Max,max(L[i],R[i]));\n\tfor (int i=1;i<=n;i++)\n\t\tif (L[i]==Max){\n\t\t\tif (flag){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tflag=i;\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (R[i]==Max){\n\t\t\tif (flag!=i&&flag){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tflag=i;\n\t\t}\n\tint i=flag;\n\tif (L[i]==R[i]&&L[i]%2==1)puts(\"1\");\n\telse puts(\"0\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Let s Go Hiking.json",
    "editorial_link": "https://codeforces.com//blog/entry/88533",
    "editorial": "Let's consider that the 2k+1(k?0)\n-th turn is Qingshan's and the 2k+2(k?0)\n-th turn is Daniel's.\n\nIf Qingshan chooses x(1<x?n)\n satisfying x=n\n or px<px+1\n, then Daniel can choose y=x?1\n to make Qingshan can't move in the first turn. The case that x=1\n or px<px?1\n is the same. So Qingshan must choose x(1<x<n)\n satisfying px>px?1\n and px>px+1\n at first.\n\nLet l\n be the length of the longest monotone segments and c\n be the number of the longest monotone segments. l?2\n and c?1\n are always true.\n\nIt is obvious that Qingshan can't win when c>2\n because wherever Qingshan chooses, Daniel can always find a place that he can move l?1\n times while Qingshan can move l?1\n times at most.\n\nWhen c=1\n, Qingshan will also lose. If the only longest monotone segment is ps,ps+1\u0085,ps+l?1\n and it's increasing(if it's decreasing, the discussion is almost the same). Qingshan must choose x=s+l?1\n at first. The discussion follows:\n\nIf lmod2=0\n, Daniel can choose y=s\n at first. After the l?3\n-th turn(Qingshan's turn), x=s+l?l2\n and After the l?2\n-th turn(Daniel's turn), y=s+l2?1\n. The next turn is Qingshan's and Qingshan loses.\nIf lmod2=1\n, Daniel can choose y=s+1\n at first. Pay attention that Qingshan can't change x\n to x+1\n in the first turn because Daniel can move l?2\n times while Qingshan can move l?2\n times at most if she change x\n to x+1\n in the first turn. After the l?4\n-th turn(Qingshan's turn), x=s+l?l?12\n and After the l?3\n-th turn(Daniel's turn), y=s+l?12\n. The next turn is Qingshan's and Qingshan loses.\nWhen c=2\n , the only two longest monotone segments must be like pm?l+1<pm?l+2<?<pm>pm+1>?>pm+l?1\n. (Otherwise Qingshan will lose.) In that case Qingshan will lose if lmod2=0\n because Daniel can choose y=m?l+1\n at first and whatever Qingshan's first move is, Qingshan will lose(just like the discussion above). If lmod2=1\n, Qingshan is the winner. It is not hard to check it in O(n)\n."
}