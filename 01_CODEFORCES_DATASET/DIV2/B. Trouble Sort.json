{
    "link": "https://codeforces.com//contest/1365/problem/B",
    "problemId": "643137",
    "problem_idx": "B",
    "shortId": "1365B",
    "contest_number": "1365",
    "problem_submissions": {
        "G": [
            82837838,
            82865836,
            82846144,
            82865744,
            83288423,
            83288390,
            83115367,
            83113068,
            82891046,
            83317408
        ],
        "F": [
            82823576,
            82831163,
            82869715,
            82841291,
            82797913,
            82821383,
            82823224,
            82820878,
            82825962,
            82827764,
            82819318,
            82822994,
            82828397,
            82835003,
            82834772,
            82828790,
            83116114,
            82838680,
            82843357,
            82850042
        ],
        "E": [
            82816827,
            82806889,
            82828546,
            82852781,
            82820451,
            82809338,
            82811048,
            82815094,
            82813767,
            82818099,
            82819025,
            82806699,
            82809270,
            82814661,
            82803838,
            82820792,
            82820031,
            82816700,
            82817857,
            82816698
        ],
        "D": [
            82812948,
            82823500,
            82822183,
            82824676,
            82812570,
            82806668,
            82804333,
            82805751,
            82808225,
            82811038,
            82801401,
            82805193,
            82808495,
            82818445,
            82814370,
            83282843,
            82816083,
            82808400,
            82807406,
            82806087
        ],
        "C": [
            82796097,
            82796764,
            82804011,
            82805788,
            82786984,
            82796314,
            82793579,
            82793092,
            82796581,
            82800342,
            82827239,
            82793084,
            82792671,
            82807140,
            82802231,
            82801070,
            82793918,
            82793032,
            82794670
        ],
        "B": [
            82789379,
            82791264,
            82799267,
            82793610,
            82787860,
            82790701,
            82790486,
            82792963,
            82793820,
            82794046,
            82787508,
            82790351,
            82789454,
            82795420,
            82796086,
            83567414,
            83567289,
            83567233,
            83566819,
            83566572,
            83566088,
            83137777,
            83136749,
            83136555,
            82797438,
            82788975,
            82789229,
            82789419
        ],
        "A": [
            82787406,
            82788164,
            82795856,
            82788300,
            82789945,
            82787354,
            82787533,
            82792868,
            82790605,
            82788592,
            83313475,
            82823189,
            82788613,
            82787440,
            82788379,
            82788620,
            82787269,
            82787662,
            82787203,
            82787209
        ]
    },
    "name": "B. Trouble Sort",
    "statement": "Ashish has n elements arranged in a line. These elements are represented\r\nby two integers a_i the value of the element and b_i the type of the\r\nelement (there are only two possible types: 0 and 1). He wants to sort\r\nthe elements in non-decreasing values of a_i.He can perform the\r\nfollowing operation any number of times: Select any two elements i and j\r\nsuch that b_i\r\nne b_j and swap them. That is, he can only swap two elements of\r\ndifferent types in one move. Tell him if he can sort the elements in\r\nnon-decreasing values of a_i after performing any number of operations.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint t;\n\tscanf(\"%d\" ,&t);\n\twhile(t--){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector <int> a(n);\n\t\tfor(int&i:a)\n\t\t\tscanf(\"%d\", &i);\n\t\tbool sorted=true;\n\t\tfor(int i = 1;i < n;i ++){\n\t\t\tif(a[i-1]>a[i])\n\t\t\t\tsorted=false;\n\t\t}\n\t\tvector <int> b(n);\n\t\tfor(int&i:b)\n\t\t\tscanf(\"%d\", &i);\n\t\tbool swapcan=((*min_element(b.begin(), b.end())!=*max_element(b.begin(), b.end())));\n\t\tprintf((swapcan||sorted)?\"Yes\\n\":\"No\\n\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Trouble Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/78504",
    "editorial": "If there is at least one element of type and at least one element of\r\ntype , we can always sort the array.If all the elements are of the same\r\ntype, we cannot swap any two elements. So, in this case, we just need to\r\ncheck if given elements are already in sorted order.Otherwise, there is\r\nat least one element of type and at least one element of type . In this\r\ncase, it is possible to swap any two elements! We can swap elements of\r\ndifferent types using only one operation. Suppose we want to swap two\r\nelements and of the same type. We can do it in operations. Let be an\r\nelement of the type different from and . We can first swap and , then\r\nswap and and then swap and again. In doing so, remains at its initial\r\nposition and , are swapped. This is exactly how we swap two integers\r\nusing a temporary variable. Since we can swap any two elements, it is\r\nalways possible to sort the array in this case.Time complexity:\r\n"
}