{
    "link": "https://codeforces.com//contest/1826/problem/D",
    "problemId": "1909268",
    "problem_idx": "D",
    "shortId": "1826D",
    "contest_number": "1826",
    "problem_submissions": {
        "E": [
            204602017,
            204700967,
            204596765,
            204613109,
            204610329,
            204611748,
            204612296,
            204613897,
            204618004,
            204612275,
            204613205,
            204624231,
            204661971,
            204617315,
            204616794,
            204621809,
            204612737,
            204608182,
            204614402,
            204623261,
            204628297,
            204657040,
            204656984,
            204620172
        ],
        "D": [
            204582402,
            204585260,
            204585742,
            204589825,
            204587542,
            204586441,
            204588591,
            204588717,
            204601344,
            204595957,
            204585944,
            204587666,
            204590835,
            204583319,
            204595885,
            204598399,
            204596824,
            204590840,
            204586792,
            204595240
        ],
        "C": [
            204575229,
            204577835,
            204576798,
            204582977,
            204581863,
            204581888,
            204584053,
            204580950,
            204583799,
            204579525,
            204580707,
            204583107,
            204584404,
            204580743,
            204585996,
            204593307,
            204588423,
            204580589,
            204579635,
            204588957
        ],
        "B": [
            204572809,
            204580324,
            204572676,
            204573618,
            204574774,
            204576010,
            204578782,
            204574513,
            204577548,
            204573291,
            204574259,
            204574305,
            204578256,
            204586331,
            204580048,
            204581387,
            204580847,
            204576280,
            204573990,
            204577086
        ],
        "A": [
            204572057,
            204576972,
            204571963,
            204571901,
            204572576,
            204573728,
            204575534,
            204572534,
            204574691,
            204572015,
            204572728,
            204572787,
            204573859,
            204573619,
            204575569,
            204576295,
            204576573,
            204576421,
            204572686,
            204573646
        ],
        "F": [
            204650095,
            204649588,
            204792576,
            204790910,
            204785582,
            204784675,
            204782497,
            204779284,
            205142563
        ]
    },
    "name": "D. Running Miles",
    "statement": "There is a street with n sights, with sight number i being i miles from\r\nthe beginning of the street. Sight number i has beauty b_i. You want to\r\nstart your morning jog l miles and end it r miles from the beginning of\r\nthe street. By the time you run, you will see sights you run by\r\n(including sights at l and r miles from the start). You are interested\r\nin the 3 most beautiful sights along your jog, but every mile you run,\r\nyou get more and more tired.So choose l and r, such that there are at\r\nleast 3 sights you run by, and the sum of beauties of the 3 most\r\nbeautiful sights minus the distance in miles you have to run is\r\nmaximized. More formally, choose l and r, such that b_{i_1} + b_{i_2} +\r\nb_{i_3} - (r - l) is maximum possible, where i_1, i_2, i_3 are the\r\nindices of the three maximum elements in range [l, r].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint a[N];\nint n;\nint ans;\n\nvoid rec(int from, int to){\n    int len = to - from + 1;\n    if(len < 3) return;\n    int mid = (from + to) / 2;\n    rec(from, mid);\n    rec(mid + 1, to);\n\n    int inf = 1e9;\n    int L1 = -inf;\n    int L2 = -inf;\n    int best = -inf;\n    int best2 = -inf;\n\n    for(int i=mid;i>=from;i--){\n        best2 = max(best2, a[i]);\n        if(best2 > best) swap(best, best2);\n        L1 = max(L1, best - (mid + 1 - i));\n        L2 = max(L2, best + best2 - (mid + 1 - i));\n    }\n\n    int R1 = -inf;\n    int R2 = -inf;\n    best = -inf;\n    best2 = -inf;\n    for(int i=mid+1;i<=to;i++){\n        best2 = max(best2, a[i]);\n        if(best2 > best) swap(best, best2);\n        R1 = max(R1, best - (i - mid));\n        R2 = max(R2, best + best2 - (i - mid));\n    }\n    ans = max(ans, R1 + L2);\n    ans = max(ans, R2 + L1);\n}\n\nvoid solve(){\n    cin >> n;\n    for(int i=1;i<=n;i++) cin >> a[i];\n    ans = 0;\n    rec(1, n);\n    cout << ans + 1 << \"\\n\";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Running Miles.json",
    "editorial_link": "https://codeforces.com//blog/entry/115892",
    "editorial": "There is a fairly straightforward solution using DP, but Iâll leave that\r\nfor the comment section and present a very short and simple\r\nsolution.First we need to notice, that at two of the maximums are at the\r\nends of , otherwise we can move one of the boundaries closer to the\r\nother and improve the answer.Using this observation we can reduce the\r\nproblem to the following: choose three indices , such that is maximum.\r\nNow, letâs iterate over the middle index and rewrite the function as .\r\nWe can see, that values in the braces are pretty much independent on of\r\nthem depends only on the index and the second one depends only on the\r\nindex . So, for a given we can choose the numbers and greedily! To make\r\nit fast enough we can precalculate the prefix maximum for the array and\r\nthe suffix maximum for array . This results in a time complexity\r\nsolution.\r\n",
    "hint": [
        "Hint1 What can we say about the position of the maximum elements relative to ?",
        "Hint2 You can use DP, or otherwise: Iterate over the middle maximum element and choose greedily."
    ]
}