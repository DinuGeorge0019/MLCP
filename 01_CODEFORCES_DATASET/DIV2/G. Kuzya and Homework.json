{
    "link": "https://codeforces.com//contest/1582/problem/G",
    "problemId": "1156638",
    "problem_idx": "G",
    "shortId": "1582G",
    "contest_number": "1582",
    "problem_submissions": {
        "G": [
            133300654,
            132904411,
            132903819,
            132921500,
            132938189,
            132915561,
            132904925,
            132893999,
            132930384,
            132930246,
            132930119,
            132929885,
            132929830,
            132917984,
            132923122,
            132922486,
            132909943,
            132922580,
            132929375,
            132930555,
            133312799,
            132969396
        ],
        "F2": [
            132908314,
            132865018,
            132905309,
            132899324,
            132901682,
            132900235,
            132911727,
            132926934,
            132906558,
            132909549,
            132893391,
            132884523,
            132901241,
            132906554,
            132898256,
            133312622,
            132970055,
            132969976,
            132904321
        ],
        "F1": [
            132881252,
            132864382,
            132880627,
            132888291,
            132872964,
            132880051,
            132887180,
            132892561,
            132900410,
            132897751,
            132862757,
            132872739,
            132870584,
            132888250,
            132889092,
            132882038,
            132891013,
            132872187,
            132887941,
            133312616,
            132891504
        ],
        "E": [
            132874913,
            132878099,
            132874176,
            132880923,
            132882227,
            132876672,
            132871740,
            132883982,
            132905776,
            132893914,
            132871055,
            132859358,
            132881562,
            132870144,
            132885086,
            132894857,
            132869674,
            132887914,
            132877059,
            133312375,
            132888626
        ],
        "D": [
            132866716,
            132891541,
            132886280,
            132871648,
            132863103,
            132871610,
            132863993,
            132875189,
            132911684,
            132876113,
            132889182,
            132879862,
            132890109,
            132872530,
            132875475,
            132891337,
            132884986,
            132886500,
            132884112,
            133312126,
            132970973,
            132882901
        ],
        "C": [
            132859265,
            132871828,
            132860284,
            132861165,
            132856817,
            132935747,
            132866931,
            132863031,
            132863018,
            132893464,
            132893294,
            132866549,
            132861428,
            132858872,
            132861957,
            132863927,
            132861005,
            132863860,
            132868896,
            133312107,
            132858386
        ],
        "B": [
            132856790,
            132867123,
            132856747,
            132855505,
            132854485,
            132859085,
            132858770,
            132858595,
            132856173,
            132857637,
            132856186,
            132859468,
            132855951,
            132855099,
            132854810,
            132855351,
            132856357,
            132855765,
            132859435,
            133312040,
            132970544,
            132854847
        ],
        "A": [
            132855030,
            132855528,
            132854523,
            132892082,
            132854129,
            132904251,
            132854758,
            132854419,
            132906994,
            132854763,
            132856077,
            132854737,
            132984138,
            132854196,
            132859118,
            132854306,
            132855186,
            132865041,
            132857131,
            133311808,
            132970350,
            132854128
        ]
    },
    "name": "G. Kuzya and Homework",
    "statement": "Kuzya started going to school. He was given math homework in which he\r\nwas given an array a of length n and an array of symbols b of length n,\r\nconsisting of symbols ’*’ and ’/’.Let’s denote a for a segment [l; r] (1\r\nle l\r\nle r\r\nle n) in the following way: Let x=1 initially. For every i from l to r\r\nwe will consequently do the following: if b_i= ’*’, x=x*a_i, and if b_i=\r\n’/’, then x=\r\nfrac{x}{a_i}. Let’s call for the segment [l; r] a list of all x that we\r\ngot during the calculations (the number of them is exactly r - l + 1).\r\nFor example, let a=[7, 12, 3, 5, 4, 10, 9], b=[/, *, /, /, /, *, *],\r\nl=2, r=6, then the path of calculations for that segment is [12, 4, 0.8,\r\n0.2, 2].Let’s call a segment [l;r] if the path of calculations for it\r\ncontains . Kuzya needs to find the number of simple segments [l;r] (1\r\nle l\r\nle r\r\nle n). Since he obviously has no time and no interest to do the\r\ncalculations for each option, he asked you to write a program to get to\r\nfind that number!\r\n",
    "solutions": [
        "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = (1 << 20);\n\nvector<int> p;\n\nvoid solve(int n) {\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tstring b;\n\tcin >> b;\n\tvector<vector<pair<int, int>>> f(M);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint val = a[i];\n\t\tint op = (b[i] == '*' ? +1 : -1); \n\t\twhile (val > 1) {\n\t\t\tint p0 = p[val];\n\t\t\tint e0 = 0;\n\t\t\twhile (val % p0 == 0) {\n\t\t\t\tval /= p0;\n\t\t\t\te0 += op;\n\t\t\t}\n\t\t\tf[p0].push_back({i, e0});\n\t\t}\n\t}\n\tvector<int> g(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tg[i] = i;\n\t}\n\tfor (const auto& f0 : f) {\n\t\tif (!f0.empty()) {\n\t\t\tvector<pair<int, int>> sk;\n\t\t\tauto add = [&](int val, int pos) {\n\t\t\t\twhile (sk.size() > 0 && sk.back().first >= val) {\n\t\t\t\t\tsk.pop_back();\n\t\t\t\t}\n\t\t\t\tsk.push_back({ val, pos });\n\t\t\t};\n\t\t\tadd(0, 0);\n\t\t\tint cur = 0;\n\t\t\tfor (const auto& w : f0) {\n\t\t\t\tadd(cur, w.first);\n\t\t\t\tcur += w.second;\n\t\t\t\tint target =  -1;\n\t\t\t\tif (sk[0].first <= cur) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = sk.size();\n\t\t\t\t\twhile (hi - lo > 1) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (sk[mi].first <= cur) {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttarget = sk[lo].second;\n\t\t\t\t}\n\t\t\t\tg[w.first] = min(g[w.first], target);\n\t\t\t\tadd(cur, w.first + 1);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> h(n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\th[g[i] + 1].push_back(i);\n\t}\n\tset<int> w;\n\tw.insert(n);\n\tlong long r = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j : h[i]) {\n\t\t\tw.insert(j);\n\t\t}\n\t\twhile (*w.begin() < i) {\n\t\t\tw.erase(w.begin());\n\t\t}\n\t\tr += *w.begin() - i;\n\t}\n\tcout << r << endl;\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"g.in\", \"r\", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tp = vector<int>(M);\n\tfor (int i = 2; i < M; ++i) {\n\t\tif (p[i] == 0) {\n\t\t\tfor (int j = i; j < M; j += i) {\n\t\t\t\tp[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tsolve(n);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Kuzya and Homework.json",
    "editorial_link": "https://codeforces.com//blog/entry/96267",
    "editorial": "Notice that the segment is simple, if for any prime number we will get a\r\nbracket sequence, which has the minimal balance greater of equal to .\r\nThe bracket sequence is formed the following way: we will iterate over\r\nthe segment and add an opening bracket if we multiply by that number,\r\nand a closing bracket, if we divide by that number.Letâs consider the\r\nelements of the array and calculate the array , wich contains the\r\ngreatest left bound, such that we can do the -th operations in integer\r\nnumbers with every . To calculate such bounds, for each prime number\r\nletâs maintain all indices of its occurences in the numbers of in a\r\nstack (if the prime numbers occurs in a number several times, we need to\r\nstore the index several times). If the -th operation is the operation of\r\nmultiplying, then is equal to , and for all prime divisors of the number\r\nwe need to add the index , and if itâs the operation of division,then\r\nfor all prime divisors of we need to delete indices (in the same amount\r\nas the prime divisor occurs in ) and save the smallest erased index in .\r\nIf for any prime divisor we had to erase an index from an empty stack,\r\nthen we got a non-integer result, so .Now that we know the values of the\r\narray , we need to calculate the number of segments , such that , where\r\nis the minimal value of on segment . We can do that using segment tree\r\non minimum in (iterate over the left bound and traversing the tree from\r\nthe root find the greatest right bound for current left one) or using\r\nlinear algorithms with a stack (to do that, letâs iterate over all left\r\nbounds in decreasing order and maintain a stack on minimum on the array\r\n).\r\n",
    "hint": []
}