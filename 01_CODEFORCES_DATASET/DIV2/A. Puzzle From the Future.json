{"link": "https://codeforces.com//contest/1474/problem/A", "problemId": "870480", "problem_idx": "A", "shortId": "1474A", "contest_number": "1474", "problem_submissions": {"E": [104828368, 104825250, 104827801, 104822469, 104822968, 104825131, 104832974, 104811012, 104834815, 104836057, 104786622, 104834179, 104835602, 104835107, 104819950, 104895130, 104882601, 104882491, 104822858], "D": [104803255, 104806609, 104803024, 104811001, 104809350, 104807802, 104813937, 104829181, 104824996, 104821358, 104809387, 104820702, 104821421, 104825040, 104833883, 104796190, 104794553, 104806036, 104805452, 104811623], "C": [104789142, 104791190, 104786189, 104802722, 104796149, 104800127, 104797483, 104805966, 104792346, 104794052, 104822570, 104797300, 104791406, 104805588, 104813805, 104788832, 104801037, 104795624, 104794599, 104838458], "B": [104775373, 104776212, 104776559, 104780629, 104776012, 104787737, 104785829, 104784413, 104779863, 104778330, 104827451, 104777621, 104780062, 104783179, 104774681, 104778495, 104779543, 104781042, 104777052, 104790738], "A": [104773322, 104773959, 104773453, 104773717, 104779601, 104775931, 104776918, 104778778, 104773943, 104773918, 104829555, 104773504, 104773695, 104774435, 104774622, 104773540, 104774168, 104774408, 104773478, 104781204]}, "name": "A. Puzzle From the Future", "statement": "In the year, Mike found two binary integers a and b of length n (both of\r\nthem are written only by digits 0 and 1) that can have leading zeroes.\r\nIn order not to forget them, he wanted to construct integer d in the\r\nfollowing way: he creates an integer c as a result of bitwise summing of\r\na and b , so c may have one or more 2-s. For example, the result of\r\nbitwise summing of 0110 and 1101 is 1211 or the sum of 011000 and 011000\r\nis 022000; after that Mike replaces equal consecutive digits in c by one\r\ndigit, thus getting d. In the cases above after this operation, 1211\r\nbecomes 121 and 022000 becomes 020 (so, d won\u2019t have equal consecutive\r\ndigits). Unfortunately, Mike lost integer a before he could calculate d\r\nhimself. Now, to cheer him up, you want to find integer a of length n\r\nsuch that d will be .Maximum possible as integer means that 102 > 21,\r\n012 < 101, 021 = 21 and so on.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n\tlong long n,i;\n\tstring str;\n\tcin>>n>>str;\n\tlong long b[n],cur=1+str[0]-'0';\n\tb[0]=1;\n\tfor(i=1;i<n;i++){\n\t\tif(cur==0){\n\t\t\tb[i]=1;\n\t\t}\n\t\telse if(cur==1){\n\t\t\tif(str[i]=='1'){\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i]=0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(str[i]=='0'){\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i]=0;\n\t\t\t}\n\t\t}\n\t\tcur=(str[i]-'0')+b[i];\n\t}\n\tfor(i=0;i<n;i++)\n\t\tcout<<b[i];\n\tcout<<endl;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlong long t=1;\n\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["greedy"], "dificulty": "800", "interactive": false}