{"link": "https://codeforces.com//contest/1471/problem/F", "problemId": "855313", "problem_idx": "F", "shortId": "1471F", "contest_number": "1471", "problem_submissions": {"E": [103450052, 103527230, 103525401, 103598525], "F": [103434846, 103427866, 103439415, 103444744, 103449013, 103443306, 103451232, 103449545, 103450844, 103457122, 103444374, 103429431, 103453099, 103450549, 103452495, 103451463, 103455883, 103458926, 103459110, 103458706], "D": [103430457, 103433587, 103415562, 103429984, 103422346, 103434860, 103464447, 103432755, 103438270, 103433203, 103429688, 103431896, 103454609, 103429555, 103432993, 103431363, 103439051, 103433971, 103434798, 103443976, 103435625], "C": [103407997, 103401931, 103402977, 103409572, 103406225, 103408555, 103406435, 103414503, 103418347, 103405513, 103405296, 103416304, 103408620, 103413240, 103409443, 103419306, 103414842, 103414451, 103407384, 103412728], "B": [103396816, 103402555, 103399513, 103402026, 103401651, 103404250, 103396796, 103402859, 103407240, 103400401, 103398000, 103404884, 103399937, 103406757, 103403051, 103411496, 103400880, 103401862, 103399435, 103395040], "A": [103391504, 103392070, 103391475, 103392431, 103397645, 103392332, 103392672, 103392165, 103392211, 103391494, 103393909, 103392635, 103393542, 103391831, 103396953, 103391758, 103391661, 103393211, 103391536]}, "name": "F. Strange Housing", "statement": "Students of Winter Informatics School are going to live in a set of\r\nhouses connected by underground passages. Teachers are also going to\r\nlive in some of these houses, but they can not be accommodated randomly.\r\nFor safety reasons, the following must hold: All passages between two\r\nhouses will be closed, if there are no teachers in both of them. All\r\nother passages will stay open. It should be possible to travel between\r\nany two houses using the underground passages that are . Teachers should\r\nnot live in houses, directly connected by a passage. Please help the\r\norganizers to choose the houses where teachers will live to satisfy the\r\nsafety requirements or determine that it is impossible.\r\n", "solutions": ["// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\n\nconst int N = 1000005;\nvector<int> adj[N];\nint n, m, vis[N], f[N], col[N];\n\nint find(int x) {\n  return f[x] == x ? x : f[x] = find(f[x]);\n}\n\nvoid dfs(int u, int fa) {\n  vis[u] = 1, col[u] = !col[fa];\n  for (auto v: adj[u]) if (vis[v]) col[u] &= !col[v];\n  for (auto v: adj[u]) if (!vis[v] && v != fa) {\n    dfs(v, u);\n  }\n}\nint main() {\n  int T = read();\n  while (T--) {\n    n = read(), m = read();\n    for (int i = 1; i <= n; i++) {\n      vis[i] = 0, f[i] = i;\n      adj[i].clear(), col[i] = 0;\n    }\n    int comp = n;\n    for (int i = 1; i <= m; i++) {\n      int u = read(), v = read();\n      if (find(u) != find(v)) comp--, f[find(u)] = find(v);\n      adj[u].pb(v), adj[v].pb(u);\n    }\n    if (comp != 1) {\n      puts(\"NO\"); continue;\n    }\n    dfs(1, 0);\n    int cnt = 0;\n    puts(\"YES\");\n    vector<int> ans;\n    for (int i = 1; i <= n; i++) if (col[i]) ans.pb(i), cnt++;\n    printf(\"%d\\n\", cnt);\n    for (auto v: ans) printf(\"%d \", v);\n    puts(\"\");\n  }\n  return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "greedy"], "dificulty": "2200", "interactive": false}