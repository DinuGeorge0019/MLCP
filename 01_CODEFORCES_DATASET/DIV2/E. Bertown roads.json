{"link": "https://codeforces.com//contest/118/problem/E", "problemId": "621", "problem_idx": "E", "shortId": "118E", "contest_number": "118", "problem_submissions": {"E": [744037, 745078, 744813, 745388, 745323, 745867, 745436, 743649, 746938, 747382, 916949, 916937, 745101, 744662, 746262, 745809, 747461, 745823, 746138], "D": [743430, 743260, 743613, 743901, 743105, 744593, 742112, 744619, 744423, 745827, 743409, 746775, 745410, 743985, 744866, 743911, 743861, 744184, 744358, 744533], "C": [743075, 741949, 742890, 743396, 742360, 743301, 743646, 747932, 743990, 743060, 744985, 747243, 742852, 748623, 744300, 747942, 746584], "B": [741723, 743683, 741482, 741838, 741312, 741497, 746089, 742393, 742319, 741483, 742136, 741733, 740956, 741809, 742820, 742009, 741676, 741556, 742466, 742218], "A": [741066, 743899, 740889, 741247, 744792, 740920, 740962, 741172, 741019, 740916, 741008, 741288, 741140, 741579, 741121, 741180, 741200, 741119]}, "name": "E. Bertown roads", "statement": "Bertown has junctions and bidirectional roads. We know that one can get\r\nfrom any junction to any other one by the existing roads. As there were\r\nmore and more cars in the city, traffic jams started to pose real\r\nproblems. To deal with them the government decided to make the traffic\r\none-directional on all the roads, thus easing down the traffic. Your\r\ntask is to determine whether there is a way to make the traffic\r\none-directional so that there still is the possibility to get from any\r\njunction to any other one. If the answer is positive, you should also\r\nfind one of the possible ways to orient the roads.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n#define NextLine() { char c = getchar(); while (c != 10 && c != EOF) { c = getchar(); } }\n\nclass Edge\n{\npublic:\n\tint be, en;\n};\n\nint first[110000];\nvector<int> next;\nvector<Edge> edg;\nint n, m;\n\nvoid AddEdge(int v1, int v2)\n{\n\tEdge a;\n\ta.be = v1;\n\ta.en = v2;\n\tedg.push_back(a);\n\tnext.push_back(first[a.be]);\n\tfirst[a.be] = edg.size() - 1;\n\ta.be = v2;\n\ta.en = v1;\n\tedg.push_back(a);\n\tnext.push_back(first[a.be]);\n\tfirst[a.be] = edg.size() - 1;\n}\n\nvoid Load()\n{\n\tmemset(first, 0xFF, sizeof(first));\n\tscanf(\"%d%d\", &n, &m);\n\tint i;\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tint p, q;\n\t\tscanf(\"%d%d\", &p, &q);\n\t\tAddEdge(p, q);\n\t}\n}\n\nint ct;\nint tin[110000];\nint ue[610000];\nint was[110000];\nint w[110000];\n\nbool Dfs(int ver)\n{\n\tint i;\n\tct++;\n\ttin[ver] = ct;\n\tw[ver] = ct;\n\twas[ver] = 1;\n\tfor (i = first[ver]; i != -1; i = next[i])\n\t{\n\t\tif (ue[i ^ 1]) continue;\n\t\tue[i] = 1;\n\t\tif (was[edg[i].en]) w[ver] = min(w[ver], tin[edg[i].en]);\n\t\telse\n\t\t{\n\t\t\tif (!Dfs(edg[i].en)) return false;\n\t\t\tw[ver] = min(w[ver], w[edg[i].en]);\n\t\t\tif (w[edg[i].en] >= tin[edg[i].en]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid Solve()\n{\n\tmemset(ue, 0, sizeof(ue));\n\tct = 0;\n\tif (!Dfs(1))\n\t{\n\t\tprintf(\"0\\n\");\n\t}\n\telse\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < edg.size(); i++)\n\t\t{\n\t\t\tif (ue[i])\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\", edg[i].be, edg[i].en);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tLoad();\n\tSolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "2000", "interactive": false}