{
    "link": "https://codeforces.com//contest/1106/problem/B",
    "problemId": "290931",
    "problem_idx": "B",
    "shortId": "1106B",
    "contest_number": "1106",
    "problem_submissions": {
        "F": [
            49265817,
            49264923,
            49266558,
            49269257,
            49271213,
            49272184,
            49272969,
            49267903,
            49273554,
            49895559,
            49298045,
            49263114,
            49273336,
            49274102,
            49274867,
            49300428,
            49276394,
            49277229,
            49269016,
            49266937,
            49277423,
            49277280,
            49269846
        ],
        "E": [
            49261808,
            49267815,
            49266852,
            49261526,
            49261539,
            49258516,
            49262159,
            49269184,
            49261973,
            49895562,
            49273364,
            49263914,
            49261370,
            49261525,
            49300401,
            49261737,
            49261915,
            49273907,
            49276075,
            49262981,
            49266273,
            49276021
        ],
        "B": [
            49257277,
            49252209,
            49248876,
            49251236,
            49256788,
            49251411,
            49251144,
            49255473,
            49251954,
            49895487,
            49263583,
            49254902,
            49252783,
            49253845,
            49300101,
            49250570,
            49252035,
            49259947,
            49251497,
            49253887,
            49260721,
            49251319
        ],
        "D": [
            49252880,
            49254281,
            49252504,
            49255122,
            49251697,
            49253429,
            49254193,
            49257749,
            49255378,
            49895514,
            49296674,
            49250135,
            49257979,
            49256084,
            49256833,
            49300300,
            49255435,
            49255524,
            49255367,
            49255410,
            49258191,
            49255067,
            49255106
        ],
        "C": [
            49249200,
            49252258,
            49250171,
            49253405,
            49249251,
            49247144,
            49252242,
            49250452,
            49253463,
            49895495,
            49252232,
            49249038,
            49255058,
            49255040,
            49300208,
            49300199,
            49252907,
            49253665,
            49252133,
            49253357,
            49255807,
            49250684,
            49253071
        ],
        "A": [
            49246544,
            49245865,
            49245896,
            49246235,
            49246566,
            49245858,
            49246274,
            49248820,
            49246242,
            49895480,
            49249300,
            49246352,
            49247004,
            49246275,
            49300057,
            49300056,
            49246548,
            49246161,
            49246888,
            49246017,
            49246734,
            49261784,
            49245817
        ]
    },
    "name": "B. Lunar New Year and Food Ordering",
    "statement": "The restaurant \"Alice\u2019s\" serves n kinds of food. The cost for the i-th\r\nkind is always c_i. Initially, the restaurant has enough ingredients for\r\nserving exactly a_i dishes of the i-th kind. In the New Year\u2019s Eve, m\r\ncustomers will visit Alice\u2019s one after another and the j-th customer\r\nwill order d_j dishes of the t_j-th kind of food. The (i + 1)-st\r\ncustomer will only come after the i-th customer is completely\r\nserved.Suppose there are r_i dishes of the i-th kind remaining\r\n(initially r_i = a_i). When a customer orders 1 dish of the i-th kind,\r\nthe following principles will be processed. If r_i > 0, the customer\r\nwill be served exactly 1 dish of the i-th kind. The cost for the dish is\r\nc_i. Meanwhile, r_i will be reduced by 1. Otherwise, the customer will\r\nbe served 1 dish of the available kind of food if there are any. If\r\nthere are multiple cheapest kinds of food, the one with the smallest\r\nindex among the cheapest will be served. The cost will be the cost for\r\nthe dish served and the remain for the corresponding dish will be\r\nreduced by 1. If there are no more dishes at all, the customer will\r\nleave angrily. Therefore, no matter how many dishes are served\r\npreviously, the cost for the customer is 0.If the customer doesn\u2019t leave\r\nafter the d_j dishes are served, the cost for the customer will be the\r\nsum of the cost for these d_j dishes.Please determine the total cost for\r\neach of the m customers.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nint a[N], c[N];\nset<pair<int, int> > S;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= n; i++) cin >> c[i];\n\tfor (int i = 1; i <= n; i++) S.insert(make_pair(c[i], i));\n\tlong long ans = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint t, d; cin >> t >> d;\n\t\tlong long cost = 0;\n\t\twhile (d) {\n\t\t\tif (a[t]) {\n\t\t\t\tint s = min(a[t], d);\n\t\t\t\ta[t] -= s;\n\t\t\t\td -= s;\n\t\t\t\tif (!a[t]) S.erase(make_pair(c[t], t));\n\t\t\t\tcost += 1LL * s * c[t];\n\t\t\t} else {\n\t\t\t\tif (S.empty()) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tpair<int, int> x = *S.begin();\n\t\t\t\t\tt = x.second;\n\t\t\t\t\tint s = min(a[t], d);\n\t\t\t\t\ta[t] -= s;\n\t\t\t\t\td -= s;\n\t\t\t\t\tif (!a[t]) S.erase(make_pair(c[t], t));\n\t\t\t\t\tcost += 1LL * s * c[t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}\t\t\t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Lunar New Year and Food Ordering.json",
    "editorial_link": "https://codeforces.com/blog/entry/64928",
    "editorial": "The implementation of the problem is easy: Just do what Bob tells you to\r\ndo. The only difficulty, if it is, is to handle the cheapest dish. This\r\ncan be done by a pointer or a priority queue. The details can be found\r\nin the code.\r\n"
}