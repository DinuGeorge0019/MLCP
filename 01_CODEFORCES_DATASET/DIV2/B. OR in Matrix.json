{
    "link": "https://codeforces.com//contest/486/problem/B",
    "problemId": "17060",
    "problem_idx": "B",
    "shortId": "486B",
    "contest_number": "486",
    "problem_submissions": {
        "C": [
            8656712,
            8654869,
            8655277,
            8661715,
            8659367,
            8661623,
            8671659,
            8658387,
            44544902,
            8655041,
            8655195,
            8655046,
            8655532,
            8655723,
            8654982,
            8655530,
            8654402,
            8657095,
            8655223,
            8663823,
            8658911
        ],
        "D": [
            8656322,
            8653249,
            8657902,
            8655199,
            8657521,
            8656772,
            8655987,
            8654471,
            8762125,
            8656998,
            8658007,
            8658299,
            8659044,
            8659007,
            8659117,
            8660760,
            8660451,
            8663779
        ],
        "A": [
            8652840,
            8649416,
            8649905,
            8649569,
            8649694,
            8650271,
            8649886,
            8649533,
            8650061,
            8649465,
            8650144,
            8650093,
            8650370,
            8649662,
            8650038,
            8650934,
            8649593,
            8649948,
            8650270,
            8663811,
            8649707
        ],
        "B": [
            8652668,
            8652141,
            8652012,
            8652630,
            8653907,
            8652325,
            8651841,
            8653366,
            8651435,
            8652387,
            8652466,
            8652574,
            8652046,
            8653190,
            8652712,
            8651972,
            8656481,
            8651946,
            8663812,
            8652791
        ],
        "E": [
            8651853,
            8654712,
            8659740,
            8659484,
            8661000,
            8661038,
            8654891,
            8659823,
            8952883,
            8658117,
            8661158,
            8666251,
            8659593,
            8663820,
            8660769
        ]
    },
    "name": "B. OR in Matrix",
    "statement": "Let\u2019s define logical as an operation on two logical values (i. e. values\r\nthat belong to the set ) that is equal to if either or both of the\r\nlogical values is set to , otherwise it is . We can define logical of\r\nthree or more logical values in the same manner: where is equal to if\r\nsome , otherwise it is equal to .Nam has a matrix consisting of rows and\r\ncolumns. The rows are numbered from to , columns are numbered from to .\r\nElement at row () and column () is denoted as . All elements of are\r\neither 0 or 1. From matrix , Nam creates another matrix of the same size\r\nusing formula:.( is of all elements in row and column of matrix )Nam\r\ngives you matrix and challenges you to guess matrix . Although Nam is\r\nsmart, he could probably make a mistake while calculating matrix , since\r\nsize of can be large.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 110\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nchar map[maxn][maxn];\nint nRow,nCol,a[maxn][maxn];\nvoid read()\n{\n    cin>>nRow>>nCol;\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            map[i][j]='1';\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n        {\n            scanf(\"%d\",&a[i][j]);\n            if(!a[i][j])\n            {\n                for(int k=1;k<=nRow;++k)\n                    map[k][j]='0';\n                for(int k=1;k<=nCol;++k)\n                    map[i][k]='0';\n            }\n        }\n}\nvoid print()\n{\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            if(a[i][j])\n            {\n                int s=0;\n                for(int k=1;k<=nRow;++k)\n                    s+=map[k][j]-'0';\n                for(int k=1;k<=nCol;++k)\n                    s+=map[i][k]-'0';\n                if(!s)\n                {\n                    printf(\"NO\\n\");\n                    return ;\n                }\n            }\n    printf(\"YES\\n\");\n    for(int i=1;i<=nRow;++i)\n        for(int j=1;j<=nCol;++j)\n            printf(\"%c%c\",map[i][j],j<nCol?' ':'\\n');\n}\nint main()\n{\n    read();\n    print();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "hashing",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. OR in Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/14678",
    "editorial": "Hint of this problem is presented in its statement. \" where is equal to\r\nif some , otherwise it is equal to .\" To solve this problem, do 3\r\nfollowing steps: Complexity: We can implement this algorithm in , but\r\nit\u00e2\u0080\u0099s not neccesary since .\r\n"
}