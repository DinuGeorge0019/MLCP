{"link": "https://codeforces.com//contest/760/problem/F", "problemId": "89821", "problem_idx": "F", "shortId": "760F", "contest_number": "760", "problem_submissions": {"F": [24048996, 24334592, 24109967], "D": [24042480, 24043732, 24050024, 24046176, 24044696, 24045116, 24042014, 24043570, 24047853, 24043885, 24739234, 24045094, 24044167, 24044943, 24049808, 24041812, 24045235], "C": [24040885, 24041111, 24041193, 24043138, 24047007, 24043013, 24038951, 24041237, 24046096, 24041744, 24041798, 24042387, 24042705, 24049213, 24042229, 24044994, 24042730], "B": [24039488, 24039342, 24037031, 24040294, 24041983, 24041211, 24039467, 24039465, 24039319, 24038489, 24040344, 24039097, 24039942, 24040090, 24041062], "A": [24036025, 24035890, 24035872, 24036889, 24036131, 24037811, 24035954, 24036348, 24036507, 24036069, 24036108, 24036146, 24036211, 24041066, 24035881, 24035886, 24036867], "E": [24050782, 24048436, 24049579, 24049178, 24050210, 24052439, 24072140, 24052585, 24324528, 24324402, 24048812, 24049062, 24108774]}, "name": "F. Bacterial Melee", "statement": "Julia is conducting an experiment in her lab. She placed several\r\nluminescent bacterial colonies in a horizontal testtube. Different types\r\nof bacteria can be distinguished by the color of light they emit. Julia\r\nmarks types of bacteria with small Latin letters \"\", ..., \"\".The\r\ntesttube is divided into consecutive regions. Each region is occupied by\r\na single colony of a certain bacteria type at any given moment. Hence,\r\nthe population of the testtube at any moment can be described by a\r\nstring of Latin characters.Sometimes a colony can decide to conquer\r\nanother colony in one of the adjacent regions. When that happens, the\r\nattacked colony is immediately eliminated and replaced by a colony of\r\nthe same type as the attacking colony, while the attacking colony keeps\r\nits type. Note that a colony can only attack its neighbours within the\r\nboundaries of the testtube. At any moment, at most one attack can take\r\nplace.For example, consider a testtube with population \"\". There are six\r\noptions for an attack that may happen next: the first colony attacks the\r\nsecond colony (), the resulting population is \"\"; , the result is \"\"; ,\r\nthe result is \"\"; , the result is \"\" (note that the result is the same\r\nas the first option); or , the population does not change.The pattern of\r\nattacks is rather unpredictable. Julia is now wondering how many\r\ndifferent configurations of bacteria in the testtube she can obtain\r\nafter a sequence of attacks takes place (it is possible that no attacks\r\nwill happen at all). Since this number can be large, find it modulo .\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 5e3 + 10, MOD = 1e9 + 7, A = 27;\n\nint add(int a, int b){ return ( ll(a) + b ) % MOD; }\nint mul(int a, int b){ return ( ll(a) * b ) % MOD; }\nint sadd(int &a, int b){ return a = ( ll(a) + b ) % MOD; }\nint smul(int &a, int b){ return a = ( ll(a) * b ) % MOD; }\nint mpow(int x, int p){\n\tint res = 1;\n\tfor (p %= MOD - 1; p; p /= 2, smul(x, x))\n\t\tif (p % 2) smul(res, x);\n\treturn res;\n}\nint rev(int x){ return mpow(x, MOD - 2); }\n\nint fac[N], rfac[N];\nint C(int n, int r){\n\tif (r < 0 || r > n) return 0;\n\treturn mul( fac[n], mul(rfac[n - r], rfac[r]) );\n}\n\nint dp[N][A], sum[N];;\n\nvoid calcDP(string s){\n\tdp[0][A - 1] = 1;\n\tsum[0] = 1;\n\t\n\tfor (int i = 0; i < s.size(); i++){\n\t\tint c = s[i] - 'a';\n\t\tfor (int j = 0; j < N - 1; j++){\n\t\t\tsadd(sum[j + 1], MOD - dp[j + 1][c]);\n\t\t\tdp[j + 1][c] = add(sum[j], MOD - dp[j][c]);\n\t\t\tsadd(sum[j + 1], dp[j + 1][c]);\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcout.tie(0); cin.tie(0);\n\n\tfac[0] = rfac[0] = 1;\n\tfor (int i = 1; i < N; i++){\n\t\tfac[i] = mul(fac[i - 1], i);\n\t\trfac[i] = rev(fac[i]);\n\t}\n\t\n\tint n; string s;\n\tcin >> n >> s;\n\n\ts.resize(unique(s.begin(), s.end()) - s.begin());\n\tint sz = s.size();\n\t//cout << s << \", \" << sz << endl;\n\tcalcDP(s);\n\n\tint ans = 0;\n\tfor (int i = 1; i <= sz; i++){\n\t\tint sum = 0;\n\t\tfor (int j = 0; j < A - 1; j++)\n\t\t\tsadd(sum, dp[i][j]);\n\n\t\tsadd(ans, mul(sum, C(n - i + i - 1, i - 1) ) );\n\t}\n\t\t\n\tcout << add(ans, MOD) << endl;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2400", "interactive": false}