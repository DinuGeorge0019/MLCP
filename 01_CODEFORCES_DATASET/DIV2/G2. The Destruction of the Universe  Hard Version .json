{
    "link": "https://codeforces.com//contest/2030/problem/G2",
    "problemId": "2962995",
    "problem_idx": "G2",
    "shortId": "2030G2",
    "contest_number": "2030",
    "problem_submissions": {
        "D": [
            286870605,
            286870097,
            286766067,
            286743790,
            286749704,
            286752517,
            286743540,
            286763694,
            286769489,
            286762215,
            286755968,
            286807582,
            286774479,
            286755264,
            286748829,
            286762354,
            286767397,
            286766307,
            286775817,
            286773805,
            286867460,
            286806694,
            286757030
        ],
        "C": [
            286860734,
            286764785,
            286775512,
            286732737,
            286735870,
            286731279,
            286736529,
            286759035,
            286741312,
            286740209,
            286770332,
            286732276,
            286730948,
            286749099,
            286748589,
            286737019,
            286738816,
            286732618,
            286746919,
            286735952,
            286744382
        ],
        "B": [
            286858184,
            286726117,
            286721582,
            286722000,
            286722997,
            286722179,
            286731090,
            286742656,
            286728669,
            286721456,
            286721616,
            286722634,
            286723485,
            286723817,
            286722712,
            286723090,
            286725291,
            286719819,
            286727047,
            286721215,
            286722880
        ],
        "A": [
            286857205,
            286716570,
            286716508,
            286717068,
            286716187,
            286716722,
            286727391,
            286716522,
            286715165,
            286715628,
            286715445,
            286716659,
            286717260,
            286715083,
            286717340,
            286715258,
            286718621,
            286715888,
            286722488,
            286715834,
            286716388
        ],
        "G1": [
            286855127,
            286854605,
            287072911,
            286866647
        ],
        "F": [
            286768609,
            286793091,
            286802410,
            286804764,
            286807723,
            286808203,
            286799478,
            286806636,
            286814242,
            286786481,
            286811066,
            286813827,
            286813676,
            286816754,
            286814190,
            286813606,
            286813682,
            286795825,
            286808765,
            286817519
        ],
        "E": [
            286766337,
            286759349,
            286779444,
            286786742,
            286788454,
            286791781,
            286783999,
            286800776,
            286780259,
            286764648,
            286793854,
            286792948,
            286789703,
            286779768,
            286799721,
            286794191,
            286791806,
            286816988,
            286786381,
            286789315
        ],
        "G2": [
            287138384
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135218",
    "editorial": "Problem Credits: Proof_by_QED, satyam343 Analysis: satyam343 Solution\r\n(Easy Version)To find the score of a set of intervals , we follow these\r\nsteps:Initially, the score is set to .We perform the following process\r\nrepeatedly: Let be the interval with the smallest among all active\r\nintervals. Let be the interval with the largest among all active\r\nintervals. If , add to the score, mark intervals and as inactive, and\r\ncontinue the process. If , stop the process. At the end of this process,\r\nall active intervals will intersect at least one common point.Now, we\r\nneed to prove that the process indeed gives us the minimum possible\r\nscore. We can prove this by induction.Let be some set of intervals, and\r\nlet and be the intervals defined above. Consider the set (i.e., is the\r\nset excluding and ). We claim that: This is true because, for and to\r\nintersect, we must perform at least operations. Our construction\r\nachieves the lower bound of . Thus, During the process, we pair some\r\nintervals (possibly none). Specifically, in the -th step, we pair the\r\ninterval with the -th smallest with the interval having the -th largest\r\n, and add the distance between them to the score.In the problem G1, we\r\ncan compute the contribution of each pair of intervals as\r\nfollows:Suppose we consider a pair . Without loss of generality, assume\r\nthat .The pair will be considered in some subset if there are exactly\r\nintervals such that and exactly intervals such that , for some\r\nnon-negative integer .Let there be intervals such that and intervals\r\nsuch that .For to be paired in some subset , we must choose intervals\r\nfrom the intervals on the left and intervals from the intervals on the\r\nright, for some non-negative integer . There are no restrictions on the\r\nremaining intervals.Therefore, the contribution of is: We can simplify\r\nthis sum using the identity: (This is a form of the Vandermonde\r\nIdentity.)Thus, the contribution of becomes: This can be computed in\r\ntime.Note that in the explanation above, we assumed that the interval\r\nendpoints are distinct for simplicity. If they are not, we can order the\r\nintervals based on their values to maintain consistency.\r\n",
    "name": "G2. The Destruction of the Universe  Hard Version ",
    "statement": "There are n planets in the universe. Each planet has an [l, r], during\r\nwhich it will be exposed to destruction by orangutans. Orangutans can\r\nalso expand the of any planet by 1 unit.Specifically, suppose the\r\nexpansion is performed on planet p with [l_p, r_p]. Then, the resulting\r\nmay be either [l_p - 1, r_p] or [l_p, r_p + 1].Given a set of planets,\r\norangutans can destroy all planets if the of all planets in the set\r\nintersect at least one common point. Let the of such a set denote the\r\nminimum number of expansions that must be performed.Orangutans are\r\ninterested in the sum of of all subsets of the planets in the universe.\r\nAs the answer can be large, output it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <cstdio>#include <algorithm>#include <set>using ll=long long;constexpr int N=1000010,M=998244353,INV2=M+1>>1;int T,n,i,Ch,j,pre[N],suf[N];ll ans,pw[N],fac[N],inv[N],invfac[N];struct ss{int l,r;}a[N];std::multiset<int>st;template<typename T>inline void r(T&x){\twhile((Ch=getchar())<48);\tx=Ch&15;\twhile((Ch=getchar())>47)x=(x<<1)+(x<<3)+(Ch&15);}template<typename...Ar>inline void r(Ar&&...x){std::initializer_list<int>{(r(x),0)...};}template<typename T>inline void w(T x){\tstatic char stk[64],*top=stk;\tdo{\t\t*++top=x%10;\t\tx/=10;\t}while(x);\tdo putchar(*top--|48);while(top!=stk);\tputchar(10);}template<typename T>inline void Mod(T&x){if(x>=M)x-=M;}inline ll C(const int&n,const int&m){return m>=0&&n>=m?fac[n]*invfac[m]%M*invfac[n-m]%M:0;}inline ll f(const int&x,const int&y){\tstatic int X=0,Y=0;\tstatic ll ans=0;\twhile(X<x+y)ans=((ans<<1)+C(X++,Y))%M;\twhile(X>x+y)ans=(ans+M-C(--X,Y))*INV2%M;\twhile(Y<x)Mod(ans=ans+M-C(X,++Y));\twhile(Y>x)Mod(ans=ans+C(X,Y--));\treturn ans*pw[n-1-x-y]%M;}int main(){\t*fac=*invfac=*pw=1;\tr(T);\twhile(T--){\t\t__builtin_memset(pre+1,0,n<<2);\t\t__builtin_memset(suf+1,0,n<<2);\t\tans=0;\t\tr(n);\t\tfor(i=1;i<=n;i++){\t\t\tMod(pw[i]=pw[i-1]<<1);\t\t\tfac[i]=fac[i-1]*i%M;\t\t\tinv[i]=i>1?inv[M%i]*(M-M/i)%M:1;\t\t\tinvfac[i]=invfac[i-1]*inv[i]%M;\t\t\tr(a[i].l,a[i].r);\t\t\tst.emplace(a[i].l);\t\t}\t\tstd::sort(a+1,a+n+1,[](const ss&a,const ss&b){return a.r<b.r;});\t\tfor(i=1;i<=n;i++){\t\t\twhile(!st.empty()&&*st.begin()<=a[i].r)st.erase(*st.begin());\t\t\tans=(ans-a[i].r*f(i-1,st.size()))%M;\t\t}\t\tfor(i=1;i<=n;i++)st.emplace(a[i].r);\t\tstd::sort(a+1,a+n+1,[](const ss&a,const ss&b){return a.l>b.l;});\t\tfor(i=1;i<=n;i++){\t\t\twhile(!st.empty()&&*st.rbegin()>=a[i].l)st.erase(*st.rbegin());\t\t\tans=(ans+a[i].l*f(i-1,st.size()))%M;\t\t}\t\tw(ans);\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G2. The Destruction of the Universe  Hard Version .json",
    "hint": []
}