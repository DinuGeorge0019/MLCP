{
    "link": "https://codeforces.com//contest/1492/problem/D",
    "problemId": "905859",
    "problem_idx": "D",
    "shortId": "1492D",
    "contest_number": "1492",
    "problem_submissions": {
        "E": [
            108275392,
            108337957,
            108337929,
            108337897,
            108337869,
            108337530,
            108336584,
            108280929,
            108279892,
            108283262,
            108283717,
            108289278,
            108287786,
            108268660,
            108390482,
            108288687,
            108282322,
            108287306,
            108280347,
            108291576,
            108288062,
            108373037,
            108293277,
            129805186,
            108287644,
            108300980,
            108299703,
            108393370
        ],
        "D": [
            108260382,
            108258893,
            108270014,
            108263349,
            108264609,
            108252892,
            108264793,
            108287598,
            108390440,
            108271913,
            108257825,
            108266386,
            108268610,
            108279786,
            108409580,
            108293329,
            108289857,
            108251059,
            108267145,
            108268232,
            108256122,
            108256138
        ],
        "C": [
            108249862,
            108249847,
            108251625,
            108254267,
            108251919,
            108258077,
            108250178,
            108246037,
            108390405,
            108300472,
            108250750,
            108280684,
            108253606,
            108267184,
            108256872,
            108409648,
            108265283,
            108263373,
            108244223,
            108254346,
            108334110,
            108246220,
            108249150
        ],
        "B": [
            108245129,
            108245447,
            108247395,
            108247985,
            108246834,
            108246031,
            108256869,
            108242298,
            108390120,
            108243502,
            108256163,
            108245585,
            108255038,
            108249056,
            108252947,
            108246277,
            108240957,
            108244517,
            108243521,
            108242960,
            108244326
        ],
        "A": [
            108239344,
            108239466,
            108239941,
            108241103,
            108239731,
            108245369,
            108243343,
            108239512,
            108390047,
            108239332,
            108245439,
            108239555,
            108241591,
            108245013,
            108409613,
            108242749,
            108239786,
            108239373,
            108240879,
            108239525,
            108239590,
            108239428
        ]
    },
    "name": "D. Genius s Gambit",
    "statement": "You are given three integers a, b, k.Find two integers x and y (x\r\nge y) such that both x and y consist of a zeroes and b ones; x - y (also\r\nwritten in binary form) has exactly k ones. You are .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n\nll MOD = (ll)1000000007;\nvector<ll> nums;\nbool nums1[200001], nums2[200001];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t, m, n, k;\n    ll ans = 0;\n    string s1, s2;\n    bool sad = false;\n    cin >> m >> n >> k;\n    if(m == 0 || n == 1) {\n        if(k == 0) {\n            cout << \"Yes\\n\";\n            for(int i = 0; i < n; i++) cout << 1;\n            for(int i = 0; i < m; i++) cout << 0;\n            cout << '\\n';\n            for(int i = 0; i < n; i++) cout << 1;\n            for(int i = 0; i < m; i++) cout << 0;\n        }\n        else {\n            cout << \"No\\n\";\n        }\n        return 0;\n    }\n    if(m + n < k + 2) {\n        cout << \"No\\n\";\n        return 0;\n    }\n    cout << \"Yes\\n\";\n    int x = n-2;\n    cout << 1;\n    for(int i = 1; i < m+n; i++) {\n        if(i == 1) {\n            cout << 1;\n            continue;\n        }\n        if(i == k+1) {\n            cout << 0;\n            continue;\n        }\n        if(x) {\n            x--;\n            cout << 1;\n        }\n        else cout << 0;\n    }\n    x = n-2;\n    cout << \"\\n1\";\n    for(int i = 1; i < m+n; i++) {\n        if(i == k+1) {\n            cout << 1;\n            continue;\n        }\n        if(i == 1) {\n            cout << 0;\n            continue;\n        }\n        if(x) {\n            x--;\n            cout << 1;\n        }\n        else cout << 0;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Genius s Gambit.json",
    "editorial_link": "https://codeforces.com//blog/entry/87792",
    "editorial": "This problem has a cute constructive solution. If or the answer is\r\ntrivial. In other cases letâs fix as a number in form . Let , then we\r\nwill change only . Letâs take the last digit from the consecutive prefix\r\nof ones, then move it positions to the right. It is easy to see, that\r\nthe number of ones in has increased by . If we already have the answer.\r\nIf not, letâs take the last digit from the consecutive prefix of ones\r\nand move it one position to the right. The number of ones in the answer\r\nincreased by one and if it is less than , we just repeat this move. With\r\nthis construction we can easily build an answer for every Itâs not\r\ndifficult to prove that the answer does not exist when .\r\n",
    "hint": []
}