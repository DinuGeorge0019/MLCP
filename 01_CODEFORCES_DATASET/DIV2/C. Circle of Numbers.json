{
    "link": "https://codeforces.com//contest/263/problem/C",
    "problemId": "2518",
    "problem_idx": "C",
    "shortId": "263C",
    "contest_number": "263",
    "problem_submissions": {
        "E": [
            2943196
        ],
        "D": [
            2942145,
            2939985,
            2942208,
            2939952,
            2940748,
            2942993,
            2943370,
            2941259,
            2941637,
            2940304,
            2943228,
            2941800,
            2941304,
            2944161,
            2943666,
            2944368,
            2940892
        ],
        "C": [
            2940759,
            2941829,
            2940936,
            2942500,
            2943328,
            2941933,
            2942288,
            2943440,
            2943805,
            2944431,
            2942111,
            2943776,
            2944668,
            2943093,
            2943041,
            2942906,
            2944522
        ],
        "B": [
            2938515,
            2938111,
            2937699,
            2937858,
            2938311,
            2938172,
            2938572,
            2938277,
            2938614,
            2941034,
            2937866,
            2938119,
            2938506,
            2938610,
            2938586,
            2938823,
            2938384
        ],
        "A": [
            2937160,
            2937166,
            2936927,
            2936979,
            2936967,
            2936966,
            2936959,
            2936975,
            2937475,
            2941215,
            2938221,
            2937216,
            2937223,
            2937302,
            2937515,
            2937451,
            2937077
        ]
    },
    "name": "C. Circle of Numbers",
    "statement": "One day Vasya came up to the blackboard and wrote out distinct integers\r\nfrom to in some order in a circle. Then he drew arcs to join the pairs\r\nof integers , that are either each other’s immediate neighbors in the\r\ncircle, or there is number , such that and are immediate neighbors, and\r\nand are immediate neighbors. As you can easily deduce, in the end Vasya\r\ndrew arcs.For example, if the numbers are written in the circle in the\r\norder (in the clockwise direction), then the arcs will join pairs of\r\nintegers , , , , , , , , and .Much time has passed ever since, the\r\nnumbers we wiped off the blackboard long ago, but recently Vasya has\r\nfound a piece of paper with written pairs of integers that were joined\r\nwith the arcs on the board. Vasya asks you to find the order of numbers\r\nin the circle by these pairs.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define MN 100100\n\nstd::vector<int> ee[MN], ans;\nint n, ls[10];\nbool app[MN];\n\ninline bool nei(int a, int b) {\n    for(int i=0; i<4; i++)\n        if(ee[a][i] == b) return true;\n    return false;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n+n; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        if(a == b) {\n            puts(\"-1\");\n            return 0;\n        }\n        ee[a].push_back(b);\n        ee[b].push_back(a);\n    }\n    for(int i=1; i<=n; i++) {\n        if(ee[i].size() != 4) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n\n    // QQ!!\n\n    if(n <= 10) {\n        int ar[30] = {};\n        for(int i=0; i<n; i++) ar[i] = i+1;\n        do {\n            ar[n] = ar[0];\n            ar[n+1] = ar[1];\n            \n            bool ok = true;\n\n            for(int i=0; i<n; i++) {\n                if(!nei(ar[i], ar[i+1]) || !nei(ar[i], ar[i+2])) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok) {\n                for(int i=0; i<n; i++)\n                    printf(\"%d%c\", ar[i], i==n-1 ? '\\n' : ' ');\n                return 0;\n            }\n        } while( std::next_permutation( ar, ar+n ) );\n        \n        puts(\"-1\");\n        return 0;\n    }\n\n\n    int st = 1, pre = -1;\n    while(!app[st]) {\n        app[st] = true;\n        ans.push_back(st);\n        int nxt = st;\n        for(int i=0; i<4; i++) {\n            int cnt = 0;\n            for(int j=0; j<4; j++)\n                if(nei(ee[st][i], ee[st][j])) cnt ++;\n            if(cnt == 2 && ee[st][i] != pre) {\n                nxt = ee[st][i];\n                break;\n            }\n        }\n        if(nxt == st) {\n            puts(\"-1\");\n            return 0;\n        }\n        pre = st;\n        st = nxt;\n    }\n    if((int)ans.size() < n) {\n        puts(\"-1\");\n        return 0;\n    }\n    ans.push_back(ans[0]);\n    ans.push_back(ans[1]);\n    for(int i=0; i<n; i++) {\n        if(!nei(ans[i], ans[i+1]) || !nei(ans[i], ans[i+2])) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for(int i=0; i<n; i++)\n        printf(\"%d%c\", ans[i], i==n-1 ? '\\n' : ' ');\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Circle of Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/6419",
    "editorial": "First of all, we have to check that each number occurs in the input\r\nexactly 4 times. If itâs not true, then the answer definitely doesnât\r\nexist. Otherwise, letâs try to restore the circle. As cyclic shift of\r\ncircle doesnât matter, let to be the first number. As the second and the\r\nthird number must be connected to each other and to , there are only few\r\npossibilities. So letâs try them all. And when we know first three\r\nnumbers, the rest of the circle could be easily and unambiguously\r\nrestored in . Just find a number, which is not included in the circle\r\nyet, and is connected to the last two numbers of the circle. Add this\r\nnumber to the resulting circle (as new last number), and repeat the\r\nprocedure while possible. If we succeeded to add all the numbers to the\r\ncircle, than the resulting circle is the answer.\r\n",
    "hint": []
}