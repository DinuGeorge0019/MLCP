{
    "link": "https://codeforces.com//contest/2063/problem/F2",
    "problemId": "3154908",
    "problem_idx": "F2",
    "shortId": "2063F2",
    "contest_number": "2063",
    "problem_submissions": {
        "F2": [
            302425610,
            302451940,
            302442929,
            302441504,
            302438014,
            302448830,
            302447651,
            302449239,
            302451441,
            302441520,
            302449441,
            302462040,
            302527079
        ],
        "C": [
            302417331,
            302388966,
            302380666,
            302386796,
            302391515,
            302388488,
            302384390,
            302383854,
            302392461,
            302390039,
            302389493,
            302385787,
            302379767,
            302392628,
            302382228,
            302388334,
            302383676,
            302394839,
            302388632,
            302391072
        ],
        "D": [
            302412152,
            302402949,
            302396428,
            302402633,
            302409161,
            302404535,
            302411549,
            302409325,
            302409501,
            302412675,
            302403620,
            302420625,
            302411254,
            302422339,
            302414704,
            302406132,
            302417532,
            302411171,
            302418058,
            302418384
        ],
        "E": [
            302404720,
            302395352,
            302418668,
            302414791,
            302422680,
            302426848,
            302421742,
            302427528,
            302428407,
            302458083,
            302451720,
            302434097,
            302422758,
            302403323,
            302431883,
            302433354,
            302432981,
            302436125,
            302427678,
            302431985
        ],
        "F1": [
            302388355,
            302424887,
            302442481,
            302433761,
            302438421,
            302445686,
            302447198,
            302443757,
            302450796,
            302427723,
            302449982,
            302451319,
            302436505,
            302455100,
            302448501,
            302454721,
            302454623,
            302448067,
            302454995,
            302448498
        ],
        "B": [
            302385897,
            302389386,
            302371425,
            302391237,
            302379321,
            302378690,
            302373741,
            302377026,
            302378459,
            302385735,
            302370221,
            302376737,
            302372000,
            302386149,
            302374530,
            302374437,
            302376025,
            302383492,
            302381557,
            302378496
        ],
        "A": [
            302374954,
            302366962,
            302363313,
            302365021,
            302366134,
            302366042,
            302365897,
            302366966,
            302363934,
            302362493,
            302362600,
            302366245,
            302365093,
            302367784,
            302363061,
            302365428,
            302365621,
            302368569,
            302369401,
            302377605
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138593",
    "editorial": "If you have not read the editorial for the easy subtask, I strongly\r\nsuggest you to read it first. It contains some important observations\r\nthat carry on to the solution of the hard subtask.The easy subtask’s\r\nsolution relied on enumerating the \"minimal balanced subsequences\". (We\r\nwill use this same term repeatedly in the hard subtask’s editorial, so\r\nwe abbreviate it to \"MBS(es)\" for convenience. Note that, , the\r\ndefinition of MBSes in the hard version’s editorial includes the good\r\npairs themselves.) Now, the hard subtask makes it impossible to use the\r\nsolution, so we cannot enumerate the MBSes. The hard subtask asks for a\r\nmore clever approach.An important observation for the hard subtask is as\r\nfollows: : When a new good pair is added, in fact, most MBSes do not\r\nchange. If a good pair is added on an MBS which is enclosed by another\r\nMBS , the MBS does not change because the good pair does not give any\r\nadditional information about . (It just gave the information that some\r\nsupersequence of is balanced, but that doesn’t make any additional\r\ninformation about .)If a good pair is added on an MBS which encloses\r\nanother MBS , the MBS does not change because the good pair does not\r\ngive any additional information about . (It just gave the information\r\nthat some supersequence of is balanced, but that doesn’t make any\r\nadditional information about .)If a good pair is added on an MBS and\r\nthere is another MBS not enclosing/enclosed by it, the MBS does not\r\nchange either; the two MBSes are simply independent.Therefore, when the\r\ngood pair is added on an MBS , the only MBS that changes is , and all\r\nother MBSes do not change.Let’s observe what happens when a good pair is\r\nadded on an MBS . Precisely the following things happen according to the\r\ninformation that this good pair adds: As the subsequence inside the good\r\npair must be balanced, the subsequence containing indices inside the\r\ngood pair becomes a new MBS (assuming that it exists). As the\r\nsubsequence outside the good pair must be balanced, the subsequence\r\ncontaining indices outside the good pair becomes a new MBS (assuming\r\nthat it exists). The good pair itself becomes a new MBS, assuming the\r\nMBS was not a single good pair. Thus, the MBS splits into at most three\r\nnew MBSes upon the addition of a good pair.For example, if the MBS was ,\r\nand the good pair is , the MBS splits to three following MBSes: inside\r\nthe good pair; outside the good pair; denoting the good pair itself.\r\nNote that the two brackets making a good pair are always added on the\r\nsame MBS, because otherwise it must make \"contradicting informations\".If\r\nwe can track the MBSes, split efficiently, and count the number of\r\nindices in the resulting MBSes, we can do the following to update the\r\nanswer: When an MBS is split into three MBSes , and the good pair,\r\ndivide (multiply the inverse) the answer by , and multiply the answer by\r\n. The Catalan number corresponding to the good pair is automatically ,\r\nso it does not matter. To deal with the required operations, the model\r\nsolution uses a forest of splay trees. A forest of splay trees is just a\r\nsplay tree which does not specify a single root, so there can be\r\nmultiple roots in the structure. In practice, a node is considered a\r\nroot simply if it does not have a parent. Ideally, it is most convenient\r\nto implement it on a sequential data structure (e.g. vector) using\r\nindices than using pointers in this task, because you will need to\r\naccess a node immediately given the index. It is possible to do the same\r\nusing treaps, but some operations’ implementation may be more convoluted\r\nif you use treaps.You can notice that detecting if there exist\r\nsubsequences inside or outside the good pair naturally translate to a\r\nseries of simple operations on the splay tree, like follows: : if there\r\nexists a subsequence inside the good pair , you can splay the node and\r\ncut its right subtree. Now the right subtree will only contain values\r\ngreater than , so if you splay node on it, node will not have a left\r\nsubtree if and only if there was no subsequence inside . If there exists\r\na subsequence inside, then the left child of is one element of the\r\nsubsequence inside. : if there exists a subsequence outside the good\r\npair , the tree will have values either less than or greater than . In\r\nother words, if you splay node and find a left subtree, or splay node\r\nand find a right subtree, there exists a subsequence outside. : The left\r\nsubtree of after it is splayed, and the right subtree of after it is\r\nsplayed, might both have two children. If that is the case, you can\r\nsimply find the leftmost node in the right subtree of and splay it, and\r\nthen connect the left subtree of to its left. (This is only just a\r\nsimple binary search tree operation.) : This is simple; we already found\r\nat least one node corresponding to each of the two subsequences. Splay\r\nthe two nodes and find the size of the trees. Now the only thing left in\r\nthe solution is careful implementation. The solution has an amortized\r\ntime complexity of , and runs comfortably in second.Though the model\r\nsolution used a complex data structure to utilize its convenient\r\ncharacteristics, the author acknowledges that it is possible to replace\r\nsome details or entire sections of the editorial with other data\r\nstructures or techniques such as segment trees or a smaller-to-larger\r\ntrick. If you can prove that your solution works in time complexity with\r\na not too terrible constant, your solution is deemed to be correct.\r\n",
    "name": "F2. Counting Is Not Fun  Hard Version ",
    "statement": "A bracket sequence is called if it can be constructed by the following\r\nformal grammar. The empty sequence\r\nvarnothing is balanced. If the bracket sequence A is balanced, then\r\nmathtt{(}A\r\nmathtt{)} is also balanced. If the bracket sequences A and B are\r\nbalanced, then the concatenated sequence A B is also balanced. For\r\nexample, the sequences \"\", \"\", \"\", and the empty sequence are balanced,\r\nwhile \"\" and \"\" are not.Given a balanced bracket sequence s, a pair of\r\nindices (i,j) (i<j) is called a if s_i is ”, s_j is ”, and the two\r\nbrackets are added simultaneously with respect to Rule 2 while\r\nconstructing the sequence s. For example, the sequence \"\" has three\r\ndifferent good pairs, which are (1,4), (2,3), and (5,6). One can show\r\nthat any balanced bracket sequence of 2n brackets contains exactly n\r\ndifferent good pairs, and using any order of rules to construct the same\r\nbracket sequence will yield the same set of good pairs.Emily will play a\r\nbracket guessing game with John. The game is played as\r\nfollows.Initially, John has a balanced bracket sequence s containing n\r\ndifferent good pairs, which is not known to Emily. John tells Emily the\r\nvalue of n and asks Emily to guess the sequence.Throughout n turns, John\r\ngives Emily the following kind of clue on each turn. l\r\n;r: The sequence s contains a good pair (l,r). The clues that John gives\r\nEmily are pairwise distinct and do not contradict each other.At a\r\ncertain point, Emily can be certain that the balanced bracket sequence\r\nsatisfying the clues given so far is unique. For example, assume Emily\r\nknows that s has 3 good pairs, and it contains the good pair (2,5). Out\r\nof 5 balanced bracket sequences with 3 good pairs, there exists only one\r\nsuch sequence \"\" with the good pair (2,5). Therefore, one can see that\r\nEmily does not always need n turns to guess s.To find out the content of\r\ns as early as possible, Emily wants to know the number of different\r\nbalanced bracket sequences that match the clues after each turn. Surely,\r\nthis is not an easy job for Emily, especially when she is given so many\r\ngood pairs. Now it is your turn to help Emily. Given the clues, you must\r\nfind the answer before and after each turn. As the answers may be huge,\r\nyou need to find them modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "bool M1;#define look_memory cerr<<abs(&M2-&M1)/1024.0/1024<<\" MB\\n\"#define look_time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\\n'#include <cstdio>#include <cmath>#include <iomanip>#include <iostream>#include <cstring>#include <array>#include <algorithm>#include <queue>#include <vector>#include <bitset>#include <ctime>#include <cstdlib>#include <random>#include <set>#include <ctime>#include <map>#include <stack>#include <unordered_map>#include <assert.h>#include <unordered_set>#define i128 __int128#define ll long long#define uint unsigned#define ull unsigned long long#define ld long double#define fo(a,b,c) for(ll a=b;a<=c;++a)#define re(a,b,c) for(ll a=b;a>=c;--a)#define pii pair<ll,ll>#define pdd pair<db,db>#define fi first#define pb push_back#define se second#define ite set<array<ll,3>> ::iterator#define vite vector<ll> ::iterator#define mite map<ll,ll> ::iteratorusing namespace std;const ll mod=998244353;inline ll gi(){\tll x = 0, f = 1;\tchar ch = getchar();\twhile(ch < '0' || ch > '9')\t{\t\tif (ch == '-')\t\t\tf = -1;\t\tch = getchar();\t}\twhile(ch >= '0' && ch <= '9')\t{\t\tx = (x<<1) + (x<<3) + (ch^48);\t\tch = getchar();\t}\treturn x * f;}ll _=1;const ll inf=2e17+5,iinf=1e9+5;const ll N=600005;ll ksm(ll a,ll b){\tll c=1;\twhile(b)\t{\t\tif(b&1) c=c*a%mod;\t\ta=a*a%mod;\t\tb/=2;\t}\treturn c;}ll fac[N],ifac[N],cat[N];ll C(ll a,ll b){\treturn fac[a]*ifac[b]%mod*ifac[a-b]%mod;}void init(ll n){\tfac[0]=1;\tfo(i,1,n) fac[i]=fac[i-1]*i%mod;\tifac[n]=ksm(fac[n],mod-2);\tre(i,n-1,0) ifac[i]=ifac[i+1]*(i+1)%mod;}ll il[N],ir[N],len[N],ans[N],num[N],nw;void del(ll x){\tnw=nw*ksm(cat[x/2],mod-2)%mod;}void ins(ll x){\tnw=nw*cat[x/2]%mod;}vector<ll> g[N];ll tot,n,fa[N],re[N];void dfs(ll u,ll dj){\tif(dj==n*2+1)\t{\t\treturn;\t}\tif(len[dj]==1)\t{\t\tdfs(fa[u],dj+1);\t\treturn;\t}\ttot++;\tre[dj]=tot;\tg[u].pb(tot);\tg[tot].pb(u);\tfa[tot]=u;\tdfs(tot,dj+1);}ll pa[N];ll fd(ll x){\tif(pa[x]==x) return x;\treturn pa[x]=fd(pa[x]);}void sol(){\tnw=1;\tn=gi();\tfo(i,0,2*n+2) num[i]=0,g[i].clear(),pa[i]=i;\tfo(i,1,n)\t{\t\til[i]=gi(),ir[i]=gi();\t\tlen[il[i]]=0;\t\tlen[ir[i]]=1;\t}\tinit(n*2);\tcat[0]=1;\tfo(i,1,n) cat[i]=(C(2*i,i)-C(2*i,i-1)+mod)%mod;\ttot=1;\tdfs(1,1);//\tfo(i,1,tot)//\t{//\t\tcout<<fa[i]<<\" \";//\t}//\tcout<<'\\n';\tnw=1;\tre(i,n,1)\t{\t\tans[i]=nw;\t\tll id=re[il[i]];//\t\tcout<<\"FFFF \"<<i<<\" \"<<il[i]<<\" \"<<re[il[i]]<<'\\n';\t\tdel(num[id]);\t\tll fx=fd(fa[id]);\t\tdel(num[fx]);\t\tnum[fx]+=num[id]+2;\t\tpa[id]=fx;\t\tins(num[fx]);//\t\tcout<<\"TEST \"<<id<<\" \"<<fx<<'\\n';//\t\tcout<<\"FUCK \"<<num[1]<<'\\n';\t}\tans[0]=nw;\tfo(i,0,n)\t{\t\tcout<<ans[i]<<\" \";\t}}bool M2;int main(){\tint Time=clock();\tlook_memory;\t_=gi();\twhile(_--)\t{\t\tsol();\t\tprintf(\"\\n\");\t}\tlook_time;\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Counting Is Not Fun  Hard Version .json",
    "hint": [
        "Hint In the solution of the easy subtask, we manually enumerated the minimal balanced subsequences, each time in . You can show that most minimal balanced subsequences do not change when a new clue is added. What data structure will you choose in order to utilize this fact as much as possible?"
    ]
}