{
    "link": "https://codeforces.com//contest/937/problem/B",
    "problemId": "159982",
    "problem_idx": "B",
    "shortId": "937B",
    "contest_number": "937",
    "problem_submissions": {
        "B": [
            35696794,
            35702864,
            35692823,
            35690729,
            35694513,
            35690544,
            35690257,
            35698410,
            35691221,
            35690892,
            35691375,
            35702558,
            35696021,
            35691603,
            35692248,
            35693511,
            35689627,
            35691074
        ],
        "D": [
            35692697,
            35713147,
            35697020,
            35698388,
            35700044,
            35703123,
            35701138,
            35701740,
            35699988,
            35703153,
            35699440,
            35715758,
            35702654,
            35703145,
            35702583,
            35705096,
            35704134,
            35704747
        ],
        "C": [
            35687317,
            35691596,
            35689373,
            35694359,
            35690896,
            35693744,
            35693408,
            35694406,
            35694106,
            35697537,
            35696111,
            35691520,
            35694573,
            35696303,
            35696728,
            35696658,
            35694289,
            35696468,
            35696813
        ],
        "A": [
            35686618,
            35687353,
            35687073,
            35686895,
            35689698,
            35687175,
            35687230,
            35687897,
            35688429,
            35688503,
            35687868,
            35688027,
            35686930,
            35689664,
            35687167,
            35686480,
            35686539
        ],
        "E": [
            35699925,
            35705854,
            35766833,
            35707300,
            35705001,
            35707037,
            35726109,
            35750977,
            35707021
        ]
    },
    "name": "B. Vile Grasshoppers",
    "statement": "The weather is fine today and hence it\u2019s high time to climb the nearby\r\npine and enjoy the landscape.The pine\u2019s trunk includes several branches,\r\nlocated one above another and numbered from to . Some of them (more\r\nprecise, from to ) are occupied by tiny vile grasshoppers which you\u2019re\r\nat war with. These grasshoppers are known for their awesome jumping\r\nskills: the grasshopper at branch can jump to branches .Keeping this in\r\nmind, you wisely decided to choose such a branch that none of the\r\ngrasshoppers could interrupt you. At the same time you wanna settle as\r\nhigh as possible since the view from up there is simply breathtaking.In\r\nother words, your goal is to find the highest branch that cannot be\r\nreached by any of the grasshoppers or report that it\u2019s impossible.\r\n",
    "solutions": [
        "//\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl \"\\n\"\n#define mp make_pair\n\nconst int mod = 1000000007;\nconst int INF = 1000000000;\n\nint p, y;\nint result = -1;\nint crossed[35005];\nvector <int> prime;\n\nint getMin(int x);\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    for (int i = 2; i * i <= 35000; i++) {\n        if (!crossed[i]) {\n            for (int j = i * i; j <= 35000; j += i)\n                crossed[j] = 1;\n        }\n    }\n\n    for (int i = 2; i <= 35000; i++) {\n        if (!crossed[i])\n            prime.push_back(i);\n    }\n\n    cin >> p >> y;\n\n    for (int i = y; (i > p); i--) {\n        if (getMin(i) > p) {\n            result = i;\n\n            break;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n\nint getMin(int x) {\n    for (int i = 0; i < prime.size(); i++) {\n        if (!(x % prime[i]))\n            return prime[i];\n    }\n\n    return x;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Vile Grasshoppers.json",
    "editorial_link": "https://codeforces.com//blog/entry/58056",
    "editorial": "The first observation is that the optimal branch shouldn\u00e2\u0080\u0099t be divisible\r\nby anything in range . Let us decrease until its minimal divisor (other\r\nthan one) is greater than .Why does this approach work? Note that the\r\nthe nearest prime less or equal to is valid. At the same time the prime\r\ngap of numbers less than billion doesn\u00e2\u0080\u0099t exceed and we\u00e2\u0080\u0099re gonna\r\nfactorize no more than numbers in total. Therefore the complexity is .\r\n"
}