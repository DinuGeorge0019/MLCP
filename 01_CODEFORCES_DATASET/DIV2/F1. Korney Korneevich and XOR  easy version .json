{
    "link": "https://codeforces.com//contest/1582/problem/F1",
    "problemId": "1156636",
    "problem_idx": "F1",
    "shortId": "1582F1",
    "contest_number": "1582",
    "problem_submissions": {
        "G": [
            133300654,
            132904411,
            132903819,
            132921500,
            132938189,
            132915561,
            132904925,
            132893999,
            132930384,
            132930246,
            132930119,
            132929885,
            132929830,
            132917984,
            132923122,
            132922486,
            132909943,
            132922580,
            132929375,
            132930555,
            133312799,
            132969396
        ],
        "F2": [
            132908314,
            132865018,
            132905309,
            132899324,
            132901682,
            132900235,
            132911727,
            132926934,
            132906558,
            132909549,
            132893391,
            132884523,
            132901241,
            132906554,
            132898256,
            133312622,
            132970055,
            132969976,
            132904321
        ],
        "F1": [
            132881252,
            132864382,
            132880627,
            132888291,
            132872964,
            132880051,
            132887180,
            132892561,
            132900410,
            132897751,
            132862757,
            132872739,
            132870584,
            132888250,
            132889092,
            132882038,
            132891013,
            132872187,
            132887941,
            133312616,
            132891504
        ],
        "E": [
            132874913,
            132878099,
            132874176,
            132880923,
            132882227,
            132876672,
            132871740,
            132883982,
            132905776,
            132893914,
            132871055,
            132859358,
            132881562,
            132870144,
            132885086,
            132894857,
            132869674,
            132887914,
            132877059,
            133312375,
            132888626
        ],
        "D": [
            132866716,
            132891541,
            132886280,
            132871648,
            132863103,
            132871610,
            132863993,
            132875189,
            132911684,
            132876113,
            132889182,
            132879862,
            132890109,
            132872530,
            132875475,
            132891337,
            132884986,
            132886500,
            132884112,
            133312126,
            132970973,
            132882901
        ],
        "C": [
            132859265,
            132871828,
            132860284,
            132861165,
            132856817,
            132935747,
            132866931,
            132863031,
            132863018,
            132893464,
            132893294,
            132866549,
            132861428,
            132858872,
            132861957,
            132863927,
            132861005,
            132863860,
            132868896,
            133312107,
            132858386
        ],
        "B": [
            132856790,
            132867123,
            132856747,
            132855505,
            132854485,
            132859085,
            132858770,
            132858595,
            132856173,
            132857637,
            132856186,
            132859468,
            132855951,
            132855099,
            132854810,
            132855351,
            132856357,
            132855765,
            132859435,
            133312040,
            132970544,
            132854847
        ],
        "A": [
            132855030,
            132855528,
            132854523,
            132892082,
            132854129,
            132904251,
            132854758,
            132854419,
            132906994,
            132854763,
            132856077,
            132854737,
            132984138,
            132854196,
            132859118,
            132854306,
            132855186,
            132865041,
            132857131,
            133311808,
            132970350,
            132854128
        ]
    },
    "name": "F1. Korney Korneevich and XOR  easy version ",
    "statement": "Korney Korneevich dag up an array a of length n. Korney Korneevich has\r\nrecently read about the operation bitwise XOR, so he wished to\r\nexperiment with it. For this purpose, he decided to find all integers x\r\nge 0 such that there exists an subsequence of the array a, in which the\r\nbitwise XOR of numbers is equal to x.It didn’t take a long time for\r\nKorney Korneevich to find all such x, and he wants to check his result.\r\nThat’s why he asked you to solve this problem!A sequence s is a\r\nsubsequence of a sequence b if s can be obtained from b by deletion of\r\nseveral (possibly, zero or all) elements.A sequence s_1, s_2,\r\nldots , s_m is called increasing if s_1 < s_2 <\r\nldots < s_m.\r\n",
    "solutions": [
        "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 512;\n\nvoid solve(const vector<int>& a) {\n\tvector<int> f(M, M);\n\tf[0] = -1;\n\tfor (int val : a) {\n\t\tvector<int> g = f;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (g[i] < val) {\n\t\t\t\tf[i ^ val] = min(f[i ^ val], val);\n\t\t\t}\n\t\t}\n\t}\n\tint count = 0;\n\tfor (int val = 0; val < M; ++val) {\n\t\tif (f[val] < M) {\n\t\t\t++count;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", count);\n\tfor (int val = 0; val < M; ++val) {\n\t\tif (f[val] < M) {\n\t\t\tprintf(\"%d \", val);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"f.in\", \"r\", stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tsolve(a);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Korney Korneevich and XOR  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/96267",
    "editorial": "Let's iterate over all numbers of the array and for each number t\n maintain a list gt\n of all numbers y\n, such that it's possible to choose an increasing subsequence on the current prefix, in which xor\n of numbers is equal to y\n, and the last number of that increasing subsequence is less than t\n.\n\nLet us currently consider the element ai\n. Then let's consider elements of gai\n  there will be all values of xor\n-s of the subsequences to which we can append the element ai\n. If gai\n contains a value f\n, then it's possible to get a value f?ai\n, then let's add the value f?ai\n to all lists g\n from ai+1\n to the maximal value of a\n (if the value that is being added is already in some g\n-s, it's unnecessary to add it there again).\n\nLet's perform some optimizations for this solution.\n\nLet's stop considering the values gt\n that have already been considered. That is, if we have already considered gt\n at some iteration, then let's erase it, but remember that we never need to add the values of xor\n, that are being erased. That optimization is sufficient to get the asymptotic behaviour O((max_a)3)\n, where max_a\n is the greatest one among all numbers of the array a\n (for every number t\n and its possible value of xor\n f\n we will pass over the value t?f\n to all states t+1,,max_a\n; the amount of different t\n is O(max_a)\n, the amount of f\n is O(max_a)\n as well, and the passing of the value each time is performed in O(max_a)\n).\nLet's notice that when we pass some value of xor\n equal to f\n to elements t+1,,max_a\n, and find the element r\n, in which that value of xor\n has already been, then the value f\n is already in all elements greater than r\n, and that's why we don't have to add the value f\n any further. Using this optimization we can finally get a solution in O(max_a2)\n, since for every value of xor\n (the amount of them is O(max_a)\n), we perform O(max_a)\n operations.\nIn total (considering all optimizations), the asymptotic behaviour of the solution is O(n+(max_a)2)\n.",
    "hint": []
}