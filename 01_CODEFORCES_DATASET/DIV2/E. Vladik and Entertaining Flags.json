{"link": "https://codeforces.com//contest/811/problem/E", "problemId": "107533", "problem_idx": "E", "shortId": "811E", "contest_number": "811", "problem_submissions": {"E": [27384705, 106269730, 27384523, 27384734, 27377479, 27382245, 27387921, 27385994, 27378312, 27417485, 27383230, 27385468, 27379502, 27382190, 27381400, 27383006], "D": [27379365, 27381500, 27381222, 27386537, 27382445, 27381225, 27382121, 27382035, 27384111, 27380209, 27384960, 27386244, 27384575, 27385712, 27381029, 27382189, 27383952], "C": [27375763, 27376427, 27377289, 27382636, 27375842, 27378042, 27373086, 27379255, 27377375, 27374603, 27380152, 27380818, 27378127, 27376964, 27376298, 27380327, 27375518, 27379100, 27378177, 27379352], "B": [27372900, 27372650, 27375003, 27380196, 27375149, 27373634, 27384935, 27374432, 27374563, 27374805, 27389142, 27372946, 27375127, 27378423, 27372846, 27373956, 27374358], "A": [27371146, 27371406, 27372004, 27371481, 27372708, 27371377, 27372619, 27371210, 27371813, 27371396, 27371888, 27371519, 27371189, 27371592, 27371623, 27372374, 27385878, 27371337, 27371714, 27372067]}, "name": "E. Vladik and Entertaining Flags", "statement": "In his spare time Vladik estimates beauty of the flags.Every flag could\r\nbe represented as the matrix which consists of positive integers.Let\u2019s\r\ndefine the beauty of the flag as number of components in its matrix. We\r\ncall component a set of cells with same numbers and between any pair of\r\ncells from that set there exists a path through adjacent cells from same\r\ncomponent. Here is the example of the partitioning some flag matrix into\r\ncomponents: But this time he decided to change something in the process.\r\nNow he wants to estimate not the entire flag, but some segment. Segment\r\nof flag can be described as a submatrix of the flag matrix with opposite\r\ncorners at and , where conditions are satisfied.Help Vladik to calculate\r\nthe beauty for some segments of the given flag.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define rep(i,j,k) for((i)=(j);(i)<=(k);++i)\n#define per(i,j,k) for((i)=(j);(i)>=(k);--i)\nusing namespace std;\ntypedef long long ll;\ninline void cmin(int &x,int y){if(y<x)x=y;}\ninline void cmax(int &x,int y){if(y>x)x=y;}\nconst int N = 1000006;\nint a[12][N],sum[N],tmp[N],bcj[N],f[N][22],id[N],n,m,T,i,j,l,r;\nint inline read(){\n\tchar ch=getchar();int z=0,f=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){z=z*10+ch-'0';ch=getchar();}\n\treturn z*f;\n}\nint find(int x){if(bcj[x]==x)return x;return bcj[x]=find(bcj[x]);}\n/*int calc(int j,int k){\n\tint i , ans = 0;\n\trep(i,1,n) if(i == 1 || a[i][j] != a[i-1][j]) f[i] = i; else f[i] = f[i - 1];\n\trep(i,1,n) if(i == 1 || a[i][k] != a[i-1][k]) f[i+n] = i+n; else f[i+n] = f[i+n-1];\n\trep(i,1,n) if(a[i][j] == a[i][k] && find(i) != find(i + n)){++ans; f[find(i + n)] = find(i);}\n\treturn ans;\n}*/\nint calc(int f[],int g[],int j,int k){\n\tint i,ans = 0;\n\trep(i,1,n+n) bcj[i] = f[i];\n\trep(i,1,n+n) bcj[n+n+i] = n + n + g[i];\n\trep(i,1,n)\n\t\tif(a[i][j] == a[i][k] && find(n + i) != find(n + n + i)){++ans; bcj[find(n + n + i)] = find(n + i);}\n\treturn ans;\n}\nvoid build(int l,int r,int x){\n\tint mid=l+r>>1,i;\n\tif(l == r){\n\t\tint ans = 1;\n\t\trep(i,2,n) if(a[i][l] != a[i-1][l]) ++ans;\n\t\tsum[x] = ans;\n\t\trep(i,1,n) if(i == 1 || a[i][l] != a[i-1][l]) f[x][i] = i; else f[x][i] = f[x][i - 1];\n\t\trep(i,1,n) f[x][n + i] = f[x][i];\n\t\t//printf(\"a %d %d\\n\",l,r);\n\t\t//rep(i,1,n+n) printf(\"%d \",f[x][i]); puts(\"\");\n\t}else{\n\t\tbuild(l,mid,x*2); build(mid+1,r,x*2+1);\n\t\tsum[x] = sum[x*2] + sum[x*2+1];\n\t\tsum[x] -= calc(f[x * 2],f[x * 2 + 1],mid,mid+1);\n\t\trep(i,1,n * 4) bcj[i] = find(i) , id[i] = 0;\n\t\trep(i,1,n){\n\t\t\tint z = bcj[i];\n\t\t\tif(!id[z]) id[z] = i;\n\t\t\tf[x][i] = id[z];\n\t\t}\n\t\trep(i,n+1,n+n){\n\t\t\tint z = bcj[n * 2 + i];\n\t\t\tif(!id[z]) id[z] = i;\n\t\t\tf[x][i] = id[z];\n\t\t}\n\t\t//printf(\"a %d %d\\n\",l,r);\n\t\t//rep(i,1,n*4) printf(\"%d \",bcj[i]); puts(\"\");\n\t\t//rep(i,1,n+n) printf(\"%d \",f[x][i]); puts(\"\");\n\t}\n}\nint query(int l,int r,int x,int s,int t,int g[]){\n\tint i;\n\tif(s <= l && r <= t){\n\t\trep(i,1,n+n) g[i] = f[x][i];\n\t\treturn sum[x];\n\t}\n\tint mid = l + r >> 1;\n\tif(t <= mid) return query(l,mid,x*2,s,t,g);\n\tif(s > mid) return query(mid+1,r,x*2+1,s,t,g);\n\tint h1[22],h2[22];\n\tint ans = query(l,mid,x*2,s,t,h1) + query(mid+1,r,x*2+1,s,t,h2);\n\tans -= calc(h1,h2,mid,mid+1);\n\trep(i,1,n * 4) bcj[i] = find(i) , id[i] = 0;\n\trep(i,1,n){\n\t\tint z = bcj[i];\n\t\tif(!id[z]) id[z] = i;\n\t\tg[i] = id[z];\n\t}\n\trep(i,n+1,n+n){\n\t\tint z = bcj[n * 2 + i];\n\t\tif(!id[z]) id[z] = i;\n\t\tg[i] = id[z];\n\t}\n\treturn ans;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tn=read();m=read();T=read();\n\trep(i,1,n) rep(j,1,m) a[i][j] = read();\n\tbuild(1 , m , 1);\n\twhile(T--){l=read();r=read();printf(\"%d\\n\",query(1,m,1,l,r,tmp));}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "graphs"], "dificulty": "2600", "interactive": false}