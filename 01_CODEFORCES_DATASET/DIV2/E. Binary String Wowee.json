{
    "link": "https://codeforces.com//contest/2109/problem/E",
    "problemId": "3390992",
    "problem_idx": "E",
    "shortId": "2109E",
    "contest_number": "2109",
    "problem_submissions": {
        "C2": [
            320118950,
            320073736,
            320068679,
            320124378,
            320088007,
            320099914,
            320088056,
            320105924,
            320094095,
            320054092,
            320088375,
            320117252,
            320159702,
            320297948,
            320129461
        ],
        "E": [
            320106052,
            320125847,
            320119663,
            320112747,
            320118295,
            320121207,
            320131663,
            320110730,
            320128078,
            320129236,
            320110744,
            320127177,
            320108066,
            320117106,
            320128297,
            320112511,
            320120975
        ],
        "D": [
            320084454,
            320096087,
            320086735,
            320070362,
            320102091,
            320074349,
            320103285,
            320093531,
            320100400,
            320105158,
            320078822,
            320113231,
            320125387,
            320105790,
            320100126,
            320105353,
            320099936
        ],
        "C1": [
            320061130,
            320073433,
            320068905,
            320093298,
            320088271,
            320100091,
            320074252,
            320072104,
            320084300,
            320083297,
            320050083,
            320088782,
            320116287,
            320087460,
            320071464,
            320092016,
            320091499
        ],
        "B": [
            320050560,
            320061643,
            320055414,
            320051017,
            320057316,
            320061436,
            320061341,
            320059001,
            320056714,
            320064357,
            320163023,
            320069479,
            320059381,
            320057224,
            320059103,
            320056729,
            320106329
        ],
        "A": [
            320046103,
            320049390,
            320046455,
            320052253,
            320046661,
            320045885,
            320049476,
            320051953,
            320049481,
            320055558,
            320125055,
            320054117,
            320047392,
            320045825,
            320051802,
            320046883,
            320046433
        ],
        "C3": [
            320075162,
            320252987,
            320173697,
            320298218
        ],
        "F": [
            320205542,
            320345282
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142960",
    "editorial": "Idea by Intellegent, prepared by Intellegent. SolutionSome useful\r\ninsight is to see that if you operate on an element, then every element\r\nafter it will be unaffected; similarly, the state of an element in the\r\nstring depends only on the number of operations used on the suffix after\r\nit. More specifically, an elementâ€™s state flips with each operation\r\napplied to a suffix that includes it, so its value depends entirely on\r\nthe number of operations done to its suffix.This inspires the following\r\nstate: Now, regarding transitions the number of ways to move from state\r\nto (in other words the number of ways to add operations at the -th\r\nindex) can be thought of in terms of forming strings composed of\r\ncharacters and , where represents making a move on and represents making\r\na move on . Each valid string with s and s represents a unique sequence\r\nof moves, so the total number of transitions corresponds to the number\r\nof such valid strings. Notice that a string will be valid if and only if\r\nevery occurs when is , because flips every operation, meaning that every\r\nshould occur on either only even indices or only odd indices depending\r\non the initial value of .This means that the transition will be either\r\nor .Finally, the answer can be found in .The overall time complexity is:\r\n.\r\n",
    "name": "E. Binary String Wowee",
    "statement": "You are given a binary^{\r\ntext{ }} string s of length n. You are to perform the following\r\noperation exactly k times: select an index i (1\r\nle i\r\nle n) such that s_i =\r\nmathtt{0}; then flip^{\r\ntext{ }} each s_j for all indices j (1\r\nle j\r\nle i). You need to count the number of possible ways to perform all k\r\noperations. Since the answer could be ginormous, print it modulo 998\r\n,244\r\n,353.Two sequences of operations are considered different if they differ\r\nin the index selected at any step.^{\r\ntext{ }}A binary string is a string that consists only of the characters\r\nmathtt{0} and\r\nmathtt{1}.^{\r\ntext{ }}Flipping a binary character is changing it from\r\nmathtt{0} to\r\nmathtt{1} or vice versa.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Binary String Wowee.json",
    "hint": [
        "Hint 1 The state of depend entirely on how many operations have been performed on the suffix .",
        "Hint 2 Let denote the number of ways to perform exactly moves on the suffix ."
    ]
}