{"link": "https://codeforces.com//contest/1438/problem/F", "problemId": "793477", "problem_idx": "F", "shortId": "1438F", "contest_number": "1438", "problem_submissions": {"F": [98319461], "E": [98311897, 98314215, 98306470, 98317401, 98315562, 98322785, 98318720, 99208201, 99208187, 99208130, 98328285, 98328073, 98322490, 98320922, 98318257, 98322974, 98321581], "D": [98297867, 98301844, 98300240, 98304054, 98318299, 98309651, 98315030, 98308693, 98315767, 98313297, 98316364, 98315158, 98303678, 98304345, 98304632, 98306346, 98305264, 98305346, 98303552, 98306335], "C": [98289953, 98289036, 98308314, 98293256, 98292637, 98297135, 98292890, 98294300, 98300290, 98319932, 98304074, 98317336, 98290569, 98289827, 98289903, 98288415, 98294636, 98293103, 98292335, 98295796], "B": [98286960, 98285186, 98298192, 98293037, 98287297, 98288613, 98287215, 98290416, 98288546, 98286932, 98293844, 98285378, 98286885, 98286961, 98287702, 98285226, 98286945, 98289425, 98287421, 98290261], "A": [98283268, 98281489, 98282933, 98292930, 98282693, 98281140, 98281789, 98285668, 98284421, 98282468, 98283785, 98281307, 98281791, 98283429, 98281766, 98282741, 98281310, 98282372, 98281634, 98285176]}, "name": "F. Olha and Igor", "statement": "Igor wants to find the key to Olha\u2019s heart. The problem is, that it\u2019s at\r\nthe root of a binary tree.There is a perfect binary tree of height h\r\nconsisting of n = 2^{h} - 1 nodes. The nodes have been assigned distinct\r\nlabels from 1 to n. However, . To find key to Olha\u2019s heart he needs to\r\nfind the label assigned to the root by making queries of the following\r\ntype : Select three labels u, v and w (1\r\nleq u,v,w\r\nleq n). In response, Olha (the grader) will tell him the label of the of\r\nnodes labelled u and v, if the tree was at the node labelled w instead.\r\nHelp Igor to find the root! the grader is not adaptive: the labels are\r\nfixed before any queries are made.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl \"\\n\";\nmt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint h;\n\nint query(int u, int v, int w){\n    cout <<\"? \" <<  u << \" \" << v << \" \" << w << endl;\n    cout.flush();\n    int ans;\n    cin >> ans;\n    return ans;\n}\n\nvoid answer(int ans){\n    cout << \"! \" << ans << endl;\n    cout.flush();\n    exit(0);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> h;\n    int n = (1 << h) - 1;\n\n    map<int, int> cnt;\n    for(int i = 0; i < 410; ++i){\n        int u = mt() % n + 1, v = mt() % n + 1, w = mt() % n + 1;\n        if(u == v || v == w || u == w){\n            i--;\n            continue;\n        }\n        cnt[query(u, v, w)]++;\n    }\n\n    vector<array<int, 2>> v;\n    for(auto [x, y]: cnt)\n        v.push_back({y, x});\n\n    sort(v.begin(), v.end(), greater<array<int, 2>>());\n\n    /*if(v.size() >= 3){\n        if(query(v[0][1], v[1][1], v[2][1]) == v[2][1]) answer(v[2][1]);\n        if(query(v[0][1], v[2][1], v[1][1]) == v[1][1]) answer(v[1][1]);\n        if(query(v[1][1], v[2][1], v[0][1]) == v[0][1]) answer(v[0][1]);\n    }*/\n\n    for(int i = 1; i <= n; ++i){\n        if(i == v[0][1] || i == v[1][1]) continue;\n        if(query(v[0][1], v[1][1], i) == i) answer(i);\n    }\n\n    answer(-1);\n}"], "input": "", "output": "", "tags": ["interactive", "probabilities", "trees"], "dificulty": "3000", "interactive": false}