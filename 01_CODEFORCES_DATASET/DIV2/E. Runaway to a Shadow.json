{"link": "https://codeforces.com//contest/681/problem/E", "problemId": "62561", "problem_idx": "E", "shortId": "681E", "contest_number": "681", "problem_submissions": {"E": [18473617, 18479418], "D": [18465030, 18465518, 18465862, 18467403, 18466936, 18467028, 18466296, 18466578, 18464030, 18470842, 18472466, 18467659, 18469382, 18468431, 18468146, 18474068, 18472044, 18469596, 18470424], "C": [18461194, 18461464, 18461743, 18461928, 18464405, 18461875, 18462398, 18461641, 18467308, 18461870, 18461760, 18464265, 18463730, 18463224, 18460036, 18461042, 18464863, 18463886, 18462766], "B": [18458177, 18458124, 18456973, 18457752, 18459469, 18459156, 18458143, 18457120, 18457840, 18462206, 18457571, 18458202, 18457782, 18458846, 18457327, 18456130, 18460750, 18458949, 18458321], "A": [18456291, 18456107, 18458037, 18456137, 18457389, 18456748, 18456511, 18456015, 18456218, 18456056, 18455988, 18456198, 18456050, 18456723, 18456074, 18457095, 18458719, 18456145, 18456265]}, "name": "E. Runaway to a Shadow", "statement": "Dima is living in a dormitory, as well as some cockroaches.At the moment\r\nDima saw a cockroach running on a table and decided to kill it. Dima\r\nneeds exactly seconds for aiming, and after that he will precisely\r\nstrike the cockroach and finish it.To survive the cockroach has to run\r\ninto a shadow, cast by round plates standing on the table, in seconds.\r\nShadow casted by any of the plates has the shape of a circle. Shadow\r\ncircles may intersect, nest or overlap arbitrarily.The cockroach uses\r\nthe following strategy: first he equiprobably picks a direction to run\r\ntowards and then runs towards it with the constant speed . If at some\r\nmoment it reaches any shadow circle, it immediately stops in the shadow\r\nand thus will stay alive. Otherwise the cockroach is killed by the\r\nDima\u2019s precise strike. Consider that the Dima\u2019s precise strike is\r\ninstant.Determine the probability of that the cockroach will stay alive.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define y0 y0_1289749\n\nusing namespace std;\ntypedef long double ld;\nconst int MAXN = 120000;\n\nstruct point {\n\tld x, y, r;\n\tld len() {\n\t\treturn sqrt(x * x + y * y);\n\t}\n};\n\nconst ld PI = acos(-1);\nconst ld PI2 = PI * 2;\n\nint n;\nld x0, y0, v, t;\n\npoint arr[MAXN];\n\nint main() {\n\tint fl = 0;\n\tios_base::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(6);\n\tcin >> x0 >> y0 >> v >> t;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tlong long x, y;\n\t\tcin >> x >> y;\n\t\tarr[i].x = x;\n\t\tarr[i].y = y;\n\t\tcin >> arr[i].r;\n\t\tarr[i].x -= x0;\n\t\tarr[i].y -= y0;\n\t\tx -= x0;\n\t\ty -= y0;\n\t\tif (x * x + y * y <= arr[i].r * arr[i].r) {\n\t\t\tfl = 1;\n\t\t}\n\t}\n\tif (fl) {\n\t\tcout << 1.00000000000 << \"\\n\";\n\t\treturn 0;\n\t}\n\tif (v < 1e-2 || t < 1e-2) {\n\t\tcout << 0.00000000000 << \"\\n\";\n\t\treturn 0;\n\t}\n\tvector<pair<ld, ld> > vv;\n\tfor (int i = 0; i < n; ++i) {\n\t\tld len = t * v;\n\t\tlen = min(len, sqrt(arr[i].len() * arr[i].len() - arr[i].r * arr[i].r));\n\t\tld cs = (len * len + arr[i].len() * arr[i].len() - arr[i].r * arr[i].r) / (2 * len * arr[i].len());\n\t\tif (abs(cs) >= 1)\n\t\t\tcs = 0;\n\t\telse\n\t\t\tcs = acos(cs);\n\n\t\tld cs2 = atan2(arr[i].y, arr[i].x);\n\t\tvv.push_back(make_pair(cs2 - cs, cs2 + cs));\n\t\tvv.push_back(make_pair(cs2 - cs + PI2, cs2 + cs + PI2));\n\t\tvv.push_back(make_pair(cs2 - cs - PI2, cs2 + cs - PI2));\n\t}\n\tsort(vv.begin(), vv.end());\n\tld sum = 0;\n\tld mx = -PI;\n\tfor (int i = 0; i < (int)vv.size(); ++i) {\n\t\tif (vv[i].first > mx && PI > mx)\n\t\t\tsum += min(PI, vv[i].first) - mx;\n\t\tmx = max(mx, vv[i].second);\n\t}\n\tcout << 1 - (sum / PI2) << \"\\n\";\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["geometry", "sortings"], "dificulty": "2500", "interactive": false}