{
    "link": "https://codeforces.com//contest/1526/problem/E",
    "problemId": "998299",
    "problem_idx": "E",
    "shortId": "1526E",
    "contest_number": "1526",
    "problem_submissions": {
        "F": [
            117674501,
            117718090
        ],
        "E": [
            117641265,
            117622832,
            117632917,
            117655078,
            117650360,
            117639127,
            117655021,
            117622676,
            117655327,
            117632538,
            117657710,
            117639481,
            117666815,
            117667694,
            117675419,
            117641336,
            117667368,
            117663164,
            117676666,
            117665783
        ],
        "D": [
            117632533,
            117637660,
            117642436,
            117623173,
            117637988,
            117639630,
            117639808,
            117654338,
            117642482,
            117656737,
            117641555,
            117661726,
            117632865,
            117643854,
            117639700,
            117671596,
            117639266,
            117649770,
            117640101,
            117649235
        ],
        "C2": [
            117607723,
            117607154,
            117602271,
            117601746,
            117613546,
            117613022,
            117607432,
            117606655,
            117614092,
            117605064,
            117613264,
            117601205,
            117618975,
            117612210,
            117617886,
            117613492,
            117619366,
            117636680,
            117605737,
            117632479
        ],
        "C1": [
            117607362,
            117607834,
            117601722,
            117602159,
            117613090,
            117613322,
            117607889,
            117607044,
            117614454,
            117603816,
            117613790,
            117601639,
            117616576,
            117603874,
            117618238,
            117612867,
            117619659,
            117635895,
            117606026,
            117617120
        ],
        "B": [
            117601602,
            117610780,
            117595803,
            117598275,
            117596391,
            117609017,
            117598567,
            117600812,
            117600764,
            117618105,
            117599167,
            117612003,
            117600763,
            117595368,
            117595660,
            117608430,
            117600516,
            117617181,
            117613055,
            117606766
        ],
        "A": [
            117595740,
            117594587,
            117593757,
            117594246,
            117593849,
            117594075,
            117595264,
            117593810,
            117605058,
            117594287,
            117594338,
            117603759,
            117594059,
            117594193,
            117593995,
            117604884,
            117594125,
            117594212,
            117608105,
            117606903
        ]
    },
    "name": "E. Oolimry and Suffix Array",
    "statement": "Once upon a time, Oolimry saw a suffix array. He wondered how many\r\nstrings can produce this suffix array. More formally, given a suffix\r\narray of length n and having an alphabet size k, count the number of\r\nstrings that produce such a suffix array. Let s be a string of length n.\r\nThen the i-th suffix of s is the substring s[i\r\nldots n-1]. A suffix array is the array of integers that represent the\r\nstarting indexes of all the suffixes of a given string, after the\r\nsuffixes are sorted in the lexicographic order. For example, the suffix\r\narray of is [3,2,4,1,0,5,6] as the array of sorted suffixes is [\r\ntexttt{imry},\r\ntexttt{limry},\r\ntexttt{mry},\r\ntexttt{olimry},\r\ntexttt{oolimry},\r\ntexttt{ry},\r\ntexttt{y}]. A string x is lexicographically smaller than string y, if\r\neither x is a prefix of y (and x\r\nneq y), or there exists such i that x_i < y_i, and for any 1\r\nleq j < i , x_j = y_j.\r\n",
    "solutions": [
        "//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n#define mod 998244353\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0){\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar('-') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + '0' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\nint sa[1114514],rk[1114514],n,k;\nlong long fac[1000002],ifac[1000002],inv[1000002];\ninline long long pw(long long x,long long p){\n    long long res=1;\n    for(;p;p>>=1,x=x*x%mod)\n        if(p&1)res=res*x%mod;\n    return res;\n}\ninline long long getm(long long top,long long bot) {\n\treturn (top*pw(bot,mod-2))%mod;\n}\ninline long long C(long long top,long long bot){\n\tif(top<bot||top<0||bot<0)return 0;\n\treturn fac[top]*ifac[bot]%mod*ifac[top-bot]%mod;\n}\nint main() {\n\tn=1e6;\n\tfac[0]=1;\n\tF(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=getm(1,fac[n]);\n\tUF(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tF(i,1,n)inv[i]=ifac[i]*fac[i-1]%mod;\n\tcin>>n>>k;\n\tF(i,1,n)sa[i]=read()+1;\n\tF(i,1,n)rk[sa[i]]=i;\n\tF(i,2,n)if(rk[sa[i]+1]>rk[sa[i-1]+1])++k;\n\tcout<<C(k,n);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Oolimry and Suffix Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/91195",
    "editorial": "First, let's consider a simpler problem. Is it possible to make a string with a certain suffix array given an alphabet size .Consider two adjacent suffixes in the suffix array \"xy\" and \"ab\" where  and  are some strings and  and  are some characters i.e.  is the first character of that suffix and similarly for . If  and  don't exist we consider them as \\\\$, i.e. smaller than everything. Also, \"xy\" comes before \"ab\". Observation: If the position of  is less than the position of  in the suffix array,  must be less than . Otherwise,  must be less than or equal to .This can be easily shown as \"xy\" must be lexicographically smaller than \"ab\". This is sufficient also. Thus we can iterate through the suffix array and check if  where  is the suffix array and  is the position of the th element in the suffix array. If this condition holds then the  th character must be strictly less than the  th character. Thus we can just count how many such pairs exist. If this count is larger than the alphabet size no such string is possible. Otherwise, such string exists. Note that special care must be taken when considering  as  may not be defined (-indexed). After tackling the simpler question we move on to the full question of counting how many such strings are there. If we consider the string as an array and the order of the array as the order of the suffix array meaning that the  th element of this array is the  th element of the string. We have now transformed the question into \"Given that some elements must be greater than the previous elements while others can be equal. Count how many arrays are there such that the largest element is less than \". Consider the difference array, some elements must be  while some can be . We add padding to the front and back of the array so as to account for the first value being non-zero and the last element being less than . These two elements are both . Let  be the number of elements that must be  in the difference array. Now, this becomes count how many arrays of  non-negative elements sum to . This can be solved using stars and bars so the final answer comes out to be  which can be found easily. Note that we define  when .Final Complexity  or  depending on how you find the modular inverse. Btw  was chosen to also be  so as to hide the final complexity :)"
}