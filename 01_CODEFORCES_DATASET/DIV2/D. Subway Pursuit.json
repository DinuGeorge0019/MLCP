{
    "link": "https://codeforces.com//contest/1040/problem/D",
    "problemId": "215708",
    "problem_idx": "D",
    "shortId": "1040D",
    "contest_number": "1040",
    "problem_submissions": {
        "C": [
            42525959,
            42516403,
            42520218,
            42509951
        ],
        "E": [
            42518563,
            42515513,
            42516608,
            42523906,
            42523822,
            42524914,
            42516929,
            42524932,
            42514503,
            42511196,
            42518320,
            42524442,
            42528537
        ],
        "B": [
            42514292,
            42503342,
            42502589,
            42503781,
            42507515,
            42504172,
            42504545,
            42506438,
            42505683,
            42503118,
            42546497,
            42508433,
            42507210,
            42502341,
            42521565,
            42507357,
            42501900,
            42505960,
            42504857
        ],
        "A": [
            42508408,
            42500521,
            42500426,
            42504655,
            42500575,
            42500946,
            42519886,
            42500455,
            42501027,
            42501547,
            42500337,
            42501761,
            42500387,
            42500370,
            42517380,
            42500340,
            42502900,
            42500738,
            42500745
        ],
        "D": [
            42506377,
            42520704,
            42524366,
            42520672,
            42517604,
            42513292,
            42525930,
            42524271,
            42524410,
            42522170,
            42511068,
            42514990,
            42523580,
            42531287,
            42513155
        ]
    },
    "name": "D. Subway Pursuit",
    "statement": "In the Wonderful Metropolis of the Future, there is no need in subway\r\ntrain drivers. Due to the technological progress, they were replaced by\r\nthe Artificial Intelligence (AI). Unfortunately, one day the predictions\r\nof sci-fi writers came true: the AI rebelled and now there is an\r\nuncontrollable train in the subway. It can be dangerous! Your task is to\r\nfind the train and stop the AI.The subway of the Metropolis is one line\r\n(regular straight line with no self-intersections) with n stations,\r\nindexed consecutively from 1 to n. At each moment the train is at some\r\nstation. You need to determine the index of this station, so that the\r\ntrain would be secured.To find the train, dispatcher Sarah gave you a\r\ngadget that allows you to select arbitrary numbers l and r (l\r\nle r), and then check, whether the train is located on a station with\r\nindex between l and r, inclusive. Unfortunately, recharging of the\r\ngadget takes some time (and every time you use it as soon as possible),\r\nso between two applications of the gadget the train can move to any\r\nstation that is at most k stations away. Formally, if the train was at\r\nthe station x when the gadget was applied, then at the next application\r\nof the gadget the train can appear at any station y such that\r\nmax(1, x - k)\r\nleq y\r\nleq\r\nmin(n, x + k).Note that AI is not aware that you are trying to catch the\r\ntrain, so it makes all moves according to its predefined plan.After an\r\nexamination of the gadget you found that it is very old and can hold no\r\nmore than 4500 applications, after which it will break and your mission\r\nwill be considered a failure.Can you find the station with the train\r\nusing no more than 4500 applications of the gadgets?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nchar s[5];\n\nint rd(int x) {\n   return rand() % x;\n}\n\nint main() {\n   ll N, K; scanf(\"%lld%lld\", &N, &K);\n   ll l = 1, r = N;\n\n   srand((int)time(NULL));\n\n   while(1) {\n      if((r - l + 1) <= 4 * K + 4) {\n         ll t = l + rd(r - l + 1);\n         printf(\"%lld %lld\\n\", t, t);\n         fflush(stdout);\n         scanf(\"%s\", s);\n         if(s[0] == 'N') {\n            l = max(1LL, l - K);\n            r = min(N, r + K);\n         }\n         else break;\n      }\n      else {\n         ll m = (l + r) >> 1;\n         printf(\"%lld %lld\\n\", l, m);\n         fflush(stdout);\n         scanf(\"%s\", s);\n         if(s[0] == 'Y') {\n            l = max(1LL, l - K);\n            r = min(N, m + K);\n         }\n         else {\n            l = max(1LL, m - K + 1);\n            r = min(N, r + K);\n         }\n      }\n   }\n   return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "interactive"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Subway Pursuit.json",
    "editorial_link": "https://codeforces.com//blog/entry/61668",
    "editorial": "Notice that we can make segment in which we are located small enough using binary search. Let [l;r]\n be the last segment about which we knew for sure that train is in it (at the beginning it's [1;n]\n). Let m=l+r2\n. Let's ask about segment [l;m]\n. If we receive answer \u00abYES\u00bb, after this query train for sure will be in segment [l?k;m+k]\n, otherwise in [m?k;r+k]\n. So, after each query length of segment is divided by 2\n and increased by 2k\n. After segment length becomes irreducible (4k\n), let's ask about some random station in this segment. If we guessed right, let's finish the program, otherwise make the binary search again.\n\nTo get the OK let's make one more observation: for all binary searches except the first one initial segment can be made [l?k;r+k]\n instead of [1;n]\n."
}