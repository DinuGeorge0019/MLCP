{"link": "https://codeforces.com//contest/197/problem/E", "problemId": "1433", "problem_idx": "E", "shortId": "197E", "contest_number": "197", "problem_submissions": {"E": [1791268, 1802740, 1802736, 1795426], "C": [1788910, 1789269, 1789264, 1788938, 1788924, 1790933, 1791154, 1789450, 1802730, 1789405, 1789447, 1788838, 1790005, 1788746, 1790181], "B": [1788528, 1788680, 1789600, 1788527, 1790011, 1789032, 1788888, 1788636, 1788195, 1802729, 1788848, 1790689, 1795848, 1788783, 1791951, 1789313], "A": [1788079, 1787820, 1787632, 1787687, 1787891, 1787887, 1788039, 1787844, 1789322, 1802727, 1791494, 1791478, 1788291, 1788862, 1792369], "D": [1790975, 1793898, 1793489, 1794292, 1794595, 1794900, 1792868, 1794686, 1795625, 1795183, 1792703, 1794330, 1795844, 1794780, 1795863]}, "name": "E. Paint Tree", "statement": "You are given a tree with vertexes and points on a plane, no three\r\npoints lie on one straight line.Your task is to paint the given tree on\r\na plane, using the given points as vertexes. That is, you should\r\ncorrespond each vertex of the tree to exactly one point and each point\r\nshould correspond to a vertex. If two vertexes of the tree are connected\r\nby an edge, then the corresponding points should have a segment painted\r\nbetween them. The segments that correspond to non-adjacent edges, should\r\nnot have common points. The segments that correspond to adjacent edges\r\nshould have exactly one common point.\r\n", "solutions": ["#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<ll> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic ll cross(const pnt &a, const pnt &b) { return imag(conj(a) * b); }\nstatic ll cross(const pnt &a, const pnt &b, const pnt &c)\n{\n    return cross(b - a, c - a);\n}\n\nstruct node\n{\n    int parent;\n    vi edges;\n    int size;\n    int pntid;\n\n    node() : parent(-1), size(0), pntid(-1) {}\n};\n\nstatic void prepare(vector<node> &nodes, int cur, int parent)\n{\n    node &n = nodes[cur];\n    n.parent = parent;\n    n.size = 1;\n    for (int i = 0; i < SZ(n.edges); i++)\n    {\n        int y = n.edges[i];\n        if (y != parent)\n        {\n            prepare(nodes, y, cur);\n            n.size += nodes[y].size;\n        }\n    }\n}\n\nstruct compareYX\n{\n    bool operator()(const pnt &a, const pnt &b) const\n    {\n        if (a.imag() != b.imag())\n            return a.imag() < b.imag();\n        else\n            return a.real() < b.real();\n    }\n\n    bool operator()(const pair<pnt, int> &a, const pair<pnt, int> &b) const\n    {\n        return (*this)(a.first, b.first);\n    }\n};\n\nstruct compareAngle\n{\n    pnt base;\n\n    compareAngle(const pnt &base) : base(base) {}\n\n    bool operator()(const pnt &a, const pnt &b) const\n    {\n        return cross(base, a, b) > 0;\n    }\n\n    bool operator()(const pair<pnt, int> &a, const pair<pnt, int> &b) const\n    {\n        return (*this)(a.first, b.first);\n    }\n};\n\ntypedef vector<pair<pnt, int> > pntvec;\n\nstatic void place(vector<node> &nodes, int cur, pntvec::iterator first, pntvec::iterator last)\n{\n    node &n = nodes[cur];\n    assert(last - first == n.size);\n    pntvec::iterator lo = min_element(first, last, compareYX());\n    swap(*first, *lo);\n\n    n.pntid = first->second;\n\n    sort(first + 1, last, compareAngle(first->first));\n    first++;\n    for (int i = 0; i < SZ(n.edges); i++)\n    {\n        int y = n.edges[i];\n        if (y != n.parent)\n        {\n            place(nodes, y, first, first + nodes[y].size);\n            first += nodes[y].size;\n        }\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N;\n    vector<node> nodes(N);\n    for (int i = 1; i < N; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        nodes[u].edges.push_back(v);\n        nodes[v].edges.push_back(u);\n    }\n    prepare(nodes, 0, -1);\n\n    vector<pair<pnt, int> > pnts;\n    for (int i = 0; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        pnts.push_back(make_pair(pnt(x, y), i));\n    }\n\n    place(nodes, 0, pnts.begin(), pnts.end());\n    vector<int> ans(N, -1);\n    for (int i = 0; i < N; i++)\n        ans[nodes[i].pntid] = i + 1;\n\n    cout << ans[0];\n    for (int i = 1; i < N; i++)\n        cout << ' ' << ans[i];\n    cout << '\\n';\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "geometry", "trees"], "dificulty": "2200", "interactive": false}