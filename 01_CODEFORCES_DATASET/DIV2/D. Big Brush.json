{
    "link": "https://codeforces.com//contest/1638/problem/D",
    "problemId": "1297618",
    "problem_idx": "D",
    "shortId": "1638D",
    "contest_number": "1638",
    "problem_submissions": {
        "E": [
            146394309,
            146388037,
            146392264,
            146392799,
            146383148,
            146391230,
            146412303,
            146401025,
            146403078,
            146402136,
            179550421,
            146406748,
            146402980,
            146407733,
            146480267,
            146392395,
            146416198,
            146408751,
            146407567,
            146399245,
            146416242,
            146413814
        ],
        "D": [
            146373961,
            146380846,
            146385038,
            146375477,
            146392500,
            146381733,
            146401310,
            146378870,
            146384454,
            146387386,
            146387880,
            146390053,
            146382176,
            146480222,
            146406431,
            146388651,
            146388267,
            146392625,
            146412206,
            146374640,
            146389515
        ],
        "C": [
            146366299,
            146372352,
            146371729,
            146367670,
            146366106,
            146373666,
            146370507,
            146365761,
            146370642,
            146376834,
            146376510,
            146371594,
            146370051,
            146480186,
            146375503,
            146369319,
            146374946,
            146378437,
            146373206,
            146367076,
            146373277
        ],
        "B": [
            146362311,
            146363442,
            146362707,
            146365725,
            146364605,
            146363885,
            146366228,
            146383066,
            146364746,
            146368584,
            146368423,
            146367380,
            146366091,
            146480117,
            146369102,
            146364936,
            146367883,
            146370547,
            146366764,
            146364119,
            146368017
        ],
        "A": [
            146361810,
            146361860,
            146361937,
            146362725,
            146362534,
            146362379,
            146363944,
            146381318,
            146362119,
            146362820,
            146362493,
            146479991,
            146363108,
            146363259,
            146480100,
            146363531,
            146362617,
            146363968,
            146362163,
            146363256,
            146362105,
            146365613
        ],
        "F": [
            154464206,
            146479912,
            146613983,
            146474726,
            146640126
        ]
    },
    "name": "D. Big Brush",
    "statement": "You found a painting on a canvas of size n\r\ntimes m. The canvas can be represented as a grid with n rows and m\r\ncolumns. Each cell has some color. Cell (i, j) has color c_{i,j}.Near\r\nthe painting you also found a brush in the shape of a 2\r\ntimes 2 square, so the canvas was surely painted in the following way:\r\ninitially, no cell was painted. Then, the following painting operation\r\nhas been performed some number of times: Choose two integers i and j (1\r\nle i < n, 1\r\nle j < m) and some color k (1\r\nle k\r\nle nm). Paint cells (i, j), (i + 1, j), (i, j + 1), (i + 1, j + 1) in\r\ncolor k. All cells must be painted at least once. A cell can be painted\r\nmultiple times. In this case, its final color will be the last one.Find\r\nany sequence of at most nm operations that could have led to the\r\npainting you found or state that it’s impossible.\r\n",
    "solutions": [
        "// Author: wlzhouzhuan\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(!isdigit(ch))f|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ntemplate<typename T>void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n\tprint(x),putchar(ch);\n}\n\n#define free freee\n\nqueue<array<int,3>> q;\nbool vis[1005][1005];\nbool free[1005][1005];\nint a[1005][1005];\nint n,m;\n\nconst int dx[]={-1,-1,-1,0,0,0,1,1,1};\nconst int dy[]={-1,0,1,-1,0,1,-1,0,1};\n\nvector<array<int,3>> ans;\n\nint check(int x,int y){\n\tint las=-1;\n\tfor(int i=x;i<=x+1;i++){\n\t\tfor(int j=y;j<=y+1;j++){\n\t\t\tif(free[i][j])continue;\n\t\t\tif(!~las)las=a[i][j];\n\t\t\telse if(a[i][j]!=las)return -1;\n\t\t}\n\t}\n\treturn ~las?las:1;\n}\n\nint main(){\n\tn=read(),m=read();\n\trep(i,1,n)rep(j,1,m)a[i][j]=read();\n\trep(i,1,n-1)rep(j,1,m-1){\n\t\tif(check(i,j)!=-1)vis[i][j]=1,q.push({i,j,a[i][j]});\n\t}\n\twhile(!q.empty()){\n\t\tauto [x,y,_]=q.front();q.pop();\n\t\tans.pb({x,y,_});\n\t\tfree[x][y]=free[x][y+1]=free[x+1][y]=free[x+1][y+1]=1;\n\t\tfor(int d=0;d<9;d++){\n\t\t\tint fx=x+dx[d],fy=y+dy[d];\n\t\t\tif(fx>=1&&fx<n&&fy>=1&&fy<m&&!vis[fx][fy]){\n\t\t\t\tint t=check(fx,fy);\n\t\t\t\tif(t!=-1){\n\t\t\t\t\tvis[fx][fy]=1;\n\t\t\t\t\tq.push({fx,fy,t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(SZ(ans)!=(n-1)*(m-1)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tprint(SZ(ans),'\\n');\n\treverse(ans.begin(),ans.end());\n\tfor(auto [x,y,c]:ans){\n\t\tprintf(\"%d %d %d\\n\",x,y,c);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Big Brush.json",
    "editorial_link": "https://codeforces.com//blog/entry/99942",
    "editorial": "Letâs try to build the solution from the last operation to the first\r\noperation. The last operation can be any square painted in a single\r\ncolor. If there is no such square, it is clearly impossible. Otherwise,\r\nthis square being the last operation implies that we could previously\r\ncolor its cells in any color, multiple times, without any consequences.\r\nWe will name these . What happens when we run out of squares painted in\r\na single color? Well, we can use the special cells described above. The\r\nnext operation considered can be any square such that all its\r\nnon-special cells are painted in the same color. If there is no such\r\nsquare, it is clearly impossible.We now have a correct solution. It\r\nconsists of at most operation because at each step we turn at least one\r\nnon-special cell into a special one and there are cells. We can\r\nimplement this solution similar to BFS. First, insert all squares\r\npainted in a single color into a queue. Then, at each step take the\r\nsquare in the front of the queue, add it to the solution and make all\r\nits non-special cells special. When making a cell special, check all\r\nsquares that contain it and if some of them meet the condition after the\r\ncurrent step, insert them into the queue. Note that there are at most\r\nsuch squares. Time complexity: .\r\n",
    "hint": [
        "Hint 1 Solve the problem in reverse.",
        "Hint 2 What are the possible final operations?",
        "Hint 3 They are the squares painted in a single color. After finding all such squares, how can you \"remove\" them from the painting?",
        "Hint 4 When removing a square, the cells below could have been painted in any color. So, mark them as special cells. After running out of squares painted in a single color, what are the new possible last operations?",
        "Hint 5 They are all the squares whose non-special cells are painted in the same color. How do we keep track of those while removing squares?",
        "Hint 6 Queue."
    ]
}