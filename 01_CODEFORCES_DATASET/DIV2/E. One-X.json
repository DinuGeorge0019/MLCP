{
    "link": "https://codeforces.com//contest/1905/problem/E",
    "problemId": "2384304",
    "problem_idx": "E",
    "shortId": "1905E",
    "contest_number": "1905",
    "problem_submissions": {
        "F": [
            237519503,
            237518706,
            237482920,
            237522705,
            237524131,
            237602806,
            237553489,
            237539816,
            237539559,
            237531355,
            238226356,
            238226333
        ],
        "E": [
            237505954,
            237497832,
            237495453,
            237512642,
            237513385,
            237508924,
            237511733,
            237515516,
            237508774,
            237502235,
            237513715,
            237519547,
            237522468,
            237711000,
            237515591,
            237507153,
            237518502,
            237520768,
            237516891,
            237516610
        ],
        "D": [
            237492749,
            237504330,
            237509326,
            237501351,
            237508164,
            237500145,
            237500325,
            237496593,
            237501654,
            237512862,
            237494885,
            237497599,
            237495760,
            237710975,
            237503073,
            237516000,
            237505850,
            237496346,
            237504183,
            237504223
        ],
        "C": [
            237484859,
            237486387,
            237514010,
            237484118,
            237485834,
            237477056,
            237481640,
            237480170,
            237483989,
            237484101,
            237482806,
            237484400,
            237487254,
            237710962,
            237490113,
            237487402,
            237483252,
            237485864,
            237495090,
            237491635
        ],
        "B": [
            237476673,
            237478416,
            237514764,
            237473227,
            237475996,
            237480677,
            237471243,
            237471572,
            237474579,
            237471819,
            237473855,
            237474076,
            237478005,
            237710941,
            237481035,
            237481302,
            237473092,
            237475685,
            237477792,
            237477297
        ],
        "A": [
            237470661,
            237474004,
            237515478,
            237470037,
            237470853,
            237487781,
            237469382,
            237469477,
            237471099,
            237469459,
            237470679,
            237470317,
            237471411,
            237710923,
            237474857,
            237474763,
            237469530,
            237469890,
            237472488,
            237474669
        ]
    },
    "name": "E. One-X",
    "statement": "In this sad world full of imperfections, ugly segment trees exist.A\r\nsegment tree is a tree where each node represents a segment and has its\r\nnumber. A segment tree for an array of n elements can be built in a\r\nrecursive manner. Let\u2019s say function\r\noperatorname{build}(v,l,r) builds the segment tree rooted in the node\r\nwith number v and it corresponds to the segment [l,r].Now let\u2019s define\r\noperatorname{build}(v,l,r): If l=r, this node v is a leaf so we stop\r\nadding more edges Else, we add the edges (v, 2v) and (v, 2v+1). Let m=\r\nlfloor\r\nfrac{l+r}{2}\r\nrfloor. Then we call\r\noperatorname{build}(2v,l,m) and\r\noperatorname{build}(2v+1,m+1,r). So, the whole tree is built by calling\r\noperatorname{build}(1,1,n).Now Ibti will construct a segment tree for an\r\narray with n elements. He wants to find the sum of\r\noperatorname{lca}^\r\ndagger(S), where S is a non-empty subset of . Notice that there are\r\nexactly 2^n - 1 possible subsets. Since this sum can be very large,\r\noutput it modulo 998\r\n,244\r\n,353.^\r\ndagger\r\noperatorname{lca}(S) is the number of the least common ancestor for the\r\nnodes that are in S.\r\n",
    "solutions": [
        "// Problem: E. One-X\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/E\n// Memory Limit: 512 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#pragma GCC optimize(\"Ofast,inline,unroll-loops\")\n// #define _GLIBCXX_DEBUG //\u4ea4\u9898\u524d\u8bb0\u5f97\u6ce8\u91ca\u6389\u4e0d\u7136\u5bb9\u6613T\u3002\n#include<bits/stdc++.h>\n#define File(s) freopen(#s\".in\",\"r\",stdin),freopen(#s\".out\",\"w\",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<\"@\"<<__LINE__<<\"=\"<<(x)<<'\\n')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c=='-';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=-2023,M=998244353;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\nauto pow2(ll b){\n\t//todo:\u5149\u901f\n\treturn qpow(2,b%(M-1));\n}\nll calc(ll n){\n\tif(n==0)return 0;\n\tif(n==1)return 1;\n\tll ln=(n+1)/2,rn=n/2;\n\treturn (pow2(ln)+M-1)*ll(pow2(rn)+M-1)%M;\n}\nsigned main(){\n\t//std::ios::sync_with_stdio(0);std::cin.tie(0);std::cout.tie(0);\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tll n=g90;\n\t\tll ans=0,sum=1,sum1=0,cnt=1,cnt1=0;\n\t\tfor(int l=0;;++l){\n\t\t\tans=(ans+sum*calc(n)+sum1*calc(n+1))%M;\n\t\t\tif(n==1){\n\t\t\t\tsum1=sum1*4+cnt1;\n\t\t\t\tans=(ans+sum1*calc(1))%M;\n\t\t\t\tbreak;\n\t\t\t}else if(n&1){\n\t\t\t\tstd::tie(sum,sum1)=std::make_pair(sum*2+cnt,sum*2+sum1*4+cnt1);//(2j)+(2j+1)\n\t\t\t\tstd::tie(cnt,cnt1)=std::make_pair(cnt,cnt+cnt1*2);\n\t\t\t}else{\n\t\t\t\tstd::tie(sum,sum1)=std::make_pair(sum1*2+cnt1+sum*4+cnt,sum1*2);\n\t\t\t\tstd::tie(cnt,cnt1)=std::make_pair(cnt*2+cnt1,cnt1);\n\t\t\t}\n\t\t\t\n\t\t\tsum%=M,sum1%=M;\n\t\t\tn/=2;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}();\n}//main()"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. One-X.json",
    "editorial_link": "https://codeforces.com//blog/entry/123384",
    "editorial": "SolutionLet\u00e2\u0080\u0099s try to solve a slightly easier problem first: changing the\r\ncoefficient of the label to be the msb of the label.We can note that at\r\neach depth, every label will have the same number of digits ( in base 2\r\n), thus the same msb. And we can notice that for each depth there are at\r\nmost different interval lengths. Combining the former with the latter,\r\nwe can solve this case in time complexity, since the maximum depth is\r\nbounded by .We can find an easy generalization to this: for the -th most\r\nsignificant bit of each label to be , we have to go right from a node\r\nwhose depth is . Thus the above solution can be extended to find the\r\ncontribution of the -th most significant bit of each label.Doing this\r\nfor all bits gives us a time complexity of which is sufficient to pass\r\nthe given constraints.\r\n"
}