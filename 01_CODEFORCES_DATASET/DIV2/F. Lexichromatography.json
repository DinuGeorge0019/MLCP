{
    "link": "https://codeforces.com//contest/1877/problem/F",
    "problemId": "2251957",
    "problem_idx": "F",
    "shortId": "1877F",
    "contest_number": "1877",
    "problem_submissions": {
        "F": [
            227174558,
            227466890,
            227293603,
            227329252
        ],
        "E": [
            227163070,
            227145733,
            227144090,
            227153972,
            227157518,
            227156560,
            227163724,
            227161365,
            227162255,
            227162229,
            227160325,
            227160791,
            227163873,
            227162598,
            227166392,
            227166841,
            227158401,
            227162185,
            227162372
        ],
        "D": [
            227138699,
            227131389,
            227129888,
            227134099,
            227129112,
            227133071,
            227133077,
            227144267,
            227136086,
            227139472,
            227138655,
            227139596,
            227138226,
            227141861,
            227140431,
            227137088,
            227140648,
            227146399,
            227136902
        ],
        "C": [
            227133414,
            227127308,
            227127530,
            227125282,
            227126156,
            227610507,
            227128623,
            227127297,
            227125856,
            227127429,
            227131821,
            227132500,
            227131322,
            227128501,
            227133505,
            227132343,
            227131403,
            227133386,
            227133010,
            227130729
        ],
        "B": [
            227128215,
            227121053,
            227122944,
            227120105,
            227119973,
            227121777,
            227121712,
            227120149,
            227123349,
            227121082,
            227122657,
            227123511,
            227122887,
            227123130,
            227122430,
            227122300,
            227131461,
            227125290,
            227124467
        ],
        "A": [
            227124912,
            227116905,
            227115298,
            227115060,
            227115015,
            227610458,
            227116248,
            227116367,
            227115306,
            227116532,
            227115007,
            227115508,
            227115261,
            227115583,
            227117792,
            227115925,
            227115499,
            227117913,
            227116538,
            227116495
        ]
    },
    "name": "F. Lexichromatography",
    "statement": "Pak Chanek loves his faculty, the Faculty of Computer Science,\r\nUniversity of Indonesia (Fasilkom). He wants to play with the colours of\r\nthe faculty\u2019s logo, blue and red.There is an array a consisting of n\r\nelements, element i has a value of a_i. Pak Chanek wants to colour each\r\nelement in the array blue or red such that these following conditions\r\nare satisfied: If all blue elements are formed into a subsequence^\r\ndagger and so are all the red elements, the blue subsequence is strictly\r\nless than the red subsequence lexicographically^\r\nddagger. Array a does not have that is imbalanced. A subarray is\r\nimbalanced if and only if there is a value k such that the absolute\r\ndifference between the number of blue elements with value k and the\r\nnumber of red elements with value k in this subarray is 2 or more. Note\r\nthat it is possible to colour every element of the array the same\r\ncolour. How many different colourings satisfy all those conditions?\r\nSince the answer can be very big, print the answer modulo 998\r\n,244\r\n,353. Two colourings are different if and only if there is at least one\r\nelement that is blue in one colouring, but red in the other.^\r\ndagger A subsequence of an array is a sequence that can be obtained from\r\nthe array by deleting some elements (possibly none), without changing\r\nthe order of the remaining elements.^\r\nddagger Let p and q be two different sequences. Sequence p is said to be\r\nlexicographically less than sequence q if and only if p is a prefix of q\r\nor there is an index i such that p_j=q_j holds for every 1\r\nleq j<i, and p_i<q_i. In particular, an empty sequence is always\r\nlexicographically less than any non-empty sequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long \n#define pb push_back\nusing namespace std;\nconst int INF=1e6+5;\nconst int Mod=998244353;\nint n,a[INF],tot,kk,vis[INF];\nvector <int> v3[INF],e[INF];\nstruct P3{\n\tint l,r,id;\n}aa[INF];\nint ksm(int x,int y) {\n\tint ba=x%Mod,ans=1;\n\twhile (y) {\n\t\tif (y&1) ans=(ans*ba)%Mod;\n\t\tba=(ba*ba)%Mod;y>>=1;\n\t}\n\treturn ans;\n}\nvoid DFS(int x) {\n\tif (vis[x]) return ;\n\tvis[x]=1;\n\tfor (int v:e[x]) {\n\t\tDFS(v);\n\t}\n}\nvoid solve(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++) cin>>a[i];\n\tfor (int i=1;i<=n;i++) v3[a[i]].pb(i);\n\tint kk2=0;\n\tfor (int i=1;i<=2e5;i++) if (v3[i].size()) kk2++;\n\tfor (int i=1;i<=2e5;i++) {\n\t\tint len=v3[i].size();\n\t\tif (len&1) {cout<<ksm(2,kk2-1)<<\"\\n\";return ;}\n\t\tfor (int j=0;j<len;j+=2) \n\t\t\taa[++tot]={v3[i][j],v3[i][j+1],i};\n\t}\n\t\n\tsort(aa+1,aa+1+tot,[](P3 xx,P3 yy){return xx.l!=yy.l?xx.l<yy.l:xx.r>yy.r;});\n\tint res=0,R=aa[1].r;\n\tfor (int i=2;i<=tot;i++) {\n\t\tif (aa[i].r<=R) {cout<<ksm(2,kk2-1)<<\"\\n\";return ;}\n\t\telse R=aa[i].r;\n\t}\n\t\n\tfor (int i=2;i<=tot;i++) {\n\t\tif (aa[i].l<=aa[i-1].r) {\n\t\t\te[aa[i].id].pb(aa[i-1].id);\n\t\t\te[aa[i-1].id].pb(aa[i].id);\n\t\t}\n\t}\n\tfor (int i=1;i<=2e5;i++) {\n\t\tif (v3[i].size()) {\n\t\t\tif (vis[i]) continue;\n\t\t\tkk++;\n\t\t\tDFS(i);\n\t\t}\n\t}\n\tcout<<((ksm(2,kk2-1)-ksm(2,kk-1))%Mod+Mod)%Mod<<\"\\n\";\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tint t=1;\n\twhile (t--) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dsu"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Lexichromatography.json",
    "editorial_link": "https://codeforces.com//blog/entry/121200",
    "editorial": "There are two conditions in the problem. The lexicography condition and\r\nthe imbalanced subarrays condition.Let\u00e2\u0080\u0099s look at the imbalanced\r\nsubarrays condition. Consider some value and consider all elements in\r\nwith a value of . In order to satisfy this condition, those elements\r\nmust be coloured blue and red alternatingly from left to right. So for\r\neach value that is present in , there are ways to colour its elements,\r\neither starting from blue or starting from red. This means, if we ignore\r\nthe lexicography condition, the number of colourings is with\r\nrepresenting the number of different values in .From now on, we are only\r\nconsidering the colourings that satisfy the imbalanced subarray\r\ncondition.Define the following: : the number of colourings with the blue\r\nsubsequence less than the red subsequence lexicographically. : the\r\nnumber of colourings with the blue subsequence equal to the red\r\nsubsequence. : the number of colourings with the blue subsequence bigger\r\nthan the red subsequence lexicographically. We can get that .\r\nFurthermore, we can get that since we can always flip the colouring to\r\nget the opposite one. Therefore, .Now, let\u00e2\u0080\u0099s calculate the value of .\r\nIterate the array from left to right while simultaneously maintaining\r\nboth the blue and red subsequences. During the iteration, we want both\r\nsubsequences to be equal. For the first element, we can colour it either\r\nred or blue, and put the value of that element into its corresponding\r\nsubsequence. We iterate each element but we stop the next time both\r\nsubsequences have the same length. So if we colour the first element\r\nblue, then the blue subsequence will be longer than the red one\r\nthroughout this process, until both subsequences have equal lengths. For\r\neach of the next elements, there are a few cases: If we have not found\r\nan element with this value before, we must put the element in the\r\ncurrently longer subsequence. (If we put it in the shorter subsequence\r\nit will not match with the corresponding element in the longer\r\nsubsequence. If we have found an element with this value before, it must\r\nbe the opposite colour than the previous one. This means we must put it\r\nin the shorter subsequence. If the corresponding element in the longer\r\nsubsequence does not match, then . Otherwise, we can continue the\r\nprocess. Once both subsequences have equal lengths, let\u00e2\u0080\u0099s say we ignore\r\nall of the previous elements and the currently built subsequences and\r\nassume we continue iterating the array while forgetting about all things\r\nwe did before. We cannot actually do this to calculate properly, but we\r\nwill get to that later. Notice that continuing the iteration now is just\r\nlike how we start in the beginning. We can choose the colour of the\r\nfirst element and every other element after that is forced until both\r\nsubsequences have the same length. We continue doing this repeatedly\r\nuntil the end of .If at the end of , the lengths of both subsequences\r\nare different or we hit the case at least once, then .Otherwise, from\r\nour assumption above, we can deduce that each time we add an element\r\nwhen both subsequences have equal lengths, we can freely choose the\r\ncolour of that element. We can split into several sections where the\r\nsections are separated by the times both subsequences have the same\r\nlength. Using our assumption above, the number of colourings is with\r\nbeing the number of sections, because there are starting colours we can\r\nchoose for each section.However, as we have said before, when starting a\r\nnew section, we cannot completely ignore the previous sections. Since\r\nthe colouring of the elements with the same value must be alternating,\r\ntwo sections that have at least one common value must have the same\r\nstarting colour. This means we can construct a graph of sections and\r\nconnect the sections that have a common value with edges. Then, the true\r\nvalue of is with being the number of connected components.Time\r\ncomplexity:\r\n"
}