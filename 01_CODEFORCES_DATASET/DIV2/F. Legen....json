{"link": "https://codeforces.com//contest/697/problem/F", "problemId": "65179", "problem_idx": "F", "shortId": "697F", "contest_number": "697", "problem_submissions": {"C": [19125110, 19119489, 19115272, 19120784, 19120358, 19121611, 19126423, 19120555, 19121257, 19119720, 19124669, 19118290, 19123580, 19123345, 19122737, 19115954, 19121052, 19121218], "E": [19122529, 19128431, 19129328, 19128568, 19122012, 19131082, 19131216, 19131999, 19129938, 19131814, 19130868, 19130697, 19131810, 19129659, 19128578, 19132416], "D": [19120706, 19118022, 19122001, 19123039, 19123280, 19123177, 19124026, 19133711, 19129326, 19124900, 19124469, 19135107, 19135081, 19134986, 19134844, 19134818, 19134786, 19125750, 19126098, 19126640, 19125926, 19127387, 19126729, 19124071, 19125133, 19126884], "B": [19115236, 19122038, 19115614, 19117710, 19115812, 19115890, 19117501, 19117067, 19116748, 19116047, 19119950, 19118136, 19119352, 19135966, 19141445, 19130167], "A": [19111990, 19120635, 19112000, 19111957, 19112038, 19111973, 19115290, 19112119, 19111989, 19112683, 19113904, 19113940, 19113380, 19111958, 19112326, 19112540], "F": [19129833, 19132590, 19155674]}, "name": "F. Legen...", "statement": "Barney was hanging out with Nora for a while and now he thinks he may\r\nhave feelings for her. Barney wants to send her a cheesy text message\r\nand wants to make her as happy as possible. Initially, happiness level\r\nof Nora is . Nora loves some pickup lines like \"I\u2019m falling for you\" and\r\nstuff. Totally, she knows pickup lines, each consisting only of\r\nlowercase English letters, also some of them may be equal (in writing,\r\nbut different in pronouncing or meaning though). Every time Nora sees\r\n-th pickup line as a of Barney\u2019s text message her happiness level\r\nincreases by . These substrings may overlap, for example, Nora will see\r\nthe pickup line twice and the pickup line once in text message .Due to\r\ntexting app limits, Barney\u2019s text may have up to characters.Barney asked\r\nyou to help him make Nora as much happy as possible, it\u2019s gonna be\r\nlegen...\r\n", "solutions": ["#include <array>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <unordered_map>\n#include <map>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\n\nconst int A = 256;\n\nint sz = 0;\n\nusing CHAR = uint8_t;\n\nstruct Node {\n  int index;\n  Node* s;\n  Node* go[A];\n  Node* p;\n  int happy;\n  CHAR c;\n\n  Node() {\n  }\n\n  Node(CHAR c, Node* p)\n    : s(NULL)\n    , p(p)\n    , happy(0)\n    , c(c)\n  {\n    for (int i = 0; i < A; ++i) go[i] = NULL;\n    index = sz++;\n  }\n};\n\ntypedef Node* pNode;\n\n\nNode nodes[1000];\npNode root = new (&nodes[0]) Node(' ', NULL);\n\nvoid add_string(const string& s, int w) {\n  pNode current = root;\n  for (int i = 0; i < (int) s.size(); ++i) {\n    CHAR c = s[i];\n    if (current->go[c] == NULL) {\n      current->go[c] = new (&nodes[sz]) Node(c, current);\n    }\n    current = current->go[c];\n  }\n  current->happy += w;\n}\n\nint n, m, p;\nstring dic, s;\n\ninline pNode go(pNode u, CHAR c);\n\ninline pNode get_link(pNode u) {\n  if (u->s != NULL) {\n    return u->s;\n  }\n  u->s = (u == root || u->p == root) ? root : go(get_link(u->p), u->c);\n  get_link(u->s);\n  u->happy += u->s->happy;\n  // if (u->index == 5 || u->index == 9) {\n    // std::cout << \"link \" << u->s->index << std::endl;\n    // std::cout << \"parent happy: \" << u->s->happy << std::endl;\n    // std::cout << \"current happy: \" << u->happy << std::endl;\n  // }\n  return u->s;\n}\n\ninline pNode go(pNode u, CHAR c) {\n  if (u->go[c] != NULL) {\n    return u->go[c];\n  }\n  return u->go[c] = (u == root) ? root : go(get_link(u), c);\n}\nconst int64_t UNDEF = numeric_limits<int64_t>::min();\n\n\nvector<vector<int64_t>> apply(\n  const vector<vector<int64_t>>& a,\n  const vector<vector<int64_t>>& b)\n{\n  vector<vector<int64_t>> dp(sz, vector<int64_t>(sz, UNDEF));\n\n  for (int from = 0; from < sz; ++from) {\n    for (int middle = 0; middle < sz; ++middle) {\n      if (a[from][middle] == UNDEF) {\n        continue;\n      }\n      for (int to = 0; to < sz; ++to) {\n        if (b[middle][to] != UNDEF) {\n          dp[from][to] = max(dp[from][to], a[from][middle] + b[middle][to]);\n        }\n      }\n    }\n  }\n\n  return dp;\n}\n\nvoid print_state(int x) {\n  cout << x << ':' << nodes[x].happy << ':';\n  while (x) {\n    cout << nodes[x].c;\n    x = nodes[x].p->index;\n  }\n  cout << endl;\n}\n\nint main() {\n  // freopen(\"in.txt\", \"r\", stdin);\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n\n  int n;\n  long long l;\n  cin >> n >> l;\n\n  vector<int> w(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> w[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    add_string(s, w[i]);\n  }\n\n  for (int i = 0; i < sz; ++i) {\n    get_link(&nodes[i]);\n  }\n\n  vector<vector<int64_t>> dp(sz, vector<int64_t>(sz, UNDEF));\n\n\n  for (int i = 0; i < sz; ++i) {\n    for (char c = 'a'; c <= 'z'; ++c) {\n      pNode from = &nodes[i];\n      pNode to = go(from, c);\n      dp[from->index][to->index] = to->happy;\n      // print_state(from->index);\n      // cout << \"=== \" << c << \" ===\" << endl;\n      // print_state(from->index);\n    }\n  }\n\n  // for (int i = 0; i < sz; ++i) {\n    // print_state(i);\n  // }\n\n  vector<vector<int64_t>> current(sz, vector<int64_t>(sz, UNDEF));\n  bool first = true;\n\n  long long k = 1;\n  while (l) {\n    if (l & k) {\n      if (first) {\n        current = dp;\n        first = false;\n      } else {\n        current = apply(current, dp);\n      }\n      l ^= k;\n    }\n    dp = apply(dp, dp);\n    k <<= 1;\n  }\n\n  int64_t ans = 0;\n  for (int i = 0; i < sz; ++i) {\n    ans = max(ans, current[0][i]);\n  }\n  std::cout << ans << std::endl;\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "strings"], "dificulty": "2500", "interactive": false}