{
    "link": "https://codeforces.com//contest/359/problem/D",
    "problemId": "3899",
    "problem_idx": "D",
    "shortId": "359D",
    "contest_number": "359",
    "problem_submissions": {
        "E": [
            4966366,
            4965901,
            4965165,
            4968971,
            4968031,
            5030475,
            5030447,
            5030443
        ],
        "D": [
            4963797,
            4964306,
            4968709,
            4966296,
            4964708,
            4965929,
            4967215,
            4966606,
            4965405,
            4965253,
            4966594,
            4966662,
            4966795,
            4967604,
            4966152,
            4967077
        ],
        "C": [
            4963211,
            4971196,
            4966025,
            4963647,
            4966280,
            4964475,
            4964256,
            4964574,
            4963690,
            4965973,
            4965008,
            4965354,
            4964698,
            4965004,
            4964990,
            4964922
        ],
        "B": [
            4961725,
            4962522,
            4962983,
            4962414,
            4961846,
            4962396,
            4964001,
            4966184,
            4962445,
            4962650,
            4963163,
            4962642,
            4962226,
            4962488,
            4962708
        ],
        "A": [
            4961217,
            4961382,
            4961759,
            4961310,
            4961187,
            4961559,
            4961723,
            4962044,
            4961592,
            4961515,
            4962109,
            4961860,
            4961456,
            4962020,
            4961421
        ]
    },
    "name": "D. Pair of Numbers",
    "statement": "Simon has an array , consisting of positive integers. Today Simon asked\r\nyou to find a pair of integers , such that the following conditions\r\nhold: there is integer (), such that all integers are divisible by ;\r\nvalue takes the maximum value among all pairs for which condition is\r\ntrue; Help Simon, find the required pair of numbers . If there are\r\nmultiple required pairs find all of them.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxN = 300000;\nconst int kMaxR = 1000000;\nint n, a[kMaxN];\nint dp[19][kMaxN];\nint lg[kMaxN + 1];\n\nint gcd(int a, int b) {\n    return (b ? gcd(b, a % b) : a);\n}\n\nint calc(int l, int r) {\n    int t = lg[r - l + 1];\n    return gcd(dp[t][l], dp[t][r - (1 << t) + 1]);\n}\n\nint inr[kMaxR + 1];\nint ans[kMaxN + 1];\n\nbool check(int x) {\n    memset(inr, 0, sizeof(inr));\n    ans[0] = 0;\n    for (int i = 0; i < x; ++ i) inr[a[i]] ++;\n    for (int i = x - 1; i < n; ++ i) {\n        int g = calc(i - x + 1, i);\n        if (inr[g]) ans[++ ans[0]] = i - x + 1;\n        if (i + 1 != n) {\n            inr[a[i - x + 1]] --;\n            inr[a[i + 1]] ++ ;\n        }\n    }\n    return (ans[0] > 0);\n}\n\nint main() {\n    lg[1] = 0;\n    for (int i = 2; i <= kMaxN; ++ i) {\n        lg[i] = lg[i - 1];\n        if (!(i & (i - 1))) ++ lg[i];\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < n; ++ i) dp[0][i] = a[i];\n    for (int j = 1; j < 19; ++ j)\n        for (int i = 0; i < n; ++ i) {\n            dp[j][i] = dp[j - 1][i];\n            if (i + (1 << (j - 1)) < n) dp[j][i] = gcd(dp[j][i], dp[j - 1][i + (1 << (j - 1))]);\n        }\n    int lb = 1, rb = n + 1;\n    while (lb + 1 < rb) {\n        int mid = (lb + rb) >> 1;\n        if (check(mid))\n            lb = mid;\n        else\n            rb = mid;\n    }\n    check(lb);\n    printf(\"%d %d\\n\", ans[0], lb - 1);\n    for (int i = 1; i <= ans[0]; ++ i) printf(\"%d \", ans[i] + 1);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "math",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Pair of Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/9425",
    "editorial": "Quite simple note: if the pair satisfies the condition 1 from the\r\nstatements, then , where is smallest number from the segment (l, r) and\r\nis a GCD of all numbers from the segment (l, r). Calculate some data\r\nstructure that will allow us to respond quickly to requests and . For\r\nexample, you can use Sparce Table. Solutuions, that uses segment tree,\r\nis too slow. So I think, you should use Sparce Table. So, now our task\r\nquite simple. Let\u00e2\u0080\u0099s use binary search to find greatest value of : is the\r\nfunction, that determines, is there some segment where and ( is fixed\r\nvalue by binary search). If there is some good segment, you should\r\nupdate boundaries of binary search correctly. After that, it\u00e2\u0080\u0099s very\r\nsimple to restore answer. Some information about Sparce Table : 4968587\r\n"
}