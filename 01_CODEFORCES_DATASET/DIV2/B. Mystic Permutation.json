{
    "link": "https://codeforces.com//contest/1689/problem/B",
    "problemId": "1426169",
    "problem_idx": "B",
    "shortId": "1689B",
    "contest_number": "1689",
    "problem_submissions": {
        "E": [
            160112065,
            160122128,
            160125790,
            160125174,
            160129572,
            160129585,
            160131786,
            160198613,
            160135003,
            160132850,
            160130305,
            160129724,
            160130309,
            160134699,
            160132208,
            160134730,
            160133947,
            160135624,
            160132845
        ],
        "D": [
            160105444,
            160106619,
            160103165,
            160105284,
            160109476,
            160111661,
            160111580,
            160114903,
            160117754,
            160223912,
            160117858,
            160115373,
            160119358,
            160119569,
            160110447,
            160119288,
            160122102,
            160117625,
            160122103
        ],
        "C": [
            160101725,
            160101027,
            160100377,
            160100502,
            160102947,
            160104518,
            160104470,
            160103940,
            160105751,
            160106384,
            160109439,
            160101319,
            160107036,
            160099160,
            160109505,
            160110151,
            160109766,
            160109925
        ],
        "B": [
            160095106,
            160095099,
            160095692,
            160094546,
            160098042,
            160100154,
            160098117,
            160097987,
            160101496,
            160099759,
            160105755,
            160095146,
            160101519,
            160094285,
            160105059,
            160102238,
            160103140,
            160102070
        ],
        "A": [
            160093939,
            160093596,
            160093753,
            160097601,
            160094503,
            160096047,
            160095876,
            160093955,
            160095035,
            160094694,
            160102269,
            160093545,
            160098465,
            160096387,
            160095131,
            160099800,
            160098054,
            160096796
        ]
    },
    "name": "B. Mystic Permutation",
    "statement": "Recently, he found a permutation of length n. He has to come up with a\r\npermutation. It has to be a new permutation such that it differs from\r\nthe old one in each position.More formally, if the old permutation is\r\np_1,p_2,\r\nldots,p_n and the new one is q_1,q_2,\r\nldots,q_n it must hold that p_1\r\nneq q_1, p_2\r\nneq q_2,\r\nldots ,p_n\r\nneq q_n.Monocarp is afraid of lexicographically large permutations. Can\r\nyou please help him to find the lexicographically minimal permutation?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint T, n;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> T;\n    while (T--) {\n        int n; cin >> n;\n        vector<int> a(n), used(n + 1, 0);\n        for (int i = 0; i < n; i++) cin >> a[i];\n        if (n == 1) {\n            cout << -1 << endl;\n            continue;\n        }\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (!used[j] && a[i] != j) {\n                    used[j] = 1;\n                    cout << j << \" \";\n                    break;\n                }\n            }\n        }\n        int x = 0, y = 0;\n        for (int i = 1; i <= n; i++) {\n            if (!used[i]) {\n                if (!x) x = i;\n                else y = i;\n            }\n        }\n        if (x != a[n - 2] && y != a[n - 1]) cout << x << \" \" << y << endl;\n        else cout << y << \" \" << x << endl;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Mystic Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/103471",
    "editorial": "SolutionThe exception is the last two elements. We can always take the\r\nsmallest available number for each satisfying . To do this we maintain\r\nan array of bools of already taken numbers, and then iterate over it to\r\nfind the smallest available number satisfying which is also not checked\r\nin the array, and then check it (we took it).Now consider and we want to\r\nbe lexicographically minimal while satisfying and . Let and be the last\r\ntwo unused numbers in the array of bools with . We try to take . If or ,\r\nthen we take . If isn\u00e2\u0080\u0099t valid, then is. The proof is left as an exercise\r\nto the reader.This solution runs in and can be optimized to .\r\n"
}