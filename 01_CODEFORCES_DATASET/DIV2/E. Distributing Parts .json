{
    "link": "https://codeforces.com//contest/496/problem/E",
    "problemId": "19580",
    "problem_idx": "E",
    "shortId": "496E",
    "contest_number": "496",
    "problem_submissions": {
        "D": [
            9176843,
            9169490,
            9172648,
            9169938,
            9173192,
            9179837,
            9174502,
            9174977,
            9172607,
            9170640,
            9175019,
            9174412,
            9173755,
            9175240,
            9175102,
            9175021,
            9194689,
            9175370
        ],
        "E": [
            9173226,
            9193133,
            9174734,
            14339417,
            9237849,
            9178765,
            9188533,
            9194680
        ],
        "C": [
            9169367,
            9166605,
            9167404,
            9165048,
            9168057,
            9167727,
            9166806,
            9167081,
            9169029,
            9167067,
            9167500,
            9168857,
            9168096,
            9168403,
            9167842,
            9167765,
            9194690,
            9167905
        ],
        "B": [
            9165977,
            9165371,
            9165516,
            9171586,
            9164457,
            9164520,
            9165537,
            9165229,
            9167890,
            9173609,
            9166677,
            9165999,
            9166755,
            9166602,
            9165952,
            9165871,
            9194688,
            9168604
        ],
        "A": [
            9164610,
            9164035,
            9164187,
            9170696,
            9163931,
            9163962,
            9163896,
            9164249,
            9166611,
            9174109,
            9164186,
            9164233,
            9164281,
            9163978,
            9164264,
            9163934,
            9194687,
            9165603
        ]
    },
    "name": "E. Distributing Parts ",
    "statement": "You are an assistant director in a new musical play. The play consists\r\nof musical parts, each part must be performed by exactly one actor.\r\nAfter the casting the director chose actors who can take part in the\r\nplay. Your task is to assign the parts to actors. However, there are\r\nseveral limitations.First, each actor has a certain voice range and\r\nthere are some parts that he cannot sing. Formally, there are two\r\nintegers for each actor, and () the pitch of the lowest and the highest\r\nnote that the actor can sing. There also are two integers for each part\r\nand () the pitch of the lowest and the highest notes that are present in\r\nthe part. The -th actor can perform the -th part if and only if , i.e.\r\neach note of the part is in the actor\u2019s voice range.According to the\r\ncontract, the -th actor can perform at most parts. Besides, you are\r\nallowed not to give any part to some actors (then they take part in\r\ncrowd scenes).The rehearsal starts in two hours and you need to do the\r\nassignment quickly!\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nset <pair<pair<int, int>, int> > part;\nset <pair<int, int> > ac;\nvector <pair<pair<int, int>, int > > acu;\nint k[1000 * 1000];\nint match[1000 * 1000];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"a.txt\", \"w\", stdout);\n    int n, m, a, b, c;\n    cin >> n;\n    memset(k, 0, sizeof k);\n    memset(match, -1, sizeof match);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a >> b;\n        part.insert(make_pair(make_pair(a, b),i));\n    }\n    cin >> m;\n    for (int i = 0; i < m; i++)\n    {\n        cin >> a >> b >> c;\n        acu.push_back(make_pair(make_pair(a, b) , i));\n        k[i] = c;\n    }\n    sort(acu.begin(), acu.end());\n    ac.insert(make_pair(inf, -1));\n    int s = 0, lo = 0;\n    for (int i = 0; i < n; i++)\n    {\n        a = part.begin()->first.first; b = part.begin()->first.second;\n        c = part.begin()->second;\n        part.erase(part.begin());\n        s = a;\n        while (lo<m && acu[lo].first.first <= s)\n        {\n            ac.insert(make_pair(acu[lo].first.second, acu[lo].second));\n            lo++;\n        }\n        int x = (ac.upper_bound(make_pair(b - 0.1, inf)))->first; int y = (ac.upper_bound(make_pair(b - 0.1, inf)))->second;\n        if (y != -1 && x >= b)\n        {\n            k[y]--;\n            match[c] = y;\n            if (k[y] == 0)\n            {\n                ac.erase(ac.upper_bound(make_pair(b - 0.1, inf)));\n            }\n        }\n        else\n        {\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n    cout << \"YES\" << endl;\n    for (int i = 0; i < n; i++)\n    {\n        if (i>0)cout << \" \";\n        cout << match[i] + 1;\n    }\n    cout << endl;\n    //system(\"pause\");\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Distributing Parts .json",
    "editorial_link": "https://codeforces.com//blog/entry/15208",
    "editorial": "Sort all the parts and actors altogether by increasing lower bounds (if\r\nequal, actors precede parts); process all the enitities in this order.\r\nWe maintain a set of actors which have already occured in the order; if\r\nwe meet an entry for an actor, add it to the set. If we currently\r\nprocess a part, we have to assign it to an actor; from the current set\r\nof actors we have to choose one such that his (the constraint is\r\nprovided by the fact that the -th actor has occured earlier than the -th\r\npart); if there are no such actors in the set, no answer can be\r\nobtained; if there are several actors satisftying this requirement, we\r\nshould choose one with minimal (intuitively, he will be less useful in\r\nthe future). Assign the chosen actor with the current part and decrement\r\nhis ; if is now zero, the actor can not be used anymore, thus we remove\r\nhim from the set. To fit the limits we should implement the set of\r\ncurrent actors as some efficient data structure (e.g., an std::set or a\r\ntreap). The resulting complexity is . Challenge: suppose that now there\r\nare copies of the -th part (), and each copy must be separately assigned\r\nwith an actor in a valid way. Can you solve this new problem with all\r\nthe old constraints (as the actual distribution now has too much\r\nentries, it is sufficient to check whether an answer exists)?\r\n"
}