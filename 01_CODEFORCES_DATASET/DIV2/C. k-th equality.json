{
    "link": "https://codeforces.com//contest/1836/problem/C",
    "problemId": "1971175",
    "problem_idx": "C",
    "shortId": "1836C",
    "contest_number": "1836",
    "problem_submissions": {
        "E": [
            210147681,
            210156192,
            210163487,
            210136429,
            210157213,
            210315010,
            210158073,
            210164123,
            210155192,
            210164163,
            210159525
        ],
        "C": [
            210130232,
            210131057,
            210124529,
            210133873,
            210151231,
            210126284,
            210133931,
            210138158,
            210136673,
            210132463,
            210128133,
            210140056,
            210148028,
            210143853,
            210137711,
            210137608,
            210128551,
            210120166,
            210126121
        ],
        "B": [
            210123440,
            210126296,
            210116405,
            210125585,
            210144712,
            210122722,
            210125845,
            210141461,
            210122883,
            210123468,
            210120670,
            210126915,
            210118094,
            210134923,
            210163701,
            210137111,
            210115730,
            210115790
        ],
        "A": [
            210111620,
            210110060,
            210110623,
            210116661,
            210139143,
            210111484,
            210110034,
            210110353,
            210111957,
            210118244,
            210112250,
            210110488,
            210111107,
            210115218,
            210110094,
            210110963,
            210112266,
            210116067,
            210110124
        ],
        "D": [
            210158558,
            210154147,
            210162752,
            210191544,
            210162490,
            210160449,
            210160513,
            210163603
        ]
    },
    "name": "C. k-th equality",
    "statement": "Consider all equalities of form a + b = c, where a has A digits, b has B\r\ndigits, and c has C digits. All the numbers are integers and are written\r\nwithout leading zeroes. Find the k-th lexicographically smallest\r\nequality when written as a string like above or determine that it does\r\nnot exist.For example, the first three equalities satisfying A = 1, B =\r\n1, C = 2 are 1 + 9 = 10, 2 + 8 = 10, 2 + 9 = 11. An equality s is\r\nlexicographically smaller than an equality t with the same lengths of\r\nthe numbers if and only if the following holds: in the first position\r\nwhere s and t differ, the equality s has a smaller digit than the\r\ncorresponding digit in t.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint powers[7];\nint digits[1000000];\n\nint number_of_good(int A, int b, int c){\n\tint low = A + powers[b - 1];\n\tint high = A + powers[b] - 1;\n\tif (low < powers[c - 1]){\n\t\tlow = powers[c - 1];\n\t}\n\tif (high >= powers[c]){\n\t\thigh = powers[c] - 1;\n\t}\n\t\n\treturn max(0, high - low + 1);\n}\n\nint get_good(int A, int b, int c, long long k){\n\tint low = A + powers[b - 1];\n\tif (low < powers[c - 1]){\n\t\tlow = powers[c - 1];\n\t}\n\t\n\treturn low + k - 1;\n}\n\nstring build(int a, int b){\n\treturn to_string(a) + \" + \" + to_string(b - a) + \" = \" + to_string(b);\n}\n\nstring solve(int a, int b, int c, long long k){\n\tif (c < a || c < b) return \"-1\";\n\t\n\tfor(int i = 1; i < 1000000; ++i){\n\t\tif (digits[i] == a){\n\t\t\tlong long number = number_of_good(i, b, c);\n\t\t\t//cout << i << ' ' << number << endl;\n\t\t\tif (k > number){\n\t\t\t\tk -= number;\n\t\t\t}else{\n\t\t\t\tint B = get_good(i, b, c, k);\n\t\t\t\treturn build(i, B);\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\treturn \"-1\";\n}\n\nint main(){\n\tpowers[0] = 1;\n\tfor(int i = 1; i < 7; ++i){\n\t\tpowers[i] = powers[i - 1] * 10;\n\t}\n\t\n\tfor(int i = 1; i < 1000000; ++i){\n\t\tint tmp = i;\n\t\twhile(tmp > 0){\n\t\t\tdigits[i]++;\n\t\t\ttmp /= 10;\n\t\t}\n\t}\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint a, b, c;\n\t\tlong long k; \n\t\tcin >> a >> b >> c >> k;\n\t\tcout << solve(a, b, c, k) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. k-th equality.json",
    "editorial_link": "https://codeforces.com//blog/entry/117394",
    "editorial": "The largest possible value for is , so we can iterate over each\r\npossibility. When we fix , we can find the range of values for such that\r\n, and . For each such value, we have a correct equality.We can easily\r\nfind this range. We get that and from this inequality, we know how many\r\nequations for the given we have. As we start by minimizing , we can find\r\nits value for the -th equation if we iterate from the smallest possible\r\nvalues of .When we have fixed (or find out that there is no such\r\nequation), we iterate over all possible values of and check if the\r\nresulting has digits. The complexity is .\r\n"
}