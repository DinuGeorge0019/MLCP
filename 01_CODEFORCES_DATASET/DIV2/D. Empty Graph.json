{
    "link": "https://codeforces.com//contest/1712/problem/D",
    "problemId": "1501806",
    "problem_idx": "D",
    "shortId": "1712D",
    "contest_number": "1712",
    "problem_submissions": {
        "F": [
            168185997,
            168251887,
            168219993
        ],
        "D": [
            168145291,
            168129998,
            168130818,
            168126018,
            168130208,
            168150361,
            168134585,
            168133390,
            168138455,
            168134081,
            168125783,
            168137077,
            168136879,
            168129408,
            168136930,
            168129243,
            168125119,
            168132698,
            168160697
        ],
        "E2": [
            168140188,
            168158270,
            168148121,
            168161916,
            168160378,
            168143972,
            168164627,
            168154079,
            168159111,
            168162533,
            168162132,
            168162930,
            168162457,
            168165260,
            168162375,
            168157107,
            168171929,
            168162727,
            168146310
        ],
        "E1": [
            168139990,
            168143565,
            168142598,
            168152240,
            168154486,
            168136125,
            168153299,
            168148039,
            168146574,
            168156854,
            168162049,
            168149859,
            168153717,
            168157309,
            168155734,
            168157279,
            168163352,
            168162849,
            168111592
        ],
        "C": [
            168099696,
            168121142,
            168097588,
            168110349,
            168111432,
            168115384,
            168111269,
            168107817,
            168332689,
            168116564,
            168111708,
            168108690,
            168109977,
            168116188,
            168105860,
            168124053,
            168136319,
            168107454,
            168118827,
            168132254
        ],
        "B": [
            168092536,
            168105158,
            168090795,
            168101197,
            168098906,
            168103766,
            168096786,
            168097289,
            168095985,
            168094917,
            168094914,
            168099431,
            168102987,
            168092377,
            168105879,
            168092526,
            168097397,
            168101154,
            168148773
        ],
        "A": [
            168089016,
            168089238,
            168089117,
            168090448,
            168090182,
            168095836,
            168091066,
            168089267,
            168092084,
            168090133,
            168090067,
            168092244,
            168092571,
            168089003,
            168099380,
            168089001,
            168089147,
            168093453,
            168116561
        ]
    },
    "name": "D. Empty Graph",
    "statement": "O_o and Another Young BoyAn array of n integers a_1,a_2,\r\nldots,a_n fell down on you from the skies, along with a positive integer\r\nk\r\nle n.You can apply the following operation at most k times: Choose an\r\nindex 1\r\nle i\r\nle n and an integer 1\r\nle x\r\nle 10^9. Then do a_i := x (assign x to a_i). Then build a complete\r\nundirected graph with n vertices numbered with integers from 1 to n,\r\nwhere edge (l, r) (1\r\nle l < r\r\nle n) has weight\r\nmin(a_{l},a_{l+1},\r\nldots,a_{r}).You have to find the maximum possible of the resulting\r\ngraph after performing at most k operations.The of a graph is equal to\r\nmax\r\nlimits_{1\r\nle u < v\r\nle n}{\r\noperatorname{d}(u, v)}, where\r\noperatorname{d}(u, v) is the length of the shortest path between vertex\r\nu and vertex v.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define IOS ios::sync_with_stdio(0)\n#define N 1000005\n#define ls k<<1\n#define rs k<<1|1\nint T,n,ans,i,j,k,a[N],b[N],l,r,mid,c[N],pos[N],gg,tot; \nint check(int x){\n\ttot=0;\n\tfor(i=1;i<=n;++i)b[i]=a[i];\n\tfor(i=1;i<=n;++i){\n\t\tif(b[i]*2<x)++tot,b[i]=1e9;\n\t}\n\tint res=2;\n\tfor(i=1;i<n;++i){\n\t\tres=min(res,(b[i]<x)+(b[i+1]<x));\n\t}\n\treturn res+tot;\n}\nsigned main(){\n\tIOS;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>k;\n\t\tfor(i=1;i<=n;++i)cin>>a[i];\n\t\tl=1;r=1000000000;\n\t\twhile(l<r){\n\t\t\tmid=r-(r-l>>1);\n\t\t\tif(check(mid)<=k)l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tcout<<l<<\"\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Empty Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/105919",
    "editorial": "First of all, we will always use the operation to assign to .1. Suppose\r\n. Then .Proof: since the weight of an edge is always , the best we can\r\ndo with one edge is . And the best we can possibly do with two edges is\r\n, which turns out possible to achieve.Subproof: suppose is the index of\r\none of the minimums in the array. If , then is optimal, so we donât need\r\ntwo edges in the first place. Else, either or . In the first case, we\r\ncan notice that . In the second case, . 2. The diameter of the graph is\r\nequal to .Proof: since the minimum of a subsegment can only decrease\r\nwhen itâs length increases, it is optimal to look only at the distance\r\nbetween two adjacent vertices.Now we can either do binary search on the\r\nanswer, or we can do a clever greedy. Binary search solution:Suppose the\r\nanswer is . First of all, we need to apply the operation for all . If\r\nthere are not enough operations to do this, return false. Otherwise\r\nassign to such . If there are no operations left, just calculate the\r\ndiameter and see if it is .If there is at least one operation left,\r\nthere are two cases: and . If the first case, it is optimal to apply our\r\noperation near one of the maximums in the array to maximize , so we need\r\nto return true if . With , it is optimal to apply the operation near an\r\nindex which has been turned into , so we always return true.Make sure to\r\nbinary search on from to inclusive. Doing it from to needs another case\r\nto work.Complexity: .Greedy solution:We can actually maintaining the\r\ndiameter of the graph while supporting point update queries (set to some\r\nvalue). To do this, we can use any structure that can get (multiset,\r\nsegment tree) and another structure to maintain the minimum in the\r\narray.Change the smallest values in the array into . For every from to ,\r\nchange to , get the diameter, and then change back to itâs original\r\nvalue. The answer is the max value over all the returned\r\ndiameters.Proof: obviously works for , so suppose . Since we changed at\r\nleast one value, we will check if having two adjacent is optimal,\r\nmaximizing . And we will also check if we need to change the -th\r\nsmallest value, in this case maximizing .Complexity: Note: it is also\r\npossible to solve without data structures by doing a bit more casework,\r\nbut the solution is still due to sorting.\r\n",
    "hint": [
        "Hint 1",
        "Hint 2 diameter",
        "Hint 3 diameter",
        "Hint 4 Binary search on the answer or do a clever greedy."
    ]
}