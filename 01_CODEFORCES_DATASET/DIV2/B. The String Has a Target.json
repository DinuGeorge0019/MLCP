{
    "link": "https://codeforces.com//contest/1805/problem/B",
    "problemId": "1861352",
    "problem_idx": "B",
    "shortId": "1805B",
    "contest_number": "1805",
    "problem_submissions": {
        "F1": [
            200439106,
            200443524,
            200424069,
            200446588,
            200467490,
            200437348,
            200464508,
            200464351,
            200463340,
            209038123,
            200557576,
            200463298
        ],
        "C": [
            200413348,
            200408313,
            200430286,
            200414727,
            200402344,
            200408784,
            200395896,
            200428904,
            200404720,
            200402863,
            200404086,
            200425916,
            200413389,
            200409508,
            200408670,
            200409948,
            200401611,
            200399297,
            200403669
        ],
        "B": [
            200409525,
            200389992,
            200432442,
            200395023,
            200391231,
            200403848,
            200389421,
            200391233,
            200390818,
            200392560,
            200392816,
            200391784,
            200391655,
            200392657,
            200391007,
            200395691,
            200393122,
            200390776,
            200392459
        ],
        "A": [
            200408080,
            200387988,
            200433504,
            200390983,
            200388843,
            200402551,
            200387906,
            200388117,
            200387935,
            200388566,
            200388387,
            200388650,
            200388558,
            200388007,
            200388011,
            200389948,
            200389103,
            200388194,
            200388689
        ],
        "D": [
            200406761,
            200528793,
            200401484,
            200399149,
            200420505,
            200419712,
            200416986,
            200406203,
            200414310,
            200416697,
            200410720,
            200413945,
            200420475,
            200409512,
            200419982,
            200414162,
            200411839,
            200411433,
            200405601,
            200415016
        ],
        "E": [
            200397032,
            200427084,
            200411961,
            200433750,
            200593267,
            200592726,
            200467387,
            200400294,
            200428962,
            200409350,
            200426292,
            200428409,
            200434434,
            200414709,
            200432234,
            214976359,
            200427846,
            200430477,
            200431439,
            200435575,
            200437915,
            200434896
        ],
        "F2": [
            200479147,
            200478731,
            200478432,
            200478085,
            200477991,
            200477963,
            200476470,
            200447442,
            209038798
        ]
    },
    "name": "B. The String Has a Target",
    "statement": "You are given a string s. You can apply this operation to the string\r\nexactly once: choose index i and move character s_i to the beginning of\r\nthe string (removing it at the old position). For example, if you apply\r\nthe operation with index i=4 to the string \"\" with numbering from 1, you\r\nget the string \"\". What is the lexicographically minimal^{\r\ndagger} string you can obtain by this operation?^{\r\ndagger}A string a is lexicographically smaller than a string b of the\r\nsame length if and only if the following holds: in the first position\r\nwhere a and b differ, the string a has a letter that appears earlier in\r\nthe alphabet than the corresponding letter in b.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define DEBUG\n#define int long long\n#define y1 vbjksfvnbhjaukjliksfmgnj\nconstexpr int inf=1000000007;\nconstexpr long long INF=4000000000000000000;\n//constexpr long long mod=1000000007;\nconstexpr double eps=1e-9;\ninline void YORN(bool f)\n{\n\tif(f)\n\t\tputs(\"YES\");\n\telse\n\t\tputs(\"NO\");\n}\ninline void yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"yes\");\n\telse\n\t\tputs(\"no\");\n}\ninline void Yorn(bool f)\n{\n\tif(f)\n\t\tputs(\"Yes\");\n\telse\n\t\tputs(\"No\");\n}\ninline void judgeoutput(bool f,string s1,string s2)\n{\n\tif(f)\n\t\tcout<<s1<<endl;\n\telse\n\t\tcout<<s2<<endl;\n}\nconstexpr int ___S1=1<<20;\nchar ___buf1[___S1],*___l1,*___r1;\n#define getchar() ((___l1==___r1&&(___r1=(___l1=___buf1)+fread(___buf1,1,___S1,stdin)),___l1!=___r1)?*___l1++:EOF)\ntemplate<typename T=int>inline T read()\n{\n\tT x=0,y=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tif(c=='-')\n\t\t\ty=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*y;\n}\nconstexpr int ___S2=1<<20;\nchar ___buf2[___S2],*___l2=___buf2,*___r2=___buf2+___S2;\n#define putchar(c) (___l2==___r2&&(fwrite(___buf2,1,___S2,stdout),___r2=(___l2=___buf2)+___S2),*___l2++=(c))\nint ___st[22];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0)\n\t\tputchar('-'),x=-x;\n\tint tp=0;\n\tdo\n\t\t___st[++tp]=x%10,x/=10;\n\twhile(x);\n\twhile(tp)\n\t\tputchar(___st[tp--]+'0');\n//\tputchar('\\n');\n}\ninline void fre()\n{\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n}\nvoid work()\n{\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\tchar mn='z';\n\tfor(int i=0;i<n;i++)\n\t\tmn=min(mn,s[i]);\n\tfor(int i=n-1;~i;i--)\n\t\tif(s[i]==mn)\n\t\t{\n\t\t\tcout<<mn<<s.substr(0,i)<<s.substr(i+1)<<endl;\n\t\t\treturn;\n\t\t}\n}\ninline void cases()\n{\n\tint T;\n\tcin>>T;\n\twhile(T--)\n\t\twork();\n}\nsigned main()\n{\n//\tfre();\n\tcases();\n//\twork();\n\tfwrite(___buf2,1,___l2-___buf2,stdout);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The String Has a Target.json",
    "editorial_link": "https://codeforces.com//blog/entry/114644",
    "editorial": "At first, note that the operation should be applied only to the position\r\nof the minimal element of the string (since the 1st position in the\r\nfinal string should always contain the minimal letter). Next, let the\r\npositions of the minimum letter are . Then we must apply the operation\r\nto the last position (). Indeed, let us apply the operation to another\r\noccurrence: then the prefixes will coincide, and after that there will\r\nbe a character that is equal to the minimal one if we applied the\r\noperation to and will not be equal to it otherwise, which contradicts\r\nthe minimal string.\r\n",
    "hint": [
        "Hint 1 What should be the first character if we are trying to make the string lexicographically minimal?",
        "Hint 2 Consider the string « ». If you choose , you get the string « », and if you choose you get « ». Try to generalize this reasoning to any string."
    ]
}