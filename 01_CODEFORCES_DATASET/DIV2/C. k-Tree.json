{
    "link": "https://codeforces.com//contest/431/problem/C",
    "problemId": "9654",
    "problem_idx": "C",
    "shortId": "431C",
    "contest_number": "431",
    "problem_submissions": {
        "D": [
            6672598,
            6676181,
            6673450,
            6673470,
            6674088,
            6674095,
            6674295,
            6674808,
            6675923,
            6675071,
            6674830,
            6674866,
            6674901,
            6674478,
            6674991,
            6674414
        ],
        "E": [
            6671267,
            6673725,
            6713420,
            6713416,
            6713362,
            6676446,
            6676376,
            6675447,
            6675215
        ],
        "C": [
            6671164,
            6669924,
            6671428,
            6670548,
            6670647,
            6671004,
            6671098,
            6672117,
            6672492,
            6671804,
            6670661,
            6670538,
            6670152,
            6671790,
            6670929,
            6672251,
            6671397,
            6672712
        ],
        "B": [
            6669392,
            6669162,
            6669814,
            6669821,
            6669379,
            6669661,
            6669742,
            6670279,
            6669311,
            6670384,
            6669700,
            6669887,
            6671526,
            6670362,
            6670035,
            6670413,
            6670132,
            6671672
        ],
        "A": [
            6668772,
            6668067,
            6668159,
            6668040,
            6668001,
            6668140,
            6668106,
            6668437,
            6668090,
            6669605,
            6668154,
            6669148,
            6670613,
            6668347,
            6668448,
            6668920,
            6668602,
            6670229
        ]
    },
    "name": "C. k-Tree",
    "statement": "Quite recently a creative student Lesha had a lecture on trees. After\r\nthe lecture Lesha was inspired and came up with the tree of his own\r\nwhich he called a -tree.A -tree is an infinite rooted tree where: each\r\nvertex has exactly children; each edge has some weight; if we look at\r\nthe edges that goes from some vertex to its children (exactly edges),\r\nthen their weights will equal . The picture below shows a part of a\r\n3-tree. As soon as Dima, a good friend of Lesha, found out about the\r\ntree, he immediately wondered: \"How many paths of total weight (the sum\r\nof all weights of the edges in the path) are there, starting from the\r\nroot of a -tree and also containing at least one edge of weight at least\r\n?\".Help Dima find an answer to his question. As the number of ways can\r\nbe rather large, print it modulo ().\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#define MASK 1000000007\nint n,k,d;\nlong long f1[200][200],f2[200][200],ans1=0,ans2=0;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&k,&d);\n    for(int i=1;i<=k;i++) f1[1][i]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int l=1;l<=std::min(j,k);l++) f1[i][j]=(f1[i][j]+f1[i-1][j-l])%MASK;\n        }\n    }\n    for(int i=1;i<d;i++) f2[1][i]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int l=1;l<=std::min(j,d-1);l++) f2[i][j]=(f2[i][j]+f2[i-1][j-l])%MASK;\n        }\n    }\n    for(int i=1;i<=n;i++) ans1=(ans1+f1[i][n])%MASK;\n    for(int i=1;i<=n;i++) ans2=(ans2+f2[i][n])%MASK;\n    printf(\"%I64d\\n\",((ans1-ans2)%MASK+MASK)%MASK);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. k-Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/12369",
    "editorial": "This problem can be solved by dinamic programming. Letâs Dp[n][is]\r\nnumber of ways with length equals to in k-tree, where if there is exists\r\nedge with length at least , lengths of all edges less then . Initial\r\nstate Dp[0][0] = 1. Transition iterate all edges which can be first on\r\nthe way in k-tree, then problem transform to the same, but with less\r\nlength of the way (because subtree of vertex son is the k-tree).\r\nDp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0] Dp[n][1] =\r\nDp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) +\r\n... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1]) See solution for more\r\ndetails. Complexity: Notice that this solution can be easy midify to\r\ncomplexity, only precalc partial sums. But it is not neccesary to solve\r\nthis problem in such way. Solution: 6676700\r\n",
    "hint": []
}