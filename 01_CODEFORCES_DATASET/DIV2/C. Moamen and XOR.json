{
    "link": "https://codeforces.com//contest/1557/problem/C",
    "problemId": "1072434",
    "problem_idx": "C",
    "shortId": "1557C",
    "contest_number": "1557",
    "problem_submissions": {
        "E": [
            125390553,
            125390734,
            125392343,
            125392686,
            125431451,
            125435877,
            125406211,
            125406056,
            125414773,
            125406063
        ],
        "D": [
            125366097,
            125368312,
            125364331,
            125365749,
            125357934,
            125344874,
            125362312,
            125363710,
            125360139,
            125365438,
            125352274,
            125365421,
            125369984,
            125368368,
            125366161,
            125468355,
            125462031,
            125368493,
            125372723,
            125367940,
            125373215,
            125366128
        ],
        "B": [
            125339476,
            125330912,
            125327019,
            125342138,
            125325903,
            125329268,
            125324623,
            125326695,
            125334429,
            125327128,
            125335125,
            125326339,
            125327891,
            125331045,
            125330449,
            125461492,
            125334099,
            125330283,
            125340978,
            125329869,
            125325192
        ],
        "A": [
            125335099,
            125321865,
            125321562,
            125320952,
            125321336,
            125323901,
            125320479,
            125327602,
            125322088,
            125320782,
            125336065,
            125321115,
            125321768,
            125324090,
            125325059,
            125320563,
            125324049,
            125322314,
            125322780,
            125320582
        ],
        "C": [
            125325238,
            125355338,
            125335147,
            125349230,
            125339333,
            125363322,
            125341948,
            125346131,
            125341447,
            125343360,
            125338074,
            125338930,
            125334666,
            125347698,
            125346618,
            125348911,
            125346966,
            125353644,
            125345876,
            125344725
        ]
    },
    "name": "C. Moamen and XOR",
    "statement": "Moamen and Ezzat are playing a game. They create an array a of n\r\nnon-negative integers where every element is less than 2^k.Moamen wins\r\nif a_1\r\n,\r\n&\r\n, a_2\r\n,\r\n&\r\n, a_3\r\n,\r\n&\r\n,\r\nldots\r\n,\r\n&\r\n, a_n\r\nge a_1\r\noplus a_2\r\noplus a_3\r\noplus\r\nldots\r\noplus a_n.Here\r\n& denotes the bitwise AND operation, and\r\noplus denotes the bitwise XOR operation.Please calculate the number of\r\nwinning for Moamen arrays a.As the result may be very large, print the\r\nvalue modulo 1\r\n,000\r\n,000\r\n,007 (10^9 + 7).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nint Power(int x,int y){\n\tint r=1;\n\twhile(y){\n\t\tif(y&1)r=1ll*r*x%mod;\n\t\tx=1ll*x*x%mod,y>>=1;\n\t}\n\treturn r;\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tint prod=1,ans=0;\n\t\tfor(int i=k-1;i>=0;i--){\n\t\t\tif(n%2==0)ans=(ans+1ll*prod*Power(Power(2,i),n))%mod;\n\t\t\tint u=0;\n\t\t\tu=Power(2,n-1);\n\t\t\tif(n%2==0)u=(u-1+mod)%mod;\n\t\t\tif(n&1)u=(u+1)%mod;\n\t\t\tprod=1ll*prod*u%mod;\n\t\t}\n\t\tans=(ans+prod)%mod;\n\t\tcout<<ans<<'\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "math",
        "matrices"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Moamen and XOR.json",
    "editorial_link": "https://codeforces.com//blog/entry/93703",
    "editorial": "SolutionFrom now on, I will use to describe the result of the bitwise\r\nAND operation over all the elements in the array, and to describe the\r\nresult of the bitwise XOR operation over all the elements in the\r\narray.Let\u00e2\u0080\u0099s call the array is valid if the value of .We don\u00e2\u0080\u0099t care about\r\nthe values in the array. We just need to know, for every bit, the number\r\nof indices at which this bit is on or off.So let\u00e2\u0080\u0099s build the array from\r\nthe most significant bit () to the least significant bit () using\r\ndynamic programming and combinatorics optimization.Define an array where\r\nthe number of ways to build the array from the -th bit to -th bit. is if\r\nin the previous bits, and if ( is not a valid state).Our base case is ,\r\nand . If is at any moment, then you can choose any subset of indices to\r\ncontain in the -th bit.Therefore, . Now if is odd there are possible\r\nchoices: You can make -th bit in an even number of indices, then will be\r\nand will be too. You can make -th bit in all indices, then will be and\r\nwill be too. You Don\u00e2\u0080\u0099t have any other valid choices. So ({number of ways\r\nto choose number of indices from } ). ( for the second choice). If is\r\neven there are possible choices: You can make -th bit in an even number\r\n(less than ) of indices, then will be and will be also. You can make -th\r\nbit in all indices, then will be and will be . and now will be . You\r\nDon\u00e2\u0080\u0099t have any other valid choices. So (number of ways to choose number\r\nof indices from ) + . We can precalculate the factorial, to get in , and\r\nthen calculate the number of ways to choose an even number from before\r\nstarting the . The total complexity will be .\r\n"
}