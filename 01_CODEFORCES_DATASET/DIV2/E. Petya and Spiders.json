{
    "link": "https://codeforces.com//contest/112/problem/E",
    "problemId": "591",
    "problem_idx": "E",
    "shortId": "112E",
    "contest_number": "112",
    "problem_submissions": {
        "E": [
            661515,
            662874,
            2208045,
            664480,
            661906,
            663725,
            662944,
            662382,
            664303,
            664496,
            664182,
            664291,
            661875,
            663719
        ],
        "D": [
            660108,
            660648,
            666737,
            662551,
            663388,
            661138,
            662047,
            664089,
            661049,
            663375,
            663073,
            663786,
            661800,
            660057,
            659826,
            661487,
            660879
        ],
        "C": [
            658966,
            658390,
            659354,
            659440,
            660401,
            660274,
            659498,
            660592,
            659105,
            659595,
            660276,
            659577,
            660725,
            658945,
            658804,
            659250,
            661169
        ],
        "B": [
            658547,
            659080,
            659101,
            658680,
            658296,
            659054,
            658518,
            658875,
            658579,
            658792,
            659760,
            659247,
            658033,
            658337,
            658386,
            658364
        ],
        "A": [
            658006,
            659133,
            659664,
            657520,
            657372,
            657808,
            657203,
            657373,
            657774,
            657571,
            657367,
            657294,
            657475,
            657744,
            657708,
            657355,
            657910
        ]
    },
    "name": "E. Petya and Spiders",
    "statement": "Little Petya loves training spiders. Petya has a board in size. Each\r\ncell of the board initially has a spider sitting on it. After one second\r\nPetya chooses a certain action for each spider, and all of them humbly\r\nperform its commands. There are 5 possible commands: to stay idle or to\r\nmove from current cell to some of the four side-neighboring cells (that\r\nis, one command for each of the four possible directions). Petya gives\r\nthe commands so that no spider leaves the field. It is allowed for\r\nspiders to pass through each other when they crawl towards each other in\r\nopposite directions. All spiders crawl simultaneously and several\r\nspiders may end up in one cell. Petya wants to know the maximum possible\r\nnumber of spider-free cells after one second.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nint f[41][1 << 14];\nint mask;\nint cnt[1 << 7];\n\nint main() {\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    if (n<m) swap(n,m);\n\n    memset(f,255,sizeof(f));\n    f[0][0]=0; mask=(1 << m)-1;\n    memset(cnt,0,sizeof(cnt));\n    for (int i=0;i<1 << m;++i)\n        for (int j=0;j<m;++j)\n            if (((i >> j) & 1)==0) cnt[i]++;\n    for (int i=0;i<n;++i)\n        for (int j=0;j<1 << 2*m;++j)\n            if (f[i][j]!=-1) {\n                for (int p=mask-(j & mask);p>=0;p=(p-1)&(mask-(j & mask))) {\n                    int state=(j & mask) | p;\n                    int need=(state | (state << 1) | (state >> 1) | ((j >> m) & mask)) & mask;\n                    need=mask-need;\n                    f[i+1][(state << m)+need]=max(f[i+1][(state << m)+need],f[i][j]+cnt[state]);\n                    if (p==0) break;\n                }\n            }\n    int ans=0;\n    for (int i=0;i<1 << m;++i)\n        ans=max(ans,f[n][i << m]);\n\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Petya and Spiders.json",
    "editorial_link": "https://codeforces.com//blog/entry/2616",
    "editorial": "This problem has many different approaches. One of them uses the fact that the overall number of possible inputs is small and it is possible to compute the answer manually for all of them. One could also write a brute-force with a few optimizations, which works even without a precalc.\n\n\nHowever, the major part of all solutions involved dynamic programming with bitmasks. The solution below was described by Zlobober.\n\n\nInstead of counting the maximal number of free cells, well count the minimal number of occupied cells. Well assume that the number of rows is not greater than 6 (otherwise we can rotate the board).\n\n\nLet D[k][pmask][mask] be the minimal number of occupied cells in the first k columns with the restrictions that the k-th column is described by pmask (ones correspond to occupied cells and zeroes correspond to free cells) and k+1-st column is described by mask. To make a transition from D[k-1][*][*] we can iterate over all possible masks for the k-1-st column, check whether we can distribute spiders in kth column knowing the masks for k+1-st and k-1-st columns and find the minimal value of D[k-1][*][pmask] for all such masks.",
    "hint": []
}