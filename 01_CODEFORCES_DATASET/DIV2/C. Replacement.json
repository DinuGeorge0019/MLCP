{
    "link": "https://codeforces.com//contest/570/problem/C",
    "problemId": "33019",
    "problem_idx": "C",
    "shortId": "570C",
    "contest_number": "570",
    "problem_submissions": {
        "A": [
            12511664,
            12494868,
            12495315,
            12495052,
            12498729,
            12495010,
            12494706,
            12495365,
            12494962,
            12496174,
            12494954,
            12502600,
            12496200,
            12496316,
            12506558,
            12502467,
            12495107,
            12496065,
            12498893,
            12498878
        ],
        "B": [
            12509887,
            12497298,
            12497382,
            12499467,
            12505096,
            12495563,
            12498176,
            12497892,
            12496695,
            12495228,
            12498861,
            12499890,
            12502905,
            12497610,
            12503032,
            12504155,
            12497913,
            12496421
        ],
        "E": [
            12508866,
            12514963,
            12515149,
            12513258,
            12512484,
            12512570,
            12514497,
            12512953,
            12509761,
            12511947,
            12514813
        ],
        "D": [
            12503406,
            12507923,
            12507699,
            12507537,
            12509874,
            12513189,
            12507259,
            12527819,
            12514569,
            12511515,
            12568414,
            12512833
        ],
        "C": [
            12498193,
            12507310,
            12502209,
            12498057,
            12501547,
            12500587,
            12501845,
            12503728,
            12502079,
            12505954,
            12509333,
            12499956,
            12503373,
            12503640,
            12501153,
            12511401,
            12502671,
            12506512,
            12510295,
            12502880
        ]
    },
    "name": "C. Replacement",
    "statement": "Daniel has a string , consisting of lowercase English letters and period\r\nsigns (characters ”). Let’s define the operation of as the following\r\nsequence of steps: find a substring \"\" (two consecutive periods) in\r\nstring , of all occurrences of the substring let’s choose the first one,\r\nand replace this substring with string \"\". In other words, during the\r\nreplacement operation, the first two consecutive periods are replaced by\r\none. If string contains no two consecutive periods, then nothing\r\nhappens.Let’s define as the minimum number of operations of to perform,\r\nso that the string does not have any two consecutive periods left.You\r\nneed to process queries, the -th results in that the character at\r\nposition () of string is assigned value . After each operation you have\r\nto calculate and output the value of .Help Daniel to process all\r\nqueries.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n\n#define MAXN 300005\n\nint n,m;\n\nstruct data {\n\tint l,r,size;\n};\n\ninline data operator + (const data &a,const data &b) {\n\treturn (data){a.l==a.size ? a.size+b.l : a.l,b.r==b.size ? b.size+a.r : b.r,a.size+b.size};\n}\n\nchar a[MAXN];\n\nstruct segnode {\n\tsegnode *l,*r;\n\tdata x;\n\t\n\tinline void update() {\n\t\tx=l->x+r->x;\n\t}\n};\n\nsegnode seg[MAXN*2],*segtot=seg;\n\ninline segnode * build(int l,int r) {\n\tsegnode *ret=++segtot;\n\tif (l==r) {\n\t\tret->x=(data){0,0,1};\n\t} else {\n\t\tint mid=(l+r)>>1;\n\t\tret->l=build(l,mid);\n\t\tret->r=build(mid+1,r);\n\t\tret->update();\n\t}\n\treturn ret;\n}\n\ninline data query(segnode *a,int l,int r,int L,int R) {\n\tif (l==L && r==R) return a->x;\n\tint mid=(L+R)>>1;\n\tif (r<=mid) {\n\t\treturn query(a->l,l,r,L,mid);\n\t} else if (l>mid) {\n\t\treturn query(a->r,l,r,mid+1,R);\n\t} else {\n\t\treturn query(a->l,l,mid,L,mid)+query(a->r,mid+1,r,mid+1,R);\n\t}\n}\n\ninline void mod(segnode *a,int pos,data x,int L,int R) {\n\tif (L==R) {\n\t\ta->x=x;\n\t} else {\n\t\tint mid=(L+R)>>1;\n\t\tif (pos<=mid) {\n\t\t\tmod(a->l,pos,x,L,mid);\n\t\t} else {\n\t\t\tmod(a->r,pos,x,mid+1,R);\n\t\t}\n\t\ta->update();\n\t}\n}\n\nint ans;\n\nsegnode *root;\n\ninline void modify(int pos,char x) {\n\tif (x!='.') x=0;\n\tif (x==a[pos]) return;\n\ta[pos]=x;\n\tif (x=='.') {\n\t\tdata L,R;\n\t\tL=R=(data){0,0,0};\n\t\tif (pos>1) L=query(root,1,pos-1,1,n);\n\t\tif (pos<n) R=query(root,pos+1,n,1,n);\n\t\tans-=std::max(L.r-1,0)+std::max(R.l-1,0);\n\t\tans+=L.r+R.l;\n\t\tmod(root,pos,(data){1,1,1},1,n);\n\t} else {\n\t\tdata L,R;\n\t\tL=R=(data){0,0,0};\n\t\tif (pos>1) L=query(root,1,pos-1,1,n);\n\t\tif (pos<n) R=query(root,pos+1,n,1,n);\n\t\tans+=std::max(L.r-1,0)+std::max(R.l-1,0);\n\t\tans-=L.r+R.l;\n\t\tmod(root,pos,(data){0,0,1},1,n);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\troot=build(1,n);\n\tint i;\n\tfor (i=1;i<=n;i++) {\n\t\tchar t=a[i];\n\t\ta[i]=0;\n\t\tmodify(i,t);\n\t}\n\tfor (i=1;i<=m;i++) {\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tchar ch=getchar();\n\t\twhile (ch<=32) ch=getchar();\n\t\tmodify(x,ch);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Replacement.json",
    "editorial_link": "https://codeforces.com//blog/entry/19770",
    "editorial": "Lets find how replacements occur. If we have segment of points with\r\nlength ,we need operations and stop replacements for this segment. If we\r\nsum lenghts of all segments and its quantity then answer will be = total\r\nlength of segments quantity of segments. After change of one symbol\r\nlength changes by 1. Quantity of segments can be supported by array.\r\nConsider events of merging, dividing,creation and deletion of segments.\r\nFor merging we need to find if both of neighbors(right and left) are\r\npoints then merging occured and quantity of segments reduced by 1. Other\r\ncases can be cosidered similarly. Solutions\r\n",
    "hint": []
}