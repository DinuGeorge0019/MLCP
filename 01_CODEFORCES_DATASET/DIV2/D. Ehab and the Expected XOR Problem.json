{
    "link": "https://codeforces.com//contest/1174/problem/D",
    "problemId": "353393",
    "problem_idx": "D",
    "shortId": "1174D",
    "contest_number": "1174",
    "problem_submissions": {
        "E": [
            55039336,
            55044361,
            55047429,
            55040838,
            55047094,
            55042040,
            55042878,
            55038492,
            55074361,
            55045215,
            55070465,
            55052562,
            55043353,
            55077730,
            55041823,
            55062278,
            55053681
        ],
        "D": [
            55035444,
            55029768,
            55027239,
            55028917,
            55030017,
            55031266,
            55030524,
            55028205,
            55035219,
            55028511,
            55029682,
            55031022,
            55031315,
            55027972,
            55032439,
            55032979,
            55028299,
            55033103,
            55028679,
            55031061
        ],
        "F": [
            55031300,
            55038342,
            55040097,
            55045770,
            55039431,
            55046891,
            55053088,
            55047685,
            55049921,
            55049066,
            55039349,
            55055925,
            55055858,
            55055759,
            55055564,
            55043749,
            55038284,
            55041004,
            55058775,
            55042228,
            55041603,
            55041698,
            55114618,
            55041755,
            55042241
        ],
        "C": [
            55029741,
            55022001,
            55024172,
            55023941,
            55024511,
            55027105,
            55028150,
            55023124,
            55027027,
            55025166,
            55024084,
            55029153,
            55025965,
            55022505,
            55024454,
            55026547,
            55024657,
            55028838,
            55026161,
            55026567
        ],
        "A": [
            55027419,
            55020850,
            55019913,
            55020331,
            55020481,
            55020928,
            55020714,
            55019727,
            55021559,
            55020242,
            55019597,
            55021256,
            55019953,
            55019896,
            55019608,
            55020117,
            55020693,
            55023232,
            55019790,
            55019854
        ],
        "B": [
            55024841,
            55019799,
            55022270,
            55021874,
            55022067,
            55023546,
            55022681,
            55021183,
            55024705,
            55023720,
            55021538,
            55025471,
            55021813,
            55021948,
            55022335,
            55022891,
            55031469,
            55023328,
            55023867,
            55022256
        ]
    },
    "name": "D. Ehab and the Expected XOR Problem",
    "statement": "Given two integers n and x, construct an array that satisfies the\r\nfollowing conditions: for any element a_i in the array, 1\r\nle a_i<2^n; there is no subsegment with bitwise XOR equal to 0 or x, its\r\nlength l should be maximized. A sequence b is a subsegment of a sequence\r\na if b can be obtained from a by deletion of several (possibly, zero or\r\nall) elements from the beginning and several (possibly, zero or all)\r\nelements from the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint n, x;\nint vis[(1 << 18) + 5];\nint main()\n{\n\tcin >> n >> x;\n\tfor (int i = 0; i < 1 << n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t\tvis[i ^ x] = 1;\n\t}\n\tint lst = 0;\n\tvector<int> vec;\n\tfor (int i = 1; i < 1 << n; i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tvec.push_back(i ^ lst);\n\t\t\tlst = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int)vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++)\n\t\tprintf(\"%d \", vec[i]);\n\tputs(\"\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Ehab and the Expected XOR Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/67388",
    "editorial": "The main idea is to build the prefix-xor of the array, not the array\r\nitself, then build the array from it. Let the prefix-xor array be called\r\n. Now, . Thus, the problem becomes: construct an array such that no pair\r\nof numbers has bitwise-xor sum equal to 0 or , and its length should be\r\nmaximal. Notice that \"no pair of numbers has bitwise-xor sum equal to 0\"\r\nsimply means \"you can\u00e2\u0080\u0099t use the same number twice\". If , no pair of\r\nnumbers less than will have bitwise-xor sum equal to , so you can just\r\nuse all the numbers from 1 to in any order. Otherwise, you can think of\r\nthe numbers forming pairs, where each pair consists of 2 numbers with\r\nbitwise-xor sum equal to . From any pair, if you add one number to the\r\narray, you can\u00e2\u0080\u0099t add the other. However, the pairs are independent from\r\neach other: your choice in one pair doesn\u00e2\u0080\u0099t affect any other pair. Thus,\r\nyou can just choose either number in any pair and add them in any order\r\nyou want. After you construct , you can construct using the formula: .\r\nCode link: https://pastebin.com/0gCLC0BP Time complexity: .\r\n"
}