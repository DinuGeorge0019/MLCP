{
    "link": "https://codeforces.com//contest/1106/problem/D",
    "problemId": "290933",
    "problem_idx": "D",
    "shortId": "1106D",
    "contest_number": "1106",
    "problem_submissions": {
        "F": [
            49265817,
            49264923,
            49266558,
            49269257,
            49271213,
            49272184,
            49272969,
            49267903,
            49273554,
            49895559,
            49298045,
            49263114,
            49273336,
            49274102,
            49274867,
            49300428,
            49276394,
            49277229,
            49269016,
            49266937,
            49277423,
            49277280,
            49269846
        ],
        "E": [
            49261808,
            49267815,
            49266852,
            49261526,
            49261539,
            49258516,
            49262159,
            49269184,
            49261973,
            49895562,
            49273364,
            49263914,
            49261370,
            49261525,
            49300401,
            49261737,
            49261915,
            49273907,
            49276075,
            49262981,
            49266273,
            49276021
        ],
        "B": [
            49257277,
            49252209,
            49248876,
            49251236,
            49256788,
            49251411,
            49251144,
            49255473,
            49251954,
            49895487,
            49263583,
            49254902,
            49252783,
            49253845,
            49300101,
            49250570,
            49252035,
            49259947,
            49251497,
            49253887,
            49260721,
            49251319
        ],
        "D": [
            49252880,
            49254281,
            49252504,
            49255122,
            49251697,
            49253429,
            49254193,
            49257749,
            49255378,
            49895514,
            49296674,
            49250135,
            49257979,
            49256084,
            49256833,
            49300300,
            49255435,
            49255524,
            49255367,
            49255410,
            49258191,
            49255067,
            49255106
        ],
        "C": [
            49249200,
            49252258,
            49250171,
            49253405,
            49249251,
            49247144,
            49252242,
            49250452,
            49253463,
            49895495,
            49252232,
            49249038,
            49255058,
            49255040,
            49300208,
            49300199,
            49252907,
            49253665,
            49252133,
            49253357,
            49255807,
            49250684,
            49253071
        ],
        "A": [
            49246544,
            49245865,
            49245896,
            49246235,
            49246566,
            49245858,
            49246274,
            49248820,
            49246242,
            49895480,
            49249300,
            49246352,
            49247004,
            49246275,
            49300057,
            49300056,
            49246548,
            49246161,
            49246888,
            49246017,
            49246734,
            49261784,
            49245817
        ]
    },
    "name": "D. Lunar New Year and a Wander",
    "statement": "The park can be represented as a connected graph with n nodes and m\r\nbidirectional edges. Initially Bob is at the node 1 and he records 1 on\r\nhis notebook. He can wander from one node to another through those\r\nbidirectional edges. Whenever he visits a node not recorded on his\r\nnotebook, he records it. After he visits all nodes at least once, he\r\nstops wandering, thus finally a permutation of nodes a_1, a_2,\r\nldots, a_n is recorded.Wandering is a boring thing, but solving problems\r\nis fascinating. Bob wants to know the lexicographically smallest\r\nsequence of nodes he can record while wandering. Bob thinks this problem\r\nis trivial, and he wants you to solve it.A sequence x is\r\nlexicographically smaller than a sequence y if and only if one of the\r\nfollowing holds: x is a prefix of y, but x\r\nne y (this is impossible in this problem as all considered sequences\r\nhave the same length); in the first position where x and y differ, the\r\nsequence x has a smaller element than the corresponding element in y.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 550000;\n\nvector<int> adj[N];\nset<int> S;\nint vis[N];\n\t\nint main() {\n\tios::sync_with_stdio(0);\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint cur = 1;\n\tvector<int> ans;\n\twhile (true) {\n\t\tans.push_back(cur);\n\t\tvis[cur] = 1;\n\t\tif (ans.size() == n) break;\n\t\tfor (int v : adj[cur]) if (!vis[v]) S.insert(v);\n\t\tcur = *S.begin();\n\t\tS.erase(cur);\n\t}\n\tfor (int x : ans) cout << x << \" \";\n\tcout << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Lunar New Year and a Wander.json",
    "editorial_link": "https://codeforces.com/blog/entry/64928",
    "editorial": "In fact, you don\u00e2\u0080\u0099t really need to consider the path Bob wanders. A\r\npriority queue is enough for this problem. When Bob visits a node, add\r\nits adjacent nodes into the priority queue. Every time he visits a new\r\nnode, it will be one with the smallest index in the priority queue.\r\n"
}