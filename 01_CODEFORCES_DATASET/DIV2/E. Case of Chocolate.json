{
    "link": "https://codeforces.com//contest/556/problem/E",
    "problemId": "30418",
    "problem_idx": "E",
    "shortId": "556E",
    "contest_number": "556",
    "problem_submissions": {
        "E": [
            11798593,
            11802983,
            11804367,
            11806288,
            11807296,
            11809513,
            11800434,
            11802658,
            11830953
        ],
        "D": [
            11795355,
            11796315,
            11795899,
            11796322,
            11799061,
            11798540,
            11799119,
            11797672,
            11798131,
            11798280,
            11800191,
            11812529,
            11800092,
            11799755,
            11800619,
            11802251,
            11818504,
            11800610,
            11801708,
            11800703
        ],
        "C": [
            11790828,
            11813461,
            11790864,
            11790816,
            11792705,
            11791993,
            11793214,
            11794207,
            11799350,
            11792271,
            11793843,
            11792946,
            11788929,
            11794460,
            11794387,
            11796150,
            11791587,
            11789894,
            11791106,
            11792562,
            11793761
        ],
        "B": [
            11787481,
            11788094,
            11788373,
            11788280,
            11788531,
            11789067,
            11788489,
            11786492,
            11787137,
            11787902,
            11790114,
            11790590,
            11787542,
            11786980,
            11787988,
            11787858,
            11787163,
            11788286,
            11787516
        ],
        "A": [
            11785901,
            11785921,
            11786590,
            11785894,
            11785846,
            11786159,
            11786486,
            11786214,
            11785755,
            11785763,
            11785847,
            11785750,
            11785944,
            11785887,
            11785926,
            11786005,
            11786011,
            11785820,
            11786301,
            11785958
        ]
    },
    "name": "E. Case of Chocolate",
    "statement": "Andrewid the Android is a galaxy-known detective. Now he does not\r\ninvestigate any case and is eating chocolate out of boredom.A bar of\r\nchocolate can be presented as an table, where each cell represents one\r\npiece of chocolate. The columns of the table are numbered from to from\r\nleft to right and the rows are numbered from top to bottom. Let\u2019s call\r\nthe anti-diagonal to be a diagonal that goes the lower left corner to\r\nthe upper right corner of the table. First Andrewid eats all the pieces\r\nlying below the anti-diagonal. Then he performs the following actions\r\nwith the remaining triangular part: first, he chooses a piece on the\r\nanti-diagonal and either direction \u2019up\u2019 or \u2019left\u2019, and then he begins to\r\neat all the pieces starting from the selected cell, moving in the\r\nselected direction until he reaches the already eaten piece or chocolate\r\nbar edge.After each action, he wants to know how many pieces he ate as a\r\nresult of this action.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nstruct seg {\n  seg(int a, int x, int y) : A(a), X(x), Y(y) {}\n  int A;\n  int X;\n  int Y;\n};\n\nbool operator<(const seg &M, const seg &N) {\n  return M.A < N.A;\n}\n\nset<seg> segs;\n\nint main() {\n  int N, Q;\n  scanf(\"%d %d\\n\", &N, &Q);\n  segs.insert(seg(0, 0, 0));\n  for (int i = 0; i < Q; ++i) {\n    int x, y;\n    char c;\n    scanf(\"%d %d %c\\n\", &x, &y, &c);\n    set<seg>::iterator it = segs.upper_bound(seg(x, 0, 0));\n    --it;\n    if (x == it->A) {\n      printf(\"0\\n\");\n      continue;\n    }\n    int fa = it->A;\n    int fy = it->Y;\n    int fx = it->X;\n    if (c == 'U') {\n      printf(\"%d\\n\", y - it->Y);\n      segs.insert(seg(x, x, fy));\n    } else {\n      printf(\"%d\\n\", x - it->X);\n      segs.erase(it);\n      segs.insert(seg(fa, fx, y));\n      segs.insert(seg(x, fx, fy));\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Case of Chocolate.json",
    "editorial_link": "https://codeforces.com//blog/entry/18919",
    "editorial": "Let's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.\n\nn is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees."
}