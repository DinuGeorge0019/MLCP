{
    "link": "https://codeforces.com//contest/1946/problem/F",
    "problemId": "2546666",
    "problem_idx": "F",
    "shortId": "1946F",
    "contest_number": "1946",
    "problem_submissions": {
        "F": [
            252778634,
            252785320,
            252786013,
            252792288,
            252797773,
            252760159,
            252805049,
            252802973,
            252797418,
            252804807,
            252802498,
            252803677,
            252806450,
            252799639,
            252798045,
            252805458,
            253149787,
            253149764,
            252804697,
            252968362,
            252967816,
            252967536,
            252967308,
            252806243,
            252801898,
            252945361
        ],
        "E": [
            252767893,
            252755066,
            252775649,
            252778497,
            252788255,
            252768645,
            252781620,
            252778378,
            252791272,
            252783666,
            252792255,
            252787037,
            252788438,
            252796123,
            252791048,
            252789043,
            253149820,
            252796931,
            252794065,
            252793295,
            252769537
        ],
        "D": [
            252762969,
            252760657,
            252762929,
            252773084,
            252775710,
            252791493,
            252768538,
            252788123,
            252780760,
            252772529,
            252780806,
            252771784,
            252771623,
            252765540,
            252785160,
            252771914,
            253149843,
            252783465,
            252776484,
            252789596,
            252761305
        ],
        "C": [
            252755980,
            252750182,
            252755510,
            252756532,
            252756457,
            252786638,
            252755577,
            252760887,
            252765082,
            252758814,
            252754307,
            252762090,
            252762611,
            252762199,
            252764272,
            252764206,
            253149881,
            252762872,
            252757806,
            252747947,
            252752185
        ],
        "B": [
            252751889,
            252748922,
            252750334,
            252750610,
            252747768,
            252788061,
            252749547,
            252752546,
            252752071,
            252751826,
            252749973,
            252750830,
            252751955,
            252750419,
            252760194,
            252752821,
            253149896,
            252756666,
            252745823,
            252761849,
            252754627
        ],
        "A": [
            252743735,
            252744280,
            252743830,
            252744601,
            252743817,
            252788730,
            252743641,
            252745268,
            252744800,
            252746033,
            252743616,
            252744372,
            252744103,
            252744348,
            252750764,
            252744631,
            253149908,
            252746630,
            252743684,
            252757716,
            252743737
        ]
    },
    "name": "F. Nobody is needed",
    "statement": "Oleg received a permutation a of length n as a birthday present.Oleg\u2019s\r\nfriend Nechipor asks Oleg q questions, each question is characterized by\r\ntwo numbers l and r, in response to the question Oleg must say the\r\nnumber of sets of indices (t_1, t_2,\r\nldots, t_k) of any length k\r\nge 1 such that: l\r\nle t_i\r\nle r for each i from 1 to k. t_i < t_{i+1} for each i from 1 to k-1.\r\na_{t_{i+1}} is divisible by a_{t_i} for each i from 1 to k-1. Help Oleg\r\nand answer all of Nechipor\u2019s questions.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=1e6+5;\nint n,m;\nint p[MAXN],q[MAXN],d[MAXN];\nvector<int> di[MAXN];\nvector<pair<int,int> > vec[MAXN];\nll ans[MAXN];\nstruct BIT{\nll a[MAXN];\nvoid init(){for(int i=1;i<=n;i++)a[i]=0;}\nll ask(int x){ll s=0;while(x){s+=a[x];x-=(x&-x);}return s;}\nvoid add(int x,int v){while(x<=n){a[x]+=v;x+=(x&-x);}return;}\n}T;\nvoid solve(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>p[i],q[p[i]]=i;\n\tT.init();\n\tfor(int i=1;i<=n;i++) vec[i].clear();\n\tfor(int i=1;i<=m;i++){\n\t\tint l,r;cin>>l>>r;\n\t\tvec[r].push_back(MP(l,i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tpriority_queue<int> Q;\n\t\tQ.push(i);d[i]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.top();Q.pop();\n\t\t\tfor(int v:di[p[u]]) if(q[v]<u){\n\t\t\t\tint p=q[v];\n\t\t\t\tif(!d[p]) Q.push(p);\n\t\t\t\td[p]+=d[u];\n\t\t\t}\n\t\t\t// cout<<\"Add \"<<u<<' '<<d[u]<<endl;\n\t\t\tT.add(u,d[u]);\n\t\t\td[u]=0;\n\t\t}\n\t\tfor(auto it:vec[i]) ans[it.second]=T.ask(n)-T.ask(it.first-1);\n\t}\n\tfor(int i=1;i<=m;i++) cout<<ans[i]<<\" \\n\"[i==m];\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(\"Otomachi_Una.in\",\"r\",stdin);\n\t// freopen(\"Otomachi_Una.out\",\"w\",stdout);\n\tfor(int i=1;i<MAXN;i++) for(int j=i;j<MAXN;j+=i) di[j].push_back(i);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "data structures",
        "dfs and similar",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Nobody is needed.json",
    "editorial_link": "https://codeforces.com//blog/entry/127439",
    "editorial": "Let\u00e2\u0080\u0099s iterate the left boundary of our queries from to and maintain the\r\nFenwick tree , where = the number of sought sets of indices in which ,\r\nand . Then the answer to the query with the left boundary at will be the\r\nsum over the interval in our Fenwick tree. Now we just need to learn how\r\nto update our tree when transitioning from to . Some new sets of indices\r\nmay have been added, starting at . Let\u00e2\u0080\u0099s denote as the position of the\r\nnumber in the permutation. We\u00e2\u0080\u0099ll create an auxiliary array . We\u00e2\u0080\u0099ll learn\r\nto calculate the dynamics the number of sought sets of indices where , .\r\nThe base case will be . Suppose we know the value of . Then we can\r\nupdate , if is divisible by and , . We can calculate this dynamics\r\nstraightforwardly, iterating over and is divisible by and is divisible\r\nby . Notice that this will work in total for for the permutation. Now we\r\ncan iterate over all numbers again that are multiples of , update the\r\nFenwick tree, and clear the array to reuse it in the future.\r\n"
}