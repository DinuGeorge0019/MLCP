{"link": "https://codeforces.com//contest/1130/problem/C", "problemId": "303008", "problem_idx": "C", "shortId": "1130C", "contest_number": "1130", "problem_submissions": {"E": [50451743, 50450700, 50452094, 50453474, 50446313, 50455916, 50454920, 50454012, 50454008, 50454839, 50457467, 50456727, 50456260, 50455672, 50455605, 50457927, 50458312, 50458126, 50457415, 50456722], "D1": [50446455, 50445965, 50445582, 50447980, 50455630, 50447204, 50446775, 50447785, 50448347, 50449449, 50449217, 50450469, 50443264, 50449132, 50450976, 50449020, 50447745, 50451064, 50451498, 50451552], "D2": [50446421, 50445878, 50447104, 50447912, 50455476, 50447640, 50449363, 50448330, 50449131, 50450168, 50449067, 50450309, 50443073, 50449382, 50450922, 50449226, 50450982, 50451004, 50451840, 50451473], "C": [50442552, 50443206, 50442662, 50441379, 50437688, 50442381, 50441711, 50439129, 50445792, 50444106, 50444264, 50443989, 50450118, 50445704, 50445333, 50444492, 50440739, 50444078, 50446518, 50445495], "B": [50438439, 50440829, 50438694, 50437732, 50440500, 50437727, 50437348, 50443831, 50442386, 50441239, 50438973, 50438854, 50445257, 50439931, 50440493, 50439101, 50443847, 50438507, 50438623, 50441001], "A": [50434167, 50434903, 50434750, 50433920, 50434056, 50434451, 50434231, 50435637, 50434352, 50433911, 50435681, 50434866, 50434981, 50436177, 50436562, 50434700, 50434131, 50435258, 50434348, 50436340]}, "name": "C. Connect", "statement": "Alice lives on a flat planet that can be modeled as a square grid of\r\nsize n\r\ntimes n, with rows and columns enumerated from 1 to n. We represent the\r\ncell at the intersection of row r and column c with ordered pair (r, c).\r\nEach cell in the grid is either or . Alice resides in cell (r_1, c_1).\r\nShe wishes to travel to cell (r_2, c_2). At any moment, she may move to\r\none of the cells adjacent to where she is in one of the four directions\r\n(i.e., up, down, left, or right).Unfortunately, Alice cannot swim, and\r\nthere is no viable transportation means other than by foot (i.e., she\r\ncan walk only on ). As a result, Alice\u2019s trip may be impossible.To help\r\nAlice, you plan to create tunnel between some two cells. The tunnel will\r\nallow Alice to freely travel between the two endpoints. Indeed, creating\r\na tunnel is a lot of effort: the cost of creating a tunnel between cells\r\n(r_s, c_s) and (r_t, c_t) is (r_s-r_t)^2 + (c_s-c_t)^2.For now, your\r\ntask is to find the minimum possible cost of creating at most one tunnel\r\nso that Alice could travel from (r_1, c_1) to (r_2, c_2). If no tunnel\r\nneeds to be created, the cost is 0.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, r1, r2, c1, c2, t[60][60], nr[60][60];\nvector <pair <int, int> > v1;\nvector <pair <int, int> > v2;\nchar s[110];\n\nint wyn=1000000000;\n\nvoid dfs1(int r, int c)\n{\n\tnr[r][c]=1;\n\tv1.push_back(make_pair(r, c));\n\tif(t[r+1][c])\n\t{\n\t\tif(!nr[r+1][c])\n\t\t{\n\t\t\tdfs1(r+1, c);\n\t\t}\n\t}\n\tif(t[r-1][c])\n\t{\n\t\tif(!nr[r-1][c])\n\t\t{\n\t\t\tdfs1(r-1, c);\n\t\t}\n\t}\n\tif(t[r][c+1])\n\t{\n\t\tif(!nr[r][c+1])\n\t\t{\n\t\t\tdfs1(r, c+1);\n\t\t}\n\t}\n\tif(t[r][c-1])\n\t{\n\t\tif(!nr[r][c-1])\n\t\t{\n\t\t\tdfs1(r, c-1);\n\t\t}\n\t}\n}\n\nvoid dfs2(int r, int c)\n{\n\tnr[r][c]=2;\n\tv2.push_back(make_pair(r, c));\n\tif(t[r+1][c])\n\t{\n\t\tif(!nr[r+1][c])\n\t\t{\n\t\t\tdfs2(r+1, c);\n\t\t}\n\t}\n\tif(t[r-1][c])\n\t{\n\t\tif(!nr[r-1][c])\n\t\t{\n\t\t\tdfs2(r-1, c);\n\t\t}\n\t}\n\tif(t[r][c+1])\n\t{\n\t\tif(!nr[r][c+1])\n\t\t{\n\t\t\tdfs2(r, c+1);\n\t\t}\n\t}\n\tif(t[r][c-1])\n\t{\n\t\tif(!nr[r][c-1])\n\t\t{\n\t\t\tdfs2(r, c-1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>n>>r1>>c1>>r2>>c2;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tscanf(\"%s\", s);\n\t\tfor(int j=1; j<=n; ++j)\n\t\t{\n\t\t\tif(s[j-1]=='0')\n\t\t\t{\n\t\t\t\tt[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tdfs1(r1, c1);\n\tif(nr[r2][c2]==1)\n\t{\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\tdfs2(r2, c2);\n\tfor(int i=0; i<(int)v1.size(); ++i)\n\t{\n\t\tfor(int j=0; j<(int)v2.size(); ++j)\n\t\t{\n\t\t\twyn=min(wyn, (v1[i].first-v2[j].first)*(v1[i].first-v2[j].first)+(v1[i].second-v2[j].second)*(v1[i].second-v2[j].second));\n\t\t}\n\t}\n\tcout<<wyn;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "dsu"], "dificulty": "1400", "interactive": false}