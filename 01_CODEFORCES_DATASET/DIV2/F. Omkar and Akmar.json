{
    "link": "https://codeforces.com//contest/1536/problem/F",
    "problemId": "1007474",
    "problem_idx": "F",
    "shortId": "1536F",
    "contest_number": "1536",
    "problem_submissions": {
        "E": [
            118631124,
            118614939,
            118616967,
            118624386,
            118627719,
            118635620,
            118636863,
            118621534,
            118623141,
            118619496,
            118630371,
            118626916,
            118634340,
            118635235,
            118626014,
            118625912,
            118631232,
            118724771,
            118637508,
            118632134,
            118634841
        ],
        "F": [
            118625791,
            118638866,
            118613437,
            118637695,
            118644936,
            118650446,
            118647459,
            118663966,
            118711352,
            118653882,
            118654218,
            118882357
        ],
        "C": [
            118608971,
            118600883,
            118628209,
            118608554,
            118608052,
            118619465,
            118622898,
            118607847,
            118602584,
            118598176,
            118609484,
            118609006,
            118618271,
            118606277,
            118606392,
            118620701,
            118612692,
            118724743,
            118612675,
            118612583,
            118612872
        ],
        "D": [
            118608031,
            118607288,
            118623947,
            118617513,
            118619773,
            118632284,
            118632215,
            118614859,
            118617552,
            118601113,
            118616452,
            118622152,
            118614133,
            118620886,
            118617343,
            118616486,
            118624441,
            118724752,
            118620219,
            118627264,
            118625159
        ],
        "B": [
            118602956,
            118599083,
            118634218,
            118612957,
            118602526,
            118613641,
            118606813,
            118602130,
            118599340,
            118630482,
            118605942,
            118604400,
            118601413,
            118601634,
            118600081,
            118601184,
            118602824,
            118724734,
            118602945,
            118605239,
            118604772
        ],
        "A": [
            118598232,
            118597991,
            118635775,
            118598107,
            118598184,
            118601999,
            118598235,
            118599189,
            118598143,
            118622748,
            118598451,
            118598128,
            118598114,
            118598284,
            118598026,
            118597979,
            118598563,
            118724715,
            118598620,
            118599178,
            118598920
        ]
    },
    "name": "F. Omkar and Akmar",
    "statement": "Omkar and Akmar are playing a game on a circular board with n (2\r\nleq n\r\nleq 10^6) cells. The cells are numbered from 1 to n so that for each i\r\n(1\r\nleq i\r\nleq n-1) cell i is adjacent to cell i+1 and cell 1 is adjacent to cell\r\nn. Initially, each cell is empty.Omkar and Akmar take turns placing\r\neither an A or a B on the board, with Akmar going first. The letter must\r\nbe placed on an empty cell. In addition, the letter cannot be placed\r\nadjacent to a cell containing the same letter. A player loses when it is\r\ntheir turn and there are no more valid moves.Output the number of\r\npossible distinct games where both players play optimally modulo 10^9+7.\r\nNote that we only consider games where some player has lost and there\r\nare no more valid moves.Two games are considered distinct if the number\r\nof turns is different or for some turn, the letter or cell number that\r\nthe letter is placed on were different.A move is considered optimal if\r\nthe move maximizes the playerâ€™s chance of winning, assuming the other\r\nplayer plays optimally as well. More formally, if the player who has to\r\nmove has a winning strategy, they have to make a move after which they\r\nwill still have a winning strategy. If they do not, they can make any\r\nmove.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+5,mod=1e9+7;\nll n,ans,jc[N],jv[N];\nint read()\n{\n\tint res=0,fl=0; char a=getchar();\n\twhile(a<'0'||a>'9') fl|=a=='-',a=getchar();\n\twhile(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();\n\treturn fl? -res:res;\n}\nll ksm(ll di,ll mi) {ll res=1; for(;mi;mi>>=1,di=di*di%mod) if(mi&1) res=res*di%mod; return res;}\nll c(ll a,ll b) {return a>=b? jc[a]*jv[b]%mod*jv[a-b]%mod:0;}\nint main()\n{\n\tint i,j;\n\tn=read();\n\tfor(jc[0]=i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;\n\tfor(jv[n]=ksm(jc[n],mod-2),i=n-1;~i;i--) jv[i]=jv[i+1]*(i+1)%mod;\n\tfor(i=0;i<=n-i;i++) if((n-1-i)&1) ans=(ans+c(n-i,i)*jc[n-i-1])%mod;\n\tcout<<ans*2*n%mod;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "combinatorics",
        "constructive algorithms",
        "fft",
        "games",
        "geometry",
        "math",
        "meet-in-the-middle",
        "string suffix structures"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Omkar and Akmar.json",
    "editorial_link": "https://codeforces.com//blog/entry/91520",
    "editorial": "Because of Hint 1 and Hint 2, we want to find the total number of possible games. This can be done by iterating over the number of moves and counting the number of ways to play a game with that number of moves.\n\nWe want to find the number of games that end in x\n moves on a board of size n\n.\n\nThe first step is to calculate the total number of ending states. If x=n\n, the total number of ending states is just 2\n because you can either have ABABA... or BABAB...\n\nOtherwise, a game that ends in x\n moves will consist of x\n letters, for example A|B|A|B|... where a | is a possible location of a single empty cell (there cannot be multiple empty cells next to each other or else it would not be a valid ending state). There are x\n possible places where there can be an empty cell, and n?x\n empty cells, so there are (xn?x)\n ways to choose places to put empty cells. Due to the circular nature of the board, you need to account for the case where the first cell on the board is an empty cell (the previous formula only works if the first cell is not empty). If you set the first cell to be empty, there are not x?1\n possible places to put an empty cell and n?x?1\n remaining empty cells, so you have to add (x?1n?x?1)\n. Multiply the answer by 2\n to account for starting with an A or B.\n\nFinally, multiply by x!\n to account for all the ways you can reach each ending configuration.\n\nThus, if x=n\n, there are 2?x!\n optimal games, otherwise there are 2?((xn?x)+(x?1n?x?1))?x!\n optimal games.\n\nAdd up the number of games that end in x\n moves for all even x\n from ?n2?\n to n\n, inclusive. Thus, the solution is O(n)\n.",
    "hint": [
        "Hint 1 Solve a simpler version of the problem, where you just need to print who would win if both players play optimally. Hint 1 Hint Consider the possible ending states of the board. Hint 1 Solution The 2nd player, Omkar, always wins no matter what either player does. The easiest way to see this is by considering ending states of the board. An ending state with an even number of letters means that the 2nd player wins (because the first player is the next player and there are no more moves), and an ending state with an odd number of letters means that the 1st player wins. An ending state must be in the form ABABA... or BABA..., where there are 0 or 1 empty cells in between each letter and the letters form an alternating pattern. If there is more than 1 empty cell in between two cells, then a player will be able to play a letter, thus it is not a valid ending state. If an ending state has two of the same letters next to each other, then it is not a valid ending state. Either they are next to each other, which is illegal, or there is at least one empty cell in between them, which means that a player can play the other letter in between. Since the ending state must form an alternating pattern, there must be an even number of states. Thus, the 2nd player, Omkar, always wins.",
        "Hint 2 Find the implication of the 2nd player always winning on the number of optimal games."
    ]
}