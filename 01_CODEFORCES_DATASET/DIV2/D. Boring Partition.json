{"link": "https://codeforces.com//contest/239/problem/D", "problemId": "2119", "problem_idx": "D", "shortId": "239D", "contest_number": "239", "problem_submissions": {"E": [2503391, 2503636, 2508718, 2504091, 2504222, 2503009, 2503604, 2504097, 2504475, 2508764, 2503840], "B": [2500622, 2501438, 2500637, 2501733, 2500564, 2500710, 2504655, 2501496, 2501817, 2501834, 2508769], "C": [2500280, 2499958, 2501166, 2500529, 2502431, 2501910, 2500357, 2500775, 2504721, 2502212, 2502257, 2500194, 2502029, 2500713, 2500815, 2500443, 2501561, 2504348], "A": [2498489, 2501638, 2498087, 2498849, 2498385, 2498220, 2500674, 2498079, 2498264, 2499139, 2498265, 2498039, 2498269, 2498638, 2498174, 2499123, 2498500, 2499003], "D": [2504916, 2503214, 2503771, 2503245, 2503673, 2503846, 2504310, 2504271]}, "name": "D. Boring Partition", "statement": "This problem is the most boring one you\u2019ve ever seen. Given a sequence\r\nof integers and a non-negative integer , our goal is to partition the\r\nsequence into two subsequences (not necessarily consist of continuous\r\nelements). Each element of the original sequence should be contained in\r\nexactly one of the result subsequences. Note, that one of the result\r\nsubsequences can be empty.Let\u2019s define function on pairs of distinct\r\nelements (that is ) in the original sequence. If and are in the same\r\nsubsequence in the current partition then otherwise . Consider all\r\npossible values of the function for some partition. We\u2019ll call the of\r\nthis partiotion the difference between the maximum value of function and\r\nthe minimum value of function .Your task is to find a partition of the\r\ngiven sequence that have the minimal possible goodness among all\r\npossible partitions.\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <stack>\n#include <list>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VP;\ntypedef vector<string> VS;\n\n#define FOR(i,a,b) for(i=(a);i<(b);i++)\n#define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ALL(x) x.begin(),x.end()\n#define CLR(x, v) memset((x),v,sizeof (x))\n#define gcd(a, b) __gcd(a, b)\n#define PB push_back \n#define MP make_pair\n#define INF 2000000007\n\nint toInt(string s){ istringstream sin(s); int t; sin>>t; return t; }\ntemplate<class T> string toString(T x){ ostringstream sout; sout<<x; return sout.str(); }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nint a[100010], h;\nVP vp;\nint solve(int x, int p[], int n)\n{\n\tif(n==1) return 0;\n\treturn max(p[n-1]+p[n-2],p[n-1]+x+h)-min(p[0]+p[1],p[0]+x+h);\n}\nint ans[100010];\nint main()\n{\n\tint n;\n\tint i;\n\tcin>>n>>h;\n\tFOR(i,0,n) {\n\t\tcin>>a[i];\n\t\tvp.PB(MP(a[i],i));\n\t}\n\tsort(ALL(vp));\n\tsort(a,a+n);\n\tint v0 = a[n-1]+a[n-2]-a[0]-a[1];\n\tint v1 = solve(a[0],a+1,n-1);\n\tswap(a[0],a[1]);\n\tint v2 = solve(a[0],a+1,n-1);\n\tint v = min(v0,min(v1,v2));\n\tif(v0==v) {\n\t} else if(v1==v) {\n\t\tans[vp[0].second]=1;\n\t} else if(v2==v) {\n\t\tswap(vp[0],vp[1]);\n\t\tans[vp[0].second]=1;\n\t}\n\tcout<<v<<endl;\n\tcout<<ans[0]+1;\n\tFOR(i,1,n) cout<<\" \"<<ans[i]+1;\n\tcout<<endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings"], "dificulty": "1800", "interactive": false}