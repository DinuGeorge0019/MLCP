{"link": "https://codeforces.com//contest/849/problem/C", "problemId": "120623", "problem_idx": "C", "shortId": "849C", "contest_number": "849", "problem_submissions": {"E": [29984627], "D": [29980380, 29984713, 29987113, 29987678, 29986479, 29988201, 29987208, 29988755, 29987991, 29987817, 29987769, 29988339, 29988247, 29989621, 29986927, 29988632, 29990118, 29990720, 29989058, 29990251], "B": [29979684, 29977657, 29978977, 29978484, 29979095, 29977894, 29979276, 29977973, 29982859, 29980015, 29979892, 29979449, 29979975, 29979216, 29978971, 29979346, 29979237, 29979525, 29984295, 29979922], "C": [29976407, 29980612, 29981370, 29975801, 29981874, 29980020, 29981577, 29978884, 29980292, 29982740, 29981839, 29981519, 29982769, 29982080, 29982993, 29981923, 29980470, 29981447, 29979227, 29982562], "A": [29974883, 29975173, 29974854, 29979296, 29975395, 29982064, 29975326, 29974873, 29976333, 29975161, 29977076, 29975568, 29977504, 29975431, 29977059, 29976536, 29974950, 29974966, 29980055, 29977173]}, "name": "C. From Y to Y", "statement": "For a given unordered multiset of lowercase English letters (\"multi\"\r\nmeans that a letter may appear more than once), we treat all letters as\r\nstrings of length , and repeat the following operation times: Remove any\r\ntwo elements and from the set, and add their concatenation to the set.\r\nThe cost of such operation is defined to be , where denotes the number\r\nof times character appears in string .Given a non-negative integer ,\r\nconstruct any valid non-empty set of no more than letters, such that the\r\nminimum accumulative cost of the whole process is . It can be shown that\r\na solution always exists.\r\n", "solutions": ["#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,k=1000,cnt=0;\nint main()\n{\n    n=read();\tif(!n) return 0*puts(\"a\");\n    for(;k>1;--k) while(k*(k-1)/2<=n) \n    {\n    \tn-=k*(k-1)/2;\t\n    \tfor(int i=1;i<=k;++i) printf(\"%c\",'a'+cnt);\n    \t++cnt;\n    }\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1600", "interactive": false}