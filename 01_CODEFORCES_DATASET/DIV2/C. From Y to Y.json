{
    "link": "https://codeforces.com//contest/849/problem/C",
    "problemId": "120623",
    "problem_idx": "C",
    "shortId": "849C",
    "contest_number": "849",
    "problem_submissions": {
        "E": [
            29984627
        ],
        "D": [
            29980380,
            29984713,
            29987113,
            29987678,
            29986479,
            29988201,
            29987208,
            29988755,
            29987991,
            29987817,
            29987769,
            29988339,
            29988247,
            29989621,
            29986927,
            29988632,
            29990118,
            29990720,
            29989058,
            29990251
        ],
        "B": [
            29979684,
            29977657,
            29978977,
            29978484,
            29979095,
            29977894,
            29979276,
            29977973,
            29982859,
            29980015,
            29979892,
            29979449,
            29979975,
            29979216,
            29978971,
            29979346,
            29979237,
            29979525,
            29984295,
            29979922
        ],
        "C": [
            29976407,
            29980612,
            29981370,
            29975801,
            29981874,
            29980020,
            29981577,
            29978884,
            29980292,
            29982740,
            29981839,
            29981519,
            29982769,
            29982080,
            29982993,
            29981923,
            29980470,
            29981447,
            29979227,
            29982562
        ],
        "A": [
            29974883,
            29975173,
            29974854,
            29979296,
            29975395,
            29982064,
            29975326,
            29974873,
            29976333,
            29975161,
            29977076,
            29975568,
            29977504,
            29975431,
            29977059,
            29976536,
            29974950,
            29974966,
            29980055,
            29977173
        ]
    },
    "name": "C. From Y to Y",
    "statement": "For a given unordered multiset of lowercase English letters (\"multi\"\r\nmeans that a letter may appear more than once), we treat all letters as\r\nstrings of length , and repeat the following operation times: Remove any\r\ntwo elements and from the set, and add their concatenation to the set.\r\nThe cost of such operation is defined to be , where denotes the number\r\nof times character appears in string .Given a non-negative integer ,\r\nconstruct any valid non-empty set of no more than letters, such that the\r\nminimum accumulative cost of the whole process is . It can be shown that\r\na solution always exists.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,k=1000,cnt=0;\nint main()\n{\n    n=read();\tif(!n) return 0*puts(\"a\");\n    for(;k>1;--k) while(k*(k-1)/2<=n) \n    {\n    \tn-=k*(k-1)/2;\t\n    \tfor(int i=1;i<=k;++i) printf(\"%c\",'a'+cnt);\n    \t++cnt;\n    }\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. From Y to Y.json",
    "editorial_link": "https://codeforces.com//blog/entry/54233",
    "editorial": "For a given string, how to calculate the cost?\n\nWith several experiments, you may have found that the \"minimum cost\" doesn't make sense Â— the cost is always the same no matter how the characters are concatenated. Precisely, the cost of the process for a multiset of c1 a's, c2 b's, ... and c26 z's, is . It's in this form because every pair of same characters will contribute 1 to the total cost.\n\nTherefore we need to find such c1,?c2,?...,?c26 so that . This can be done greedily and iteratively. Every time we subtract the maximum possible  from k, and add c same new letters to the set, until k becomes 0. This c can be solved by any reasonable way, say quadratic formula, binary search or brute force. Time complexity veries from  to  or any acceptable complexity, depending on the choice of the method for finding c.\n\nOf course, if a knapsack algorithm is used, it will use the minimum possible number of different letters, and works in .",
    "hint": []
}