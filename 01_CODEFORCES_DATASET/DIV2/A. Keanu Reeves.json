{"link": "https://codeforces.com//contest/1189/problem/A", "problemId": "366812", "problem_idx": "A", "shortId": "1189A", "contest_number": "1189", "problem_submissions": {"F": [56579282, 56588782], "E": [56573729, 56581060, 56587807, 56582721, 56573316, 56576668, 56574574, 56574253, 56578675, 56569961, 56571979, 56580045, 56581830, 56582305, 56578680, 56579770, 56574900, 56580107, 56581322, 56581737], "D2": [56570743, 56583951, 56590479], "D1": [56566287, 56577941, 56576232, 56577551, 56577147, 56570210, 56577116, 56576238, 56575115, 56582247, 56573204, 56575137, 56576626, 56575444, 56576506, 56574493, 56579444, 56574000, 56578325, 56573475], "C": [56564288, 56574952, 56571400, 56573424, 56567619, 56566699, 56569018, 56568449, 56569895, 56577759, 56579059, 56569406, 56571224, 56569610, 56573567, 56600577, 56571447, 56582169, 56576771, 56570411, 56571321], "B": [56562679, 56568440, 56565277, 56565965, 56565753, 56564877, 56565902, 56566168, 56565507, 56574431, 56576380, 56566755, 56565186, 56567011, 56566710, 56600572, 56577002, 56568448, 56570059, 56563578, 56569221], "A": [56561345, 56562783, 56561869, 56561808, 56562857, 56561895, 56562128, 56561757, 56561830, 56571793, 56568111, 56561276, 56563011, 56562623, 56562477, 56600568, 56563950, 56562575, 56563861, 56594597, 56561346, 56563282]}, "name": "A. Keanu Reeves", "statement": "After playing Neo in the legendary \"\" trilogy, Keanu Reeves started\r\ndoubting himself: maybe we really live in virtual reality? To find if\r\nthis is true, he needs to solve the following problem.Let\u2019s call a\r\nstring consisting of only zeroes and ones if it contains numbers of\r\nzeroes and ones. For example, , , are good, while , , and are not\r\ngood.We are given a string s of length n consisting of only zeroes and\r\nones. We need to cut s into number of substrings s_1, s_2,\r\nldots, s_k such that of them are good. More formally, we have to find by\r\nnumber of strings sequence of good strings s_1, s_2,\r\nldots, s_k such that their concatenation (joining) equals s, i.e. s_1 +\r\ns_2 +\r\ndots + s_k = s.For example, cuttings into and or into and are valid, as\r\n, , , are all good, and we can\u2019t cut to the smaller number of substrings\r\nas isn\u2019t good itself. At the same time, cutting of into and isn\u2019t valid\r\nas both strings aren\u2019t good. Also, cutting of into , , isn\u2019t valid, as\r\nit isn\u2019t minimal, even though all 3 strings are good.Can you help Keanu?\r\nWe can show that the solution always exists. If there are multiple\r\noptimal answers, print any.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\t\n\tstring s;\n\tint n;\n\tcin>>n>>s;\n\t\n\tint x=0;\n\tfor(int i=0;i<n;i++)if(s[i]=='1')x++;\n\tif(x+x==n){\n\t\tcout<<2<<endl;\n\t\tcout << s.substr(0,n-1) << \" \"<<s[n-1]<<endl;\n\t}\n\telse {\n\t\tcout<<1<<endl;\n\t\tcout<<s<<endl;\n\t}\n\t\n}"], "input": "", "output": "", "tags": ["strings"], "dificulty": "800", "interactive": false}