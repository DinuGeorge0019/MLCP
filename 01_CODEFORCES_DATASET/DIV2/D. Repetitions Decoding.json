{
    "link": "https://codeforces.com//contest/1642/problem/D",
    "problemId": "1306241",
    "problem_idx": "D",
    "shortId": "1642D",
    "contest_number": "1642",
    "problem_submissions": {
        "E": [
            147461190,
            147448894,
            147463582,
            147629005,
            147463721,
            147465007,
            147464536,
            147464772,
            154238571,
            147442248,
            147468697,
            147546721,
            147530401
        ],
        "D": [
            147438364,
            147485650,
            147449537,
            147450562,
            147452894,
            147455461,
            147452625,
            147459786,
            147436803,
            147442745,
            147526042,
            147444306,
            147445760,
            147446955,
            147445886,
            147445039,
            147443394,
            147443106,
            147445514,
            147441961
        ],
        "B": [
            147422743,
            147420129,
            147417727,
            147418273,
            147417851,
            147419235,
            147432654,
            147420007,
            147417444,
            147417393,
            147418769,
            147419164,
            147418158,
            147418261,
            147419265,
            147416406,
            147420612,
            147425669,
            147421032,
            147423752
        ],
        "C": [
            147419008,
            147423535,
            147421085,
            147425938,
            147438330,
            147422534,
            147436627,
            147425010,
            147420010,
            147419556,
            147423431,
            147424779,
            147424498,
            147421790,
            147424573,
            147422658,
            147423818,
            147428109,
            147426206,
            147427103
        ],
        "A": [
            147415594,
            147416949,
            147415861,
            147433429,
            147415090,
            147426989,
            147415984,
            147416265,
            147415834,
            147415031,
            147415872,
            147416127,
            147415441,
            147414768,
            147415249,
            147414961,
            147417533,
            147420604,
            147417311,
            147415231
        ],
        "F": [
            147464749,
            147653708,
            147464855,
            147521397
        ]
    },
    "name": "D. Repetitions Decoding",
    "statement": "Olya has an array of integers a_1, a_2,\r\nldots, a_n. She wants to split it into tandem repeats. Since it’s rarely\r\npossible, before that she wants to perform the following operation\r\nseveral (possibly, zero) number of times: insert a pair of equal numbers\r\ninto an arbitrary position. Help her!More formally: A tandem repeat is a\r\nsequence x of even length 2k such that for each 1\r\nle i\r\nle k the condition x_i = x_{i + k} is satisfied. An array a could be\r\nsplit into tandem repeats if you can split it into several parts, each\r\nbeing a subsegment of the array, such that each part is a tandem repeat.\r\nIn one operation you can choose an arbitrary letter c and insert [c, c]\r\nto any position in the array (at the beginning, between any two\r\nintegers, or at the end). You are to perform several operations and\r\nsplit the array into tandem repeats or determine that it is impossible.\r\nPlease note that you do have to minimize the number of operations.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define inline __attribute((always_inline))\n\n#define cmax(x,y) x=max(x,y)\n#define cmin(x,y) x=min(x,y)\n#define eb emplace_back\n#define MP make_pair\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int,int> Pair;\n\ninline ll read(){\n\tll x=0,c; bool f=0;\n\tfor (;(c=getchar())<'0'||c>'9';f|=c=='-');\n\tfor (;c>='0'&&c<='9';c=getchar()) x=x*10+c-48;\n\treturn f?-x:x;\n}\n\n#define N 300005\n\nint n;\nint a[N],b[N];\n\nvoid init(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n}\n\nvector<pair<int,int>> ans;\nvector<int> t;\n\nvoid solve(){\n\tans.clear(),t.clear();\n\tint now=0;\n\tfor (;n;){\n\t\tint r=2;\n\t\twhile (r<=n&&a[1]!=a[r]) r++;\n\t\tif (r>n) return puts(\"-1\"),void();\n\t\tint x=r;\n\t\tfor (int i=2;i<r;i++,x++) ans.eb(MP(x+now,a[i]));\n\t\tt.eb((r-1)*2);\n\t\tnow+=(r-1)*2;\n\t\tint l=0;\n\t\tfor (int i=r-1;i>1;i--) b[++l]=a[i];\n\t\tfor (int i=r+1;i<=n;i++) b[++l]=a[i];\n\t\tn-=2;\n\t\tfor (int i=1;i<=l;i++) a[i]=b[i];\n\t}\n\tprintf(\"%d\\n\",ans.size());\n\tfor (auto p:ans) printf(\"%d %d\\n\",p.fi,p.se);\n\tprintf(\"%d\\n\",t.size());\n\tfor (auto p:t) printf(\"%d \",p);\n\tputs(\"\");\n}\n\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint cas=read();\n\tfor (;cas--;){\n\t\t//printf(\"Case #%d: \",v);\n\t\tinit();\n\t\tsolve();\n\t\t//puts(\"!!!\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Repetitions Decoding.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "Letâs prove that we can turn the array into a concatenation of tandem\r\nrepeats using the operations given if and only if every letter occurs an\r\neven number of timesIf there is such letter that it occurs an odd number\r\nof times there is no such sequence of operations, since the parity of\r\nthe number of occurrences if letter stays the same. If we insert a\r\ndifferent letter, the number of occurrences of letter does not change,\r\nif we insert letter , we add 2 occurrences of it. Thus, it will be\r\nimpossible to split the array into tandem repeats.If we have an array ,\r\nand we want to reverse its prefix of length , we can insert a pair of\r\nletters equal to after the -th symbol, a pair of letters equal to after\r\n-th symbol and etc.It is obvious that the first symbols of the array\r\nform a tandem repeat. We can add it to our division and cut it out from\r\nthe array. The array will now have its prefix of length reversed. Thus,\r\nwe can move any element to the beginning of the array, so we can simply\r\nsort it. Since every element occurs an even number of times, the\r\nresulting string will be a concatenation of tandem repeats consisting of\r\nthe same letters.\r\n",
    "hint": []
}