{
    "link": "https://codeforces.com//contest/849/problem/D",
    "problemId": "120624",
    "problem_idx": "D",
    "shortId": "849D",
    "contest_number": "849",
    "problem_submissions": {
        "E": [
            29984627
        ],
        "D": [
            29980380,
            29984713,
            29987113,
            29987678,
            29986479,
            29988201,
            29987208,
            29988755,
            29987991,
            29987817,
            29987769,
            29988339,
            29988247,
            29989621,
            29986927,
            29988632,
            29990118,
            29990720,
            29989058,
            29990251
        ],
        "B": [
            29979684,
            29977657,
            29978977,
            29978484,
            29979095,
            29977894,
            29979276,
            29977973,
            29982859,
            29980015,
            29979892,
            29979449,
            29979975,
            29979216,
            29978971,
            29979346,
            29979237,
            29979525,
            29984295,
            29979922
        ],
        "C": [
            29976407,
            29980612,
            29981370,
            29975801,
            29981874,
            29980020,
            29981577,
            29978884,
            29980292,
            29982740,
            29981839,
            29981519,
            29982769,
            29982080,
            29982993,
            29981923,
            29980470,
            29981447,
            29979227,
            29982562
        ],
        "A": [
            29974883,
            29975173,
            29974854,
            29979296,
            29975395,
            29982064,
            29975326,
            29974873,
            29976333,
            29975161,
            29977076,
            29975568,
            29977504,
            29975431,
            29977059,
            29976536,
            29974950,
            29974966,
            29980055,
            29977173
        ]
    },
    "name": "D. Rooter s Song",
    "statement": "On a Cartesian coordinate plane lies a rectangular stage of size ,\r\nrepresented by a rectangle with corners , , and . It can be seen that no\r\ncollisions will happen before one enters the stage.On the sides of the\r\nstage stand dancers. The -th of them falls into one of the following\r\ngroups: : stands at , moves in positive direction (upwards); : stands at\r\n, moves in positive direction (rightwards). According to choreography,\r\nthe -th dancer should stand still for the first milliseconds, and then\r\nstart moving in the specified direction at unit per millisecond, until\r\nanother border is reached. It is guaranteed that no two dancers have the\r\nsame group, position and waiting time at the same time.When two dancers\r\ncollide (i.e. are on the same point at some time when both of them are\r\nmoving), they immediately exchange their moving directions and go on.\r\nDancers stop when a border of the stage is reached. Find out every\r\ndancer\u2019s stopping position.\r\n",
    "solutions": [
        "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define MN 100000\n#define N 131072\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint h,w,n,R[N*2+5],C[N*2+5],rk[MN+5],Ansx[MN+5],Ansy[MN+5];\nstruct data{int g,t,p,T,id;}s[MN+5];\nbool cmp(const data&a,const data&b){return a.T<b.T;}\nvoid Renew(int*T,int x,int v){for(T[x+=N]=v,x>>=1;x;x>>=1)T[x]=T[x<<1]+T[x<<1|1];}\n\nint Query(int*T,int l,int r)\n{\n\tint sum=0;\n\tfor(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1)\n\t{\n\t\tif(~l&1) sum+=T[l+1];\t\n\t\tif( r&1) sum+=T[r-1];\n\t}\n\treturn sum;\n}\n\nint Solve(int*T,int k)\n{\n\tint x=1;\n\tfor(;x<=N;)\n\t{\n\t\tif(T[x<<1]>=k) x<<=1;\n\t\telse k-=T[x<<1],x=x<<1|1;\n\t}\n\treturn x-N;\n}\n\nint main()\n{\n\tn=read();w=read();h=read();\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ts[i].g=read(),s[i].p=read(),s[i].t=read();\n\t\ts[i].T=s[i].p-s[i].t;s[i].id=i;\n\t}\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=1,j;i<=n;i=j+1)\n\t{\n\t\tfor(j=i;j<n&&s[j+1].T==s[i].T;)++j;\n\t\tint tot1=0,tot2=0;\n\t\tfor(int k=i;k<=j;++k)\n\t\t\tif(s[k].g==1) Renew(C,s[k].p,1),++tot1;\n\t\t\telse Renew(R,s[k].p,1),++tot2;\n\t\tfor(int k=i;k<=j;++k)\n\t\t\tif(s[k].g==1)\n\t\t\t{\n\t\t\t\tint y2=Query(C,s[k].p+1,N),y3=tot1-y2;\n\t\t\t\tif(tot2>y2) Ansx[s[k].id]=w,Ansy[s[k].id]=Solve(R,y2+1);\n\t\t\t\telse Ansy[s[k].id]=h,Ansx[s[k].id]=Solve(C,y3+tot2);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tint y2=Query(R,s[k].p+1,N),y3=tot2-y2;\n\t\t\t\tif(tot1>y2) Ansy[s[k].id]=h,Ansx[s[k].id]=Solve(C,y2+1);\n\t\t\t\telse Ansx[s[k].id]=w,Ansy[s[k].id]=Solve(R,y3+tot1);\n\t\t\t}\n\t\tfor(int k=i;k<=j;++k)\n\t\t\tif(s[k].g==1) Renew(C,s[k].p,0);\n\t\t\telse Renew(R,s[k].p,0);\n\t}\n\tfor(int i=1;i<=n;++i) printf(\"%d %d\\n\",Ansx[i],Ansy[i]); \n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Rooter s Song.json",
    "editorial_link": "https://codeforces.com//blog/entry/54233",
    "editorial": "How to deal with \"waiting time\"?\n\nMove every dancer ti units backwards in the first place, that is to (xi?-?ti,?0) for the vertical-moving group, and (0,?yi?-?ti) for the horizontal-moving group. Then start the time, making everyone start moving immediately.\n\nWhen do dancers collide? What changes and what keeps the same?\n\nNotice that if two dancers collide before any other collision happens, then they have the same x?+?y values for their initial positions. Furthermore, after a collision, the two dancers keep having the same x?+?y, and also with the same relative orders of x and y. Also, after a collision, the union of all dancers' tracks will be the same as if they \"went through\" each other and no collision happened at all (see the figure for sample 1 to get a general idea on this).\n\nTherefore, divide dancers into groups by pi?-?ti, and collisions will happen within groups only. Dancers in the same group will move on the same x?+?y line (a line of slope ?-?1), and however collisions take place, they will keep current relative order of x and y. It's proved before that in each group, dancers' exiting positions is the same as if no collision happened at all (namely, (xi,?h) for initially-vertical dancers, and (w,?yi) for initially-horizontal ones). For each group, find out all such positions. Sort all dancers according to their initial x values, and sort these positions in the direction of (0,?h) to (w,?h) then (w,?0). Match the sorted dancers to these sorted positions and obtain the answers for all dancers. This solution works in ."
}