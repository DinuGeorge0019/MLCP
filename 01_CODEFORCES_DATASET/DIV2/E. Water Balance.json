{
    "link": "https://codeforces.com//contest/1300/problem/E",
    "problemId": "536072",
    "problem_idx": "E",
    "shortId": "1300E",
    "contest_number": "1300",
    "problem_submissions": {
        "E": [
            70656422,
            70660342,
            70659594,
            70663407,
            70663445,
            70663695,
            70662627,
            70664459,
            70667573,
            70667578,
            70667153,
            70667998,
            70667370,
            70665044,
            70668944,
            70668742,
            70668939,
            70666794,
            70654169
        ],
        "D": [
            70649967,
            70648316,
            70653519,
            70647449,
            70651136,
            70653985,
            70656894,
            70651482,
            70650140,
            70652905,
            70654553,
            70654763,
            70657422,
            70654653,
            70647217,
            70652554,
            70651738,
            70666577
        ],
        "C": [
            70637820,
            70637616,
            70643543,
            70640283,
            70645889,
            70644943,
            70645600,
            70643218,
            70643243,
            70643430,
            70644879,
            70643858,
            70645790,
            70643117,
            70639743,
            70644978,
            70645908,
            70643196
        ],
        "B": [
            70633510,
            70632581,
            70637741,
            70648477,
            70642916,
            70637878,
            70636707,
            70634786,
            70633496,
            70632050,
            70637586,
            70633740,
            70639225,
            70635607,
            70634472,
            70636324,
            70635597,
            70636449
        ],
        "A": [
            70629102,
            70628944,
            70632868,
            70644279,
            70639039,
            70634945,
            70632554,
            70630514,
            70629803,
            70629176,
            70629854,
            70629908,
            70633145,
            70629847,
            70629744,
            70641116,
            70631231,
            70631279
        ]
    },
    "name": "E. Water Balance",
    "statement": "There are n water tanks in a row, i-th of them contains a_i liters of\r\nwater. The tanks are numbered from 1 to n from left to right.You can\r\nperform the following operation: choose some subsegment [l, r] (1\r\nle l\r\nle r\r\nle n), and redistribute water in tanks l, l+1,\r\ndots, r evenly. In other words, replace each of a_l, a_{l+1},\r\ndots, a_r by\r\nfrac{a_l + a_{l+1} +\r\ndots + a_r}{r-l+1}. For example, if for volumes [1, 3, 6, 7] you choose\r\nl = 2, r = 3, new volumes of water will be [1, 4.5, 4.5, 7]. .What is\r\nthe lexicographically smallest sequence of volumes of water that you can\r\nachieve?As a reminder:A sequence a is lexicographically smaller than a\r\nsequence b of the same length if and only if the following holds: in the\r\nfirst (leftmost) position where a and b differ, the sequence a has a\r\nsmaller element than the corresponding element in b.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntemplate<typename T>\ninline void read(T &x){\n\tint ch = getchar(); x = 0;\n\tbool f = false;\n\twhile((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n\tif(ch == '-'){f = true; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}\n\tif(f) x = -x;\n}\nconst int N = 1000003;\nint n, p[N], top;\nLL a[N];\nint main(){\n\tread(n);\n\tfor(Rint i = 1, x;i <= n;++ i){\n\t\tread(x); a[i] = a[i - 1] + x;\n\t}\n\tfor(Rint i = 1;i <= n;++ i){\n\t\twhile(top && 1.0 * (a[p[top]] - a[p[top - 1]]) / (p[top] - p[top - 1]) - 1.0 * (a[i] - a[p[top - 1]]) / (i - p[top - 1]) > 1e-12) -- top;\n\t\tp[++ top] = i;\n\t}\n\tfor(Rint i = 1;i <= top;++ i){\n\t\tdouble x = 1.0 * (a[p[i]] - a[p[i - 1]]) / (p[i] - p[i - 1]);\n\t\tfor(Rint j = p[i - 1];j < p[i];++ j)\n\t\t\tprintf(\"%.10lf\\n\", x); \n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "geometry",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Water Balance.json",
    "editorial_link": "https://codeforces.com//blog/entry/73763",
    "editorial": "Let's try to make the operation simpler. When we apply the operation, only the sum of the segment matters. And so let's instead define the operation on prefix sum array:\n\nReplace each of pl,pl+1,Â…,pr\n by pi=pl?1+pr?pl?1r?l+1?(i?l+1)\n. You may see how similar it is to a line function. Hence we get the idea to plot points (i,pi)\n ((0,p0=0)\n included), and our operation is just drawing a line between 2\n points on integer x\n coordinates.\n\nNicely if sequence a\n is lexicographically smaller than sequence b\n, then prefix sum array of a\n is smaller than prefix sum array of b\n.\n\nSo we need to find the lexicographically smallest array p\n. And then it is easy to see the lexicographically smallest sequence p\n will be the lower part of the convex hull.\n\nIf you're interested you can solve IMO 2018 SL A4 by plotting similar points. I have written my solutionhere",
    "hint": []
}