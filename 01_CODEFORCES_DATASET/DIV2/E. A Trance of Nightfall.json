{
    "link": "https://codeforces.com//contest/989/problem/E",
    "problemId": "189262",
    "problem_idx": "E",
    "shortId": "989E",
    "contest_number": "989",
    "problem_submissions": {
        "D": [
            39163269,
            39163112,
            39165857,
            39164842,
            39165262,
            39167503,
            39166865,
            39167541,
            39164863,
            39166255,
            39166513,
            40225602,
            39224097
        ],
        "B": [
            39154764,
            39151093,
            39155556,
            39151132,
            39151653,
            39153849,
            39153122,
            39159658,
            39153374,
            39150884,
            39150337,
            39152210,
            39152914,
            39153499,
            39150661
        ],
        "C": [
            39153682,
            39156523,
            39156042,
            39159828,
            39156893,
            39155516,
            39158583,
            39155306,
            39156082,
            39158096,
            39162808,
            39159449,
            39155362,
            39156561,
            39157709,
            39159630
        ],
        "A": [
            39148137,
            39147995,
            39148129,
            39148199,
            39148053,
            39152704,
            39150073,
            39152107,
            39149919,
            39149579,
            39158576,
            39147965,
            39148111,
            39149222,
            39149475,
            39148105
        ],
        "E": [
            39193583,
            39193088
        ]
    },
    "name": "E. A Trance of Nightfall",
    "statement": "There is a set S of n points on a coordinate plane.Kanno starts from a\r\npoint P that can be chosen on the plane. P is not added to S if it\r\ndoesn\u2019t belong to S. Then the following sequence of operations\r\n(altogether called a ) is repeated several times, in the given order:\r\nChoose a line l such that it passes through at least two elements in S\r\nand passes through Kanno\u2019s current position. If there are multiple such\r\nlines, one is chosen equiprobably. Move to one of the points that belong\r\nto S and lie on l. The destination is chosen equiprobably among all\r\npossible ones, including Kanno\u2019s current position (if it does belong to\r\nS). There are q queries each consisting of two integers (t_i, m_i). For\r\neach query, you\u2019re to help Kanno maximize the probability of the\r\nstopping position being the t_i-th element in S after m_i moves with a\r\nproper selection of P, and output this maximum probability. Note that\r\naccording to rule 1, P should belong to at least one line that passes\r\nthrough at least two points from S.\r\n",
    "solutions": [
        "/*\n * Author: ylx\n * LANG: c++\n * PROG: \n */\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x,int y) {if (x<y) x=y;}\nvoid qmin(int &x,int y) {if (x>y) x=y;}\ninline int read()\n{\n\tchar s;\n\tint k=0,base=1;\n\twhile ((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));\n\tif (s==EOF) exit(0);\n\tif (s=='-') base=-1,s=getchar();\n\twhile (isdigit(s)) k=k*10+(s^'0'),s=getchar();\n\treturn k*base;\n}\ninline void write(int x)\n{\n\tstatic char cnt,num[15];cnt=0;\n\tif (!x)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor (;x;x/=10) num[++cnt]=x%10;\n\tfor (;cnt;putchar(num[cnt--]+48));\n}\nconst int maxn=210;\nconst double eps=1e-9;\nint n,T;\nint cnt[maxn*maxn],tot,s[maxn];//cnt[i]:\u76f4\u7ebfi\u4e0a\u7684\u70b9\u7684\u4e2a\u6570,s[i]:\u70b9i\u5468\u56f4\u6709\u7684\u76f4\u7ebf\u7684\u6761\u6570\nstruct matrix\n{\n\tdouble a[maxn][maxn];\n\tvoid clear()\n\t{\n\t\tfor (int i=0;i<maxn;i++)\n\t\t{\n\t\t\tfor (int j=0;j<maxn;j++) a[i][j]=0;\n\t\t\ta[i][i]=1;\n\t\t}\n\t}\n\tfriend matrix operator * (const matrix &a,const matrix &b)\n\t{\n\t\tmatrix c;\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tfor (int k=1;k<=tot;k++) c.a[i][k]=0;\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tfor (int k=1;k<=tot;k++)\n\t\t\t\tfor (int j=1;j<=tot;j++) \n\t\t\t\t{\n\t\t\t\t\tc.a[i][k]+=a.a[i][j]*b.a[j][k];\n\t\t\t\t}\n\t\treturn c;\n\t}\n\tvoid sc()\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t{\n\t\t\tfor (int j=1;j<=tot;j++)\n\t\t\t\tprintf(\"%.10lf \",a[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"-----------------\\n\");\n\t}\n} sum[20];\nstruct node\n{\n\tint x,y;\n} a[maxn];\nint F[maxn][maxn],id,vis[maxn*maxn],X,Y;\nbool check_line(node x,node y,node z)\n{\n\treturn (z.x-x.x)*(z.y-y.y)==(z.y-x.y)*(z.x-y.x);\n}\nvector<int> V[maxn*maxn];\ndouble p[maxn],P[maxn];\nint num[1<<20];\n#define lowbit(x) (x&-x)\nvoid work()\n{\n\tfor (int i=0;i<=13;++i) num[1<<i]=i;\n\tY--;\n\tif (!Y)\n\t{\n\t\tfor (int i=1;i<=n;i++) p[i]=0;\n\t\tp[X]=1;\n\t} else\n\t{\n\t\tY=min(Y,128);\n\t\tbool flag=false;\n\t\tfor (;Y;Y^=lowbit(Y)) \n\t\t{\n\t\t\tregister int i=num[lowbit(Y)];\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tfor (int j=1;j<=n;j++) p[j]=sum[i].a[j][X];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tdouble cur=.0;\n\t\t\t\tfor (int j=1;j<=n;j++,cur=.0)\n\t\t\t\t{\n\t\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\t\tcur+=sum[i].a[j][k]*p[k];\n\t\t\t\t\tP[j]=cur;\n\t\t\t\t}\n\t\t\t\tswap(p,P);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=0.0,sum=0.0;\n\tfor (int i=1;i<=id;i++)\n\t{\n\t\tsum=0.0;\n\t\tfor (int j=0;j<cnt[i];j++) sum+=p[V[i][j]]/(double)cnt[i];\n\t\tans=max(ans,sum);\n\t}\n\tprintf(\"%.8f\\n\",ans);\n}\nint main()\n{\n#ifdef ylx\n\tfreopen(\"989E.in\",\"r\",stdin);\n\tfreopen(\"989E.out\",\"w\",stdout);\n#endif\n\tn=read();tot=n;\n\tfor (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (!F[i][j])\n\t\t\t{\n\t\t\t\t++id;\n\t\t\t\tfor (int k=1;k<=n;k++) if (check_line(a[i],a[j],a[k])) V[id].push_back(k),s[k]++;\n\t\t\t\tcnt[id]=V[id].size();\n\t\t\t\tfor (int k=V[id].size()-1;k>=0;--k)\n\t\t\t\t\tfor (int l=V[id].size()-1;l>=0;--l) F[V[id][k]][V[id][l]]=id;\n\t\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i^j)\n\t\t\t{\n\t\t\t\tsum[0].a[i][j]=1.0/(double)s[i]/cnt[F[i][j]];\n\t\t\t\tif (vis[F[i][j]]!=i)\n\t\t\t\t{\n\t\t\t\t\tvis[F[i][j]]=i;\n\t\t\t\t\tsum[0].a[i][i]+=1.0/s[i]/cnt[F[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor (int i=1;i<=13;i++) \n\t{\n\t\tsum[i]=sum[i-1]*sum[i-1];\n\t}\n\tT=read();\n\twhile (T--)\n\t{\n\t\tX=read();\n\t\tY=read();\n\t\twork();\n\t}\n\treturn 0;\n}\n//2018\u5e74 06\u6708 12\u65e5 \u661f\u671f\u4e8c 19:50:40 CST\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "geometry",
        "matrices",
        "probabilities"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. A Trance of Nightfall.json",
    "editorial_link": "https://codeforces.com//blog/entry/59968",
    "editorial": "Is this a graph theory problem? Yes.Let\u00e2\u0080\u0099s consider a graph , where there\r\nis a vertex for each point in (the terms \"vertices\" and \"points\" are\r\nused interchangeably hereafter), and an edge of weight whenever can be\r\nreached from in one move with a probability of .Finding out all the\r\nlines, removing duplicates, and building the graph can be done\r\nstraightforwardly in time.Represent the graph as an adjacency matrix .\r\nNow, given a fixed target vertex , we\u00e2\u0080\u0099d like to calculate for each\r\nvertex the probability of reaching from after moves. Let be this\r\nprobability.We can represent as an vector. Obviously , where only the\r\n-th element is . Here denotes transpose of .It\u00e2\u0080\u0099s not hard to see that .\r\nThus we can deduce that . By induction, .In this way, for each query ,\r\nwe can calculate in order to get for each the probability of reaching in\r\nsteps.You may ask, why ? It\u00e2\u0080\u0099s because after the first move, the whole\r\nprocess can be determined by Kanno\u00e2\u0080\u0099s position; but the first step is up\r\nto us to decide.To be more precise, the process, therefore the desired\r\nprobability, is determined . We should observe that if we select a point\r\nfrom which there are multiple candidates of , we can always select a\r\npoint on one of the candidates, making it the only candidate without\r\ndecreasing the whole probability. It\u00e2\u0080\u0099s because the average of a set of\r\nnumbers never exceeds the largest among them.Hence, we\u00e2\u0080\u0099ve proved that we\r\nonly need to consider cases where there is only one candidate for , and\r\nsuch cases are always valid. For each , we should calculate the average\r\nof such that the -th point lies on . With calculated, this should take\r\nno more than time.Now, one last thing remains: how to calculate\r\nquickly?We utilize a trick that a multiplication of an matrix and an\r\nvector takes time. With preprocessed for all non-negative integers in\r\ntime, we can perform matrix-vector multiplications in order to calculate\r\nin time.Overall, the time complexity for the problem is .If anybody is\r\never too lazy (:P) to do the fast-exponentiation step, setting and\r\napplying matrix-vector multiplications also work well with the error\r\ntoleration. Think of this problem in other ways that do not work. What\u00e2\u0080\u0099s\r\nthe difference, and where do the redundant calculations lie? Is the\r\nproblem solvable with matrix diagonalization? In theory or in practice,\r\ntry to show that the errors do not accumulate quickly in the matrix\r\nexponentiation processes for this problem.\r\n"
}