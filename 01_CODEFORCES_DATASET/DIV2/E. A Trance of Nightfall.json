{"link": "https://codeforces.com//contest/989/problem/E", "problemId": "189262", "problem_idx": "E", "shortId": "989E", "contest_number": "989", "problem_submissions": {"D": [39163269, 39163112, 39165857, 39164842, 39165262, 39167503, 39166865, 39167541, 39164863, 39166255, 39166513, 40225602, 39224097], "B": [39154764, 39151093, 39155556, 39151132, 39151653, 39153849, 39153122, 39159658, 39153374, 39150884, 39150337, 39152210, 39152914, 39153499, 39150661], "C": [39153682, 39156523, 39156042, 39159828, 39156893, 39155516, 39158583, 39155306, 39156082, 39158096, 39162808, 39159449, 39155362, 39156561, 39157709, 39159630], "A": [39148137, 39147995, 39148129, 39148199, 39148053, 39152704, 39150073, 39152107, 39149919, 39149579, 39158576, 39147965, 39148111, 39149222, 39149475, 39148105], "E": [39193583, 39193088]}, "name": "E. A Trance of Nightfall", "statement": "There is a set S of n points on a coordinate plane.Kanno starts from a\r\npoint P that can be chosen on the plane. P is not added to S if it\r\ndoesn\u2019t belong to S. Then the following sequence of operations\r\n(altogether called a ) is repeated several times, in the given order:\r\nChoose a line l such that it passes through at least two elements in S\r\nand passes through Kanno\u2019s current position. If there are multiple such\r\nlines, one is chosen equiprobably. Move to one of the points that belong\r\nto S and lie on l. The destination is chosen equiprobably among all\r\npossible ones, including Kanno\u2019s current position (if it does belong to\r\nS). There are q queries each consisting of two integers (t_i, m_i). For\r\neach query, you\u2019re to help Kanno maximize the probability of the\r\nstopping position being the t_i-th element in S after m_i moves with a\r\nproper selection of P, and output this maximum probability. Note that\r\naccording to rule 1, P should belong to at least one line that passes\r\nthrough at least two points from S.\r\n", "solutions": ["/*\n * Author: ylx\n * LANG: c++\n * PROG: \n */\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x,int y) {if (x<y) x=y;}\nvoid qmin(int &x,int y) {if (x>y) x=y;}\ninline int read()\n{\n\tchar s;\n\tint k=0,base=1;\n\twhile ((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));\n\tif (s==EOF) exit(0);\n\tif (s=='-') base=-1,s=getchar();\n\twhile (isdigit(s)) k=k*10+(s^'0'),s=getchar();\n\treturn k*base;\n}\ninline void write(int x)\n{\n\tstatic char cnt,num[15];cnt=0;\n\tif (!x)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor (;x;x/=10) num[++cnt]=x%10;\n\tfor (;cnt;putchar(num[cnt--]+48));\n}\nconst int maxn=210;\nconst double eps=1e-9;\nint n,T;\nint cnt[maxn*maxn],tot,s[maxn];//cnt[i]:\u76f4\u7ebfi\u4e0a\u7684\u70b9\u7684\u4e2a\u6570,s[i]:\u70b9i\u5468\u56f4\u6709\u7684\u76f4\u7ebf\u7684\u6761\u6570\nstruct matrix\n{\n\tdouble a[maxn][maxn];\n\tvoid clear()\n\t{\n\t\tfor (int i=0;i<maxn;i++)\n\t\t{\n\t\t\tfor (int j=0;j<maxn;j++) a[i][j]=0;\n\t\t\ta[i][i]=1;\n\t\t}\n\t}\n\tfriend matrix operator * (const matrix &a,const matrix &b)\n\t{\n\t\tmatrix c;\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tfor (int k=1;k<=tot;k++) c.a[i][k]=0;\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tfor (int k=1;k<=tot;k++)\n\t\t\t\tfor (int j=1;j<=tot;j++) \n\t\t\t\t{\n\t\t\t\t\tc.a[i][k]+=a.a[i][j]*b.a[j][k];\n\t\t\t\t}\n\t\treturn c;\n\t}\n\tvoid sc()\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t{\n\t\t\tfor (int j=1;j<=tot;j++)\n\t\t\t\tprintf(\"%.10lf \",a[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"-----------------\\n\");\n\t}\n} sum[20];\nstruct node\n{\n\tint x,y;\n} a[maxn];\nint F[maxn][maxn],id,vis[maxn*maxn],X,Y;\nbool check_line(node x,node y,node z)\n{\n\treturn (z.x-x.x)*(z.y-y.y)==(z.y-x.y)*(z.x-y.x);\n}\nvector<int> V[maxn*maxn];\ndouble p[maxn],P[maxn];\nint num[1<<20];\n#define lowbit(x) (x&-x)\nvoid work()\n{\n\tfor (int i=0;i<=13;++i) num[1<<i]=i;\n\tY--;\n\tif (!Y)\n\t{\n\t\tfor (int i=1;i<=n;i++) p[i]=0;\n\t\tp[X]=1;\n\t} else\n\t{\n\t\tY=min(Y,128);\n\t\tbool flag=false;\n\t\tfor (;Y;Y^=lowbit(Y)) \n\t\t{\n\t\t\tregister int i=num[lowbit(Y)];\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tfor (int j=1;j<=n;j++) p[j]=sum[i].a[j][X];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tdouble cur=.0;\n\t\t\t\tfor (int j=1;j<=n;j++,cur=.0)\n\t\t\t\t{\n\t\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\t\tcur+=sum[i].a[j][k]*p[k];\n\t\t\t\t\tP[j]=cur;\n\t\t\t\t}\n\t\t\t\tswap(p,P);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=0.0,sum=0.0;\n\tfor (int i=1;i<=id;i++)\n\t{\n\t\tsum=0.0;\n\t\tfor (int j=0;j<cnt[i];j++) sum+=p[V[i][j]]/(double)cnt[i];\n\t\tans=max(ans,sum);\n\t}\n\tprintf(\"%.8f\\n\",ans);\n}\nint main()\n{\n#ifdef ylx\n\tfreopen(\"989E.in\",\"r\",stdin);\n\tfreopen(\"989E.out\",\"w\",stdout);\n#endif\n\tn=read();tot=n;\n\tfor (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (!F[i][j])\n\t\t\t{\n\t\t\t\t++id;\n\t\t\t\tfor (int k=1;k<=n;k++) if (check_line(a[i],a[j],a[k])) V[id].push_back(k),s[k]++;\n\t\t\t\tcnt[id]=V[id].size();\n\t\t\t\tfor (int k=V[id].size()-1;k>=0;--k)\n\t\t\t\t\tfor (int l=V[id].size()-1;l>=0;--l) F[V[id][k]][V[id][l]]=id;\n\t\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i^j)\n\t\t\t{\n\t\t\t\tsum[0].a[i][j]=1.0/(double)s[i]/cnt[F[i][j]];\n\t\t\t\tif (vis[F[i][j]]!=i)\n\t\t\t\t{\n\t\t\t\t\tvis[F[i][j]]=i;\n\t\t\t\t\tsum[0].a[i][i]+=1.0/s[i]/cnt[F[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor (int i=1;i<=13;i++) \n\t{\n\t\tsum[i]=sum[i-1]*sum[i-1];\n\t}\n\tT=read();\n\twhile (T--)\n\t{\n\t\tX=read();\n\t\tY=read();\n\t\twork();\n\t}\n\treturn 0;\n}\n//2018\u5e74 06\u6708 12\u65e5 \u661f\u671f\u4e8c 19:50:40 CST\n"], "input": "", "output": "", "tags": ["dp", "geometry", "matrices", "probabilities"], "dificulty": "2700", "interactive": false}