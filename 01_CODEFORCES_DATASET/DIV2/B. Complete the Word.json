{
    "link": "https://codeforces.com//contest/716/problem/B",
    "problemId": "71756",
    "problem_idx": "B",
    "shortId": "716B",
    "contest_number": "716",
    "problem_submissions": {
        "D": [
            20744308,
            20715273,
            20712384,
            20698605,
            20701478,
            20703552,
            20702205,
            20704228,
            20701939,
            20707973,
            20706457,
            20707569,
            20706505,
            20706746,
            20706853,
            20708058,
            20712985,
            20706596,
            20702545,
            20706258,
            20710911,
            20710377
        ],
        "E": [
            20707330,
            20706633,
            57471482,
            57471318,
            20786861,
            20925655
        ],
        "C": [
            20688634,
            20691024,
            20700161,
            20694588,
            20693330,
            20695251,
            20692209,
            20693550,
            20695785,
            20697429,
            20695666,
            20696475,
            20696500,
            20694424,
            20694087,
            20699957,
            20710553,
            20698572,
            20699352,
            20704716
        ],
        "B": [
            20685444,
            20688304,
            20686329,
            20686970,
            24007938,
            20689436,
            20687334,
            20687385,
            20688481,
            20689944,
            20688816,
            20691138,
            20689052,
            20691817,
            20689042,
            20688727,
            20687466,
            20689562,
            20689097,
            20691531,
            20693092
        ],
        "A": [
            20683347,
            20683430,
            20683470,
            20683362,
            23991578,
            20684483,
            20684599,
            20683578,
            20683497,
            20684120,
            20684147,
            20685068,
            20683750,
            20684470,
            20685278,
            20683948,
            20683393,
            20683688,
            20684344,
            20683813,
            20686732
        ]
    },
    "name": "B. Complete the Word",
    "statement": "ZS the Coder loves to read the dictionary. He thinks that a word is if\r\nthere exists a (contiguous segment of letters) of it of length where\r\neach letter of English alphabet appears exactly once. In particular, if\r\nthe string has length strictly less than , no such substring exists and\r\nthus it is not nice.Now, ZS the Coder tells you a word, where some of\r\nits letters are missing as he forgot them. He wants to determine if it\r\nis possible to fill in the missing letters so that the resulting word is\r\nnice. If it is possible, he needs you to find an example of such a word\r\nas well. Can you help him?\r\n",
    "solutions": [
        "/*AMETHYSTS*/\n#pragma comment(linker, \"/STACK:1000000000\")\n#include <cstdio>\n#include <iostream>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <climits>\n#include <string>\n#include <queue>\n#include <memory.h>\n#include <unordered_map>\n#include <random>\n\n#define ll long long\n#define ld double\n#define pii pair <int, int>\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define ui unsigned ll\n\nusing namespace std;\n\nconst int maxn = (int)1e5 + 10;\nchar s[maxn];\nbool used[maxn];\n\nint main() {\n\tscanf(\"%s\", s);\n\n\tint len = strlen(s);\n\n\tfor (int i = 0; i <= len - 26; i++) {\n\t\tmemset(used, 0, sizeof used);\n\t\tbool st = true;\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tif (s[i + j] != '?') {\n\t\t\t\tif (used[s[i + j] - 'A']) {\n\t\t\t\t\tst = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tused[s[i + j] - 'A'] = true;\n\t\t\t}\n\t\t}\n\n\t\tif (st) {\n\t\t\tint pos = 0;\n\n\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\tif (s[i + j] == '?') {\n\t\t\t\t\twhile (pos < 26 && used[pos]) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tused[pos] = true;\n\n\t\t\t\t\ts[i + j] = 'A' + pos;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tif (s[j] == '?') {\n\t\t\t\t\ts[j] = 'A';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%s\\n\", s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << -1 << endl;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Complete the Word.json",
    "editorial_link": "https://codeforces.com//blog/entry/47169",
    "editorial": "Prerequisites : None Firstly, if the length of the string is less than ,\r\noutput immediately. We want to make a substring of length have all the\r\nletters of the alphabet. Thus, the simplest way is to iterate through\r\nall substrings of length (there are such substrings), then for each\r\nsubstring count the number of occurrences of each alphabet, ignoring the\r\nquestion marks. After that, if there exist a letter that occurs twice or\r\nmore, this substring cannot contain all letters of the alphabet, and we\r\nprocess the next substring. Otherwise, we can fill in the question marks\r\nwith the letters that have not appeared in the substring and obtain a\r\nsubstring of length which contains all letters of the alphabet. After\r\niterating through all substrings, either there is no solution, or we\r\nalready created a nice substring. If the former case appears, output .\r\nOtherwise, fill in the remaining question marks with random letters and\r\noutput the string. Note that one can optimize the solution above by\r\nnoting that we donât need to iterate through all letters of each\r\nsubstring we consider, but we can iterate through the substrings from\r\nleft to right and when we move to the next substring, remove the front\r\nletter of the current substring and add the last letter of the next\r\nsubstring. This optimization is not required to pass. We can still\r\noptimize it further and make the complexity purely . We use the same\r\ntrick as above, when we move to the next substring, we remove the\r\nprevious letter and add the new letter. We store a frequency array\r\ncounting how many times each letter appear in the current substring.\r\nAdditionally, store a counter which we will use to detect whether the\r\ncurrent substring can contain all the letters of the alphabet in . When\r\na letter first appear in the frequency array, increment the counter by .\r\nIf a letter disappears (is removed) in the frequency array, decrement\r\nthe counter by . When we add a new question mark, increment the counter\r\nby . When we remove a question mark, decrement the counter by . To check\r\nwhether a substring can work, we just have to check whether the counter\r\nis equal to . This solution works in . Time Complexity : , or Code\r\n(O(26^2*|s|)\r\n",
    "hint": []
}