{
    "link": "https://codeforces.com//contest/922/problem/D",
    "problemId": "154241",
    "problem_idx": "D",
    "shortId": "922D",
    "contest_number": "922",
    "problem_submissions": {
        "F": [
            35024389,
            35030878,
            35066050
        ],
        "E": [
            35021772,
            35023531,
            35025088,
            35031161,
            35025975,
            35029014,
            35026988,
            35021941,
            35026997,
            35064591,
            35064474,
            35026191,
            35037602,
            35037396,
            35027845
        ],
        "A": [
            35014429,
            35006326,
            35014914,
            35006731,
            35022340,
            35006627,
            35016513,
            35027286,
            35015985,
            35019424,
            35007052,
            35007949,
            35037576,
            35006680
        ],
        "C": [
            35013242,
            35014688,
            35008675,
            35009771,
            35021848,
            35009735,
            35022809,
            35015286,
            35020018,
            35017726,
            35013353,
            35014808,
            35011448,
            35018270,
            35015187,
            35037555,
            35037421,
            35021338,
            35014321
        ],
        "D": [
            35011345,
            35017477,
            35010376,
            35021949,
            35015604,
            35013771,
            35027504,
            35020183,
            35031518,
            35015008,
            35019185,
            35023414,
            35018029,
            35028830,
            35018141,
            35037411,
            35026479,
            35021278
        ],
        "B": [
            35007623,
            35008516,
            35007719,
            35008074,
            35008746,
            35007399,
            35009873,
            35009915,
            35012055,
            35007990,
            35009015,
            35007912,
            35008304,
            35009458,
            35010175,
            35037430,
            35007761,
            35008509
        ]
    },
    "name": "D. Robot Vacuum Cleaner",
    "statement": "Pushok the dog has been chasing Imp for a few hours already.\r\nFortunately, Imp knows that Pushok is afraid of a robot vacuum cleaner.\r\nWhile moving, the robot generates a string consisting of letters \u201d and\r\n\u201d, that produces a lot of noise. We define of string as the number of\r\noccurrences of string \"\" as a in it, in other words, the number of such\r\npairs , that and and . The robot is off at the moment. Imp knows that it\r\nhas a sequence of strings in its memory, and he can arbitrary change\r\ntheir order. When the robot is started, it generates the string as a\r\nconcatenation of these strings in the given order. The noise of the\r\nresulting string equals the noise of this concatenation.Help Imp to find\r\nthe maximum noise he can achieve by changing the order of the strings.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, a[MAXN];\nstring s[MAXN];\n\nll get(string t){\n\tll res = 0;\n\tint c = 0;\n\tfor (int i = 0; i < t.size(); i++){\n\t\tif (t[i] == 's')\n\t\t\tc++;\n\t\telse\n\t\t\tres += c;\n\t}\n\treturn res;\n}\n\nbool cmp(int u, int v){\n\treturn get(s[u]+s[v]) > get(s[v]+s[u]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> s[i];\n\tiota(a, a + n, 0);\n\tsort(a, a + n, cmp);\n\tstring t;\n\tfor (int i = 0; i < n; i++)\n\t\tt += s[a[i]];\n\tcout << get(t) << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Robot Vacuum Cleaner.json",
    "editorial_link": "https://codeforces.com//blog/entry/57605",
    "editorial": "Denote as the noise function. We are gonna sort the string set in the\r\nfollowing way: for each pair we will put earlier if . The claim is that\r\nthe final concatenation will be optimal.Let be the number of\r\nsubsequences in , in . Then , . and are reduced, and the comparator\r\nturns into . This is almost equivalent to (except the degenerate case\r\nwhen the string consists of only), meaning that the sort is\r\ntransitive.Now suppose that this is all false and in the optimal\r\nconcatenation for some pair of strings the aforementioned statement\r\ndoesn\u00e2\u0080\u0099t hold. Then it can be easily shown that you can change their\r\npositions and the answer will only get better. .\r\n"
}