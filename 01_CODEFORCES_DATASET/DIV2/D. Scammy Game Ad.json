{
    "link": "https://codeforces.com//contest/2078/problem/D",
    "problemId": "3258040",
    "problem_idx": "D",
    "shortId": "2078D",
    "contest_number": "2078",
    "problem_submissions": {
        "F": [
            309845168,
            309804613,
            309841796,
            309823067,
            309971772,
            309858819,
            309855533,
            309841437,
            309834105,
            309851430,
            309826936,
            309834714,
            309835485,
            309840125,
            309827794,
            309828757
        ],
        "E": [
            309812379,
            309854980,
            309839226,
            309853674,
            309832176,
            309835402,
            309857392,
            309853622,
            309829570
        ],
        "D": [
            309801382,
            309795004,
            309820420,
            309784551,
            309817372,
            309815186,
            309816026,
            309844527,
            309853381,
            309802672,
            309817126,
            309822071,
            309793873,
            309820885,
            309833034
        ],
        "C": [
            309787405,
            309840609,
            309788191,
            309843996,
            309800781,
            309791909,
            309812664,
            309803352,
            309798971,
            309815039,
            309796718,
            309806817,
            309816670,
            309839012,
            309795576
        ],
        "A": [
            309780485,
            309778788,
            309767942,
            309767794,
            309767952,
            309767753,
            309784104,
            309803728,
            309781369,
            309767607,
            309771222,
            309775146,
            309770593,
            309767881,
            309767838
        ],
        "B": [
            309780352,
            309782582,
            309776930,
            309777081,
            309772587,
            309777502,
            309794442,
            309808722,
            309789512,
            309773973,
            309780928,
            309797844,
            309803238,
            309783432,
            309769465
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140505",
    "editorial": "Solution 1This is the greedy solution.When we get more people, place all\r\nto where the will occur first. If both lanes have the next multiply at\r\nthe same gate pair, then choose the one with higher multiply. If the\r\nmultiply is the same, look to the next multiply. ProofIt’s easier to\r\nthink of as . The idea is as follows.Consider the range of gate pairs\r\nbetween two pairs with different multiply, and the pairs in the range\r\nall have the same multiply. You have people on the left side and on the\r\nright side before you enter the range. In this range, you will gain a\r\nconstant number of people, say , regardless of your actions here. You\r\nchoose to allocate to the left side.At the end of the range, there’s a\r\npair of gates where (same argument for case ). After passing the gate,\r\nyou will gain more people. With the current number people of on the left\r\nside and on the right side, we can see that maximizing is the optimal\r\nchoice, because there always exist an allocation such that both number\r\nof people on the left and right side will exceed those with lower\r\nselection of .Time complexity: per test case. implementations are also\r\nacceptable.Submission: 310297718\r\n",
    "name": "D. Scammy Game Ad",
    "statement": "Consider the following game. In this game, a level consists of n pairs\r\nof gates. Each pair contains one left gate and one right gate. Each gate\r\nperforms one of two operations: (): Increases the number of people in a\r\nlane by a constant amount a. (): Multiplies the current number of people\r\nin a lane by an integer a. This means the number of people increases by\r\n(a - 1) times the current count in that lane. The additional people\r\ngained from each operation can be assigned to either lane. However,\r\npeople already in a lane be moved to the other lane.Initially, there is\r\none person in each lane. Your task is to determine the maximum total\r\nnumber of people that can be achieved by the end of the level.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Scammy Game Ad.json",
    "hint": [
        "Hint 1 It is optimal to place everyone on the same lane.",
        "Hint 2 Think about the multiplier.",
        "Hint 3 It is best to think of each as \"how much can we multiply this by\".",
        "Hint 1 Try to get information on half of the bits.",
        "Hint 2 Alternate the bits.",
        "Hint 1 Find a closed-form expression for the score of a binary string.",
        "Hint 2 The closed-form expression for the score of a binary string is Where and are the number of and in the binary string, respectively. A useful rearrangement",
        "Hint 3 The expression for counting subsequences might be simpler than you think.",
        "Hint 1 Find a way to get the answer if you fixed the largest value or the first value of the subsequence.",
        "Hint 2 Sufficiently long (which is not that long) arrays will definitely be polygon side lengths.",
        "Hint 1 Folding is basically alternating the parity of the indices.",
        "Hint 2 Maximum subarray sum.",
        "Hint 1 Characterize the property of a good pair of arrays.",
        "Hint 2 Think about the last operation that turns a good pair of arrays into the same array.",
        "Hint 1 It might help to solve this task with two colors first. As in, minimize the difference between red and blue. Hint 1.1 Walking back and forth can do wonders. Solution for this Let the difference between the red edges and the blue edges passed be . Let the edge weights of the red edges be and the blue edges be . Let and . We can find a walk with which passes every edge and returns to vertex . Proof For each edge, walk to one of its endpoint, walk that edge, and then walk back to vertex using the same walk. This way, we passed through every edge an even number of times. We will now walk back and forth using the edges we passed. This way, we can add to by some linear combination of . Because is divisible by , we can add to it such that by Bézout's identity. Note: About the \"can add by some linear combination\", there's the slight caveat that we can only add the red and subtract the blue. We can subtract the red (or similarly, add the blue) by first subtracting from blue by , then add back red just so that it is deficit by the edge weight. After passing every edge and returning to vertex with , we can walk from vertex to vertex . If the walk have divisible by , then the answer is and otherwise. The proof of this is similar to the proof above. To check if a walk with divisible by exist or not, create a state graph where each vertex is either \"reach the vertex with divisible by \" and \" not divisible by \".",
        "Hint 1.1 Walking back and forth can do wonders.",
        "Hint 2 In the two-color version (in Hint 1), we created a state graph on the parity. Can a similar idea be used?",
        "Hint 3 Think about each color separately first."
    ]
}