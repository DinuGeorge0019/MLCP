{"link": "https://codeforces.com//contest/84/problem/E", "problemId": "441", "problem_idx": "E", "shortId": "84E", "contest_number": "84", "problem_submissions": {"E": [452627, 449024, 452609], "D": [450400, 451453, 450260, 451049, 453042, 452087, 451115, 451601, 451359, 451092, 451134, 451165, 450005, 451055], "C": [447706, 448885, 448694, 448914, 451302, 448275, 448059, 448906, 449306, 449387, 449576, 449309, 449347, 449955, 451170, 448806], "B": [446645, 447856, 447405, 447553, 453022, 447491, 447046, 447993, 447247, 447674, 447584, 447304, 447460, 447841, 447050, 447119], "A": [446385, 57312850, 57312533, 44578621, 6030624, 2567513, 2498001, 2426190, 2072252, 1715370, 1214658, 447192, 447016, 446945, 446434, 446701, 446518, 447430, 446507, 446885, 446463, 446570, 446769, 447019, 446386, 446513]}, "name": "E. Track", "statement": "You already know that Valery\u2019s favorite sport is biathlon. Due to your\r\nhelp, he learned to shoot without missing, and his skills are unmatched\r\nat the shooting range. But now a smaller task is to be performed, he\r\nshould learn to complete the path fastest.The track\u2019s map is represented\r\nby a rectangle in size divided into squares. Each square is marked with\r\na lowercase Latin letter (which means the type of the plot), with the\r\nexception of the starting square (it is marked with a capital Latin\r\nletters ) and the terminating square (it is marked with a capital Latin\r\nletter ). The time of movement from one square to another is equal to\r\nminute. The time of movement within the cell can be neglected. We can\r\nmove from the cell only to side-adjacent ones, but it is forbidden to go\r\nbeyond the map edges. Also the following restriction is imposed on the\r\npath: it is not allowed to visit more than of squares (squares of one\r\ntype can be visited an infinite number of times). Squares marked with\r\nand have no type, so they are not counted. But must be visited exactly\r\nonce at the very beginning, and must be visited exactly once at the very\r\nend.Your task is to find the path from the square to the square that\r\ntakes minimum time. Among all shortest paths you should choose the one.\r\nWhen comparing paths you should lexicographically represent them as a\r\nsequence of characters, that is, of plot types.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstruct point\n{\n    char h;\n    string res;\n    bool poss;\n};\n\n\npoint a[50][50];\nint n, m, k;\n\nstring res;\nvector <int> qx, qy;\nint step[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nvoid bfs()\n{\n    for(int i = 0; i < qx.size(); i++)\n    {\n        int x, y;\n        for(int j = 0; j < 4; j++)\n        {\n            x = qx[i] + step[j][0];\n            y = qy[i] + step[j][1];\n            if(x > -1  &&  y > -1  &&  x < n  &&  y < m  && a[x][y].poss)\n            {\n                if(a[x][y].res.size() == 0)\n                {\n                    qx.push_back(x);\n                    qy.push_back(y);\n                    a[x][y].res = a[qx[i]][qy[i]].res + a[x][y].h;\n                }\n                else\n                {\n                    if(a[x][y].res.size() == a[qx[i]][qy[i]].res.size() + 1  && a[x][y].res > a[qx[i]][qy[i]].res + a[x][y].h)\n                    {\n                         a[x][y].res = a[qx[i]][qy[i]].res + a[x][y].h;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nvector <char> temp, meeted;\nchar now[6];\nint startx, starty, fx, fy;\n\n\nvoid pere(int deep, int start)\n{\n    for(int i = start; i < meeted.size(); i++)\n    {\n        now[deep + 2] = meeted[i];\n        if(deep == k - 1)\n        {\n            qx.clear();\n            qy.clear();\n            qx.push_back(startx);\n            qy.push_back(starty);\n\n                    for(int ii = 0; ii < n; ii++)\n                        for(int jj = 0; jj < m; jj++)\n                        {\n                            a[ii][jj].res.clear();\n                            a[ii][jj].poss = false;\n                            for(int j = 0; j < k + 2; j++)\n                                if(a[ii][jj].h == now[j])   a[ii][jj].poss = true;\n                        }\n                    a[startx][starty].res = \"S\";\n            bfs();\n            if(a[fx][fy].res.size())\n            {\n                if(!res.size()  ||  res.size() > a[fx][fy].res.size()  ||  (a[fx][fy].res.size() == res.size()  &&  res > a[fx][fy].res))\n                    res = a[fx][fy].res;\n            }\n        }\n        else\n        {\n            pere(deep + 1, i + 1);\n        }\n    }\n}\n\n\nint main()\n{\n    cin >> n >> m >> k;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            cin >> a[i][j].h;\n            if(a[i][j].h == 'S')\n            {\n                startx = i;\n                starty = j;\n            }\n            if(a[i][j].h == 'T')\n            {\n                fx = i;\n                fy = j;\n            }\n            if(a[i][j].h >= 'a')\n                temp.push_back(a[i][j].h);\n        }\n    }\n\n    now[0] = 'S';\n    now[1] = 'T';\n    sort(temp.begin(), temp.end());\n    for(int i = 0; i < temp.size(); i++)\n    {\n        if(!i  ||  temp[i] != temp[i - 1])  meeted.push_back(temp[i]);\n    }\n    k = min(k, int(meeted.size()));\n    if(meeted.size() == 0)  return 0;\n    pere(0, 0);\n    if(res.size() == 0) cout << -1;\n    else\n    {\n        for(int i = 1; i < res.size() - 1; i++) cout << res[i];\n    }\n}\n"], "input": "", "output": "", "tags": ["brute force", "shortest paths"], "dificulty": "2400", "interactive": false}