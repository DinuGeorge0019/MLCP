{
    "link": "https://codeforces.com//contest/25/problem/D",
    "problemId": "117",
    "problem_idx": "D",
    "shortId": "25D",
    "contest_number": "25",
    "problem_submissions": {
        "E": [
            108305,
            107891,
            108459,
            109074,
            109171,
            109424,
            109005,
            109444,
            109356,
            110109,
            109944
        ],
        "D": [
            107815,
            107231,
            107893,
            107939,
            107979,
            108143,
            107913,
            108468,
            108112,
            108146,
            108477,
            108033,
            107622,
            108937,
            108395,
            108185,
            107746
        ],
        "C": [
            107542,
            107972,
            107666,
            109348,
            109330,
            109305,
            109284,
            107599,
            107695,
            109679,
            107814,
            107526,
            108085,
            109622,
            107856,
            107775,
            108767,
            108192,
            107976,
            107797,
            107728,
            107534
        ],
        "B": [
            107003,
            106875,
            107055,
            106850,
            107367,
            107390,
            107161,
            107267,
            107320,
            107286,
            107129,
            107361,
            106975,
            107251,
            107517,
            106925,
            106908
        ],
        "A": [
            106730,
            106739,
            106878,
            106704,
            106912,
            107216,
            106718,
            106909,
            107174,
            107012,
            106856,
            106840,
            106744,
            106943,
            106825,
            106728,
            106741
        ]
    },
    "name": "D. Roads not only in Berland",
    "statement": "Berland Government decided to improve relations with neighboring\r\ncountries. First of all, it was decided to build new roads so that from\r\neach city of Berland and neighboring countries it became possible to\r\nreach all the others. There are cities in Berland and neighboring\r\ncountries in total and exactly two-way roads. Because of the recent\r\nfinancial crisis, the Berland Government is strongly pressed for money,\r\nso to build a new road it has to close some of the existing ones. Every\r\nday it is possible to close one existing road and immediately build a\r\nnew one. Your task is to determine how many days would be needed to\r\nrebuild roads so that from each city it became possible to reach all the\r\nothers, and to draw a plan of closure of old roads and building of new\r\nones.\r\n",
    "solutions": [
        "#include <assert.h>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <list>\n#include <stack>\n#include <string.h>\n#include <stdlib.h>\n#include <vector>\n#include <utility>\n#include <list>\n#define INF 0x3fffffff\n#define LINF 0x3fffffffffffffffll\n#define DINF 1e100;\n\ntypedef long long ll;\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PDD pair<double, double>\n#define PIL pair<int, ll>\n#define PLI pair<ll, int>\n#define PID pair<int, double>\n#define PDI pair<double, int>\n#define PLD pair<ll, double>\n#define PDL pair<double, ll>\n\n#define NUL(x) memset(x, 0, sizeof(x))\n#define MINUS(x) memset(x, 0xff, sizeof(x))\n#define PQ(x) priority_queue< x >  //highest first\n#define PQR(x) priority_queue< x , vector< x > , greater < x > > //lowest first\n#define MP make_pair\n#define PB push_back\n#define IT(x) for (typeof((x).begin()) it = (x).begin() ; it != (x).end() ; it++)\n#define IT2(x) for (typeof((x).begin()) it2 = (x).begin() ; it2 != (x).end() ; it2++)\n#define FOR(i, a, b) for (int i = (a) ; i< (b) ; i++)\n#define DEB(x...) fprintf(stderr,x);\n//#define DEB\n\nusing namespace std;\n\n\n#define MAX 1005\nint par[MAX];\nint n;\nint find(int a)\n{\n  if (par[a]==a) return a;\n  par[a]=find(par[a]);\n  return par[a];\n}\nbool unio(int a, int b)\n{\n  if (find(a)==find(b)) return false;\n  if (rand()&1) par[find(a)]=par[find(b)];\n  else par[find(b)]=par[find(a)];\n  return true;\n}\n\n\nlist<PII> cl;\nint main()\n{\n  srand(123);\n  int a,b;\n  int t=0;\n  scanf(\"%i \", &n);\n  FOR(i,0,n) par[i]=i;\n  FOR(i,0,n-1)\n    {\n      scanf(\"%i %i \", &a, &b);\n      a--;b--;\n      if (!unio(a,b))\n\t{\n\t  cl.PB(MP(a,b));\n\t  t++;\n\t}\n    }\n  printf(\"%i\\n\",t);\n  FOR(i,1,n)\n    {\n      if (unio(0,i))\n\t{\n\t  printf(\"%i %i %i %i\\n\", cl.front().first+1, cl.front().second+1, 1, i+1);\n\t  t--;\n\t  cl.pop_front();\n\t}\n    }\n\n  /*\n    while(testc());\n  */\n  \n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Roads not only in Berland.json",
    "editorial_link": "https://codeforces.com//blog/entry/594",
    "editorial": "Initially, we are given a matrix D, where D[i][j] is the distance of shortest path between city i and city j. Suppose we build a new road between a and b with length shorter than D[a][b]. How do we update the rest of the graph accordingly?\n\nDefine a new matrix D', whose entries D'[i][j] are the minimum path distance between i and j while taking into account the new road ab. There are three possibilities for each i,?j:\nD'[i][j] remains unchanged by the new road. In this case D'[i][j]?=?D[i][j]\nD'[i][j] is shorter if we use the new road ab. This means that the new path i,?v1,?v2,?...,?vn,?j must include the road a,?b. If we connect the vertices i,?a,?b,?j together in a path, then our new distance will be D[i][a]?+?length(ab)?+?D[b][j].\nLastly, we may have to use the road ba. (Note that this may not be the same as road ab.) In this case, we have D'[i][j]?=?D[i][b]?+?length(ab)?+?D[a][j].\nThus, for each new road that we build, we must update each path i,?j within the graph. Then we must sum shortest distances between cities. Updating the matrix and summing the total distance are both O(N2), so about 3002 operations. Lastly, there are at most 300 roads, so in total there are about 3003 operations.\n\nOne thing to note is that the sum of all shortest distances between cities may be larger than an int; thus, we need to use a long when calculating the sum."
}