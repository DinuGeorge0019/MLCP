{
    "link": "https://codeforces.com//contest/1920/problem/F2",
    "problemId": "2424506",
    "problem_idx": "F2",
    "shortId": "1920F2",
    "contest_number": "1920",
    "problem_submissions": {
        "F2": [
            241519708,
            242461640,
            241499605,
            241499150,
            241499121,
            241526798,
            241677520,
            242000469
        ],
        "F1": [
            241460299,
            241470662,
            241472660,
            241471905,
            241452735,
            241475361,
            241451154,
            241473438,
            241479153,
            241478315,
            241484928,
            241465563,
            241477422,
            241477811,
            241688562,
            241479348,
            241481887,
            241485652,
            241484576,
            241481175
        ],
        "E": [
            241449808,
            241450749,
            250647629,
            250647603,
            250646809,
            241453536,
            241456702,
            241468503,
            241457240,
            241473848,
            241459615,
            241448891,
            241462905,
            241455611,
            241473828,
            241462340,
            241463447,
            241688611,
            241464804,
            241470317,
            241459879,
            241463678,
            241464099
        ],
        "D": [
            241440349,
            241444733,
            241443927,
            241444084,
            241461216,
            241445290,
            241465918,
            241452364,
            241443025,
            241445939,
            241448263,
            241452666,
            241453380,
            241452851,
            241446075,
            241446900,
            241450746,
            241452656,
            241457511
        ],
        "C": [
            241424760,
            241434849,
            241435347,
            241432571,
            241426106,
            241430363,
            241433735,
            241436246,
            241435590,
            241433210,
            241428829,
            241435049,
            241436115,
            241439877,
            241436063,
            241433607,
            241435067,
            241438107,
            241435335
        ],
        "B": [
            241420376,
            241425242,
            241428830,
            241429674,
            241419228,
            241425601,
            241423672,
            241427964,
            241426457,
            241429604,
            241423387,
            241427147,
            241430484,
            241428576,
            241428228,
            241423313,
            241427602,
            241429162,
            241430149
        ],
        "A": [
            241418935,
            241420574,
            241419051,
            241419262,
            241421587,
            241419112,
            241419031,
            241419259,
            241421308,
            241419216,
            241419840,
            241421070,
            241419328,
            241428462,
            241421467,
            241419238,
            241420328,
            241420339,
            241423810
        ]
    },
    "name": "F2. Smooth Sailing  Hard Version ",
    "statement": "Thomas is sailing around an island surrounded by the ocean. The ocean\r\nand island can be represented by a grid with n rows and m columns. The\r\nrows are numbered from 1 to n from top to bottom, and the columns are\r\nnumbered from 1 to m from left to right. The position of a cell at row r\r\nand column c can be represented as (r, c). Below is an example of a\r\nvalid grid. There are three types of cells: island, ocean and underwater\r\nvolcano. Cells representing the island are marked with a \u201d, cells\r\nrepresenting the ocean are marked with a \u201d, and cells representing an\r\nunderwater volcano are marked with a \u201d. It is guaranteed that there is\r\nat least one island cell and at least one underwater volcano cell. It is\r\nalso guaranteed that the set of all island cells forms a single\r\nconnected component^{\r\ndagger} and the set of all ocean cells and underwater volcano cells\r\nforms a single connected component. Additionally, it is guaranteed that\r\nthere are no island cells at the edge of the grid (that is, at row 1, at\r\nrow n, at column 1, and at column m).Define a starting from cell (x, y)\r\nas a path Thomas takes which satisfies the following conditions: The\r\npath starts and ends at (x, y). If Thomas is at cell (i, j), he can go\r\nto cells (i+1, j), (i-1, j), (i, j-1), and (i, j+1) as long as the\r\ndestination cell and is still inside the grid. Note that it is allowed\r\nfor Thomas to visit the same cell multiple times in the same round trip.\r\nThe path must go around the island and fully encircle it. Some path p\r\nfully encircles the island if it is impossible to go from an island cell\r\nto a cell on the grid border by only traveling cells without visiting a\r\ncell on path p. In the image below, the path starting from (2, 2), going\r\nto (1, 3), and going back to (2, 2) the other way does fully encircle\r\nthe island and is not considered a round trip. The of a round trip is\r\nthe minimum Manhattan distance^{\r\nddagger} from a cell on the round trip to an underwater volcano (note\r\nthat the presence of island cells does not impact this distance).You\r\nhave q queries. A query can be represented as (x, y) and for every\r\nquery, you want to find the maximum safety of a round trip starting from\r\n(x, y). It is guaranteed that (x, y) is an ocean cell or an underwater\r\nvolcano cell.^{\r\ndagger}A set of cells forms a single connected component if from any\r\ncell of this set it is possible to reach any other cell of this set by\r\nmoving only through the cells of this set, each time going to a cell .^{\r\nddagger}Manhattan distance between cells (r_1, c_1) and (r_2, c_2) is\r\nequal to |r_1 - r_2| + |c_1 - c_2|.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int dx[]={1, -1, 0, 0}, dy[]={0, 0, 1, -1};\nint n, m, Q, ix, iy;\n\nstruct DSU{\n   vector<int> lab;\n   void init(int _n){\n      lab.assign(_n+1, 0);\n   }\n   int get_idx(int x, int y, int z){\n      return ((x-1)*m+y)<<1|z;\n   }\n   int find_set(int u){\n      return lab[u]<0?u:lab[u]=find_set(lab[u]);\n   }\n   void union_sets(int u, int v){\n      u=find_set(u); v=find_set(v);\n      if (u!=v){\n         if (lab[u]>lab[v]) swap(u, v);\n         lab[u]+=lab[v];\n         lab[v]=u;\n         return;\n      }\n   }\n   void make_set(int x, int y, int z){\n      int i=get_idx(x, y, z);\n      lab[i]=-1;\n      for (int k=0; k<4; ++k){\n         int u=x+dx[k], v=y+dy[k];\n         if (u<1 || v<1 || u>n || v>m) continue;\n         int z2=z;\n         if (v<=iy && iy<y && x<=ix) z2^=1;\n         else if (y<=iy && iy<v && x<=ix) z2^=1;\n         int j=get_idx(u, v, z2);\n         if (lab[j]!=0){\n            union_sets(i, j);\n         }\n      }\n   }\n} dsu;\n\nconst int N=3e5+1;\npair<int, int> query[N];\nint ans[N], l[N], r[N];\nvector<int> v[N];\nvector<pair<int, int>> pos[N];\n\nvoid solve(){\n   cin >> n >> m >> Q;\n   vector<vector<char>> a(n+1, vector<char>(m+1));\n   vector<vector<int>> dist(n+1, vector<int>(m+1, -1));\n   queue<pair<int, int>> q;\n   for (int i=1; i<=n; ++i) for (int j=1; j<=m; ++j){\n      cin >> a[i][j];\n      if (a[i][j]=='#') ix=i, iy=j;\n      if (a[i][j]=='v'){\n         q.emplace(i, j);\n         dist[i][j]=0;\n      }\n   }\n   int mx=0;\n   while (q.size()){\n      int x=q.front().first, y=q.front().second;\n      q.pop();\n      for (int k=0; k<4; ++k){\n         int u=x+dx[k], v=y+dy[k];\n         if (u<1 || v<1 || u>n || v>m || dist[u][v]!=-1) continue;\n         dist[u][v]=dist[x][y]+1;\n         mx=max(mx, dist[u][v]);\n         q.emplace(u, v);\n      }\n   }\n   for (int i=1; i<=n; ++i) for (int j=1; j<=m; ++j) if (a[i][j]!='#') pos[dist[i][j]].emplace_back(i, j);\n   for (int i=1; i<=Q; ++i){\n      int x, y; cin >> x >> y;\n      query[i]={x, y};\n      l[i]=0; r[i]=dist[x][y];\n   }\n   for (int rep=0; rep<20; ++rep){\n      for (int i=1; i<=Q; ++i) v[(l[i]+r[i])/2].push_back(i);\n      dsu.init(n*m*2+1);\n      for (int d=mx; d>=0; --d){\n         for (auto &i:pos[d]) dsu.make_set(i.first, i.second, 0);\n         for (auto &i:pos[d]) dsu.make_set(i.first, i.second, 1);\n         for (auto &i:v[d]){\n            if (dsu.lab[dsu.get_idx(query[i].first, query[i].second, 0)]==0) r[i]=d-1;\n            else if (dsu.lab[dsu.get_idx(query[i].first, query[i].second, 1)]==0) r[i]=d-1;\n            else if (dsu.find_set(dsu.get_idx(query[i].first, query[i].second, 0))==dsu.find_set(dsu.get_idx(query[i].first, query[i].second, 1))){\n               l[i]=d+1;\n            }else{\n               r[i]=d-1;\n            }\n         }\n         v[d].clear();\n      }\n   }\n   for (int i=1; i<=Q; ++i) cout << r[i] << '\\n';\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   // cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dsu",
        "geometry",
        "graphs",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F2. Smooth Sailing  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/122560",
    "editorial": "SolutionIt\u00e2\u0080\u0099s basically similar idea as in the editorial. But... with a\r\nfew differences.First one: instead of parity, I\u00e2\u0080\u0099m using angles. I think\r\nyou can exchange those. So, in DSU I maintain for each node angle to its\r\nroot, if I walk there cell by cell in MST. Then, to check is there round\r\ntrip I check all cycles if total angle of circle > pi / 2. Why pi / 2?\r\nWell, I thought it\u00e2\u0080\u0099s enough :DSeocond one: why is the complexity\r\ndifferent? Well, each time I find a cycle I answer on all cells within\r\nthe component. Not taking into account are they listed in queries or\r\nnot. How do I keep list of cells within a component? I maintain other\r\ntree \u00e2\u0080\u0093 binary tree with new node added when two component joined, and\r\nthis node I have two children representing joined components. In this\r\nway I can use dfs to traverse all cells within component. And after I do\r\nit, I clear list of component cells, it\u00e2\u0080\u0099s same as marking component as\r\nhaving round trip. First I thought to make linked list, but I thought it\r\nwould be troublesome.So, complexity consists of: joins in DSU, which\r\nleads to and traversing components when cycle is found, which is .\r\nCalculating angles adds time for calculating arc sin, but you may\r\nconsider it as a constant. If you dislike it, you can use parity\r\napproach I guess.\r\n"
}