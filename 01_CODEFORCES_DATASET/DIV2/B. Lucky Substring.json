{
    "link": "https://codeforces.com//contest/122/problem/B",
    "problemId": "638",
    "problem_idx": "B",
    "shortId": "122B",
    "contest_number": "122",
    "problem_submissions": {
        "E": [
            804119,
            810208,
            803742,
            804906,
            805053,
            805535,
            805395,
            806278,
            806048,
            805630,
            806062,
            806110,
            807439,
            805646,
            806935,
            805348,
            805292,
            807148,
            803308
        ],
        "D": [
            802482,
            810206,
            802395,
            802956,
            803158,
            802902,
            802962,
            803118,
            803510,
            803885,
            803728,
            803980,
            803776,
            806452,
            804671,
            807608,
            806313,
            807465,
            804059,
            807952
        ],
        "C": [
            800923,
            810203,
            801356,
            801235,
            801284,
            802077,
            801764,
            801779,
            801639,
            801891,
            801899,
            801697,
            801979,
            801645,
            801654,
            802889,
            808508,
            803366,
            802586,
            801728
        ],
        "B": [
            799762,
            810199,
            799636,
            800167,
            799922,
            800682,
            800298,
            799652,
            799602,
            800265,
            800137,
            800018,
            800096,
            799947,
            799741,
            801185,
            801074,
            799786,
            801520
        ],
        "A": [
            799077,
            810197,
            799191,
            799050,
            799146,
            799438,
            799389,
            799108,
            799052,
            799014,
            799373,
            799207,
            799220,
            799284,
            799168,
            799106,
            799481,
            799192,
            799054
        ]
    },
    "name": "B. Lucky Substring",
    "statement": "One day Petya was delivered a string , containing only digits. He needs\r\nto find a string that represents a lucky number without leading zeroes,\r\nis not empty, is contained in as a substring the maximum number of\r\ntimes.Among all the strings for which the three conditions given above\r\nare fulfilled, Petya only needs the lexicographically minimum one. Find\r\nthis string for Petya.\r\n",
    "solutions": [
        "#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <string> vs;\ntypedef istringstream iss;\ntypedef ostringstream oss;\n\nconst int INF = (int) 1E9 + 5;\nconst ll LINF = (ll) 4E18 + 5;\n\nconst ld PI = acos(-1.0);\nconst ld E = 2.718281828459045L;\n\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define FORD(i, a, b) for (int i = (a); i >= (b); i--)\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define REPD(i, a) for (int i = ((a) - 1); i >= 0; i--)\n#define FIT(it, v) for (typeof((v).begin())it = (v).begin(); it != (v).end(); ++it)\n#define FITD(it, v) for (typeof((v).rbegin())it = (v).rbegin(); it != (v).rend(); ++it)\n\n#define VAR(a, b) typeof(b) a(b)\n#define ALL(v) (v).begin(), (v).end()\n#define SET(a, x) memset((a), (x), sizeof(a))\n#define SIZE(a) ((int)(a).size())\n\n#define EXIST(a, b) (find(ALL(a), (b)) != (a).end())\n#define SORT(x) sort(ALL(x))\n#define GSORT(x) sort(ALL(x), greater<typeof(*((x).begin()))>())\n#define UNIQUE(v) SORT(v); (v).resize(unique(ALL(v)) - (v).begin())\n#define ENUM(v) FIT(it, (v)) cout << *it << \" \"; cout << endl\n\n#define PF push_front\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n\ntemplate<typename T> T gcd(T a, T b) { return (b == 0) ? abs(a) : gcd(b, a % b); }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> inline T mod(T a, T b) { return (a % b + b) % b; }\ntemplate<typename T> inline T sqr(T x) { return x * x; }\n\ntemplate<typename T> inline string toString(const T& x) { oss os; os << x; return os.str(); }\ninline ll toInt(const string& s) { iss is(s); ll x; is >> x; return x; }\ninline ld toDouble(const string& s) { iss is(s); ld x; is >> x; return x; }\ninline string toLower(string s) { FIT(it, s) *it = tolower(*it); return s; }\ninline string toUpper(string s) { FIT(it, s) *it = toupper(*it); return s; }\n\nconst char DEBUG_PARAM[] = \"__LOCAL_TESTING\";\n\nconst char IN[] = \"_.in\";\nconst char OUT[] = \"_.out\";\n\ninline void init();\ninline void run();\n\nint ntest = 0, test;\n\nint main(int argc, char* argv[]) {\n\tif (argc > 1 && strcmp(argv[1], DEBUG_PARAM) == 0) {\n\t\tfreopen(IN, \"r\", stdin);\n\t\t//freopen(OUT, \"w\", stdout);\n\t}\n\tinit();\n\tif (ntest == 0) { puts(\"ntest = ?\"); return 0; }\n\tfor (test = 1; test <= ntest; test++) {\n\t\trun();\n\t}\n\treturn 0;\n}\n\ninline void stop() {\n\tntest = test - 1;\n}\n\n/* IMPLEMENTATION */\n\nconst int dx[] = { -1, 0, 0, 1 };\nconst int dy[] = { 0, -1, 1, 0 };\n\nconst ld EPS = 1E-9;\nconst ll MODULE = 1000000007LL;\n\ninline void init() {\n\tntest = 1;\n}\n\nbool isLucky(string s) {\n\tFIT(it, s) {\n\t\tif (*it != '4' && *it != '7') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ninline void run() {\n\tstring s;\n\tcin >> s;\n\tint MAX = 0;\n\tstring ret = \"\";\n\tREP(i, SIZE(s)) {\n\t\tFOR(j, i, SIZE(s) - 1) {\n\t\t\tstring t = s.substr(i, j - i + 1);\n\t\t\tif (isLucky(t)) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(start, SIZE(s)) {\n\t\t\t\t\tif (start + SIZE(t) <= SIZE(s)\n\t\t\t\t\t\t\t&& s.substr(start, SIZE(t)) == t) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt > MAX) {\n\t\t\t\t\tMAX = cnt;\n\t\t\t\t\tret = t;\n\t\t\t\t} else if (cnt == MAX) {\n\t\t\t\t\tret = min(ret, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (MAX > 0) {\n\t\tcout << ret << endl;\n\t} else {\n\t\tcout << -1 << endl;\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Lucky Substring.json",
    "editorial_link": "https://codeforces.com//blog/entry/2956",
    "editorial": "Notice, that answer is either one digit or -1. So, if there are no 4 and 7 digits, then answer is -1. Else, if there is more or equel number of digits 4, then answer is 4, else answer is 7."
}