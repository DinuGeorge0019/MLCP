{
    "link": "https://codeforces.com//contest/1925/problem/E",
    "problemId": "2447855",
    "problem_idx": "E",
    "shortId": "1925E",
    "contest_number": "1925",
    "problem_submissions": {
        "F": [
            243635672,
            243648922,
            243652277,
            243654463,
            243696386
        ],
        "E": [
            243616564,
            243621263,
            243626621,
            243628373,
            243642423,
            243636417,
            243643693,
            243633557,
            243638778,
            243637771,
            243645710,
            243648841,
            243629267,
            243713101,
            243632960,
            243654973,
            243648168,
            243647861,
            243652611,
            243647183,
            243650906
        ],
        "D": [
            243592234,
            243594869,
            243599958,
            243596486,
            243624513,
            243610640,
            243600801,
            243608352,
            243605500,
            243665895,
            243608581,
            243587140,
            243614894,
            243606314,
            243649266,
            243604378,
            243609277,
            243609750,
            243623206,
            243609456,
            249399690,
            243606073
        ],
        "C": [
            243570353,
            243577698,
            243576709,
            243576761,
            243588406,
            243564488,
            243578879,
            243585269,
            243576848,
            243595639,
            243608536,
            243585312,
            243573744,
            243571216,
            243580792,
            243582138,
            243591440,
            243576695,
            243587225,
            249717100,
            243587500
        ],
        "B": [
            243565143,
            243557943,
            243563278,
            243563287,
            243557566,
            243563680,
            243568156,
            243559337,
            243561416,
            243559345,
            243566711,
            243558705,
            243561296,
            243561403,
            243570584,
            243570498,
            243563900,
            243563678,
            243565505
        ],
        "A": [
            243556584,
            243556225,
            243557446,
            243557520,
            243556082,
            243557771,
            243560727,
            243556392,
            243556560,
            243556879,
            243556644,
            243556058,
            243556214,
            243556452,
            243557610,
            243558322,
            243556372,
            243556420,
            243556133
        ]
    },
    "name": "E. Space Harbour",
    "statement": "There are n points numbered 1 to n on a straight line. Initially, there\r\nare m harbours. The i-th harbour is at point X_i and has a value V_i.\r\nThere is exactly one ship on each of the n points. The cost of moving a\r\nship from its current location to the next harbour is the product of the\r\nvalue of the nearest harbour to its left and the distance from the\r\nnearest harbour to its right. Specifically, if a ship is already at a\r\nharbour, the cost of moving it to the next harbour is 0. Additionally,\r\nthere are q queries, each of which is either of the following 2 types: 1\r\nx v Add a harbour at point x with value v. It is guaranteed that before\r\nadding the harbour, there is no harbour at point x. 2 l r Print the sum\r\nof the cost of moving all ships at points from l to r to their next\r\nharbours.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cassert>\n\nusing namespace std;\n\nbool __hack = ios::sync_with_stdio(false);\nauto __hack1 = cin.tie(nullptr);\n\ntemplate<typename T>\nT next() {\n    T x;\n    cin >> x;\n    return x;\n}\n\nint64_t sum2(int64_t n) {\n    return n * (n - 1) / 2;\n}\n\nstruct Segment {\n    int l, r;\n    int val;\n\n    Segment(): l(0), r(0), val(0) {\n    }\n\n    Segment(int l, int r, int val) : l(l), r(r), val(val) {\n    }\n\n    int64_t eval(int64_t L, int64_t R) {\n        if (val == 0) {\n            return 0;\n        }\n        assert(l < L && R <= r + 1);\n        int64_t ret = 0;\n        // for (int i = L; i < R; ++i) {\n        //     ret += int64_t(val) * (r - i);\n        // }\n        ret = int64_t(val) * ((R - L) * r - (sum2(R) - sum2(L)));\n        return ret;\n    }\n};\n\nstruct SegmentTree {\n    vector<int64_t> tree_sum;\n    vector<Segment> tree_assign;\n    int size;\n\n    SegmentTree(int n) : size(1) {\n        while (size < n) {\n            size *= 2;\n        }\n        tree_sum.resize(2 * size - 1, 0);\n        tree_assign.resize(2 * size - 1);\n    }\n\n    void assign(int l, int r, Segment s) {\n        // cerr << \"assign \" << l << \" \" << r << \" (\" << s.l << \", \" << s.r << \", \" << s.val << \")\\n\";\n        assign(l, r, s, 0, 0, size);\n    }\n    \n    int64_t assign(int l, int r, Segment s, int ti, int tl, int tr) {\n        if (l <= tl && tr <= r) {\n            tree_assign[ti] = s;\n            return tree_sum[ti] = s.eval(tl, tr);\n        }\n        if (r <= tl || tr <= l) {\n            return tree_sum[ti];\n        }\n        int tm = (tl + tr) / 2;\n        if (tree_assign[ti].val != 0) {\n            Segment push_down = tree_assign[ti];\n            tree_assign[ti * 2 + 1] = push_down;\n            tree_sum[ti * 2 + 1] = push_down.eval(tl, tm);\n            tree_assign[ti * 2 + 2] = push_down;\n            tree_sum[ti * 2 + 2] = push_down.eval(tm, tr);\n            tree_assign[ti] = Segment();\n        }\n        return tree_sum[ti] = assign(l, r, s, ti * 2 + 1, tl, tm) + assign(l, r, s, ti * 2 + 2, tm, tr);\n    }\n\n    int64_t query(int l, int r) {\n        // cerr << \"query \" << l << \" \" << r << '\\n';\n        return query(l, r, 0, 0, size);\n    }\n\n    int64_t query(int l, int r, int ti, int tl, int tr) {\n        if (l <= tl && tr <= r) {\n            return tree_sum[ti];\n        }\n        if (r <= tl || tr <= l) {\n            return 0;\n        }\n        if (tree_assign[ti].val != 0) {\n            return tree_assign[ti].eval(max(l, tl), min(r, tr));\n        }\n        int tm = (tl + tr) / 2;\n        return query(l, r, ti * 2 + 1, tl, tm) + query(l, r, ti * 2 + 2, tm, tr);\n    }\n};\n\nint main() {\n    int n = next<int>();\n    int m = next<int>();\n    int q = next<int>();\n    SegmentTree tree(n + 1);\n    vector<pair<int, int>> beacons(m);\n    for (int i = 0; i < m; ++i) {\n        beacons[i].first = next<int>();\n    }\n    for (int i = 0; i < m; ++i) {\n        beacons[i].second = next<int>();\n    }\n    sort(beacons.begin(), beacons.end());\n    for (int i = 0; i < m - 1; ++i) {\n        tree.assign(beacons[i].first + 1, beacons[i + 1].first + 1, Segment(beacons[i].first, beacons[i + 1].first, beacons[i].second));\n    }\n    set<pair<int, int>> beacon_set;\n    for (int i = 0; i < m; ++i) {\n        beacon_set.insert(beacons[i]);\n    }\n    for (int i = 0; i < q; ++i) {\n        int t = next<int>();\n        if (t == 1) {\n            int x = next<int>();\n            int v = next<int>();\n            auto beacon = make_pair(x, v);\n            auto next_beacon = beacon_set.lower_bound(beacon);\n            auto prev_beacon = next_beacon;\n            prev_beacon--;\n            tree.assign(prev_beacon->first + 1, beacon.first + 1, Segment(prev_beacon->first, beacon.first, prev_beacon->second));\n            tree.assign(beacon.first + 1, next_beacon->first + 1, Segment(beacon.first, next_beacon->first, beacon.second));\n            beacon_set.insert(beacon);\n        } else {\n            int l = next<int>();\n            int r = next<int>();\n            cout << tree.query(l, r + 1) << '\\n';\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Space Harbour.json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "We can maintain a segment tree of size n\n which initially stores the cost of all the ships.\n\nNow there are 2 types of updates when we add an harbour:\n\nThe ships to the left of the new harbour have their cost decreased by a fixed amount.\nThe ships to the right of the harbour have their cost changed by the value equivalent to product of distance from the harbour on their right (which remains unchanged) and the difference in values of the previous and new harbour to their left.\nExample of updates\nThere are multiple ways to handle both the updates simultaneously, a simple way would be to use a struct simulating an arithmetic progression. It can contain two values\n\nBase: Simply a value which has to be added to all values belonging to the segment.\nDifference: For each node of the segment, dif\u00d7dist\n will be added to the node, where dist\n is the distance of node from the end of the segment.\nUsing summation of arithmetic progression we can make sure that the updates on Difference can be applied to an entire segment lazily. You can see the code for more details."
}