{
    "link": "https://codeforces.com//contest/745/problem/C",
    "problemId": "85236",
    "problem_idx": "C",
    "shortId": "745C",
    "contest_number": "745",
    "problem_submissions": {
        "D": [
            23063628,
            23061434,
            23062278,
            23062946,
            23063952,
            23062953,
            23063684,
            23065227,
            23067508,
            23064054,
            23066325,
            23064778,
            23065417,
            23065640,
            23065940,
            23064035,
            23066189,
            23064933,
            23065850
        ],
        "C": [
            23058754,
            23056208,
            23058146,
            23057537,
            23056194,
            23058075,
            23057431,
            23056700,
            23056696,
            23059037,
            23057208,
            23057100,
            23059888,
            23057785,
            23058711,
            23057786,
            23057804,
            23058775,
            23060465,
            23060269
        ],
        "B": [
            23054534,
            23053936,
            23055906,
            23053616,
            23057561,
            59539483,
            23055581,
            23054327,
            23058797,
            23055722,
            23054071,
            23052962,
            23055965,
            23054973,
            23055010,
            23060679,
            23060284,
            23055704,
            23055472,
            23055306
        ],
        "A": [
            23052643,
            23052117,
            23054108,
            23052198,
            23052470,
            23052835,
            23052386,
            23052148,
            23052356,
            23052891,
            23052103,
            23052050,
            23052345,
            23052453,
            23052723,
            23054138,
            23052447,
            23052434
        ],
        "E": [
            23177019,
            25241753,
            23067030,
            23140409
        ]
    },
    "name": "C. Hongcow Builds A Nation",
    "statement": "Hongcow is ruler of the world. As ruler of the world, he wants to make\r\nit easier for people to travel by road within their own countries.The\r\nworld can be modeled as an undirected graph with nodes and edges. of the\r\nnodes are home to the governments of the countries that make up the\r\nworld.There is at most one edge connecting any two nodes and no edge\r\nconnects a node to itself. Furthermore, for any two nodes corresponding\r\nto governments, . Any graph that satisfies all of these conditions is\r\n.Hongcow wants to add as many edges as possible to the graph while\r\nkeeping it stable. Determine the maximum number of edges Hongcow can\r\nadd.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define FORU(i,j,k) for(int i=(j);i<=(k);++i)\n#define FORD(i,j,k) for(int i=(j);i>=(k);--i)\n\nusing namespace std;\n\nusing lli = long long int;\nusing pll = pair<lli, lli>;\n\nconst long long int oo = 1000*1000*1000;\n\nstruct Coord\n{\n\tint x, y;\n\tCoord(int x = 0, int y = 0) : x(x), y(y) {}\n\tCoord operator + (const Coord& droite) const\n\t{\n\t\treturn Coord(x + droite.x, y + droite.y);\n\t}\n};\n\nint compo[1042];\nint taille[1042];\nbool gov[1042];\nvector<int> graph[1042];\n\nint dfs(int noeud, int repr)\n{\n\tif(compo[noeud])\n\t\treturn 0;\n\tcompo[noeud] = repr;\n\tint r = 1;\n\tfor(auto v : graph[noeud])\n\t\tr += dfs(v, repr);\n\treturn r;\n}\n\nint main()\n{\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tFOR(i, k)\n\t{\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tgov[tmp-1] = true;\n\t}\n\tFOR(i, m)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a; --b;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\tFOR(i, n)\n\t\tif(gov[i])\n\t\t\ttaille[i] = dfs(i, i+1);\n\tFOR(i, n)\n\t\tif(!compo[i])\n\t\t\ttaille[i] = dfs(i, i+1);\n\tint maxi = 0;\n\tint r = 0;\n\tFOR(i, n)\n\t\tif(gov[i])\n\t\t\tmaxi = max(maxi, taille[i]);\n\tint libr = 0;\n\tint dejaP = 0;\n\tFOR(i, n)\n\t\tif(taille[i])\n\t\t{\n\t\t\tint nbA = 0;\n\t\t\tFOR(j, n)\n\t\t\t\tif(compo[j] == i+1)\n\t\t\t\t\tnbA += graph[j].size();\n\t\t\tnbA /= 2;\n\t\t\tif(gov[i])\n\t\t\t\tr += taille[i] * (taille[i]-1) / 2 - nbA;\n\t\t\tif(!gov[i])\n\t\t\t{\n\t\t\t\tlibr += taille[i];\n\t\t\t\tdejaP += nbA;\n\t\t\t}\n\t\t}\n\tr += libr * (libr - 1) / 2 - dejaP;\n\tr += maxi * libr;\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Hongcow Builds A Nation.json",
    "editorial_link": "https://codeforces.com//blog/entry/49126",
    "editorial": "First, let's make all connected components cliques. This graph is still stable.\n\nNow, there are some components without special nodes. Where should we connect them?\n\nIf there is a component with size A and a component with size B, we can add A*B edges if we connect these two components. So, it makes sense to choose the largest component."
}