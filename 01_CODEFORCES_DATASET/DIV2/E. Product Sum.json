{"link": "https://codeforces.com//contest/631/problem/E", "problemId": "50476", "problem_idx": "E", "shortId": "631E", "contest_number": "631", "problem_submissions": {"D": [16497522, 16499633, 16493773, 16494892, 16499612, 16496131, 16500541, 16496189, 16496051, 16496096, 16496795, 16496029, 16497137, 16492337, 16499122, 16499237, 16493359, 16497887], "B": [16495030, 16489061, 16486659, 16487643, 16488029, 16489630, 16489917, 16489099, 16489411, 16488403, 16487977, 16488126, 16487679, 16488914, 16488419, 16487198, 16487289, 16490683, 16488019, 16489321], "A": [16494676, 16486534, 16486041, 16486092, 16486307, 16490385, 16486724, 16487325, 16488701, 16486887, 16486812, 16486989, 16486391, 16488010, 16486032, 16486094, 16486005, 16486116, 16486446, 16486353], "E": [16494439, 16497634, 16498079, 16498605, 16510405, 16640523, 34966720], "C": [16487628, 16491468, 16495480, 16491148, 16494024, 16488408, 16494546, 16492668, 16492714, 16493264, 16490967, 16493139, 16492497, 16492510, 16493001, 16497861, 16491052, 16495036, 16496778, 16492352]}, "name": "E. Product Sum", "statement": "Blake is the boss of Kris, however, this doesn\u2019t spoil their friendship.\r\nThey often gather at the bar to talk about intriguing problems about\r\nmaximising some values. This time the problem is really special.You are\r\ngiven an array of length . The of this array is the value the sum of the\r\nproducts of the values by . One may perform the following operation :\r\npick some element of the array and move to any position. In particular,\r\nit\u2019s allowed to move the element to the beginning or to the end of the\r\narray. Also, it\u2019s allowed to put it back to the initial position. The\r\ngoal is to get the array with the maximum possible value of\r\ncharacteristic.\r\n", "solutions": ["#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 200011;\ntypedef long long intl;\n\nintl a[N];\nintl sum[N];\n\nintl dp[N];\n\n#define x first\n#define y second\npair <intl, intl> sta[N];\n\nintl cross(pair <intl, intl> lhs, pair <intl, intl> rhs)\n{\n\treturn lhs.x * rhs.y - lhs.y * rhs.x;\n}\npair <intl, intl> sub(pair <intl, intl> lhs, pair <intl, intl> rhs)\n{\n\treturn {lhs.x - rhs.x, lhs.y - rhs.y};\n}\n\nintl calc(intl k, int n)\n{\n\treturn -k * sta[n].x + sta[n].y;\n}\n\nintl solve(intl k, int n)\n{\n\tint left = 0, right = n;\n\twhile(left + 1 < right)\n\t{\n\t\tint mid = (left + right) / 2;\n\t\tif(calc(k, mid) >= calc(k, mid - 1))\n\t\t\tleft = mid;\n\t\telse\n\t\t\tright = mid;\n\t}\n\treturn calc(k, left);\n}\n\nint main()\n{\n\tios :: sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tintl offset = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tcin >> a[i];\n\t\toffset += a[i] * i;\n\t\tsum[i] = sum[i - 1] + a[i];\n\t}\n\tif(n == 1)\n\t{\n\t\tcout << offset << '\\n';\n\t\treturn 0;\n\t}\n\tfill(dp + 1, dp + n + 1, -1e18);\n\tint top = 0;\n\tsta[top ++] = {n, -sum[n]};\n\tfor(int i = n - 1; i >= 1; i --)\n\t{\n\t\tdp[i] = max(dp[i], solve(-a[i], top) + sum[i] - i * a[i]);\n\t\twhile(top >= 2 && cross(sub({i, -sum[i]}, sta[top - 1]),\n\t\t\tsub(sta[top - 1], sta[top - 2])) >= 0)\n\t\t\ttop --;\n\t\tsta[top ++] = {i, -sum[i]};\n\t}\n\t\n\ttop = 0;\n\tsta[top ++] = {1, 0};\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tdp[i] = max(dp[i], solve(-a[i], top) + sum[i - 1] - i * a[i]);\n\t\twhile(top >= 2 && cross(sub({i, -sum[i - 1]}, sta[top - 1]),\n\t\t\tsub(sta[top - 1], sta[top - 2])) <= 0)\n\t\t\ttop --;\n\t\tsta[top ++] = {i, -sum[i - 1]};\n\t}\n\n\tintl ans = offset;\n\tfor(int i = 1; i <= n; i ++)\n\t\tans = max(ans, dp[i] + offset);\n\tcout << ans << '\\n';\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "geometry"], "dificulty": "2600", "interactive": false}