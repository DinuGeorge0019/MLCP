{
    "link": "https://codeforces.com//contest/1315/problem/F",
    "problemId": "547047",
    "problem_idx": "F",
    "shortId": "1315F",
    "contest_number": "1315",
    "problem_submissions": {
        "E": [
            71717972,
            71722121,
            71723928,
            71729230,
            71974152,
            72008868,
            72008805
        ],
        "B": [
            71712835,
            71705609,
            71705328,
            71705471,
            71703387,
            71704005,
            71704127,
            71704155,
            71704023,
            71705610,
            71706151,
            71706053,
            71706193,
            71704779,
            71704406,
            71705432,
            71705176,
            71707656,
            71704939
        ],
        "A": [
            71711680,
            71703327,
            71702875,
            71702517,
            71702293,
            71702355,
            71702415,
            71702704,
            71703705,
            71703020,
            71702906,
            71703383,
            71703894,
            71702683,
            71702739,
            71702868,
            71702438,
            71703823,
            71702490
        ],
        "D": [
            71705281,
            71711782,
            71710689,
            71709097,
            71706684,
            71712045,
            71709367,
            71709685,
            71709559,
            71709699,
            71712591,
            71718977,
            71710420,
            71711447,
            71712487,
            71711123,
            71711486,
            71711635,
            71712415
        ],
        "C": [
            71703583,
            71708130,
            71708191,
            71706924,
            71704462,
            71705381,
            71706364,
            71706633,
            71705353,
            71706839,
            71709056,
            71708876,
            71707615,
            71706977,
            71706123,
            71708378,
            71708224,
            71705852,
            71707083
        ],
        "F": [
            71735158,
            71754645,
            71744524,
            71744441
        ]
    },
    "name": "F. Au Pont Rouge",
    "statement": "VK just opened its second HQ in St. Petersburg! Side of its office\r\nbuilding has a huge string s written on its side. This part of the\r\noffice is supposed to be split into m meeting rooms in such way that\r\nmeeting room walls are strictly between letters on the building.\r\nObviously, meeting rooms should not be of size 0, but can be as small as\r\none letter wide. Each meeting room will be named after the substring of\r\ns written on its side.For each possible arrangement of m meeting rooms\r\nwe ordered a test meeting room label for the meeting room with\r\nlexicographically name. When delivered, those labels got sorted\r\nlexicographically.What is printed on kth label of the delivery?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int MOD = 1000 * 1000 * 1000 + 7;\nconstexpr int ALPHABET_SIZE = 26;\nconstexpr ll INF = 1e18;\n\nbool check(const string& s, ll k, vector<vector<ll>>& dp, vector<int>& cont, const string& cand, int m) {\n    int n = s.length(), l = cand.length();\n    if (n < l) {\n        return false;\n    }\n    for (int i = 0; i < n; ++i) {\n        int pos = i;\n        while (pos < n && pos - i < l && s[pos] == cand[pos - i]) {\n            ++pos;\n        }\n        if ((pos < n && pos - i < l && s[pos] < cand[pos - i]) || (pos == n && pos - i < l)) {\n            cont[i] = -1;\n        }\n        else if (pos == n || pos - i == l) {\n            cont[i] = pos;\n        }\n        else {\n            cont[i] = pos + 1;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        dp[i].assign(m, 0);\n    }\n\n    if (cont[0] != -1) {\n        dp[cont[0] - 1][0] = 1;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < m; ++j) {\n            dp[i + 1][j] = min(k, dp[i][j] + dp[i + 1][j]);\n        }\n        if (cont[i + 1] == -1) {\n            continue;\n        }\n        for (int j = 0; j + 1 < m; ++j) {\n            dp[cont[i + 1] - 1][j + 1] = min(k, dp[cont[i + 1] - 1][j + 1] + dp[i][j]);\n        }\n    }\n\n    return dp[n -1][m - 1] > 0 && dp[n - 1][m - 1] >= k;\n}\n\nstruct TreeNode {\n    int have = 0;\n    int interm = 0;\n    array<int, ALPHABET_SIZE> nxt{};\n};\n\nstring find_in_trie(const vector<TreeNode>& trie, int ind) {\n    string ans;\n    int have = 0;\n    int cur = 0;\n    while (cur != -1) {\n        if (have + trie[cur].interm > ind) {\n            return ans;\n        }\n        have += trie[cur].interm;\n        for (int i = 0; i < ALPHABET_SIZE; ++i) {\n            int nxt = trie[cur].nxt[i];\n            if (nxt == -1) {\n                continue;\n            }\n            if (have + trie[nxt].have > ind) {\n                ans.push_back('a' + i);\n                cur = nxt;\n                break;\n            }\n            else {\n                have += trie[nxt].have;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n\n    int n, m;\n    ll k;\n    cin >> n >> m >> k;\n    string s;\n    cin >> s;\n\n    vector<vector<ll>> dp(n, vector<ll>(m));\n    vector<int> cont(n);\n\n    vector<TreeNode> nodes;\n    nodes.emplace_back();\n    nodes.back().nxt.fill(-1);\n\n    for (int i = 0; i < n; ++i) {\n        int cur = 0;\n        nodes[0].have += n - i;\n        for (int j = i; j < n; ++j) {\n            if (nodes[cur].nxt[s[j] - 'a'] == -1) {\n                nodes[cur].nxt[s[j] - 'a'] = nodes.size();\n                nodes.emplace_back();\n                nodes.back().nxt.fill(-1);\n            }\n            cur = nodes[cur].nxt[s[j] - 'a'];\n            nodes[cur].have += n - j;\n            ++nodes[cur].interm;\n        }\n    }\n\n    int st = 0, e = (n * n + n) / 2;\n    while (e - st > 1) {\n        int mid = (st + e) / 2;\n\n        string cand = find_in_trie(nodes, mid);\n\n        if (check(s, k, dp, cont, cand, m)) {\n            st = mid;\n        }\n        else {\n            e = mid;\n        }\n    }\n\n    cout << find_in_trie(nodes, st) << \"\\n\";\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Au Pont Rouge.json",
    "editorial_link": "https://codeforces.com//blog/entry/74214",
    "editorial": "Let's list all distinct substrings, sort them and make a binary search. Now, we need to count number of ways to make minimal string no more then given one. Let's count inverse value  number of wat to make minimal string greater. It could be done by quadratic dynamic programming dppos,count\n  number of ways to split suffix starting at pos to count string all of which are greater then given value. Let's find first position where suffix differs which given string. If next character in suffix is smaller, no part can start here and answer is zero. Otherwise, any longer part is acceptable, so we need to find ?i>lcp(S,s[pos:])dpi,count?1\n, which can be done in O(1) time by suffix sums and precalculating lcp for all pairs of suffixes. Later can by done by another quadratic dynamic programming. lcp of two suffix is equal to 0 if first letter differs, and equal to lcp of two smaller suffixes +1 otherwise.",
    "hint": []
}