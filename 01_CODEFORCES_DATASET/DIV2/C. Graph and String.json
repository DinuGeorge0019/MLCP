{
    "link": "https://codeforces.com//contest/624/problem/C",
    "problemId": "47308",
    "problem_idx": "C",
    "shortId": "624C",
    "contest_number": "624",
    "problem_submissions": {
        "D": [
            15806940,
            15809834,
            15815500,
            15815488,
            15808308,
            15806499,
            15822402,
            15822389
        ],
        "C": [
            15799916,
            15800393,
            15799101,
            15798526,
            15798053,
            15812078,
            15803640,
            15799590,
            15811141,
            15805884,
            15804773,
            15807212,
            15803919,
            15798110,
            15802924,
            15800928,
            15805592
        ],
        "B": [
            15793209,
            15795799,
            15793505,
            15792793,
            15792808,
            15793962,
            15793304,
            15801141,
            15793770,
            15794743,
            15794904,
            15792647,
            15795417,
            15795148,
            15800662,
            15793795,
            15793891,
            15802098
        ],
        "A": [
            15791761,
            15792375,
            15792429,
            15819369,
            15791753,
            15791811,
            15792573,
            15791726,
            15792066,
            15792762,
            15792462,
            15791748,
            15792983,
            15792030,
            15791890,
            15791871,
            15791850,
            15792535
        ],
        "E": [
            15845804,
            15845576,
            15805460
        ]
    },
    "name": "C. Graph and String",
    "statement": "One day student Vasya was sitting on a lecture and mentioned a string ,\r\nconsisting of letters \"\", \"\" and \"\" that was written on his desk. As the\r\nlecture was boring, Vasya decided to complete the picture by composing a\r\ngraph with the following properties: has exactly vertices, numbered from\r\nto . For all pairs of vertices and , where , there is an edge connecting\r\nthem characters and are either equal or neighbouring in the alphabet.\r\nThat is, letters in pairs \"\"-\"\" and \"\"-\"\" are neighbouring, while\r\nletters \"\"-\"\" are not. Vasya painted the resulting graph near the string\r\nand then erased the string. Next day Vasya\u2019s friend Petya came to a\r\nlecture and found some graph at his desk. He had heard of Vasya\u2019s\r\nadventure and now he wants to find out whether it could be the original\r\ngraph , painted by Vasya. In order to verify this, Petya needs to know\r\nwhether there exists a string , such that if Vasya used this he would\r\nproduce the given graph .\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\nusing namespace std;\n\nconst int maxn=605;\nint n,m;\nbool e[maxn][maxn];\nvector<int>edge[maxn];\nint vis[maxn];\n\nbool dfs(int x, int c) {\n\tif (vis[x]!=-1) {\n\t\tif (vis[x]==c) return true;\n\t\tif (vis[x]!=c) return false;\n\t}\n\tvis[x]=c;\n\tfor (int y:edge[x]) \n\t\tif (!dfs(y, 2-c)) return false;\n\treturn true;\n}\n\nint main()  {\n\tscanf(\"%d%d\",&n,&m);\n\tmemset(e,0,sizeof e);\n\tfor (int i=1;i<=n;i++) edge[i].clear();\n\tfor (int i=1;i<=m;i++) {\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[a][b]=e[b][a]=true;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i!=j&&!e[i][j]) {\n\t\t\t\tedge[i].push_back(j);\n\t\t\t}\n\tfor (int i=1;i<=n;i++) vis[i]=-1;\n\n\tint cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (vis[i]==-1) {\n\t\t\tif ((int)edge[i].size() == 0) {\n\t\t\t\t//single\n\t\t\t\tvis[i] = 1;\n\t\t\t}else {\n\t\t\t\tcnt ++;\t\n\t\t\t\tif (!dfs(i, 0)) {\n\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i!=j) {\n\t\t\t\tbool sh=1;\n\t\t\t\tif (vis[i]==0&&vis[j]==2) sh=0;\n\t\t\t\tif (vis[i]==2&&vis[j]==0) sh=0;\n\t\t\t\tif (e[i][j]!=sh) {\n\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"Yes\\n\");\n\tfor (int i=1;i<=n;i++)\n\t\tprintf(\"%c\", vis[i]+'a');\n\tprintf(\"\\n\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Graph and String.json",
    "editorial_link": "https://codeforces.com//blog/entry/23278",
    "editorial": "I checked for any unconnected edge, which implied that one end had to be\r\n\u00e2\u0080\u0099a\u00e2\u0080\u0099 and the other \u00e2\u0080\u0099c\u00e2\u0080\u0099. So mark them as \u00e2\u0080\u0099a\u00e2\u0080\u0099 and \u00e2\u0080\u0099c\u00e2\u0080\u0099 respectively Now for\r\nall the other nodes check their edges with the found nodes in previous\r\nstep, there would be 4 possibilities: 1) Connected to both, mean the\r\nnode is \u00e2\u0080\u0099b\u00e2\u0080\u0099 2) Connected to the one marked \u00e2\u0080\u0099a\u00e2\u0080\u0099 only, mean the node is\r\n\u00e2\u0080\u0099a\u00e2\u0080\u0099 3) Connected to the one marked \u00e2\u0080\u0099c\u00e2\u0080\u0099 only, mean the node is \u00e2\u0080\u0099c\u00e2\u0080\u0099 4)\r\nConnected to none, means such a graph can\u00e2\u0080\u0099t exist. You now have the if\r\nand only possible string, (other possible string would just have been,\r\nif you taken the node marked \u00e2\u0080\u0099a\u00e2\u0080\u0099 as \u00e2\u0080\u0099c\u00e2\u0080\u0099 and vice versa) Now just check\r\nfor its validity This is my code 15819935\r\n"
}