{
    "link": "https://codeforces.com//contest/1521/problem/B",
    "problemId": "977644",
    "problem_idx": "B",
    "shortId": "1521B",
    "contest_number": "1521",
    "problem_submissions": {
        "D": [
            115581818,
            115594850,
            115598612,
            115603691,
            115599448,
            115601993,
            115608478,
            115569159,
            115612872,
            115604589,
            115610795,
            115602271,
            115608146,
            115607408,
            115599985
        ],
        "C": [
            115571933,
            115576814,
            115571686,
            115575287,
            115554792,
            115578008,
            115583346,
            115581715,
            115563254,
            115563941,
            115569253,
            115571673,
            115577961,
            115579502,
            115578223,
            115583699
        ],
        "B": [
            115555782,
            115541222,
            115542122,
            115539078,
            115535984,
            115537884,
            115535617,
            115535973,
            115540952,
            115589944,
            115543027,
            115535929,
            115532822,
            115550853,
            115551249,
            115536556,
            115547431,
            115535420
        ],
        "A": [
            115533383,
            115523492,
            115530232,
            115525696,
            115523586,
            115527609,
            115525343,
            115525115,
            115586248,
            115523901,
            115524582,
            115523559,
            115530582,
            115527602,
            115524514,
            115526011,
            115524612
        ],
        "E": [
            115603853,
            115608158,
            115614666,
            116024421,
            115649428,
            115659057,
            115613282,
            115649743,
            115610712
        ]
    },
    "name": "B. Nastia and a Good Array",
    "statement": ".She calls such an array a good that for all i (2\r\nle i\r\nle n) takes place gcd(a_{i - 1}, a_{i}) = 1, where gcd(u, v) denotes the\r\ngreatest common divisor (GCD) of integers u and v.You can perform the\r\noperation: select two indices i, j (1\r\nle i, j\r\nle n, i\r\nneq j) and two integers x, y (1\r\nle x, y\r\nle 2\r\ncdot 10^9) so that\r\nmin{(a_i, a_j)} =\r\nmin{(x, y)}. Then change a_i to x and a_j to y.The girl asks you to make\r\nthe array good using n operations.It can be proven that this is always\r\npossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define _FORTIFY_SOURCE 0\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\n#pragma GCC optimize(\"fast-math\")\n#define int long long\n\nusing namespace std;\n\nmt19937 rnd(time(nullptr));\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector <int> a(n);\n    int min_val = 2e9 + 7, pos = -1;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        if (a[i] < min_val) {\n            min_val = a[i];\n            pos = i;\n        }\n    }\n    cout << n - 1 << \"\\n\";\n    for (int i = 0; i < pos - 1; i++) {\n        cout << pos + 1 << \" \" << i + 1 << \" \" << min_val << \" \" << min_val + i + 1 << \"\\n\";\n    }\n    if (pos)\n        cout << pos + 1 << \" \" << pos << \" \" << min_val << \" \" << 1000100501 << \"\\n\";\n    for (int i = pos + 1; i < n; i++) {\n        cout << pos + 1 << \" \" << i + 1 << \" \" << min_val << \" \" << min_val + (i - pos) << \"\\n\";\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Nastia and a Good Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/90477",
    "editorial": "There are many ways to solve the problem. Here is one of them: We will\r\nuse the fact that for any integer .Letâs find the minimum element of the\r\narray that is located in the position . Then for all integer () perform\r\nthe following operation: . Thatâs how we replace to . The main\r\ncondition: is satisfied because always equals to and this value always\r\nless than any other element in the array .Consider the structure of the\r\narray after performing the operations describing above. Letâs define and\r\n. These are the leftmost and the rightmost elements in the array ,\r\nrespectively.The array looks like . Thus, we obtain an absolute\r\ndifference, equal to one, between all pairs of adjacent elements.\r\n",
    "hint": []
}