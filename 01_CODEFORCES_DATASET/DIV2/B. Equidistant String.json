{
    "link": "https://codeforces.com//contest/545/problem/B",
    "problemId": "28035",
    "problem_idx": "B",
    "shortId": "545B",
    "contest_number": "545",
    "problem_submissions": {
        "E": [
            11152908,
            11157700,
            11157522,
            11156542,
            11161300,
            11156960,
            11158926,
            11159332,
            11158333,
            11161026,
            11158857,
            11159720,
            11174097,
            11173935,
            11160858,
            11161651,
            11159778,
            11161054,
            11160310,
            11161820,
            11163252
        ],
        "C": [
            11150440,
            11147958,
            11150824,
            11150276,
            11148970,
            11148884,
            11153300,
            11153422,
            11152117,
            11151008,
            11151654,
            11153299,
            11155654,
            11152365,
            11152087,
            11153750,
            11154873,
            11151525,
            11151659
        ],
        "D": [
            11148301,
            11149439,
            11148692,
            11151407,
            11150444,
            11147349,
            11150296,
            11170906,
            11151431,
            11154441,
            11153203,
            11155014,
            11154361,
            11150015,
            11154687,
            11154652,
            11154830,
            11154199,
            11153829,
            11150376
        ],
        "B": [
            11147493,
            11152440,
            11147604,
            11147721,
            11147256,
            11149962,
            11148762,
            11149882,
            11149290,
            11148961,
            11148519,
            11150280,
            11148361,
            11149006,
            11149406,
            11151773,
            11147710,
            11148107,
            11147713
        ],
        "A": [
            11146984,
            11151375,
            11147061,
            11147027,
            11146977,
            11151139,
            11147222,
            11147723,
            11147389,
            11147403,
            11160745,
            11149107,
            11147430,
            11147598,
            11148409,
            11148792,
            11148668,
            11147021,
            11147024
        ]
    },
    "name": "B. Equidistant String",
    "statement": "Little Susie loves strings. Today she calculates distances between them.\r\nAs Susie is a small girl after all, her strings contain only digits zero\r\nand one. She uses the definition of Hamming distance:We will define the\r\ndistance between two strings and of the same length consisting of digits\r\nzero and one as the number of positions , such that isn’t equal to . As\r\nbesides everything else Susie loves symmetry, she wants to find for two\r\nstrings and of length such string of length , that the distance from to\r\nwas equal to the distance from to .It’s time for Susie to go to bed,\r\nhelp her find such string or state that it is impossible.\r\n",
    "solutions": [
        "//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    string S,P;\n    cin >> S >> P;\n    int n = S.size();\n    int dis = 0;\n    for(int i = 0; i < n;i++) if(S[i] != P[i]) dis++;\n    if(dis % 2){\n        cout << \"impossible\\n\";\n        return 0;\n    }\n    int c = 0;\n    string ans = \"\";\n    for(int i = 0; i < n;i++){\n        if(S[i] == P[i]){\n            ans += S[i];\n            continue;\n        }\n        if(c % 2) ans += S[i];\n        else ans += P[i];\n        c++;\n    }\n    cout << ans << endl;\n    return 0;\n    \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Equidistant String.json",
    "editorial_link": "https://codeforces.com//blog/entry/17982",
    "editorial": "One can see, that if for some , then the value of isnât important for\r\nus. Really, if we make equal to then it also be equal to . And if we\r\nmake not equal to then it also be not equal to . So, we have an answer\r\nthat is closer or further to both of s and t. So we interested about\r\nsuch position that . If we make equal to we make further from . If we\r\nmake equal to we make further from . It means that we need to divide\r\nthese positions into two equal parts to have equidistant string. For\r\nexample, we can make first of these positions closer to , second closer\r\nto and so on. If the number of these positions is even, we find an\r\nanswer, if it is odd, answer doesnât exist. Time complexity .\r\n",
    "hint": []
}