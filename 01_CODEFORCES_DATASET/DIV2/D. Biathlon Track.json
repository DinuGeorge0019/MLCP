{"link": "https://codeforces.com//contest/424/problem/D", "problemId": "8843", "problem_idx": "D", "shortId": "424D", "contest_number": "424", "problem_submissions": {"D": [6467465, 6468586, 6468437, 6471959, 6471829, 6468691, 6468869, 6467987, 6469186, 6469164, 6468850, 6468690, 6469089, 6472200, 6472173, 6469491, 6468201, 6469445, 6468946, 6470668, 6470648], "B": [6465143, 6465456, 6465043, 6464913, 6464966, 6468705, 6465228, 6464961, 6466059, 6465849, 6465782, 6467158, 6465289, 6469422, 6465084, 6465026, 6464523, 6464586, 6464947, 6465071], "C": [6464612, 6464680, 6466885, 6466816, 6466600, 6466756, 6466254, 6466363, 6467123, 6466142, 6467334, 6467704, 7360874, 6469401, 6471708, 6464542, 6465234, 6465523, 6465757, 6465709], "A": [6463928, 6465862, 6463956, 6464239, 6464063, 6464156, 6464137, 6464377, 6467414, 6468789, 6467791, 6466667, 6464430, 6469471, 6464203, 6463882, 6463888, 6463886, 6464224, 6464098]}, "name": "D. Biathlon Track", "statement": "Recently an official statement of the world Olympic Committee said that\r\nthe Olympic Winter Games 2030 will be held in Tomsk. The city officials\r\ndecided to prepare for the Olympics thoroughly and to build all the\r\nnecessary Olympic facilities as early as possible. First, a biathlon\r\ntrack will be built.To construct a biathlon track a plot of land was\r\nallocated, which is a rectangle divided into identical squares. Each of\r\nthe squares has two coordinates: the number of the row (from 1 to ),\r\nwhere it is located, the number of the column (from 1 to ), where it is\r\nlocated. Also each of the squares is characterized by its height. During\r\nthe sports the biathletes will have to move from one square to another.\r\nIf a biathlete moves from a higher square to a lower one, he makes a\r\ndescent. If a biathlete moves from a lower square to a higher one, he\r\nmakes an ascent. If a biathlete moves between two squares with the same\r\nheight, then he moves on flat ground.The biathlon track should be a\r\nborder of some rectangular area of the allocated land on which\r\nbiathletes will move in the clockwise direction. It is known that on one\r\nmove on flat ground an average biathlete spends seconds, an ascent takes\r\nseconds, a descent takes seconds. The Tomsk Administration wants to\r\nchoose the route so that the average biathlete passes it in as close to\r\nseconds as possible. In other words, the difference between time of\r\npassing the selected track and should be minimum.For a better\r\nunderstanding you can look at the first sample of the input data. In\r\nthis sample , and the administration wants the track covering time to be\r\nas close to seconds as possible, also, , and . If we consider the\r\nrectangle shown on the image by arrows, the average biathlete can move\r\nalong the boundary in a clockwise direction in exactly seconds. The\r\nupper left corner of this track is located in the square with the row\r\nnumber , column number and the lower right corner is at square with row\r\nnumber , column number . Among other things the administration wants all\r\nsides of the rectangle which boundaries will be the biathlon track to\r\nconsist of no less than three squares and to be completely contained\r\nwithin the selected land.You are given the description of the given plot\r\nof land and all necessary time values. You are to write the program to\r\nfind the most suitable rectangle for a biathlon track. If there are\r\nseveral such rectangles, you are allowed to print any of them.\r\n", "solutions": ["#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define forint(i, a, b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define forintdown(i, a, b) for(int i=(int)(a); i>=(int)(b); --i)\n#define forn(i, n) forint(i, 0, (n)-1)\n#define forndown(i, n) forintdown(i, (n)-1, 0)\n#define fillchar(a, x) memset(a, x, sizeof(a))\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPI;\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n\nconst int MAXN=333;\n\nint height[MAXN][MAXN];\nint a[MAXN], b[MAXN], c[MAXN], d[MAXN];\nint n, m, t, tp, tu, td;\n\nint cst(int h1, int h2) {\n\tif(h1==h2) return tp;\n\tif(h1<h2) return tu;\n\telse return td;\n}\n\nint ans, ansx1, ansy1, ansx2, ansy2;\nvoid upt(int tmp, int x1, int y1, int x2, int y2) {\n\tif(tmp<ans) {\n\t\tans=tmp;\n\t\tansx1=x1, ansy1=y1;\n\t\tansx2=x2, ansy2=y2;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n,&m,&t);\n\tscanf(\"%d%d%d\", &tp,&tu,&td);\n\tforint(i, 1, n) forint(j, 1, m) scanf(\"%d\", &height[i][j]);\n\tans=1<<30;\n\tansx1=1, ansy1=1;\n\tansx2=2, ansy2=2;\n\tforint(x1, 1, n) {\n\t\tfillchar(a, 0); fillchar(b, 0);\n\t\tforint(x2, x1+1, n) {\n\t\t\tfillchar(c, 0); fillchar(d, 0);\n\t\t\tforint(j, 1, m) { //\n\t\t\t\ta[j]+=cst(height[x2][j], height[x2-1][j]);\n\t\t\t\tb[j]+=cst(height[x2-1][j], height[x2][j]);\n\t\t\t}\n\t\t\tforint(j, 2, m) {\n\t\t\t\tc[j]=c[j-1]+cst(height[x1][j-1], height[x1][j]);\n\t\t\t\td[j]=d[j-1]+cst(height[x2][j], height[x2][j-1]);\n\t\t\t}\n\t\t\tif(x2<=x1+1) continue;\n\t\t\tset<PII> z;\n\t\t\tforint(j, 1, m) {\n\t\t\t\tif(j>=3) z.insert(MP(a[j-2]-c[j-2]-d[j-2], j-2));\n\t\t\t\tint want=t-(c[j]+d[j]+b[j]);\n\t\t\t\tset<PII>::iterator it=z.lower_bound(MP(want, 0));\n\t\t\t\tif(it!=z.end()) {\n\t\t\t\t\tupt(abs(want-it->fi), x1, it->se, x2, j);\n\t\t\t\t}\n\t\t\t\tif(it!=z.begin() && z.size()>0) {\n\t\t\t\t\t--it;\n\t\t\t\t\tupt(abs(want-it->fi), x1, it->se, x2, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d %d %d %d\\n\", ansx1, ansy1, ansx2, ansy2);\n\t//printf(\"ans=%d\\n\",ans);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "constructive algorithms", "data structures", "dp"], "dificulty": "2300", "interactive": false}