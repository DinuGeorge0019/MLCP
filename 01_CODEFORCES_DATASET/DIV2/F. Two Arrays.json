{
    "link": "https://codeforces.com//contest/1642/problem/F",
    "problemId": "1306243",
    "problem_idx": "F",
    "shortId": "1642F",
    "contest_number": "1642",
    "problem_submissions": {
        "E": [
            147461190,
            147448894,
            147463582,
            147629005,
            147463721,
            147465007,
            147464536,
            147464772,
            154238571,
            147442248,
            147468697,
            147546721,
            147530401
        ],
        "D": [
            147438364,
            147485650,
            147449537,
            147450562,
            147452894,
            147455461,
            147452625,
            147459786,
            147436803,
            147442745,
            147526042,
            147444306,
            147445760,
            147446955,
            147445886,
            147445039,
            147443394,
            147443106,
            147445514,
            147441961
        ],
        "B": [
            147422743,
            147420129,
            147417727,
            147418273,
            147417851,
            147419235,
            147432654,
            147420007,
            147417444,
            147417393,
            147418769,
            147419164,
            147418158,
            147418261,
            147419265,
            147416406,
            147420612,
            147425669,
            147421032,
            147423752
        ],
        "C": [
            147419008,
            147423535,
            147421085,
            147425938,
            147438330,
            147422534,
            147436627,
            147425010,
            147420010,
            147419556,
            147423431,
            147424779,
            147424498,
            147421790,
            147424573,
            147422658,
            147423818,
            147428109,
            147426206,
            147427103
        ],
        "A": [
            147415594,
            147416949,
            147415861,
            147433429,
            147415090,
            147426989,
            147415984,
            147416265,
            147415834,
            147415031,
            147415872,
            147416127,
            147415441,
            147414768,
            147415249,
            147414961,
            147417533,
            147420604,
            147417311,
            147415231
        ],
        "F": [
            147464749,
            147653708,
            147464855,
            147521397
        ]
    },
    "name": "F. Two Arrays",
    "statement": "Sam changed his school and on the first biology lesson he got a very\r\ninteresting task about genes.You are given n arrays, the i-th of them\r\ncontains m different integers a_{i,1}, a_{i,2},\r\nldots,a_{i,m}. Also you are given an array of integers w of length\r\nn.Find the minimum value of w_i + w_j among all pairs of integers (i, j)\r\n(1\r\nle i, j\r\nle n), such that the numbers a_{i,1}, a_{i,2},\r\nldots,a_{i,m}, a_{j,1}, a_{j,2},\r\nldots,a_{j,m} are distinct.\r\n",
    "solutions": [
        "/*\nstart thinking:\nBULB:\nresult of thinking:\n\nstart coding:\nAC:\n*/\n#include <bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ldouble;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\nconst int inf = 0x3f3f3f3f;\nconst ll infll = 0x3f3f3f3f3f3f3f3f;\ntemplate<class T> bool chmin(T& x, const T& y) {\n  return x > y ? (x = y, true) : false;\n}\ntemplate<class T> bool chmax(T& x, const T& y) {\n  return x < y ? (x = y, true) : false;\n}\nbool Mbe;\n\n#define maxn 100005\nint n, m, a[maxn][6], w[maxn], V, id[3915], minw[3915], chi[3915][6];\nvector<int> pos[maxn * 5];\n\nint ban[maxn];\nint minId() {\n  int x = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!ban[i] && w[i] < w[x])\n      x = i;\n  }\n  return x;\n}\nvoid build(int u, int dep) {\n  id[u] = minId();\n  minw[u] = w[id[u]];\n  if (dep == m || !id[u])\n    return;\n  for (int i = 1; i <= m; i++) {\n    int x = a[id[u]][i];\n    for (auto j : pos[x])\n      ban[j]++;\n    chi[u][i] = ++V;\n    build(V, dep + 1);\n    for (auto j : pos[x])\n      ban[j]--;\n  }\n}\n\nint query(const vector<int> &b) {\n  int u = 1;\n  while (true) {\n    if (minw[u] == INT_MAX)\n      return INT_MAX;\n    bool ok = false;\n    for (int i = 1; i <= m; i++) {\n      for (int j = 0; j < m; j++) {\n        if (b[j] == a[id[u]][i]) {\n          ok = true;\n          u = chi[u][i];\n          break;\n        }\n      }\n      if (ok)\n        break;\n    }\n    if (!ok)\n      return minw[u];\n  }\n}\n\nbool Med;\nint main() {\n  fprintf(stderr, \"%.2fMB\\n\", (&Mbe - &Med) / 1048576.0);\n  scanf(\"%d%d\", &n, &m);\n  vector<int> as;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &a[i][j]);\n      as.push_back(a[i][j]);\n    }\n    scanf(\"%d\", w + i);\n  }\n  sort(as.begin(), as.end());\n  as.erase(unique(as.begin(), as.end()), as.end());\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      a[i][j] = lower_bound(as.begin(), as.end(), a[i][j]) - as.begin() + 1;\n      pos[a[i][j]].push_back(i);\n    }\n  }\n  w[0] = INT_MAX;\n  build(++V, 0);\n  int ans = INT_MAX;\n  for (int i = 1; i <= n; i++) {\n    vector<int> foo;\n    for (int j = 1; j <= m; j++)\n      foo.push_back(a[i][j]);\n    int bar = query(foo);\n    if (bar != INT_MAX)\n      chmin(ans, bar + w[i]);\n  }\n  printf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "combinatorics",
        "math",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Two Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "Let\u00e2\u0080\u0099s maintain a set of arrays of length , add new arrays there, delete\r\narrays from this set and understand if the set has a suitable pair for\r\nsome array. To do this, let\u00e2\u0080\u0099s consider a pair of sorted arrays and of\r\nlength . Let\u00e2\u0080\u0099s write out all subsets of the array . Then we start a\r\ncounter , and for each subset of the array we add one to , if the subset\r\noccurs in and contains an odd number of elements, and subtract one if\r\nthe subset occurs in and contains an even number of elements. Note that\r\nif and have at least one element in common, then will be equal to ,\r\notherwise it will be equal to . Thus, we can maintain a trie that\r\ncontains all the subsets of each array in the set. Now any request to\r\nthis trie is trivially done for .Now let\u00e2\u0080\u0099s sort the arrays by and use\r\nour structure to find the first array that has a suitable pair. We can\r\nsimply find the pair and maintain 2 pointers, is equal to the first\r\narray in the pair, is equal to the second array in the pair. Note that\r\nnow we are only interested in pairs such that . Therefore, we will move\r\nto the left only. When we moved it once again, we will see if there is a\r\npair for it among . If so, then we will move to the left until there is\r\na pair for among . After that we can update the answer with . The\r\nsolution works in .It is also possible to solve this problem in using .\r\n"
}