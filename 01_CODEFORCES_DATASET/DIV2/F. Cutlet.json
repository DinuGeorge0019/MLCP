{
    "link": "https://codeforces.com//contest/939/problem/F",
    "problemId": "157445",
    "problem_idx": "F",
    "shortId": "939F",
    "contest_number": "939",
    "problem_submissions": {
        "F": [
            35407164,
            35404527,
            35409631,
            35413577,
            35411662,
            35419439,
            35414187,
            35411618,
            35431888,
            35412467,
            35419660,
            35433583
        ],
        "E": [
            35398600,
            35400617,
            35396384,
            35401251,
            35402353,
            35398722,
            35401205,
            35397543,
            35398502,
            35402734,
            35403103,
            35414533,
            35403422,
            35401372,
            35401626,
            35461044,
            35403396,
            35403015,
            35403923,
            35405332,
            35405603
        ],
        "D": [
            35396133,
            35397568,
            35397994,
            35395417,
            35401286,
            35396814,
            35398696,
            35395034,
            35395649,
            35399214,
            35400903,
            35404198,
            35396354,
            35399157,
            35398522,
            35399419,
            35400286,
            35400477,
            35399060,
            35399994
        ],
        "C": [
            35393837,
            35395958,
            35393508,
            35393769,
            35396360,
            35392577,
            35412731,
            35392757,
            35393879,
            35395902,
            35398127,
            35403086,
            35394045,
            35395387,
            35396026,
            35395295,
            35396730,
            35397951,
            35394874,
            35395895
        ],
        "B": [
            35389969,
            35392883,
            35389759,
            35389629,
            35391873,
            35393694,
            35390537,
            35390126,
            35390538,
            35390605,
            35392335,
            35394074,
            35390549,
            35391091,
            35397165,
            35390254,
            35391051,
            35391212,
            35391979,
            35390583
        ],
        "A": [
            35388647,
            35391478,
            35388695,
            35388656,
            35389475,
            35394633,
            35388859,
            35388665,
            35388816,
            35388903,
            35389256,
            35400980,
            35388685,
            35388755,
            35389214,
            35388752,
            35389036,
            35388963,
            35390469,
            35388756
        ]
    },
    "name": "F. Cutlet",
    "statement": "Arkady wants to have a dinner. He has just returned from a shop where he\r\nhas bought a semifinished cutlet. He only needs to fry it. The cutlet\r\nshould be fried for seconds, in particular, it should be fried for\r\nseconds on one side and seconds on the other side. Arkady has already\r\ngot a frying pan and turn on fire, but understood that maybe he won’t be\r\nable to flip the cutlet exactly after seconds after the beginning of\r\ncooking.Arkady is too busy with sorting sticker packs in his favorite\r\nmessenger and can flip the cutlet only in some periods of time. Namely,\r\nthere are periods of time in which he can do it, the -th of them is an\r\ninterval of time from seconds after he starts cooking till seconds,\r\ninclusive. Arkady decided that it’s not required to flip the cutlet\r\nexactly in the middle of cooking, instead, he will flip it several times\r\nin such a way that the cutlet will be fried exactly seconds on one side\r\nand seconds on the other side in total.Help Arkady and find out if it’s\r\npossible for him to cook the cutlet, if he is able to flip the cutlet\r\nonly in given periods of time; and if yes, find the minimum number of\r\nflips he needs to cook the cutlet.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 2e5 + 10;\nconst int INF = 1e9;\n\nint n, k;\npii seg[MAXN];\nint d[2][MAXN];\nvector<int> vec[2][MAXN];\nmultiset<int> st;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> k;\n\tfor (int i = 0; i < k; i++)\tcin >> seg[i].F >> seg[i].S;\n\tmemset(d, 63, sizeof(d));\n\td[1][0] = 0;\n\tint cur = 0;\n\tfor (int l = 0; l < 2*n;) {\n\t\tif (cur < k && l == seg[cur].F){\n\t\t\tint r = seg[cur++].S;\n\t\t\tfor (int w = 0; w < 2; w++)\n\t\t\t\tfor (int i = 0; i < MAXN; i++) vec[w][i].clear();\n\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tvec[0][i].push_back(d[1][i] + 1 + 1);\n\t\t\t\tvec[0][min(n + 1, i + (r-l)+1)].push_back(-(d[1][i] + 1 + 1));\n\n\t\t\t\tvec[1][i].push_back(d[1][i] + 2 + 1);\n\t\t\t\tvec[1][min(n+1, i+(r-l)+1)].push_back(- (d[1][i] + 2 + 1));\n\n\t\t\t\tif (i + (r-l) <= n) {\n\t\t\t\t\tvec[1][i+ (r-l)].push_back(d[1][i] + 1);\n\t\t\t\t\tvec[1][i+ (r-l) + 1].push_back(-(d[1][i] + 1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tvec[1][i].push_back(d[0][i] + 1 + 1);\n\t\t\t\tvec[1][min(n+1, i+(r-l)+1)].push_back(- (d[0][i] + 1 + 1));\n\n\t\t\t\tvec[0][i].push_back(d[0][i] + 2 + 1);\n\t\t\t\tvec[0][min(n+1, i+1+(r-l))].push_back(- (d[0][i] + 2 + 1));\n\t\t\t\t\n\t\t\t\tvec[0][i].push_back(d[0][i] + 1);\n\t\t\t\tvec[0][i+1].push_back(-(d[0][i] + 1));\n\t\t\t}\n\n\t\t\tfor (int w = 0; w < 2; w++){\n\t\t\t\tst.clear();\n\t\t\t\tfor (int i = 0; i <= n; i++){\n\t\t\t\t\tfor (int x:vec[w][i])\n\t\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\t\tst.insert(x - 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tst.erase(st.find(-x - 1));\n\t\t\t\t\td[w][i] = (st.size()? *st.begin(): INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tl = r;\n\t\t}\n\t\telse{\n\t\t\tint r = (cur < k? seg[cur].F: 2*n);\n\t\t\tfor (int i = n; ~i; i--){\n\t\t\t\tif (i >= r-l)\n\t\t\t\t\td[1][i] = d[1][i-(r-l)];\n\t\t\t\telse\n\t\t\t\t\td[1][i] = INF;\n\t\t\t}\n\t\t\tl = r;\n\t\t}\n\t}\n\tint ans = min(d[0][n], d[1][n]);\n\tif (ans > (int)1e6)\n\t\tcout << \"Hungry\\n\";\n\telse {\n\t\tcout << \"Full\\n\";\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Cutlet.json",
    "editorial_link": "https://codeforces.com//blog/entry/57892",
    "editorial": "Letâs use dynamic programming approach. Solve the following subproblem:\r\nlet be the seconds passed since the start of cooking, and seconds among\r\nthem the cutlet was preparing on the current side; what is the minimum\r\nnumber of flips needed to reach this state? This can be easily computed\r\nusing answers for subproblems , , in which the cutlet lays on the same\r\nside, and and , in which the cutlet lays on the other side. You should\r\ncarefully consider the number of flips needed for each transition, and\r\ncheck if it is possible, according to Arkadyâs availability. The\r\ncomplexity of this solution is , which is not enough.For full solution,\r\nit is enough to consider only moments that correspond to start of some\r\nsegment Arkadyâs availability, because between these moments we can make\r\nat most two flips, otherwise the result is obviously not optimal. In\r\nsuch case to compute the answer for subproblem it is enough to compute\r\nminimum among answers for subproblems , where the time of the start of\r\nthe previous time segment is fixed, and changes within several segments,\r\nthe bounds of which depend on the number of flips between moments and\r\nseconds, and parameters , , , . For effective computing of minimums you\r\ncan use the queue of minimums, because the bounds of the segments\r\nincrease with the increase of . The total complexity is . You can also\r\nuse other data structures for computing minimum, and the complexity of\r\nsuch solutions is .\r\n",
    "hint": []
}