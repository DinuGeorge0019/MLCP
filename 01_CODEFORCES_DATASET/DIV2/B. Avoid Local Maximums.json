{
    "link": "https://codeforces.com//contest/1635/problem/B",
    "problemId": "1304248",
    "problem_idx": "B",
    "shortId": "1635B",
    "contest_number": "1635",
    "problem_submissions": {
        "F": [
            147074799,
            147095752,
            147102178,
            147104275
        ],
        "E": [
            147062187,
            147069534,
            147070601,
            147071820,
            147072661,
            147071018,
            147073981,
            147068936,
            147074142,
            147080760,
            147076462,
            147075385,
            147083209,
            147071491,
            147078900,
            147071624,
            147081688,
            147079690,
            147084319
        ],
        "D": [
            147053217,
            147052386,
            147056630,
            147057231,
            147060557,
            147060631,
            147061935,
            147063792,
            147060134,
            147103502,
            147102937,
            147062678,
            147065535,
            147062609,
            147060941,
            147064885,
            147067705,
            147078835,
            147068792,
            147065392,
            147061320
        ],
        "C": [
            147045170,
            147044912,
            147046365,
            147045126,
            147049650,
            147049621,
            147048160,
            147047404,
            147047609,
            147047366,
            147047254,
            147054268,
            147048212,
            147053384,
            147048532,
            147046997,
            147047963,
            147049441,
            147044930
        ],
        "B": [
            147039520,
            147040113,
            147040251,
            147041870,
            147044628,
            147040558,
            147042641,
            147039735,
            147042175,
            147042000,
            147041459,
            147043659,
            147041936,
            147043726,
            147040154,
            147042155,
            147041291,
            147040938,
            147041038
        ],
        "A": [
            147036699,
            147037179,
            147036802,
            147037015,
            147036879,
            147036847,
            147037144,
            147036925,
            147036758,
            147037118,
            147036774,
            147037869,
            147036975,
            147036790,
            147036876,
            147036819,
            147036907,
            147037053,
            147036783
        ]
    },
    "name": "B. Avoid Local Maximums",
    "statement": "You are given an array a of size n. Each element in this array is an\r\ninteger between 1 and 10^9.You can perform several operations to this\r\narray. During an operation, you can replace an element in the array with\r\nany integer between 1 and 10^9. Output the minimum number of operations\r\nneeded such that the resulting array doesn’t contain any local maximums,\r\nand the resulting array after the operations.An element a_i is a local\r\nmaximum if it is strictly larger than both of its neighbors (that is,\r\na_i > a_{i - 1} and a_i > a_{i + 1}). Since a_1 and a_n have only one\r\nneighbor each, they will never be a local maximum.\r\n",
    "solutions": [
        "// Problem: B. Avoid Local Maximums\n// Contest: Codeforces Round #772 (Div. 2)\n// URL: https://codeforces.com/contest/1635/problem/B\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nint a[1000003];\nbool f[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tfor(int i=1; i<=n; ++i) a[i]=read();\n\t\tint ans=0;\n\t\ta[n+1]=1000000000;\n\t\tfor(int i=2; i<n; ++i) if(a[i]>a[i-1]&&a[i]>a[i+1]) \n\t\t{\n\t\t\ta[i+1]=max(a[i],a[i+2]);\n\t\t\t++ans;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\tfor(int i=1; i<=n; ++i) printf(\"%lld \",a[i]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Avoid Local Maximums.json",
    "editorial_link": "https://codeforces.com//blog/entry/100153",
    "editorial": "Letâs check all elements in from the left. Once we find that is a local\r\nmaximum, then we should perform an operation to fix it. There are many\r\nways to do this, but the optimal way is to set to , because we can avoid\r\nand from being local maximums at the same time.Proof: Letâs take all\r\nindices of local maximums in the initial array and append them to an\r\nempty array with their corresponding order. For example, if , we obtain\r\n. Then, we devide into subarrays, such that and are in the same subarray\r\nif and only if . Using the same example above, we will devide into . To\r\nfinish our proof, we need two important observations. 1. Any operation\r\nwould cancel at most two local maximums.2. Any operation wonât cancel\r\ntwo local maximums whose indices are in different subarrays of .So for a\r\nfixed subarray, we need at least operations to cancel all corresponding\r\nlocal maximums, and the lower bound of the answer is the sum of for all\r\nsubarrays.Since the strategy described above could achieve this lower\r\nbound, our proof has completed.\r\n",
    "hint": []
}