{
    "link": "https://codeforces.com//contest/1794/problem/E",
    "problemId": "1808459",
    "problem_idx": "E",
    "shortId": "1794E",
    "contest_number": "1794",
    "problem_submissions": {
        "E": [
            196467319,
            196091024,
            196065447,
            196027516,
            196045507,
            196044539,
            196049784,
            196043653,
            196050334,
            196053527,
            196054181,
            196051837,
            196052921,
            196053608,
            196051434,
            196129108,
            196055320,
            196058590,
            196049523,
            196042891,
            196053778,
            196054545,
            196037576,
            196074501,
            196074391
        ],
        "D": [
            196083505,
            196016109,
            196024909,
            196024858,
            196021434,
            196025217,
            196028904,
            196025001,
            196032867,
            196029336,
            196033933,
            196031399,
            196038559,
            196037652,
            196048488,
            196050480,
            196036074,
            196036926,
            208633215,
            196022650
        ],
        "C": [
            196008950,
            196011685,
            196013987,
            196009207,
            196010114,
            196018308,
            196011596,
            196011705,
            196015187,
            196016689,
            196011713,
            196018563,
            196020776,
            196010830,
            196012003,
            196018106,
            196018224,
            196016136,
            196008531
        ],
        "B": [
            196004154,
            196004594,
            196009639,
            196005082,
            196031084,
            196004622,
            196004148,
            196006017,
            196007935,
            196006213,
            196009047,
            196004027,
            196017820,
            196010698,
            196013843,
            196006494,
            196003310,
            196003871
        ],
        "A": [
            196003031,
            196003363,
            196007521,
            196004024,
            196002777,
            196003379,
            196002990,
            196004171,
            196003805,
            196004167,
            196007050,
            196002947,
            196003739,
            196007194,
            196008753,
            196020821,
            196002700,
            196002959
        ]
    },
    "name": "E. Labeling the Tree with Distances",
    "statement": "You are given an unweighted tree of n vertices numbered from 1 to n and\r\na list of n-1 integers a_1, a_2,\r\nldots, a_{n-1}. A tree is a connected undirected graph without cycles.\r\nYou will use each element of the list to label one vertex. No vertex\r\nshould be labeled twice. You can label the only remaining unlabeled\r\nvertex with any integer. A vertex x is called if it is possible to do\r\nthis labeling so that for each vertex i, its label is the distance\r\nbetween x and i. The distance between two vertices s and t on a tree is\r\nthe minimum number of edges on a path that starts at vertex s and ends\r\nat vertex t. Find all good vertices.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <iostream>\n#include <random>\n#include <set>\n#include <vector>\n#include <chrono>\nusing namespace std;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nconst int P = 1e9 + 7;\n\ntypedef array<int, 10> Hash;\n \nHash operator*(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = 1LL * u[i] * v[i] % P;\n  return t;\n}\n\nHash operator+(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + v[i]) % P;\n  return t;\n}\n\nHash operator-(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] - v[i] + P) % P;\n  return t;\n}\n \nHash Base;\n \nHash mult_base(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (1LL * u[i] * Base[i]) % P;\n  return t;\n}\n\nHash add_one(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + 1) % P;\n  return t;\n}\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n \nint gen_base() {\n  static uniform_int_distribution<int> d(258, P - 1);\n  int b = d(rng);\n  return b % 2 == 0 ? b - 1 : b;\n}\n\nconst int N = 2e5;\n\nHash sub[N];\nvector<int> g[N];\n\nvoid dfs1(int p, int i) {\n  for (int j : g[i])\n    if (p != j) {\n      dfs1(i, j);\n      sub[i] = sub[i] + sub[j];\n    }\n  sub[i] = add_one(mult_base(sub[i]));\n}\n\nHash root[N];\n\nvoid dfs2(int p, int i, Hash up) {\n  root[i] = sub[i] + mult_base(up);\n  Hash all = up;\n  for (int j : g[i])\n    if (p != j)\n      all = all + sub[j];\n  for (int j : g[i])\n    if (p != j) {\n      Hash tmp = add_one(mult_base(all - sub[j]));\n      dfs2(i, j, tmp);\n    }\n}\n\nint main() {\n  for (int i = 0; i < 10; i++)\n    Base[i] = gen_base();\n  static int c[N];\n  int n = read();\n  for (int i = 0; i < n - 1; i++)\n    c[read()]++;\n  for (int h = 0; h < n - 1; h++) {\n    int i = read() - 1, j = read() - 1;\n    g[i].push_back(j), g[j].push_back(i);\n  }\n  dfs1(-1, 0);\n  Hash h;\n  fill(h.begin(), h.end(), 0);\n  dfs2(-1, 0, h);\n  Hash rn, pw;\n  for (int i = 0; i < 10; i++)\n    rn[i] = 0, pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    while (c[i]--)\n      rn = rn + pw;\n    pw = mult_base(pw);\n  }\n  set<Hash> ok;\n  for (int i = 0; i < 10; i++)\n    pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    ok.insert(pw + rn);\n    pw = mult_base(pw);\n  }\n  vector<int> ans;\n  for (int i = 0; i < n; i++)\n    if (ok.count(root[i]))\n      ans.push_back(i);\n  printf(\"%d\\n\", (int) ans.size());\n  sort(ans.begin(), ans.end());\n  for (int i : ans)\n    printf(\"%d \", i + 1);\n  printf(\"\\n\");\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "hashing",
        "implementation",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Labeling the Tree with Distances.json",
    "editorial_link": "https://codeforces.com//blog/entry/113500",
    "editorial": "First, count the number of occurrences of each element in the list . Let\r\nthese numbers be . Then, compute the polynomial hash of the array , that\r\nis where is the base of the hash. Because the tree is unweighted, there\r\nare only possible values to write in the unlabeled vertex (all integers\r\nbetween and ). Including this extra number, the hash has possibilities:\r\nfor each .Now, let\u00e2\u0080\u0099s compute the same hash for each vertex of the tree.\r\nThat is, for each vertex count how many vertices are at distances , and\r\nif these numbers are compute the value . To compute these values\r\nefficiently, we will use rerooting dynamic programming: We will make two\r\nDFS. In the first one, compute the parent of each node and the hash of\r\neach node only considering the nodes in its subtree. For each vertex ,\r\nif we call this hash then . In the second one (which must be performed\r\nafter the first one), for each vertex compute the hash of the parent of\r\nconsidering the nodes which are not in the subtree of vertex . If we\r\ncall this hash then where is the parent of .Now, observe that . With\r\nthese hashes, we can compute the good vertices. A vertex will be good if\r\nand only if for some . Doing a two pointers algorithm with the two\r\nsorted lists and is enough to find for each if there is a number on the\r\nother list equal to it.To make the solution pass, it is advisable to use\r\nhashing with multiple modules or just one big modulo.Intended\r\ncomplexity: .\r\n"
}