{
    "link": "https://codeforces.com//contest/673/problem/E",
    "problemId": "59810",
    "problem_idx": "E",
    "shortId": "673E",
    "contest_number": "673",
    "problem_submissions": {
        "E": [
            17790544,
            17790298,
            17792643,
            17795142,
            17797198,
            17796072,
            17796678,
            17794290,
            17802948,
            18498821,
            18454059,
            18453934,
            18453804,
            27208468,
            17814502,
            17814492,
            17810486
        ],
        "A": [
            17785371,
            17780028,
            17783006,
            17781229,
            17780841,
            17781392,
            17781436,
            17783310,
            17780077,
            17780098,
            17783943,
            17780241,
            17780697,
            17780142,
            17780713,
            17780906,
            17780033,
            17782963,
            17780095,
            17780488
        ],
        "D": [
            17784968,
            17784163,
            17787638,
            17787311,
            17788261,
            17790516,
            17791783,
            17788147,
            17787202,
            17788591,
            17787856,
            17787228,
            17787665,
            17788331,
            17788505,
            17790808,
            17791801,
            17789992,
            17788978,
            17790173
        ],
        "B": [
            17783887,
            17780728,
            17785147,
            17782968,
            17783327,
            17784516,
            17785052,
            17786520,
            17783375,
            17784877,
            17782865,
            17784125,
            17784706,
            17782517,
            17784194,
            17786784,
            17781561,
            17784108,
            17784745,
            17783935
        ],
        "C": [
            17780670,
            17782033,
            17785575,
            17788307,
            17784829,
            17786955,
            17787316,
            17789788,
            17784945,
            17782021,
            17781157,
            17785332,
            17782835,
            17785106,
            17786557,
            17783986,
            17790134,
            17785539,
            17783083,
            17786914
        ],
        "F": [
            17799743
        ]
    },
    "name": "E. Levels and Regions",
    "statement": "Radewoosh is playing a computer game. There are levels, numbered through\r\n. Levels are divided into regions (groups). Each region contains some\r\npositive number of consecutive levels.The game repeats the the following\r\nprocess: If all regions are beaten then the game ends immediately.\r\nOtherwise, the system finds the first region with at least one\r\nnon-beaten level. Let denote this region. The system creates an empty\r\nbag for tokens. Each token will represent one level and there may be\r\nmany tokens representing the same level. For each already beaten level\r\nin the region , the system adds tokens to the bag (tokens representing\r\nthe -th level). Let denote the first non-beaten level in the region .\r\nThe system adds tokens to the bag. Finally, the system takes a uniformly\r\nrandom token from the bag and a player starts the level represented by\r\nthe token. A player spends one hour and beats the level, even if he has\r\nalready beaten it in the past. Given , and values , your task is to\r\nsplit levels into regions. Each level must belong to exactly one region,\r\nand each region must contain non-empty consecutive set of levels. What\r\nis the minimum possible expected number of hours required to finish the\r\ngame?\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <limits.h>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int K_ = 55;\nconst int N_ = 200500;\n\nint N, K, T[N_];\n\nlf sumT[N_], suminvT[N_], sumU[N_], prec[N_];\n\nstruct line {\n\tlf a, b;\n\tline (lf a = 0, lf b = 0): a(a), b(b) { }\n};\n\nnamespace CHT {\n\tline lines[N_];\n\tint l, r;\n\n\tvoid clear() {\n\t\tl = r = 0;\n\t}\n\n\tvoid push (lf a, lf b) {\n\t\tlines[r] = line(a, b);\n\t\twhile(l+1 < r && (lines[r-1].b - lines[r-2].b) * (lines[r].a - lines[r-1].a) <= (lines[r-2].a - lines[r-1].a) * (lines[r-1].b - lines[r].b)) {\n\t\t\tlines[r-1] = lines[r];\n\t\t\tr--;\n\t\t}\n\t\tr++;\n\t}\n\n\tllf get (lf x) {\n\t\twhile(l+1 < r && (lines[l+1].b - lines[l].b) >= x * (lines[l].a - lines[l+1].a)) ++l;\n\t\treturn lines[l].a * x + lines[l].b;\n\t}\n};\n\nlf tb[K_][N_];\n\nint main() {\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", T+i);\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tsumT[i] = sumT[i-1] + T[i];\n\t\tsuminvT[i] = suminvT[i-1] + (lf)1.0 / T[i];\n\t\ttb[1][i] = sumU[i] = sumU[i-1] + sumT[i] / T[i];\n\t\tprec[i] = sumU[i] - sumT[i] * suminvT[i];\n\t}\n\n\tfor(int k = 2; k <= K; k++) {\n\t\tCHT::clear();\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\ttb[k][i] = sumU[i] - CHT::get(suminvT[i]);\n\t\t\tCHT::push(sumT[i], prec[i] - tb[k-1][i]);\n\t\t}\n\t}\n\tprintf(\"%.25f\\n\", tb[K][N]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Levels and Regions.json",
    "editorial_link": "https://codeforces.com//blog/entry/44754",
    "editorial": "When we repeat something and each time we have\nprobability to succeed then the expected number or tries is , till we\nsucceed. How to calculate the expected time for one region ? For each in\nsome moment we will try to beat this level and then there will be tokens\nin the bag, including tokens allowing us to beat this new level. The\nprobability to succeed is , so the expected time is . So, in total we\nshould sum up values for . Ok, we managed to understand the actual\nproblem. You can now stop and try to find a slow solution in . Hint: use\nthe dynamic programming. Now letâs write formula for , as the minimum\nover denoting the end of the previous region: So we can use convex hull\ntrick to calculate it in . You should also get AC with a bit slower\ndivide&conquer trick, if itâs implemented carefully. 18286696 (invented\nby Radewoosh) Letâs say that every company has one parent (a company it\nfollows). Also, every copmany has some (maybe empty) set of children.\nItâs crucial that sets of children are disjoint. For each company letâs\nkeep (and always update) one value, equal to the sum of: It turns out\nthat after each query only the above sum changes only for a few values.\nIf starts to follows then you should care about . And maybe and if you\nwant to be sure. You can stop reading now for a moment and analyze that\nindeed other companies will keep the same sum, described above. Ok, but\nso far we donât count the income coming from parentâs fanpage. But, for\neach company we can store all its children in one set. All children have\nthe same \"income from parentâs fanpage\" because they have the same\nparent. So, in set you can keep children sorted by the sum described\nabove. Then, we should always puts the extreme elements from sets in one\nglobal set. In the global set you care about the total income, equal to\nthe sum described above and this new \"income from parent\". Check codes\nfor details. The complexity should be , with big constant factor.\n18286747 (invented by Errichto) Let denote the probability that subtree\n(if attacked now) would have height at most . The first observation is\nthat we donât care about big because itâs very unlikely that a path with\ne.g. 100 edges will survive. Letâs later talk about choosing and now\nletâs say that itâs enough to consider up to . When we should answer a\nquery for subtree then we should sum up to get the answer. The other\nquery is harder. Letâs say that a new vertex is attached to vertex .\nThen, among only changes (other values stay the same). Also, one value\nchanges, and so does and so on. You should iterate over vertices (each\ntime going to parent) and update the corresponding value. TODO puts here\ncome formula for updating value. The complexity is . You may think that\nis enough because is small enough. Unfortunately, there exist malicious\ntests. Consider a tree with paths from root, each with length . Now, we\ntalk about the probability of magnitude: which is more than for .\nhttp://www.wolframalpha.com/input/?i=1+-+(1-(1\n",
    "hint": []
}