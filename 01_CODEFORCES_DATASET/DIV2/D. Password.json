{
    "link": "https://codeforces.com//contest/127/problem/D",
    "problemId": "670",
    "problem_idx": "D",
    "shortId": "127D",
    "contest_number": "127",
    "problem_submissions": {
        "C": [
            850036,
            853243,
            846749,
            850308,
            846400,
            846988,
            845889,
            846983,
            848328,
            847795,
            850207,
            848393,
            852965,
            852478
        ],
        "E": [
            847897,
            853236,
            852099,
            849554,
            849938,
            852088,
            847325,
            849147,
            850677,
            850641,
            851469,
            847732,
            853167,
            848319
        ],
        "D": [
            846279,
            853241,
            847740,
            846696,
            846866,
            848133,
            848630,
            6502633,
            848689,
            855255,
            848044,
            852652,
            849109,
            849008,
            849880,
            850099
        ],
        "B": [
            844434,
            853246,
            843634,
            844201,
            843671,
            852802,
            849355,
            844696,
            844897,
            844537,
            843982,
            844433,
            845330,
            844159,
            844315,
            844292,
            844410,
            844073
        ],
        "A": [
            843764,
            853248,
            844472,
            843689,
            844407,
            843900,
            849942,
            843939,
            843940,
            843968,
            843625,
            843834,
            844583,
            843676,
            843729,
            843791,
            844024,
            843613
        ]
    },
    "name": "D. Password",
    "statement": "Asterix, Obelix and their temporary buddies Suffix and Prefix has\r\nfinally found the Harmony temple. However, its doors were firmly locked\r\nand even Obelix had no luck opening them.A little later they found a\r\nstring , carved on a rock below the temple’s gates. Asterix supposed\r\nthat that’s the password that opens the temple and read the string\r\naloud. However, nothing happened. Then Asterix supposed that a password\r\nis some substring of the string .Prefix supposed that the substring is\r\nthe beginning of the string ; Suffix supposed that the substring should\r\nbe the end of the string ; and Obelix supposed that should be located\r\nsomewhere inside the string , that is, is neither its beginning, nor its\r\nend.Asterix chose the substring so as to please all his companions.\r\nBesides, from all acceptable variants Asterix chose the longest one (as\r\nAsterix loves long strings). When Asterix read the substring aloud, the\r\ntemple doors opened. You know the string . Find the substring or\r\ndetermine that such substring does not exist and all that’s been written\r\nabove is just a nice legend.\r\n",
    "solutions": [
        "// Friendship is Magic\n#pragma comment(linker, \"/STACK:32000000\")\n\n#include <memory.h>\n#include <string.h>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define maxn 1000005\n\nchar s[maxn];\nint z[maxn];\nint n;\n\nvoid czf(char *s, int *z) {\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > r) {            \n            int k = 0;\n            while (i+k < n && s[i+k] == s[k]) k++;\n            if (k > 0) l = i, r = i+k-1;\n            z[i] = k;\n        } else {\n            int j = i-l, b = r-i+1;\n            if (z[j] < b) {\n                z[i] = z[j];\n            } else {\n                int k = 1;\n                while (r + k < n && s[r+k] == s[b+k-1]) k++;\n                l = i; r = r+k-1; z[i] = r-l+1;\n            }\n        }\n    }\n}\n\nvoid do_solve() {\n    scanf(\"%s\", s);\n    n = strlen(s);\n    czf(s, z);\n    int mx = 0;\n    //for (int i = 1; i < n; i++) mx = max(mx, z[i]);\n    int res = 0;\n    for (int i = n-2; i >= 1; i--)\n    {\n        mx = max(mx, z[n-i-1]);\n        if (z[n-i] == i && mx >= i)\n        {\n            res = i;\n            break;\n        }\n    }\n    if (res == 0)\n    {\n        printf(\"Just a legend\");\n        return;\n    }\n    s[res] = 0;\n    printf(\"%s\", s);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    do_solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Password.json",
    "editorial_link": "https://codeforces.com//blog/entry/3140",
    "editorial": "Let us calculate a prefix-function for all prefices of string. Prefix-function p[i] is maximal length of prefix that also is suffix of substring [1...i]. More about prefix function you can see in a description of Knuth-Morris-Pratt algorithm (KMP).\n\nThe first of possible answers is prefix of length p[n]. If p[n]?=?0, there is no solution. For checking the first possible answer you should iterate over p[i]. If at least one of them equal to p[n] (but not n-th, of course) - you found the answer. The second possible answer is prefix of length p[p[n]]. If p[p[n]]?=?0, you also have no solution. Otherwise you can be sure that the answer already found. This substring is a prefix and a suffix of our string. Also it is suffix of prefix with length p[n] that places inside of all string. This solution works in O(n).\n\nAlso this problem can be solved using hashing. You can find hash of every substring in O(1) and compare substrings by comparing thier hashes. Well, let's check for every prefix that it is a suffix of our string and store thier lengths into some array in the increasing order. Then, using binary search over the array, you can find maximal length of prefix that lie inside of string. Check of every prefix you can do in O(n). So, you have some  solution.\n\nIn point of fact, the array of prefix lengths in the previous solution is list { p[n], p[p[n]], ... }, that written if reversed order. From the first solution you know that the answer is prefix of length either p[n], or p[p[n]] (if it exists, of course). Therefore some naive solution without binary search can fits in the limits if you will stupidly check all prefices in the order of decrease thier lengths:) This solution works in O(n).\n\nAlso this problem can be solved using z-function.",
    "hint": []
}