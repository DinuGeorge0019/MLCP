{
    "link": "https://codeforces.com//contest/527/problem/B",
    "problemId": "24743",
    "problem_idx": "B",
    "shortId": "527B",
    "contest_number": "527",
    "problem_submissions": {
        "D": [
            10320998,
            10323329,
            10320418,
            10316376,
            10320868,
            10323389,
            10322440,
            10320232,
            10321604,
            10323582,
            10321959,
            10322883,
            10324771,
            10323891,
            10324342,
            10325751,
            10316899,
            10320622
        ],
        "C": [
            10319281,
            10317608,
            10318719,
            10321621,
            10319197,
            10319745,
            10320049,
            10325822,
            10321996,
            10320609,
            10320450,
            10322500,
            10322047,
            10318021,
            10323195,
            10322166,
            10322519,
            10313548
        ],
        "B": [
            10316733,
            10315414,
            10316286,
            10320342,
            10316974,
            10315178,
            10316059,
            10315345,
            10320022,
            10315992,
            10316397,
            10319742,
            10317580,
            10315069,
            10315584,
            10318949,
            10318891,
            10343112,
            10316418
        ],
        "A": [
            10313000,
            10313055,
            10313796,
            10312916,
            10313836,
            10313217,
            10312846,
            10312806,
            10313753,
            10312901,
            10312783,
            10313020,
            10313144,
            10312917,
            10312793,
            10312900,
            10314293,
            10313134
        ],
        "E": [
            11345011
        ]
    },
    "name": "B. Error Correct System",
    "statement": "Ford Prefect got a job as a web developer for a small company that makes\r\ntowels. His current work task is to create a search engine for the\r\nwebsite of the company. During the development process, he needs to\r\nwrite a subroutine for comparing strings and of equal length to be\r\n\"similar\". After a brief search on the Internet, he learned about the\r\nbetween two strings and of the same length, which is defined as the\r\nnumber of positions in which and have different characters. For example,\r\nthe Hamming distance between words \"\" and \"\" is two, as these words\r\ndiffer in the fourth and sixth letters.Moreover, as he was searching for\r\ninformation, he also noticed that modern search engines have powerful\r\nmechanisms to correct errors in the request to improve the quality of\r\nsearch. Ford doesn\u2019t know much about human beings, so he assumed that\r\nthe most common mistake in a request is swapping two arbitrary letters\r\nof the string (not necessarily adjacent). Now he wants to write a\r\nfunction that determines which two letters should be swapped in string ,\r\nso that the Hamming distance between a new string and string would be as\r\nsmall as possible, or otherwise, determine that such a replacement\r\ncannot reduce the distance between the strings.Help him do this!\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst int N = 30, L = 2e5 + 5;\nint n, ans;\nchar s[L], t[L];\nbool app[N][N];\nvector<int> pos[N];\n\ninline bool check2() {\n\tint p1, p2;\n\tbool f1 = false, f2 = false;\n\tfor (int i = 0; i <= 25; ++i)\n\t\tfor (int j = 0; j <= 25; ++j)\n\t\t\tif (i != j)\n\t\t\t\tif (app[i][j] && app[j][i]) {\n\t\t\t\t\tans -= 2;\n\t\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\t\tif (!f1 && s[k] - 'a' == i && t[k] - 'a' == j) {\n\t\t\t\t\t\t\tf1 = true;\n\t\t\t\t\t\t\tp1 = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!f2 && s[k] - 'a' == j && t[k] - 'a' == i) {\n\t\t\t\t\t\t\tf2 = true;\n\t\t\t\t\t\t\tp2 = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p1 > p2) swap(p1, p2);\n\t\t\t\t\tprintf(\"%d\\n%d %d\\n\", ans, p1 + 1, p2 + 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\treturn false;\n}\n\ninline bool check1() {\n\tfor (int i = 0; i < n; ++i)\n\t\tif (s[i] != t[i]) {\n\t\t\tif (pos[t[i] - 'a'].size() == 0) continue;\n\t\t\tint p1 = i, p2 = pos[t[i] - 'a'][0];\n\t\t\t--ans;\n\t\t\tif (p1 > p2) swap(p1, p2);\n\t\t\tprintf(\"%d\\n%d %d\\n\", ans, p1 + 1, p2 + 1);\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s%s\", s, t);\n\tfor (int i = 0; i < n; ++i)\n\t\tif (s[i] != t[i]) {\n\t\t\t++ans;\n\t\t\tapp[t[i] - 'a'][s[i] - 'a'] = true;\n\t\t\tpos[s[i] - 'a'].push_back(i);\n\t\t}\n\tif (check2()) return 0;\n\tif (check1()) return 0;\n\tprintf(\"%d\\n\", ans);\n\tputs(\"-1 -1\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Error Correct System.json",
    "editorial_link": "https://codeforces.com//blog/entry/17020",
    "editorial": "The first observation is that the new Hamming distance may not be less\r\nthan the old one minus two, since we change only two characters. So the\r\ntask is to actually determine, if we can attain decrease by two, one or\r\ncan t attain decrease at all. The decrease by two is possible if there\r\nare two positions with the same two letters in two strings but that\r\nappear in different order (like double <-> bundle ). If there are no\r\nsuch positions, then we just need to check that we may decrease the\r\ndistance. This can be done by just fixing the character that stands on\r\nthe wrong position, like in permanent <-> pergament (here n stands in\r\nwrong pair with m, and there is also unmatched m, so we may fix this\r\nposition). Otherwise, the answer is to keep everything as it is.\r\nImplementation can be done by keeping for each pair (x, y) of symbols\r\nposition where such pair appears in S and T and then by carefully\r\nchecking the conditions above. Obviously the largest glass piece at any\r\nmoment is the one that is product of the largest horizontal segment by\r\nthe largest vertical segment. One of the possible solutions is to\r\ncarefully implement what described in the statement and keep all\r\nhorizontal segments and all vertical segments in priority queue or\r\nstd::set, or some logarithmic data structure. This solution works in .\r\nBut there is also a nice linear solution if we answer all queries in\r\nreverse order. Suppose segments are not cutting, but merging. In this\r\ncase we may keep the horizontal and vertical cut lines in double-linked\r\nlists and track the current maximum (that can only increase and become\r\nequal to the newly-merged segment each time). This solution works in .\r\nOne may think that this task is about graph theory, but it after some\r\ninvestigation and several equivalent changes in task statement it can be\r\nreduced to the well-known greedy problem. Initially you have that points\r\nmay lie together in a set if they are not too close, i. e. . This is\r\nobviously equivalent to the following condition. Let s consider interval\r\nof radius with center in point and call this interval to be the interval\r\nof point i. Then the statement actually says that no two such intervals\r\nshould be intersecting. This task is well-known and can be solved\r\ngreedily after sorting segments in ascending order of right endpoint: It\r\ns easy to prove that this solution is correct. Among all ways to choose\r\nfirst segments, the best way is the one that minimizes x-coordinate of\r\nthe right endpoint of the last segment (since it restricts us in the\r\nleast possible way). Problem legend asks you to add minimum number of\r\nedges to the given connected undirected graph (possibly, with loops and\r\nduplicating edges) and choose direction for its edges so that both the\r\nincoming and outgoing degrees of all vertices are even. First idea is\r\nthat the resulting graph before we choose the direction (but after we\r\nadded some edges) will contain Euler circuit, since all degrees are\r\neven. That s almost what we need: if we have an Euler circuit that\r\ncontains even number of edges, we may direct them like following: a <- b\r\n-> c <- d -> e It s easy to see that each vertex appearance in this\r\ncycle adds 2 to its ingoing or outgoing degree, so the resulting degrees\r\nwill be even. But if the Euler circuit is odd (meaning that there is odd\r\nnumber of edges in the graph), we must add some extra edge to the graph\r\nbefore we continue, the easiest way is to add a loop from vertex 0 to\r\nitself, since it doesn t affect the Euler tour, but now tour length is\r\neven, so everything is ok. Now we should think how to add edges\r\noptimally. It s easy to see that the optimal way is to first fix all odd\r\ndegrees of vertices (i. e. combine all odd vertices by pairs and put an\r\nedge in each pair), and then, possibly, add an extra loop as described\r\nabove. The last part is to actually find an Euler circuit, and to print\r\nthe answer. There were issues with this task. Intended constraints were\r\nactually , and the intended solution was using Fast Fourier\r\nTransformation, that leads to running time. But unfortunately the\r\nstatement contained wrong constraints, so we reduced input size during\r\nthe tour. Nevertheless, we will add the harder version of this task and\r\nyou will be able to submit it shortly. Key idea is to reduce this task\r\nto a polynomial multiplication. Let s solve the task in following\r\nmanner. For each position i of the S for each character c from ATGC we\r\nwill calculate match(c, i) that is equal to the number of c characters\r\nthat have matching symbol in S if we put string T in position i. Then\r\nthe criteria for us to have an occurrence at position i is that match(A,\r\ni) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly\r\nthat each character from T being put at position i has a corresponding\r\ncharacter in S). Now let s find out how to calculate match(c, i). Let s\r\nkeep only c characters and not c characters in both strings and denote\r\nthem by 1 and 0 respectively. Let s also spread each 1 in string S by\r\nthe distance k to the left and to the right. For example, k = 1 for the\r\nsample string AGCAATTCAT and the character A corresponding bit vector\r\nwill be 111110111, and for the character C it will be 0111001110. This\r\nbitvector can be calculated in by putting two events +1 and -1 in string\r\nS in positions and for each in original string S and then sweeping from\r\nleft to right over the string S and processing those events. Now our\r\ntask is reduced to searching all positions where the bitvector T is the\r\nsubmask of the bitvector S. In constraints this can be done by using\r\nbitsets in . Nevertheless, this task can be seen as calculation of\r\npolynomials S and reversed(T) product. We will keep this as an exercise\r\nfor those who decide to submit the harder version of this task. Let s\r\ndraw a bounding box that contains all intersection points. Let s fix a\r\ntriangle and consider three angles shown on the picture. Calculate area\r\nof intersection of those area with the bounding box and call this area\r\nto be the area of an angle . Then it s easy to see, that those three\r\nangles are complement to the triangle itself in the bounding box, i. e.\r\ntriangle area is bounding box area minus three angle areas. This leads\r\nus to the idea how to solve this task by carefully calculating for each\r\npossible formed angle on the plane, how much times does it appear in\r\ntotal answer if we sum all values like over all triples of lines.\r\nActually, the angle is considered as many times, as many lines there are\r\nthat intersect both sides of its right adjacent angle. So, our task is\r\nreduced to calculate for each angle on plane how much lines intersect\r\nits sides (i. e. its rays). This can be done in by fixing the first side\r\nof the angle and then adding lines in ascending order of polar angle,\r\nand then by keeping the number of lines that intersect the base line to\r\nthe left and that intersect the base line to the right. Key idea is that\r\nthe exact of four angles formed by the pair of lines that is crossed by\r\nsome third line c, can be determined by two numbers: its polar angle\r\nalpha and its crossing with a coordinate x. Further details are shown on\r\nthe picture below. There is also a nice short solution from enot110\r\nhere.\r\n"
}