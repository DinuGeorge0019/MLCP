{
    "link": "https://codeforces.com//contest/1201/problem/D",
    "problemId": "383827",
    "problem_idx": "D",
    "shortId": "1201D",
    "contest_number": "1201",
    "problem_submissions": {
        "D": [
            58282984,
            58285276,
            58288662,
            58287120,
            58288428,
            58288088,
            58287196,
            58286940,
            58293709,
            58290148,
            58292701,
            58291902,
            58289292,
            58289457,
            58289281,
            58288685,
            58285856,
            58292531
        ],
        "C": [
            58274262,
            58275378,
            58275429,
            116632449,
            116631019,
            58275062,
            58276963,
            58278514,
            58276803,
            58277770,
            58276940,
            58274085,
            58273643,
            58275528,
            58274524,
            58274700,
            58277775,
            58274570,
            58271303,
            58273056
        ],
        "B": [
            58271978,
            58270841,
            58272256,
            58272912,
            58273123,
            58271671,
            58271261,
            58275291,
            58272166,
            58271760,
            58271053,
            58271553,
            58271578,
            58272097,
            58275948,
            58271369,
            58278712,
            58274589
        ],
        "A": [
            58270131,
            58270185,
            58270752,
            58271799,
            58270882,
            58270392,
            58270232,
            58273480,
            58270504,
            58270476,
            58308382,
            58270298,
            58270453,
            58270435,
            58270635,
            58270730,
            58270229,
            58270187,
            58276880
        ],
        "E1": [
            58306902,
            58388117,
            58386937
        ],
        "E2": [
            58306808
        ]
    },
    "name": "D. Treasure Hunting",
    "statement": "You are on the island which can be represented as a n\r\ntimes m table. The rows are numbered from 1 to n and the columns are\r\nnumbered from 1 to m. There are k treasures on the island, the i-th of\r\nthem is located at the position (r_i, c_i).Initially you stand at the\r\nlower left corner of the island, at the position (1, 1). If at any\r\nmoment you are at the cell with a treasure, you can pick it up without\r\nany extra time. In one move you can move up (from (r, c) to (r+1, c)),\r\nleft (from (r, c) to (r, c-1)), or right (from position (r, c) to (r,\r\nc+1)). Because of the traps, you can\u2019t move down.However, moving up is\r\nalso risky. You can move up only if you are in a safe column. There are\r\nq safe columns: b_1, b_2,\r\nldots, b_q. You want to collect all the treasures as fast as possible.\r\nCount the minimum number of moves required to collect all the treasures.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nvector<int> p[maxn];\nint b[maxn];\n\nint main() {\n    int n, m, k, q; scanf(\"%d%d%d%d\", &n, &m, &k, &q);\n    int tp = 0;\n    for (int i = 0; i < k; ++i) {\n        int r, c; scanf(\"%d%d\", &r, &c);\n        p[r].push_back(c);\n        tp = max(tp, r);\n    }\n    for (int i = 0; i < q; ++i) scanf(\"%d\", &b[i]);\n    sort(b, b + q);\n    \n    int prv = 1, s = 1;\n    vector<pair<int, long long>> cand;\n\n    if (p[1].empty()) {\n        for (int i = 0; i < q; ++i) cand.emplace_back(b[i], b[i] - 1); \n        s = 2;\n    } else {\n        cand = {make_pair(1, 0)};\n    }\n\n    for (int i = s; i <= n; ++i) {\n        if (p[i].empty()) continue;\n        sort(p[i].begin(), p[i].end());\n        int dist = i - prv;\n        int lb = p[i].front(), rb = p[i].back();\n        long long ld = 1e18, rd = 1e18;\n\n        for (int j = 0; j < (int)cand.size(); ++j) {\n            long long ldp = cand[j].second + abs(cand[j].first - rb) + abs(rb - lb) + dist;\n            long long rdp = cand[j].second + abs(cand[j].first - lb) + abs(rb - lb) + dist;\n            ld = min(ld, ldp);\n            rd = min(rd, rdp);\n        }\n\n        if (i == tp) {\n            printf(\"%lld\\n\", min(ld, rd));\n            return 0;\n        }\n\n        int pos = lower_bound(b, b + q, lb) - b;\n        vector<pair<int, long long>> ncand;\n        if (pos != q) ncand.emplace_back(b[pos], ld + abs(b[pos] - lb));\n        if (pos > 0) ncand.emplace_back(b[pos - 1], ld + abs(b[pos - 1] - lb));\n        pos = lower_bound(b, b + q, rb) - b;\n        if (pos != q) ncand.emplace_back(b[pos], rd + abs(b[pos] - rb));\n        if (pos > 0) ncand.emplace_back(b[pos - 1], rd + abs(b[pos - 1] - rb));\n\n        cand = ncand;\n        prv = i;\n    }\n    assert(false);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Treasure Hunting.json",
    "editorial_link": "https://codeforces.com/blog/entry/68911",
    "editorial": "Make two arrays: left and right. is the treasure in the leftmost\r\nposition in row i (0 if there are no treasures in row ). is the treasure\r\nin the rightmost cell in row (0 if there are no treasures in row ).We\r\ncan simply take out rows where there is no treasure (and add 1 to the\r\nresult if there are treasure above that line, because we have to move up\r\nthere).For every row, except the last, we have to leave that row at one\r\nof the safe columns. Let\u00e2\u0080\u0099s notice that the last treasure we collect in\r\nthe row will be either or . Let\u00e2\u0080\u0099s take a look at both possibilities: If\r\nwe collect the treasure last, we have to leave the row either going left\r\nor going right to the closest safe column, because going further\r\nwouldn\u00e2\u0080\u0099t worth it (consider moving up earlier and keep doing the same\r\nthing at row ). The same is true for . For the first row, we start at\r\nthe first column, we can calculate the moves required to go up the\r\nsecond row at the for cells. For all the other rows, we have 4\r\npossibilities, and we have to calculate how many moves it takes to reach\r\nthe row at the 4 possible columns. For the last row, we don\u00e2\u0080\u0099t have to\r\nreach a safe column, we just have to collect all the treasures there. We\r\ncan count the answer for the problem from the calculated results from\r\nthe previous row. Time complexity:\r\n"
}