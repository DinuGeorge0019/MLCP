{
    "link": "https://codeforces.com//contest/721/problem/E",
    "problemId": "73871",
    "problem_idx": "E",
    "shortId": "721E",
    "contest_number": "721",
    "problem_submissions": {
        "E": [
            21042234,
            21104290,
            21041800,
            21039130,
            21182080
        ],
        "D": [
            21029644,
            21033019,
            21030262,
            21053351,
            21030654,
            21028935,
            21032532,
            21032446,
            21031468,
            21029821,
            21033557,
            21036571,
            21034746,
            21031908,
            21028774,
            21033067,
            21034309,
            21035655,
            21033370,
            21035759
        ],
        "C": [
            21024340,
            21029695,
            21023653,
            21025311,
            21023065,
            21023920,
            21023708,
            21027694,
            21026337,
            21025612,
            21024290,
            21025832,
            21026823,
            21026753,
            21033393,
            21026369,
            21027659,
            21024234,
            21028054,
            21028402
        ],
        "B": [
            21020547,
            21023831,
            21019117,
            21020848,
            21020236,
            21018793,
            21019630,
            21018806,
            21021097,
            21020368,
            21019611,
            21018664,
            21023267,
            21021687,
            21020531,
            21019677,
            21021078,
            21019653,
            21021642,
            21022060
        ],
        "A": [
            21016747,
            21016854,
            21016383,
            21017669,
            21020192,
            21016357,
            21016892,
            21016594,
            21016893,
            21016724,
            21016524,
            21016663,
            21017641,
            21017121,
            21017001,
            21016623,
            21017723,
            21016907,
            21017349,
            21018497
        ]
    },
    "name": "E. Road to Home",
    "statement": "Once Danil the student was returning home from tram stop lately by\r\nstraight road of length . The stop is located at the point , but the\r\nDanil’s home at the point . Danil goes from to with a constant speed and\r\ndoes not change direction of movement.There are street lights at the\r\nroad, each of which lights some continuous segment of the road. All of\r\nthe lightened segments do not share common points.Danil loves to sing,\r\nthus he wants to sing his favourite song over and over again during his\r\nwalk. As soon as non-lightened segments of the road scare him, he sings\r\nonly when he goes through the lightened segments.Danil passes distance\r\nwhile performing his favourite song once. Danil can’t start another\r\nperformance if the segment passed while performing is not fully\r\nlightened. Moreover, if Danil has taken a pause between two\r\nperformances, he is not performing while not having passed a segment of\r\nlength at least . Formally, Danil can start single performance at a\r\npoint only if every point of segment is lightened; If Danil has finished\r\nperforming at a point , then the next performance can be started only at\r\na point such that or satisfying the statement under the point .\r\nDetermine how many times Danil can perform his favourite song during his\r\nwalk from to .Please note that Danil does not break a single\r\nperformance, thus, started singing another time, he finishes singing\r\nwhen having a segment of length of passed from the performance start\r\npoint.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define N 100005\nusing namespace std;\n\nint m,n,p,t,f[N],g[N];\nvoid up(int k,int w,int x,int y){\n\tif (w+(y-x)/p>f[k]){\n\t\tf[k]=w+(y-x)/p; g[k]=x+(y-x)/p*p;\n\t} else if (w+(y-x)/p==f[k]){\n\t\tg[k]=min(g[k],x+(y-x)/p*p);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d%d\",&m,&n,&p,&t);\n\tint now=0,i,ans=0,x,y;\n\tg[0]=-t;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (now) now--;\n\t\tfor (; now<i && g[now]+t<=y; now++){\n\t\t\tif (g[now]+t<=x) up(i,f[now],x,y); else up(i,f[now],g[now]+t,y);\n\t\t}\n\t\tans=max(ans,f[i]);\n\t\tif (f[i-1]>f[i]){ f[i]=f[i-1]; g[i]=g[i-1]; }\n\t\telse if (f[i-1]==f[i]) g[i]=min(g[i],g[i-1]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Road to Home.json",
    "editorial_link": "https://codeforces.com//blog/entry/47457",
    "editorial": "Firstly, if we are in some segment and we are going to sing in it, we\r\nwant to sing as much as possible in this segment. So there are two cases\r\nfor each segment: either we sing in the segment while we can or we just\r\nskip it.Now we consider two different cases:1) If we have stopped\r\nsinging in the segment, then the distance we need to walk to reach the\r\nend of this segment is strictly less than . Letâs calculate two values\r\nthe answer (how many times we can sing a song) if we start from the\r\nbeginning of segment number (from ), and the answer if we start from (,\r\nas we already said before). To calculate the value using the value from\r\npoint , we have to find the segment which contains the point and the\r\nsegment which begins after this point. If we are in segment number , we\r\neither skip it and update next segment (), or start singing and update\r\nthe value in the point where we stop singing ().To find the segment\r\ncontaining point , we can use binary search or precalculate the required\r\nindices using iterations on the array of segments.Time complexity: or\r\n.2) Letâs use the fact that the answer is not greater than . For each\r\nvalue we calculate - the leftmost point where we can get it. We will\r\niterate on those values considering that we have already calculated for\r\nevery when we start calculating . Then if is before the beginning of\r\nsome segment, and is after its beginning, then we can try singing\r\nstarting from the beginning of this segment with performed songs\r\ncurrently, updating for next values (from till with the values ). Using\r\nthis fact we update the value for the largest answer, skipping the\r\npoints in the middle of the segment. To calculate these values we need a\r\ndata structure (for example, Fenwick tree) which sustains the minimum\r\nvalue on the suffix ( is the minimum on suffix beginning from element\r\nnumber ). All values are increasing, so we need only one variable to\r\nsustain the index of the segment we are using to update.How we have to\r\nconsider the points in the middle of some segment. So we have a variable\r\nstoring the index of the rightmost segment which begins before for\r\ncurrent answer . It may seem that the values from the beginning and from\r\nthe middle of some segment may be used in the wrong order, but itâs easy\r\nto prove that itâs not true.Copmplexity: . We can use a special updating\r\nstructure based on stack to get rid of Fenwick tree, then complexity\r\nwill be .\r\n",
    "hint": []
}