{"link": "https://codeforces.com//contest/133/problem/E", "problemId": "705", "problem_idx": "E", "shortId": "133E", "contest_number": "133", "problem_submissions": {"E": [924813, 923201, 925122, 924740, 923151, 925910, 928212, 925928, 924995, 923703, 924128, 929077, 924213, 924289], "D": [923670, 925451, 923404, 923731, 926478, 924800, 924588, 926856, 923474, 924032, 924197, 924879], "C": [921698, 921926, 921368, 921398, 921083, 921917, 922348, 919949, 921656, 922402, 921490, 922221, 929129, 921781, 920761, 921370, 922130], "B": [920321, 920624, 920117, 919992, 919882, 920500, 921070, 921364, 920093, 921113, 920430, 920262, 929115, 919964, 919777, 919852, 920879], "A": [919203, 919548, 919250, 919042, 919124, 919191, 920089, 921756, 919222, 920426, 919339, 918987, 918923, 918953, 918882, 918982]}, "name": "E. Logo Turtle", "statement": "A lot of people associate Logo programming language with turtle\r\ngraphics. In this case the turtle moves along the straight line and\r\naccepts commands \"\" (\"turn around\") and \"\" (\"move 1 unit forward\").You\r\nare given a list of commands that will be given to the turtle. You have\r\nto change exactly commands from the list (one command can be changed\r\nseveral times). How far from the starting point can the turtle move\r\nafter it follows the commands of the modified list?\r\n", "solutions": ["#include <cstdio>\n#include <string>\n#include <map>\n#include <cstring>\n#include <bitset>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <memory.h>\n#include <list>\n#include <vector>\n#include <set>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define sqr(n)  (n)*(n)\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define INF 2000000000\n\ntypedef long long ll;\n\nint D[200][60][2][2];\n\nint bestMax(int a, int b){\n    if(a==1000)\n        return b;\n    if(b==1000)\n        return a;\n    return max(a,b);\n}\n\nint bestMin(int a, int b){\n    if(a==1000)\n        return b;\n    if(b==1000)\n        return a;\n    return min(a,b);\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n    int N;\n    scanf(\"%d\",&N);\n    for(int i = 0; i < 200; i++)\n        for(int j = 0; j < 60; j++)\n            for(int k = 0; k < 2; k++)\n                D[i][j][k][0] = D[i][j][k][1] = 1000;\n    D[0][N][0][0] = D[0][N][0][1] = 0;\n    for(int i = 0; i < s.size(); i++)\n    {\n        for(int j = 0; j <= N; j++)\n        {\n            for(int k = 0; k < 2; k++){\n                for(int way = 0; way < 2; way++){\n                    if(D[i][j][k][way] == 1000)\n                        continue;\n                    int step = k==0?1:-1;\n                    if(s[i]=='T'){\n                        for(int z = 0; z <= j; z+=2){\n                            D[i+1][j-z][(k+1)%2][0] = bestMin(D[i+1][j-z][(k+1)%2][0],D[i][j][k][way]);\n                            D[i+1][j-z][(k+1)%2][1] = bestMax(D[i+1][j-z][(k+1)%2][1],D[i][j][k][way]);\n                        }\n                        for(int z = 1; z <= j; z+=2){\n                            D[i+1][j-z][k][0] = bestMin(D[i+1][j-z][k][0],D[i][j][k][way]+step);\n                            D[i+1][j-z][k][1] = bestMax(D[i+1][j-z][k][1],D[i][j][k][way]+step);\n                        }\n                    }\n                    else{\n                        for(int z = 1; z <= j; z+=2){\n                            D[i+1][j-z][(k+1)%2][0] = bestMin(D[i+1][j-z][(k+1)%2][0],D[i][j][k][way]);\n                            D[i+1][j-z][(k+1)%2][1] = bestMax(D[i+1][j-z][(k+1)%2][1],D[i][j][k][way]);\n                        }\n                        for(int z = 0; z <= j; z+=2){\n                            D[i+1][j-z][k][0] = bestMin(D[i+1][j-z][k][0],D[i][j][k][way]+step);\n                            D[i+1][j-z][k][1] = bestMax(D[i+1][j-z][k][1],D[i][j][k][way]+step);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int result = 0;\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++)\n            if(D[s.size()][0][i][j]!=1000)\n                result = max(result, abs(D[s.size()][0][i][j]));\n    printf(\"%d\",result);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "implementation"], "dificulty": "1800", "interactive": false}