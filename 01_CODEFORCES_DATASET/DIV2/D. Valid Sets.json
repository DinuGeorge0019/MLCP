{"link": "https://codeforces.com//contest/486/problem/D", "problemId": "17062", "problem_idx": "D", "shortId": "486D", "contest_number": "486", "problem_submissions": {"C": [8656712, 8654869, 8655277, 8661715, 8659367, 8661623, 8671659, 8658387, 44544902, 8655041, 8655195, 8655046, 8655532, 8655723, 8654982, 8655530, 8654402, 8657095, 8655223, 8663823, 8658911], "D": [8656322, 8653249, 8657902, 8655199, 8657521, 8656772, 8655987, 8654471, 8762125, 8656998, 8658007, 8658299, 8659044, 8659007, 8659117, 8660760, 8660451, 8663779], "A": [8652840, 8649416, 8649905, 8649569, 8649694, 8650271, 8649886, 8649533, 8650061, 8649465, 8650144, 8650093, 8650370, 8649662, 8650038, 8650934, 8649593, 8649948, 8650270, 8663811, 8649707], "B": [8652668, 8652141, 8652012, 8652630, 8653907, 8652325, 8651841, 8653366, 8651435, 8652387, 8652466, 8652574, 8652046, 8653190, 8652712, 8651972, 8656481, 8651946, 8663812, 8652791], "E": [8651853, 8654712, 8659740, 8659484, 8661000, 8661038, 8654891, 8659823, 8952883, 8658117, 8661158, 8666251, 8659593, 8663820, 8660769]}, "name": "D. Valid Sets", "statement": "As you know, an undirected connected graph with nodes and edges is\r\ncalled a . You are given an integer and a tree consisting of nodes. Each\r\nnode has a value associated with it.We call a set of tree nodes if\r\nfollowing conditions are satisfied: is non-empty. is connected. In other\r\nwords, if nodes and are in , then all nodes lying on the simple path\r\nbetween and should also be presented in . .Your task is to count the\r\nnumber of valid sets. Since the result can be very large, you must print\r\nits remainder modulo ().\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define mod 1000000007\n#define maxn 2010\n#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\ntypedef long long LL;\nbool use[maxn];\nint dp[maxn][2][2],a[maxn],n,d,l,r;\nint nEdge=1,to[maxn*2],next[maxn*2],start[maxn];\nvoid add(int &a,int b)\n{\n    a+=b;\n    if(a>=mod)\n        a-=mod;\n}\nvoid make(int a,int b)\n{\n    ++nEdge,to[nEdge]=b,next[nEdge]=start[a],start[a]=nEdge;\n}\nvoid read()\n{\n    scanf(\"%d %d\",&d,&n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%d\",a+i);\n    for(int i=2,x,y;i<=n;++i)\n    {\n        scanf(\"%d %d\",&x,&y);\n        make(x,y),make(y,x);\n    }\n}\nvoid Tree_Dp(int p)\n{\n    if(a[p]>=l&&a[p]<=r)\n        dp[p][1][a[p]==l]=1,dp[p][1][1]=1;\n    dp[p][0][0]=1;\n    use[p]=true;\n    for(int i=start[p];i;i=next[i])\n        if(!use[to[i]])\n        {\n            Tree_Dp(to[i]);\n            add(dp[p][0][0],dp[to[i]][0][0]);\n            add(dp[p][0][0],dp[to[i]][1][0]);\n            add(dp[p][0][1],dp[to[i]][0][1]);\n            add(dp[p][0][1],dp[to[i]][1][1]);\n            if(a[p]==l)\n                dp[p][1][1]=(LL)dp[p][1][1]*(dp[to[i]][1][0]+dp[to[i]][1][1]+1)%mod;\n            else if(a[p]>=l&&a[p]<=r)\n            {\n                dp[p][1][0]=(LL)dp[p][1][0]*(dp[to[i]][1][0]+1)%mod;\n                dp[p][1][1]=(LL)dp[p][1][1]*(dp[to[i]][1][0]+dp[to[i]][1][1]+1)%mod;\n            }\n        }\n    add(dp[p][1][1],mod-dp[p][1][0]),add(dp[p][0][0],mod-1);\n}\nvoid work()\n{\n    int ans=0;\n    for(int i=1;i<=2000;++i)\n        if(find(a+1,a+n+1,i)-a!=n+1)\n        {\n            memset(dp,0,sizeof(dp));\n            memset(use,false,sizeof(use));\n            l=i,r=i+d;\n            Tree_Dp(1);\n            add(ans,dp[1][0][1]),add(ans,dp[1][1][1]);\n        }\n    printf(\"%d\\n\",ans);\n}\nint main()\n{\n    read();\n    work();\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "math", "trees"], "dificulty": "2100", "interactive": false}