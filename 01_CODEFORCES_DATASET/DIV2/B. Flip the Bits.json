{"link": "https://codeforces.com//contest/1504/problem/B", "problemId": "945464", "problem_idx": "B", "shortId": "1504B", "contest_number": "1504", "problem_submissions": {"F": [111935045], "E": [111919537, 111908818, 111915476, 111922174, 111919354, 111912277, 111926667, 111933626, 111923368, 111927972, 111922895, 111929837, 111918921, 111930705, 111931199, 111927831, 111933167, 111936231, 111927723], "D": [111903831, 111898035, 111906622, 111906753, 111900341, 111920726, 111905882, 111889202, 111908288, 111906401, 111899954, 111909419, 111914558, 111906091, 111907496, 111910516, 111906791, 111899242, 111913796], "C": [111894612, 111888998, 111897074, 111891045, 111894960, 111894678, 111893967, 111898677, 111898779, 111894676, 111891710, 111887088, 111899272, 111894062, 111898183, 111901135, 111896065, 111907589, 111899883], "B": [111886123, 111877937, 111882311, 111876691, 111883851, 111877415, 111875995, 111877870, 111879515, 111885430, 111904265, 111879266, 111878112, 111883768, 111877486, 111882773, 111887115, 111878394, 111891154], "A": [111877837, 111872895, 111873662, 111872585, 111875452, 111883020, 111872169, 111872988, 111873021, 111873751, 111907400, 111872188, 111872713, 111872621, 111882814, 111875730, 111872954, 111872953, 111883462]}, "name": "B. Flip the Bits", "statement": "There is a binary string a of length n. In one operation, you can select\r\nany prefix of a with an number of 0 and 1 symbols. Then all symbols in\r\nthe prefix are inverted: each 0 becomes 1 and each 1 becomes 0.For\r\nexample, suppose a=0111010000. In the first operation, we can select the\r\nprefix of length 8 since it has four 0\u2019s and four 1\u2019s: [01110100]00\r\nto [10001011]00. In the second operation, we can select the prefix of\r\nlength 2 since it has one 0 and one 1: [10]00101100\r\nto [01]00101100. It is illegal to select the prefix of length 4 for the\r\nthird operation, because it has three 0\u2019s and one 1. Can you transform\r\nthe string a into the string b using some finite number of operations\r\n(possibly, none)?\r\n", "solutions": ["#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n    char ch;\n    while(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n    if (ch=='-'){\n        int s=0;\n        while(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n        return -s;\n    }\n    int s=ch-'0';\n    while(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n    return s;\n}\n\nconst int N = 3e5+5;\n\nint n;\nchar a[N],b[N];\nint A[N],B[N];\nbool suf[N][2];\n\nint main(){\n    for(int T=get();T;T--){\n        n=get();\n        scanf(\"%s\",a+1);\n        scanf(\"%s\",b+1);\n        fo(i,1,n){\n            A[i]=a[i]-'0';\n            B[i]=b[i]-'0';\n            suf[i][0]=suf[i][1]=0;\n        }\n        suf[0][0]=suf[0][1]=1;\n        int pre=0;\n        fo(i,1,n){\n            int v=A[i] xor B[i];\n            if (A[i]) pre++; else pre--;\n            suf[i][v]=suf[i-1][v];\n            if (pre==0)suf[i][v^1]=suf[i-1][v];\n        }\n        if (suf[n][0])printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "implementation", "math"], "dificulty": "1200", "interactive": false}