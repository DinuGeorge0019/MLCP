{
    "link": "https://codeforces.com//contest/1422/problem/F",
    "problemId": "748728",
    "problem_idx": "F",
    "shortId": "1422F",
    "contest_number": "1422",
    "problem_submissions": {
        "F": [
            94701883,
            94826866,
            94826835,
            94745688,
            94705379,
            94693551,
            94953245,
            94915043,
            94711007,
            94710952
        ],
        "D": [
            94689176,
            94687852,
            94699245,
            94700756,
            94730858,
            94685919,
            94687412,
            94684031,
            94691326,
            94692798,
            209847951,
            94692199,
            94693976,
            94690624,
            94695759,
            95022837,
            94688084,
            94690199
        ],
        "C": [
            94679953,
            94679288,
            94678596,
            94684155,
            94679523,
            94703846,
            94668997,
            94676012,
            94678225,
            94681262,
            94689674,
            94678418,
            94678427,
            94678143,
            94682123,
            94677251,
            94684478,
            94676757,
            94679761
        ],
        "B": [
            94670303,
            94669460,
            94669121,
            94671181,
            94667987,
            94697716,
            94673035,
            94667020,
            94667631,
            94669211,
            94678649,
            94671772,
            94672654,
            94668738,
            94675426,
            94669613,
            94671963,
            94668373,
            94672738
        ],
        "A": [
            94662989,
            94664962,
            97569670,
            94661799,
            94662880,
            94662335,
            94664103,
            94661944,
            94661473,
            94662039,
            94663061,
            94665832,
            94661500,
            94664606,
            94661429,
            94662035,
            94661746,
            94661457,
            94662741,
            94673552
        ],
        "E": [
            94701493,
            94708058,
            94709364,
            94747586,
            95060609,
            95041928,
            94699655,
            94723718,
            94704623
        ]
    },
    "name": "F. Boring Queries",
    "statement": "Yura owns a quite ordinary and boring array a of length n. You think\r\nthere is nothing more boring than that, but Vladik doesn’t agree!In\r\norder to make Yura’s array even more boring, Vladik makes q boring\r\nqueries. Each query consists of two integers x and y. Before answering a\r\nquery, the bounds l and r for this query are calculated: l = (last + x)\r\nbmod n + 1, r = (last + y)\r\nbmod n + 1, where last is the answer on the previous query (zero\r\ninitially), and\r\nbmod is the remainder operation. Whenever l > r, they are swapped.After\r\nVladik computes l and r for a query, he is to compute the least common\r\nmultiple (LCM) on the segment [l; r] of the initial array a modulo\r\n10^9 + 7. LCM of a multiset of integers is the smallest positive integer\r\nthat is divisible by all the elements of the multiset. The obtained LCM\r\nis the answer for this query.Help Vladik and compute the answer for each\r\nquery!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch=='-')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nint n,m,a[N];\nI Pow(ll t,int x,ll s=1){\n\tfor(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;\n\treturn s;\n}\nnamespace T1{\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,n\n#define lson lc,L,mid\n#define rson rc,mid+1,R\n\tconst int B=sqrt(N),M=90;\n\tint tot,pri[N],tag[N];\n\tstruct node{\n\t\tint w[M];\n\t\tV ins(const node&u){\n\t\t\tFOR(i,1,86)cmax(w[i],u.w[i]);\n\t\t}\n\t\tV init(){FOR(i,1,86)w[i]=0;}\n\t\tI val(int out=1){\n\t\t\tFOR(i,1,86)out=Pow(pri[i],w[i],out);\n\t\t\treturn out;\n\t\t}\n\t}t[N<<2],tmp;\n\tV build(int p,int L,int R){\n\t\tif(L==R){\n\t\t\tFOR(i,1,86)\n\t\t\t\twhile(a[L]%pri[i]==0)\n\t\t\t\t\tt[p].w[i]++,a[L]/=pri[i];\n\t\t\treturn;\n\t\t}\n\t\tint mid=L+R>>1;\n\t\tbuild(lson),build(rson),t[p]=t[lc],t[p].ins(t[rc]);\n\t}\n\tV init(){\n\t\tint p;\n\t\tFOR(i,2,B){\n\t\t\tif(!tag[i])pri[++tot]=i;\n\t\t\tFOR(j,1,tot){\n\t\t\t\tif((p=i*pri[j])>B)break;\n\t\t\t\ttag[p]=1;\n\t\t\t\tif(i%pri[j]==0)break;\n\t\t\t}\n\t\t}\n\t\tbuild(root);\n\t}\n\tV ask(int p,int L,int R,int l,int r){\n\t\tif(L==l&&R==r)return tmp.ins(t[p]);\n\t\tint mid=L+R>>1;\n\t\tif(l>mid)return ask(rson,l,r);\n\t\tif(r<=mid)return ask(lson,l,r);\n\t\task(lson,l,mid),ask(rson,mid+1,r);\t\n\t}\n\tI ask(int l,int r){\n\t\ttmp.init();\n\t\task(root,l,r);\n\t\treturn tmp.val();\n\t}\n#undef lc\n#undef rc\n#undef root\n#undef lson\n#undef rson\n}\nnamespace T2{\n#define lc t[p].ls\n#define rc t[p].rs\n#define lson lc,L,mid\n#define rson rc,mid+1,R\n#define root(p) rt[p],1,n\n\tint tot,rt[N],last[N];\n\tstruct ele{\n\t\tint ls,rs,tag;\n\t}t[N<<5];\n\tV modify(int&p,int L,int R,int l,int r,int x){\n\t\tt[++tot]=t[p],p=tot;\n\t\tif(L==l&&R==r)return void(t[p].tag=1ll*t[p].tag*x%mod);\n\t\tint mid=L+R>>1;\n\t\tif(l>mid)return modify(rson,l,r,x);\n\t\tif(r<=mid)return modify(lson,l,r,x);\n\t\tmodify(lson,l,mid,x),modify(rson,mid+1,r,x);\n\t}\n\tV init(){\n\t\tt[0].tag=1;\n\t\tFOR(i,1,n)if(rt[i]=rt[i-1],a[i]>1)\n\t\t\tmodify(root(i),last[a[i]]+1,i,a[i]),last[a[i]]=i;\n\t}\n\tI ask(int p,int L,int R,int x){\n\t\tif(L==R)return t[p].tag;\n\t\tint mid=L+R>>1;\n\t\tif(x<=mid)return 1ll*t[p].tag*ask(lson,x)%mod;\n\t\tif(x> mid)return 1ll*t[p].tag*ask(rson,x)%mod;\n\t}\n\tI ask(int l,int r){return ask(root(r),l);}\n#undef lc\n#undef rc\n#undef root\n#undef lson\n#undef rson\n}\nV input(){\n\tn=getint();\n\tFOR(i,1,n)a[i]=getint();\n}\nV init(){\n\tT1::init(),T2::init();\n}\nV work(){\n\tint ans=0;\n\tm=getint();\n\tfor(int l,r;m--;cout<<ans<<'\\n'){\n\t\tl=(getint()+ans)%n+1,r=(getint()+ans)%n+1;\n\t\tif(l>r)swap(l,r);\n\t\tans=1ll*T1::ask(l,r)*T2::ask(l,r)%mod;\n\t}\n}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"test.out\",\"w\",stdout);\n//\tfor(scanf(\"%d\",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n//\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Boring Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/83452",
    "editorial": "In order to find the LCM of numbers on a segment, you can, for each\r\nprime number, find the maximum power with which it enters into any\r\nnumber on the segment and multiply the answer with this power. Letâs\r\ncalculate the LCM for primes less than and greater than separately using\r\nthe segment tree.There are prime numbers less than . Letâs store a\r\nsorted list of prime numbers with their maximum power in each subsegment\r\nof the tree. The union of two segments can be done in . Then the\r\nconstruction of the entire tree can be done in . In order to answer the\r\nquery, we split it into subsegments of the segment tree and sequentially\r\ncombine them in .For each number in the array, there will be no more\r\nthan one prime divisor greater than . For a query, you need to find the\r\nproduct of unique numbers on a segment. To do this, for each such simple\r\nnumber, find the closest position to the left in the array of the same\r\nprime number (or if there is no such number on the left). For a\r\nsubsegment, we will store a sorted list of pairs, and also pre-calculate\r\nthe product for each prefix. Now, for each subsegment of the tree that\r\nwill be included in the query , you need to select all such pairs for\r\nwhich and take product of . Since the list is ordered, all these numbers\r\nwill form a prefix. The prefix can be found using a binary search for\r\n.Total complexity , where (the number of primes up to the root).\r\n",
    "hint": []
}