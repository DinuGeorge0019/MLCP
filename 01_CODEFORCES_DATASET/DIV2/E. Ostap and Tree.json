{
    "link": "https://codeforces.com//contest/735/problem/E",
    "problemId": "82050",
    "problem_idx": "E",
    "shortId": "735E",
    "contest_number": "735",
    "problem_submissions": {
        "E": [
            22551909
        ],
        "D": [
            22544646,
            22538932,
            22538494,
            22533130,
            22538839,
            22534703,
            22542520,
            22538073,
            22538552,
            22544184,
            22540518,
            22540226,
            22540566,
            22541948,
            22536512,
            22543846,
            22534272,
            22543891,
            22542284,
            22535111
        ],
        "B": [
            22537273,
            22532854,
            22534320,
            22538199,
            22533929,
            22532194,
            22539115,
            22533382,
            22535165,
            22534258,
            22533972,
            22533579,
            22533796,
            22532602,
            22539678,
            22534871,
            22532255,
            22533784,
            22536534,
            22532104
        ],
        "C": [
            22534384,
            22535405,
            22546614,
            22545073,
            22541931,
            22538563,
            22536243,
            22534983,
            22543290,
            22541842,
            22536128,
            22536857,
            22538655,
            22536562,
            22534861,
            22538350,
            22539201,
            22542576,
            22543288,
            22543269
        ],
        "A": [
            22532849,
            22530580,
            22530636,
            22535838,
            22530703,
            22530451,
            22531034,
            22531009,
            22531797,
            22531370,
            22530550,
            22530672,
            22530851,
            22530651,
            22530865,
            22531281,
            22530612,
            22530842,
            22530502
        ]
    },
    "name": "E. Ostap and Tree",
    "statement": "Ostap already settled down in Rio de Janiero suburb and started to grow\r\na tree in his garden. Recall that a tree is a connected undirected\r\nacyclic graph. Ostap\u2019s tree now has vertices. He wants to paint some\r\nvertices of the tree black such that from any vertex there is at least\r\none black vertex at distance no more than . between two vertices of the\r\ntree is the minimum possible number of edges of the path between them.As\r\nthis number of ways to paint the tree can be large, Ostap wants you to\r\ncompute it modulo . Two ways to paint the tree are considered different\r\nif there exists a vertex that is painted black in one way and is not\r\npainted in the other one.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define task \"DBG\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int N = 101;\nconst ll M = 1e9 + 7;\n\nvector <int> adj[N];\nint n, k, p[N], Q[N];\n\nll dp[N][31][31], dp_t[31][31];\n\nvoid add(ll &a, ll b) {\n  a = (a + b) % M;\n}\n\nii Get(int x, int xx, int y, int yy) {\n  ii res;\n  if (y + xx <= k) y = 0;\n  else if (y) y++;\n  if (x + yy <= k) x = 0;\n  return make_pair(max(x, y), min(xx, yy + 1));\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n  assert(freopen(task\".INP\", \"r\", stdin));\n  assert(freopen(task\".OUT\", \"w\", stdout));\n#endif // ONLINE_JUDGE\n\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v; cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int L = 1, R = 1;\n  Q[1] = 1;\n  while (L <= R) {\n    int u = Q[L++];\n    for (auto v : adj[u]) {\n      if (v == p[u]) continue;\n      p[v] = u;\n      Q[++R] = v;\n    }\n  }\n\n  for (int i = n; i >= 1; i--) {\n    int u = Q[i];\n    dp[u][1][k + 1] = 1;\n    dp[u][0][0] = 1;\n\n    for (auto v : adj[u]) {\n      if (v == p[u]) continue;\n      for (int j1 = 0; j1 <= k + 1; j1++)\n        for (int j2 = 0; j2 <= k + 1; j2++)\n          dp_t[j1][j2] = dp[u][j1][j2];\n\n      memset(dp[u], 0, sizeof dp[u]);\n      for (int y = 0; y <= k + 1; y++)\n        for (int yy = 0; yy <= k + 1; yy++)\n          for (int x = 0; x <= k + 1; x++)\n            for (int xx = 0; xx <= k + 1; xx++) {\n              ii cur = Get(x, xx, y, yy);\n              int curx = cur.first, cury = cur.second;\n\n              if (curx == -1) continue;\n              add(dp[u][curx][cury], dp_t[x][xx] * dp[v][y][yy]);\n            }\n    }\n  }\n\n  ll ans = 0;\n  for (int i = 0; i <= k; i++)\n    add(ans, dp[1][0][i]);\n\n  return cout << ans, 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Ostap and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/48659",
    "editorial": "Problem can be solved by the method of dynamic programming. Let dp[v][i][j] be the number of possibilities to color subtree of vertex v in such a way that the closest black vertex is on depth i, and the closest white vertex \u0097 on depth j (we also store dp[v][-1][j] and dp[v][i][-1] in the cases where there are no black and white vertexes in diapason k of v respectively). In order to connect two subtrees, we can check all pairs (i,j) in both subtrees (by brute-force algorithm). Then let we have pair (a,c) in the first subtree and pair (b,d) in the second one. If min(a,c)+max(b,d)<=k, then we update value of current vertex.\n\nComplexity of the algorithm O(n*k^4), which is acceptable for this particular problem (n \u0097 the number of vertexes, k^4 brute force search of pairs (a,b); (c,d))."
}