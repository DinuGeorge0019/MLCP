{
    "link": "https://codeforces.com//contest/445/problem/D",
    "problemId": "11258",
    "problem_idx": "D",
    "shortId": "445D",
    "contest_number": "445",
    "problem_submissions": {
        "E": [
            7031344,
            7029564,
            7031729,
            7068922,
            7035909,
            7034442,
            7033387
        ],
        "C": [
            7025323,
            7027971,
            7026637,
            7030980,
            7028071,
            7028481,
            7024658,
            7025212,
            7025034,
            7025214,
            7025763,
            7024802,
            7023869,
            7024049,
            7023827,
            7026131,
            7026431
        ],
        "B": [
            7022932,
            7022406,
            7022331,
            7024786,
            7025216,
            7025923,
            7030833,
            7024955,
            7022701,
            7022564,
            7022789,
            7023593,
            7023467,
            7022262,
            7022269,
            7022887,
            7024673,
            7023418,
            7023287
        ],
        "A": [
            7021792,
            7021809,
            7021708,
            7022060,
            7022326,
            7021941,
            7023928,
            7023130,
            7021718,
            7021716,
            7021763,
            7021740,
            7021975,
            7024184,
            7027019,
            7027895,
            7025904,
            7022028,
            7021858
        ],
        "D": [
            7026779,
            7029902,
            7028957,
            7032143,
            7031896,
            7053884,
            7033436
        ]
    },
    "name": "D. DZY Loves FFT",
    "statement": "Fast Fourier Transformation is an algorithm used to calculate\r\nconvolution. Specifically, if , and are sequences with length , which\r\nare indexed from to , andWe can calculate fast using Fast Fourier\r\nTransformation.DZY made a little change on this formula. NowTo make\r\nthings easier, is a permutation of integers from to , and is a sequence\r\nonly containing and . Given and , DZY needs your help to calculate\r\n.Because he is naughty, DZY provides a special way to get and . What you\r\nneed is only three integers , , . After getting them, use the code below\r\nto generate and .//x is 64-bit variable;function getNextX() { x = (x *\r\n37 + 10007)\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\n\ntypedef long long qw;\n\n#ifdef WIN32\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\n\nconst int maxn = 100010;\n\nint n, m, a[maxn], b[maxn], r[maxn], c, l, s[maxn], bp[maxn], bt;\nqw d, x;\n\nqw getNextX() {\n    x = (x * 37 + 10007) % 1000000007;\n    return x;\n}\nvoid initAB() {\n\tint i;\n    for(i = 0; i < n; i = i + 1){\n        a[i] = i + 1;\n    }\n    for(i = 0; i < n; i = i + 1){\n        swap(a[i], a[getNextX() % (i + 1)]);\n    }\n    for(i = 0; i < n; i = i + 1){\n        if (i < d)\n            b[i] = 1;\n        else\n            b[i] = 0;\n    }\n    for(i = 0; i < n; i = i + 1){\n        swap(b[i], b[getNextX() % (i + 1)]);\n    }\n}\n\ninline bool cmpR(int x, int y) {\n\treturn a[x] > a[y];\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tmemset(s, -1, sizeof(s));\n\tscanf(\"%d\" lld lld, &n, &d, &x);\n\tinitAB();\n\tfor (int i = 0; i < n; i ++)\n\t\tr[i] = i;\n\tsort(r, r + n, cmpR);\n\tbt = 0;\n\tfor (int i = 0; i < n; i ++)\n\t\tif (b[i])\n\t\t\tbp[bt ++] = i;\n\tc = n;\n\tl = n;\n\tfor (int i = 0; i < n && c; i ++)\n\t\tfor (int j = 0; r[i] + bp[j] < l && j < bt; j ++)\n\t\t\tif (s[r[i] + bp[j]] == -1) {\n\t\t\t\ts[r[i] + bp[j]] = a[r[i]], c --;\n\t\t\t\twhile (l && s[l - 1] > -1)\n\t\t\t\t\tl --;\n\t\t\t}\n\tfor (int i = 0; i < n; i ++)\n\t\tif (s[i] == -1)\n\t\t\tputs(\"0\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", s[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. DZY Loves FFT.json",
    "editorial_link": "https://codeforces.com//blog/entry/12959",
    "editorial": "Firstly, you should notice that A, B are given randomly.\n\nThen there're many ways to solve this problem, I just introduce one of them.\n\nThis algorithm can get Ci one by one. Firstly, choose an s. Then check if Ci equals to n,?n?-?1,?n?-?2... n?-?s?+?1. If none of is the answer, just calculate Ci by brute force.\n\nThe excepted time complexity to calculate Ci?-?1 is around\n\n\nwhere .\n\nJust choose an s to make the formula as small as possible. The worst excepted number of operations is around tens of million."
}