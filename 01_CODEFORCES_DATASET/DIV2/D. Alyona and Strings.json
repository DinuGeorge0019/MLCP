{
    "link": "https://codeforces.com//contest/682/problem/D",
    "problemId": "62841",
    "problem_idx": "D",
    "shortId": "682D",
    "contest_number": "682",
    "problem_submissions": {
        "E": [
            18561879,
            18561336,
            18563426,
            18572191,
            18568838
        ],
        "D": [
            18555791,
            18558610,
            18560557,
            18552272,
            18555181,
            18555531,
            18555300,
            18555970,
            18554396,
            18555899,
            18557118,
            18557764,
            18557208,
            18556682,
            18552327,
            18556733,
            18558689,
            18554285,
            18556142,
            18557417
        ],
        "C": [
            18552544,
            18555995,
            18556311,
            18552880,
            18552350,
            18565999,
            18551727,
            18552070,
            18553200,
            18552786,
            18550786,
            18553141,
            18554015,
            18554928,
            18554671,
            18557194,
            18554246,
            18553490,
            18557896,
            18552468,
            18554757
        ],
        "B": [
            18548869,
            18549933,
            18550925,
            18548469,
            18549125,
            18547478,
            18548571,
            18548891,
            18548990,
            18548117,
            18548700,
            18549479,
            18547648,
            18549616,
            18547660,
            18549624,
            18549820,
            18555517,
            18549964,
            18549305
        ],
        "A": [
            18548806,
            18547357,
            18547853,
            18549155,
            18547571,
            18566378,
            18547486,
            18547744,
            18547663,
            18548239,
            18547470,
            18547490,
            18548002,
            18547325,
            18548103,
            18548001,
            18547695,
            18548749,
            18554886,
            18547503,
            18547920
        ]
    },
    "name": "D. Alyona and Strings",
    "statement": "After returned from forest, Alyona started reading a book. She noticed\r\nstrings and , lengths of which are and respectively. As usual, reading\r\nbored Alyona and she decided to pay her attention to strings and , which\r\nshe considered very similar.Alyona has her favourite positive integer\r\nand because she is too small, does not exceed . The girl wants now to\r\nchoose disjoint non-empty substrings of string such that these strings\r\nappear as disjoint substrings of string and in the same order as they do\r\nin string . She is also interested in that their length is maximum\r\npossible among all variants.Formally, Alyona wants to find a sequence of\r\nnon-empty strings satisfying following conditions: can be represented as\r\nconcatenation , where is a sequence of arbitrary strings (some of them\r\nmay be possibly empty); can be represented as concatenation , where is a\r\nsequence of arbitrary strings (some of them may be possibly empty); sum\r\nof the lengths of strings in sequence is maximum possible. Please help\r\nAlyona solve this complicated problem and find at least the sum of the\r\nlengths of the strings in a desired sequence.A of a string is a\r\nsubsequence of consecutive characters of the string.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint f[1001][1001][11];\nchar s1[1011],s2[1011];\nint len[1011][1011];\nint g[1001][1001][11];\n\nint m,n,q;\nint ans = 0;\nint main()\n{\n\tscanf(\"%d%d%d\",&m,&n,&q);\n\tscanf(\"%s\",s1+1);\n\tscanf(\"%s\",s2+1);\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(s1[i]==s2[j])\n\t\t\t\tlen[i][j]=len[i-1][j-1]+1;\n\t\t\telse\n\t\t\t\tlen[i][j]=0;\n\t\t\t\t\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int k=1;k<=q;k++)\n\t\t\t{\n\t\t\t\tint w = len[i][j];\n\t\t\t\tif(w!=0)\n\t\t\t\t\tf[i][j][k]=g[i-w][j-w][k-1]+w;\n\t\t\t\telse f[i][j][k]=0;\n\t\t\t\tg[i][j][k]=max(g[i][j][k],g[i-1][j][k]);\n\t\t\t\tg[i][j][k]=max(g[i][j][k],g[i][j-1][k]);\n\t\t\t\tg[i][j][k]=max(g[i][j][k],g[i-1][j-1][k]);\n\t\t\t\tg[i][j][k]=max(g[i][j][k],f[i][j][k]);\n\t\t\t\tans=max(ans,g[i][j][k]);\n\t\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Alyona and Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/45491",
    "editorial": "Letâs use the method of dynamic programming. Let d[i][j][cnt][end] be\r\nanswer to the problem for the prefix of string of length and for the\r\nprefix of string of length , we have chosen substrings. , if both last\r\ncharacters of the prefixes are included in the maximum subsequence and\r\notherwise. When the state is d[i][j][cnt][end], you can add the\r\nfollowing letters in the string s or t, though it will not be included\r\nin the response subsequence. Then d[i + 1][j][cnt][0] = max(d[i +\r\n1][j][cnt][0], d[i][j][cnt][end]), d[i][j + 1][cnt][0] = max(d[i][j +\r\n1][cnt][0], d[i][j][cnt][end]). So the new value of end is 0, because\r\nthe new letter is not included in the response subsequence. If s[i] =\r\nt[j], then if , we can update the d[i + 1][j + 1][k][1] =\r\nmax(d[i][j][k][end] + 1, d[i + 1][j + 1][k][1]). When we add an element\r\nto the response subsequence, the number of substring, which it is\r\ncomposed, will remain the same, because . If , we can update d[i +\r\n1][j + 1][k + 1][1] = max(d[i][j][k][end] + 1, d[i + 1][j + 1][k +\r\n1][1]). In this case, the new characters, which we try to add to the\r\nresponse subsequence, will form a new substring, so in this case we do\r\nthe transition from the state to the state . The answer will be the\r\nlargest number among the states of the d[n][m][k][end], where the values\r\nof and take all possible values.\r\n",
    "hint": []
}