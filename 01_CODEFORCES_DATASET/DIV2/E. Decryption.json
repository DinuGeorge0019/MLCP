{
    "link": "https://codeforces.com//contest/1419/problem/E",
    "problemId": "729812",
    "problem_idx": "E",
    "shortId": "1419E",
    "contest_number": "1419",
    "problem_submissions": {
        "F": [
            93295033,
            93295948,
            93577512,
            141950739,
            141949703,
            93333082
        ],
        "E": [
            93234753,
            93227212,
            93234200,
            93238693,
            93238493,
            93238433,
            93238275,
            93245697,
            93246537,
            93242848,
            93246826,
            93247065,
            93245207,
            93241549,
            93243538,
            93254913,
            93249479,
            93238516
        ],
        "D2": [
            93212522,
            93217506,
            93213686,
            93220590,
            93215812,
            93218918,
            93214966,
            93215328,
            93210409,
            93223664,
            93218002,
            93222549,
            93220767,
            93225667,
            93221756,
            93229039,
            93216049,
            93227118
        ],
        "D1": [
            93210697,
            93214622,
            93213970,
            93213840,
            93206345,
            93211719,
            93208773,
            93212321,
            93204619,
            93213170,
            93216390,
            93214097,
            93210302,
            93207013,
            93214684,
            93211970,
            93215865,
            93206978
        ],
        "C": [
            93207169,
            93210000,
            93209428,
            93210195,
            93217148,
            93208516,
            93207753,
            93214333,
            93218732,
            93213670,
            93211157,
            93218160,
            93211807,
            93211495,
            93209180,
            93205213,
            93217455
        ],
        "B": [
            93202581,
            93203801,
            93204920,
            93203314,
            93203851,
            93201764,
            93202768,
            93202454,
            93208579,
            93203844,
            93205640,
            93206433,
            93220603,
            93204341,
            93204189,
            93202311,
            93214207
        ],
        "A": [
            93200129,
            93200069,
            93200258,
            93200020,
            93200369,
            93204977,
            93200037,
            93200656,
            93201705,
            93200310,
            93200086,
            93201198,
            93200525,
            93199999,
            93201236,
            93200136,
            93200638
        ]
    },
    "name": "E. Decryption",
    "statement": "An agent called Cypher is decrypting a message, that contains a\r\ncomposite number n. All divisors of n, which are greater than 1, are\r\nplaced in a circle. Cypher can choose the initial order of numbers in\r\nthe circle.In one move Cypher can choose two adjacent numbers in a\r\ncircle and insert their least common multiple between them. He can do\r\nthat move as many times as needed.A message is decrypted, if every two\r\nadjacent numbers are not coprime. Note that for such constraints it’s\r\nalways possible to decrypt the message.Find the minimal number of moves\r\nthat Cypher should do to decrypt the message, and show the initial order\r\nof numbers in the circle for that.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s\".in\", \"r\", stdin); freopen(s\".out\", \"w\", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, \"%d \", a[i]); fprintf(stderr, \"\\n\");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=' ';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>' ';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]=='-') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-'0'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = '0'; else {if(x<0) obuf[opt++]='-',x=-x;int sn=0; while(x)str[sn++]=x%10+'0',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint p[MAXN], a[MAXN], pc, d[MAXN], dc = 0, used[MAXN], n;\nvoid Div(int n) {\n//\tcerr << n << \":\\n\";\n\tFor(i, 1, pc) p[i] = a[i] = 0; pc = 0; \n\tFor(i, 1, dc) used[i] = d[i] = 0; dc = 0;\n\tfor(int i = 1; i * i <= n; i++) {\n//\t\tcerr << i << endl;\n\t\tif(n % i == 0) {\n\t\t\tif(n / i != i) d[++dc] = n / i;\n\t\t\tif(i != 1) d[++dc] = i;\n\t\t}\n\t}\n\tsort(d + 1, d + 1 + dc);\n//\tcerr << dc << endl;\n//\tcerr << \"?\";\n\tfor(int i = 2; i * i <= n; i++) {\n\t\tif(n % i == 0) {\n\t\t\tp[++pc] = i;\n\t\t\twhile(n % i == 0) {\n\t\t\t\tn /= i; a[pc]++;\n\t\t\t}\n\t\t}\n\t}\n\tif(n != 1)\n\t\tp[++pc] = n, a[pc] = 1;\n//\tcerr << pc << ' ' << dc << endl;\n\t\n}\n#define nxt(x) (x!=pc?x+1:1)\n#define pre(x) (x!=1?x-1:pc)\nvoid solve(int x) {\n\tFor(i, 1, dc) {\n\t\tif(!used[i] && d[i] % p[x] == 0 && d[i] % p[nxt(x)] != 0 && (x != 1 || d[i] % p[pc] != 0)) printf(\"%d \", d[i]), used[i] = 1;\n//\t\tcerr << i << ' ' << d[i] << ' ' << p[pc] << endl;\n//\t\tcerr << x << ' ' << nxt(x) << ' ' << p[nxt(x)] << endl;\n\t}\n    \t\n    For(i, 1, dc)\n    \tif(!used[i] && d[i] % p[x] == 0 && d[i] % p[nxt(x)] == 0 && (x != 1 || d[i] % p[pc] != 0)) printf(\"%d \", d[i]), used[i] = 1;\n}\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(\"pro\");\n    #endif\n    int T; cin >> T;\n    while(T--) {\n    \tcin >> n;\n    \tDiv(n);\n    \tif(pc == 1) {\n    \t\tFor(i, 1, dc) printf(\"%d \", d[i]);\n    \t\tprintf(\"\\n0\\n\");\n\t\t} else if(pc == 2) {\n\t\t\tif(a[1] == 1 && a[2] == 1) {\n\t    \t\tFor(i, 1, dc)\n\t    \t\t\tif(d[i] % p[1] == 0 && d[i] % p[2] != 0) printf(\"%d \", d[i]);\n\t\t\t\tFor(i, 1, dc)\n\t    \t\t\tif(d[i] % p[1] == 0 && d[i] % p[2] == 0) printf(\"%d \", d[i]);\n\t    \t\tFor(i, 1, dc)\n\t    \t\t\tif(d[i] % p[1] != 0 && d[i] % p[2] == 0) printf(\"%d \", d[i]);\n\t    \t\tprintf(\"\\n1\\n\");\n\t\t\t} else {\n\t\t\t\tFor(i, 1, dc)\n\t    \t\t\tif(d[i] % p[1] == 0 && d[i] % p[2] != 0) printf(\"%d \", d[i]);\n\t\t\t\tFor(i, 1, dc)\n\t    \t\t\tif(d[i] % p[1] == 0 && d[i] % p[2] == 0 && d[i] != p[2] * p[1]) printf(\"%d \", d[i]);\n\t    \t\tFor(i, 1, dc)\n\t    \t\t\tif(d[i] % p[1] != 0 && d[i] % p[2] == 0) printf(\"%d \", d[i]);\n\t    \t\tprintf(\"%d\\n0\\n\", p[2] * p[1]);\n\t\t\t}\n    \t\t\n\t\t} else {\n\t\t\tFor(i, 1, pc) solve(i);\n\t\t\tprintf(\"\\n%d\\n\", 0);\n\t\t}\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Decryption.json",
    "editorial_link": "https://codeforces.com//blog/entry/82817",
    "editorial": "Letâs factorize : If and (i.e. is the product of two different prime\r\nnumbers)Divisors and will definately be adjacent and they are coprime so\r\nwe should make one operation to insert their lcm between them. After\r\nthat the circle will be , , , and there will be no such two adjacent\r\nnumbers that are coprime. The answer is 1. If and or , then we can\r\nfirstly place numbers . After that we can insert all unused divisors\r\nthat are multiples of between and , all divisors that are multiples of\r\nbetween and . It is easy to see that in this case the answer is 0. In\r\nanother case it is possible to arrange the divisors so that there are no\r\nsuch two adjacent numbers that are coprime. Firstly, we need to arrange\r\nin a circle these numbers: , , , ..., After that we need to write down\r\nthe products of these numbers between them: , , , , ..., , From now on\r\nwe can just place unused numbers that way: insert all unused divisors,\r\nthat are multiples of , after , insert all unused divisors, that are\r\nmultiples of , after and so on. If the solution is still unclear you may\r\ntake a look at the image below. The answer in this case is 0.\r\n",
    "hint": []
}