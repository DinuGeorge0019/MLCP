{
    "link": "https://codeforces.com//contest/2032/problem/F",
    "problemId": "2994609",
    "problem_idx": "F",
    "shortId": "2032F",
    "contest_number": "2032",
    "problem_submissions": {
        "F": [
            289267915,
            289277706,
            289232912,
            289267377,
            291314197,
            289416021
        ],
        "E": [
            289238022,
            289262776,
            289255223,
            289258448,
            289250787,
            289260574,
            289261929,
            289227660,
            289263018,
            289263597,
            289263187,
            289266715,
            289259935,
            289271752,
            289266962,
            289268830,
            289269008,
            289265714
        ],
        "D": [
            289731015,
            289233613,
            289264637,
            289214258,
            289228700,
            289223391,
            289226883,
            289280487,
            289241431,
            289231526,
            289229626,
            289234786,
            289242007,
            289228890,
            289240630,
            289239305,
            289231442,
            289232355
        ],
        "B": [
            289203679,
            289271925,
            289191670,
            289200056,
            289196726,
            289200003,
            289197742,
            289196982,
            289194362,
            289197275,
            289201147,
            289202156,
            289199141,
            289200655,
            289202275,
            289195764
        ],
        "C": [
            289193496,
            289267532,
            289198910,
            289207633,
            289201326,
            289203591,
            289285062,
            289204577,
            289220034,
            289205439,
            289204433,
            289208681,
            289194187,
            289211250,
            289206397,
            289208627,
            289215203
        ],
        "A": [
            289187421,
            289273450,
            289186675,
            289187594,
            289186664,
            289189130,
            289187996,
            289189265,
            289187088,
            289189596,
            289187843,
            289188574,
            289187095,
            289189623,
            289187877,
            289187863
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135622",
    "editorial": "Let\u00e2\u0080\u0099s get the trivial case out of the way: If the peanut pockets always\r\ncontain nut each, then partitioning the pockets doesn\u00e2\u0080\u0099t affect the\r\ngame\u00e2\u0080\u0099s outcome at all: Alice will always win if is odd, and there are\r\nways to partition pockets. Jack will always win if is even. Proof for\r\nthe trivial case is, indeed, trivial.For the main problem, we see that\r\nthis is a derivative of a game of Nim. To be exact, each box is a\r\nvanilla Nim game. To determine the winner of a vanilla Nim game when\r\nboth players play optimally is trivial if not for you, I strongly\r\nsuggest reading about the game and the Sprague-Grundy theorem before\r\ncontinuing.In short, the Nim-sum of a Nim game is the xor sum of all\r\nvalues presented, and if that value is at least , the first player will\r\nwin if they play optimally.The original game of this problem is a series\r\nof consecutive Nim games, with the loser of the previous game becoming\r\nthe first player of the next game. Clearly, trying to win all the boxes\r\nisn\u00e2\u0080\u0099t a correct approach one of the simplest counterexamples is a\r\npartition with two boxes, both with the first player winning if played\r\noptimally, so of course if the first player \"wins\" the first box, they\r\nimmediately lose the second one and thus lose the whole game.In short,\r\nsometimes, tactically \"losing\" some boxes might be required. But how to\r\nknow which player would lose if they both aimed for it?Now, introducing\r\nthe \"mirrored\" version of a Nim game a Mis re Nim game, where the\r\nwinning condition is the original Nim game\u00e2\u0080\u0099s losing condition.If the\r\npeanut pockets always contain nut each, then the winner of a Mis re Nim\r\ngame can be easily declared by the parity of . Otherwise, the winner of\r\na Mis re Nim game can be decided using the same nimber used in a regular\r\nNim game: if the nimber is not , the first player wins both the original\r\nand the Mis re version; otherwise, the second player wins the optimal\r\nstrategies to acquire such outcome have the exact mirror intents of\r\nthose in a regular Nim game.Also, surpassing the leading s in array ,\r\nboth Alice and Jack have the rights to tactically lose. Thus, any of\r\nthem would win the game if and only if they could win the first box\r\ncontaining non-trivial pockets (here defined as pockets with more than\r\nnut, we\u00e2\u0080\u0099ll call a box having at least one non-trivial pocket a\r\nnon-trivial box) if both play optimally until there as proven above, if\r\nthey could theoretically win it, they could also tactically lose it,\r\nthus they would have full control of the game, and they could make a\r\ndecision in accordance with whatever partition coming next in the\r\nremaining pockets.We\u00e2\u0080\u0099ll denote as the number of trivial pockets (i.e.\r\npockets with nut each) standing at the left side of array , i.e., the\r\npocket will be the leftmost one to have more than nut. We\u00e2\u0080\u0099ll consider\r\nall possible options for first boxes containing non-trivial pockets, and\r\nthus we\u00e2\u0080\u0099ll iterate in range : First, we denote as the xor sum of all\r\nelements of the prefix of array up until the element. This value will\r\ndetermine how much control Alice would have. If , Alice will lose in all\r\ncases with the first non-trivial box ending at . Proof is simple: if\r\nthis box has an even amount of s before it, obviously Alice will be the\r\nstarting player of a game with nimber of and thus cannot control it to\r\nher will; and if the amount of preceding s is odd, then the first\r\nnon-trivial box is a game with nimber of and Jack as first player, thus\r\nJack retains full control. If , Alice will win in all cases with the\r\nfirst non-trivial box ending at . Proof is literally the reverse of the\r\nabove case. If , both Alice and Jack have full control to win it, thus\r\nAlice will win if and only if she is the starting player of the game at\r\nthe first non-trivial box. So we have the detailed winning condition.\r\nNow, towards the maths. First, whatever pockets after the first\r\nnon-trivial box doesn\u00e2\u0080\u0099t matter. Thus, for each , there exists different\r\npartitions of the pockets following the one. We don\u00e2\u0080\u0099t consider cases\r\nwith , obviously. If , all partitions involving only the first pockets\r\nare allowed. In fact, there are items here: trivial pockets, and the\r\nfirst non-trivial blob always coming last, thus the number of different\r\npartitions of the pockets preceding the one in this case is . If , we\u00e2\u0080\u0099ll\r\nconsider all even in range , with denoting the number of s not within\r\nthe first non-trivial box. Clearly, for each , the number of different\r\npartitions would be . And since is fixed and this process has no\r\nrelation with , this value could be pre-calculated. In more details,\r\ndenoting that value as , we have . All powers of could be pre-calculated\r\nas well, saving a considerable amount of runtime. All pre-calculations\r\nhave time complexity in linear order of the maximum size of array . Time\r\ncomplexity: .\r\n",
    "name": "F. Peanuts",
    "statement": "Having the magical beanstalk, Jack has been gathering a lot of peanuts\r\nlately. Eventually, he has obtained n pockets of peanuts, conveniently\r\nnumbered 1 to n from left to right. The i-th pocket has a_i peanuts.Jack\r\nand his childhood friend Alice decide to play a game around the peanuts.\r\nFirst, Alice divides the pockets into some boxes; each box will have a\r\nnon-zero number of pockets, and each pocket will, obviously, belong to\r\nexactly one box. At the same time, Alice does not change the order of\r\nthe boxes, that is, the boxes are numbered in ascending order of the\r\nindices of the pockets in them.After that, Alice and Jack will take\r\nturns alternately, with Alice going first.At each turn, the current\r\nplayer will remove a positive number of peanuts from pocket which\r\nbelongs to the (i.e., the leftmost box containing at least one non-empty\r\npocket). In other words, if we number the boxes from left to right, then\r\neach player can only pick peanuts from the pocket in the j-th box (j\r\nge 2) only if the (j - 1)-th box has no peanuts left. The player who\r\ncannot make a valid move loses.Alice is sure she will win since she has\r\nthe advantage of dividing the pockets into boxes herself. Thus, she\r\nwanted to know how many ways there are for her to divide the peanuts\r\ninto boxes at the start of the game so that she will win, assuming both\r\nplayers play optimally. Can you help her with the calculation?As the\r\nresult can be very large, output it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;const int mod = 998244353;int t, n;int a[1000020];int s[1000020];int c[1000020];long long f[1000020];long long g[1000020];int main(){\tscanf(\"%d\", &t);\tfor (int tt = 0; tt < t; tt++)\t{\t\tscanf(\"%d\", &n);\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\tscanf(\"%d\", &a[i]);\t\t\ts[i + 1] = s[i] ^ a[i];\t\t\tc[i + 1] = c[i] + (a[i] == 1);\t\t}\t\tfor (int i = 0; i <= n; i++)\t\t{\t\t\tf[i] = 0;\t\t\tg[i] = 0;\t\t}\t\tunordered_map<int, long long> ff;\t\tunordered_map<int, long long> gg;\t\tunordered_map<int, long long> ggg;\t\tint sf = 0;\t\tint sg = 0;\t\tf[n] = 1;\t\tg[n] = 0;\u00a0\t\tff[s[n]] = 1;\t\tsf = (sf + f[n]) % mod;\t\tint onej = n;\t\tfor (int i = n - 1; i >= 0; i--)\t\t{\t\t\t// long long debugf = 0;\t\t\t// long long debugg = 0;\t\t\tif (a[i] != 1)\t\t\t{\t\t\t\tfor (int j = onej; j > i; j--)\t\t\t\t{\t\t\t\t\tgg[s[j]] = (gg[s[j]] + g[j]) % mod;\t\t\t\t\tsg = (sg + g[j]) % mod;\t\t\t\t}\t\t\t\tonej = i;\t\t\t\tggg.clear();\t\t\t}\t\t\tg[i] = (g[i] + sg - gg[s[i]]) % mod;\t\t\tf[i] = (f[i] + gg[s[i]]) % mod;\u00a0\t\t\t// for (int j = onej + 1; j <= n; j++)\t\t\t// {\t\t\t// \tif ((s[i] ^ s[j]) != 0)\t\t\t// \t{\t\t\t// \t\tg[i] += g[j];\t\t\t// \t}\t\t\t// \telse\t\t\t// \t{\t\t\t// \t\tf[i] += g[j];\t\t\t// \t}\t\t\t// }\u00a0\t\t\tg[i] = (g[i] + ggg[i % 2]) % mod;\t\t\tf[i] = (f[i] + ggg[1 - i % 2]) % mod;\u00a0\t\t\tg[i] = (g[i] + sf - ff[s[i]]) % mod;\t\t\tf[i] = (f[i] + ff[s[i]]) % mod;\t\t\tggg[i % 2] = (ggg[i % 2] + g[i]) % mod;\t\t\tff[s[i]] = (ff[s[i]] + f[i]) % mod;\t\t\tsf = (sf + f[i]) % mod;\t\t}\t\tif (g[0] < 0)\t\t{\t\t\tg[0] += mod;\t\t}\t\tprintf(\"%lld\\n\", g[0]);\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "games",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Peanuts.json"
}