{
    "link": "https://codeforces.com//contest/1920/problem/D",
    "problemId": "2424503",
    "problem_idx": "D",
    "shortId": "1920D",
    "contest_number": "1920",
    "problem_submissions": {
        "F2": [
            241519708,
            242461640,
            241499605,
            241499150,
            241499121,
            241526798,
            241677520,
            242000469
        ],
        "F1": [
            241460299,
            241470662,
            241472660,
            241471905,
            241452735,
            241475361,
            241451154,
            241473438,
            241479153,
            241478315,
            241484928,
            241465563,
            241477422,
            241477811,
            241688562,
            241479348,
            241481887,
            241485652,
            241484576,
            241481175
        ],
        "E": [
            241449808,
            241450749,
            250647629,
            250647603,
            250646809,
            241453536,
            241456702,
            241468503,
            241457240,
            241473848,
            241459615,
            241448891,
            241462905,
            241455611,
            241473828,
            241462340,
            241463447,
            241688611,
            241464804,
            241470317,
            241459879,
            241463678,
            241464099
        ],
        "D": [
            241440349,
            241444733,
            241443927,
            241444084,
            241461216,
            241445290,
            241465918,
            241452364,
            241443025,
            241445939,
            241448263,
            241452666,
            241453380,
            241452851,
            241446075,
            241446900,
            241450746,
            241452656,
            241457511
        ],
        "C": [
            241424760,
            241434849,
            241435347,
            241432571,
            241426106,
            241430363,
            241433735,
            241436246,
            241435590,
            241433210,
            241428829,
            241435049,
            241436115,
            241439877,
            241436063,
            241433607,
            241435067,
            241438107,
            241435335
        ],
        "B": [
            241420376,
            241425242,
            241428830,
            241429674,
            241419228,
            241425601,
            241423672,
            241427964,
            241426457,
            241429604,
            241423387,
            241427147,
            241430484,
            241428576,
            241428228,
            241423313,
            241427602,
            241429162,
            241430149
        ],
        "A": [
            241418935,
            241420574,
            241419051,
            241419262,
            241421587,
            241419112,
            241419031,
            241419259,
            241421308,
            241419216,
            241419840,
            241421070,
            241419328,
            241428462,
            241421467,
            241419238,
            241420328,
            241420339,
            241423810
        ]
    },
    "name": "D. Array Repetition",
    "statement": "Jayden has an array a which is initially empty. There are n operations\r\nof two types he must perform in the given order. Jayden appends an\r\ninteger x (1\r\nleq x\r\nleq n) to the end of array a. Jayden appends x copies of array a to the\r\nend of array a. In other words, array a becomes [a,\r\nunderbrace{a,\r\nldots,a}_{x}]. It is guaranteed that he has done at least one operation\r\nof the first type before this. Jayden has q queries. For each query, you\r\nmust tell him the k-th element of array a. The elements of the array are\r\nnumbered from 1.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int N=1e5+1, inf=2e18;\nint n, q, cnt[N];\npair<int, int> a[N];\npair<int, vector<int>> b[N];\n\nvoid solve(){\n   cin >> n >> q;\n   int m=0, sz=0;\n   for (int i=1; i<=n; ++i){\n      cin >> a[i].first >> a[i].second;\n      if (m && b[m].first==1 && a[i].first==1) b[m].second.push_back(a[i].second);\n      else b[++m]={a[i].first, {a[i].second}};\n   }\n   for (int i=1; i<=m; ++i){\n      if (b[i].first==1){\n         sz=min(sz+isz(b[i].second), inf);\n      }else{\n         if (sz>=inf/(b[i].second[0]+1)) sz=inf;\n         else sz*=(b[i].second[0]+1);\n      }\n      cnt[i]=sz;\n   }\n   int m2=m;\n   while (cnt[m-1]==inf) --m;\n   for (int i=1; i<=q; ++i){\n      int idx; cin >> idx;\n      int ans=-1;\n      for (int j=m; j>=1; --j){\n         if (b[j].first==1){\n            if (cnt[j]-idx+1<=isz(b[j].second)){\n               ans=b[j].second[idx-(cnt[j]-isz(b[j].second))-1];\n               break;\n            }\n         }else{\n            int prev_sz=cnt[j-1];\n            idx=(idx-1)%prev_sz+1;\n         }\n      }\n      cout << ans << ' ';\n   }\n   cout << '\\n';\n   for (int i=1; i<=m2; ++i) b[i]={0, {}};\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dsu",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Array Repetition.json",
    "editorial_link": "https://codeforces.com//blog/entry/122560",
    "editorial": "First, let's precalculate some things:\n\nlsti=last element after performing the first i operations\ndpi=number of elements after the first i operations\nNow, let's try answering some query k\n. If we have some dpi=k\n then the answer is lsti\n.\n\nOtherwise, let's find the first i\n such that dpi>k\n. This i\n will be a repeat operation and our answer will lie within one of the repetitions. Our list at this point will look like:\n\n[l1,l2,...ldpi?1]????????????????length dpi?1[l1,l2,...ldpi?1]????????????????length dpi?1[l1,l2,...ldpi?1]????????????????length dpi?1...[l1,l_2,...ldpi?1]??????????????????length dpi?1\nLet the k\n-th element be the bolded l2\n of the final repetition. As you can see, finding the k\n-the element is equivalent to finding the (kmoddpi?1)\n-th element. Thus, we should do k:=kmoddpi?1\n and repeat! But there is one more case! If k?0(moddpi?1)\n then the answer is lsti?1\n.",
    "hint": [
        "Hint 1 For some query try to trace your way back to where the -th number was added.",
        "Hint 2 Here's an example of tracing back: Suppose the -th element is the bolded . Finding the -th element is equivalent to finding the ( )-th element (unless if is )."
    ]
}