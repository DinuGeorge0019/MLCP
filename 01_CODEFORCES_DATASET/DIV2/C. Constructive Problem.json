{
    "link": "https://codeforces.com//contest/1820/problem/C",
    "problemId": "1880611",
    "problem_idx": "C",
    "shortId": "1820C",
    "contest_number": "1820",
    "problem_submissions": {
        "E": [
            202221495,
            202224197,
            202223650,
            202221055,
            202211278,
            202210773,
            202210525,
            202392193,
            202234544,
            202241741
        ],
        "D": [
            202204493,
            202203834,
            202204941,
            202200357,
            202224521,
            202196714,
            202201649,
            202201288,
            202205548,
            202208808,
            202207552,
            202206152,
            202208768,
            202210206,
            202204088,
            202209173,
            202204193,
            202208143
        ],
        "C": [
            202188210,
            202190438,
            202191871,
            202204067,
            202186370,
            202194680,
            202193928,
            202184998,
            202190422,
            202190852,
            202188780,
            202191686,
            202189589,
            202189497,
            202191313,
            202189933,
            202193203,
            202191781,
            202192559,
            202193037
        ],
        "B": [
            202184059,
            202186314,
            202188694,
            202185290,
            202181971,
            202185877,
            202195824,
            202184988,
            202186184,
            202184424,
            202184282,
            202185384,
            202184368,
            202185406,
            202183611,
            202187273,
            202187259,
            202188101,
            202186319
        ],
        "A": [
            202181070,
            202181088,
            202184573,
            202180673,
            202180868,
            202181103,
            202180754,
            202181157,
            202181299,
            202180503,
            202180966,
            202180804,
            202180777,
            202180572,
            202180527,
            202180589,
            202182901,
            202184035,
            202181508
        ],
        "F": [
            202489739,
            202420015
        ]
    },
    "name": "C. Constructive Problem",
    "statement": "As you know, any problem that does not require the use of complex data\r\nstructures is considered constructive. You are offered to solve one of\r\nsuch problems.You are given an array a of n non-negative integers. You\r\nare allowed to perform the following operation : choose some non-empty\r\nsubsegment a_l, a_{l+1},\r\nldots, a_r of the array a and a non-negative integer k, and assign value\r\nk to all elements of the array on the chosen subsegment.The task is to\r\nfind out whether\r\noperatorname{MEX}(a) can be increased by exactly one by performing such\r\nan operation. In other words, if before the operation\r\noperatorname{MEX}(a) = m held, then after the operation it must hold\r\nthat\r\noperatorname{MEX}(a) = m + 1.Recall that\r\noperatorname{MEX} of a set of integers c_1, c_2,\r\nldots, c_k is defined as the smallest non-negative integer x which does\r\nnot occur in the set c.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FORI(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n \nmt19937 rnd(time(0));\n\n#define ll long long\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define endl '\\n'\n\n#define mp(m, n) make_pair((m), (n))\n \ntemplate<typename T>\nvoid read(vector<T> &t) {FOR(i, t.size()) {cin >> t[i];}}\ntemplate<typename T> string tostring(T a) { istringstream sin; sin >> a; return sin.str(); }\n \n// #define DEBUG\n \n#ifdef DEBUG\ntemplate<typename T>\nvoid _debug(string s, T x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, unordered_map<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \":\" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, map<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \":\" << it->second;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, set<T, K> x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << *it;\n    }\n    cerr << endl;\n}\n \ntemplate<typename T, typename K>\nvoid _debug(string s, vector<pair<T, K> > x) {\n    cerr << s << \":\";\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        cerr << \" \" << it->first << \",\" << it->second;\n    }\n    cerr << endl;\n}\n\ntemplate<typename T, typename K>\nvoid _debug(string s, pair<T, K> x) {\n    cerr << s << \": \" << x.first << \",\" << x.second << endl;\n}\n \nvoid _debug(string s, int x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, long long x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, double x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, string x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, char x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, size_t x) {\n    cerr << s << \": \" << x << endl;\n}\nvoid _debug(string s, bool x) {\n    cerr << s << \": \" << x << endl;\n}\n \n#define debug(x) _debug(#x, (x))\n#else\n#define debug(x)\n#endif\n \n#define db debug\n\ntemplate <class T>\nvoid print(vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        cout << v[i];\n        if (i == v.size() - 1) {\n            cout << endl;\n        } else {\n            cout << \" \";\n        }\n    }\n}\n\nvoid solve();\n \nvoid pre_init();\n\nint main() {\n    ios_base::sync_with_stdio(false); std::cin.tie(0);\n    pre_init();\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}\n \nvoid pre_init() {}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    read(v);\n    set<int> s(v.begin(), v.end());\n    int val = 0;\n    for (int i = 0; i < n + 1; i++) {\n        val = i;\n        if (!s.count(i)) {\n            break;\n        }\n    }\n    int l_val_1 = -1, r_val_1 = -1;\n    for (int i = 0; i < n; i++) {\n        if (v[i] == val + 1) {\n            if (l_val_1 == -1) {\n                l_val_1 = i;\n            }\n            r_val_1 = i;\n        }\n    }\n    // debug(val);\n    // debug(l_val_1);\n    // debug(r_val_1);\n    if (l_val_1 == -1) {\n        if (val == n) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n        return;\n    }\n    for (int i = l_val_1; i <= r_val_1; i++) {\n        v[i] = val;\n    }\n    {\n        set<int> s(v.begin(), v.end());\n        int val2 = 0;\n        for (int i = 0; i < n + 1; i++) {\n            val2 = i;\n            if (!s.count(i)) {\n                break;\n            }\n        }\n        if (val + 1 == val2) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Constructive Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "Let the current value of mex equal to m\n and the value of mex after performing operation equals to m?\n. It's easy to see that in the resulting array there should exist element equals to m+1\n (if it doesn't exist, the value of mex won't be equal to m+1\n). Also notice that k\n should be equal to m\n because this value didn't appear in the array before the operation and must appear there after performing the operation. Consider the following cases.\n\nIf there exists such i\n that ai=m+1\n, let's find the minimum value l\n and the maximum value r\n such that al=ar=m+1\n. It's easy to see that the performed operation should cover these elements. We already know which value of k\n to select. Now notice that there are no profits from using longer segments because m?\n is already not greater than m+1\n (there are no elements equal to m+1\n) and longer segments may make m?\n less.\nIf there is no such i\n that ai=m\n but there exists i\n such that ai>m+1\n, m?\n is already not greater than m+1\n. Similarly with the previous case, we can find any i\n such that ai>m+1\n and replace ai\n with m\n.\nIn all other cases if there exist two indices i?j\n such that ai=aj\n, we can replace one of these elements with m\n. In this case we will make m?\n equals to m+1\n. If there are no such indices, m\n equals to the length of the array and we cannot increment m\n.\nThe only thing we have to do after considering cases is to check if the performed operation leads to correct value of m?\n.\n\nTime complexity: O(nlogn)\n.",
    "hint": []
}