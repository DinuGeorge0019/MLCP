{
    "link": "https://codeforces.com//contest/1720/problem/D1",
    "problemId": "1512385",
    "problem_idx": "D1",
    "shortId": "1720D1",
    "contest_number": "1720",
    "problem_submissions": {
        "E": [
            168846777,
            168840544,
            168827050,
            168859240,
            168862248,
            168861844,
            168862010,
            168825889,
            168916027,
            168877554,
            168901697,
            168883239
        ],
        "D2": [
            168835694,
            168850679,
            168839552,
            168830934,
            168845483,
            168843478,
            168832795,
            168821250,
            168836283,
            168852109,
            168831844,
            168842245,
            168839190,
            168846298,
            168842200,
            168837729,
            168842524
        ],
        "D1": [
            168824858,
            168826632,
            168839665,
            168830830,
            168827889,
            168830140,
            168824710,
            168836162,
            168821401,
            168836396,
            168823758,
            168831963,
            168842466,
            168825766,
            168831343,
            168842031,
            168837590,
            168842611
        ],
        "C": [
            168811322,
            168813329,
            168842584,
            168815215,
            168819795,
            168819474,
            168819456,
            168850754,
            168812287,
            168814430,
            168814760,
            168822741,
            168815241,
            168811935,
            168821777,
            168817839,
            168814181,
            168823921,
            168820025
        ],
        "A": [
            168809810,
            168807059,
            168846238,
            168808208,
            168810706,
            168809379,
            168807927,
            168854111,
            168807247,
            168807149,
            168808346,
            168808021,
            168807215,
            168848108,
            168807353,
            168808693,
            168807411,
            168807295,
            168808471
        ],
        "B": [
            168807225,
            168807985,
            168844246,
            168809736,
            168814160,
            168814167,
            168862630,
            168852491,
            168808670,
            168808487,
            168810496,
            168816414,
            168815954,
            168809438,
            168816039,
            168810273,
            168810419,
            168815510,
            168813227
        ]
    },
    "name": "D1. Xor-Subsequence  easy version ",
    "statement": "You are given an array of n integers a_0, a_1, a_2,\r\nldots a_{n - 1}. Bryap wants to find the longest subsequence in the\r\narray.An array b = [b_0, b_1,\r\nldots, b_{m-1}], where 0\r\nle b_0 < b_1 <\r\nldots < b_{m - 1} < n, is a subsequence of length m of the array\r\na.Subsequence b = [b_0, b_1,\r\nldots, b_{m-1}] of length m is called , if the following condition\r\nholds: For any p (0\r\nle p < m - 1) holds: a_{b_p}\r\noplus b_{p+1} < a_{b_{p+1}}\r\noplus b_p. Here a\r\noplus b denotes the bitwise XOR of a and b. For example, 2\r\noplus 4 = 6 and 3\r\noplus 1=2.Bryap is a simple person so he only wants to know the length\r\nof the longest such subsequence. Help Bryap and find the answer to his\r\nquestion.\r\n",
    "solutions": [
        "//\u8fd9\u56de\u53ea\u82b1\u4e86114514min\u5c31\u6253\u5b8c\u4e86\u3002\n//\u771f\u597d\u3002\u8bb0\u5f97\u591a\u624b\u9020\u51e0\u7ec4\u3002ACM\u62cd\u4ec0\u4e48\u62cd\u3002 \n#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include \"my_header\\debug.h\"\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=3e5+5;\nint A[N];\nint f[256];\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,i,j,k,res=0;\n\t\tcin>>n;\n\t\tfor (i=0; i<n; i++) cin>>A[i];\n\t\tint m=n;\n\t\tfor (k=0; k<m; k+=256)\n\t\t{\n\t\t\tint *a=A+k;\n\t\t\tn=min(m-k,256);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tfor (j=0; j<i; j++) if ((a[j]^i)<(a[i]^j)) f[i]=max(f[i],f[j]+1);\n\t\t\t}\n\t\t\tres=max(res,*max_element(f,f+n));\n\t\t}\n\t\tcout<<res<<'\\n';\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "strings",
        "trees",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. Xor-Subsequence  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/106136",
    "editorial": "Let\u00e2\u0080\u0099s use dynamic programming to solve this task. \u00e2\u0080\u0093 maximum\nlength of good subsequence, that ends int -th element of , than naive\nsolution is Let\u00e2\u0080\u0099s observe that changes not more than by .This way we can\nrelax not from , but , because xor operation changes only last 8 bits,\nso for , definitely .Additional idea:It not so hard to proove that we\ncan try from to .\n"
}