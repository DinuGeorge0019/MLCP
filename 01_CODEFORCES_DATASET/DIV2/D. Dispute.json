{
    "link": "https://codeforces.com//contest/242/problem/D",
    "problemId": "2150",
    "problem_idx": "D",
    "shortId": "242D",
    "contest_number": "242",
    "problem_submissions": {
        "D": [
            2537952,
            2537942,
            2539339,
            2539698,
            2539156,
            2539580,
            2537494,
            2542278,
            2538787,
            2539905,
            2536184,
            2537759,
            2542044,
            2538066,
            2564424
        ],
        "C": [
            2537373,
            2537268,
            2536519,
            2536785,
            2537810,
            2537116,
            2537792,
            2536568,
            2536898,
            2537580,
            2536958,
            2536262,
            2537263,
            2538218,
            2536235,
            2542015,
            2536779,
            2536389,
            2538664,
            2537599
        ],
        "B": [
            2536607,
            2534065,
            2534724,
            2534650,
            2534927,
            2535116,
            2534461,
            2535027,
            2534468,
            2533804,
            2535897,
            2534112,
            2534107,
            2535117,
            2534450,
            2534923,
            2542000,
            2534963,
            2534474,
            2534940,
            2535281
        ],
        "A": [
            2536206,
            2533805,
            2533960,
            2533930,
            2534212,
            2534073,
            2533868,
            2533943,
            2533896,
            2534746,
            2535180,
            2533808,
            2533814,
            2534432,
            2533857,
            2533887,
            2541991,
            2534152,
            2533996,
            2533848,
            2534557
        ],
        "E": [
            2535640,
            2536427,
            2538447,
            2538483,
            2538649,
            2538639,
            2537907,
            2539042,
            2537371,
            2537776,
            2539203,
            2536140,
            2538840,
            2538202,
            2564479,
            2541961,
            2541948,
            2542249,
            2542247,
            2542240,
            2539344,
            9226579,
            2538102,
            2538950
        ]
    },
    "name": "D. Dispute",
    "statement": "Valera has counters numbered from to . Some of them are connected by\r\nwires, and each of the counters has a special button.Initially, all the\r\ncounters contain number . When you press a button on a certain counter,\r\nthe value it has increases by one. Also, the values recorded in all the\r\ncounters, directly connected to it by a wire, increase by one.Valera and\r\nIgnat started having a dispute, the dispute is as follows. Ignat thought\r\nof a sequence of integers . Valera should choose some set of distinct\r\ncounters and press buttons on each of them exactly once (on other\r\ncounters the buttons won\u2019t be pressed). If after that there is a counter\r\nwith the number , which has value , then Valera loses the dispute,\r\notherwise he wins the dispute.Help Valera to determine on which counters\r\nhe needs to press a button to win the dispute.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define maxn (111111)\nint d[maxn];\nint n, m;\nvector<int> e[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &d[i]);\n\n\tqueue<int> q; while (!q.empty()) q.pop();\n\tfor (int i = 1; i <= n; ++i) if (d[i] == 0) q.push(i);\n\n\tvector<int> ans; ans.clear();\n\twhile (!q.empty()) {\n\t\tint k = q.front(); q.pop();\n\t\tif (d[k] != 0) continue;\n\n\t\td[k]--; ans.push_back(k);\n\t\tfor (int i = 0; i < e[k].size(); ++i) {\n\t\t\tint x = e[k][i]; d[x]--;\n\t\t\tif (d[x] == 0) q.push(x);\n\t\t}\n\t}\n\n\tsort(ans.begin(), ans.end());\n\tprintf(\"%d\\n\", (int) ans.size());\n\tfor (int i = 0; i < ans.size(); ++i) printf(\"%d%c\", ans[i], i == ans.size() - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Dispute.json",
    "editorial_link": "https://codeforces.com//blog/entry/5837",
    "editorial": "Denote current value of counter number as . Let\u00e2\u0080\u0099s describe an algorithm.\r\nIt takes any counter such that and presses its button. The algorithm\r\nfinishes if there is no such . Let\u00e2\u0080\u0099s proof correctness of the algorithm:\r\nWhy does Valera win the game? Because there is no such counter which has\r\nelse we must press the button. Why doesn\u00e2\u0080\u0099t algorithm press some button\r\nmultiple times? Because it presses button number only if , and after\r\nthis pressing the value is increased and the equation will be true\r\nnever. Why is the algorithm fast? Because of paragraph 2 it does no more\r\npressings which produces no more increases of the counters. We should\r\nuse queue for fast seaching counters which has like this: every time we\r\nchange value of the counter numbered we check equation and if it\u00e2\u0080\u0099s true\r\nthen we push value to the queue. It\u00e2\u0080\u0099s easy to understand that all\r\nindexes will be in queue no more one time. Also these paragraphs proof\r\nthat the answer always exists. You must print never. The time is .\r\n"
}