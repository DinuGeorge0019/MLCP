{
    "link": "https://codeforces.com//contest/427/problem/D",
    "problemId": "9096",
    "problem_idx": "D",
    "shortId": "427D",
    "contest_number": "427",
    "problem_submissions": {
        "E": [
            6529676,
            6527850,
            6529995,
            6528507,
            6529891,
            6528022,
            6531554,
            6531662,
            6531650,
            6531698,
            6531712,
            6530455,
            6532065,
            6527906,
            6531472,
            6533495,
            6528109,
            6530245,
            6529960,
            6530613
        ],
        "D": [
            6527983,
            6529398,
            6528326,
            6530702,
            6534291,
            6529012,
            6529644,
            6529417,
            6530366,
            6530850,
            6529777,
            6528806,
            6532098,
            6529134,
            8322622,
            6531820,
            6528330
        ],
        "C": [
            6526456,
            6526319,
            6526893,
            6528943,
            6526905,
            6526400,
            6528201,
            6526648,
            6527081,
            6527815,
            6530569,
            6528401,
            6530942,
            6525719,
            6528319,
            6527086,
            6526075,
            6526591,
            6526667,
            6525971
        ],
        "B": [
            6524329,
            6524628,
            6525243,
            6524515,
            6525057,
            6524940,
            6525765,
            6524924,
            6525305,
            6528525,
            6525911,
            6525634,
            6525338,
            6523816,
            6528718,
            6524445,
            6524359,
            6525504,
            6525432,
            6526909
        ],
        "A": [
            6523077,
            6523845,
            6524661,
            6523545,
            6523918,
            6523933,
            6523978,
            6523356,
            6523252,
            6524775,
            6525360,
            6523618,
            6524309,
            6523039,
            6524259,
            6523009,
            6523402,
            6523741,
            6523222,
            6524142
        ]
    },
    "name": "D. Match   Catch",
    "statement": "Police headquarter is monitoring signal on different frequency levels.\r\nThey have got two suspiciously encoded strings and from two different\r\nfrequencies as signals. They are suspecting that these two strings are\r\nfrom two different criminals and they are planning to do some evil\r\ntask.Now they are trying to find a common substring of minimum length\r\nbetween these two strings. The substring must occur only once in the\r\nfirst string, and also it must occur only once in the second\r\nstring.Given two strings and consist of lowercase Latin letters, find\r\nthe smallest (by length) common substring of both and , where is a\r\nunique substring in and also in . See notes for formal definition of\r\nsubstring and uniqueness.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <string.h>\n#define max(a,b) ((a)>(b)?(a):(b))\n\nconst int N = 5001;\n\nchar str1[N];\nchar str2[N];\n\nint csa[N][N];\nint csb[N][N];\nint csab[N][N];\nint cna[N];\nint cnb[N];\n\nvoid calc(int d[N][N], char* a, int na, char* b, int nb)\n{\n  for (int i = na; i >= 0; i--)\n  {\n    for (int j = nb; j >= 0; j--)\n    {\n      if (i == na || j == nb || a[i] != b[j])\n        d[i][j] = 0;\n      else\n        d[i][j] = d[i + 1][j + 1] + 1;\n    }\n  }\n}\nvoid calc2(int d[N], int s[N][N], int n)\n{\n  for (int i = 0; i < n; i++)\n  {\n    d[i] = 0;\n    for (int j = 0; j < n; j++)\n      if (j != i && s[i][j] > d[i])\n        d[i] = s[i][j];\n  }\n}\n\nint main()\n{\n  //freopen(\"input.txt\", \"rt\", stdin);\n  //freopen(\"output.txt\", \"wt\", stdout);\n\n  scanf(\"%s %s\", str1, str2);\n  int n1 = strlen(str1);\n  int n2 = strlen(str2);\n\n  calc(csa, str1, n1, str1, n1);\n  calc(csb, str2, n2, str2, n2);\n  calc(csab, str1, n1, str2, n2);\n  calc2(cna, csa, n1);\n  calc2(cnb, csb, n2);\n\n  int best = -1;\n  for (int i = 0; i < n1; i++)\n  {\n    for (int j = 0; j < n2; j++)\n    {\n      int mx = max(cna[i], cnb[j]) + 1;\n      if (csab[i][j] >= mx && (best < 0 || best > mx))\n        best = mx;\n    }\n  }\n\n  printf(\"%d\", best);\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Match   Catch.json",
    "editorial_link": "https://codeforces.com//blog/entry/12082",
    "editorial": "Calculate the longest common prefix ( LCP\n) for each index of with each index of . Then, calculate LCP for each\nindex of with all the other indexes of itâs own ( ). Do the same for .\nNow from precalculated values, you can easily check the length of the\nshortest unique substring starting from any of the indexes of or .\nSuppose is an index of and is an index of . Find the LCP for and . Now,\nthe minimum of the length of LCP, length of shortest unique substring\nstarting from , length of shortest unique substring starting from is the\nanswer for ,. Now we need to find the minimum answer from all possible ,\npair. This problem can also be solved in by suffix array and in using\nsuffix automaton.\n",
    "hint": []
}