{
    "link": "https://codeforces.com//contest/615/problem/C",
    "problemId": "45131",
    "problem_idx": "C",
    "shortId": "615C",
    "contest_number": "615",
    "problem_submissions": {
        "D": [
            15246218,
            15243648,
            15241674,
            15242192,
            15244574,
            15242022,
            15243833,
            15247327,
            15245928,
            15245965,
            15250600,
            15244765,
            15244668,
            15243379,
            15244617,
            15245499,
            15246279,
            15242819
        ],
        "C": [
            15243771,
            15245552,
            15245503,
            15246881,
            15242164,
            15249238,
            15422750,
            15249506,
            15244269,
            15243604,
            15243504,
            15247689,
            15243273,
            15245397,
            15244917,
            15256203,
            15256783,
            15256658,
            15262298
        ],
        "E": [
            15241790,
            15242394,
            15249657,
            15250007,
            15248042,
            15246416,
            15250940,
            15251751,
            15248476,
            15250193,
            15254285,
            15249151,
            15249613,
            15242059,
            15248491,
            15248349,
            15250365
        ],
        "B": [
            15240908,
            15246431,
            15240992,
            15240867,
            15249484,
            15247141,
            15245895,
            15241449,
            15250210,
            15247251,
            15242653,
            15240727,
            15240692,
            15240772,
            15241317,
            15251939,
            15241564,
            15244142,
            15246779
        ],
        "A": [
            15238675,
            15239335,
            15238139,
            15237976,
            15238447,
            15239307,
            15239985,
            15238131,
            15248916,
            15237777,
            15240179,
            15237788,
            15238124,
            15238812,
            15238095,
            15252529,
            15238764,
            15239416,
            15239104
        ]
    },
    "name": "C. Running Track",
    "statement": "A boy named Ayrat lives on planet AMI-1511. Each inhabitant of this\r\nplanet has a talent. Specifically, Ayrat loves running, moreover, just\r\nrunning is not enough for him. He is dreaming of making running a real\r\nart.First, he wants to construct the running track with coating . On\r\nplanet AMI-1511 the coating of the track is the sequence of colored\r\nblocks, where each block is denoted as the small English letter.\r\nTherefore, every coating can be treated as a string.Unfortunately,\r\nblocks aren\u2019t freely sold to non-business customers, but Ayrat found an\r\ninfinite number of coatings . Also, he has scissors and glue. Ayrat is\r\ngoing to buy some coatings , then cut out from each of them (substring)\r\nand glue it to the end of his track coating. Moreover, he may choose to\r\nflip this block before glueing it. Ayrat want\u2019s to know the minimum\r\nnumber of coating he needs to buy in order to get the coating for his\r\nrunning track. Of course, he also want\u2019s to know some way to achieve the\r\nanswer.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 2100;\n\nint na, nb;\nchar a[maxn + 5], b[maxn + 5];\n\nint l[maxn + 5][maxn + 5];\n\npair<int, int> best[maxn + 5];\n\nint dp[maxn + 5], pre[maxn + 5];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%s%s\", a, b);\n\tna = strlen(a), nb = strlen(b);\n\tmemset(l, 0, sizeof l);\n\tfor (int i = nb - 1; i >= 0; --i)\n\t\tfor (int j = na - 1; j >= 0; --j)\n\t\t\tif (b[i] != a[j]) l[i][j] = 0;\n\t\t\telse l[i][j] = l[i + 1][j + 1] + 1;\n\tREP(i, 0, nb)\n\t{\n\t\tbest[i] = mp(0, -1);\n\t\tREP(j, 0, na) chkmax(best[i], mp(l[i][j], j << 1));\n\t}\n\treverse(a, a + na);\n\tmemset(l, 0, sizeof l);\n\tfor (int i = nb - 1; i >= 0; --i)\n\t\tfor (int j = na - 1; j >= 0; --j)\n\t\t\tif (b[i] != a[j]) l[i][j] = 0;\n\t\t\telse l[i][j] = l[i + 1][j + 1] + 1;\n\tREP(i, 0, nb) REP(j, 0, na) chkmax(best[i], mp(l[i][j], j << 1 | 1));\n\tmemset(pre, -1, sizeof pre);\n\tmemset(dp, oo, sizeof dp);\n\tdp[0] = 0;\n\tpre[0] = -1;\n\tREP(i, 0, nb)\n\t{\n\t\tREP(j, i + 1, i + best[i].x + 1)\n\t\t\tif (chkmin(dp[j], dp[i] + 1)) pre[j] = i;\n\t}\n\tif (pre[nb] == -1) printf(\"-1\\n\");\n\telse\n\t{\n\t\tprintf(\"%d\\n\", dp[nb]);\n\t\tint v = nb, u = pre[nb];\n\t\tvector<pair<int, int> > ans;\n\t\twhile (u >= 0)\n\t\t{\n\t\t\tif (best[u].y & 1) ans.pb(mp(na - (best[u].y >> 1), na - (best[u].y >> 1) - (v - u) + 1));\n\t\t\telse ans.pb(mp((best[u].y >> 1) + 1, (best[u].y >> 1) + v - u));\n\t\t\tv = u;\n\t\t\tu = pre[u];\n\t\t}\n\t\treverse(ALL(ans));\n\t\tfor (auto x : ans) printf(\"%d %d\\n\", x.x, x.y);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "strings",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Running Track.json",
    "editorial_link": "https://codeforces.com//blog/entry/22658",
    "editorial": "The idea is that if can make a substring t[i, j] using k coatings, then\r\nwe can also make a substring t[i + 1, j] using k coatings. So we should\r\nuse the longest substring each time. Let n = |s|, m = |t|. On each stage\r\nwe will search for the longest substring in s and s_reversed to update\r\nthe answer. We can do it in several ways: calculation lcp: code:\r\n15277213 Let\u00e2\u0080\u0099s check iterative t[i, i ] exists in s as a substring, t[i,\r\ni + 1] t[i, i + 2] . We will make an array endPos, where endPos[j] is\r\ntrue when t[i, i + cur_len - 1] = s[j - cur_len + 1, j] (t[1, i 1]\r\ngreedy already got). We will update this array, adding symbols t[i],\r\nt[i + 1], t[i + 2] and so on. We will make one more array for\r\ns_reversed. (more details in code) Overall time complexity will be code:\r\n15260867 trie solution: 15260870 Can you solve with complexity? ? ?\r\nalphabet size.\r\n"
}