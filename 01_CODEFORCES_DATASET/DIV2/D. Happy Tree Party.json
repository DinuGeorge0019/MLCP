{"link": "https://codeforces.com//contest/593/problem/D", "problemId": "40049", "problem_idx": "D", "shortId": "593D", "contest_number": "593", "problem_submissions": {"E": [14074831, 14071839, 14069012, 14112263, 14101227, 14078183, 14073295, 14073367], "D": [14071251, 14067776, 14071547, 14071080, 14071834, 14069627, 14072451, 14072921, 14072768, 14072117, 14072979, 14072065, 14072780, 14073132, 14073238], "B": [14065295, 14080270, 14065853, 14065770, 14066413, 14066282, 14075373, 14072184, 14066079, 14066654, 14066024, 14067374, 14064950, 14066946, 14073180, 14067257, 14066769, 14067908, 14066629], "A": [14064191, 14073716, 14064213, 14064573, 14064399, 14064679, 14064276, 14064487, 14064593, 14064652, 14065927, 14064315, 14065183, 14065251, 14065732, 14064991, 14065641, 14065343], "C": [14105964, 14078413, 14072751]}, "name": "D. Happy Tree Party", "statement": "Bogdan has a birthday today and mom gave him a tree consisting of\r\nvertecies. For every edge of the tree , some number was written on it.\r\nIn case you forget, a tree is a connected non-directed graph without\r\ncycles. After the present was granted, guests consecutively come to\r\nBogdan\u2019s party. When the -th guest comes, he performs exactly one of the\r\ntwo possible operations: Chooses some number , and two vertecies and .\r\nAfter that, he moves along the edges of the tree from vertex to vertex\r\nusing the shortest path (of course, such a path is unique in the tree).\r\nEvery time he moves along some edge , he replaces his current number by\r\n, that is, by the result of integer division div . Chooses some edge and\r\nreplaces the value written in it by some positive integer . As Bogdan\r\ncares about his guests, he decided to ease the process. Write a program\r\nthat performs all the operations requested by guests and outputs the\r\nresulting value for each of the first type.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 100;\nconst int MAXL = 18;\n\nint N, M;\npair<int, int> edge[MAXN];\nvector<pair<int, ll>> adj[MAXN];\n\nll edge_up[MAXN];\nint depth[MAXN];\nint par[MAXN][MAXL];\n\nvoid fill(int loc, int abv) {\n    par[loc][0] = abv;\n    for (int l = 1; l < MAXL; l++)\n        par[loc][l] = par[par[loc][l-1]][l-1];\n\n    for (auto v : adj[loc]) {\n        if (v.first == abv) continue;\n\n        depth[v.first] = depth[loc] + 1;\n        edge_up[v.first] = v.second;\n\n        fill(v.first, loc);\n    }\n}\n\nint go_up(int loc, int far) {\n    for (int l = 0; l < MAXL; l++)\n        if ((far >> l) & 1)\n            loc = par[loc][l];\n    return loc;\n}\n\nint lca(int a, int b) {\n    if (depth[a] < depth[b]) swap(a, b);\n    a = go_up(a, depth[a] - depth[b]);\n    if (a == b) return a;\n\n    for (int l = MAXL - 1; l >= 0; l--) {\n        if (par[a][l] != par[b][l]) {\n            a = par[a][l];\n            b = par[b][l];\n        }\n    }\n\n    return par[a][0];\n}\n\nstruct union_find{\n    vector<int> P, R, S;\n    vector<pair<int, int>> SM;\n    \n    union_find(int N){\n        P.resize(N), R.resize(N), S.resize(N), SM.resize(N);\n        for(int i=0; i<N; i++){\n            P[i] = i;\n            R[i] = 0;\n            S[i] = 1;\n            SM[i] = make_pair(depth[i], i);\n        }\n    }\n    \n    int rep(int i){\n        if(P[i] != i) P[i] = rep(P[i]);\n        return P[i];\n    }\n\n    bool unio(int a, int b){\n        a = rep(a), b = rep(b);\n        if(a == b) return false;\n        if(R[a] < R[b]) swap(a, b);\n        P[b] = a;\n        S[a] += S[b];\n        if(R[a] == R[b]) R[a]++;\n\n        if (SM[b].first < SM[a].first)\n            SM[a] = SM[b];\n\n        return true;\n    }\n};\n\nll solve(union_find &uf, int a, int b, ll V) {\n    int p = lca(a, b);\n\n    while (V > 0) {\n        int ra = uf.rep(a);\n        a = uf.SM[ra].second;\n\n        if (depth[a] <= depth[p]) break;\n        V /= edge_up[a];\n        a = par[a][0];\n    }\n\n    while (V > 0) {\n        int rb = uf.rep(b);\n        b = uf.SM[rb].second;\n\n        if (depth[b] <= depth[p]) break;\n        V /= edge_up[b];\n        b = par[b][0];\n    }\n\n    return V;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0), cout.precision(15);\n\n    cin >> N >> M;\n\n    for (int i = 0; i < N - 1; i++) {\n        int &u = edge[i].first;\n        int &v = edge[i].second;\n        ll c;\n\n        cin >> u >> v >> c;\n        u--, v--;\n\n        adj[u].emplace_back(v, c);\n        adj[v].emplace_back(u, c);\n    }\n\n    fill(0, 0);\n\n    union_find uf(N);\n\n    for (int i = 1; i < N; i++) {\n        if (edge_up[i] == 1) {\n            uf.unio(i, par[i][0]);\n        }\n    }\n\n    int T, A, B, P;\n    ll Y, C;\n\n    for (int i = 0; i < M; i++) {\n        cin >> T;\n        if (T == 1) {\n            cin >> A >> B >> Y;\n            cout << solve(uf, A - 1, B - 1, Y) << \"\\n\";\n        } else {\n            cin >> P >> C;\n            P--;\n            int u = edge[P].first;\n            int v = edge[P].second;\n\n            if (depth[u] > depth[v]) swap(u, v);\n            edge_up[v] = C;\n            if (C == 1) uf.unio(u, v);\n        }\n    }\n}\n\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "math", "trees"], "dificulty": "2400", "interactive": false}