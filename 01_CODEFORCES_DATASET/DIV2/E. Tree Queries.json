{
    "link": "https://codeforces.com//contest/1904/problem/E",
    "problemId": "2374325",
    "problem_idx": "E",
    "shortId": "1904E",
    "contest_number": "1904",
    "problem_submissions": {
        "F": [
            236570080,
            236576621,
            236554431,
            236568040,
            236582005,
            236574981,
            236880626,
            236880480,
            236569573
        ],
        "E": [
            236554914,
            236578860,
            236576444,
            236573774,
            238458664,
            236560297,
            236558822,
            236558918,
            236569149,
            236563127,
            236567711,
            236569198,
            236566626,
            236565306,
            236568569,
            236566882,
            236569261,
            236579274,
            236552305,
            236552808,
            236798985
        ],
        "D1": [
            236545065,
            236536170,
            236543035,
            236535328,
            236546645,
            236545333,
            236534429,
            236543154,
            236535118,
            236545269,
            236548952,
            236561907,
            236552142,
            236547668,
            236547285,
            236579190,
            236560952,
            236535340,
            236566707
        ],
        "D2": [
            236544975,
            236536268,
            236547976,
            236535232,
            236546707,
            236545240,
            236539045,
            236543101,
            236535019,
            236550494,
            236549022,
            236539644,
            236552226,
            236551334,
            236547141,
            236579204,
            236562744,
            236535269,
            236566631
        ],
        "C": [
            236537578,
            236532163,
            236538305,
            236529701,
            236530813,
            236537981,
            236531278,
            236536485,
            236540998,
            236534952,
            236537201,
            236530975,
            236533757,
            236539773,
            236559221,
            236579140,
            236529162,
            236713604,
            236530644
        ],
        "B": [
            236533750,
            236526956,
            236527715,
            236527401,
            236528167,
            236531303,
            236527554,
            236530718,
            236528605,
            236528181,
            236531779,
            236528715,
            236530882,
            236530328,
            236531954,
            236579315,
            236527688,
            236526407,
            236558484,
            236528501
        ],
        "A": [
            236526415,
            236525678,
            236525809,
            236525816,
            236525646,
            236527341,
            236525550,
            236527627,
            236527718,
            236525848,
            236525742,
            236526468,
            236525731,
            236528067,
            236527808,
            236579299,
            236525701,
            236525590,
            236554437,
            236526433
        ]
    },
    "name": "E. Tree Queries",
    "statement": "Santa, Hayate has a tree with n nodes.Hayate now wants you to answer q\r\nqueries. Each query consists of a node x and k other additional nodes\r\na_1,a_2,\r\nldots,a_k. These k+1 nodes are guaranteed to be all distinct.For each\r\nquery, you must find the length of the longest simple path starting at\r\nnode x^\r\ndagger after removing nodes a_1,a_2,\r\nldots,a_k along with all edges connected to at least one of nodes\r\na_1,a_2,\r\nldots,a_k.^\r\ndagger A simple path of length k starting at node x is a sequence of\r\nnodes x=u_0,u_1,\r\nldots,u_k such that there exists a edge between nodes u_{i-1} and u_i\r\nfor all 1\r\nleq i\r\nleq k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nint n, q;\nvector<int> tr[N];\nvector<int> ask[N], ver[N];\nint ans[N];\n\nint dep[N], fa[N], st[N], ed[N], id[N], cnt;\n\nvoid pdfs(int u, int pre) {\n\tdep[u] = dep[pre] + 1, fa[u] = pre;\n\tst[u] = ++cnt, id[cnt] = u;\n\tfor (int v : tr[u])\n\t\tif (v != pre)\n\t\t\tpdfs(v, u);\n\ted[u] = cnt;\n}\n\ninline bool cmp(int i, int j) { return st[i] < st[j]; }\n\n#define ls(x) (x << 1)\n#define rs(x) (x << 1 | 1)\n\nint val[N << 2], add[N << 2];\n\ninline void pushup(int x) {\n\tval[x] = max(val[ls(x)], val[rs(x)]);\n}\n\nvoid build(int x = 1, int l = 1, int r = n) {\n\tif (l == r) {\n\t\tval[x] = dep[id[l]] - 1;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(x), l, mid);\n\tbuild(rs(x), mid + 1, r);\n\tpushup(x);\n}\n\ninline void pushdown(int x) {\n\tif (add[x]) {\n\t\tval[ls(x)] += add[x];\n\t\tval[rs(x)] += add[x];\n\t\tadd[ls(x)] += add[x];\n\t\tadd[rs(x)] += add[x];\n\t\tadd[x] = 0;\n\t}\n}\n\nvoid update(int L, int R, int v, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\tval[x] += v;\n\t\tadd[x] += v;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tpushdown(x);\n\tif (L <= mid) update(L, R, v, ls(x), l, mid);\n\tif (R > mid) update(L, R, v, rs(x), mid + 1, r);\n\tpushup(x);\n}\n\nint query(int L, int R, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) return val[x];\n\tint mid = (l + r) >> 1, res = 0;\n\tpushdown(x);\n\tif (L <= mid) res = max(res, query(L, R, ls(x), l, mid));\n\tif (R > mid) res = max(res, query(L, R, rs(x), mid + 1, r));\n\treturn res;\n}\n\nint len;\npair<int, int> seg[N << 1];\n\nvoid dfs(int u) {\n\tfor (int i : ask[u]) {\n\t\tlen = 0;\n\t\tfor (int x : ver[i]) {\n\t\t\tif (x == u) seg[++len] = pair<int, int>(1, n);\n\t\t\telse if (st[u] >= st[x] && ed[u] <= ed[x]) {\n\t\t\t\tint y = *(upper_bound(tr[x].begin(), tr[x].end(), u, cmp) - 1);\n\t\t\t\tif (st[y] > 1) seg[++len] = pair<int, int>(1, st[y] - 1);\n\t\t\t\tif (ed[y] < n) seg[++len] = pair<int, int>(ed[y] + 1, n);\n\t\t\t} else {\n\t\t\t\tseg[++len] = pair<int, int>(st[x], ed[x]);\n\t\t\t}\n\t\t}\n\t\tsort(seg + 1, seg + len + 1);\n\t\tint mx = 0;\n\t\tfor (int j = 1; j <= len; ++j) {\n\t\t\tint l, r;\n\t\t\ttie(l, r) = seg[j];\n\t\t\tif (mx + 1 <= l - 1) ans[i] = max(ans[i], query(mx + 1, l - 1));\n\t\t\tmx = max(mx, r);\n\t\t}\n\t\tif (mx + 1 <= n) ans[i] = max(ans[i], query(mx + 1, n));\n\t}\n\tfor (int v : tr[u]) {\n\t\tif (v == fa[u]) continue;\n\t\tupdate(1, n, 1), update(st[v], ed[v], -2);\n\t\tdfs(v);\n\t\tupdate(1, n, -1), update(st[v], ed[v], 2);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> q;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint x, k;\n\t\tcin >> x >> k;\n\t\tver[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) cin >> ver[i][j];\n\t\task[x].push_back(i);\n\t}\n\tpdfs(1, 0);\n\tfor (int i = 1; i <= n; ++i) sort(tr[i].begin(), tr[i].end(), cmp);\n\tbuild();\n\tdfs(1);\n\tfor (int i = 1; i <= q; ++i) cout << ans[i] << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/123160",
    "editorial": "SolutionConsider the Euler tour of the tree where is the entry time of\r\neach node and is the exit time. The interval corresponds to the subtree\r\nof . Removing a node is equivalent to blocking some intervals on the\r\nEuler tour. There are two cases when is blocked with respect to query\r\nnode . If is an ancestor of , then the set of reachable nodes is reduced\r\nto the interval , where is the first node on the path from to . This is\r\nequivalent to blocking the intervals and . If is not an ancestor, then\r\nthe interval is blocked.Lets build a lazy segment tree on the Euler tour\r\nof the tree. Each leaf node will correspond to the depth of a node on\r\nthe tree. We can re-root the tree from to by subtracting one from all\r\nnodes the range and adding one to all other nodes. Thus, we can traverse\r\nthe tree while re-rooting and process our queries offline. When the\r\nquery node is the root, block all the necessary intervals and then find\r\nthe maximum value in the segment tree.\r\n",
    "hint": [
        "Hint 1 The solution doesn't involve virtual tree",
        "Hint 2 What is an easy way to represent the tree?",
        "Hint 1 In a tree, one of the farthest nodes from some node is one of the two endpoints of the diameter.",
        "Hint 2 Let's try to find the diameter of the connected subgraph node is in after the nodes are removed.",
        "Hint 3 Consider an euler tour of the tree and order the nodes by their inorder traversal. When nodes are removed, the remaining nodes form contiguous intervals in the tour."
    ]
}