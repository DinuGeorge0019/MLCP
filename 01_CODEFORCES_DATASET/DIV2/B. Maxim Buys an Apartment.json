{"link": "https://codeforces.com//contest/854/problem/B", "problemId": "121094", "problem_idx": "B", "shortId": "854B", "contest_number": "854", "problem_submissions": {"E": [30148890, 30158025, 30153207, 30152099, 30153347, 30153605, 30153960, 30156519, 30155338, 30152255, 30155374, 30156465, 30154492, 30155027, 30148559, 30154341, 30150107, 30159302, 30147585, 30149154], "D": [30145685, 30142579, 30146315, 30147771, 30145357, 30143469, 30147555, 30149225, 30160358, 30148581, 30148332, 30147340, 30151054, 30154650, 30153132, 30141029, 30169028, 30157758, 30157493, 30145363, 30157424, 30143188], "C": [30138936, 30136736, 30141613, 30138597, 30141883, 30137426, 30140011, 30142683, 30144635, 30142411, 30142409, 30142369, 30142517, 30150426, 30151674, 30137870, 30138345, 30140659, 30136856, 30172754, 30148019], "B": [30137227, 30133256, 30139063, 30133886, 30139922, 30134279, 30135422, 30135809, 30140613, 30136252, 30139573, 30137665, 30140693, 30154807, 30155358, 30135403, 30136178, 30140207, 30133289, 30134600], "A": [30136803, 30131896, 30136932, 30132115, 30139440, 30132166, 30132064, 30131930, 30132413, 30132484, 30133433, 30131987, 30139438, 30153559, 30131806, 30133316, 30132007, 30137844, 30131966, 30135700]}, "name": "B. Maxim Buys an Apartment", "statement": "Maxim wants to buy an apartment in a new house at Line Avenue of\r\nMetropolis. The house has apartments that are numbered from to and are\r\narranged in a row. Two apartments are adjacent if their indices differ\r\nby . Some of the apartments can already be inhabited, others are\r\navailable for sale.Maxim often visits his neighbors, so apartment is for\r\nhim if it is available for sale and there is at least one already\r\ninhabited apartment adjacent to it. Maxim knows that there are exactly\r\nalready inhabited apartments, but he doesn\u2019t know their indices yet.Find\r\nout what could be the minimum possible and the maximum possible number\r\nof apartments that are good for Maxim.\r\n", "solutions": ["#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int &x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char &x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char *x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf &x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf &x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint &x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull &x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char *x){while(*x)P(*x++);RT}\nI Fw&OP()(const char *x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nint main()\n{\n\tint x=in,y=in;\n\tif(y==0||y==x)out,0,' ',0,'\\n';\n\telse out,1,' ',min(x-y,y*2),'\\n';\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "1200", "interactive": false}