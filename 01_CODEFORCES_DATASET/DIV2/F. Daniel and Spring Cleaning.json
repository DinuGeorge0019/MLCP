{"link": "https://codeforces.com//contest/1245/problem/F", "problemId": "456079", "problem_idx": "F", "shortId": "1245F", "contest_number": "1245", "problem_submissions": {"F": [64010477, 64009886, 64014319, 64150819, 64002324, 64004647, 64015739, 64002490, 64015888, 64014383, 64013493, 64015031, 64011720, 64026953, 64021476, 64018260, 64031462, 64031970, 64021775, 64023172], "E": [64006910, 64015295, 64016337, 64021964, 64020329, 64023633, 64021101, 64021058, 64022796, 64020913, 64022965, 64022978, 64020972, 64029225, 64026181, 64018441, 64017598, 64027038, 64029618], "D": [64002898, 64003958, 64002526, 64016634, 64013877, 64004966, 64016399, 64011069, 64010801, 64007938, 64006781, 64015310, 64008535, 64005186, 64010692, 64009342, 64009799, 64014521, 64014195], "C": [63999164, 64000498, 64005851, 64003393, 64010042, 64000573, 64010656, 64003837, 64005015, 63999349, 64002111, 63996519, 64003084, 64000048, 64002428, 64002402, 63999517, 64005913, 64002319], "B": [63997617, 63998088, 64001465, 63998805, 64003870, 63998306, 64008480, 64001186, 63999749, 64027106, 64016776, 64027202, 64000627, 64000016, 64005778, 63999988, 64002993, 63999540, 63999182], "A": [63995951, 63995957, 63997656, 63996018, 63998793, 63996004, 64003787, 63998279, 63996658, 64024063, 63995955, 63998248, 63997191, 63996609, 63995990, 63996228, 63999456, 63996540, 63996316]}, "name": "F. Daniel and Spring Cleaning", "statement": "While doing some spring cleaning, Daniel found an old calculator that he\r\nloves so much. However, it seems like it is broken. When he tries to\r\ncompute 1 + 3 using the calculator, he gets 2 instead of 4. But when he\r\ntries computing 1 + 4, he gets the correct answer, 5. Puzzled by this\r\nmystery, he opened up his calculator and found the answer to the riddle:\r\nthe full adders became half adders! So, when he tries to compute the sum\r\na + b using the calculator, he instead gets the xorsum a\r\noplus b (read the definition by the link:\r\nhttps://en.wikipedia.org/wiki/Exclusive_or).As he saw earlier, the\r\ncalculator sometimes gives the correct answer. And so, he wonders, given\r\nintegers l and r, how many pairs of integers (a, b) satisfy the\r\nfollowing conditions: a + b = a\r\noplus b l\r\nleq a\r\nleq r l\r\nleq b\r\nleq rHowever, Daniel the Barman is going to the bar and will return in\r\ntwo hours. He tells you to solve the problem before he returns, or else\r\nyou will have to enjoy being blocked.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n\nmap<pair<int, int>, long long > M;\nlong long solve(int a, int b)\n{\n    if(a==-1 || b== -1) return 0LL;\n    if(a == 0 || b == 0) return a+b+1;\n    if(a>b) swap(a, b);\n    auto it = M.find(make_pair(a,b));\n    if(it!=M.end())\n    {\n        return it->second;\n    }\n    int lb = 0;\n    for(int i=30; i>=0; --i)\n    {\n        if( (a&(1<<i))||(b&(1<<i)) )\n        {\n            lb = i;\n            break;\n        }\n    }\n\n    long long ans = 0;\n    // both 0,\n    {\n        int na = min(a, (1<<lb)-1);\n        int nb = min(b, (1<<lb)-1);\n        ans += solve(na, nb);\n    }\n    //a: 1 b = 0;\n    if(a >= (1<<lb))\n    {\n        int na = a-(1<<lb);\n        int nb = min(b, (1<<lb)-1);\n        ans += solve(na, nb);\n    }\n    //a: 0 b = 1;\n    if(b >= (1<<lb))\n    {\n        int na = min(a, (1<<lb)-1);\n        int nb = b-(1<<lb);\n        ans += solve(na, nb);\n    }\n\n\n    return M[make_pair(a, b)] = ans;\n}\nint main()\n{\n    int T; scanf(\"%d\", &T);\n    while(T--)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        long long ans = solve(b, b) - 2*solve(b, a-1) + solve(a-1, a-1);\n        printf(\"%lld\\n\", ans);\n    }\n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "combinatorics", "dp"], "dificulty": "2300", "interactive": false}