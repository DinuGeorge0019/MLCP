{
    "link": "https://codeforces.com//contest/2107/problem/F1",
    "problemId": "3369878",
    "problem_idx": "F1",
    "shortId": "2107F1",
    "contest_number": "2107",
    "problem_submissions": {
        "F2": [
            318524340,
            318484817,
            318509938,
            318511203,
            318525439,
            318523594,
            318519776
        ],
        "F1": [
            318519651,
            318487840,
            318492813,
            318505063,
            318504824,
            318527743,
            318517545,
            318515290,
            318492245,
            318507170,
            318502926,
            318494892,
            318509274,
            318493554,
            318492460,
            318538698,
            318513104
        ],
        "E": [
            318507496,
            318520903,
            318524820,
            319045355,
            318517429,
            318526986,
            318522135,
            318520283
        ],
        "D": [
            318493293,
            318536403,
            318487166,
            318499916,
            318508438,
            318508583,
            318505898,
            318493577,
            318513154,
            318499523,
            318510734,
            318518593,
            318502474,
            318501316,
            318505642
        ],
        "C": [
            318476342,
            318476070,
            318476829,
            318476779,
            318475602,
            318489984,
            318490878,
            318480285,
            318468986,
            318484993,
            318479001,
            318481099,
            318477842,
            318483418,
            318469245,
            318475881,
            318486336
        ],
        "B": [
            318459029,
            318461790,
            318460834,
            318460140,
            318461949,
            318460838,
            318465148,
            318465596,
            318462205,
            318463062,
            318467674,
            318475025,
            318483564,
            318464926,
            318482093,
            318463365,
            318465794
        ],
        "A": [
            318456403,
            318456545,
            318456374,
            318456379,
            318456465,
            318456630,
            318465029,
            318458451,
            318456594,
            318457358,
            318459958,
            318457429,
            318485822,
            318458433,
            318472714,
            318456756,
            318458361
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142642",
    "editorial": "SolutionLet us try to figure out the optimal strategy. We want to use\r\nsmall values for the \"overtake\" operation, and we will use \"swap\"\r\noperations to make the overtakes less costly. Suppose first position of\r\nminima element. We should over take cyclists for the cost of , swapping\r\ntill first. This is because all is , and so the swap + overtake can’t be\r\nworse. And obviously, if we are using , it is less costly in terms of\r\nswaps to use since the overtake cost cannot be worse.Now, we might use\r\nthe value for overtakes in the suffix as well, i.e. there exists some\r\nsuch that we overtake cyclists using . This reduces the problem to the\r\nsubproblem , and thus we can use Dynamic Programming! But why are the\r\nproblems independent in and the rest of the array? Suppose that we took\r\nsome to be used for swaps in the suffix , but we could then instead set\r\nup the swaps such that first reaches , and then is taken for these\r\nsuffix swaps. This won’t add any additional swaps, and may only reduce\r\nthe cost.Let be the answer for the suffix . Then, we compute position of\r\nminima in , iterate on partition index such that we will take to using\r\nit for swaps , value computed as , where denotes the total swaps made\r\n().This solves the problem in .\r\n",
    "name": "F1. Cycling  Easy Version ",
    "statement": "Leo works as a programmer in the city center, and his lover teaches at a\r\nhigh school in the suburbs. Every weekend, Leo would ride his bike to\r\nthe suburbs to spend a nice weekend with his lover.There are n cyclists\r\nriding in front of Leo on this road right now. They are numbered 1, 2,\r\nldots, n from front to back. Initially, Leo is behind the n-th cyclist.\r\nThe i-th cyclist has an agility value a_i. Leo wants to get ahead of the\r\n1-st cyclist. Leo can take the following actions as many times as he\r\nwants: Assuming that the first person in front of Leo is cyclist i, he\r\ncan go in front of cyclist i for a cost of a_i. This puts him behind\r\ncyclist i - 1. Using his super powers, swap a_i and a_j (1\r\nle i < j\r\nle n) for a cost of (j - i). Leo wants to know the minimum cost to get\r\nin front of the 1-st cyclist. Here you only need to print the answer for\r\nthe whole array, i.e. [a_1, a_2,\r\nldots, a_n].\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F1. Cycling  Easy Version .json",
    "hint": []
}