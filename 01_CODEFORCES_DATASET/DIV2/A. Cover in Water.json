{"link": "https://codeforces.com//contest/1900/problem/A", "problemId": "2348158", "problem_idx": "A", "shortId": "1900A", "contest_number": "1900", "problem_submissions": {"E": [234456838, 234455027, 234457931, 234455766, 234456771, 234460502, 234461970, 234463093, 234461258, 234461626, 235437599, 234459471, 234465112, 234465941, 234463278, 234463477, 234464668, 234464310, 234465647, 234465136], "D": [234442999, 234445532, 234447119, 234444027, 234448662, 234449846, 234450821, 234448590, 234544232, 234544122, 234453539, 234456816, 234449461, 234446745, 234447346, 234455068, 234451202, 234455283, 234455174, 234452017, 234447175], "C": [234433856, 234437020, 234438208, 234438984, 234436746, 234440214, 234440440, 234440880, 234441500, 234437974, 234441984, 234439314, 234438351, 234441349, 234441838, 234441318, 234441667, 234442122, 234444120], "B": [234430889, 234432938, 234432800, 234433842, 234432820, 234435211, 234434789, 234436751, 234434039, 234432505, 234436824, 234433963, 234433725, 234434390, 234437612, 234436752, 234436425, 234432619, 234438330], "A": [234429140, 234429060, 234429292, 234429383, 234429959, 234434373, 234428876, 234431698, 234428932, 234429000, 234431129, 234431009, 234429251, 234429090, 234434493, 234430325, 234429412, 234429176, 234429387], "F": [234821914, 234821787]}, "name": "A. Cover in Water", "statement": "Filip has a row of cells, some of which are blocked, and some are empty.\r\nHe wants all empty cells to have water in them. He has two actions at\r\nhis disposal: 1 place water in an empty cell. 2 remove water from a cell\r\nand place it in any other empty cell. If at some moment cell i (2\r\nle i\r\nle n-1) is empty and both cells i-1 and i+1 contains water, then it\r\nbecomes filled with water.Find the minimum number of times he needs to\r\nperform action 1 in order to fill all empty cells with water. Note that\r\nyou don\u2019t need to minimize the use of action 2. Note that blocked cells\r\nneither contain water nor can Filip place water in them.\r\n", "solutions": ["#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < '0' || c > '9') c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x;\n}\nint ans, n, a[105], cnt = 0;\nchar s[105];\nvoid solve(){\n\tscanf(\"%d%s\", &n, s + 1);\n\tcnt = 0; ans = 0;\n\tfor(int i = 1, j; i <= n; i = j + 1){\n\t\tj = i; if(s[j] == '#') continue;\n\t\twhile(j < n && s[j + 1] == '.') ++j;\n\t\ta[++cnt] = j - i + 1; \n\t}\n\tint yes = 0;\n\tfor(int i = 1; i <= cnt; ++i) if(a[i] >= 3) yes = 1;\n\tif(yes) printf(\"2\\n\");\n\telse {\n\t\tfor(int i = 1; i <= cnt; ++i) ans += a[i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(\"%d\", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "implementation", "strings"], "dificulty": "800", "interactive": false}