{
    "link": "https://codeforces.com//contest/599/problem/E",
    "problemId": "41192",
    "problem_idx": "E",
    "shortId": "599E",
    "contest_number": "599",
    "problem_submissions": {
        "D": [
            14373739,
            14373664,
            14394221,
            14375180,
            14375137,
            14375830,
            14374794,
            14372514,
            14378293,
            14374356,
            14380491,
            14376576,
            14377604,
            14379482,
            14375007,
            14373832,
            14379192,
            14384201,
            14378143,
            14374835,
            14375909
        ],
        "C": [
            14369474,
            14370302,
            14371990,
            14366448,
            14371734,
            14369913,
            14369228,
            14371288,
            14371880,
            14370952,
            14370316,
            14371725,
            14372878,
            14369085,
            14371250,
            14372876,
            14369840,
            14370142,
            14369299,
            14369577
        ],
        "B": [
            14367721,
            14365689,
            14367534,
            14376988,
            14368981,
            14368542,
            14366919,
            14366011,
            14371510,
            14368972,
            14367928,
            14368335,
            14367992,
            14366870,
            14370057,
            14371458,
            14366298,
            14368075,
            14367504
        ],
        "A": [
            14363461,
            14367023,
            14364757,
            14369525,
            14385293,
            14364759,
            14363593,
            14363286,
            14364018,
            14364707,
            14365621,
            14364489,
            14364779,
            14363557,
            14367419,
            14365247,
            14363341,
            14364093,
            14364413,
            14363223
        ],
        "E": [
            14379749,
            14385538
        ]
    },
    "name": "E. Sandy and Nuts",
    "statement": "is a connected graph without any simple cycles with one vertex selected\r\nas a root. In this problem the vertex number will always serve as a\r\nroot. of two vertices and is the farthest from the root vertex that lies\r\non both the path from to the root and on path from to the root. We will\r\ndenote it as .Sandy had a rooted tree consisting of vertices that she\r\nused to store her nuts. Unfortunately, the underwater storm broke her\r\ntree and she doesn\u2019t remember all it\u2019s edges. She only managed to\r\nrestore edges of the initial tree and triples , and , for which she\r\nsupposes .Help Sandy count the number of trees of size with vertex as a\r\nroot, that match all the information she remembered. If she made a mess\r\nand there are no such trees then print . Two rooted trees are considered\r\nto be distinct if there exists an edge that occur in one of them and\r\ndoesn\u2019t occur in the other one.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define pll pair < ll, ll >\n#define all(s) s.begin(), s.end()\n#define sz(s) (int) s.size()\n#define vi vector < int >\n\n\nconst int inf = (1ll << 31) - 1;\nconst int mod = (int) 1e9 + 7;\n\nint n, m, q;\nint a[111], b[111], c[111];\nint A[111], B[111];\nll dp[15][1<<14];\n\nll calc(int v, int mask){\n    if ( mask == 0 ) return 1;\n\n    ll &res = dp[v][mask];\n    if ( res != -1 ) return res;\n    res = 0;\n\n\n\n    for (int i=0;i<q;i++){\n        if ( a[i] == v && b[i] == v && c[i] != v) return 0;\n\n        if ( (a[i] == v && (mask&(1<<b[i]))) && c[i] != v ){\n            return res = 0;\n        }\n        if ( (b[i] == v && (mask&(1<<a[i]))) && c[i] != v ){\n            return res = 0;\n        }\n    }\n\n\n    int id = 0;\n    for (int i=0;i<n;i++){\n        if (mask&(1<<i) ){\n            id = i;\n            break;\n        }\n    }\n\n    for (int s=mask;s>0;s=mask&(s-1)){\n        if (s&(1<<id))\n        for (int i=0;i<n;i++){\n            if (s&(1<<i)){\n                \n                int t = mask^s;\n\n                ll val2 = calc(v, t);\n                ll val1 = calc(i, s^(1<<i));\n\n                bool bad = false;\n                for (int j=0;j<q;j++){\n                    if ( c[j] == v){\n                        if ( (s&(1<<a[j])) && (s&(1<<b[j]))){\n                            bad = true;\n                            break;                          \n                        }\n                    }\n                    else {\n                        if ( (s&(1<<a[j])) && (t&(1<<b[j])) ) bad = true;\n                        if ( (t&(1<<a[j])) && (s&(1<<b[j])) ) bad = true;\n\n                        if ( (s&(1<<c[j])) && (t&(1<<b[j])) ) bad = true;\n                        if ( (t&(1<<c[j])) && (s&(1<<b[j])) ) bad = true;\n\n\n                        if ( (s&(1<<c[j])) && (t&(1<<a[j])) ) bad = true;\n                        if ( (t&(1<<c[j])) && (s&(1<<a[j])) ) bad = true;\n\n                    }\n                }\n\n\n                for (int j=0;j<m;j++){\n                    if ( (s&(1<<A[j])) && (t&(1<<B[j])) ) bad = true;\n                    if ( (t&(1<<A[j])) && (s&(1<<B[j])) ) bad = true;\n                    if ( A[j] == v && B[j] == i ) continue;\n                    if ( B[j] == v && A[j] == i ) continue;\n                    if ( A[j] == v && (s&(1<<B[j])) ) bad = true;\n                    if ( B[j] == v && (s&(1<<A[j])) ) bad = true;\n                }\n\n                if (bad) continue;\n\n                res += val1*val2;\n\n            }\n        }   \n    }\n    \n    return res;\n    \n}\n\nint main () {\n    #ifdef LOCAL\n    freopen (\"a.in\", \"r\", stdin);\n    freopen (\"a.out\", \"w\", stdout);\n    #endif\n\n\n    scanf(\"%d%d%d\", &n, &m, &q);\n\n    for (int i=0;i<m;i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        u--; v--;\n        A[i] = u;\n        B[i] = v;\n    }\n\n    for (int i=0;i<q;i++){\n        scanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n        a[i]--; b[i]--; c[i]--;\n    }\n\n    // check corner case\n\n    memset(dp, -1, sizeof(dp));\n    cout <<calc(0, ((1<<n)-1)^1)<<endl;\n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    #endif\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Sandy and Nuts.json",
    "editorial_link": "https://codeforces.com//blog/entry/21685",
    "editorial": "The solution for this problem is dynamic programming.\n\nLet froot,?mask is the number of ways to build a tree with root in vertex root using vertices from the mask mask and all restrictions were met. For convenience we shall number the vertices from zero.\n\nThe answer is f0,?2n?-?1.\n\nTrivial states are the states where a mask has only one single bit. In such cases froot,?mask?=?1.\n\nLet's solve this task recursively with memorization. To make the transition, we need to choose some kind of mask newMask, which is necessarily is the submask of mask mask. Then we should try to find new root newRoot in mask newMask. Also, in order not to count the same tree repeatedly impose conditions on the mask newMask. Namely, we shall take only such masks newMask, in which the senior bit (not in charge of the root) coincides with a senior bit (not in charge of the root) of the mask mask. After that, you need to check the fulfillment of all conditions to the edges and to the lca. If everything is OK, update . Where  means xor.\n\nWhat about checking lca, it's possible to do it in time O(N2) \u0097 previously memorized lca for each pair or in the worst case in time O(Q) just iterating through all pairs of vertices, for which some vertex v is lca."
}