{
    "link": "https://codeforces.com//contest/746/problem/D",
    "problemId": "85372",
    "problem_idx": "D",
    "shortId": "746D",
    "contest_number": "746",
    "problem_submissions": {
        "F": [
            23098160,
            23101734,
            23098656,
            23102651,
            23103415,
            23107961,
            23097485,
            23103112,
            23103543,
            23134726,
            23104852,
            23131476
        ],
        "G": [
            23093374,
            23095345,
            23096484,
            23099554,
            23094331,
            23098793,
            32644514,
            23097257,
            23097589,
            23088737,
            23098418,
            23099935,
            23101255,
            23098493,
            23095437,
            23098070,
            23097715,
            23102940,
            23099714,
            23102329,
            23100307
        ],
        "E": [
            23090983,
            23091838,
            23090400,
            23090385,
            23091224,
            23095595,
            23092637,
            23090974,
            23092694,
            23093218,
            23092131,
            23090847,
            23094473,
            23098598,
            23094014,
            23142601,
            23096689,
            23092749,
            23095909,
            23093965,
            23096216
        ],
        "C": [
            23089009,
            23086489,
            23093136,
            23087647,
            23090881,
            23086795,
            23086617,
            23094723,
            23086814,
            23087320,
            23089539,
            23108446,
            23092756,
            23088603,
            23090345,
            23087808,
            23091627
        ],
        "D": [
            23086805,
            23088293,
            23086244,
            23094627,
            23088889,
            23093685,
            23088867,
            23088313,
            23096227,
            23088723,
            23089318,
            23104824,
            23090867,
            23090879,
            23091937,
            23088754,
            23089647,
            23091296,
            23088886,
            23089358
        ],
        "B": [
            23084224,
            23084449,
            23084370,
            23084955,
            23085227,
            23087278,
            23084159,
            23084283,
            23090451,
            23083745,
            23084649,
            23085347,
            23084771,
            23089523,
            23085956,
            23085476,
            23085206,
            23084905,
            23085967
        ],
        "A": [
            23082169,
            23082385,
            23081947,
            23082691,
            23082163,
            23085385,
            23081965,
            23082429,
            23082420,
            23082009,
            23082118,
            23082810,
            23086953,
            23088467,
            23082662,
            23082884,
            23082308,
            23082652,
            23082888
        ]
    },
    "name": "D. Green and Black Tea",
    "statement": "Innokentiy likes tea very much and today he wants to drink exactly cups\r\nof tea. He would be happy to drink more but he had exactly tea bags, of\r\nthem are green and are black.Innokentiy doesn’t like to drink the same\r\ntea (green or black) more than times in a row. Your task is to determine\r\nthe order of brewing tea bags so that Innokentiy will be able to drink\r\ncups of tea, without drinking the same tea more than times in a row, or\r\nto inform that it is impossible. Each tea bag has to be used exactly\r\nonce.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)301*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n,k,a,b;\nchar A='G',B='B';\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>k>>a>>b;\n    if(a<b)swap(a,b),swap(A,B);\n    ll num=(a+k-1)/k-1;\n    if(num>b)return cout<<\"NO\",0;\n    b-=num;\n    for(int i=0;i<num;i++)\n    {\n    \tfor(int j=0;j<k;j++)cout<<A;\n    \tcout<<B;\n    \tfor(int j=0;j<k-1 && b;j++,b--)cout<<B;\n\t}\n\tll p=a%k;\n\tif(p==0)p=k;\n\tfor(int j=0;j<p;j++)cout<<A;\n\tfor(int j=0;j<k && b;j++,b--)cout<<B;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Green and Black Tea.json",
    "editorial_link": "https://codeforces.com//blog/entry/49160",
    "editorial": "Letâs use greedy to solve this problem. On the current step we choose\r\ntea, which left more, but if the last cups were equal we need to use the\r\nother tea. If we canât use the other tea there is no answer and we need\r\nto print . So, we need to store the number of last cups, which were\r\nequals and how many of green and black tea left we greedily build the\r\nanswer. If we use all tea with this algorithm we found the answer and it\r\nis guaranteed that it is correct answer.\r\n",
    "hint": []
}