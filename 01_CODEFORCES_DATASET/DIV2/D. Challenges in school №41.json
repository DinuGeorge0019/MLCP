{"link": "https://codeforces.com//contest/1333/problem/D", "problemId": "586756", "problem_idx": "D", "shortId": "1333D", "contest_number": "1333", "problem_submissions": {"E": [75896339, 75896565, 75977605, 75896691, 75897517, 75909706, 75903789, 75909595, 75887158, 75892751, 75911705, 75893605, 75903871, 75907577, 75907287, 75905980, 75911364, 102357635], "F": [75886038, 75883944, 75977662, 75881660, 75879950, 75880078, 75883983, 75889261, 75893323, 75897108, 75891281, 75909072, 75894697, 75898619, 75885706, 75889606, 75886207, 75876954, 75881193], "D": [75864744, 75869369, 75977526, 75869421, 75870061, 75872281, 75875027, 75874985, 75876429, 75882167, 75873219, 75876350, 75881516, 75880068, 75879600, 75883836, 75901469, 75865548, 75870511], "C": [75852521, 75859230, 75977465, 75850790, 75858133, 75853774, 75862591, 75860649, 75860611, 75873215, 75852933, 75864634, 75853173, 75865167, 75868921, 75862158, 75875332, 75854728, 75853080], "B": [75848076, 75848553, 75977412, 75847691, 75848476, 75846675, 75848813, 75851794, 75895723, 75859034, 75846157, 75848508, 75884037, 75854691, 75852331, 75853099, 75848989, 75850255, 75846775], "A": [75845195, 75845040, 75977221, 75844826, 75845093, 75844889, 75845001, 75846626, 75847661, 75851327, 75844724, 75845218, 75845746, 75850998, 75847105, 75848789, 75855160, 75846223, 75844893]}, "name": "D. Challenges in school \u211641", "statement": "There are n children, who study at the school 41. It is well-known that\r\nthey are good mathematicians. Once at a break, they arranged a challenge\r\nfor themselves. All children arranged in a row and turned heads either\r\nto the left or to the right.Children can do the following: in one second\r\nseveral pairs of neighboring children who are can turn the head in the\r\nopposite direction. For instance, the one who was looking at the right\r\nneighbor turns left and vice versa for the second child. Moreover, every\r\nsecond pair of neighboring children performs such action. They are going\r\nto finish when there is no pair of neighboring children who are looking\r\nat each other. You are given the number n, the initial arrangement of\r\nchildren and the number k. You have to find a way for the children to\r\nact if they want to finish the process in exactly k seconds. More\r\nformally, for each of the k moves, you need to output the numbers of the\r\nchildren who turn left during this move.For instance, for the\r\nconfiguration shown below and k = 2 children can do the following steps:\r\nAt the beginning, two pairs make move: (1, 2) and (3, 4). After that, we\r\nreceive the following configuration: At the second move pair (2, 3)\r\nmakes the move. The final configuration is reached. Good job. It is\r\nguaranteed that if the solution exists, it takes not more than n^2\r\n\"headturns\".\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nusing ll = long long;\nint const nmax = 3000;\nchar v[1 + nmax];\n\nvector<int> processlevel(int n){\n  vector<int> sol;\n  for(int i = 1;i < n; i++)\n    if(v[i] == 'R' && v[i + 1] == 'L')\n      sol.push_back(i);\n  for(int i = 0; i < sol.size(); i++)\n    swap(v[sol[i]], v[sol[i] + 1]);\n  return sol;\n}\n\nint main()\n{\n  int n, k;\n  cin >> n >> k;\n  for(int i = 1;i <= n; i++)\n    cin >> v[i];\n  vector<vector<int>> solbig;\n  int movesmax = 0;\n  while(true){\n    vector<int> sol = processlevel(n);\n    if(sol.size() == 0)\n      break;\n    movesmax += sol.size();\n    solbig.push_back(sol);\n  }\n  if(k < solbig.size() || movesmax < k){\n    cout << -1;\n    return 0;\n  }\n  int ptr = 0, movesmin = solbig.size();\n\n  while(movesmin < k){\n    if(solbig[ptr].size() == 0) {\n      ptr++;\n      movesmin--;\n    }\n    cout << 1 << \" \" << solbig[ptr].back() << '\\n';\n    solbig[ptr].pop_back();\n    k--;\n    if(solbig[ptr].size() == 0) {\n      ptr++;\n      movesmin--;\n    }\n  }\n\n  for(int i = ptr; i < solbig.size(); i++){\n    cout << solbig[i].size() << \" \";\n    for(int j = 0; j < solbig[i].size(); j++)\n      cout << solbig[i][j] << \" \";\n    cout << '\\n';\n  }\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "games", "graphs", "greedy", "implementation", "sortings"], "dificulty": "2100", "interactive": false}