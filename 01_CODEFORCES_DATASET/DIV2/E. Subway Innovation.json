{
    "link": "https://codeforces.com//contest/371/problem/E",
    "problemId": "4155",
    "problem_idx": "E",
    "shortId": "371E",
    "contest_number": "371",
    "problem_submissions": {
        "E": [
            5386691,
            5385652,
            5387391,
            5387322,
            5390985,
            5387784,
            5383050,
            5388200,
            5387733,
            5386214,
            5386292,
            5388053,
            5385063,
            5389504,
            5394788,
            5402945
        ],
        "D": [
            5385132,
            5387024,
            5385113,
            5383557,
            5389960,
            5384908,
            5386335,
            5385491,
            5385734,
            5387644,
            5385157,
            5390842,
            5385613,
            5388772,
            5383171,
            5383787,
            5383978,
            5383957
        ],
        "C": [
            5383277,
            5383807,
            5383992,
            5381888,
            5382446,
            5383936,
            5383664,
            5385279,
            5384741,
            5383042,
            5382860,
            5382943,
            5382483,
            5383152,
            5382630,
            5382839
        ],
        "B": [
            5381953,
            5382093,
            5382443,
            5385168,
            5381736,
            5388764,
            5382596,
            5382957,
            5382638,
            5388559,
            5381967,
            5382051,
            5381711,
            5381795,
            5381475,
            5381931
        ],
        "A": [
            5381375,
            5381309,
            5381281,
            5382547,
            5381148,
            5381302,
            5382094,
            5382203,
            5381364,
            5381179,
            5388604,
            5381203,
            5381211,
            5381180,
            5381177,
            5381327
        ]
    },
    "name": "E. Subway Innovation",
    "statement": "Berland is going through tough times the dirt price has dropped and that\r\nis a blow to the country’s economy. Everybody knows that Berland is the\r\ntop world dirt exporter!The President of Berland was forced to leave\r\nonly of the currently existing subway stations.The subway stations are\r\nlocated on a straight line one after another, the trains consecutively\r\nvisit the stations as they move. You can assume that the stations are on\r\nthe axis, the -th station is at point with coordinate . In such case the\r\ndistance between stations and is calculated by a simple formula\r\n.Currently, the Ministry of Transport is choosing which stations to\r\nclose and which ones to leave. Obviously, the residents of the capital\r\nwon’t be too enthusiastic about the innovation, so it was decided to\r\nshow the best side to the people. The Ministry of Transport wants to\r\nchoose such stations that minimize the average commute time in the\r\nsubway!Assuming that the train speed is constant (it is a fixed value),\r\nthe average commute time in the subway is calculated as the sum of\r\npairwise distances between stations, divided by the number of pairs\r\n(that is ) and divided by the speed of the train.Help the Minister of\r\nTransport to solve this difficult problem. Write a program that, given\r\nthe location of the stations selects such stations that the average\r\ncommute time in the subway is minimized.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <string>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>                              \nusing namespace std;\n#define fname \"\"\n#define ull unsigned long long\n#define ll long long\n#define INF 1000*1000*1000\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define sz size()\nconst int N = 400500;\nstruct node {\n\tll x, id;\n}a[N];\nbool cmp (node a, node b) {\n\treturn a.x < b.x;\n}\nll n, k;\n\nll d[N];\n\nvector <int> ans;\n\nint main ()\n{\t\n\t#ifndef ONLINE_JUDGE\n\tfreopen (fname\"in\",\"r\",stdin);\n\tfreopen (fname\"out\",\"w\",stdout);\n\t#endif\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tcin >> a[i].x;\n\t\ta[i].id = i;\n\t}\n\n\tcin >> k;\n\n\tsort(a + 1, a + 1 + n, &cmp);\n\n\tll mn = 0, id = k, sum = 0, now = 0;\n\n\tfor (int i = 1; i <= k; i ++ ) {\n\t\tmn += a[i].x * 1ll * (i - 1) - sum;\n\t\tsum += a[i].x;\n\t}\n\n\tnow = mn;\n\n\tfor (int i = k + 1; i <= n; i ++ ) {\n\t\tsum -= a[i - k].x;\n\t\tnow -= (sum - a[i - k].x * (k - 1));\n\t\tnow += (a[i].x * (k - 1) - sum);\n\t\tsum += a[i].x;\n\t\tif (mn > now) {\n\t\t\tmn = now;\n\t\t\tid = i;\n\t\t}\n\t}\n\n\tfor (int i = id; i >= id - k + 1; i -- ) ans.pb(a[i].id);\n\n\tsort(ans.begin(), ans.end());\n\n\tfor (int i = 0; i < ans.size(); i ++ ) cout << ans[i] << \" \";\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Subway Innovation.json",
    "editorial_link": "https://codeforces.com//blog/entry/9876",
    "editorial": "It is easy to see that you need to minimize the sum of pairwise\r\ndistances between stations. The main idea to do it is to sort them and\r\nthe required stations will form a continuous segment. It is easy to\r\nprove by contradiction. Huge constraints do not allow to use\r\nstraight-forward method to find required segment. Let s call Unable to\r\nparse markup [type=CF_TEX] Unable to parse markup [type=CF_TEX] Unable\r\nto parse markup [type=CF_TEX] Unable to parse markup [type=CF_TEX]\r\nUnable to parse markup [type=CF_TEX] Unable to parse markup\r\n[type=CF_TEX] Unable to parse markup [type=CF_TEX] Unable to parse\r\nmarkup [type=CF_TEX] where means Unable to parse markup [type=CF_TEX]\r\nUnable to parse markup [type=CF_TEX] Unable to parse markup\r\n[type=CF_TEX] Actually we need Unable to parse markup [type=CF_TEX]\r\nUnable to parse markup [type=CF_TEX] To recalculate Unable to parse\r\nmarkup [type=CF_TEX] Unable to parse markup [type=CF_TEX] Unable to\r\nparse markup [type=CF_TEX] Unable to parse markup [type=CF_TEX]\r\n",
    "hint": []
}