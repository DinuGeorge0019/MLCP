{"link": "https://codeforces.com//contest/1794/problem/D", "problemId": "1808458", "problem_idx": "D", "shortId": "1794D", "contest_number": "1794", "problem_submissions": {"E": [196467319, 196091024, 196065447, 196027516, 196045507, 196044539, 196049784, 196043653, 196050334, 196053527, 196054181, 196051837, 196052921, 196053608, 196051434, 196129108, 196055320, 196058590, 196049523, 196042891, 196053778, 196054545, 196037576, 196074501, 196074391], "D": [196083505, 196016109, 196024909, 196024858, 196021434, 196025217, 196028904, 196025001, 196032867, 196029336, 196033933, 196031399, 196038559, 196037652, 196048488, 196050480, 196036074, 196036926, 208633215, 196022650], "C": [196008950, 196011685, 196013987, 196009207, 196010114, 196018308, 196011596, 196011705, 196015187, 196016689, 196011713, 196018563, 196020776, 196010830, 196012003, 196018106, 196018224, 196016136, 196008531], "B": [196004154, 196004594, 196009639, 196005082, 196031084, 196004622, 196004148, 196006017, 196007935, 196006213, 196009047, 196004027, 196017820, 196010698, 196013843, 196006494, 196003310, 196003871], "A": [196003031, 196003363, 196007521, 196004024, 196002777, 196003379, 196002990, 196004171, 196003805, 196004167, 196007050, 196002947, 196003739, 196007194, 196008753, 196020821, 196002700, 196002959]}, "name": "D. Counting Factorizations", "statement": "The prime factorization of a positive integer m is the unique way to\r\nwrite it as\r\ndisplaystyle m=p_1^{e_1}\r\ncdot p_2^{e_2}\r\ncdot\r\nldots\r\ncdot p_k^{e_k}, where p_1, p_2,\r\nldots, p_k are prime numbers, p_1 < p_2 <\r\nldots < p_k and e_1, e_2,\r\nldots, e_k are positive integers. For each positive integer m, f(m) is\r\ndefined as the multiset of all numbers in its prime factorization, that\r\nis f(m)=\r\n{p_1,e_1,p_2,e_2,\r\nldots,p_k,e_k\r\n}. For example, f(24)=\r\n{2,3,3,1\r\n}, f(5)=\r\n{1,5\r\n} and f(1)=\r\n{\r\n}.You are given a list consisting of 2n integers a_1, a_2,\r\nldots, a_{2n}. Count how many positive integers m satisfy that f(m)=\r\n{a_1, a_2,\r\nldots, a_{2n}\r\n}. Since this value may be large, print it modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353; \n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_P = 1e6 + 5;\n\nModint fact [MAX_P];\nModint ifact [MAX_P];\nint sieve [MAX_P];\n\nconst int MAX_N = 2022 * 2 + 5;\n\nModint dp [MAX_N][MAX_N];\n\nint main () {\n  fact[0] = 1;\n  ifact[0] = 1;\n  for (int i = 1; i < MAX_P; i++) {\n    fact[i] = fact[i - 1] * i;\n    ifact[i] = inv(fact[i]);\n  }\n\n  sieve[0] = 1;\n  sieve[1] = 1;\n  for (int i = 2; i < MAX_P; i++) {\n    if (!sieve[i]) {\n      for (int j = 2 * i; j < MAX_P; j += i) {\n        sieve[j] = 1;\n      }\n    }\n  }\n  \n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> arr (2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    cin >> arr[i];\n  }\n\n  sort(arr.begin(), arr.end());\n\n  vector<pair<int, int>> grp;\n  for (int u : arr) {\n    if (grp.empty() || grp.back().first != u) {\n      grp.emplace_back(u, 0);\n    }\n    grp.back().second++;\n  }\n\n  int m = grp.size();\n\n  dp[0][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j <= n; j++) {\n      if (!sieve[grp[i].first]) {\n        dp[i + 1][j + 1] += dp[i][j] * ifact[grp[i].second - 1];\n      }\n      \n      dp[i + 1][j] += dp[i][j] * ifact[grp[i].second];\n    }\n  }\n\n  cout << dp[m][n] * fact[n] << '\\n';\n}"], "input": "", "output": "", "tags": ["combinatorics", "divide and conquer", "dp", "math", "number theory"], "dificulty": "1900", "interactive": false}