{
    "link": "https://codeforces.com//contest/1794/problem/D",
    "problemId": "1808458",
    "problem_idx": "D",
    "shortId": "1794D",
    "contest_number": "1794",
    "problem_submissions": {
        "E": [
            196467319,
            196091024,
            196065447,
            196027516,
            196045507,
            196044539,
            196049784,
            196043653,
            196050334,
            196053527,
            196054181,
            196051837,
            196052921,
            196053608,
            196051434,
            196129108,
            196055320,
            196058590,
            196049523,
            196042891,
            196053778,
            196054545,
            196037576,
            196074501,
            196074391
        ],
        "D": [
            196083505,
            196016109,
            196024909,
            196024858,
            196021434,
            196025217,
            196028904,
            196025001,
            196032867,
            196029336,
            196033933,
            196031399,
            196038559,
            196037652,
            196048488,
            196050480,
            196036074,
            196036926,
            208633215,
            196022650
        ],
        "C": [
            196008950,
            196011685,
            196013987,
            196009207,
            196010114,
            196018308,
            196011596,
            196011705,
            196015187,
            196016689,
            196011713,
            196018563,
            196020776,
            196010830,
            196012003,
            196018106,
            196018224,
            196016136,
            196008531
        ],
        "B": [
            196004154,
            196004594,
            196009639,
            196005082,
            196031084,
            196004622,
            196004148,
            196006017,
            196007935,
            196006213,
            196009047,
            196004027,
            196017820,
            196010698,
            196013843,
            196006494,
            196003310,
            196003871
        ],
        "A": [
            196003031,
            196003363,
            196007521,
            196004024,
            196002777,
            196003379,
            196002990,
            196004171,
            196003805,
            196004167,
            196007050,
            196002947,
            196003739,
            196007194,
            196008753,
            196020821,
            196002700,
            196002959
        ]
    },
    "name": "D. Counting Factorizations",
    "statement": "The prime factorization of a positive integer m is the unique way to\r\nwrite it as\r\ndisplaystyle m=p_1^{e_1}\r\ncdot p_2^{e_2}\r\ncdot\r\nldots\r\ncdot p_k^{e_k}, where p_1, p_2,\r\nldots, p_k are prime numbers, p_1 < p_2 <\r\nldots < p_k and e_1, e_2,\r\nldots, e_k are positive integers. For each positive integer m, f(m) is\r\ndefined as the multiset of all numbers in its prime factorization, that\r\nis f(m)=\r\n{p_1,e_1,p_2,e_2,\r\nldots,p_k,e_k\r\n}. For example, f(24)=\r\n{2,3,3,1\r\n}, f(5)=\r\n{1,5\r\n} and f(1)=\r\n{\r\n}.You are given a list consisting of 2n integers a_1, a_2,\r\nldots, a_{2n}. Count how many positive integers m satisfy that f(m)=\r\n{a_1, a_2,\r\nldots, a_{2n}\r\n}. Since this value may be large, print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353; \n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_P = 1e6 + 5;\n\nModint fact [MAX_P];\nModint ifact [MAX_P];\nint sieve [MAX_P];\n\nconst int MAX_N = 2022 * 2 + 5;\n\nModint dp [MAX_N][MAX_N];\n\nint main () {\n  fact[0] = 1;\n  ifact[0] = 1;\n  for (int i = 1; i < MAX_P; i++) {\n    fact[i] = fact[i - 1] * i;\n    ifact[i] = inv(fact[i]);\n  }\n\n  sieve[0] = 1;\n  sieve[1] = 1;\n  for (int i = 2; i < MAX_P; i++) {\n    if (!sieve[i]) {\n      for (int j = 2 * i; j < MAX_P; j += i) {\n        sieve[j] = 1;\n      }\n    }\n  }\n  \n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> arr (2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    cin >> arr[i];\n  }\n\n  sort(arr.begin(), arr.end());\n\n  vector<pair<int, int>> grp;\n  for (int u : arr) {\n    if (grp.empty() || grp.back().first != u) {\n      grp.emplace_back(u, 0);\n    }\n    grp.back().second++;\n  }\n\n  int m = grp.size();\n\n  dp[0][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j <= n; j++) {\n      if (!sieve[grp[i].first]) {\n        dp[i + 1][j + 1] += dp[i][j] * ifact[grp[i].second - 1];\n      }\n      \n      dp[i + 1][j] += dp[i][j] * ifact[grp[i].second];\n    }\n  }\n\n  cout << dp[m][n] * fact[n] << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Counting Factorizations.json",
    "editorial_link": "https://codeforces.com//blog/entry/113500",
    "editorial": "First, we will count how many times each different element in occurs and\r\ncheck which of these elements are prime numbers. This can be done by\r\nchecking for each element if it has a divisor up to its square root or\r\nusing the Sieve of Eratosthenes.To construct a number such that we have\r\nto choose elements of to be the primes in its factorization and elements\r\nto be the exponents. The numbers we choose to be the primes in the\r\nfactorization have to be prime numbers and distinct. If there are less\r\nthan distinct primes in , then there is no number satisfying the\r\nproperty. So, from now on we will assume there are at least distinct\r\nprime numbers in .Let be the number of occurrences of each non-prime\r\nnumber in and let be the number of occurrences of each prime number in .\r\nAfter we choose the primes for the factorization, let be the remaining\r\nnumber of occurrences of each prime number. As we can choose each prime\r\nnumber at most once, then or . For each way of choosing the primes, the\r\nnumber of possible values for is because this is the number of ways to\r\nchoose where to place the exponents. The answer to the problem is the\r\nsum of all these numbers over all ways of choosing the prime\r\nnumbers.Observe that when we sum terms of the form , the value is a\r\ncommon factor over all these terms. Thus, we just need to find the sum\r\nof the terms and then multiply by the common factor.To find this sum, we\r\nwill use dynamic programming. Let be the sum considering only the primes\r\nfrom the -th of them and assuming that primes need to be chosen (or that\r\nprimes are already chosen). Then . The value of will give the desired\r\nsum.Intended complexity: (plus the complexity of primality checking)\r\n"
}