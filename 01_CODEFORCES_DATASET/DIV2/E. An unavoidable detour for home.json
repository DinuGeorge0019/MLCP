{
    "link": "https://codeforces.com//contest/814/problem/E",
    "problemId": "108817",
    "problem_idx": "E",
    "shortId": "814E",
    "contest_number": "814",
    "problem_submissions": {
        "D": [
            27647493,
            27672108,
            27640106,
            27643923,
            27641961,
            27641720,
            27642103,
            27641350,
            27644262,
            27643542,
            27643790,
            27645753,
            27644413,
            27642630,
            27644185,
            27644064,
            27644363,
            27643194,
            27644293,
            27646026
        ],
        "C": [
            27645217,
            27635551,
            27636661,
            27634217,
            27636436,
            27636571,
            27637453,
            27638720,
            27637173,
            27637214,
            27639563,
            27637118,
            27638741,
            27639783,
            27640321,
            27639165,
            27639941,
            27659642,
            27639358,
            27640727,
            27637633
        ],
        "A": [
            27642326,
            27632216,
            27632277,
            27632196,
            27632419,
            27632275,
            27632342,
            27633234,
            27632333,
            27632408,
            27632471,
            27632235,
            27632967,
            27632675,
            27632317,
            27633643,
            27632625,
            27632707,
            27632622,
            27632717
        ],
        "E": [
            27641600,
            27647168,
            27666856,
            27661378,
            27652552,
            27730170,
            27729667,
            27669973,
            27692659
        ],
        "B": [
            27634262,
            27635046,
            27632554,
            27634627,
            27634088,
            27635201,
            27635429,
            27634469,
            27634865,
            27635554,
            27634700,
            27635414,
            27636492,
            27635586,
            27636132,
            27636741,
            27636455,
            27636685,
            27634894
        ]
    },
    "name": "E. An unavoidable detour for home",
    "statement": "Those unwilling to return home from a long journey, will be affected by\r\nthe oddity of the snail and lose their way. Mayoi, the oddity\u2019s carrier,\r\nwouldn\u2019t like this to happen, but there\u2019s nothing to do with this before\r\na cure is figured out. For now, she would only like to know the enormous\r\nnumber of possibilities to be faced with if someone gets lost.There are\r\ntowns in the region, numbered from to . The town numbered is called the\r\ncapital. The traffic network is formed by bidirectional roads connecting\r\npairs of towns. No two roads connect the same pair of towns, and no road\r\nconnects a town with itself. The time needed to travel through each of\r\nthe roads is the same. Lost travelers will not be able to find out how\r\nthe towns are connected, but the residents can help them by providing\r\nthe following facts: Starting from each town other than the capital, the\r\nshortest path (i.e. the path passing through the minimum number of\r\nroads) to the capital exists, and is unique; Let be the number of roads\r\non the shortest path from town to the capital, then holds for all ; For\r\ntown , the number of roads connected to it is denoted by , which equals\r\neither or . You are to count the number of different ways in which the\r\ntowns are connected, and give the answer modulo . Two ways of connecting\r\ntowns are considered different if a pair () exists such there is a road\r\nbetween towns and in one of them but not in the other.\r\n",
    "solutions": [
        "/*\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nll md(ll x){\n    return x % mod;\n}\n\nint n;\n\nint d[maxn];\n\nll sq[55][55][55][55];\n\nll q[55][55];\n\nll bpow(ll x, ll y){\n    if (y == 0)\n        return 1;\n    if (y == 1)\n        return x;\n    ll ret = bpow(x, y >> 1);\n    ret = md(ret * ret);\n    if (y & 1)\n        ret = md(ret * x);\n    return ret;\n}\n\nll bdiv(ll x, ll y){\n    return md(x * bpow(y, mod - 2));\n}\n\nll fact[55];\n\nvoid prefact(){\n    fact[0] = 1;\n    for (ll i = 1; i <= n; i++)\n        fact[i] = md(fact[i - 1] * i);\n}\n\nvoid presq(){\n    for (int l = 1; l < n; l++){\n        if (d[l] == 3)\n            sq[l][l][2][1] = 1;\n        else\n            sq[l][l][1][0] = 1;\n        for (int r = l; r < n - 1; r++)\n            for (int k = 0; k <= (r - l + 1) * 2; k++)\n                for (int db = 0; db <= r - l + 1; db++)\n                if (sq[l][r][k][db] != 0){\n                    ll val = sq[l][r][k][db];\n                    if (d[r + 1] == 2){\n                        sq[l][r + 1][k + 1][db] = md(sq[l][r + 1][k + 1][db] + val);\n                        if (db > 0)\n                            sq[l][r + 1][k - 1][db - 1] = md(sq[l][r + 1][k - 1][db - 1] + val * db);\n                        if (k - 2 * db > 0)\n                            sq[l][r + 1][k - 1][db] = md(sq[l][r + 1][k - 1][db] + val * (k - 2 * db));\n                    }\n                    else{\n                        sq[l][r + 1][k + 2][db + 1] = md(sq[l][r + 1][k + 2][db + 1] + val);\n                        if (db > 0)\n                            sq[l][r + 1][k][db - 1] = md(sq[l][r + 1][k][db - 1] + val * db);\n                        if (k - 2 * db > 0)\n                            sq[l][r + 1][k][db] = md(sq[l][r + 1][k][db] + val * (k - 2 * db));\n                        if (k - 2 * db > 1)\n                            sq[l][r + 1][k - 2][db] = md(sq[l][r + 1][k - 2][db] + val * (k - 2 * db) * (k - 2 * db - 1) / 2);\n                        if (k - 2 * db > 0 && db > 0)\n                            sq[l][r + 1][k - 2][db - 1] = md(sq[l][r + 1][k - 2][db - 1] + val * (k - 2 * db) * db);\n                        if (db > 1)\n                            sq[l][r + 1][k - 2][db - 2] = md(sq[l][r + 1][k - 2][db - 2] + val * db * (db - 1) / 2);\n                    }\n                }\n    }\n}\n\nvoid preq(){\n    if (d[0] == 2)\n        q[1][2] = 1;\n    else\n        q[1][3] = 1;\n    for (int r = 2; r < n; r++)\n        for (int l = 1; l <= r; l++)\n        if (q[l][r] > 0)\n            for (int k = 0; k <= (r - l + 1) * 2; k++)\n                for (int db = 0; db <= r - l + 1; db++)\n                    if (r + k < n)\n                        q[r + 1][r + k] = md(q[r + 1][r + k] + bdiv(md(md(q[l][r] * sq[l][r][k][db]) * fact[k]), bpow(2, db)));\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(\"a.in\");\n    ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> d[i];\n    if (d[0] == 3 && n == 3){\n        cout << 0;\n        return 0;\n    }\n    prefact();\n    presq();\n    preq();\n    ll answer = 0;\n    for (int l = 1; l < n; l++)\n        answer = md(answer + q[l][n - 1] * sq[l][n - 1][0][0]);\n    cout << answer;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. An unavoidable detour for home.json",
    "editorial_link": "https://codeforces.com//blog/entry/52449",
    "editorial": "Let\u00e2\u0080\u0099s make it intuitive: the graph looks like this. Formally, if we find\r\nout the BFS levels of the graph, it will look like a tree with extra\r\nedges among vertices of the same level, and indices of vertices in the\r\nsame level form a consecutive interval. Therefore we can add vertices\r\nfrom number to number to the graph, without missing or violating\r\nanything.Consider the case when we want to add vertex to a graph formed\r\nby the first vertices. The state only depend on the current and the\r\nprevious level (We can\u00e2\u0080\u0099t start level without finishing level , thus\r\nthere are only two unfinished levels). The whole thing is described by\r\nfour parameters: the number of \"1-plug\" (having one outgoing edge that\r\nis not determined) and \"2-plug\" (similar definition) vertices in the\r\nprevious and the current level. Let be the number of ways to build the\r\ngraph with the first vertices, with \"1-plug\" vertices and \"2-plug\"\r\nvertices in the previous level, and and in the current one\r\nrespectively.For vertex , we must choose one vertex in the previous\r\nlayer and connect to it. For the remaining degree(s) of , we can choose\r\neither to connect them to vertices in the same layer, or simply leave\r\nthem for future. Also, we may start a new level if . This gives us an\r\nrecursion.There are states, giving us a time complexity of and a space\r\ncomplexity of if the first dimension is reused. The constant factor can\r\nbe rather small (since ). See solution 1 for detailed recursion.Let\u00e2\u0080\u0099s\r\ntry to improve this a bit. Instead of adding one vertex at a time, we\r\nconsider the layer as a whole. Let be the number of ways to build a\r\nsingle level with vertices (their \"plugs\" don\u00e2\u0080\u0099t matter), and connect it\r\nto the previous layer which has \"1-plug\" vertices and \"2-plug\" ones.\r\nRecursion over can be done in . Then let be the number of ways to build\r\nthe graph with vertices from to , while vertices from to form the first\r\nlevel note that this level should be connected to another previous one.\r\nThe recursion over can be done in . The final answer should be since the\r\ncapital must be directly connected to vertices from to . The overall\r\ntime complexity is . Huge thanks to Nikolay Kalinin (KAN) for this!\r\nFigure out the solution :P\r\n"
}