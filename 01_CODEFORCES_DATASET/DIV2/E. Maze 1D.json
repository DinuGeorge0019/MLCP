{
    "link": "https://codeforces.com//contest/404/problem/E",
    "problemId": "7292",
    "problem_idx": "E",
    "shortId": "404E",
    "contest_number": "404",
    "problem_submissions": {
        "B": [
            6081380,
            6071583,
            6070927,
            6071339,
            6070454,
            6070614,
            6072572,
            6071620,
            6071224,
            6072980,
            6072201,
            6072080,
            6071625,
            6070557,
            6072898,
            6071106,
            6072617,
            6072939
        ],
        "A": [
            6081009,
            6068298,
            6068430,
            6069127,
            6068593,
            6068443,
            6069041,
            6068506,
            6069739,
            6068994,
            6068641,
            6068845,
            6068699,
            6071140,
            6069542,
            6069802,
            6068288
        ],
        "E": [
            6077708,
            6078243,
            6080273,
            6089004,
            6098326,
            6095224,
            6104347
        ],
        "D": [
            6074157,
            6076415,
            6075648,
            6078211,
            6077330,
            6077784,
            6078940,
            6079076,
            6079336,
            6078890,
            6080135,
            6077817,
            6078043,
            6080355,
            6079190,
            6077371
        ],
        "C": [
            6072624,
            6074366,
            6073677,
            6073792,
            6072756,
            6073958,
            6074499,
            6073931,
            6073038,
            6075180,
            6075460,
            6076470,
            6074776,
            6073618,
            6075857,
            6074780,
            6076291,
            6078785
        ]
    },
    "name": "E. Maze 1D",
    "statement": "Valera has a strip infinite in both directions and consisting of cells.\r\nThe cells are numbered by integers. The cell number has a robot.The\r\nrobot has instructions the sequence of moves that he must perform. In\r\none move, the robot moves one cell to the left or one cell to the right,\r\naccording to instructions. Before the robot starts moving, Valera puts\r\nobstacles in some cells of the strip, excluding cell number . If the\r\nrobot should go into the cell with an obstacle according the\r\ninstructions, it will skip this move.Also Valera indicates the finish\r\ncell in which the robot has to be after completing the entire\r\ninstructions. The finishing cell should be different from the starting\r\none. It is believed that the robot , if during the process of moving he\r\nvisited the finish cell exactly once at its last move. Moreover, the\r\nlatter move cannot be skipped.Let\u2019s assume that is the minimum number of\r\nobstacles that Valera must put to make the robot able to complete the\r\nentire sequence of instructions successfully and end up in some\r\nfinishing cell. You need to calculate in how many ways Valera can choose\r\nobstacles and the finishing cell so that the robot is able to complete\r\nthe instructions successfully.\r\n",
    "solutions": [
        "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define lx x + x\n#define rx lx + 1\n#define ly y + y\n#define ry ly + 1\ntypedef long long LL;\n\nconst int N = 1000005;\nconst int M = 1005;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\ntypedef double DB;\n\nchar s[N];\nint n;\nbool check(int l){\n    int now = 0, mn = 0;\n    for (int i = 1; i <= n; i++)\n    if (s[i] == 'R'){\n        if (now + 1 < l) now += 1;\n    }else{\n        now--;\n        if (i != n) mn = min(mn, now);\n    }\n    return now < mn;\n}\nint Solve(){\n    int l = 1, r = n, ans = 0;\n    while (l <= r){\n        int mid = l + r >> 1;\n        if (check(mid)){\n            ans = mid;\n            l = mid + 1;\n        }else r = mid - 1;\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    int mx = 0, mn = 0, now = 0;\n    for (int i = 1; i <= n; i++)\n    if (s[i] == 'R'){\n        now++;\n        if (i != n) mx = max(mx, now);\n    }else{\n        now--;\n        if (i != n) mn = min(mn, now);\n    }\n    if (now > mx || now < mn){\n        puts(\"1\");\n        return 0;\n\n    }\n\n    int ans = Solve();\n    for (int i = 1; i <= n; i++)\n    if (s[i] == 'L') s[i] = 'R'; else s[i] = 'L';\n    ans += Solve();\n    cout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Maze 1D.json",
    "editorial_link": "https://codeforces.com/blog/entry/11095",
    "editorial": "Let\u00e2\u0080\u0099s consider the case when the last move of the robot is equal to \"R\".\r\nIf the last move is equal to \"L\" then we can replace all \"L\" by \"R\" and\r\nvise versa and the answer doesn\u00e2\u0080\u0099t change. Let\u00e2\u0080\u0099s show that Valera doesn\u00e2\u0080\u0099t\r\nneed more than one obstacle. Suppose Valera placed obstacles somewhere.\r\nWe will say that the number of obstacle is the number of cell containing\r\nit. Let\u00e2\u0080\u0099s consider the rightmost obstacle among the obstacles with\r\nnegative numbers and the leftmost obstacle among the obstacles with\r\npositive numbers. Obvious robot cannot go to the left of and to the\r\nright of . So the needed number of obstacles is not greater than two.\r\nLet\u00e2\u0080\u0099s show that Valera doesn\u00e2\u0080\u0099t need to place obstacles to the cells with\r\nnumbers greater than zero. Suppose he place obstacle to the cell with\r\nnumber . If robot doesn\u00e2\u0080\u0099t try to go to this cell then its obstacle is\r\nout of place. If robot try to go to this cell then it will visit finish\r\ncell more than once. It is because robot needs to go to the right on its\r\nlast move, but it can\u00e2\u0080\u0099t do it from cell and it has already visited all\r\ncells to the left of . So Valera doesn\u00e2\u0080\u0099t need more than one obstacle and\r\nits obstacle must have number less than zero. Let\u00e2\u0080\u0099s now check if Valera\r\ncan do without obstacles. If so the robot won\u00e2\u0080\u0099t skip moves and will stop\r\nin some cell. Than Valera can choose this cell as finish and the answer\r\nwill be one. We have to consider only one case when Valera must place\r\none obstacle. Firstly let\u00e2\u0080\u0099s notice that if Valera place obstacle to some\r\ncell, the finish cell can be restored uniquely. It means that the number\r\nof ways to choose where to place obstacles and finish cell is equal to\r\nthe number of ways to choose one cell to place one obstacle. Suppose\r\nValera placed obstacle in the cell with number and robot completed its\r\ninstructions successfully. Notice, that in that case robot skipped some\r\nmoves of type \"L\", completed all moves of type \"R\" and went to the right\r\non its last move to the unvisited cell. If we shift Valera\u00e2\u0080\u0099s obstacle to\r\nthe right on one cell then robot is going to skip not less moves of type\r\n\"L\" than in the previous case. It means that the finish cell can either\r\ngo to the right or remains the same. But last time robot visited this\r\ncell on its last move, so it is going to visit a new finish cell on its\r\nlast move either. This means that there is such cell that if Valera\r\nplace obstacle to the cells then robot will be able to complete its\r\ninstructions successfully, but if Valera place obstacle to the cells\r\nthen robot will not. This cell can be found by using binary search and\r\nsimple simulation on each iteration. Time complexity is .\r\n"
}