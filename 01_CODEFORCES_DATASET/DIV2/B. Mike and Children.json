{
    "link": "https://codeforces.com//contest/1121/problem/B",
    "problemId": "306948",
    "problem_idx": "B",
    "shortId": "1121B",
    "contest_number": "1121",
    "problem_submissions": {
        "D": [
            50758250,
            50758015,
            50749128,
            50747632,
            50785617,
            50754149,
            50754700,
            50755682
        ],
        "E": [
            50757916,
            50764324
        ],
        "F": [
            50745381,
            50750604,
            50753091,
            50749617,
            50753700,
            50750259,
            50754814,
            50754495,
            50760298,
            50761256,
            50756002,
            50755635,
            50755816,
            50755833,
            50755580,
            50757571,
            50755934
        ],
        "C": [
            50743029,
            50746539,
            50749003,
            50753301,
            50747698,
            50753219,
            50747567,
            50743419,
            50747905,
            50747562,
            50753852,
            50753022,
            50751877,
            50749086,
            50748818,
            50753336,
            50747068
        ],
        "B": [
            50741461,
            50741819,
            50743532,
            50743792,
            50743537,
            50751011,
            50741449,
            50742306,
            50748477,
            50742402,
            50750467,
            50743138,
            50747985,
            50747123,
            50743911,
            50743533,
            50747184,
            50742809
        ],
        "A": [
            50741269,
            50741274,
            50741426,
            50741433,
            50742538,
            50742625,
            50742751,
            50741659,
            50741596,
            50741572,
            50751688,
            50741748,
            50743041,
            50748198,
            50742474,
            50741733,
            50743780,
            50741312
        ]
    },
    "name": "B. Mike and Children",
    "statement": "Mike decided to teach programming to children in an elementary school.\r\nHe knows that it is not an easy task to interest children in that age to\r\ncode. That is why he decided to give each child sweets.Mike has n sweets\r\nwith sizes a_1, a_2,\r\nldots, a_n. All his sweets have sizes. That is, there is no such pair\r\n(i, j) (1\r\nleq i, j\r\nleq n) such that i\r\nne j and a_i = a_j.Since Mike has taught for many years, he knows that\r\nif he gives two sweets with sizes a_i and a_j to one child and a_k and\r\na_p to another, where (a_i + a_j)\r\nneq (a_k + a_p), then a child who has a smaller sum of sizes will be\r\nupset. That is, if there are two children who have different sums of\r\nsweets, then one of them will be upset. Apparently, Mike does not want\r\nsomebody to be upset. Mike wants to invite children giving each of them\r\nsweets. Obviously, he canâ€™t give one sweet to two or more children. His\r\ngoal is to invite as many children as he can. Since Mike is busy\r\npreparing to his first lecture in the elementary school, he is asking\r\nyou to find the maximum number of children he can invite giving each of\r\nthem two sweets in such way that nobody will be upset.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>                                                                                                                                                                                                                                                                                            \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace std;\n\nint n;\nint a[1000001];\n\nint used[1000001];\n\nint main(){\n    #ifdef DIAS\n        freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n    #elif NAME \n    \tfreopen(fn\".in\", \"r\", stdin);\n    \tfreopen(fn\".out\", \"w\", stdout);\n    #endif\n\tcin >> n;\n    for(int i = 1; i <= n; i++){\n    \tcin >> a[i];\n    }\n    int mx = 0;\n    for(int i = 1; i <= n; i++){\n    \tfor(int j = 1; j < i; j++){\n    \t\tused[a[i] + a[j]] ++;\n    \t\tmx = max(mx, used[a[i] + a[j]]);\n    \t}\n    }\n    cout << mx;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Mike and Children.json",
    "editorial_link": "https://codeforces.com//blog/entry/65679",
    "editorial": "Notice that the sum of sweets each child gets cannot exceed , so for\r\neach of numbers no more than this threshold we can store the number of\r\nways to obtain it as the sum of two sweets. It can be done just by\r\nconsidering all possible (unordered) pairs of sweets and printing the\r\nmaximal obtained number (of ways to represent something as sum of two\r\nsweets). Indeed, if can be represented as a sum of two sweets in several\r\nways then no two of them share a sweet since if = then and therefore .\r\n",
    "hint": []
}