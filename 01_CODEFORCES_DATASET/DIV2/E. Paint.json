{
    "link": "https://codeforces.com//contest/1573/problem/E",
    "problemId": "1113073",
    "problem_idx": "E",
    "shortId": "1573E",
    "contest_number": "1573",
    "problem_submissions": {
        "D": [
            129211729,
            129206759,
            129197164,
            129194726,
            129186807,
            129296553,
            129201143,
            129198553,
            129200951,
            129204017,
            129203484,
            129203960,
            129200720,
            129203477,
            129203437,
            129205853
        ],
        "E": [
            129195381,
            129194363,
            129199429,
            129179637,
            129197397,
            129196652
        ],
        "C": [
            129184190,
            129188576,
            129188704,
            129201501,
            129185674,
            129198766,
            129196140,
            129200201,
            129228180,
            129201620,
            129186651,
            129189132,
            129188899,
            129187320,
            129192678,
            129192241,
            129184572,
            129199512,
            129191618,
            129190718
        ],
        "B": [
            129172862,
            129196906,
            129176190,
            129203844,
            129172298,
            129171523,
            129174991,
            129187627,
            129183320,
            129178269,
            129185994,
            129182784,
            129179822,
            129174918,
            129183834,
            129199069,
            129172947,
            129197456,
            129180823
        ],
        "A": [
            129167486,
            129167526,
            129168431,
            129168344,
            129167107,
            129167895,
            129167756,
            129167152,
            129174946,
            129168601,
            129168318,
            129169357,
            129170825,
            129173901,
            129168162,
            129170465,
            129167770,
            129167307,
            129177822,
            129167367
        ],
        "F": [
            132459885
        ]
    },
    "name": "E. Paint",
    "statement": "You are given a 1 by n pixel image. The i-th pixel of the image has\r\ncolor a_i. For each color, the number of pixels of that color is 20.You\r\ncan perform the following operation, which works like the bucket tool in\r\npaint programs, on this image: pick a color an integer from 1 to n;\r\nchoose a pixel in the image; for all pixels connected to the selected\r\npixel, change their colors to the selected color (two pixels of the same\r\ncolor are considered connected if all the pixels between them have the\r\nsame color as those two pixels). Compute the minimum number of\r\noperations needed to make all the pixels in the image have the same\r\ncolor.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nvoid debug_out(){\n    cerr << endl;\n}\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T){\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n#ifdef local\n#define debug(...) cerr<<\"[\"<<#__VA_ARGS__<<\"]:\",debug_out(__VA_ARGS__)\n#else\n#define debug(...) 55\n#endif\nconst int N = 5005;\nint a[N], dp[N][N], nxt[N], pos[N];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n + 1; i++) pos[i] = n + 1;\n\t\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\t\tfor(int i = n; i >= 1; i--){\n\t\t\tnxt[i] = pos[a[i]];\n\t\t\tpos[a[i]] = i;\n\t\t}\n\t\tfor(int i = 1; i <= n; i++) dp[i][i] = 0;\n\t\tfor(int i = n; i >= 1; i--){\n\t\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\t\tdp[i][j] = 1e9;\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);\n\t\t\t\tfor(int p = nxt[i]; p <= j; p = nxt[p]){\n\t\t\t\t//\tdebug(i, j, p, dp[i][p - 1], dp[p][j]);\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][p - 1] + dp[p][j]);\n\t\t\t\t}\n\t\t\t\t//debug(i, j, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << dp[1][n] << '\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Paint.json",
    "editorial_link": "https://codeforces.com//blog/entry/95086",
    "editorial": "Firstly, we can notice that when we modify a segment of the form [a,b,a]\n and change it to [a,a,a]\n by performing the operation on the second element, as opposed to performing the operation first on the third element and then on the second element (like so [a,b,a]?[a,b,b]?[a,a,a]\n) we avoid using one unnecessary operation. In our solution we will try to maximize the number of operations that we didn't have to perform.\n\nLet dp[i][j]\n be the maximum number of operations that we can avoid on the interval from i\n to j\n, while making all of its elements have the same color. Then the answer to the problem will be n?1?dp[1][n]\n. For i?j\n we have dp[i][j]=0\n and for i<j\n dp[i][j]\n will be the maximum of dp[i+1][j]\n and max(1+dp[i+1][k?1]+dp[k][j])\n over i<k?j\n such that a[i]=a[k]\n. It's because we can either not save any operations on the i\n-th element and just take the answer from the interval [i+1,j]\n or we can save one operation while coloring the segment from i\n to k\n and take the answer from segments [i+1,k?1]\n and [k,j]\n. Because each color occurs in a\n at most 20\n times, we can calculate this dp\n in O(20n2)\n which is also our final time complexity.",
    "hint": []
}