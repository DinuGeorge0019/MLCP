{
    "link": "https://codeforces.com//contest/1763/problem/C",
    "problemId": "1701406",
    "problem_idx": "C",
    "shortId": "1763C",
    "contest_number": "1763",
    "problem_submissions": {
        "C": [
            186020491,
            186014618,
            185970901,
            185991875,
            185997685,
            185982190,
            185984673,
            185981496,
            186009097,
            185973602,
            185981183,
            185984898,
            185981738,
            185976906,
            185977465
        ],
        "E": [
            185998794,
            185987416,
            185979003,
            185992302,
            186002492,
            185989056,
            185993894,
            186011236,
            186008232,
            186008161,
            185976627,
            185996244,
            185993843,
            185994524,
            185987330,
            185983728,
            186014244,
            186001030
        ],
        "D": [
            185995867,
            185980597,
            185999397,
            185984870,
            186005387,
            185985568,
            186006095,
            185982650,
            186022836,
            186016207,
            186014411,
            186000359,
            186003392,
            186001911,
            185991399,
            185982901,
            185988475,
            185988930,
            185993150,
            185994062
        ],
        "F": [
            185990818,
            186680252,
            186011772,
            186580963
        ],
        "B": [
            185964960,
            185964863,
            185976136,
            185966519,
            185970293,
            185964032,
            185970337,
            185968669,
            185966545,
            185964632,
            185967215,
            185968457,
            185964010,
            185967589,
            185966627,
            185963830,
            185965988,
            185967114,
            185965147
        ],
        "A": [
            185961159,
            185960941,
            185963086,
            185960882,
            185963700,
            185960926,
            185963152,
            185960960,
            185961563,
            185960964,
            185961279,
            185962189,
            185960916,
            185963432,
            185961791,
            185961037,
            185961928,
            185961021,
            185961325
        ]
    },
    "name": "C. Another Array Problem",
    "statement": "You are given an array a of n integers. You are allowed to perform the\r\nfollowing operation on it as many times as you want (0 or more times):\r\nChoose 2 indices i,j where 1\r\nle i < j\r\nle n and replace a_k for all i\r\nleq k\r\nleq j with |a_i - a_j| Print the maximum sum of all the elements of the\r\nfinal array that you can obtain in such a way.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n  int a=0;int f=0;char p=getchar();\n  while(!isdigit(p)){f|=p=='-';p=getchar();}\n  while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n  return f?-a:a;\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n,m;\nint val[N];\nvoid solve()\n{\n  n=read(); int pa=0; int pb=0; ll ans=0; ll sx=0;  ll sy=0;\n  for(int i=1;i<=n;++i) val[i]=read();\n  for(int i=1;i<=n;++i) if(!pa||val[i]<val[pa]) pa=i;\n  for(int i=1;i<=n;++i) if(!pa||val[i]>val[pb]) pb=i;\n  for(int i=1;i<=n;++i) ans+=val[i];\n  if(n==1)\n  {\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n  if(n==2)\n  {\n    ans=max(ans,(ll)abs(val[1]-val[2])*2);\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n  if(n==3)\n  {\n    if(val[1]>val[3]) swap(val[1],val[3]);\n    ans=max(ans,(ll)val[3]*3);\n    ans=max(ans,(ll)abs(val[2]-val[1])*3);\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n  if(n>=4)\n  {\n    ans=(ll)val[pb]*n;\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n}\nint main()\n{\n  T=read();\n  while(T--)  solve();\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Another Array Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/110278",
    "editorial": "SolutionLet s first consider the case for . The key observation to make\r\nhere is that we can make all the elements of a subarray zero by applying\r\nthe operation on range twice. Then let s assume the maximum element of\r\nthe array is at an index . We can apply the operation on the range and\r\nturn all its elements into .Using the above information we can see that\r\nto achieve the final array with maximum sum we need to make all the\r\nelements in it equal to the maximum element in the array. Regardless of\r\nthe given array this can be achieved by making the last two elements\r\n(n-1,n) zero. Then applying the operation on subarray to make all its\r\nelements equal to . Then making the first two elements (1,2) zero and\r\napplying the operation on the whole array making all the elements equal\r\nto . Thus the maximum sum for the final array will always be . (In case\r\nor , we can operate on the left side first to reach the same\r\nsolution).For the maximum final sum would be .For , when the maximum\r\nelement is present at index or we can make all the elements of the array\r\ninto . When the maximum element is at index , we have the following\r\noptions.Case 1: We can apply the operation on (1,2), then we can convert\r\nall the elements of the array into .Case 2: We can apply the operation\r\non (2,3), then we can convert all the elements of the array into .Case\r\n3: We can apply the operation on (1,3) making all the elements in the\r\narray . This is redundant since either case 1 or case 2 will give a\r\nlarger sum as .Now considering case 1, if the maximum sum possible would\r\nbe the current sum of the array (see sample 1 and 3). Therefore no\r\noperations are required. Similar case for case 2.So the maximum possible\r\nsum for will be .To avoid doing this casework for , we can see that\r\nthere are only 3 possible operations -> (1,2) , (2,3), (1,3). We will be\r\nrequired to perform operations (1,2) and (2,3) at most two times. So we\r\ncan brute force all possible combinations of operations\r\n[(1,2),(1,2),(2,3),(2,3),(1,3)] to find the maximum sum.\r\n",
    "hint": [
        "Hint 1 What happens when we apply the same operation twice?",
        "Hint 2 What about n = 3 ?"
    ]
}