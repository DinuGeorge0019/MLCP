{"link": "https://codeforces.com//contest/1763/problem/C", "problemId": "1701406", "problem_idx": "C", "shortId": "1763C", "contest_number": "1763", "problem_submissions": {"C": [186020491, 186014618, 185970901, 185991875, 185997685, 185982190, 185984673, 185981496, 186009097, 185973602, 185981183, 185984898, 185981738, 185976906, 185977465], "E": [185998794, 185987416, 185979003, 185992302, 186002492, 185989056, 185993894, 186011236, 186008232, 186008161, 185976627, 185996244, 185993843, 185994524, 185987330, 185983728, 186014244, 186001030], "D": [185995867, 185980597, 185999397, 185984870, 186005387, 185985568, 186006095, 185982650, 186022836, 186016207, 186014411, 186000359, 186003392, 186001911, 185991399, 185982901, 185988475, 185988930, 185993150, 185994062], "F": [185990818, 186680252, 186011772, 186580963], "B": [185964960, 185964863, 185976136, 185966519, 185970293, 185964032, 185970337, 185968669, 185966545, 185964632, 185967215, 185968457, 185964010, 185967589, 185966627, 185963830, 185965988, 185967114, 185965147], "A": [185961159, 185960941, 185963086, 185960882, 185963700, 185960926, 185963152, 185960960, 185961563, 185960964, 185961279, 185962189, 185960916, 185963432, 185961791, 185961037, 185961928, 185961021, 185961325]}, "name": "C. Another Array Problem", "statement": "You are given an array a of n integers. You are allowed to perform the\r\nfollowing operation on it as many times as you want (0 or more times):\r\nChoose 2 indices i,j where 1\r\nle i < j\r\nle n and replace a_k for all i\r\nleq k\r\nleq j with |a_i - a_j| Print the maximum sum of all the elements of the\r\nfinal array that you can obtain in such a way.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n  int a=0;int f=0;char p=getchar();\n  while(!isdigit(p)){f|=p=='-';p=getchar();}\n  while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n  return f?-a:a;\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n,m;\nint val[N];\nvoid solve()\n{\n  n=read(); int pa=0; int pb=0; ll ans=0; ll sx=0;  ll sy=0;\n  for(int i=1;i<=n;++i) val[i]=read();\n  for(int i=1;i<=n;++i) if(!pa||val[i]<val[pa]) pa=i;\n  for(int i=1;i<=n;++i) if(!pa||val[i]>val[pb]) pb=i;\n  for(int i=1;i<=n;++i) ans+=val[i];\n  if(n==1)\n  {\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n  if(n==2)\n  {\n    ans=max(ans,(ll)abs(val[1]-val[2])*2);\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n  if(n==3)\n  {\n    if(val[1]>val[3]) swap(val[1],val[3]);\n    ans=max(ans,(ll)val[3]*3);\n    ans=max(ans,(ll)abs(val[2]-val[1])*3);\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n  if(n>=4)\n  {\n    ans=(ll)val[pb]*n;\n    printf(\"%lld\\n\",ans);\n    return ;\n  }\n}\nint main()\n{\n  T=read();\n  while(T--)  solve();\n  return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "greedy"], "dificulty": "2000", "interactive": false}