{
    "link": "https://codeforces.com//contest/1372/problem/B",
    "problemId": "665583",
    "problem_idx": "B",
    "shortId": "1372B",
    "contest_number": "1372",
    "problem_submissions": {
        "F": [
            86587331,
            86592445
        ],
        "D": [
            86567204,
            86579473,
            86577327,
            86535735,
            86539756,
            86541547,
            86541810,
            86544261,
            86545902,
            86544858,
            86551552,
            86549456,
            86551379,
            86554398,
            86555103,
            86559228,
            86553301
        ],
        "C": [
            86542450,
            86550447,
            86544146,
            86549498,
            86526578,
            86530081,
            86532018,
            86527267,
            86533550,
            86528779,
            86532078,
            86534770,
            86530142,
            86536030,
            86548674,
            86533586,
            86533762,
            86528487,
            86532205
        ],
        "B": [
            86530649,
            86544843,
            86528066,
            86586370,
            86518220,
            86520050,
            86527028,
            86521440,
            86521451,
            86520560,
            86523901,
            86522899,
            86522046,
            86527358,
            86530942,
            86526972,
            86524542,
            86517410,
            86521410
        ],
        "A": [
            86513990,
            86538518,
            86515960,
            86516941,
            86513491,
            86515289,
            86513521,
            86514849,
            86514076,
            86513724,
            86514041,
            86514826,
            86513853,
            86514635,
            86523362,
            86514036,
            86514079,
            86513422,
            86513617
        ],
        "E": [
            86584231,
            86531273,
            86583888,
            86618428,
            86570603
        ]
    },
    "name": "B. Omkar and Last Class of Math",
    "statement": "In Omkar’s last class of math, he learned about the least common\r\nmultiple, or LCM. LCM(a, b) is the smallest positive integer x which is\r\ndivisible by both a and b.Omkar, having a laudably curious mind,\r\nimmediately thought of a problem involving the LCM operation: given an\r\ninteger n, find positive integers a and b such that a + b = n and LCM(a,\r\nb) is the minimum value possible.Can you help Omkar solve his\r\nludicrously challenging math problem?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef pair<int ,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double rl;\n\ntypedef pii int2;\ntypedef tuple<int, int, int>           int3;\ntypedef tuple<int, int, int, int>      int4;\ntypedef tuple<int, int, int, int, int> int5;\n\ntypedef pll ll2;\ntypedef tuple<ll, ll, ll>         ll3;\ntypedef tuple<ll, ll, ll, ll>     ll4;\ntypedef tuple<ll, ll, ll, ll, ll> ll5;\n\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vll_ll;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\ntypedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n\n#define FOR(i,N) for(int i=0; i<N; i++)\n\n#define popc __builtin_popcountll\n// #define popc __builtin_popcount\n\ntemplate<typename A>\nstring to_string(A* ptr)\n{\n    stringstream ss; ss << \"0x\" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr;\n    return ss.str();\n}\n\nstring to_string(char c)\n{\n    return ((string)\"'\"+c)+ \"'\";\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#if !ONLINE_JUDGE && 1\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\nll gcd(ll A, ll B)\n{\n    while(B!=0)\n    {\n        A%=B;\n        swap(A, B);\n    }\n    return A;\n}\n\nll lcm(ll A, ll B)\n{\n    return A*(B/gcd(A, B));\n}\n\nvoid solve(ll n)\n{\n    ll minres=n-1;\n    ll ansx=1;\n\n    for(ll d=2; d*d<=n; d++)\n    {\n        if(n%d!=0) continue;\n\n        ll tmp=lcm(d, n-d);\n        if(tmp < minres)\n        {\n            minres=tmp;\n            ansx=d;\n        }\n\n        tmp=lcm(n/d, n-n/d);\n        if(tmp < minres)\n        {\n            minres=tmp;\n            ansx=n/d;\n        }\n    }\n\n    cout << ansx << ' ' << n-ansx << '\\n';\n}\n\nint main()\n{\n#if !ONLINE_JUDGE && 1\n    freopen(\"B.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n#if 0\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n#endif\n\n    int TT;\n#if 1\n    cin >> TT;\n#else\n    TT=1;\n#endif\n    for(int ttt=0; ttt<TT; ttt++)\n    {\n        int n;\n        cin >> n;\n        solve(n);\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Omkar and Last Class of Math.json",
    "editorial_link": "https://codeforces.com//blog/entry/79974",
    "editorial": "Short Solution: The two integers are and , where is the largest proper\r\nfactor of .Proof: Let the two integers be and . Assume WLOG that .\r\nNotice that this implies that .We first claim that if , and we prove\r\nthis as follows: if , then there exists some integer such that . The\r\ninteger can then be written as , which is a multiple of . Thus, if .We\r\nnow show that if . We show this by using the fact that iff , so if , ,\r\nand so . And since must be a multiple of both and , it follows that .We\r\nhave now established that to minimize , must be a factor of . And, since\r\nwhen is a factor of , we need to minimize , so we must maximize by\r\nchoosing it to be the largest proper factor of (i. e. the largest factor\r\nof other than ).We then simply need to find , the largest proper factor\r\nof . If is the smallest prime dividing , then , so it suffices to find\r\nthe smallest prime factor of . We can do this by simply checking all\r\nvalues of such that . If is not prime, then it must have a prime factor\r\nnot exceeding . Furthermore, if we do not find a factor of between and ,\r\nthen must be prime so we simply get and .Weâre given that , so . ,\r\nmeaning that we will check less than numbers, which runs well under the\r\ntime limit.\r\n",
    "hint": []
}