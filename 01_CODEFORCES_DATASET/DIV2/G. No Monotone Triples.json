{
    "link": "https://codeforces.com//contest/1332/problem/G",
    "problemId": "578667",
    "problem_idx": "G",
    "shortId": "1332G",
    "contest_number": "1332",
    "problem_submissions": {
        "G": [
            74991585,
            75037266,
            77351427
        ],
        "F": [
            74972207,
            74968358,
            74971720,
            74973348,
            74978859,
            74982724,
            74982735,
            74986275,
            74983269,
            74987837,
            74986665,
            74991793,
            74983515,
            74979782,
            74972196,
            74981046,
            74990576,
            74985479,
            74988801,
            74990228
        ],
        "E": [
            74961161,
            74955523,
            74954162,
            74962710,
            74964351,
            74963597,
            74954423,
            74965477,
            74965579,
            74964400,
            74967235,
            74963711,
            74965887,
            74966494,
            74989155,
            74967207,
            74974070,
            74976881,
            74974061,
            74976693
        ],
        "D": [
            74952985,
            74945715,
            74946665,
            74947888,
            74950207,
            74948751,
            74939741,
            74946829,
            74947089,
            74946824,
            74948968,
            74945728,
            74948946,
            74959413,
            74956458,
            74959082,
            74952408,
            74962224,
            74953788,
            74952090
        ],
        "C": [
            74942005,
            74937624,
            74936343,
            74941037,
            74943187,
            74945247,
            74948388,
            74939023,
            74936776,
            74940250,
            74942517,
            74933392,
            74937059,
            74947682,
            74933984,
            74947387,
            74935824,
            74944324,
            74945827,
            74930594
        ],
        "B": [
            74937320,
            74934172,
            74933187,
            74935530,
            74936050,
            74936599,
            74943429,
            74933909,
            74931708,
            74932124,
            74935133,
            74939689,
            74933624,
            74939412,
            74938935,
            74936225,
            74945372,
            74938477,
            74936882,
            74941959
        ],
        "A": [
            74930167,
            74929341,
            74931394,
            74930114,
            74930077,
            74932449,
            74934529,
            74928977,
            74928761,
            74928547,
            74928820,
            74928500,
            74928970,
            74929648,
            74959446,
            74929583,
            74931416,
            74933421,
            74928735,
            74938510
        ]
    },
    "name": "G. No Monotone Triples",
    "statement": "Given a sequence of integers a of length n, a tuple (i,j,k) is called\r\nmonotone triples if 1\r\nle i<j<k\r\nle n; a_i\r\nle a_j\r\nle a_k or a_i\r\nge a_j\r\nge a_k is satisfied. For example, a=[5,3,4,5], then (2,3,4) is monotone\r\ntriples for sequence a while (1,3,4) is not.Bob is given a sequence of\r\nintegers a of length n in a math exam. The exams itself contains\r\nquestions of form L, R, for each of them he is asked to find any\r\nsubsequence b of sequence a_L, a_{L+1},\r\nldots, a_{R}.Recall that an sequence b is a subsequence of sequence a if\r\nb can be obtained by deletion of several (possibly zero, or all)\r\nelements.However, he hates monotone stuff, and he wants to find a\r\nsubsequence . Besides, he wants to find one subsequence with the length\r\namong all subsequences free from monotone triples for every query.Please\r\nhelp Bob find out subsequences meeting the above constraints.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define p2 p << 1\n#define p3 p << 1 | 1\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntemplate <class T>\ninline T Max(const T &a, const T &b) {return a > b ? a : b;}\n\ntemplate <class T>\ninline T Min(const T &a, const T &b) {return a < b ? a : b;}\n\nconst int N = 2e5 + 5, M = N << 2, E = 20;\n\nint n, q, a[N], top, stk[N], pre0[N], pre1[N], nxt0[N], nxt1[N], pre[N], nxt[N],\nlt[N], mx[M], rmin[N][E], rmax[N][E], Log[N], ml[N], mr[N], l0[N], r0[N],\nl1[N], r1[N];\nstd::vector<int> oz[N];\n\nvoid change(int l, int r, int pos, int v, int p)\n{\n\tmx[p] = Max(mx[p], v); if (l == r) return;\n\tint mid = l + r >> 1;\n\tif (pos <= mid) change(l, mid, pos, v, p2);\n\telse change(mid + 1, r, pos, v, p3);\n}\n\nint query(int l, int r, int x, int p)\n{\n\tif (l == r) return mx[p];\n\tint mid = l + r >> 1;\n\tif (x <= mid) return query(l, mid, x, p2);\n\telse return Max(mx[p2], query(mid + 1, r, x, p3));\n}\n\nint qmin(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmin[l][k]] < a[rmin[r - (1 << k) + 1][k]]\n\t\t? rmin[l][k] : rmin[r - (1 << k) + 1][k];\n}\n\nint qmax(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmax[l][k]] > a[rmax[r - (1 << k) + 1][k]]\n\t\t? rmax[l][k] : rmax[r - (1 << k) + 1][k];\n}\n\nint main()\n{\n\tint l, r;\n\tread(n); read(q);\n\tfor (int i = 1; i <= n; i++) read(a[i]), rmin[i][0] = rmax[i][0] = i;\n\tLog[0] = -1;\n\tfor (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1;\n\tfor (int j = 1; j <= 17; j++)\n\t\tfor (int i = 1; i + (1 << j) - 1 <= n; i++)\n\t\t{\n\t\t\trmin[i][j] = a[rmin[i][j - 1]] < a[rmin[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmin[i][j - 1] : rmin[i + (1 << j - 1)][j - 1];\n\t\t\trmax[i][j] = a[rmax[i][j - 1]] > a[rmax[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmax[i][j - 1] : rmax[i + (1 << j - 1)][j - 1];\n\t\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tpre0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tpre1[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tnxt0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tnxt1[i] = stk[top]; stk[++top] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) pre[i] = std::min(pre0[i], pre1[i]),\n\t\tnxt[i] = std::max(nxt0[i], nxt1[i]), oz[pre[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt[i] <= n) change(1, n, nxt[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tml[i] = ml[i - 1]; mr[i] = mr[i - 1];\n\t\tif (lt[i] > ml[i]) ml[i] = lt[i], mr[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre0[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt0[i] <= n) change(1, n, nxt0[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl0[i] = l0[i - 1]; r0[i] = r0[i - 1];\n\t\tif (lt[i] > l0[i]) l0[i] = lt[i], r0[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre1[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt1[i] <= n) change(1, n, nxt1[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl1[i] = l1[i - 1]; r1[i] = r1[i - 1];\n\t\tif (lt[i] > l1[i]) l1[i] = lt[i], r1[i] = i;\n\t}\n\twhile (q--)\n\t{\n\t\tread(l); read(r);\n\t\tif (ml[r] >= l)\n\t\t{\n\t\t\tputs(\"4\"); int x = qmin(ml[r], mr[r]), y = qmax(ml[r], mr[r]);\n\t\t\tif (x > y) std::swap(x, y);\n\t\t\tprintf(\"%d %d %d %d\\n\", ml[r], x, y, mr[r]);\n\t\t}\n\t\telse if (l0[r] >= l)\n\t\t\tputs(\"3\"), printf(\"%d %d %d\\n\", l0[r], qmin(l0[r], r0[r]), r0[r]);\n\t\telse if (l1[r] >= l)\n\t\t\tputs(\"3\"), printf(\"%d %d %d\\n\", l1[r], qmax(l1[r], r1[r]), r1[r]);\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. No Monotone Triples.json",
    "editorial_link": "https://codeforces.com//blog/entry/75432",
    "editorial": "We will solve this task with the following observations. If an array of\r\nlength () has no monotone triple, then one of the following is true: If\r\nan array of length () has no monotone triple, then its subsequence has\r\nno monotone triple. If an array of length 4 has no monotone triple, then\r\n, ,vice versa. WLOG, we assume , by observation 1 we will know that ,\r\nsince , we get a monotone triple , leading to contradiction. Second part\r\ncan be verified easily. For every array of length (), must have monotone\r\ntriple. WLOG, we just need to prove the observation holds when and cases\r\nwhen not all elements are equal. In that case, one of extremal can be\r\nreached in position other than . WLOG, we will assume that maximum is\r\nreached at position . However, cannot be monotone-triple-free, leading\r\nto contradiction!Combining those observations (or Erdos Szekeres theorem\r\nif you know it), we would like to get the following solution, which runs\r\nin . If the subsequence is monotone, the answer should be 0. If there\r\nexists such that and , fails to reach maximum and minimum among those\r\nfour numbers, the answer should be 4. Otherwise, the answer should be 3.\r\nIn the following paragraphs, we will only focus on the case of . Other\r\nstuffs can be dealt similarly (or easily).(the observation is crucial to\r\nobtain a faster solution)Notice that constraint is equivalent to that\r\nthere exists such that fails to reach maximum and minimum among . This\r\nobservation allows us to solve this task in with some precalculation.\r\n(though itâs still not enough to get accepted).Letâs solve the task for\r\na sequence of a pairwise distinct numbers and then change the conditions\r\nto a general sequence.Letâs fix the leftmost element of and look at what\r\nwe are asked to find. So there should be some position to the right of\r\nso that the range of values on positions excluding the greatest and the\r\nsmallest values includes both and .Letâs process the array from right to\r\nleft, maintaining two stacks. The top element in both stacks is the\r\ncurrently processed one. Next element of the first stack is the closest\r\nto the right element greater than the top one, and the next element of\r\nthe second stack is the closest to the right smaller than the top one.\r\nAnd the stacks go like that until the end of array.Iterating over one of\r\nthese stacks will show the increase of the range of values in one\r\ndirection, iterating over both at the same time will show how the range\r\nof values changes in total.So I claim that the sequence we are looking\r\nfor exists iff both stacks include more than element and there is an\r\nelement to the right of second elements of both stacks such that it is\r\nincluded in neither of the stacks. Naturally that condition tells that\r\nthere is some position in which neither maximum, nor minimum values are\r\nupdated.The values that are in neither of stacks can be maintained in a\r\nqueue or in a BIT.Basically, the position when the range of values\r\ndoesnât change is such a value which is both smaller than the maximum\r\nvalue on the segment and greater than the minimum one. Thus, we can\r\nchoose , the latest elements in both stacks up to that position and that\r\nposition itself.How to deal with not pairwise distinct elements? Well,\r\nitâs enough to change the conditions in stacks to the next greater or\r\nequal and the next smaller or equal. However, that will push the\r\nelements equal to the current one right next to it to the both stacks.\r\nPreviously we kinda used the fact that no element except the current one\r\nis in both stacks. I think that the easiest way to deal with it is to\r\nget the answer for the rightmost of the consecutive equal elements and\r\nthen just say that the answer for the rest of them is the same. Finally,\r\npush all these consecutive equal elements to the both stacks.As for\r\nqueries. I previously said that we can take the position where the value\r\nrange doesnât change. Basically, the first valid position is\r\ncoincidentally the shortest length valid segment starting from . So to\r\nfind the first position you just need to do a binary search over that\r\nqueue or BIT of the values which are in neither of the stacks. We can\r\neasily remember it for each position and then do a range minimum query\r\nchecking if any of the positions in have their shortest right border\r\nsmaller than .\r\n",
    "hint": []
}