{"link": "https://codeforces.com//contest/1332/problem/G", "problemId": "578667", "problem_idx": "G", "shortId": "1332G", "contest_number": "1332", "problem_submissions": {"G": [74991585, 75037266, 77351427], "F": [74972207, 74968358, 74971720, 74973348, 74978859, 74982724, 74982735, 74986275, 74983269, 74987837, 74986665, 74991793, 74983515, 74979782, 74972196, 74981046, 74990576, 74985479, 74988801, 74990228], "E": [74961161, 74955523, 74954162, 74962710, 74964351, 74963597, 74954423, 74965477, 74965579, 74964400, 74967235, 74963711, 74965887, 74966494, 74989155, 74967207, 74974070, 74976881, 74974061, 74976693], "D": [74952985, 74945715, 74946665, 74947888, 74950207, 74948751, 74939741, 74946829, 74947089, 74946824, 74948968, 74945728, 74948946, 74959413, 74956458, 74959082, 74952408, 74962224, 74953788, 74952090], "C": [74942005, 74937624, 74936343, 74941037, 74943187, 74945247, 74948388, 74939023, 74936776, 74940250, 74942517, 74933392, 74937059, 74947682, 74933984, 74947387, 74935824, 74944324, 74945827, 74930594], "B": [74937320, 74934172, 74933187, 74935530, 74936050, 74936599, 74943429, 74933909, 74931708, 74932124, 74935133, 74939689, 74933624, 74939412, 74938935, 74936225, 74945372, 74938477, 74936882, 74941959], "A": [74930167, 74929341, 74931394, 74930114, 74930077, 74932449, 74934529, 74928977, 74928761, 74928547, 74928820, 74928500, 74928970, 74929648, 74959446, 74929583, 74931416, 74933421, 74928735, 74938510]}, "name": "G. No Monotone Triples", "statement": "Given a sequence of integers a of length n, a tuple (i,j,k) is called\r\nmonotone triples if 1\r\nle i<j<k\r\nle n; a_i\r\nle a_j\r\nle a_k or a_i\r\nge a_j\r\nge a_k is satisfied. For example, a=[5,3,4,5], then (2,3,4) is monotone\r\ntriples for sequence a while (1,3,4) is not.Bob is given a sequence of\r\nintegers a of length n in a math exam. The exams itself contains\r\nquestions of form L, R, for each of them he is asked to find any\r\nsubsequence b of sequence a_L, a_{L+1},\r\nldots, a_{R}.Recall that an sequence b is a subsequence of sequence a if\r\nb can be obtained by deletion of several (possibly zero, or all)\r\nelements.However, he hates monotone stuff, and he wants to find a\r\nsubsequence . Besides, he wants to find one subsequence with the length\r\namong all subsequences free from monotone triples for every query.Please\r\nhelp Bob find out subsequences meeting the above constraints.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define p2 p << 1\n#define p3 p << 1 | 1\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntemplate <class T>\ninline T Max(const T &a, const T &b) {return a > b ? a : b;}\n\ntemplate <class T>\ninline T Min(const T &a, const T &b) {return a < b ? a : b;}\n\nconst int N = 2e5 + 5, M = N << 2, E = 20;\n\nint n, q, a[N], top, stk[N], pre0[N], pre1[N], nxt0[N], nxt1[N], pre[N], nxt[N],\nlt[N], mx[M], rmin[N][E], rmax[N][E], Log[N], ml[N], mr[N], l0[N], r0[N],\nl1[N], r1[N];\nstd::vector<int> oz[N];\n\nvoid change(int l, int r, int pos, int v, int p)\n{\n\tmx[p] = Max(mx[p], v); if (l == r) return;\n\tint mid = l + r >> 1;\n\tif (pos <= mid) change(l, mid, pos, v, p2);\n\telse change(mid + 1, r, pos, v, p3);\n}\n\nint query(int l, int r, int x, int p)\n{\n\tif (l == r) return mx[p];\n\tint mid = l + r >> 1;\n\tif (x <= mid) return query(l, mid, x, p2);\n\telse return Max(mx[p2], query(mid + 1, r, x, p3));\n}\n\nint qmin(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmin[l][k]] < a[rmin[r - (1 << k) + 1][k]]\n\t\t? rmin[l][k] : rmin[r - (1 << k) + 1][k];\n}\n\nint qmax(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmax[l][k]] > a[rmax[r - (1 << k) + 1][k]]\n\t\t? rmax[l][k] : rmax[r - (1 << k) + 1][k];\n}\n\nint main()\n{\n\tint l, r;\n\tread(n); read(q);\n\tfor (int i = 1; i <= n; i++) read(a[i]), rmin[i][0] = rmax[i][0] = i;\n\tLog[0] = -1;\n\tfor (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1;\n\tfor (int j = 1; j <= 17; j++)\n\t\tfor (int i = 1; i + (1 << j) - 1 <= n; i++)\n\t\t{\n\t\t\trmin[i][j] = a[rmin[i][j - 1]] < a[rmin[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmin[i][j - 1] : rmin[i + (1 << j - 1)][j - 1];\n\t\t\trmax[i][j] = a[rmax[i][j - 1]] > a[rmax[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmax[i][j - 1] : rmax[i + (1 << j - 1)][j - 1];\n\t\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tpre0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tpre1[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tnxt0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tnxt1[i] = stk[top]; stk[++top] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) pre[i] = std::min(pre0[i], pre1[i]),\n\t\tnxt[i] = std::max(nxt0[i], nxt1[i]), oz[pre[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt[i] <= n) change(1, n, nxt[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tml[i] = ml[i - 1]; mr[i] = mr[i - 1];\n\t\tif (lt[i] > ml[i]) ml[i] = lt[i], mr[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre0[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt0[i] <= n) change(1, n, nxt0[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl0[i] = l0[i - 1]; r0[i] = r0[i - 1];\n\t\tif (lt[i] > l0[i]) l0[i] = lt[i], r0[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre1[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt1[i] <= n) change(1, n, nxt1[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl1[i] = l1[i - 1]; r1[i] = r1[i - 1];\n\t\tif (lt[i] > l1[i]) l1[i] = lt[i], r1[i] = i;\n\t}\n\twhile (q--)\n\t{\n\t\tread(l); read(r);\n\t\tif (ml[r] >= l)\n\t\t{\n\t\t\tputs(\"4\"); int x = qmin(ml[r], mr[r]), y = qmax(ml[r], mr[r]);\n\t\t\tif (x > y) std::swap(x, y);\n\t\t\tprintf(\"%d %d %d %d\\n\", ml[r], x, y, mr[r]);\n\t\t}\n\t\telse if (l0[r] >= l)\n\t\t\tputs(\"3\"), printf(\"%d %d %d\\n\", l0[r], qmin(l0[r], r0[r]), r0[r]);\n\t\telse if (l1[r] >= l)\n\t\t\tputs(\"3\"), printf(\"%d %d %d\\n\", l1[r], qmax(l1[r], r1[r]), r1[r]);\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3100", "interactive": false}