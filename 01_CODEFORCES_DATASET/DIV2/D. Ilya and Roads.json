{"link": "https://codeforces.com//contest/313/problem/D", "problemId": "3096", "problem_idx": "D", "shortId": "313D", "contest_number": "313", "problem_submissions": {"E": [3802009, 3802725, 3801964, 3805353], "D": [3797720, 3799986, 3798627, 3799192, 3799268, 3799353, 3800711, 3799866, 3801002, 3801699, 3801627, 3801742, 3801622, 3802083, 3801117, 3802360, 3801613, 3801908, 3802535], "A": [3802962, 3795436, 3795102, 3797387, 3795045, 3798014, 3794999, 3795409, 3795792, 3794982, 3795227, 3795063, 4322018, 3795032, 3797305, 3795417, 3795327, 3795051, 3795267], "B": [3801577, 3795995, 3795723, 3796954, 3795477, 3797148, 3795579, 3796367, 3796731, 3795434, 3796152, 3795631, 4322027, 3795692, 3798022, 3795515, 3796167, 3796035, 3796153, 3796081], "C": [3797963, 3797299, 3796705, 3796548, 3798340, 3796144, 3800856, 3799056, 3797632, 3798099, 3797857, 3799305, 3796795, 3796746, 3807119, 3797868, 3799430, 3798657, 3798471, 3797214]}, "name": "D. Ilya and Roads", "statement": "Everything is great about Ilya\u2019s city, except the roads. The thing is,\r\nthe only ZooVille road is represented as holes in a row. We will\r\nconsider the holes numbered from 1 to , from left to right.Ilya is\r\nreally keep on helping his city. So, he wants to fix at least holes\r\n(perharps he can fix more) on a single ZooVille road. The city has\r\nbuilding companies, the -th company needs money units to fix a road\r\nsegment containing holes with numbers of at least and at most . The\r\ncompanies in ZooVille are very greedy, so, if they fix a segment\r\ncontaining some already fixed holes, they do not decrease the price for\r\nfixing the segment. Determine the minimum money Ilya will need to fix at\r\nleast holes.\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m, k;\nlong long cost[333][333];\nlong long dp[333][333];\n\nlong long min(const long long a, const long long b) { return a < b ? a : b; }\n\nint main() {\n    // freopen(\"D.in\", \"r\", stdin);\n\n    scanf(\"%d%d%d\", &n, &m, &k);\n    memset(cost, 63, sizeof cost);\n    for(int i = 1; i <= m; i++) {\n        int l, r, c;\n        scanf(\"%d%d%d\", &l, &r, &c);\n        cost[l][r] = min(cost[l][r], c);\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = i; j <= n; j++)\n            for(int k = i; k <= j; k++) {\n                cost[i][k] = min(cost[i][k], cost[i][j]);\n                cost[k][j] = min(cost[k][j], cost[i][j]);\n            }\n    memset(dp, 63, sizeof dp);\n    dp[0][0] = 0;\n    for(int i = 1; i <= n; i++) {\n        dp[i][0] = 0;\n        for(int k = 1; k <= i; k++) {\n            dp[i][k] = min(dp[i][k], dp[i-1][k]);\n            for(int j = 1; j <= i; j++)\n                if (k-(i-j+1) >= 0) dp[i][k] = min(dp[i][k], dp[j-1][k-(i-j+1)] + cost[j][i]);\n        }\n    }\n    long long ret = 2e18;\n    for(int kk = k; kk <= n; kk++)\n        ret = min(ret, dp[n][kk]);\n    printf(\"%I64d\", ret < 1e18 ? ret : -1);\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2100", "interactive": false}