{
    "link": "https://codeforces.com//contest/982/problem/F",
    "problemId": "183676",
    "problem_idx": "F",
    "shortId": "982F",
    "contest_number": "982",
    "problem_submissions": {
        "D": [
            38375535,
            38368851,
            38373726,
            38377162,
            38371395,
            38370646,
            38371994,
            38375134,
            38373026,
            38372327,
            38378250,
            38374514,
            38364939,
            38373007,
            38369726,
            38368852,
            38367484,
            38371092,
            38368305
        ],
        "C": [
            38369557,
            38365950,
            38368727,
            38373748,
            38365636,
            38362990,
            38360353,
            38357935,
            38366403,
            38365707,
            38366242,
            38368203,
            38360426,
            38360914,
            38358247,
            38360443,
            38360473,
            38363231,
            38362845
        ],
        "B": [
            38368596,
            38365056,
            38363500,
            38360346,
            38360284,
            38359729,
            38364781,
            38362446,
            38362143,
            38359325,
            38360710,
            38365274,
            38357153,
            38595002,
            38358897,
            38360993,
            38362869,
            38358240,
            38360536,
            38357974
        ],
        "A": [
            38367216,
            38364962,
            38356449,
            38356432,
            38356314,
            38356331,
            38367453,
            38355628,
            38357632,
            38356537,
            38357572,
            38363973,
            38355536,
            38355838,
            38356345,
            38364483,
            38355616,
            38357300,
            38355573
        ],
        "F": [
            38365213,
            38386318,
            38386309,
            38375562,
            38372484,
            38551586
        ],
        "E": [
            38373371,
            38376699,
            38377910,
            38376666,
            38377583,
            38377503,
            38378506,
            38374036,
            38378687,
            40182999
        ]
    },
    "name": "F. The Meeting Place Cannot Be Changed",
    "statement": "Petr is a detective in Braginsk. Somebody stole a huge amount of money\r\nfrom a bank and Petr is to catch him. Somebody told Petr that some\r\nluxurious car moves along the roads without stopping.Petr knows that it\r\nis the robbers who drive the car. The roads in Braginsk are\r\none-directional and each of them connects two intersections. Petr wants\r\nto select one intersection such that if the robbers continue to drive\r\nthe roads indefinitely, they will sooner or later come to that\r\nintersection. The initial position of the robbers is unknown. Find such\r\nan intersection that fits the requirements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing vi = vector<int>;\n\n#define pb push_back\n\nconst int MXL = 0x3f3f3f3f;\nconst int mxn = 500006;\nusing ai = int[mxn];\nusing avi = vi[mxn];\n\nai dfn, low, scc; int cnt, scnt;\nstack<int,vi> sta; bool ins[mxn];\nint tarjan(int x, vi *e) {\n        dfn[x] = low[x] = ++cnt;\n        sta.push(x); ins[x] = true;\n        for (auto i : e[x]) low[x] = min(low[x],\n                dfn[i] ? dfn[ins[i] ? i : x] : tarjan(i, e));\n        if (low[x] == dfn[x]) {\n                ++scnt; int t;\n                do { t = sta.top(); sta.pop(); ins[t] = false;\n                        scc[t] = scnt; } while (t != x);\n        }\n        return low[x];\n}\n\nint n, m;\navi e;\nint sz[mxn];\n\nint s;\n\nbool v[mxn];\nvi ring;\nbool dfs(int x) { // 从固定点s找环的dfs\n        if (v[x] && x == s) return true;\n        if (v[x]) return false;\n        v[x] = true;\n        ring.pb(x);\n        for (auto i : e[x])\n                if (dfs(i))\n                        return true;\n        ring.pop_back();\n        return false;\n}\n\nint rid[mxn];\n\navi e2;\n\nstruct MM { // minmax\n        int mn, mx;\n        MM() : mn(MXL), mx(-MXL) {}\n        MM(int x) : mn(x), mx(x) {}\n        MM(int mn, int mx) : mn(mn), mx(mx) {}\n        void add(MM b) {\n                mn = min(mn, b.mn);\n                mx = max(mx, b.mx);\n        }\n};\n\n// forward / back\navi ef, eb;\nMM ff[mxn], fb[mxn];\nbool vf[mxn], vb[mxn];\n\nint c[mxn];\n\n// 似乎比题解讲的复杂，因为环外边的准确定义应该是不经过环上节点的路径（起点、终点除外）!!\n// 环上节点不能自己更新自己…否则会产生自环的意义… !!\nvoid dp(vi *e, MM *f, bool *v) {\n        function<void(int)> cal = [&](int x) {\n                if (v[x]) return;\n                v[x] = true;\n                for (auto i : e[x]) {\n                        if (!rid[i]) {\n                                cal(i);\n                                f[x].add(f[i]);\n                        } else {\n                                f[x].add(rid[i]);\n                        }\n                }\n        };\n        for (int i = 1; i <= n; ++i) if (!v[i])\n                cal(i);\n}\n\nint main() {\n        #define NIE ({puts(\"-1\"); return 0;})\n        #define ZERO ({puts(\"-1\"); puts(\"\"); return 0;})\n        cin >> n >> m;\n        for (int i = 0; i < m; ++i) {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                e[x].pb(y);\n        }\n\n        for (int i = 1; i <= n; ++i) if (!dfn[i])\n                tarjan(i, e);\n\n        for (int i = 1; i <= n; ++i)\n                ++sz[scc[i]];\n\n        for (int i = 1; i <= n; ++i) if (sz[scc[i]] > 1)\n                s = i;\n\n        // 无环\n\n        if (!s) NIE;\n\n        // 找出第一个环\n\n        dfs(s);\n\n        int rn = ring.size();\n\n        for (int i = 0; i < rn; ++i)\n                rid[ring[i]] = i + 1;\n\n        // 判第二个环\n\n        fill(dfn, dfn + n + 1, 0);\n        cnt = scnt = 0;\n        for (int i = 1; i <= n; ++i)\n                for (auto j : e[i])\n                        if (!rid[i] && !rid[j])\n                                e2[i].pb(j);\n\n        fill(sz, sz + n + 1, 0);\n\n        for (int i = 1; i <= n; ++i) if (!dfn[i])\n                tarjan(i, e2);\n\n        for (int i = 1; i <= n; ++i)\n                ++sz[scc[i]];\n\n        for (int i = 1; i <= n; ++i) if (sz[scc[i]] > 1)\n                ZERO;\n\n        // 环上DP\n\n        for (int i = 1; i <= n; ++i)\n                for (auto j : e[i])\n                        /*if (!rid[i] || !rid[j] || (rid[i] - 1 + 1) % rn != rid[j] - 1) */{ // 直接用原图应该也没问题? 毕竟对环交点来说环上边不影响结果？\n                                ef[i].pb(j);\n                                eb[j].pb(i);\n                        }\n\n        dp(ef, ff, vf);\n        dp(eb, fb, vb);\n\n        auto rem = [](int l, int r) {\n                if (l <= r) {\n                        ++c[l];\n                        --c[r + 1];\n                }\n        };\n\n        for (int i = 1; i <= rn; ++i) {\n                int x = ring[i - 1];\n                // 下面都有等于的可能，虽然没有自环\n                if (ff[x].mx >= i) rem(i + 1, ff[x].mx - 1); // 环序号是i不是x!!!!!\n                if (ff[x].mn <= i) rem(i + 1, rn);\n                if (fb[x].mx >= i) rem(1, i - 1);\n        }\n\n        partial_sum(c, c + rn + 1, c);\n\n        vi sol;\n        for (int i = 1; i <= rn; ++i) if (!c[i])\n                sol.pb(ring[i - 1]);\n\n        sort(sol.begin(), sol.end());\n\tif (sol.size()==0){ puts(\"-1\"); return 0; }\n        cout << sol[0] << endl;\n\n\n        return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. The Meeting Place Cannot Be Changed.json",
    "editorial_link": "https://codeforces.com//blog/entry/59551",
    "editorial": "Letâs assume that solution exists and will looking for solution relying\r\non this assumption. At the end will check found \"solution\" in linear\r\ntime, and if it is not real solution, then assumption wasnât right. If\r\nsolution exists, then intersection (by vertices) of all cycles is not\r\nempty. Letâs take any one cycle and call it \"main cycle\". Letâs imagine\r\nthis \"main cycle\" as circle directed clockwise. And letâs mark all\r\nrequired vertices of intersection of all cycles on this circle (this\r\nvertices are the answer). Consider only cycles which leave \"main cycle\",\r\ncome back to the \"main cycle\", and then moves on the \"main cycle\" to the\r\nbegining. Every such cycle when comes back to the \"main cycle\" DOES NOT\r\njump over any marked vertex of the answer, in terms of direction of the\r\n\"main cycle\" (otherwise answer not exists, but we assumed, that it\r\nexists) (if cycle comes back to the same vertex, then by definition it\r\njumped over the whole \"main cycle\", not 0). Draw the arc from the\r\nvertex, where cycle comes back to the \"main cycle\" till the vertex,\r\nwhere it leaves \"main cycle\", in the direction of the \"main cycle\".\r\nVertices not covered by this arc canât be the answer. Intersection of\r\nall considered cycles is marked by intersection of all such arcs. Now\r\nwas not considered only cycles which some times leave \"main cycle\" and\r\nsome times comes back to it. But intersection of such cycle with the\r\n\"main cycle\" is the same as intersection of simple cycles from previous\r\nparagraph between adjacent leave/comebacks. Therefore such cycles may be\r\nignored. For searching the answer we must mark arcs between\r\nleaves/comebacks of the main cycle. We do this by starting dfs from all\r\nvertices of the \"main cycle\" and trying to come back to it as far as\r\npossible (distance measured as the number of vertices of the \"main\r\ncycle\" between leave and comeback). As were noticed early, cycles does\r\nnot jump over the answer. Therefore dfses started between boundaries of\r\nthe answer are aspires to this boundary in direction of the \"main\r\ncycle\". Therefore if we selected the most far vertex in one dfs(u)\r\nreached from one start point v0, this vertex for dfs(u) reached from\r\nother start point v1 will be the most far too. And we can run all dfses\r\nwith common \"used\" array, caching the most far vertex in it. Finally the\r\nsolution is so: 1) find the \"main cycle\" and sort vertices in it, 2)\r\nstart dfses from vertices of the \"main cycle\" and mark arcs between\r\nfinish and start, 3) intersect all arcs and take answer from\r\nintersection, 4) verify answer by deleting it from graph and trying to\r\nfind any other cycle, if it founded, then assumption was wrong and\r\nsolution doesnât exists else print the answer.\r\n",
    "hint": []
}