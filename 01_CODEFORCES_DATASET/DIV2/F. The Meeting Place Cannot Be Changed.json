{
    "link": "https://codeforces.com//contest/982/problem/F",
    "problemId": "183676",
    "problem_idx": "F",
    "shortId": "982F",
    "contest_number": "982",
    "problem_submissions": {
        "D": [
            38375535,
            38368851,
            38373726,
            38377162,
            38371395,
            38370646,
            38371994,
            38375134,
            38373026,
            38372327,
            38378250,
            38374514,
            38364939,
            38373007,
            38369726,
            38368852,
            38367484,
            38371092,
            38368305
        ],
        "C": [
            38369557,
            38365950,
            38368727,
            38373748,
            38365636,
            38362990,
            38360353,
            38357935,
            38366403,
            38365707,
            38366242,
            38368203,
            38360426,
            38360914,
            38358247,
            38360443,
            38360473,
            38363231,
            38362845
        ],
        "B": [
            38368596,
            38365056,
            38363500,
            38360346,
            38360284,
            38359729,
            38364781,
            38362446,
            38362143,
            38359325,
            38360710,
            38365274,
            38357153,
            38595002,
            38358897,
            38360993,
            38362869,
            38358240,
            38360536,
            38357974
        ],
        "A": [
            38367216,
            38364962,
            38356449,
            38356432,
            38356314,
            38356331,
            38367453,
            38355628,
            38357632,
            38356537,
            38357572,
            38363973,
            38355536,
            38355838,
            38356345,
            38364483,
            38355616,
            38357300,
            38355573
        ],
        "F": [
            38365213,
            38386318,
            38386309,
            38375562,
            38372484,
            38551586
        ],
        "E": [
            38373371,
            38376699,
            38377910,
            38376666,
            38377583,
            38377503,
            38378506,
            38374036,
            38378687,
            40182999
        ]
    },
    "name": "F. The Meeting Place Cannot Be Changed",
    "statement": "Petr is a detective in Braginsk. Somebody stole a huge amount of money\r\nfrom a bank and Petr is to catch him. Somebody told Petr that some\r\nluxurious car moves along the roads without stopping.Petr knows that it\r\nis the robbers who drive the car. The roads in Braginsk are\r\none-directional and each of them connects two intersections. Petr wants\r\nto select one intersection such that if the robbers continue to drive\r\nthe roads indefinitely, they will sooner or later come to that\r\nintersection. The initial position of the robbers is unknown. Find such\r\nan intersection that fits the requirements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing vi = vector<int>;\n\n#define pb push_back\n\nconst int MXL = 0x3f3f3f3f;\nconst int mxn = 500006;\nusing ai = int[mxn];\nusing avi = vi[mxn];\n\nai dfn, low, scc; int cnt, scnt;\nstack<int,vi> sta; bool ins[mxn];\nint tarjan(int x, vi *e) {\n        dfn[x] = low[x] = ++cnt;\n        sta.push(x); ins[x] = true;\n        for (auto i : e[x]) low[x] = min(low[x],\n                dfn[i] ? dfn[ins[i] ? i : x] : tarjan(i, e));\n        if (low[x] == dfn[x]) {\n                ++scnt; int t;\n                do { t = sta.top(); sta.pop(); ins[t] = false;\n                        scc[t] = scnt; } while (t != x);\n        }\n        return low[x];\n}\n\nint n, m;\navi e;\nint sz[mxn];\n\nint s;\n\nbool v[mxn];\nvi ring;\nbool dfs(int x) { // \u4ece\u56fa\u5b9a\u70b9s\u627e\u73af\u7684dfs\n        if (v[x] && x == s) return true;\n        if (v[x]) return false;\n        v[x] = true;\n        ring.pb(x);\n        for (auto i : e[x])\n                if (dfs(i))\n                        return true;\n        ring.pop_back();\n        return false;\n}\n\nint rid[mxn];\n\navi e2;\n\nstruct MM { // minmax\n        int mn, mx;\n        MM() : mn(MXL), mx(-MXL) {}\n        MM(int x) : mn(x), mx(x) {}\n        MM(int mn, int mx) : mn(mn), mx(mx) {}\n        void add(MM b) {\n                mn = min(mn, b.mn);\n                mx = max(mx, b.mx);\n        }\n};\n\n// forward / back\navi ef, eb;\nMM ff[mxn], fb[mxn];\nbool vf[mxn], vb[mxn];\n\nint c[mxn];\n\n// \u4f3c\u4e4e\u6bd4\u9898\u89e3\u8bb2\u7684\u590d\u6742\uff0c\u56e0\u4e3a\u73af\u5916\u8fb9\u7684\u51c6\u786e\u5b9a\u4e49\u5e94\u8be5\u662f\u4e0d\u7ecf\u8fc7\u73af\u4e0a\u8282\u70b9\u7684\u8def\u5f84\uff08\u8d77\u70b9\u3001\u7ec8\u70b9\u9664\u5916\uff09!!\n// \u73af\u4e0a\u8282\u70b9\u4e0d\u80fd\u81ea\u5df1\u66f4\u65b0\u81ea\u5df1\u2026\u5426\u5219\u4f1a\u4ea7\u751f\u81ea\u73af\u7684\u610f\u4e49\u2026 !!\nvoid dp(vi *e, MM *f, bool *v) {\n        function<void(int)> cal = [&](int x) {\n                if (v[x]) return;\n                v[x] = true;\n                for (auto i : e[x]) {\n                        if (!rid[i]) {\n                                cal(i);\n                                f[x].add(f[i]);\n                        } else {\n                                f[x].add(rid[i]);\n                        }\n                }\n        };\n        for (int i = 1; i <= n; ++i) if (!v[i])\n                cal(i);\n}\n\nint main() {\n        #define NIE ({puts(\"-1\"); return 0;})\n        #define ZERO ({puts(\"-1\"); puts(\"\"); return 0;})\n        cin >> n >> m;\n        for (int i = 0; i < m; ++i) {\n                int x, y;\n                scanf(\"%d%d\", &x, &y);\n                e[x].pb(y);\n        }\n\n        for (int i = 1; i <= n; ++i) if (!dfn[i])\n                tarjan(i, e);\n\n        for (int i = 1; i <= n; ++i)\n                ++sz[scc[i]];\n\n        for (int i = 1; i <= n; ++i) if (sz[scc[i]] > 1)\n                s = i;\n\n        // \u65e0\u73af\n\n        if (!s) NIE;\n\n        // \u627e\u51fa\u7b2c\u4e00\u4e2a\u73af\n\n        dfs(s);\n\n        int rn = ring.size();\n\n        for (int i = 0; i < rn; ++i)\n                rid[ring[i]] = i + 1;\n\n        // \u5224\u7b2c\u4e8c\u4e2a\u73af\n\n        fill(dfn, dfn + n + 1, 0);\n        cnt = scnt = 0;\n        for (int i = 1; i <= n; ++i)\n                for (auto j : e[i])\n                        if (!rid[i] && !rid[j])\n                                e2[i].pb(j);\n\n        fill(sz, sz + n + 1, 0);\n\n        for (int i = 1; i <= n; ++i) if (!dfn[i])\n                tarjan(i, e2);\n\n        for (int i = 1; i <= n; ++i)\n                ++sz[scc[i]];\n\n        for (int i = 1; i <= n; ++i) if (sz[scc[i]] > 1)\n                ZERO;\n\n        // \u73af\u4e0aDP\n\n        for (int i = 1; i <= n; ++i)\n                for (auto j : e[i])\n                        /*if (!rid[i] || !rid[j] || (rid[i] - 1 + 1) % rn != rid[j] - 1) */{ // \u76f4\u63a5\u7528\u539f\u56fe\u5e94\u8be5\u4e5f\u6ca1\u95ee\u9898? \u6bd5\u7adf\u5bf9\u73af\u4ea4\u70b9\u6765\u8bf4\u73af\u4e0a\u8fb9\u4e0d\u5f71\u54cd\u7ed3\u679c\uff1f\n                                ef[i].pb(j);\n                                eb[j].pb(i);\n                        }\n\n        dp(ef, ff, vf);\n        dp(eb, fb, vb);\n\n        auto rem = [](int l, int r) {\n                if (l <= r) {\n                        ++c[l];\n                        --c[r + 1];\n                }\n        };\n\n        for (int i = 1; i <= rn; ++i) {\n                int x = ring[i - 1];\n                // \u4e0b\u9762\u90fd\u6709\u7b49\u4e8e\u7684\u53ef\u80fd\uff0c\u867d\u7136\u6ca1\u6709\u81ea\u73af\n                if (ff[x].mx >= i) rem(i + 1, ff[x].mx - 1); // \u73af\u5e8f\u53f7\u662fi\u4e0d\u662fx!!!!!\n                if (ff[x].mn <= i) rem(i + 1, rn);\n                if (fb[x].mx >= i) rem(1, i - 1);\n        }\n\n        partial_sum(c, c + rn + 1, c);\n\n        vi sol;\n        for (int i = 1; i <= rn; ++i) if (!c[i])\n                sol.pb(ring[i - 1]);\n\n        sort(sol.begin(), sol.end());\n\tif (sol.size()==0){ puts(\"-1\"); return 0; }\n        cout << sol[0] << endl;\n\n\n        return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. The Meeting Place Cannot Be Changed.json",
    "editorial_link": "https://codeforces.com//blog/entry/59551",
    "editorial": "Let\u00e2\u0080\u0099s assume that solution exists and will looking for solution relying\r\non this assumption. At the end will check found \"solution\" in linear\r\ntime, and if it is not real solution, then assumption wasn\u00e2\u0080\u0099t right. If\r\nsolution exists, then intersection (by vertices) of all cycles is not\r\nempty. Let\u00e2\u0080\u0099s take any one cycle and call it \"main cycle\". Let\u00e2\u0080\u0099s imagine\r\nthis \"main cycle\" as circle directed clockwise. And let\u00e2\u0080\u0099s mark all\r\nrequired vertices of intersection of all cycles on this circle (this\r\nvertices are the answer). Consider only cycles which leave \"main cycle\",\r\ncome back to the \"main cycle\", and then moves on the \"main cycle\" to the\r\nbegining. Every such cycle when comes back to the \"main cycle\" DOES NOT\r\njump over any marked vertex of the answer, in terms of direction of the\r\n\"main cycle\" (otherwise answer not exists, but we assumed, that it\r\nexists) (if cycle comes back to the same vertex, then by definition it\r\njumped over the whole \"main cycle\", not 0). Draw the arc from the\r\nvertex, where cycle comes back to the \"main cycle\" till the vertex,\r\nwhere it leaves \"main cycle\", in the direction of the \"main cycle\".\r\nVertices not covered by this arc can\u00e2\u0080\u0099t be the answer. Intersection of\r\nall considered cycles is marked by intersection of all such arcs. Now\r\nwas not considered only cycles which some times leave \"main cycle\" and\r\nsome times comes back to it. But intersection of such cycle with the\r\n\"main cycle\" is the same as intersection of simple cycles from previous\r\nparagraph between adjacent leave/comebacks. Therefore such cycles may be\r\nignored. For searching the answer we must mark arcs between\r\nleaves/comebacks of the main cycle. We do this by starting dfs from all\r\nvertices of the \"main cycle\" and trying to come back to it as far as\r\npossible (distance measured as the number of vertices of the \"main\r\ncycle\" between leave and comeback). As were noticed early, cycles does\r\nnot jump over the answer. Therefore dfses started between boundaries of\r\nthe answer are aspires to this boundary in direction of the \"main\r\ncycle\". Therefore if we selected the most far vertex in one dfs(u)\r\nreached from one start point v0, this vertex for dfs(u) reached from\r\nother start point v1 will be the most far too. And we can run all dfses\r\nwith common \"used\" array, caching the most far vertex in it. Finally the\r\nsolution is so: 1) find the \"main cycle\" and sort vertices in it, 2)\r\nstart dfses from vertices of the \"main cycle\" and mark arcs between\r\nfinish and start, 3) intersect all arcs and take answer from\r\nintersection, 4) verify answer by deleting it from graph and trying to\r\nfind any other cycle, if it founded, then assumption was wrong and\r\nsolution doesn\u00e2\u0080\u0099t exists else print the answer.\r\n"
}