{
    "link": "https://codeforces.com//contest/1420/problem/A",
    "problemId": "735849",
    "problem_idx": "A",
    "shortId": "1420A",
    "contest_number": "1420",
    "problem_submissions": {
        "E": [
            93699813,
            93707260,
            93695968,
            93707648,
            93705681,
            93709151,
            93715432,
            93730964,
            93708580,
            93714548,
            93716147,
            93715550,
            93736542,
            93717442,
            93710855,
            93715981,
            93697763,
            93711132,
            93762507
        ],
        "D": [
            93676952,
            93680084,
            93692950,
            93670877,
            93690670,
            93693136,
            93730971,
            93710781,
            93702357,
            93681953,
            93695104,
            93691378,
            93699248,
            93698024,
            93665582,
            93680861,
            93671056,
            93667892,
            93675623
        ],
        "C2": [
            93674880,
            93671167,
            93692067,
            93741708,
            93681627,
            93659881,
            93679255,
            93686831,
            93676610,
            93670869,
            93669089,
            93684016,
            93707465,
            93690589,
            93710188,
            93716769,
            93662876,
            93683514,
            93665601
        ],
        "C1": [
            93658399,
            93663408,
            93681461,
            93660059,
            93679792,
            93666232,
            93663489,
            93671318,
            93669597,
            93684191,
            93665522,
            93690460,
            93659663,
            93716842,
            93670252,
            93662639,
            93658224,
            93665421
        ],
        "B": [
            93652358,
            93659482,
            93658665,
            93669626,
            93664158,
            93660524,
            93657692,
            93655021,
            93655235,
            93677044,
            93656189,
            93674995,
            93653603,
            93704106,
            93656350,
            93653174,
            93653888,
            93653561
        ],
        "A": [
            93651966,
            93651886,
            93654562,
            93660205,
            93652727,
            93651674,
            93651632,
            93674907,
            93652710,
            93659767,
            93651617,
            93706046,
            93651985,
            93651435,
            93651489,
            93651367
        ]
    },
    "name": "A. Cubes Sorting",
    "statement": "Wheatley decided to try to make a test chamber. He made a nice test\r\nchamber, but there was only one detail absent cubes.For completing the\r\nchamber Wheatley needs n cubes. i-th cube has a volume a_i.Wheatley has\r\nto place cubes in such a way that they would be sorted in a\r\nnon-decreasing order by their volume. Formally, for each i>1, a_{i-1}\r\nle a_i must hold.To achieve his goal, Wheatley can exchange two cubes.\r\nIt means that for any i>1 you can exchange cubes on positions i-1 and\r\ni.But there is a problem: Wheatley is very impatient. If Wheatley needs\r\nmore than\r\nfrac{n\r\ncdot (n-1)}{2}-1 exchange operations, he won’t do this boring\r\nwork.Wheatly wants to know: can cubes be sorted under this conditions?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=1e5+5;\nint a[N],n;\nvoid solve(){\n\tscanf(\"%d\",&n);\n\tint x=1;\n\trep(i,1,n) scanf(\"%d\",a+i);\n\trep(i,1,n-1){\n\t\tif(a[i]<=a[i+1]) x=0;\n\t}\n\tputs(x?\"NO\":\"YES\");\n}\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "sortings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Cubes Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/82978",
    "editorial": "It is not difficult to see that the answer in this task is possible when\r\nand only when all are different and sorted in descending order. In this\r\ncase we need operations. Otherwise the answer is always .Why does this\r\nsolution work? Letâs define as the number of pairs such as . Note that\r\nif the number of inversions is zero, the array is sorted in\r\nnon-decreasing order. If the array is not sorted, we can always choose\r\ntwo neighboring elements such that and swap them. In this case, the\r\nnumber of inversions is reduced by one. In this case, we cannot reduce\r\nthe number of inversions by more than one, so it is equal to the minimum\r\nnumber of operations we must perform.Now, all we have to do is notice\r\nthat the number of inversions does not exceed , and the maximum is only\r\nreached when for all pairs . It follows that in this case the array must\r\nbe strictly descending.Thus, we have a solution with a time of .\r\n",
    "hint": [
        "Hint Any array can be sorted using no more than operations. Think or guess when we need exactly operations."
    ]
}