{
    "link": "https://codeforces.com//contest/1362/problem/D",
    "problemId": "640965",
    "problem_idx": "D",
    "shortId": "1362D",
    "contest_number": "1362",
    "problem_submissions": {
        "E": [
            82533242,
            82534444,
            82537740,
            82514250,
            82533930,
            82533069,
            82537596,
            82539990,
            82540242,
            82538471,
            82539682,
            82530965,
            82542614,
            82539643,
            82539283,
            82546202,
            82528337,
            82546467
        ],
        "D": [
            82510668,
            82507788,
            82509488,
            82531898,
            82514757,
            82515389,
            82522345,
            82516278,
            82518522,
            82519426,
            82519224,
            82768835,
            82595629,
            82522253,
            82524305,
            82523832,
            82521456,
            82543796,
            82520171
        ],
        "C": [
            82499455,
            82498958,
            82501198,
            82493857,
            82499687,
            82506922,
            82499891,
            82507219,
            82505247,
            82500067,
            82504471,
            82506074,
            82507172,
            82504835,
            82510757,
            82507288,
            82510259
        ],
        "B": [
            82495744,
            82495722,
            82497194,
            82492324,
            82495262,
            82500116,
            82495247,
            82495676,
            82498396,
            82494894,
            82501982,
            82494238,
            82501685,
            82493927,
            82498961,
            82504636,
            82504999
        ],
        "A": [
            82492673,
            82492696,
            82492707,
            82492807,
            82492452,
            82496773,
            82492476,
            82492710,
            82493556,
            82492430,
            82494321,
            82492417,
            82493444,
            82492319,
            82493342,
            82492942,
            82498191
        ],
        "F": [
            99790549,
            99789950,
            99789855,
            99786615,
            99786490,
            99783918,
            99783396,
            99783108,
            99779312,
            99779011,
            99778620,
            99777308,
            99776727,
            99776430,
            99776080,
            99775979,
            99775398,
            99023034,
            99020809,
            99014011,
            99012603,
            82568961,
            82562279,
            82589807
        ]
    },
    "name": "D. Johnny and Contribution",
    "statement": "Today Johnny wants to increase his contribution. His plan assumes\r\nwriting n blogs. One blog covers one topic, but one topic can be covered\r\nby many blogs. Moreover, some blogs have references to each other. Each\r\npair of blogs that are connected by a reference has to cover different\r\ntopics because otherwise, the readers can notice that they are split\r\njust for more contribution. Set of blogs and bidirectional references\r\nbetween some pairs of them is called blogs network.There are n different\r\ntopics, numbered from 1 to n sorted by Johnny’s knowledge. The structure\r\nof the blogs network is already prepared. Now Johnny has to write the\r\nblogs in some order. He is lazy, so each time before writing a blog, he\r\nlooks at it’s already written neighbors (the blogs referenced to current\r\none) and chooses the topic with the smallest number which is not covered\r\nby neighbors. It’s easy to see that this strategy will always allow him\r\nto choose a topic because there are at most n - 1 neighbors.For example,\r\nif already written neighbors of the current blog have topics number 1,\r\n3, 1, 5, and 2, Johnny will choose the topic number 4 for the current\r\nblog, because topics number 1, 2 and 3 are already covered by neighbors\r\nand topic number 4 isn’t covered.As a good friend, you have done some\r\nresearch and predicted the best topic for each blog. Can you tell\r\nJohnny, in which order he has to write the blogs, so that his strategy\r\nproduces the topic assignment chosen by you?\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nvector<int> res;\n\nstruct edge {\n\tint u, v; edge() {}\n\tedge(int _u, int _v) :\n\t\tu(_u), v(_v) {}\n};\n\nstruct node { int mex = -1; vector<edge> edges; };\n\nstruct graph {\n\tvector<node> nodes;\n\tint n;\n\n\tgraph(int _n) : n(_n) { nodes.resize(n); }\n\n\tvoid add_edge(int u, int v) {\n\t\tedge e1(u, v); nodes[u].edges.push_back(e1);\n\t\tedge e2(v, u); nodes[v].edges.push_back(e2);\n\t}\n\n\tbool check(vector<pair<int, int>> &mexOfNode) {\n\t\tvector<bool> visited(n, 0);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cur = res[i];\n\n\t\t\tset<int> seen;\n\t\t\tfor (auto &e : nodes[cur].edges) {\n\t\t\t\tif (nodes[e.v].mex != -1) {\n\t\t\t\t\tseen.insert(nodes[e.v].mex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint curMex = 1;\n\t\t\twhile (seen.count(curMex)) { curMex++; }\n\n\t\t\tnodes[cur].mex = curMex;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (mexOfNode[i].first != nodes[mexOfNode[i].second].mex) { return false; }\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n, m; cin >> n >> m;\n\tgraph g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tg.add_edge(a, b);\n\t}\n\n\tvector<pair<int, int>> mexOfNode(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint curM; cin >> curM;\n\t\tmexOfNode[i] = { curM, i };\n\t}\n\n\tsort(mexOfNode.begin(), mexOfNode.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tres.push_back(mexOfNode[i].second);\n\t}\n\n\tbool b = g.check(mexOfNode);\n\tif (b) {\n\t\tfor (auto &x : res) { cout << x + 1 << ' '; }\n\t\tcout << '\\n';\n\t}\n\telse {\n\t\tcout << -1 << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Johnny and Contribution.json",
    "editorial_link": "https://codeforces.com//blog/entry/78355",
    "editorial": "We can view blogs as a graph, references as edges, and topics as colors. Now we can reformulate our problem as finding a permutation of vertices such that given in the statement greedy coloring algorithm returns coloring as described in the input.\n\nLet us start with two observations:\n\nObservation 1: If there is an edge between vertices with the same color, then the answer is ?1\n.\n\nObservation 2: If for a vertex u\n with color c\n there exist a color c?<c\n such that u\n has no edge to any vertex with color c?\n then the answer is ?1\n.\n\nBoth observations are rather straightforward to prove, so we skip it. Let us create permutation where vertices are sorted firstly by desired color and secondly by indices. We claim that if there exists any ordering fulfilling given regulations, then this permutation fulfills these too. Let us prove it:\n\nLet us analyze vertex u\n with color c\n. From observation 2\n we know that for each color c?<c\n there exist v\n with color c?\n such that u\n and v\n are connected by an edge. Because vertices are sorted by colors in our permutation, v\n is before u\n in ordering. So the greedy algorithm will assign that vertex color k?c\n. From observation 1\n, we now that u\n does not have an edge to vertex with color c\n, so the greedy algorithm has to assign to u\n color k?c\n. Combining both inequalities, we reach that greedy must assign color k=c\n, which completes our proof.\n\nSo now the algorithm is rather straightforward  sort vertices by colors, check if that ordering fulfills given regulations, if so, then write it down, otherwise print ?1\n. This can be implemented in O(nlogn)\n or O(n)\n.",
    "hint": []
}