{"link": "https://codeforces.com//contest/1362/problem/D", "problemId": "640965", "problem_idx": "D", "shortId": "1362D", "contest_number": "1362", "problem_submissions": {"E": [82533242, 82534444, 82537740, 82514250, 82533930, 82533069, 82537596, 82539990, 82540242, 82538471, 82539682, 82530965, 82542614, 82539643, 82539283, 82546202, 82528337, 82546467], "D": [82510668, 82507788, 82509488, 82531898, 82514757, 82515389, 82522345, 82516278, 82518522, 82519426, 82519224, 82768835, 82595629, 82522253, 82524305, 82523832, 82521456, 82543796, 82520171], "C": [82499455, 82498958, 82501198, 82493857, 82499687, 82506922, 82499891, 82507219, 82505247, 82500067, 82504471, 82506074, 82507172, 82504835, 82510757, 82507288, 82510259], "B": [82495744, 82495722, 82497194, 82492324, 82495262, 82500116, 82495247, 82495676, 82498396, 82494894, 82501982, 82494238, 82501685, 82493927, 82498961, 82504636, 82504999], "A": [82492673, 82492696, 82492707, 82492807, 82492452, 82496773, 82492476, 82492710, 82493556, 82492430, 82494321, 82492417, 82493444, 82492319, 82493342, 82492942, 82498191], "F": [99790549, 99789950, 99789855, 99786615, 99786490, 99783918, 99783396, 99783108, 99779312, 99779011, 99778620, 99777308, 99776727, 99776430, 99776080, 99775979, 99775398, 99023034, 99020809, 99014011, 99012603, 82568961, 82562279, 82589807]}, "name": "D. Johnny and Contribution", "statement": "Today Johnny wants to increase his contribution. His plan assumes\r\nwriting n blogs. One blog covers one topic, but one topic can be covered\r\nby many blogs. Moreover, some blogs have references to each other. Each\r\npair of blogs that are connected by a reference has to cover different\r\ntopics because otherwise, the readers can notice that they are split\r\njust for more contribution. Set of blogs and bidirectional references\r\nbetween some pairs of them is called blogs network.There are n different\r\ntopics, numbered from 1 to n sorted by Johnny\u2019s knowledge. The structure\r\nof the blogs network is already prepared. Now Johnny has to write the\r\nblogs in some order. He is lazy, so each time before writing a blog, he\r\nlooks at it\u2019s already written neighbors (the blogs referenced to current\r\none) and chooses the topic with the smallest number which is not covered\r\nby neighbors. It\u2019s easy to see that this strategy will always allow him\r\nto choose a topic because there are at most n - 1 neighbors.For example,\r\nif already written neighbors of the current blog have topics number 1,\r\n3, 1, 5, and 2, Johnny will choose the topic number 4 for the current\r\nblog, because topics number 1, 2 and 3 are already covered by neighbors\r\nand topic number 4 isn\u2019t covered.As a good friend, you have done some\r\nresearch and predicted the best topic for each blog. Can you tell\r\nJohnny, in which order he has to write the blogs, so that his strategy\r\nproduces the topic assignment chosen by you?\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nvector<int> res;\n\nstruct edge {\n\tint u, v; edge() {}\n\tedge(int _u, int _v) :\n\t\tu(_u), v(_v) {}\n};\n\nstruct node { int mex = -1; vector<edge> edges; };\n\nstruct graph {\n\tvector<node> nodes;\n\tint n;\n\n\tgraph(int _n) : n(_n) { nodes.resize(n); }\n\n\tvoid add_edge(int u, int v) {\n\t\tedge e1(u, v); nodes[u].edges.push_back(e1);\n\t\tedge e2(v, u); nodes[v].edges.push_back(e2);\n\t}\n\n\tbool check(vector<pair<int, int>> &mexOfNode) {\n\t\tvector<bool> visited(n, 0);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cur = res[i];\n\n\t\t\tset<int> seen;\n\t\t\tfor (auto &e : nodes[cur].edges) {\n\t\t\t\tif (nodes[e.v].mex != -1) {\n\t\t\t\t\tseen.insert(nodes[e.v].mex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint curMex = 1;\n\t\t\twhile (seen.count(curMex)) { curMex++; }\n\n\t\t\tnodes[cur].mex = curMex;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (mexOfNode[i].first != nodes[mexOfNode[i].second].mex) { return false; }\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n, m; cin >> n >> m;\n\tgraph g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tg.add_edge(a, b);\n\t}\n\n\tvector<pair<int, int>> mexOfNode(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint curM; cin >> curM;\n\t\tmexOfNode[i] = { curM, i };\n\t}\n\n\tsort(mexOfNode.begin(), mexOfNode.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tres.push_back(mexOfNode[i].second);\n\t}\n\n\tbool b = g.check(mexOfNode);\n\tif (b) {\n\t\tfor (auto &x : res) { cout << x + 1 << ' '; }\n\t\tcout << '\\n';\n\t}\n\telse {\n\t\tcout << -1 << '\\n';\n\t}\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "greedy", "implementation", "sortings"], "dificulty": "1700", "interactive": false}