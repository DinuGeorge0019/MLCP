{"link": "https://codeforces.com//contest/1900/problem/C", "problemId": "2348160", "problem_idx": "C", "shortId": "1900C", "contest_number": "1900", "problem_submissions": {"E": [234456838, 234455027, 234457931, 234455766, 234456771, 234460502, 234461970, 234463093, 234461258, 234461626, 235437599, 234459471, 234465112, 234465941, 234463278, 234463477, 234464668, 234464310, 234465647, 234465136], "D": [234442999, 234445532, 234447119, 234444027, 234448662, 234449846, 234450821, 234448590, 234544232, 234544122, 234453539, 234456816, 234449461, 234446745, 234447346, 234455068, 234451202, 234455283, 234455174, 234452017, 234447175], "C": [234433856, 234437020, 234438208, 234438984, 234436746, 234440214, 234440440, 234440880, 234441500, 234437974, 234441984, 234439314, 234438351, 234441349, 234441838, 234441318, 234441667, 234442122, 234444120], "B": [234430889, 234432938, 234432800, 234433842, 234432820, 234435211, 234434789, 234436751, 234434039, 234432505, 234436824, 234433963, 234433725, 234434390, 234437612, 234436752, 234436425, 234432619, 234438330], "A": [234429140, 234429060, 234429292, 234429383, 234429959, 234434373, 234428876, 234431698, 234428932, 234429000, 234431129, 234431009, 234429251, 234429090, 234434493, 234430325, 234429412, 234429176, 234429387], "F": [234821914, 234821787]}, "name": "C. Anji s Binary Tree", "statement": "Keksic keeps getting left on seen by Anji. Through a mutual friend, he\u2019s\r\nfigured out that Anji really likes binary trees and decided to solve her\r\nproblem in order to get her attention.Anji has given Keksic a binary\r\ntree with n vertices. Vertex 1 is the root and does not have a parent.\r\nAll other vertices have exactly one parent. Each vertex can have up to 2\r\nchildren, a left child, and a right child. For each vertex, Anji tells\r\nKeksic index of both its left and its right child or tells him that they\r\ndo not exist. Additionally, each of the vertices has a letter s_i on it,\r\nwhich is either \u201d, \u201d or \u201d.Keksic begins his journey on the root, and in\r\neach move he does the following: If the letter on his current vertex is\r\n\u201d, he moves to its parent. If it doesn\u2019t exist, he does nothing. If the\r\nletter on his current vertex is \u201d, he moves to its left child. If it\r\ndoesn\u2019t exist, he does nothing. If the letter on his current vertex is\r\n\u201d, he moves to its right child. If it doesn\u2019t exist, he does nothing.\r\nBefore his journey, he can perform the following operations: choose any\r\nnode, and replace the letter written on it with another one. You are\r\ninterested in the minimal number of operations he needs to do before his\r\njourney, such that when he starts his journey, he will reach a leaf at\r\nsome point. A leaf is a vertex that has no children. It does not matter\r\nwhich leaf he reaches. Note that it does not matter whether he will stay\r\nin the leaf, he just needs to move to it. Additionally, note that it\r\ndoes not matter how many times he needs to move before reaching a\r\nleaf.Help Keksic solve Anji\u2019s tree so that he can win her heart, and\r\nmake her come to a ak.\r\n", "solutions": ["#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < '0' || c > '9') c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x;\n}\nint n, l[300005], r[300005], ans;\nchar s[300005];\nvoid dfs(int x, int now){\n\tif(l[x] == 0 && r[x] == 0) {\n\t\tans = std::min(ans, now);\n\t\treturn ;\n\t}\n\tif(s[x] != 'L' && l[x]) dfs(l[x], now + 1);\n\telse if(l[x]) dfs(l[x], now);\n\tif(s[x] != 'R' && r[x]) dfs(r[x], now + 1); \n\telse if(r[x]) dfs(r[x], now);\n\treturn ;\n}\nvoid solve(){\n\tscanf(\"%d%s\", &n, s + 1); ans = 1e9;\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d%d\", &l[i], &r[i]);\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(\"%d\", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "trees"], "dificulty": "1300", "interactive": false}