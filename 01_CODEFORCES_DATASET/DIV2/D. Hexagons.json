{
    "link": "https://codeforces.com//contest/1421/problem/D",
    "problemId": "763579",
    "problem_idx": "D",
    "shortId": "1421D",
    "contest_number": "1421",
    "problem_submissions": {
        "E": [
            95894390,
            95897364,
            95896435,
            95890539,
            95992885,
            96032464,
            95960888,
            95899400
        ],
        "D": [
            95871709,
            95861267,
            95879423,
            95894755,
            95871704,
            95872756,
            95872599,
            95874589,
            95875351,
            95876553,
            95875903,
            95874887,
            95874932,
            95876575,
            95875075,
            95872464,
            95875457,
            95901124,
            95900956,
            95877542
        ],
        "B": [
            95869646,
            95869234,
            95864293,
            95863175,
            95860152,
            95861589,
            95869345,
            95861607,
            95862906,
            95862340,
            95863307,
            95861094,
            95864173,
            95860695,
            95863889,
            95864493,
            95862062,
            95861398
        ],
        "C": [
            95868136,
            95871765,
            95866274,
            95868511,
            95867450,
            95867807,
            95865115,
            95865747,
            95867493,
            95867265,
            95868458,
            95867762,
            95869507,
            95869832,
            95870224,
            95865361,
            95865425,
            95869153
        ],
        "A": [
            95860954,
            95862603,
            95857167,
            95856436,
            95856303,
            95856722,
            95856474,
            95856404,
            95859234,
            95857052,
            95856721,
            95856373,
            95856800,
            95856207,
            95856312,
            95856260,
            95856810,
            95856671
        ]
    },
    "name": "D. Hexagons",
    "statement": "Consider a hexagonal tiling of the plane as on the picture below. Nicks\r\nwishes to go from the cell marked (0, 0) to a certain cell given by the\r\ncoordinates. She may go from a hexagon to any of its six neighbors you\r\nwant, but there is a cost associated with each of them. The costs depend\r\nonly on the direction in which you travel. Going from (0, 0) to (1, 1)\r\nwill take the exact same cost as going from (-2, -1) to (-1, 0). The\r\ncosts are given in the input in the order c_1, c_2, c_3, c_4, c_5, c_6\r\nas in the picture below. Print the smallest cost of a path from the\r\norigin which has coordinates (0, 0) to the given cell.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define INF 9223372036854000000LL\n\nint main() {\n\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n\t\n\tint Tc;\n\tfor (cin >> Tc; Tc--; ) {\n\t\tint x, y;\n\t\tlong long c1, c2, c3, c4, c5, c6;\n\t\tcin >> x >> y;\n\t\tcin >> c1 >> c2 >> c3 >> c4 >> c5 >> c6;\n\t\tlong long rlt = INF, ans;\n\t\tif (x >= 0) {\n\t\t\tans = c6 * x + ((y >= 0) ? c2 * y : c5 * -y);\n\t\t\trlt = min(rlt, ans);\n\t\t\tans = c1 * x + ((y >= x) ? c2 * (y - x) : c5 * (x - y));\n\t\t\trlt = min(rlt, ans);\n\t\t}\n\t\telse {\n\t\t\tans = c3 * -x + ((y >= 0) ? c2 * y : c5 * -y);\n\t\t\trlt = min(rlt, ans);\n\t\t\tans = c4 * -x + ((y >= x) ? c2 * (y - x) : c5 * (x - y));\n\t\t\trlt = min(rlt, ans);\n\t\t}\n\t\tif (y >= 0) {\n\t\t\tans = c2 * y + ((x >= 0) ? c6 * x : c3 * -x);\n\t\t\trlt = min(rlt, ans);\n\t\t\tans = c1 * y + ((x >= y) ? c6 * (x - y) : c3 * (y - x));\n\t\t\trlt = min(rlt, ans);\n\t\t}\n\t\telse {\n\t\t\tans = c5 * -y + ((x >= 0) ? c6 * x : c3 * -x);\n\t\t\trlt = min(rlt, ans);\n\t\t\tans = c4 * -y + ((x >= y) ? c6 * (x - y) : c3 * (y - x));\n\t\t\trlt = min(rlt, ans);\n\t\t}\n\t\tcout << rlt << endl;\n\t}\n\t\n\treturn 0;\n\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Hexagons.json",
    "editorial_link": "https://codeforces.com//blog/entry/83761",
    "editorial": "Indeed two edges are required in the solution, so one approach\nwould be picking all combinations of edges and do linear algebra so see\nhow many times each is required (or if it\u00e2\u0080\u0099s impossible).To prove that\nlet\u00e2\u0080\u0099s suppose our target is somewhere reachable by only taking and (the\nupper right sextant, a sixth division of the plane). and will never be\nused since they contribute in the wrong direction. We can now use , , or\nfor our solution. If using and is not optimal we can choose or , without\nloss of generality we choose . cannot be used because it simply counters\n. Now we either use , or , but we can further narrow down to just two\nedges. If we use all three this means we use + which goes the same way\nas , and also goes the same way as + . So we can just not use if + < ,\nor use instead of + until either of or doesn\u00e2\u0080\u0099t appear anymore on our\nsolution.\n"
}