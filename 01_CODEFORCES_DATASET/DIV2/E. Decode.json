{
    "link": "https://codeforces.com//contest/1996/problem/E",
    "problemId": "2778592",
    "problem_idx": "E",
    "shortId": "1996E",
    "contest_number": "1996",
    "problem_submissions": {
        "G": [
            272815559,
            272903634,
            272903592,
            272903418,
            272850378,
            272829160,
            272846769,
            272917148,
            272843968,
            272801966,
            272891447,
            273051360,
            273051300,
            272852709,
            277596550
        ],
        "F": [
            272784299,
            272793161,
            272807689,
            272809360,
            272830969,
            272798046,
            272797379,
            272844703,
            272806635,
            272800919,
            272804361,
            272807242,
            272813027,
            272855036,
            272810332,
            272821433,
            272800404,
            272820587,
            272829162,
            272821599,
            272807664,
            272816226,
            272826644
        ],
        "E": [
            272768761,
            272775513,
            272762810,
            272775844,
            272823416,
            272782075,
            272761261,
            272777167,
            272789153,
            272785690,
            272777083,
            272786909,
            272772099,
            272795998,
            272776949,
            272765827,
            272779861,
            272789445,
            272789546,
            272778665
        ],
        "D": [
            272761438,
            272765354,
            272813661,
            272767517,
            272818911,
            272771177,
            272779573,
            272778986,
            272764786,
            272769566,
            272775352,
            272769622,
            272774700,
            272762959,
            272779115,
            272762141,
            272771898,
            272773685,
            272774147,
            272768381,
            272757964
        ],
        "C": [
            272749300,
            272751224,
            272747619,
            272760085,
            272816579,
            272747209,
            272749428,
            272754671,
            272751382,
            272753279,
            272756574,
            272752694,
            272753758,
            272752271,
            272750229,
            272749232,
            272748871,
            272759739,
            272751545,
            272745700
        ],
        "B": [
            272737073,
            272739985,
            272740771,
            272742756,
            272810526,
            272736341,
            272731072,
            272746867,
            272739153,
            272741965,
            272746544,
            272740783,
            272737062,
            272739328,
            272737959,
            272736354,
            272736698,
            272749397,
            272742081,
            272738867
        ],
        "A": [
            272724627,
            272725221,
            272724958,
            272806237,
            272724506,
            272723181,
            272724288,
            272724605,
            272723501,
            272737370,
            272725890,
            272725751,
            272728152,
            272725138,
            272723459,
            272724250,
            272723672,
            272729720,
            272726721
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131528",
    "editorial": "How can we efficiently check if a range contains the same amount of zeroes and ones? Let's create an array a\n where ai=?1\n if si=0\n and ai=1\n if si=1\n. Let's denote p\n as the prefix sum array of a\n. We want the contribution of ?1\n by the zeroes to cancel out with the ones, so if pr?pl?1=0\n, then the range [l,r]\n contain equal amounts of zeroes and ones. We can rephrase the problem as the following: for each subrange [l,r]\n, count the number of pairs (x,y)\n such that px?1=py\n.\n\nLet's fix px?1\n and keep track of all potential y\n such that y>x\n and px?1=py\n. How many subarrays will cover [x,y]\n? Well, we have x+1\n options as l\n and n?y+1\n options as r\n, so the range [x,y]\n contributes to (x+1)?(n?y+1)\n subarrays. We just need to calculate this expression for all potential y\n now. Let's denote the all possible y\n as y1,y2,...yk\n. We are asked to find the sum of (x+1)?(n?y1+1)+(x+1)?(n?y2+1)+?+(x+1)?(n?yk+1)\n. Let's factor (x+1)\n out, and we have (x+1)?((n?y1+1)+(n?y2+1)+?+(n?yk+1))\n. Since, the second part of the expression is just the sum of all (n?yi+1)\n, we can first precalculate that sum and since y>x\n, subtract as we sweep from left to right.",
    "name": "E. Decode",
    "statement": "You are given a binary string s of length n. For each pair of integers\r\n(l, r) (1\r\nleq l\r\nleq r\r\nleq n), count the number of pairs (x, y) (l\r\nleq x\r\nleq y\r\nleq r) such that the amount of\r\nmathtt{0} equals the amount of\r\nmathtt{1} in the substring s_xs_{x+1}...s_y. Output the sum of counts\r\nover all possible (l, r) modulo 10^9+7.\r\n",
    "solutions": [
        "/**   - dwuy -\u00a0\u3000\u3000\u3000\u3000\u3000 \uff0f\uff1e\u3000   \u30d5\u3000\u3000\u3000\u3000\u3000 | \u3000_\u3000 _|\u3000 \u3000\u3000\u3000 \uff0f`\u30df _x \u30ce\u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\u3000\u3000\u3000 /\u3000  \u30fd\u3000\u3000 ?\u3000\uff0f\uffe3|\u3000\u3000 |\u3000|\u3000|\u3000| (\uffe3\u30fd\uff3f_\u30fd_)_)\u3000\uff3c\u4e8c\u3064\u00a0**/#include <bits/stdc++.h>\u00a0#define fastIO ios_base::sync_with_stdio(false); cin.tie(NULL)#define file(a) freopen(a\".inp\",\"r\",stdin); freopen(a\".out\", \"w\",stdout)#define fi first#define se second#define endl \"\\n\"#define len(s) (int)((s).size())#define MASK(k)(1LL<<(k))#define TASK \"test\"#define int long long\u00a0using namespace std;\u00a0typedef tuple<int, int, int> tpiii;typedef pair<double, double> pdd;typedef pair<int, int> pii;typedef long long ll;\u00a0const long long OO = 1e18;const int MOD = 1e9 + 7;const int INF = 1e9;const int MX = 300005;\u00a0int n, m, k, q;string s, t;int a[MX];int b[MX];\u00a0void solve(){    cin >> s;    n = len(s);    s = ' ' + s;    map<int, int> mp;    mp[0] = 1;    int sum = 0;    int ans = 0;    for(int i=1; i<=n; i++){        sum += s[i] == '0'? 1 : -1;        ans = (ans + (n - i + 1)*mp[sum])%MOD;         mp[sum] = (mp[sum] + i + 1)%MOD;    }    cout << ans << endl;}\u00a0int32_t main(){    fastIO;    //file(TASK);\u00a0    int q;    cin >> q;    while(q--){        solve();    }\u00a0    return 0;}\u00a0\u00a0\u00a0\u00a0"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Decode.json"
}