{
    "link": "https://codeforces.com//contest/807/problem/D",
    "problemId": "105604",
    "problem_idx": "D",
    "shortId": "807D",
    "contest_number": "807",
    "problem_submissions": {
        "C": [
            26937367,
            26932679,
            26931824,
            26933954,
            26935002,
            26945243,
            26934673,
            26931916,
            26932051,
            26931857,
            26932221,
            26934137,
            26931106,
            26934955,
            26948034,
            26933750,
            26931179,
            26933734
        ],
        "E": [
            26937218,
            26941715,
            26942118,
            26943819,
            26944219,
            26940388,
            26942912,
            26974189,
            26945366,
            26938570,
            26939988,
            26940095
        ],
        "D": [
            26933616,
            26938470,
            26937308,
            26935937,
            26940795,
            26937188,
            26938367,
            26934356,
            26935620,
            26933949,
            26944682,
            26939881,
            26963824,
            26941895,
            26936251,
            26938625,
            26938681
        ],
        "B": [
            26929187,
            26930221,
            26930051,
            26930975,
            26931611,
            26930997,
            26945828,
            26929713,
            26931410,
            26929634,
            26929851,
            26931739,
            26929439,
            26931155,
            26930623,
            26932660,
            26928773,
            26928963
        ],
        "A": [
            26926738,
            26928269,
            26927513,
            26927911,
            81453119,
            81452755,
            26927099,
            26927720,
            26926862,
            26927495,
            26936234,
            26928013,
            26926637,
            26926993,
            26927122,
            26929273,
            26927007,
            26927862,
            26926641,
            26926659
        ],
        "F": [
            27349164
        ]
    },
    "name": "D. Dynamic Problem Scoring",
    "statement": "Vasya and Petya take part in a Codeforces round. The round lasts for two\r\nhours and contains five problems.For this round the dynamic problem\r\nscoring is used. If you were lucky not to participate in any Codeforces\r\nround with dynamic problem scoring, here is what it means. The maximum\r\npoint value of the problem depends on the ratio of the number of\r\nparticipants who solved the problem to the total number of round\r\nparticipants. Everyone who made at least one submission is considered to\r\nbe participating in the round.Pay attention to the range bounds. For\r\nexample, if 40 people are taking part in the round, and 10 of them solve\r\na particular problem, then the solvers fraction is equal to , and the\r\nproblem\u2019s maximum point value is equal to 1500.If the problem\u2019s maximum\r\npoint value is equal to , then for each whole minute passed from the\r\nbeginning of the contest to the moment of the participant\u2019s correct\r\nsubmission, the participant loses points. For example, if the problem\u2019s\r\nmaximum point value is 2000, and the participant submits a correct\r\nsolution to it 40 minutes into the round, this participant will be\r\nawarded with points for this problem.There are participants in the\r\nround, including Vasya and Petya. For each participant and each problem,\r\nthe number of minutes which passed between the beginning of the contest\r\nand the submission of this participant to this problem is known. It\u2019s\r\nalso possible that this participant made no submissions to this\r\nproblem.With two seconds until the end of the round, all participants\u2019\r\nsubmissions have passed pretests, and not a single hack attempt has been\r\nmade. Vasya believes that no more submissions or hack attempts will be\r\nmade in the remaining two seconds, and every submission will pass the\r\nsystem testing.Unfortunately, Vasya is a cheater. He has registered new\r\naccounts for the round. Now Vasya can submit any of his solutions from\r\nthese new accounts in order to change the maximum point values of the\r\nproblems. Vasya can also submit any wrong solutions to any problems.\r\nNote that Vasya can not submit correct solutions to the problems he\r\nhasn\u2019t solved.Vasya seeks to score strictly more points than Petya in\r\nthe current round. Vasya has already prepared the scripts which allow to\r\nobfuscate his solutions and submit them into the system from any of the\r\nnew accounts in just fractions of seconds. However, Vasya doesn\u2019t want\r\nto make his cheating too obvious, so he wants to achieve his goal while\r\nmaking submissions from the smallest possible number of new\r\naccounts.Find the smallest number of new accounts Vasya needs in order\r\nto beat Petya (provided that Vasya\u2019s assumptions are correct), or report\r\nthat Vasya can\u2019t achieve his goal.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define INF 1000000007LL\n\nint n;\nint times[128][5];\n\nint score(long long a, long long b) {\n    if(a*2 > b) {\n        return 500;\n    } else if(a*4 > b) {\n        return 1000;\n    } else if(a*8 > b) {\n        return 1500;\n    } else if(a*16 > b) {\n        return 2000;\n    } else if(a*32 > b) {\n        return 2500;\n    } else {\n        return 3000;\n    }\n}\n\nbool wins(long long t) {\n    vector<int> vec(5);\n    for(int i=0;i<5;i++) {\n        if(times[0][i] == -1) {\n            vec[i] = 0;\n        } else if (times[1][i] == -1 || (times[1][i] != -1 && times[1][i] > times[0][i])) {\n            vec[i] = -1;\n        } else {\n            vec[i] = 1;\n        }\n    }\n    int score0 = 0, score1 = 0;\n    for(int i=0;i<5;i++) {\n        long long a = 0, b = 0;\n        for(int j=0;j<n;j++) {\n            if(times[j][i] != -1) {\n                a++;\n            }\n        }\n        if(vec[i] == 1) {\n            a += t;\n        }\n        b = t+n;\n        if(times[0][i] != -1) {\n            score0 += score(a,b) * (250 - times[0][i]);\n        }\n        if(times[1][i] != -1) {\n            score1 += score(a,b) * (250 - times[1][i]);\n        }\n    }\n    return score0 > score1;\n}\n\nint main() {\n    cin >> n;\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<5;j++) {\n            cin >> times[i][j];\n        }\n    }\n    for(int i=0;i<50000;i++) {\n        if(wins(i)) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    cout << -1 << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Dynamic Problem Scoring.json",
    "editorial_link": "https://codeforces.com/blog/entry/51883",
    "editorial": "Dynamic problem scoring used to be used more often in Codeforces rounds, including some tournament rounds like VK Cup 2015 Finals.\n\nOnce you read the problem statement carefully, the problem itself isn't overly difficult.\n\nConsider new accounts Vasya puts into play. Correct solutions to which problems does he submit from these new accounts?\n\nIf Vasya hasn't solved a problem, he can't submit correct solutions to it.\nIf Vasya has solved a problem which Petya hasn't solved, then clearly Vasya wants the maximum point value of this problem to be as high as possible, thus it doesn't make sense to submit its solution from the new accounts.\nSuppose Vasya solved the problem at minute v, Petya solved it at minute p and the problem's maximum point value is m, then Vasya's and Petya's scores for this problem are m\u00b7(1?-?v?/?250) and m\u00b7(1?-?p?/?250), respectively. Let's denote the difference between these values by d?=?m\u00b7(p?-?v)?/?250. Vasya wants to maximize this value.\nIf p?-?v is positive (that is, Vasya solved the problem faster than Petya), then d is maximized when m is maximized. To maximize m, Vasya shouldn't submit correct solutions to this problem from the new accounts.\nOn the other hand, if p?-?v is negative (that is, Petya solved the problem faster than Vasya), then d is maximized when m is minimized. To minimize m, Vasya should submit correct solutions to this problem from the new accounts.\nFinally, if p?-?v is zero (that is, Petya and Vasya solved the problem at the same moment), then d?=?0 for any value of m, so it doesn't matter if Vasya submits correct solutions to this problem or not.\nIt follows from the above that Vasya should always do the same for all new accounts he puts into play.\n\nLet's iterate over x \u0097 the number of new accounts Vasya puts into play, starting from 0. Then we can determine what solutions Vasya should submit from these accounts using the reasoning above. Then we can calculate the maximum point values of the problems, and then the number of points Vasya and Petya will score. If Vasya's score is higher than Petya's score, then the answer is x, otherwise we increase x by one and continue.\n\nWhen do we stop? If Vasya submits solutions to a problem from the new accounts, then after putting at least n accounts into play the maximum point value of this problem will reach 500 and won't change anymore. If Vasya doesn't, then after putting at least 31n accounts into play the maximum point value of this problem will reach 3000 and won't change anymore. Therefore, if x exceeds 31n, we can stop and output -1.\n\nNote that we can't find the value of x using binary search due to the fact that Vasya can't submit solutions to the problems he hasn't solved. That is, more accounts do not mean more profit. For example, consider the following test case:"
}