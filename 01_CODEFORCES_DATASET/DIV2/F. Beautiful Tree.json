{
    "link": "https://codeforces.com//contest/1904/problem/F",
    "problemId": "2374326",
    "problem_idx": "F",
    "shortId": "1904F",
    "contest_number": "1904",
    "problem_submissions": {
        "F": [
            236570080,
            236576621,
            236554431,
            236568040,
            236582005,
            236574981,
            236880626,
            236880480,
            236569573
        ],
        "E": [
            236554914,
            236578860,
            236576444,
            236573774,
            238458664,
            236560297,
            236558822,
            236558918,
            236569149,
            236563127,
            236567711,
            236569198,
            236566626,
            236565306,
            236568569,
            236566882,
            236569261,
            236579274,
            236552305,
            236552808,
            236798985
        ],
        "D1": [
            236545065,
            236536170,
            236543035,
            236535328,
            236546645,
            236545333,
            236534429,
            236543154,
            236535118,
            236545269,
            236548952,
            236561907,
            236552142,
            236547668,
            236547285,
            236579190,
            236560952,
            236535340,
            236566707
        ],
        "D2": [
            236544975,
            236536268,
            236547976,
            236535232,
            236546707,
            236545240,
            236539045,
            236543101,
            236535019,
            236550494,
            236549022,
            236539644,
            236552226,
            236551334,
            236547141,
            236579204,
            236562744,
            236535269,
            236566631
        ],
        "C": [
            236537578,
            236532163,
            236538305,
            236529701,
            236530813,
            236537981,
            236531278,
            236536485,
            236540998,
            236534952,
            236537201,
            236530975,
            236533757,
            236539773,
            236559221,
            236579140,
            236529162,
            236713604,
            236530644
        ],
        "B": [
            236533750,
            236526956,
            236527715,
            236527401,
            236528167,
            236531303,
            236527554,
            236530718,
            236528605,
            236528181,
            236531779,
            236528715,
            236530882,
            236530328,
            236531954,
            236579315,
            236527688,
            236526407,
            236558484,
            236528501
        ],
        "A": [
            236526415,
            236525678,
            236525809,
            236525816,
            236525646,
            236527341,
            236525550,
            236527627,
            236527718,
            236525848,
            236525742,
            236526468,
            236525731,
            236528067,
            236527808,
            236579299,
            236525701,
            236525590,
            236554437,
            236526433
        ]
    },
    "name": "F. Beautiful Tree",
    "statement": "Lunchbox has a tree of size n rooted at node 1. Each node is then\r\nassigned a value. Lunchbox considers the tree to be beautiful if each\r\nvalue is distinct and ranges from 1 to n. In addition, a beautiful tree\r\nmust also satisfy m requirements of 2 types: \"\" The node with the\r\nsmallest value on the path between nodes a and b must be located at c.\r\n\"\" The node with the largest value on the path between nodes a and b\r\nmust be located at c. Now, you must assign values to each node such that\r\nthe resulting tree is beautiful. If it is impossible to do so, output\r\n-1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e6 + 5;\nconst int M = 3e7 + 5;\nint n, m, op[N], A[N], B[N], C[N];\nvector<int> tr[N];\n\nint dep[N], fa[N], sz[N], son[N];\n\nvoid dfs1(int u, int pre) {\n\tdep[u] = dep[pre] + 1, fa[u] = pre, sz[u] = 1;\n\tfor (int v : tr[u]) {\n\t\tif (v == pre) continue;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t\tif (sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\n\nint st[N], ed[N], id[N], top[N], cnt;\n\nvoid dfs2(int u, int tp) {\n\tst[u] = ++cnt, id[cnt] = u, top[u] = tp;\n\tif (son[u]) dfs2(son[u], tp);\n\tfor (int v : tr[u])\n\t\tif (v != fa[u] && v != son[u])\n\t\t\tdfs2(v, v);\n\ted[u] = cnt;\n}\n\nstruct Edge {\n\tint to, next;\n} e[M];\n\nint head[N], deg[N], cnte;\n\ninline void addedge(int u, int v) {\n\te[++cnte] = Edge{v, head[u]}, head[u] = cnte;\n\t++deg[v];\n}\n\nint prf_in[N], prf_out[N], tot;\n\n#define ls(x) (x << 1)\n#define rs(x) (x << 1 | 1)\n\nint ver_in[N], ver_out[N];\n\nvoid build(int x = 1, int l = 1, int r = n) {\n\tif (l == r) {\n\t\tver_in[x] = ver_out[x] = id[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(x), l, mid);\n\tbuild(rs(x), mid + 1, r);\n\tver_in[x] = ++tot, ver_out[x] = ++tot;\n\taddedge(ver_in[x], ver_in[ls(x)]);\n\taddedge(ver_in[x], ver_in[rs(x)]);\n\taddedge(ver_out[ls(x)], ver_out[x]);\n\taddedge(ver_out[rs(x)], ver_out[x]);\n}\n\nvoid addin(int L, int R, int s, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(s, ver_in[x]);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addin(L, R, s, ls(x), l, mid);\n\tif (R > mid) addin(L, R, s, rs(x), mid + 1, r);\n}\n\nvoid addout(int L, int R, int t, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(ver_out[x], t);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addout(L, R, t, ls(x), l, mid);\n\tif (R > mid) addout(L, R, t, rs(x), mid + 1, r);\n}\n\nint q[N], ans[N];\n\ninline void toposort() {\n\tint l = 1, r = 0, res = 0;\n\tfor (int i = 1; i <= tot; ++i)\n\t\tif (!deg[i]) q[++r] = i;\n\twhile (l <= r) {\n\t\tint u = q[l++];\n\t\tif (u <= n) ans[u] = ++res;\n\t\tfor (int i = head[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\t--deg[v];\n\t\t\tif (!deg[v]) q[++r] = v;\n\t\t}\n\t}\n\tif (r < tot) {\n\t\tcout << \"-1\\n\";\n\t} else {\n\t\tfor (int i = 1; i <= n; ++i) cout << ans[i] << ' ';\n\t\tcout << '\\n';\n\t}\n}\n\ninline void treeaddanc(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\telse addedge(prf_out[x], v);\n\t\tx = fa[top[x]];\n\t}\n\tif (y == x) return;\n\tif (op == 1) addin(st[y] + 1, st[x], v);\n\telse addout(st[y] + 1, st[x], v);\n}\n\ninline void treeadd(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] >= dep[top[y]]) {\n\t\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\t\telse addedge(prf_out[x], v);\n\t\t\tx = fa[top[x]];\n\t\t} else {\n\t\t\tif (op == 1) addedge(v, prf_in[y]);\n\t\t\telse addedge(prf_out[y], v);\n\t\t\ty = fa[top[y]];\n\t\t}\n\t}\n\tif (dep[x] < dep[y]) {\n\t\tif (op == 1) addin(st[x], st[y], v);\n\t\telse addout(st[x], st[y], v);\n\t} else {\n\t\tif (op == 1) addin(st[y], st[x], v);\n\t\telse addout(st[y], st[x], v);\n\t}\n} \n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= m; ++i) cin >> op[i] >> A[i] >> B[i] >> C[i];\n\tdfs1(1, 0);\n\tdfs2(1, 1);\n\ttot = n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tprf_in[i] = ++tot;\n\t\tprf_out[i] = ++tot;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\taddedge(prf_in[i], i);\n\t\taddedge(i, prf_out[i]);\n\t\tif (i != top[i]) {\n\t\t\taddedge(prf_in[i], prf_in[fa[i]]);\n\t\t\taddedge(prf_out[fa[i]], prf_out[i]);\n\t\t}\n\t}\n\tbuild();\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (A[i] == B[i]) continue;\n\t\tif (A[i] != C[i]) {\n\t\t\tif (st[A[i]] >= st[C[i]] && ed[A[i]] <= ed[C[i]]) treeaddanc(A[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], A[i], op[i], C[i]);\n\t\t}\n\t\tif (B[i] != C[i]) {\n\t\t\tif (st[B[i]] >= st[C[i]] && ed[B[i]] <= ed[C[i]]) treeaddanc(B[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], B[i], op[i], C[i]);\n\t\t}\n\t}\n\ttoposort();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Beautiful Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/123160",
    "editorial": "SolutionLets rewrite the condition that node must be smaller than node\r\nas a directed edge from to . Then, we can assign each node a value based\r\non the topological sort of this new directed graph. If this directed\r\ngraph had a cycle, it is clear that there is no way to order the nodes.\r\nWith this in mind, we can try to construct a graph that would have these\r\nproperties. Once we have the graph, we can topological sort to find the\r\nanswer. For now, let\u00e2\u0080\u0099s consider the problem if it only had type 1\r\nrequirements (type 2 requirements can be done very similarly). Thus, the\r\nproblem reduces to \"given a path and a node, add a directed edge from\r\nthe node to every node in that path.\" To do this, we can use binary\r\nlifting. For each node, create dummy nodes, the th of which represents\r\nthe minimum number from the path between node and the th parent of .\r\nNow, we can draw a directed edge from the the th dummy node of to the th\r\ndummy node of and the th dummy node of the th parent of . Now, to add an\r\nedge from any node to a vertical path of the tree, we can repeatedly add\r\nan edge from that node to the largest node we can. This will add edges\r\nper requirement. The final complexity is time and .\r\n"
}