{
    "link": "https://codeforces.com//contest/1262/problem/E",
    "problemId": "479742",
    "problem_idx": "E",
    "shortId": "1262E",
    "contest_number": "1262",
    "problem_submissions": {
        "F1": [
            65643346,
            65653823,
            65643705,
            65644730,
            65690605,
            65651588,
            65651277,
            66034817,
            65646761,
            65654524,
            65651505,
            65653937,
            65645081,
            65645973,
            65647100,
            65654475,
            65687063,
            65647622,
            65647339,
            65645959
        ],
        "F2": [
            65643279,
            65653692,
            65828965,
            65686253,
            65649254,
            65653062,
            65651757,
            71816951,
            71815917,
            71815485,
            71815448,
            71815068,
            71814941,
            71814802,
            65654320,
            65687047,
            65652597,
            65652697,
            65651173
        ],
        "E": [
            65639530,
            65645042,
            65648892,
            65652057,
            65690596,
            65647275,
            65647634,
            65653097,
            65651461,
            65648284,
            65647900,
            97249054,
            97246746,
            65648360,
            65650087,
            65951237,
            65651779
        ],
        "D1": [
            65634593,
            65638676,
            65638313,
            65637479,
            65640274,
            65640849,
            65636529,
            65639533,
            65642238,
            65648533,
            65640691,
            65638549,
            65642536,
            65639709,
            65635698,
            65639724,
            65643528,
            65642432,
            65642224,
            65638684
        ],
        "D2": [
            65634523,
            65638577,
            65638418,
            65637413,
            65640211,
            65640949,
            65642851,
            65639443,
            65642574,
            65642451,
            65640796,
            65638763,
            65642667,
            65639589,
            65635638,
            65639633,
            65643328,
            65643512,
            65642176,
            65638616
        ],
        "C": [
            65629762,
            65634294,
            65634237,
            65633719,
            65632321,
            65635540,
            65633375,
            65635292,
            65633541,
            65633864,
            65634698,
            65633061,
            65637189,
            65634072,
            65640938,
            65633298,
            65638202,
            65638218,
            65637587,
            65633967
        ],
        "B": [
            65627254,
            65629631,
            65628216,
            65627679,
            65628556,
            65630807,
            65628279,
            65630765,
            65628901,
            65628780,
            65629802,
            65628147,
            65626929,
            65628945,
            65629119,
            65627530,
            65632823,
            65631394,
            65633894,
            65629398
        ],
        "A": [
            65626237,
            65626820,
            65626466,
            65626311,
            65627028,
            65627733,
            65626343,
            65627142,
            65629675,
            65626752,
            65627572,
            65626402,
            65628146,
            65626239,
            65626787,
            65626257,
            65626896,
            65628642,
            65626213,
            65626672
        ]
    },
    "name": "E. Arson In Berland Forest",
    "statement": "The Berland Forest can be represented as an infinite cell plane. Every\r\ncell contains a tree. That is, contained before the recent events.A\r\ndestructive fire raged through the Forest, and several trees were\r\ndamaged by it. Precisely speaking, you have a n\r\ntimes m rectangle map which represents the damaged part of the Forest.\r\nThe damaged trees were marked as \"\" while the remaining ones were marked\r\nas \"\". The firemen quickly extinguished the fire, and now they are\r\ninvestigating the cause of it. The main version is that there was an\r\narson: at some moment of time (let’s consider it as 0) some trees were\r\nset on fire. At the beginning of minute 0, only the trees that were set\r\non fire initially were burning. At the end of each minute, the fire\r\nspread from every burning tree to each of 8 neighboring trees. At the\r\nbeginning of minute T, the fire was extinguished.The firemen want to\r\nfind the arsonists as quickly as possible. The problem is, they know\r\nneither the value of T (how long the fire has been raging) nor the\r\ncoordinates of the trees that were initially set on fire. They want you\r\nto find the maximum value of T (to know how far could the arsonists\r\nescape) and a possible set of trees that could be initially set on\r\nfire.Note that you’d like to maximize value T but the set of trees can\r\nbe arbitrary.\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nvector<string> a;\nvector<vector<int> > pref;\nvector<vector<int> > best;\nvector<vector<int> > cur;\n\nint get(int x1, int y1, int x2, int y2) {\n    return pref[x2 + 1][y2 + 1] - pref[x2 + 1][y1] - pref[x1][y2 + 1] + pref[x1][y1];\n}\n\nvoid add(int x1, int y1, int x2, int y2) {\n    cur[x1][y1]++;\n    cur[x1][y2 + 1]--;\n    cur[x2 + 1][y1]--;\n    cur[x2 + 1][y2 + 1]++;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n, m;\n    cin >> n >> m;\n    a.resize(n);\n    rep(i, 0, n) {\n        string s;\n        cin >> s;\n        a[i] = s;\n    }\n    pref.resize(n + 1, vector<int> (m + 1, 0));\n    rep(i, 0, n) {\n        rep(j, 0, m) {\n            if (a[i][j] == 'X') {\n                pref[i + 1][j + 1]++;\n            }\n        }\n    }\n    rep(i, 0, n + 1) {\n        rep(j, 1, m + 1) {\n            pref[i][j] += pref[i][j - 1];\n        }\n    }\n    rep(j, 0, m + 1) {\n        rep(i, 1, n + 1) {\n            pref[i][j] += pref[i - 1][j];\n        }\n    }\n    best.resize(n, vector<int> (m, 0));\n    rep(i, 0, n) {\n        rep(j, 0, m) {\n            if (a[i][j] != 'X') {\n                best[i][j] = -1;\n                continue;\n            }\n            int d = min(min(i, n - i - 1), min(j, m - j - 1));\n            int l = 0, r = d + 1, mid;\n            while (r - l > 1) {\n                mid = (l + r) / 2;\n                int cnt = get(i - mid, j - mid, i + mid, j + mid);\n                int side = 1 + 2 * mid;\n                if (cnt == side * side) {\n                    l = mid;\n                } else {\n                    r = mid;\n                }\n            }\n            best[i][j] = l;\n        }\n    }\n    cur.resize(n + 1, vector<int> (m + 1, 0));\n    int L = 0, R = min(n, m), mid;\n    while (R - L > 1) {\n        mid = (L + R) / 2;\n        rep(i, 0, n + 1) {\n            fill(cur[i].begin(), cur[i].end(), 0);\n        }\n        rep(i, 0, n) {\n            rep(j, 0, m) {\n                if (best[i][j] >= mid) {\n                    add(i - mid, j - mid, i + mid, j + mid);\n                }\n            }\n        }\n        rep(i, 0, n + 1) {\n            rep(j, 1, m + 1) {\n                cur[i][j] += cur[i][j - 1];\n            }\n        }\n        rep(j, 0, m + 1) {\n            rep(i, 1, n + 1) {\n                cur[i][j] += cur[i - 1][j];\n            }\n        }\n        bool ok = true;\n        rep(i, 0, n) {\n            rep(j, 0, m) {\n                ok &= ((a[i][j] == 'X' && cur[i][j] > 0) | (a[i][j] != 'X' && cur[i][j] == 0));\n            }\n        }\n        ok ? L = mid : R = mid;\n    }\n    cout << L << \"\\n\";\n    rep(i, 0, n) {\n        rep(j, 0, m) {\n            if (best[i][j] >= L) {\n                cout << 'X';\n            } else {\n                cout << '.';\n            }\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Arson In Berland Forest.json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "Let's note that if there is a possible configuration in which the forest burnt T\n minutes then there is a configuration when the forest burnt T?1\n minutes. So we can binary search the answer.\n\nNow we need to check the existence of the configuration for a fixed time T\n. Let's find all trees that can be set on fire. There are two equivalent conditions for such trees: either the square of length 2T+1\n with a center in this cell contains only X-s or a distance between the current cell and any cell with \".\" (or border) is more or equal to T\n.\n\nWe can use any of the conditions. The first condition can be checked with prefix sums on 2D - we can precalculate them one time and use them to take a sum on a rectangle. The second condition can be checked by running bfs from all \".\"-s or borders (or from X-s which are neighboring to \".\"-s or to the borders) also one time before the binary search.\n\nThe second step is to check that it's possible to cover all burnt trees starting from all set-on-fire trees. We can check it either with \"add value on a rectangle\" (using prefix sums) since each set-on-fire tree will burn a (2T+1)×(2T+1)\n square with center in it. Or, alternatively, we can run bfs from set-on-fire trees.\n\nAnyways, both algorithms have O(nm)\n complexity. And, since all damaged trees are shown on the map, the answer can't be more than min(n,m)\n. So, the total complexity is O(nmlog(min(n,m)))\n.",
    "hint": []
}