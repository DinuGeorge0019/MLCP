{
    "link": "https://codeforces.com//contest/1894/problem/B",
    "problemId": "2312799",
    "problem_idx": "B",
    "shortId": "1894B",
    "contest_number": "1894",
    "problem_submissions": {
        "E": [
            231780542,
            231780764,
            231783721,
            231789834,
            231788705,
            231788269,
            231784914,
            231788986,
            231801971,
            231786358,
            231788036,
            231815440,
            231786637,
            231808858,
            231789692,
            231801877,
            231817632,
            231801951
        ],
        "D": [
            231763745,
            231766056,
            231762523,
            231754895,
            231759834,
            231769389,
            231770188,
            231758327,
            231760530,
            231775160,
            231770452,
            231759047,
            231773241,
            231762950,
            231774799,
            231763275,
            231763670,
            231771730
        ],
        "C": [
            231756298,
            231755831,
            231757004,
            231877074,
            231770559,
            231763470,
            231760236,
            231765769,
            231774024,
            231754920,
            231758557,
            231758057,
            231762243,
            231765459,
            231756919,
            231760340,
            231755946,
            231756421,
            231763397
        ],
        "A": [
            231751883,
            231747419,
            231747509,
            231747329,
            231751165,
            231747346,
            231747376,
            231747139,
            231747693,
            231747813,
            231746849,
            231749093,
            231749182,
            231746695,
            231748186,
            231747273,
            231747195,
            231746971
        ],
        "B": [
            231748751,
            231750138,
            231749611,
            231749322,
            231755477,
            231750451,
            231753159,
            231749369,
            231750440,
            231749706,
            231748963,
            231754750,
            231753097,
            231749553,
            231754197,
            231749717,
            231750764,
            231754291
        ]
    },
    "name": "B. Two Out of Three",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n. You need to find an array b_1, b_2,\r\nldots, b_n consisting of numbers 1, 2, 3 such that out of the following\r\nthree conditions are satisfied: There exist indices 1\r\nleq i, j\r\nleq n such that a_i = a_j, b_i = 1, b_j = 2. There exist indices 1\r\nleq i, j\r\nleq n such that a_i = a_j, b_i = 1, b_j = 3. There exist indices 1\r\nleq i, j\r\nleq n such that a_i = a_j, b_i = 2, b_j = 3.If such an array does not\r\nexist, you should report it.\r\n",
    "solutions": [
        "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint n, a[110];\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n\n    unordered_map<int, int> freq;\n    int can = 0;\n    for (int i = 1; i <= n; i++) {\n        if (++freq[a[i]] == 2) {\n            can++;\n        }\n    }\n\n    if (can < 2) {\n        cout << -1 << '\\n';\n        return;\n    }\n\n    int n12 = 0, n13 = 0;\n    for (auto [v, f] : freq) {\n        if (f >= 2) {\n            if (n12 == 0) { n12 = v; }\n            else { n13 = v; break; }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (a[i] == n12) {\n            cout << 2 << ' ';\n            n12 = 0;\n        } else if (a[i] == n13) {\n            cout << 3 << ' ';\n            n13 = 0;\n        } else {\n            cout << 1 << ' ';\n        }\n    }\n    cout << '\\n';\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Two Out of Three.json",
    "editorial_link": "https://codeforces.com//blog/entry/122074",
    "editorial": "By symmetry, it doesnât matter which two conditions are satisfied. Letâs\r\nassume itâs the conditions and . Then the elements with and the elements\r\nwith should not intersect. Therefore, it is sufficient to assign and to\r\nonly one element that is common with the elements of the form in order\r\nto satisfy the conditions and . And these elements must be distinct in\r\norder to not satisfy the condition . Thus, we obtain the necessary\r\ncondition for the existence of an answer: the array must have at least\r\ntwo elements that occur more than once. It is easy to see that this\r\ncondition is also sufficient by constructing an example: let be two\r\nnumbers that occur more than once in the array. Then we can assign to\r\none of the occurrences, to one of the occurrence, and assign to all\r\nother numbers, and this will be a suitable answer.\r\n",
    "hint": [
        "Hint 1 Everything is symmetrical, so you can fix beforehand any exact two conditions you are aimed to satisfy.",
        "Hint 2 You need to not satisfy rd condition, so it doesnt really make sense to color any elements that not used in satisfying conditions and in colors . And to satisfy conditions and one element is enough.",
        "Hint 1 How to rollback one operation? Is rollback uniquely determined?",
        "Hint 1.1 Of course it is.",
        "Hint 2 After performing operation always becomes a last element of array.",
        "Hint 1 Lower bound for answer:",
        "Hint 2 Upper bound for answer: , you can insert 's in decreasing order anywhere. When you can't achieve ?",
        "Hint 3 Solve for",
        "Hint 1 It makes sense to try to solve case first, to get general understanding of the problem, some observations will be usefull in full solution.",
        "Hint 1.1 What size can a multiset have?",
        "Hint 1.2 If , the answer to the problem is . Now we are left in the case of . So we can iterate over all sizes from to , for each of them find the minimum anti-beauty that can have a set of this size, and take the minimum of all this for the answer.",
        "Hint 2 For bigger you need to find a fast enough way to count minimal anti-beauty with fixed size, everything else remains the same.",
        "Hint 1 Solve the problem if for all .",
        "Hint 1.1 Simple greedy should work.",
        "Hint 2 Solve the problem if for all .",
        "Hint 3 Solve the problem if divides for all .",
        "Hint 4 You can treat remainder separately, as an individual shelf.",
        "Hint -1 What is the most obvious greedy you can do?",
        "Hint -2 What is the second most obvious greedy you can do?",
        "Hint -3 What is the third most obvious greedy you can do?",
        "Hint -4 It's probably correct at this point, just proof by AC!",
        "Hint 1 Cacti is a trap, don't think about it for now, it will help later.",
        "Hint 2 Well, you need to make some observations. Start with observations about determining edges weights, it seems reasonable because edge always have exactly adjacent vertices.",
        "Hint 3 Edge is good <=> Exactly one of the adjacent vertexes have a same weight as an edge.",
        "Hint 4 Direct edges, such that every edge goes from vertex with same weight as edge to another vertex. In this reality try to find easier equivalent condition for ``vertice is good``.",
        "Hint 5 Vertex is good <=> InDegree of vertex is an odd integer.",
        "Hint 6 Now you just have two separate problems: 1) Direct all edges, such that InDegree of each vertex is odd; 2) Color all vertexes in 3 colors such that any 2 adjacent vertexes have different color. Time to remember about cacti."
    ]
}