{"link": "https://codeforces.com//contest/374/problem/C", "problemId": "4192", "problem_idx": "C", "shortId": "374C", "contest_number": "374", "problem_submissions": {"A": [5465863, 5461833, 5466158, 5464911, 5466997, 5469706, 5473574, 5469853, 5468623, 5465633, 5469265, 5462265], "D": [5462696, 5467904, 5464786, 5464934, 5468604, 5465912, 5467230, 5466682, 5468095, 5465960, 5466161], "B": [5468995, 5469225, 5467607, 5470212, 5468275, 5468375, 5461857, 5462807, 5463190, 5462540, 5462778, 5463491, 5467629], "C": [5466406, 5463399, 5462344, 5464302, 5463648, 5464974, 5464693, 5465386, 5470035, 5465614, 5465245, 5466097, 5466366], "E": [5470049, 5469975]}, "name": "C. Inna and Dima", "statement": "Inna and Dima bought a table of size in the shop. Each cell of the table\r\ncontains a single letter: \"\", \"\", \"\", \"\".Inna loves Dima, so she wants\r\nto go through his name as many times as possible as she moves through\r\nthe table. For that, Inna acts as follows: initially, Inna chooses some\r\ncell of the table where letter \"\" is written; then Inna can move to some\r\nside-adjacent table cell that contains letter \"\"; then from this cell\r\nshe can go to one of the side-adjacent table cells that contains the\r\nwritten letter \"\"; then she can go to a side-adjacent cell that contains\r\nletter \"\". Then Inna assumes that she has gone through her sweetheart\u2019s\r\nname; Inna\u2019s next move can be going to one of the side-adjacent table\r\ncells that contains letter \"\" and then walk on through name DIMA in the\r\nsimilar manner. Inna never skips a letter. So, from the letter \"\" she\r\nalways goes to the letter \"\", from the letter \"\" she always goes the to\r\nletter \"\", from the letter \"\" she always goes to the letter \"\", and from\r\nthe letter \"\" she always goes to the letter \"\". Depending on the choice\r\nof the initial table cell, Inna can go through name DIMA either an\r\ninfinite number of times or some positive finite number of times or she\r\ncan\u2019t go through his name once. Help Inna find out what maximum number\r\nof times she can go through name DIMA.\r\n", "solutions": ["/** Micro Mezzo Macro Flation -- Overheated Economy ., Last Update: Feb. 12th 2013 **/ //{\n\n/** Header .. **/ //{\n#define LOCAL\n\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (int n____=(i=0,int(n));i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,int(b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,int(a));i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,int(n));i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=1,int(b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,int(a));i>=a____;--i)\n\n#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, nxt) for (int i=hd;i;i=nxt[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define fi first\n#define se second\n\n#define Rush for(int ____T=RD(); ____T--;)\n\n#define Display(A, n, m) {                      \\\n\tREP(i, n){\t\t                            \\\n        REP(j, m) cout << A[i][j] << \" \";       \\\n        cout << endl;\t\t\t\t            \\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#define Display_1(A, n, m) {\t\t\t\t    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m) cout << A[i][j] << \" \";     \\\n\t\tcout << endl;\t\t            \t\t\\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define Ruby system(\"ruby main.rb\")\n#define Haskell system(\"runghc main.hs\")\n#define Python system(\"python main.py\")\n#define Pascal system(\"fpc main.pas\")\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &x){\n    char c; for (c = getchar(); c < '-'; c = getchar());\n    if (c == '-'){x = '0' - getchar(); for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + '0' - c;}\n    else {x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';}\n    return x;\n}\n\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline void RDD(const T0&a, const T1&b){RDD(a),RDD(b);}\ntemplate<class T0,class T1,class T2>inline void RDD(const T0&a, const T1&b, const T2&c){RDD(a),RDD(b),RDD(c);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& UNQ(T &A){A.resize(unique(ALL(SRT(A)))-A.begin());return A;}\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\n\nconst int dx8[] = {-1, 0, 1, 0 , -1 , -1 , 1 , 1};\nconst int dy8[] = {0, 1, 0, -1 , -1 , 1 , -1 , 1};\n\nconst int dxhorse[] = {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\nconst int dyhorse[] = {1 ,  -1 , 2  , -2 , 2 ,-2 , 1 ,-1};\n\nconst int MOD = 1000000007;\n//int MOD = 99990001;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 1LL << 60;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = acos(-1.0); //M_PI;\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (a<b) a=b;}\ntemplate<class T> inline void checkMin(T &a, T &b, const T x){checkMin(a, x), checkMin(b, x);}\ntemplate<class T> inline void checkMax(T &a, T &b, const T x){checkMax(a, x), checkMax(b, x);}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ninline int ceil(int x, int y){return (x - 1) / y + 1;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n\ninline bool _1(int x, int i){return bool(x&1<<i);}\ninline bool _1(LL x, int i){return bool(x&1LL<<i);}\ninline LL _1(int i){return 1LL<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n\ninline int reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\ninline LL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\ntemplate<class T> inline bool odd(T x){return x&1;}\ntemplate<class T> inline bool even(T x){return !odd(x);}\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\ntemplate<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\ntemplate<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n\ninline int low_idx(int x){return __builtin_ffs(x);}\ninline int low_idx(LL x){return __builtin_ffsll(x);}\ninline int high_idx(int x){return low_idx(reverse_bits(x));}\ninline int high_idx(LL x){return low_idx(reverse_bits(x));}\ninline int clz(int x){return __builtin_clz(x);}\ninline int clz(LL x){return __builtin_clzll(x);}\ninline int ctz(int x){return __builtin_ctz(x);}\ninline int ctz(LL x){return __builtin_ctzll(x);}\ninline int parity(int x){return __builtin_parity(x);}\ninline int parity(LL x){return __builtin_parityll(x);}\ninline int lg2(int a){return 31 - clz(a);}\ninline int lg2(LL a){return 63 - clz(a);}\ninline int count_bits(int x){return __builtin_popcount(x);}\ninline int count_bits(LL x){return __builtin_popcountll(x);}\n\n} using namespace BO;//}\n// <<= '2. Number Theory .,//{\nnamespace NT{\ninline LL __lcm(LL a, LL b){return a*b/__gcd(a,b);}\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\n\ninline int pow(int a, int b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int pow(int a, LL b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T> inline T pow(T a, LL b){\n    T c(1); while (b){\n        if (b&1) c *= a;\n        a *= a, b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIV(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int phi(int n){\n    int res = n; for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n} using namespace NT;//}\n//}\n\n/** Miscellaneous .. **/ //{\n// <<= 'Random Event .. . //{\nnamespace RNG{\n//srand((unsigned)time(NULL));\ninline unsigned int rand16(){return ((rand()) << 15) ^ rand();}\ninline unsigned int rand32(){return (rand16() << 16) | rand16();}\ninline ULL rand64(){return ((LL)rand32() << 32) | rand32();}\ninline ULL random(LL l, LL r){return l == r ? l : rand64() % (r - l) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return bool(rand() % 2);}\n} using namespace RNG;\n//}\n// <<= 'Clock .. . //{\nnamespace CLOCK{\nDB s0, s1, rd, k, T;\ninline DB getTime(){\n#ifdef LOCAL\n    return 1.0 * clock() / CLOCKS_PER_SEC;\n#else\n    timeval tv;\n    gettimeofday(&tv, 0);\n    return tv.tv_sec + tv.tv_usec * 1e-6;\n#endif\n}\n\ninline void st0(DB _T = 0.98){T = _T, s0 = getTime();}\ninline void st1(DB _k = 1.618){k = _k, s1 = getTime();}\ninline void ed1(){rd = getTime() - s1;}\ninline DB elapsed(){return getTime() - s0;}\ninline bool safe(){return elapsed() + rd * k < T;}\n} //using namespace CLOCK;\n//}\n// <<= 'Temp .. . //{\nnamespace TMP{\ntemplate<class T> PTT operator+(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi + p2.fi, p1.se + p2.se);\n}\n\ntemplate<class T> PTT operator-(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi - p2.fi, p1.se - p2.se);\n}\n\ntemplate<class T> PTT operator*(const PTT &lhs, T k){\n    return PTT(lhs.fi * k, lhs.se * k);\n}\n} using namespace TMP;\n//}\n//}\n\n/** Algorithm    .. */ //{\n// <<= '-. Math .,//{\nnamespace Math{\n\ttypedef long long typec;\n\t///Lib functions\n\ttypec GCD(typec a, typec b)\n\t{\n\t\treturn b ? GCD(b, a % b) : a;\n\t}\n\ttypec extendGCD(typec a, typec b, typec& x, typec& y)\n\t{\n\t\tif(!b) return x = 1, y = 0, a;\n\t\ttypec res = extendGCD(b, a % b, x, y), tmp = x;\n\t\tx = y, y = tmp - (a / b) * y;\n\t\treturn res;\n\t}\n\t///for x^k\n\ttypec power(typec x, typec k)\n\t{\n\t\ttypec res = 1;\n\t\twhile(k)\n\t\t{\n\t\t\tif(k&1) res *= x;\n\t\t\tx *= x, k >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t///for x^k mod m\n\ttypec powerMod(typec x, typec k, typec m)\n\t{\n\t\ttypec res = 1;\n\t\twhile(x %= m, k)\n\t\t{\n\t\t\tif(k&1) res *= x, res %= m;\n\t\t\tx *= x, k >>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t/***************************************\n\tInverse in mod p^t system\n\t***************************************/\n\ttypec inverse(typec a, typec p, typec t = 1)\n\t{\n\t\ttypec pt = power(p, t);\n\t\ttypec x, y;\n\t    y = extendGCD(a, pt, x, y);\n\t\treturn x < 0 ? x += pt : x;\n\t}\n\t/***************************************\n\tLinear congruence theorem\n\tx = a (mod p)\n\tx = b (mod q)\n\tfor gcd(p, q) = 1, 0 <= x < pq\n\t***************************************/\n\ttypec linearCongruence(typec a, typec b, typec p, typec q)\n\t{\n\t\ttypec x, y;\n\t\ty = extendGCD(p, q, x, y);\n\t\twhile(b < a) b += q / y;\n\t\tx *= b - a, x = p * x + a, x %= p * q;\n\t\tif(x < 0) x += p * q;\n\t\treturn x;\n\t}\n\t/***************************************\n\tprime table\n\tO(n)\n\t***************************************/\n\tconst int PRIMERANGE = 1000000;\n\tint prime[PRIMERANGE + 1];\n\tint mobius[PRIMERANGE + 1];\n\tint getPrime()\n\t{\n\t\tmemset (prime, 0, sizeof (int) * (PRIMERANGE + 1));\n\t\tmemset(mobius , 0 , sizeof(mobius));\n\t\tmobius[1] = 1;\n\t\tfor (int i = 2; i <= PRIMERANGE; i++)\n\t\t{\n\t\t\tif (!prime[i]) prime[++prime[0]] = i , mobius[i] = -1;\n\t\t\tfor (int j = 1; j <= prime[0] && prime[j] <= PRIMERANGE / i; j++)\n\t\t\t{\n\t\t\t\tprime[prime[j]*i] = 1;\n\t\t\t\tif (i % prime[j] == 0) break;\n\t\t\t\telse mobius[i * prime[j]] = -mobius[i];\n\t\t\t}\n\t\t}\n\t\treturn prime[0];\n\t}\n\t/***************************************\n\tget factor of n\n\tO(sqrt(n))\n\tfactor[][0] is prime factor\n\tfactor[][1] is factor generated by this prime\n\tfactor[][2] is factor counter\n\n\tneed: Prime Table\n\t***************************************/\n\t///you should init the prime table before\n\tint factor[100][3], facCnt;\n\tint getFactors(int x)\n\t{\n\t\tfacCnt = 0;\n\t\tint tmp = x;\n\t\tfor(int i = 1; prime[i] <= tmp / prime[i]; i++)\n\t\t{\n\t\t\tfactor[facCnt][1] = 1, factor[facCnt][2] = 0;\n\t\t\tif(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][0] = prime[i];\n\t\t\twhile(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][2]++, factor[facCnt][1] *= prime[i], tmp /= prime[i];\n\t\t\tif(factor[facCnt][1] > 1) facCnt++;\n\t\t}\n\t\tif(tmp != 1)\n\t\t\tfactor[facCnt][0] = tmp, factor[facCnt][1] = tmp, factor[facCnt++][2] = 1;\n\t\treturn facCnt;\n\t}\n\ttypec combinationModP(typec n, typec k, typec p)\n\t{\n\t\tif(k > n) return 0;\n\t\tif(n - k < k) k = n - k;\n\t\ttypec a = 1, b = 1, x, y;\n\t\tint pcnt = 0;\n\t\tfor(int i = 1; i <= k; i++)\n\t\t{\n\t\t\tx = n - i + 1, y = i;\n\t\t\twhile(x % p == 0) x /= p, pcnt++;\n\t\t\twhile(y % p == 0) y /= p, pcnt--;\n\t\t\tx %= p, y %= p, a *= x, b *= y;\n\t\t\tb %= p, a %= p;\n\t\t}\n\t\tif(pcnt) return 0;\n\t\textendGCD(b, p, x, y);\n\t\tif(x < 0) x += p;\n\t\ta *= x, a %= p;\n\t\treturn a;\n\t}\n};//using namespace Math;\n//}\n// <<= '-. Geo ,.//{\nnamespace Geo{\n\t#define typec double\n    const typec eps=1e-9;\n    int dblcmp(double d){\n        if (fabs(d)<eps)return 0;\n        return d>eps?1:-1;\n    }\n    int sgn(double a) {return a<-eps?-1:a>eps;}\n    inline double sqr(double x){return x*x;}\n    struct Point2D{\n\t\ttypec x,y;\n\t\tPoint2D(){}\n\t\tPoint2D(typec _x,typec _y):x(_x),y(_y){};\n\t\tvoid input(){\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t}\n\t\tvoid output(){\n\t\t\tprintf(\"%.2f %.2f\\n\",x,y);\n\t\t}\n\t\tbool operator==(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0&&dblcmp(a.y-y)==0;\n\t\t}\n\t\tbool operator<(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0?dblcmp(y-a.y)<0:x<a.x;\n\t\t}\n\t\ttypec len(){\n\t\t\treturn hypot(x,y);\n\t\t}\n\t\ttypec len2(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tPoint2D operator + (const Point2D &A) const{\n\t\t\treturn Point2D(x + A.x , y + A.y);\n\t\t}\n\t\tPoint2D operator - (const Point2D &A) const{\n\t\t\treturn Point2D(x - A.x , y - A.y);\n\t\t}\n\t\tPoint2D operator * (const typec _x) const{\n\t\t\treturn Point2D(x * _x , y * _x);\n\t\t}\n\t\ttypec operator * (const Point2D &A) const{\n\t\t\treturn x * A.x + y * A.y;\n\t\t}\n\t\ttypec operator ^ (const Point2D &A) const{\n\t\t\treturn x * A.y - y * A.x;\n\t\t}\n\t\tPoint2D operator / (const typec _p) const{\n\t\t\treturn Point2D(x / _p , y / _p);\n\t\t}\n\t\ttypec distance(Point2D p){\n\t\t\treturn hypot(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D add(Point2D p){\n\t\t\treturn Point2D(x+p.x,y+p.y);\n\t\t}\n\t\tPoint2D sub(Point2D p){\n\t\t\treturn Point2D(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D mul(typec b){\n\t\t\treturn Point2D(x*b,y*b);\n\t\t}\n\t\tPoint2D div(typec b){\n\t\t\treturn Point2D(x/b,y/b);\n\t\t}\n\t\ttypec dot(Point2D p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\ttypec det(Point2D p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\ttypec rad(Point2D a,Point2D b){\n\t\t\tPoint2D p=*this;\n\t\t\treturn fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n\t\t}\n\t\tPoint2D trunc(typec r){\n\t\t\ttypec l=len();\n\t\t\tif (!dblcmp(l))return *this;\n\t\t\tr/=l;\n\t\t\treturn Point2D(x*r,y*r);\n\t\t}\n\t\tPoint2D rotleft(){\n\t\t\treturn Point2D(-y,x);\n\t\t}\n\t\tPoint2D rotright(){\n\t\t\treturn Point2D(y,-x);\n\t\t}\n\t\tPoint2D rotate(Point2D p,typec angle)//\u00c8\u00c6\u00b5\u00e3p\u00c4\u00e6\u00ca\u00b1\u00d5\u00eb\u00d0\u00fd\u00d7\u00aaangle\u00bd\u00c7\u00b6\u00c8\n\t\t{\n\t\t\tPoint2D v=this->sub(p);\n\t\t\ttypec c=cos(angle),s=sin(angle);\n\t\t\treturn Point2D(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n\t\t}\n\t};\n\n\ttypec cross(Point2D a,Point2D b,Point2D c){\n\t\treturn (b.sub(a)).det(c.sub(a));\n\t}\n}using namespace Geo;\n//}\n//}\n\n/** I/O Accelerator Interface .. **/ //{\ntemplate<class T> inline T& RD(T &x){\n    //cin >> x;\n    //scanf(\"%d\", &x);\n    char c; for (c = getchar(); c < '0'; c = getchar()); x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';\n    //char c; c = getchar(); x = c - '0'; for (c = getchar(); c >= '0'; c = getchar()) x = x * 10 + c - '0';\n    return x;\n}\n\ninline DB& RF(DB &x){\n    //cin >> x;\n    scanf(\"%lf\", &x);\n    /*char t; while ((t=getchar())==' '||t=='\\n'); x = t - '0';\n    while ((t=getchar())!=' '&&t!='\\n'&&t!='.')x*=10,x+=t-'0';\n    if (t=='.'){DB l=1; while ((t=getchar())!=' '&&t!='\\n')l*=0.1,x += (t-'0')*l;}*/\n    return x;\n}\n\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nint Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case %d: %d\\n\", ++Case, x);\n    //printf(\"%.2lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n}\n//}\n/* .................................................................................................................................. */\nconst int N = 1111;\nint n , m;\nchar a[N][N];\nint dp[N][N];\nbool inmap(int p , int q){\n    return 0 <= p && p <= n - 1 && 0 <= q && q <= m - 1;\n}\nbool next(char c , char d){\n    if (c == 'D') return d == 'I';\n    if (c == 'I') return d == 'M';\n    if (c == 'M') return d == 'A';\n    if (c == 'A') return d == 'D';\n    return false;\n}\nint id(char c){\n    if (c == 'D') return 0;\n    if (c == 'I') return 1;//d == 'M';\n    if (c == 'M') return 2;//d == 'A';\n    if (c == 'A') return 3;//d == 'D';\n    return -1;\n}\nint inst[N][N];\nbool circle;\nint __;\nint dfs(int x , int y){\n    if (inst[x][y] == __){\n//            cout << \">>> \" << x << ' ' << y << endl;\n        circle = 1;\n        return 0;\n    }\n    inst[x][y] = __;\n    if (dp[x][y] != 0) {\n            inst[x][y] = 0;\n            return dp[x][y];\n\n    }\n    for (int k = 0 ; k < 4 ; ++k) if (inmap(x + dx4[k] , y + dy4[k])){\n        int gx = x + dx4[k] , gy = y + dy4[k];\n        if (!next(a[x][y] , a[gx][gy])) continue;\n        checkMax(dp[x][y] , dfs(gx,gy));\n    }\n    inst[x][y] = 0;\n    ++dp[x][y];\n//    cout << x << ' ' << y << ' ' << dp[x][y] << endl;\n    return (dp[x][y]);\n}\n//bool fuck(int x , int y){\n//    int d = id(a[x][y]);\n//    if (dp[x][y][d] == 0) return 0;\n//    for (int k = 0 ; k < 4 ; ++k) if (inmap(x + dx4[k] , y + dy4[k])){\n//        int gx = x + dx4[k] , gy = y + dy4[k];\n//        int gd = id(a[gx][gy]);\n//        if (!next(a[x][y] , a[gx][gy])) continue;\n//        if (dp[x][y][d] <= dp[gx][gy][gd]) return true;\n//    }\n//    return false;\n//}\n\nvoid solve(){\n    RST(inst);\n    for (int i = 0 ; i < n ; ++i) scanf(\"%s\" , a[i]);\n    RST(dp);\n    circle = 0;\n    __ = 0;\n    for (int i = 0 ; i < n && !circle; ++i)\n        for (int j = 0 ; j < m && !circle; ++j){\n            __=1;\n//            cout << i << ' ' << j <<endl;\n            dfs(i , j);\n        }\n    if (circle){\n        puts(\"Poor Inna!\");\n        return;\n    }\n    int ans = 0;\n    for (int i = 0 ; i < n ; ++i)\n        for (int j = 0 ; j < m ; ++j) if (a[i][j] == 'D' && dp[i][j]) //if (a[i][j] == 'D' && dp[i][j][0])// && dp[i][j][0] % 4 ==0)\n            checkMax(ans , dp[i][j] / 4);\n    if (ans == 0) puts(\"Poor Dima!\");\n    else OT(ans);\n}\nint main(){\n    while(cin >> n >> m) solve();\n}\n//\n//\n//\n//\n////\n//const int N = 1111;\n//const int dx[] = {0, 1, 0, -1};\n//const int dy[] = {1, 0, -1, 0};\n//int v[N][N], dp[N][N], s[N][N];\n//int n, m, found;\n//void Dfs(int x, int y){\n//    if (dp[x][y] != -1) return;\n//    v[x][y] = 1;\n//    dp[x][y] = 1;\n//    for (int i = 0; i < 4; i++){\n//        int xx = x + dx[i], yy = y + dy[i];\n//        if (xx <= 0 || xx > n || yy <= 0 || yy > m || (s[x][y] + 1) % 4 != s[xx][yy]) continue;\n//        if (v[xx][yy]){found = 1; return;}\n//        Dfs(xx, yy);\n//        if (found) return;\n//        dp[x][y] = max(dp[x][y], dp[xx][yy] + 1);\n//    }\n//    v[x][y] = 0;\n//}\n//char str[N];\n//int main(){\n//    //freopen(\"in.txt\", \"r\", stdin);\n//    scanf(\"%d%d\", &n, &m);\n//    for (int i = 1; i <= n; i++){\n//        scanf(\"%s\", str + 1);\n//        for (int j = 1; j <= m; j++){\n//            if (str[j] == 'D') s[i][j] = 0;\n//            if (str[j] == 'I') s[i][j] = 1;\n//            if (str[j] == 'M') s[i][j] = 2;\n//            if (str[j] == 'A') s[i][j] = 3;\n//        }\n//    }\n//    found = 0;\n//    int ans = 0;\n//    memset(dp, -1, sizeof(dp));\n//\n//    for (int i = 1; i <= n; i++)\n//    for (int j = 1; j <= m; j++)\n//    if (dp[i][j] == -1) Dfs(i, j);\n//    if (found){\n//        puts(\"Poor Inna!\");\n//        return 0;\n//    }\n//    for (int i = 1; i <= n; i++)\n//    for (int j = 1; j <= m; j++)\n//    if (!s[i][j]) ans = max(ans, dp[i][j] / 4);\n//    if (!ans) puts(\"Poor Dima!\");\n//    else printf(\"%d\\n\", ans);\n//\n\n//}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "implementation"], "dificulty": "1900", "interactive": false}