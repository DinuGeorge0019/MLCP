{
    "link": "https://codeforces.com//contest/527/problem/A",
    "problemId": "24742",
    "problem_idx": "A",
    "shortId": "527A",
    "contest_number": "527",
    "problem_submissions": {
        "D": [
            10320998,
            10323329,
            10320418,
            10316376,
            10320868,
            10323389,
            10322440,
            10320232,
            10321604,
            10323582,
            10321959,
            10322883,
            10324771,
            10323891,
            10324342,
            10325751,
            10316899,
            10320622
        ],
        "C": [
            10319281,
            10317608,
            10318719,
            10321621,
            10319197,
            10319745,
            10320049,
            10325822,
            10321996,
            10320609,
            10320450,
            10322500,
            10322047,
            10318021,
            10323195,
            10322166,
            10322519,
            10313548
        ],
        "B": [
            10316733,
            10315414,
            10316286,
            10320342,
            10316974,
            10315178,
            10316059,
            10315345,
            10320022,
            10315992,
            10316397,
            10319742,
            10317580,
            10315069,
            10315584,
            10318949,
            10318891,
            10343112,
            10316418
        ],
        "A": [
            10313000,
            10313055,
            10313796,
            10312916,
            10313836,
            10313217,
            10312846,
            10312806,
            10313753,
            10312901,
            10312783,
            10313020,
            10313144,
            10312917,
            10312793,
            10312900,
            10314293,
            10313134
        ],
        "E": [
            11345011
        ]
    },
    "name": "A. Playing with Paper",
    "statement": "One day Vasya was sitting on a not so interesting Maths lesson and\r\nmaking an origami from a rectangular mm mm sheet of paper (). Usually\r\nthe first step in making an origami is making a square piece of paper\r\nfrom the rectangular sheet by folding the sheet along the bisector of\r\nthe right angle, and cutting the excess part. After making a paper ship\r\nfrom the square piece, Vasya looked on the remaining mm mm strip of\r\npaper. He got the idea to use this strip of paper in the same way to\r\nmake an origami, and then use the remainder (if it exists) and so on. At\r\nthe moment when he is left with a square piece of paper, he will make\r\nthe last ship from it and stop.Can you determine how many ships Vasya\r\nwill make during the lesson?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\nll a, b, ans;\n\nint main() {\n\tcin >> a >> b;\n\twhile (a > 0 && b > 0) {\n\t\tll t = (a - b) / b + 1;\n\t\tans += t;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Playing with Paper.json",
    "editorial_link": "https://codeforces.com//blog/entry/17020",
    "editorial": "It s easy to see that described process is equivalent to the following\r\nloop: But such naive approach will obviously lead to verdict TLE, since\r\nit makes Â  operations even on the third sample test. The key idea is to\r\nreplace repeating subtraction operations with integer division\r\noperations. This leads to the logarithmic-time solution that looks\r\nsimilar to the Euclid algorithm: The first observation is that the new\r\nHamming distance may not be less than the old one minus two, since we\r\nchange only two characters. So the task is to actually determine, if we\r\ncan attain decrease by two, one or can t attain decrease at all. The\r\ndecrease by two is possible if there are two positions with the same two\r\nletters in two strings but that appear in different order (like double\r\n<-> bundle ). If there are no such positions, then we just need to check\r\nthat we may decrease the distance. This can be done by just fixing the\r\ncharacter that stands on the wrong position, like in permanent <->\r\npergament (here n stands in wrong pair with m, and there is also\r\nunmatched m, so we may fix this position). Otherwise, the answer is to\r\nkeep everything as it is. Implementation can be done by keeping for each\r\npair (x, y) of symbols position where such pair appears in S and T and\r\nthen by carefully checking the conditions above. Obviously the largest\r\nglass piece at any moment is the one that is product of the largest\r\nhorizontal segment by the largest vertical segment. One of the possible\r\nsolutions is to carefully implement what described in the statement and\r\nkeep all horizontal segments and all vertical segments in priority queue\r\nor std::set, or some logarithmic data structure. This solution works in\r\n. But there is also a nice linear solution if we answer all queries in\r\nreverse order. Suppose segments are not cutting, but merging. In this\r\ncase we may keep the horizontal and vertical cut lines in double-linked\r\nlists and track the current maximum (that can only increase and become\r\nequal to the newly-merged segment each time). This solution works in .\r\nOne may think that this task is about graph theory, but it after some\r\ninvestigation and several equivalent changes in task statement it can be\r\nreduced to the well-known greedy problem. Initially you have that points\r\nmay lie together in a set if they are not too close, i. e. . This is\r\nobviously equivalent to the following condition. Let s consider interval\r\nof radius with center in point and call this interval to be the interval\r\nof point i. Then the statement actually says that no two such intervals\r\nshould be intersecting. This task is well-known and can be solved\r\ngreedily after sorting segments in ascending order of right endpoint: It\r\ns easy to prove that this solution is correct. Among all ways to choose\r\nfirst segments, the best way is the one that minimizes x-coordinate of\r\nthe right endpoint of the last segment (since it restricts us in the\r\nleast possible way). Problem legend asks you to add minimum number of\r\nedges to the given connected undirected graph (possibly, with loops and\r\nduplicating edges) and choose direction for its edges so that both the\r\nincoming and outgoing degrees of all vertices are even. First idea is\r\nthat the resulting graph before we choose the direction (but after we\r\nadded some edges) will contain Euler circuit, since all degrees are\r\neven. That s almost what we need: if we have an Euler circuit that\r\ncontains even number of edges, we may direct them like following: a <- b\r\n-> c <- d -> e It s easy to see that each vertex appearance in this\r\ncycle adds 2 to its ingoing or outgoing degree, so the resulting degrees\r\nwill be even. But if the Euler circuit is odd (meaning that there is odd\r\nnumber of edges in the graph), we must add some extra edge to the graph\r\nbefore we continue, the easiest way is to add a loop from vertex 0 to\r\nitself, since it doesn t affect the Euler tour, but now tour length is\r\neven, so everything is ok. Now we should think how to add edges\r\noptimally. It s easy to see that the optimal way is to first fix all odd\r\ndegrees of vertices (i. e. combine all odd vertices by pairs and put an\r\nedge in each pair), and then, possibly, add an extra loop as described\r\nabove. The last part is to actually find an Euler circuit, and to print\r\nthe answer. There were issues with this task. Intended constraints were\r\nactually , and the intended solution was using Fast Fourier\r\nTransformation, that leads to running time. But unfortunately the\r\nstatement contained wrong constraints, so we reduced input size during\r\nthe tour. Nevertheless, we will add the harder version of this task and\r\nyou will be able to submit it shortly. Key idea is to reduce this task\r\nto a polynomial multiplication. Let s solve the task in following\r\nmanner. For each position i of the S for each character c from ATGC we\r\nwill calculate match(c, i) that is equal to the number of c characters\r\nthat have matching symbol in S if we put string T in position i. Then\r\nthe criteria for us to have an occurrence at position i is that match(A,\r\ni) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly\r\nthat each character from T being put at position i has a corresponding\r\ncharacter in S). Now let s find out how to calculate match(c, i). Let s\r\nkeep only c characters and not c characters in both strings and denote\r\nthem by 1 and 0 respectively. Let s also spread each 1 in string S by\r\nthe distance k to the left and to the right. For example, k = 1 for the\r\nsample string AGCAATTCAT and the character A corresponding bit vector\r\nwill be 111110111, and for the character C it will be 0111001110. This\r\nbitvector can be calculated in by putting two events +1 and -1 in string\r\nS in positions and for each in original string S and then sweeping from\r\nleft to right over the string S and processing those events. Now our\r\ntask is reduced to searching all positions where the bitvector T is the\r\nsubmask of the bitvector S. In constraints this can be done by using\r\nbitsets in . Nevertheless, this task can be seen as calculation of\r\npolynomials S and reversed(T) product. We will keep this as an exercise\r\nfor those who decide to submit the harder version of this task. Let s\r\ndraw a bounding box that contains all intersection points. Let s fix a\r\ntriangle and consider three angles shown on the picture. Calculate area\r\nof intersection of those area with the bounding box and call this area\r\nto be the area of an angle . Then it s easy to see, that those three\r\nangles are complement to the triangle itself in the bounding box, i. e.\r\ntriangle area is bounding box area minus three angle areas. This leads\r\nus to the idea how to solve this task by carefully calculating for each\r\npossible formed angle on the plane, how much times does it appear in\r\ntotal answer if we sum all values like over all triples of lines.\r\nActually, the angle is considered as many times, as many lines there are\r\nthat intersect both sides of its right adjacent angle. So, our task is\r\nreduced to calculate for each angle on plane how much lines intersect\r\nits sides (i. e. its rays). This can be done in by fixing the first side\r\nof the angle and then adding lines in ascending order of polar angle,\r\nand then by keeping the number of lines that intersect the base line to\r\nthe left and that intersect the base line to the right. Key idea is that\r\nthe exact of four angles formed by the pair of lines that is crossed by\r\nsome third line c, can be determined by two numbers: its polar angle\r\nalpha and its crossing with a coordinate x. Further details are shown on\r\nthe picture below. There is also a nice short solution from enot110\r\nhere.\r\n",
    "hint": []
}