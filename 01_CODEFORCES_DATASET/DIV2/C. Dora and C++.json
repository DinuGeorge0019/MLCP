{
    "link": "https://codeforces.com//contest/2007/problem/C",
    "problemId": "2845542",
    "problem_idx": "C",
    "shortId": "2007C",
    "contest_number": "2007",
    "problem_submissions": {
        "F": [
            278829889,
            278836909,
            278834397,
            278833574,
            278834465,
            278838066,
            278835361,
            278842334,
            278824105,
            278831692,
            278838908,
            278836968,
            278839548,
            278831301,
            278823086,
            278840296,
            278841111,
            278842601
        ],
        "E": [
            278819100,
            278812531,
            278814740,
            278819903,
            278822295,
            278825462,
            278818230,
            278822054,
            278840929,
            278825485,
            278828447,
            278833891,
            278799229,
            278838138,
            278839019,
            278828512,
            278831250,
            278831388,
            278817583,
            278815781
        ],
        "D": [
            278799468,
            278799575,
            278803157,
            278799799,
            278806603,
            278804232,
            278798668,
            278803495,
            278817444,
            278796667,
            278805268,
            278809906,
            278809488,
            278817233,
            278829523,
            278808086,
            278804865,
            278814312,
            278803553,
            278802384
        ],
        "C": [
            278780728,
            278781086,
            278788227,
            278789504,
            278792493,
            278790375,
            278787480,
            278788281,
            278794086,
            278818650,
            278789734,
            278788169,
            278787429,
            278793363,
            278793381,
            278800135,
            278810824,
            278793278,
            278788023,
            278790440
        ],
        "B": [
            278776959,
            278776203,
            278777907,
            278784810,
            278782747,
            278782953,
            278836748,
            278778704,
            278778803,
            278775898,
            278785508,
            278778671,
            278810717,
            278784596,
            278792140,
            278786468,
            278796546,
            278777191,
            278777412,
            278786342
        ],
        "A": [
            278773744,
            278773692,
            278774098,
            278774399,
            278775464,
            278777680,
            278775772,
            278775250,
            278773819,
            278773814,
            278774248,
            278884949,
            278773664,
            278780595,
            278777213,
            278780108,
            278778288,
            278781544,
            278774028,
            278774012,
            278778642
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133382",
    "editorial": "Read the hints.Consider . First, the answer is less than . Otherwise,\r\nyou can always increase the minimum value by so that all elements are\r\ngreater than . Letâs go over all possible minimum values, say , and we\r\ncan do the operations so that all elements are in the range . Then we\r\ncan calculate the range and compare it with the answer.There are\r\npossible minimum values, so the process is too slow. Consider first\r\nletting be the minimum, and we do the operations to make in the range .\r\nThen, sort the array, and try as the minimum in turn. Suppose is the\r\ncurrent minimum, and is the largest integer such that . If exists, then\r\nis the maximum. Thatâs because for all , ; and for all , . So we can do\r\nthis in after sorting.In the case of . We can prove that this is\r\nequivalent to according to the Bezoutâs Identity (Please, search it\r\nyourself on https://en.wikipedia.org/wiki/, for the character \" \" cannot\r\nbe displayed inside a link): First, the changes in value of each element\r\nmust be a multiple of , since are both multiples of . Second, we can\r\nalways construct integers such that , so we can perform some operations\r\nsuch that we only increase / decrease an element by .Time complexity: .\r\n",
    "name": "C. Dora and C++",
    "statement": "Dora has just learned the programming language C++!However, she has\r\ncompletely misunderstood the meaning of C++. She considers it as two\r\nkinds of adding operations on the array c with n elements. Dora has two\r\nintegers a and b. In one operation, she can choose one of the following\r\nthings to do. Choose an integer i such that 1\r\nleq i\r\nleq n, and increase c_i by a. Choose an integer i such that 1\r\nleq i\r\nleq n, and increase c_i by b. Note that a and b are , and they can be\r\nthe same.Let’s define a of array d as\r\nmax(d_i) -\r\nmin(d_i). For instance, the range of the array [1, 2, 3, 4] is 4 - 1 =\r\n3, the range of the array [5, 2, 8, 2, 2, 1] is 8 - 1 = 7, and the range\r\nof the array [3, 3, 3] is 3 - 3 = 0.After any number of operations\r\n(possibly, 0), Dora calculates the range of the new array. You need to\r\nhelp Dora minimize this value, but since Dora loves exploring all by\r\nherself, you only need to tell her the minimized value.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; const int maxN = 110000;int c[maxN]; int main() {\tios::sync_with_stdio(0);\tcin.tie(0); cout.tie(0);\tint T;\tfor (cin >> T; T; T--) {\t\tint n, a, b; cin >> n >> a >> b;\t\tint g = __gcd(a, b);\t\tfor (int i = 0; i < n; i++) {\t\t\tcin >> c[i];\t\t\tc[i] %= g;\t\t}\t\tsort(c, c + n);\t\tint mn = c[n - 1] - c[0];\t\tfor (int i = 1; i < n; i++) {\t\t\tmn = min(mn, c[i - 1] + g - c[i]);\t\t}\t\tcout << mn << '\\n';\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Dora and C++.json",
    "hint": [
        "Hint1 If you can perform an operation that decreases or from an element, will it be different? Answer No. Decrease an element by is the same as increasing all other elements by , as it does not affect the range.",
        "Hint2 If , can you solve the problem?",
        "Hint1 How to calulate the weight of a leaf quickly?",
        "Hint2 Consider a formed string. Let's delete useless part that won't contribute to the count of and substrings. What will be the rest? Answer A string with each pair of adjacent bits different. For example, . Then what decides whether the weight is zero or not?",
        "Hint3 The root is somehow important. When to fill ?",
        "Hint1 On a tree with nodes numbered with dfs order, we have to find the distance between two consecutive nodes. What can you think of? Answer Each edge is passed by exactly two of the paths.",
        "Hint2 How to calculate the maximum value of ? Is it different when the weight of all of its edges are known?",
        "Hint1 Let's try to judge whether an array is brilliant, and try to sort it first. What happens if we minus from each element? Answer Nothing will change.",
        "Hint2 We only care about the relative positions between the elements. Let's consider the difference array of array : .",
        "Hint3 What will the difference array look like after no more operations can be done?",
        "Hint1 Let's use another way to describe the problem. Let's define an array good, that it can be reordered to satisfy the condition. How many numbers do we have to change to make it good? To handle this, we need to know what is the optimal way to reorder an array.",
        "Hint2 Sort the array. Suppose is the minimum and is the maximum. Where to place the two elements? Can you prove this is optimal?",
        "Hint3 How to maintain the answer better using the properties?",
        "Hint1 Consider the degress of vertices in a binary tree. What can you observe? Answer The root has degree , the non-leaf nodes different from the root have degree , the leaf nodes have degree . The degree of every node is not greater than .",
        "Hint2 Choose a root. It should have degree . Is it always possible to build a binary tree on the initial tree if all nodes have degree ? What will be the depth of the binary tree with the given root? Answer It's always possible to build the binary tree, and the depth of the tree is the maximum distance from the root to any nodes in the tree.",
        "Hint3 Consider the binary depth of the full tree. We should to go over every possible root, but how to find the maximum distance from the root to other nodes? Are there any special nodes?",
        "Hint4 Diameter.",
        "Hint5 Is it possible to maintain the answer for all the roots when adding a leaf to the tree?",
        "Hint1 Each column or row should be painted at most once. Suppose we paint each column and row exactly once. Then what does the number on one position tell us? Answer It tells us whether the row was painted first of the column was painted first. Try to build a graph.",
        "Hint2 We can build a directed bipartite graph. How to judge whether it is possible to paint the graph? How to calculate the beauty of one single grid? Answer Do topological sort on the graph. A cycle means it is impossible. Otherwise, the topo sort splits the graph into several layers. The beauty is the product of factorials of number of nodes in the layers (except the first layer, for we needn't do those operations).",
        "Hint3 How to solve the original problem when the initial grid has positive beauty? How to optimize? Consider adjacent layers.",
        "Hint4 How to solve the original problem when the initial grid is impossible to be painted out? Are there too many ways to flip a block?",
        "Hint5 How to optimize the process of building the graph and doing topological sort?",
        "Hint1 Try to find some way to \"sort\" the grid, for swapping different rows and different columns doesn't matter. How? Answer Sort by the number of .",
        "Hint2 How to calculate the beauty? Answer The beauty is the product of factorials of number of equal rows and equal columns.",
        "Hint3 How to solve the original problem when the initial grid has positive beauty? How to optimize?"
    ]
}