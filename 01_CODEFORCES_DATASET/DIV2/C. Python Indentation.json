{
    "link": "https://codeforces.com//contest/909/problem/C",
    "problemId": "142269",
    "problem_idx": "C",
    "shortId": "909C",
    "contest_number": "909",
    "problem_submissions": {
        "D": [
            33703562,
            33684475,
            33687934,
            33679960,
            33681845,
            33678239,
            33681778,
            33682813,
            33684628,
            33683979,
            33684264,
            33683734,
            33682267,
            33684172,
            33684972,
            33684951,
            37837707,
            33689232,
            33685173
        ],
        "C": [
            33702243,
            33685781,
            33688791,
            33678737,
            33677527,
            33680778,
            33679730,
            33677867,
            33678218,
            33679090,
            33681226,
            33679711,
            33679799,
            33678914,
            33682105,
            33681294,
            33679526,
            33680909
        ],
        "F": [
            33682616,
            33683222,
            33692268,
            33694692,
            33695944
        ],
        "E": [
            33680057,
            33686075,
            33684461,
            33682298,
            33685101,
            33681929,
            33683773,
            33684555,
            33682566,
            33680995,
            33686514,
            33687842,
            33689439,
            33687234,
            33687184,
            33690952,
            33683720,
            33689497
        ],
        "B": [
            33678984,
            33689620,
            33681003,
            33675642,
            33677938,
            33674594,
            33675218,
            33675981,
            33675928,
            33676067,
            33676981,
            33677469,
            33675490,
            33680062,
            33675898,
            33676219,
            33677187
        ],
        "A": [
            33675962,
            33690137,
            33674036,
            33674451,
            33674005,
            33674337,
            33674208,
            33673945,
            33674163,
            33674088,
            33674166,
            33675518,
            33673927,
            33674572,
            33673981,
            33673915,
            33676471
        ]
    },
    "name": "C. Python Indentation",
    "statement": "In Python, code blocks don\u2019t have explicit begin/end or curly braces to\r\nmark beginning and end of the block. Instead, code blocks are defined by\r\nindentation.We will consider an extremely simplified subset of Python\r\nwith only two types of statements. are written in a single line, one per\r\nline. An example of a simple statement is assignment. are compound\r\nstatements: they contain one or several other statements. For statement\r\nconsists of a header written in a separate line which starts with \"for\"\r\nprefix, and loop body. Loop body is a block of statements indented one\r\nlevel further than the header of the loop. Loop body can contain both\r\ntypes of statements. Loop body can\u2019t be empty.You are given a sequence\r\nof statements without indentation. Find the number of ways in which the\r\nstatements can be indented to form a valid Python program.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\n\nint n,dp[2][5005],now,ans;\nchar c;\nbool lsf;\n\nint main()\n{\n\tscanf(\"%d\",&n),dp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdo c=getchar();while(!isalpha(c));\n\t\tnow=i&1;\n\t\tmemset(dp[now],0,n<<2);\n\t\tif(lsf)for(int j=1;j<n;j++)dp[now][j]=dp[now^1][j-1];\n\t\telse\n\t\t{\n\t\t\tdp[now][n-1]=dp[now^1][n-1];\n\t\t\tfor(int j=n-2;~j;j--)dp[now][j]=(dp[now][j+1]+dp[now^1][j])%mod;\n\t\t}\n\t\tlsf=(c=='f');\n\t}\n\tfor(int i=0;i<n;i++)ans=(ans+dp[n&1][i])%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Python Indentation.json",
    "editorial_link": "https://codeforces.com//blog/entry/56666",
    "editorial": "This problem can be solved using dynamic programming. Let\u00e2\u0080\u0099s consider all\r\npossible programs which end with a certain statement at a certain\r\nindent. Dynamic programming state will be an array which stores the\r\nnumber of such programs ending with statement at indent . The starting\r\nstate is a one-dimensional array for : there is exactly one program\r\nwhich consists of the first statement only, and its last statement has\r\nindent 0. The recurrent formula can be figured out from the description\r\nof the statements. When we add command , its possible indents depend on\r\nthe possible indents of command and on the type of command . If command\r\nis a for loop, command must have indent one greater than the indent of\r\ncommand , so and for . If command is a simple statement, command can\r\nbelong to the body of any loop before it, and have any indent from 0 to\r\nthe indent of command . If we denote the indent of command (simple\r\nstatement) as , the indent of command as , we need to sum over all cases\r\nwhere : . The answer to the task is the total number of programs which\r\nend with the last command at any indent: . The complexity of this\r\nsolution is .\r\n"
}