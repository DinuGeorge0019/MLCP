{
    "link": "https://codeforces.com//contest/1884/problem/C",
    "problemId": "2278161",
    "problem_idx": "C",
    "shortId": "1884C",
    "contest_number": "1884",
    "problem_submissions": {
        "E": [
            229182998,
            232047287,
            229184537,
            229188100,
            229407530,
            229406745,
            229186340,
            229191046,
            229193161
        ],
        "D": [
            229158633,
            232074380,
            229168220,
            229164508,
            229173176,
            229157255,
            229153443,
            229155494,
            229159386,
            229160353,
            229156733,
            229156643,
            229161617,
            229157357,
            229162436,
            229158936,
            229165915,
            229162999,
            229162965,
            229163918,
            229164809
        ],
        "C": [
            229155589,
            229160960,
            229166024,
            229166680,
            229154105,
            229157494,
            229160291,
            229153826,
            229157399,
            229163211,
            229163270,
            229157632,
            229164398,
            229157764,
            229156973,
            229156300,
            229158818,
            229157218,
            229159145,
            229159718
        ],
        "B": [
            229151946,
            229151614,
            229152037,
            229164652,
            229149397,
            229159327,
            229149698,
            229150790,
            229150442,
            229150480,
            229151756,
            229152335,
            229149090,
            229150117,
            229151229,
            229150183,
            229155852,
            229153843,
            229154670,
            229153764
        ],
        "A": [
            229147132,
            229147400,
            229147746,
            229153787,
            229147017,
            229146825,
            229146890,
            229146981,
            229146866,
            229148682,
            229147191,
            229148012,
            229146920,
            229147887,
            229146935,
            229147042,
            229146861,
            229146944,
            229147243,
            229148319
        ]
    },
    "name": "C. Medium Design",
    "statement": "The array a_1, a_2,\r\nldots, a_m is initially filled with zeroes. You are given n pairwise\r\ndistinct segments 1\r\nle l_i\r\nle r_i\r\nle m. You have to select an arbitrary subset of these segments (in\r\nparticular, you may select an empty set). Next, you do the following:\r\nFor each i = 1, 2,\r\nldots, n, if the segment (l_i, r_i) has been selected to the subset,\r\nthen for each index l_i\r\nle j\r\nle r_i you increase a_j by 1 (i. e. a_j is replaced by a_j + 1). If the\r\nsegment (l_i, r_i) has not been selected, the array does not change.\r\nNext (after processing all values of i = 1, 2,\r\nldots, n), you compute\r\nmax(a) as the maximum value among all elements of a. Analogously,\r\ncompute\r\nmin(a) as the minimum value. Finally, the cost of the selected subset of\r\nsegments is declared as\r\nmax(a) -\r\nmin(a).Please, find the maximum cost among all subsets of segments.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint N,M,pos[300005],tot,l[100005],r[100005];\nint cnt1[300005],cnt2[300005];\nvoid solve(){\n\tscanf(\"%d%d\",&N,&M);tot=0;pos[++tot]=1;pos[++tot]=M+1;\n\tfor(int i=1;i<=N;++i)scanf(\"%d%d\",&l[i],&r[i]),pos[++tot]=l[i],pos[++tot]=r[i]+1;\n\tsort(pos+1,pos+tot+1);tot=unique(pos+1,pos+tot+1)-pos-1;\n\tfor(int i=1;i<=N;++i)l[i]=lower_bound(pos+1,pos+tot+1,l[i])-pos,r[i]=lower_bound(pos+1,pos+tot+1,r[i]+1)-pos-1;\n\tint res=0;for(int i=1;i<=tot;++i)cnt1[i]=cnt2[i]=0;\n\tfor(int i=1;i<=N;++i){\n\t\tif(r[i]<tot-1)++cnt1[l[i]],--cnt1[r[i]+1];\n\t\tif(l[i]>1)++cnt2[l[i]],--cnt2[r[i]+1];\n\t}\n\tfor(int i=1;i<tot;++i){\n\t\tcnt1[i]+=cnt1[i-1];\n\t\tcnt2[i]+=cnt2[i-1];\n\t\tres=max(res,cnt1[i]);\n\t\tres=max(res,cnt2[i]);\n\t} cout<<res<<endl;\n}\nint main(){\n\tint t;cin>>t;\n\twhile(t--)solve(); \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Medium Design.json",
    "editorial_link": "https://codeforces.com//blog/entry/121618",
    "editorial": "Let be the position of the maximum element in the array in the optimal\r\nanswer. Notice that in this case, we can select all the segments where ,\r\nbecause if the position of the minimum element is outside of this\r\nsegment, we increase the answer by , and if it is inside, we do not\r\nworsen the answer. From this, it follows that the minimum will either\r\noccur at position or at position .We can then consider the segments that\r\ndo not contain position (similarly, we can do the same for ) and find\r\nthe position that is covered by the largest number of such segments.\r\nThis can be done using a line sweep algorithm. A segment corresponds to\r\ntwo events: - the segment opens, and - the segment closes. We sort these\r\nevents and iterate through them, keeping track of the number of open\r\nsegments at each moment. The maximum value among these quantities is\r\nwhat we need. The solution works in time.\r\n",
    "hint": []
}