{"link": "https://codeforces.com//contest/1365/problem/G", "problemId": "643142", "problem_idx": "G", "shortId": "1365G", "contest_number": "1365", "problem_submissions": {"G": [82837838, 82865836, 82846144, 82865744, 83288423, 83288390, 83115367, 83113068, 82891046, 83317408], "F": [82823576, 82831163, 82869715, 82841291, 82797913, 82821383, 82823224, 82820878, 82825962, 82827764, 82819318, 82822994, 82828397, 82835003, 82834772, 82828790, 83116114, 82838680, 82843357, 82850042], "E": [82816827, 82806889, 82828546, 82852781, 82820451, 82809338, 82811048, 82815094, 82813767, 82818099, 82819025, 82806699, 82809270, 82814661, 82803838, 82820792, 82820031, 82816700, 82817857, 82816698], "D": [82812948, 82823500, 82822183, 82824676, 82812570, 82806668, 82804333, 82805751, 82808225, 82811038, 82801401, 82805193, 82808495, 82818445, 82814370, 83282843, 82816083, 82808400, 82807406, 82806087], "C": [82796097, 82796764, 82804011, 82805788, 82786984, 82796314, 82793579, 82793092, 82796581, 82800342, 82827239, 82793084, 82792671, 82807140, 82802231, 82801070, 82793918, 82793032, 82794670], "B": [82789379, 82791264, 82799267, 82793610, 82787860, 82790701, 82790486, 82792963, 82793820, 82794046, 82787508, 82790351, 82789454, 82795420, 82796086, 83567414, 83567289, 83567233, 83566819, 83566572, 83566088, 83137777, 83136749, 83136555, 82797438, 82788975, 82789229, 82789419], "A": [82787406, 82788164, 82795856, 82788300, 82789945, 82787354, 82787533, 82792868, 82790605, 82788592, 83313475, 82823189, 82788613, 82787440, 82788379, 82788620, 82787269, 82787662, 82787203, 82787209]}, "name": "G. Secure Password", "statement": "Ayush devised yet another scheme to set the password of his lock. The\r\nlock has n slots where each slot can hold any non-negative integer. The\r\npassword P is a sequence of n integers, i-th element of which goes into\r\nthe i-th slot of the lock.To set the password, Ayush comes up with an\r\narray A of n integers each in the range [0, 2^{63}-1]. He then sets the\r\ni-th element of P as the bitwise OR of all integers in the array except\r\nA_i.You need to guess the password. To make a query, you can choose a\r\nnon-empty subset of indices of the array and ask the all elements of the\r\narray with index in this subset. .\r\n", "solutions": ["#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef unsigned long long mask64;\nmask64 query(vector <int>&x){\n\tif(x.empty()){\n\t\treturn 0;\n\t}else{\n\t\tprintf(\"? %lu\", x.size());\n\t\tfor(int i = 0;i < x.size();i ++){\n\t\t\tprintf(\" %d\", x[i]+1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tfflush(stdout);\n\t\tmask64 ret;\n\t\tscanf(\"%llu\", &ret);\n\t\treturn ret;\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector <int> pc6;\n\tfor(int i = 0;i < (1<<13);i ++){\n\t\tif(__builtin_popcount(i)==6){\n\t\t\tpc6.push_back(i);\n\t\t}\n\t}\n\tvector <mask64> rets(13);\n\tfor(int i = 0;i < 13;i ++){\n\t\tvector <int> toQuery;\n\t\tfor(int j = 0;j < n;j ++){\n\t\t\tif(pc6[j]>>i&1){\n\t\t\t\ttoQuery.push_back(j);\n\t\t\t\t// printf(\"pushing %d\\n\", j);\n\t\t\t}\n\t\t}\n\t\t// printf(\"%d\\n\", i);\n\t\trets[i]=query(toQuery);\n\t}\n\tprintf(\"!\");\n\tfor(int i = 0;i < n;i ++){\n\t\tmask64 ans(0);\n\t\tfor(int j = 0;j < 13;j ++){\n\t\t\tif(~pc6[i]>>j&1){\n\t\t\t\tans|=rets[j];\n\t\t\t}\n\t\t}\n\t\tprintf(\" %llu\", ans);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "combinatorics", "constructive algorithms", "interactive", "math"], "dificulty": "2800", "interactive": false}