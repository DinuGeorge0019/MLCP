{"link": "https://codeforces.com//contest/405/problem/E", "problemId": "7386", "problem_idx": "E", "shortId": "405E", "contest_number": "405", "problem_submissions": {"C": [6115915, 6109660, 6110133, 6110046, 6111196, 6113157, 6113191, 6111181, 6110354, 6110520, 6111719, 6111599, 6110290, 6110453, 6111762, 6111100, 6110857], "B": [6113263, 6108172, 6108709, 6108763, 6108097, 6111258, 6110081, 6107735, 6108477, 6108386, 6108872, 6108648, 6108353, 6108714, 6109837, 6108107], "A": [6110002, 6106628, 6106664, 6106595, 6106410, 6109734, 6107964, 6106587, 6106988, 6106985, 6107053, 6107108, 6106487, 6106761, 6106362, 6106567], "E": [6109575, 6134220, 6134212, 6517207, 6129138, 6115449, 6161534, 6121533], "D": [6111866, 6112127, 6117518, 6112341, 6112656, 6109019, 6121539, 6112769, 6113306, 6112893, 6112946, 6113537, 6114230, 6114563, 6113633, 6113898, 6114989]}, "name": "E. Graph Cutting", "statement": "Little Chris is participating in a graph cutting contest. He\u2019s a pro.\r\nThe time has come to test his skills to the fullest.Chris is given a\r\nsimple undirected connected graph with vertices (numbered from 1 to )\r\nand edges. The problem is to cut it into edge-distinct paths of length\r\n2. Formally, Chris has to partition all edges of the graph into pairs in\r\nsuch a way that the edges in a single pair are adjacent and each edge\r\nmust be contained in exactly one pair.For example, the figure shows a\r\nway Chris can cut a graph. The first sample test contains the\r\ndescription of this graph. You are given a chance to compete with Chris.\r\nFind a way to cut the given graph or determine that it is impossible!\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <vector>\n\n#define Nmax 100004\nusing namespace std;\nbool viz[Nmax];\nint Deleted[Nmax];\nvector < int > Graph[Nmax];\nint Father[Nmax];\ntypedef vector < int  > :: iterator IT;\ninline void DFS(const int node)\n{\n    IT it;\n    viz[node] = 1;\n    for(it = Graph[node].begin();it != Graph[node].end();++it)\n    {\n        if(viz[*it])\n            continue ;\n        Father[*it] = node;\n        DFS(*it);\n    }\n    int degree = 0, i;\n    vector < int > v;\n    for(it = Graph[node].begin();it != Graph[node].end();++it)\n    {\n        if(Deleted[*it]==1)\n            continue ;\n        ++degree;\n        v.push_back(*it);\n    }\n    if(degree &1)\n    {\n        for(it = v.begin();it != v.end(); ++it)\n        {\n            if(*it==Father[node])\n                continue ;\n            cout<<*it<<\" \"<<node<<\" \";\n            if(Deleted[*it]==2)\n                Deleted[*it] = 1;\n            ++it;\n            if(*it==Father[node])\n                ++it;\n            if(Deleted[*it]==2)\n                Deleted[*it] = 1;\n            cout<<*it<<\"\\n\";\n        }\n        Deleted[node] = 2 ;\n\n    }\n    else\n    {\n        for(i = 0;i < degree; i += 2)\n        {\n            cout<<v[i]<<\" \"<<node<<\" \"<<v[i+1]<<\"\\n\";\n            if(Deleted[v[i]]==2)\n                Deleted[v[i]] = 1;\n            if(Deleted[v[i+1]]==2)\n                Deleted[v[i+1]] = 1;\n        }\n        Deleted[node] = 1;\n   }\n}\n\nint main()\n{\n    int n, m, i, x, y;\n    std::ios_base::sync_with_stdio(false);\n    #ifndef ONLINE_JUDGE\n        freopen(\"date.in\", \"r\", stdin);\n        freopen(\"date.out\", \"w\", stdout);\n    #endif\n    scanf(\"%d %d\\n\",&n,&m);\n    if(!(m&1))\n    {\n        for(i=1;i<=m;++i)\n        {\n            scanf(\"%d %d\\n\",&x,&y);\n            Graph[x].push_back(y);\n            Graph[y].push_back(x);\n        }\n        DFS(1);\n    }\n    else\n        cout<<\"No solution\\n\";\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs"], "dificulty": "2300", "interactive": false}