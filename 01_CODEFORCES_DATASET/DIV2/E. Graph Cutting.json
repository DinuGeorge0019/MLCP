{
    "link": "https://codeforces.com//contest/405/problem/E",
    "problemId": "7386",
    "problem_idx": "E",
    "shortId": "405E",
    "contest_number": "405",
    "problem_submissions": {
        "C": [
            6115915,
            6109660,
            6110133,
            6110046,
            6111196,
            6113157,
            6113191,
            6111181,
            6110354,
            6110520,
            6111719,
            6111599,
            6110290,
            6110453,
            6111762,
            6111100,
            6110857
        ],
        "B": [
            6113263,
            6108172,
            6108709,
            6108763,
            6108097,
            6111258,
            6110081,
            6107735,
            6108477,
            6108386,
            6108872,
            6108648,
            6108353,
            6108714,
            6109837,
            6108107
        ],
        "A": [
            6110002,
            6106628,
            6106664,
            6106595,
            6106410,
            6109734,
            6107964,
            6106587,
            6106988,
            6106985,
            6107053,
            6107108,
            6106487,
            6106761,
            6106362,
            6106567
        ],
        "E": [
            6109575,
            6134220,
            6134212,
            6517207,
            6129138,
            6115449,
            6161534,
            6121533
        ],
        "D": [
            6111866,
            6112127,
            6117518,
            6112341,
            6112656,
            6109019,
            6121539,
            6112769,
            6113306,
            6112893,
            6112946,
            6113537,
            6114230,
            6114563,
            6113633,
            6113898,
            6114989
        ]
    },
    "name": "E. Graph Cutting",
    "statement": "Little Chris is participating in a graph cutting contest. Heâ€™s a pro.\r\nThe time has come to test his skills to the fullest.Chris is given a\r\nsimple undirected connected graph with vertices (numbered from 1 to )\r\nand edges. The problem is to cut it into edge-distinct paths of length\r\n2. Formally, Chris has to partition all edges of the graph into pairs in\r\nsuch a way that the edges in a single pair are adjacent and each edge\r\nmust be contained in exactly one pair.For example, the figure shows a\r\nway Chris can cut a graph. The first sample test contains the\r\ndescription of this graph. You are given a chance to compete with Chris.\r\nFind a way to cut the given graph or determine that it is impossible!\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <vector>\n\n#define Nmax 100004\nusing namespace std;\nbool viz[Nmax];\nint Deleted[Nmax];\nvector < int > Graph[Nmax];\nint Father[Nmax];\ntypedef vector < int  > :: iterator IT;\ninline void DFS(const int node)\n{\n    IT it;\n    viz[node] = 1;\n    for(it = Graph[node].begin();it != Graph[node].end();++it)\n    {\n        if(viz[*it])\n            continue ;\n        Father[*it] = node;\n        DFS(*it);\n    }\n    int degree = 0, i;\n    vector < int > v;\n    for(it = Graph[node].begin();it != Graph[node].end();++it)\n    {\n        if(Deleted[*it]==1)\n            continue ;\n        ++degree;\n        v.push_back(*it);\n    }\n    if(degree &1)\n    {\n        for(it = v.begin();it != v.end(); ++it)\n        {\n            if(*it==Father[node])\n                continue ;\n            cout<<*it<<\" \"<<node<<\" \";\n            if(Deleted[*it]==2)\n                Deleted[*it] = 1;\n            ++it;\n            if(*it==Father[node])\n                ++it;\n            if(Deleted[*it]==2)\n                Deleted[*it] = 1;\n            cout<<*it<<\"\\n\";\n        }\n        Deleted[node] = 2 ;\n\n    }\n    else\n    {\n        for(i = 0;i < degree; i += 2)\n        {\n            cout<<v[i]<<\" \"<<node<<\" \"<<v[i+1]<<\"\\n\";\n            if(Deleted[v[i]]==2)\n                Deleted[v[i]] = 1;\n            if(Deleted[v[i+1]]==2)\n                Deleted[v[i+1]] = 1;\n        }\n        Deleted[node] = 1;\n   }\n}\n\nint main()\n{\n    int n, m, i, x, y;\n    std::ios_base::sync_with_stdio(false);\n    #ifndef ONLINE_JUDGE\n        freopen(\"date.in\", \"r\", stdin);\n        freopen(\"date.out\", \"w\", stdout);\n    #endif\n    scanf(\"%d %d\\n\",&n,&m);\n    if(!(m&1))\n    {\n        for(i=1;i<=m;++i)\n        {\n            scanf(\"%d %d\\n\",&x,&y);\n            Graph[x].push_back(y);\n            Graph[y].push_back(x);\n        }\n        DFS(1);\n    }\n    else\n        cout<<\"No solution\\n\";\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Graph Cutting.json",
    "editorial_link": "https://codeforces.com//blog/entry/11186",
    "editorial": "It can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.\n\nThe function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u,?v); the function then will return vertex u, expecting that the parent function call will assign it to some path.\n\nThe function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v,?u,?w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v,?u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u,?v,?w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.\n\nThe function could be implemented as a single DFS:",
    "hint": []
}