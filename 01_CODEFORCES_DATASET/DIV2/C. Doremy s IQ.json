{"link": "https://codeforces.com//contest/1708/problem/C", "problemId": "1465649", "problem_idx": "C", "shortId": "1708C", "contest_number": "1708", "problem_submissions": {"E": [164526365, 164509978, 164525791, 164525144, 164515105, 164526880, 164565405], "D": [164483082, 164475794, 164498322, 164502919, 164500499, 164493036, 164483535, 164489653, 164492932, 164487483, 164496395, 164492041, 164496037, 164494420, 164494528, 164500816, 164498429, 164498353, 164501077], "C": [164476151, 164486488, 164480189, 164506917, 164526449, 164483780, 164470946, 164474613, 164471073, 164464598, 164477489, 164480460, 164478377, 164479833, 164476392, 164474668, 164479091, 164477458, 164469257], "B": [164463973, 164514329, 164488244, 164465324, 164492077, 164499834, 164464194, 164460225, 164462182, 164458987, 164462805, 164471454, 164467808, 164468216, 164463689, 164461529, 164464211, 164467907, 164461028], "A": [164463865, 164513385, 164484667, 164457212, 164489629, 164494393, 164457849, 164457193, 164457578, 164456205, 164457572, 164457666, 164458662, 164460280, 164458147, 164456758, 164456563, 164456719, 164456652]}, "name": "C. Doremy s IQ", "statement": "Doremy is asked to test n contests. Contest i can only be tested on day\r\ni. The difficulty of contest i is a_i. Initially, Doremy\u2019s IQ is q. On\r\nday i Doremy will choose whether to test contest i or not. She can only\r\ntest a contest if her current IQ is strictly greater than 0.If Doremy\r\nchooses to test contest i on day i, the following happens: if a_i>q,\r\nDoremy will feel she is not wise enough, so q decreases by 1; otherwise,\r\nnothing changes. If she chooses not to test a contest, nothing\r\nchanges.Doremy wants to test as many contests as possible. Please give\r\nDoremy a solution.\r\n", "solutions": ["// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\n#define mid (l + r >> 1)\n\ndef(N, int, 1e5 + 5)\n\nint n, q;\nint a[N];\nbool chs[N];\n\nbool chk(int x) {\n\tint sum = 0;\n\trep(i, 1, n) chs[i] = 0;\n\trep(i, 1, n) if(a[i] <= q) ++sum, chs[i] = 1;\n\tper(i, n, 1) {\n\t\tif(sum >= x) break;\n\t\tif(a[i] > q) chs[i] = 1, ++sum;\n\t}\n\tint nq = q;\n\trep(i, 1, n) {\n\t\tif(chs[i]) {\n\t\t\tif(a[i] > nq) {\n\t\t\t\tif(!nq) return 0;\n\t\t\t\t--nq;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\tW(T) {\n\t\tqread(n, q);\n\t\trep(i, 1, n) qread(a[i]);\n\t\tint l = 1, r = n, res = 1;\n\t\twhile(l <= r) {\n\t\t\tif(chk(mid)) res = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tchk(res);\n\t\trep(i, 1, n) cout << chs[i]; cout << '\\n';\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "greedy"], "dificulty": "1600", "interactive": false}