{"link": "https://codeforces.com//contest/219/problem/E", "problemId": "1616", "problem_idx": "E", "shortId": "219E", "contest_number": "219", "problem_submissions": {"E": [2056692, 2057598, 2059507, 2059313, 2058485, 2059875, 2060513, 2061809], "D": [2054476, 2056179, 2055432, 2056594, 2055868, 2055622, 2055003, 2054658, 2057835, 2054870, 2055878, 2057367, 2056847, 2058567, 2057046, 2057149, 2057027, 2055883, 2057861, 2055024], "C": [2053819, 2054931, 2054300, 2055466, 2059881, 2054433, 2054050, 2054365, 2056216, 2055640, 2054836, 2056204, 2055132, 2054423, 2055456, 2055579, 2055867, 2057241, 2056728, 2057355], "B": [2053118, 2053816, 2053245, 2053935, 2054094, 2053542, 2053200, 2053567, 2054115, 2053868, 2053799, 2054198, 2053471, 2055129, 2054481, 2054228, 2054209, 2054214, 2054824, 2055919], "A": [2052729, 2052827, 2052736, 2054458, 2053049, 2052760, 2052727, 2052921, 2052934, 2052917, 2052885, 2053077, 2052795, 2052871, 2052942, 2052755, 2053281, 2053122, 2053028, 2052909]}, "name": "E. Parking Lot", "statement": "A parking lot in the City consists of parking spaces, standing in a\r\nline. The parking spaces are numbered from 1 to from left to right. When\r\na car arrives at the lot, the operator determines an empty parking space\r\nfor it. For the safety\u2019s sake the chosen place should be located as far\r\nfrom the already occupied places as possible. That is, the closest\r\noccupied parking space must be as far away as possible. If there are\r\nseveral such places, then the operator chooses the place with the\r\nminimum index from them. If all parking lot places are empty, then the\r\ncar gets place number .We consider the distance between the -th and the\r\n-th parking spaces equal to meters.You are given the parking lot records\r\nof arriving and departing cars in the chronological order. For each\r\nrecord of an arriving car print the number of the parking lot that was\r\ngiven to this car.\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nconst int maxn  =   200005;\nconst int maxid =   1000005;\n\nstruct node\n{\n    int maxlen;\n    int sl,sr,len;\n}tree[maxn*4];\nint position[maxid],n,m;\n\ninline node merge(const node &a,const node &b)\n{\n    node ret;\n    ret.maxlen=max(a.maxlen,b.maxlen);\n    ret.maxlen=max(ret.maxlen,a.sr+b.sl);\n    ret.sl=a.sl;\n    if (a.sl==a.len) ret.sl+=b.sl;\n    ret.sr=b.sr;\n    if (b.sr==b.len) ret.sr+=a.sr;\n    ret.len=a.len+b.len;\n    return ret;\n}\n\ninline void build(int num,int l,int r)\n{\n    tree[num].maxlen=tree[num].sl=tree[num].sr=tree[num].len=r-l+1;\n    if (l==r) return;\n    int mid=(l+r)/2;\n    build(num*2,l,mid);\n    build(num*2+1,mid+1,r);\n}\n\ninline void insert(int num,int l,int r,int pos,int delta)\n{\n    if (l==r){\n        if (delta==1){\n            tree[num].maxlen=tree[num].sl=tree[num].sr=0;\n        }else{\n            tree[num].maxlen=tree[num].sl=tree[num].sr=1;\n        }\n        return;\n    }\n    int mid=(l+r)/2;\n    if (pos<=mid) insert(num*2,l,mid,pos,delta);\n    else insert(num*2+1,mid+1,r,pos,delta);\n    tree[num]=merge(tree[num*2],tree[num*2+1]);\n}\n\ninline int query(int num,int l,int r,int tar)\n{\n    if (l==r){\n        return l;\n    }\n    if (l==1 && tree[num].sl>=tar) return 1;\n    int mid=(l+r)/2;\n    if ((tree[num*2].maxlen+1)>=tar*2){\n        return query(num*2,l,mid,tar);\n    }\n    if ((tree[num*2].sr+tree[num*2+1].sl)+1>=tar*2){\n        return (mid-tree[num*2].sr+tar);\n    }\n    return query(num*2+1,mid+1,r,tar);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    build(1,1,n);\n    for (int i=0;i<m;++i){\n        int t,id;\n        scanf(\"%d%d\",&t,&id);\n        if (t==1){\n            int len=(tree[1].maxlen+1)/2;\n            len=max(tree[1].sl,len);\n            len=max(tree[1].sr,len);\n            \n            int pos=query(1,1,n,len);\n            position[id]=pos;\n            insert(1,1,n,pos,1);\n            printf(\"%d\\n\",pos);\n        }else{\n            int pos=position[id];\n            insert(1,1,n,pos,-1);\n        }\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2200", "interactive": false}