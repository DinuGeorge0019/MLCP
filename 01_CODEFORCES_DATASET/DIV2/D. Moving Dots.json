{
    "link": "https://codeforces.com//contest/1788/problem/D",
    "problemId": "1767774",
    "problem_idx": "D",
    "shortId": "1788D",
    "contest_number": "1788",
    "problem_submissions": {
        "F": [
            192929323,
            192944697,
            192947972,
            192947585,
            192932378,
            192933439,
            192954011,
            193003406,
            192956724,
            192960550,
            192961107,
            192951794,
            192975658,
            193004734,
            193000099,
            192953392,
            192971360,
            193157814,
            192925320
        ],
        "E": [
            192914791,
            192927615,
            192927556,
            192934590,
            192889260,
            192914229,
            192917631,
            192924823,
            192930869,
            192943768,
            192931128,
            192903797,
            192921531,
            193004713,
            192925760,
            192927056,
            192925608,
            192917135,
            192939766,
            192904744
        ],
        "D": [
            192905122,
            192919739,
            192914784,
            192910155,
            192955552,
            192927341,
            192930171,
            192916598,
            192938656,
            192928104,
            192958419,
            192917109,
            192914086,
            193004704,
            192914561,
            192936729,
            192911543,
            192926368,
            192906600
        ],
        "C": [
            192896754,
            192903243,
            192891543,
            192895173,
            192914614,
            192879823,
            192902740,
            192906894,
            192909558,
            192922632,
            192887922,
            192904823,
            193004689,
            192890036,
            192896137,
            192904090,
            192893814,
            192946267
        ],
        "B": [
            192885653,
            192880984,
            192883005,
            192891309,
            192902865,
            192884638,
            192883772,
            192879778,
            192880217,
            192885391,
            192892745,
            192885295,
            192888862,
            193004678,
            192878668,
            192883423,
            192882746,
            192889266,
            192878522,
            192940441
        ],
        "A": [
            192874357,
            192874502,
            192872686,
            192876928,
            192873442,
            192872154,
            192872535,
            192873765,
            192873755,
            192872250,
            192873788,
            192879133,
            193004648,
            192872439,
            192874189,
            192873135,
            192877988,
            192872696,
            192938096
        ]
    },
    "name": "D. Moving Dots",
    "statement": "We play a game with n dots on a number line.The initial coordinate of\r\nthe i-th dot is x_i. These coordinates are distinct. Every dot starts\r\nmoving simultaneously with the same constant speed.Each dot moves in the\r\ndirection of the closest dot (different from itself) until it meets\r\nanother dot. In the case of a tie, it goes to the left. Two dots meet if\r\nthey are in the same coordinate, after that, they stop moving.After\r\nenough time, every dot stops moving. The result of a game is the number\r\nof distinct coordinates where the dots stop.Because this game is too\r\neasy, calculate the sum of results when we play the game for every\r\nsubset of the given n dots that has at least two dots. As the result can\r\nbe very large, print the sum modulo 10^9+7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n    int x;\n    scanf(\"%d\",&x);\n    return x;\n}\nconst int N=3005,mod=1e9+7;\ninline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\nint n,a[N];\nint pw[N];\nint main(){\n    n=in();\n    pw[0]=1;\n    for(int i=1;i<=n;i++)a[i]=in(),pw[i]=add(pw[i-1],pw[i-1]);\n    int ans=0;\n    for(int l=1;l<=n;l++){\n        for(int r=l+1;r<=n;r++){\n            int x=lower_bound(a+1,a+n+1,a[l]+a[l]-a[r])-a-1;\n            int y=lower_bound(a+1,a+n+1,a[r]+a[r]-a[l])-a;\n            ans=add(ans,pw[x+n-y+1]);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "math",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Moving Dots.json",
    "editorial_link": "https://codeforces.com//blog/entry/112584",
    "editorial": "Letâs think about the original problem where we do not think about\r\nsubsets.We can easily observe that each dot does not change direction\r\nduring moving. Assume that dots gather at coordinate . Rightmost dot of\r\ndots that have smaller coordinate than should move right, and leftmost\r\ndot which has bigger coordinate than should move left. We can observe\r\nthat the number of adjacent dot where each move toward each other will\r\nbe the answer.Now letâs solve the problem for subsets. Instead of\r\ncounting number of adjacent dot that moves toward each other for each\r\nsubset of dots, we will count the number of subset for each possible\r\nwhere dot moves right and dot moves left and there are no dots between\r\nand .Let the coordinate of a dot in a subset be . We will try to find\r\nout which can be in a subset where dot and dot move toward each\r\nother.Since there are no dot between and , dots satisfying should not be\r\nin the subset. Since dot should move right, dots that satisfy and should\r\nnot be in the subset. As the same way for dot , dots that satisfy and\r\nshould not be in the subset. Summing these up, dots satisfying should\r\nnot be in the subset. By using binary search, we can find the number of\r\ndots that cannot be in the subset in .If there are dots that can be in\r\nthe subset, the number of subset where and moves toward each other will\r\nbe . Summing all will give us the answer. Since there are pairs of , we\r\ncan solve the problem in .Instead of using binary search, we can use the\r\nmonotonicity of and when increases, we can solve the range of dots that\r\ncannot be in the subset in by sweeping. Both and solutions will be\r\naccepted.There were some dynamic programming solutions from some\r\ntesters.\r\n",
    "hint": []
}