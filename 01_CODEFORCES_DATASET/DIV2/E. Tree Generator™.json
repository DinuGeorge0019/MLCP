{
    "link": "https://codeforces.com//contest/1150/problem/E",
    "problemId": "337489",
    "problem_idx": "E",
    "shortId": "1150E",
    "contest_number": "1150",
    "problem_submissions": {
        "B": [
            53540534,
            53507569,
            53508198,
            53505953,
            53507902,
            53502830,
            53513376,
            53506258,
            53506938,
            53507029,
            53505090,
            53506786,
            53507919,
            53505701,
            53508136,
            53505737,
            53510148,
            53505896,
            53509474,
            53506927
        ],
        "A": [
            53540520,
            53504501,
            53501762,
            53504323,
            53502423,
            53506385,
            53503912,
            53503441,
            53502508,
            53503428,
            53501838,
            53503271,
            53503651,
            53502306,
            53502491,
            53507914,
            53502081,
            53502083,
            53506610,
            53502822
        ],
        "D": [
            53516414,
            53520400,
            53521416,
            53522657,
            53528159,
            53520710,
            53520700,
            53521674,
            53520691,
            53521939,
            53524571,
            53524486,
            53563821,
            53526080,
            53525497,
            53525654,
            53525306,
            53525173,
            53524887,
            53526333,
            53526204
        ],
        "C": [
            53509607,
            53510070,
            53509423,
            53505062,
            53510041,
            53509499,
            53512010,
            53510164,
            53511943,
            53509231,
            53509848,
            53515668,
            53510065,
            53514034,
            53514382,
            53512626,
            53511942,
            53512622,
            53512550
        ],
        "E": [
            53531623,
            53531513,
            53525648
        ]
    },
    "name": "E. Tree Generator™",
    "statement": "Owl Pacino has always been into trees unweighted rooted trees in\r\nparticular. He loves determining the of every tree he sees that is, the\r\nmaximum length of any simple path in the tree.Owl Pacino’s owl friends\r\ndecided to present him the Tree Generator a powerful machine creating\r\nrooted trees from their . An n-vertex rooted tree can be by a bracket\r\nsequence of length 2(n - 1) in the following way: find any walk starting\r\nand finishing in the root that traverses each edge exactly twice once\r\ndown the tree, and later up the tree. Then follow the path and write\r\ndown \"\" (an opening parenthesis) if an edge is followed down the tree,\r\nand \"\" (a closing parenthesis) otherwise.The following figure shows\r\nsample rooted trees and their descriptions: Owl wrote down the\r\ndescription of an n-vertex rooted tree. Then, he rewrote the description\r\nq times. However, each time he wrote a new description, he picked two\r\ndifferent characters in the description he wrote the last time, swapped\r\nthem and wrote down the resulting string. He always made sure that each\r\nwritten string was the description of a rooted tree.Pacino then used\r\nTree Generator for each description he wrote down. What is the diameter\r\nof each constructed tree?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate <typename T, typename E>\nstruct lazySegTree {\n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using P = function<E(E,int)>;\n    F f; G g; H h; P p; T d1; E d0;\n    int n;\n    vector<T> dat;\n    vector<E> lazy;\n\n    lazySegTree(){}\n    lazySegTree(int n_, F f_, G g_, H h_,\n        T d1_, E d0_, P p_=[](E a, int b){return a;})\n        : f(f_), g(g_), h(h_), p(p_), d1(d1_), d0(d0_)\n    {\n        n = 1; while(n < n_) n *= 2;\n        dat.assign(n*2-1, d1);\n        lazy.assign(n*2-1, d0);\n    }\n    void build(vector<T> v) {\n        REP(i, v.size()) dat[i+n-1] = v[i];\n        for(int i=n-2; i>=0; --i) dat[i] = f(dat[i*2+1], dat[i*2+2]);\n    }\n\n    inline void eval(int len, int k) {\n        if(lazy[k] == d0) return;\n        if(k*2+1 < n*2-1) {\n            lazy[2*k+1] = h(lazy[k*2+1], lazy[k]);\n            lazy[2*k+2] = h(lazy[k*2+2], lazy[k]);\n        }\n        dat[k] = g(dat[k],p(lazy[k],len));\n        lazy[k] = d0;\n    }\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r-l, k);\n        if(b <= l || r <= a) return dat[k];\n        if(a <= l && r <= b) {\n            lazy[k] = h(lazy[k], x);\n            return g(dat[k], p(lazy[k],r-l));\n        }\n        return dat[k] = f(update(a, b, x, 2*k+1, l, (l+r)/2),\n                        update(a, b, x, 2*k+2, (l+r)/2, r));\n    }\n    T update(int a, int b, E x) { return update(a, b, x, 0, 0, n); }\n    T query(int a, int b, int k, int l, int r) {\n        eval(r-l, k);\n        if(a <= l && r <= b) return dat[k];\n        bool left = !((l+r)/2 <= a || b <= l), right = !(r <= 1 || b <= (l+r)/2);\n        if(left&&right) return f(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r));\n        if(left) return query(a, b, 2*k+1, l, (l+r)/2);\n        return query(a, b, 2*k+2, (l+r)/2, r);\n    }\n    T query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, q;\n    cin >> n >> q;\n    string s;\n    cin >> s;\n\n    struct node {\n        ll ans, left, right, max, minus;\n        node() : ans(-INF), left(-INF), right(-INF), max(-INF), minus(-INF) {}\n        node(ll v) : ans(0), left(-v), right(-v), max(v), minus(-2*v) {}\n    };\n    auto f = [&](node a, node b) {\n        node ret;\n        ret.ans = max({a.ans, b.ans, a.left+b.max, a.max+b.right});\n        ret.left = max({a.left, b.left, a.max+b.minus});\n        ret.right = max({a.right, b.right, a.minus+b.max});\n        ret.max = max({a.max, b.max});\n        ret.minus = max({a.minus, b.minus});\n        return ret;\n    };\n    auto g = [&](node a, ll b) {\n        a.left -= b;\n        a.right -= b;\n        a.max += b;\n        a.minus += -2*b;\n        return a;\n    };\n    auto h = [&](ll a, ll b) {\n        return a + b;\n    };\n    lazySegTree<node,ll> seg(2*n-1, f, g, h, node(), 0);\n    vector<node> v(2*n-1);\n    ll t = 0; v[0] = t;\n    REP(i, s.size()) {\n        t += s[i]=='(' ? 1 : -1;\n        v[i+1] = node(t);\n    }\n    seg.build(v);\n\n    cout << seg.query(0, 2*n-1).ans << endl;\n    REP(i, q) {\n        ll l, r;\n        cin >> l >> r;\n        l--, r--;\n        if(l > r) swap(l, r);\n        swap(s[l], s[r]);\n        if(s[l] != s[r]) seg.update(l+1, r+1, s[l]=='('?2:-2);\n        cout << seg.query(0, 2*n-1).ans << endl;\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Tree Generator™.json",
    "editorial_link": "https://codeforces.com/blog/entry/66783",
    "editorial": "Take any rooted tree and its description. For any vertices , , let be\r\nits depth in the tree, and be the distance between and .Consider the\r\ntraversal of the tree represented by the description. Letâs say weâre\r\nprocessing the parentheses one by one each second, and letâs set be the\r\ncurrent depth after seconds. Moreover, let and be the moments of time\r\nwhen weâre in vertices , respectively (there might be multiple such\r\nmoments; pick any). Therefore, and .Assume without the loss of\r\ngenerality that and consider the part of the description between the -th\r\nand -th second. What is the shallowest vertex we visit during such\r\ntraversal? As the description represents a depth-first search of the\r\ntree, it must be . Therefore, . It follows that .Eventually, the\r\ndiameter is equal to . This leads to a slow solution for computing a\r\nsingle diameter without constructing the tree: consider the parentheses\r\none by one, and maintain the current depth and maximum values of , and\r\nfor on the prefix. However, we still need to be able to process the\r\nupdates quicker than in linear time.It turns out we can maintain a\r\nsegment tree. Each node will maintain some information about the\r\nsubstring of the description. Note that such substring doesnât have to\r\ndescribe the whole tree, and so the number of opening and closing\r\nparentheses doesnât have to match and it can happen that weâre at a\r\nnegative depth when following the description.Weâll hold the following\r\ninformation about the substring. We assume everywhere that : (the final\r\ndepth, might be non-zero), , , , , . Note that the values in the second\r\npoint describe all the contiguous parts of the formula .Itâs now pretty\r\nstraightforward to combine the informations about two neighboring\r\nsubstrings into a single information about the concatenation of the\r\nsubstrings. Note for example that and . This allows to maintain the\r\nsegment tree over the description and process the single character\r\nreplacement in time. Therefore, we can process each query in time, and\r\nsolve the whole task in time.Notably, square-root decomposition isnât\r\nmuch slower in this task; per query should pass if you arenât\r\ndeliberately trying to write as slow code as possible.\r\n",
    "hint": []
}