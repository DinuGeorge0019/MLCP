{"link": "https://codeforces.com//contest/483/problem/D", "problemId": "15996", "problem_idx": "D", "shortId": "483D", "contest_number": "483", "problem_submissions": {"D": [8386294, 8386916, 8387027, 8388203, 8385307, 8389341, 8389557, 8388183, 8391623, 8387992, 8389299, 8390155, 8390563, 8388891, 8389334, 8389180, 8390505, 8386135, 8391232, 8391185], "C": [8383615, 8382113, 8384608, 8383022, 8387457, 8384433, 8385393, 8386889, 8384602, 8386654, 8387022, 8383805, 8385999, 8390017, 8386225, 8391277, 8383936, 8386464, 8388471], "B": [8382195, 8385250, 8383239, 8384840, 8390185, 8382966, 8385025, 8385757, 8383520, 8389663, 8386087, 8387234, 8384759, 8383404, 8384794, 8384797, 8384248, 8384677], "A": [8380252, 8380147, 8380667, 8380605, 8380236, 8380104, 8380114, 8382803, 8381088, 8380652, 8380442, 8381813, 8380802, 8380441, 8390354, 8382041, 8391125, 8380372, 8381412, 8381899]}, "name": "D. Interesting Array", "statement": "We\u2019ll call an array of non-negative integers , if it meets constraints.\r\nThe -th of the constraints consists of three integers , , () meaning\r\nthat value should be equal to . Your task is to find any array of\r\nelements or state that such array doesn\u2019t exist.Expression means the\r\nbitwise AND of numbers and . In programming languages C++, Java and\r\nPython this operation is represented as \"&\", in Pascal as \"and\".\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100000 + 10;\n\nint node[maxn * 4] = {}, ql, qr, qv, fg[maxn * 4] = {};\nvoid update(int o, int l, int r) {\n    if(l >= ql && r <= qr) {\n        fg[o] |= qv;\n        // printf(\"update here %d %d become %d\\n\", l, r, fg[o]);\n        return;\n    }\n    int m = (l + r) >> 1;\n    if(ql <= m) update(o << 1, l, m);\n    if(qr > m) update((o << 1) + 1, m + 1, r);\n}\n\nint query(int o, int l, int r) {\n    if(l >= ql && r <= qr) return fg[o];\n    else {\n        fg[o << 1] |= fg[o];\n        fg[(o << 1) + 1] |= fg[o];\n        int m = (l + r) >> 1;\n        int a = 2147483647;\n        if(ql <= m) a &= query(o << 1, l, m);\n        if(qr > m) a &= query((o<<1)+1, m + 1, r);\n        return a;\n    }\n}\n\nvoid print(int o, int l, int r) {\n    if(l > r) return ;\n    if(l == r) {\n        printf(\"%d \", fg[o]);\n        return;\n    }\n    fg[o << 1] |= fg[o];\n    fg[(o << 1) + 1] |= fg[o];\n    int m = (l + r) >> 1;\n    print(o << 1, l, m);\n    print((o<<1)+1, m + 1, r);\n}\n\nint a[maxn][3], n, m;\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 0; i < m; ++i) {\n        scanf(\"%d%d%d\", &a[i][0], &a[i][1], &a[i][2]);\n        ql = a[i][0], qr = a[i][1], qv = a[i][2];\n        update(1, 1, n);\n    }\n    // print(1, 1, n); puts(\"\");\n    for(int i = 0; i < m; ++i) {\n        ql = a[i][0], qr = a[i][1];\n        if(query(1, 1, n) != a[i][2]) {\n            // printf(\"%d to %d expect %d get %d\\n\", ql, qr, a[i][2], query(1, 1, n));\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n    print(1, 1, n); puts(\"\");\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures"], "dificulty": "1800", "interactive": false}