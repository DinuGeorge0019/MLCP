{
    "link": "https://codeforces.com//contest/1180/problem/D",
    "problemId": "361552",
    "problem_idx": "D",
    "shortId": "1180D",
    "contest_number": "1180",
    "problem_submissions": {
        "E": [
            55893859,
            55894752,
            55901354,
            55899227,
            55899601,
            55901958,
            55925264,
            55926068,
            55925665,
            55901489,
            233719923,
            56137984
        ],
        "D": [
            55886120,
            55888146,
            55895366,
            55891739,
            55901351,
            55888912,
            55886961,
            55887441,
            55889700,
            55885693,
            55885046,
            55888982,
            55895413,
            55887827,
            55888865,
            55887449,
            55890050,
            55889347,
            55889337,
            55889598
        ],
        "B": [
            55883680,
            55881669,
            55882390,
            55902887,
            55885746,
            55928231,
            55877920,
            55878680,
            55879245,
            55879265,
            55878648,
            55878842,
            55880598,
            55879213,
            55878902,
            55880179,
            55880226,
            55880939,
            55879031,
            55878699
        ],
        "C": [
            55881632,
            55883944,
            55885637,
            55882803,
            55884870,
            55882898,
            55883039,
            55882359,
            55884046,
            55883397,
            55882537,
            55907439,
            55883279,
            55883175,
            55884337,
            55884299,
            55883318,
            55885078,
            55882396,
            55882286
        ],
        "A": [
            55875261,
            55875247,
            55875638,
            55875332,
            55875345,
            55875222,
            55875465,
            55875376,
            55875312,
            55875276,
            55875257,
            55875199,
            55876007,
            55875234,
            55875346,
            55875606,
            55877781,
            55876574,
            55875619,
            55875756
        ]
    },
    "name": "D. Tolik and His Uncle",
    "statement": "This morning Tolik has understood that while he was sleeping he had\r\ninvented an incredible problem which will be a perfect fit for\r\nCodeforces! But, as a \"Discuss tasks\" project hasn\u2019t been born yet (in\r\nEnglish, well), he decides to test a problem and asks his uncle.After a\r\nlong time thinking, Tolik\u2019s uncle hasn\u2019t any ideas on how to solve it.\r\nBut, he doesn\u2019t want to tell Tolik about his inability to solve it, so\r\nhe hasn\u2019t found anything better than asking you how to solve this\r\ntask.In this task you are given a cell field n\r\ncdot m, consisting of n rows and m columns, where point\u2019s coordinates\r\n(x, y) mean it is situated in the x-th row and y-th column, considering\r\nnumeration from one (1\r\nleq x\r\nleq n, 1\r\nleq y\r\nleq m). Initially, you stand in the cell (1, 1). Every move you can jump\r\nfrom cell (x, y), which you stand in, by any non-zero vector (dx, dy),\r\nthus you will stand in the (x+dx, y+dy) cell. Obviously, you can\u2019t leave\r\nthe field, but also there is one more important condition you\u2019re not\r\nallowed to use one vector twice. Your task is to visit each cell of the\r\nfield exactly once (the initial cell is considered as already\r\nvisited).Tolik\u2019s uncle is a very respectful person. Help him to solve\r\nthis task!\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\n\nnamespace SOLVE {\n    void main(){\n        int n,m;\n        in(n,m);\n        ll u = 1,d = n;\n        while (u<d) {\n            REP(i,1,m+1){\n                printf(\"%lld %lld\\n\",u,i);\n                printf(\"%lld %lld\\n\",d,m-i+1);\n            }\n            u++;\n            d--;\n        }\n        if(u == d){\n            ll l = 1,r = m;\n            while(l<r){\n                printf(\"%lld %lld\\n\",u,l++);\n                printf(\"%lld %lld\\n\",u,r--);\n            }\n            if(l == r)                printf(\"%lld %lld\\n\",u,l);\n\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tolik and His Uncle.json",
    "editorial_link": "https://codeforces.com//blog/entry/67891",
    "editorial": "First, we are going to describe how to bypass 1?m\n strip.\n\nThis algorithm is pretty easy \u0097 (1,1)\n -> (1,m)\n -> (1,2)\n -> (1,m?1)\n -> \u0085\n. Obviously all jumps have different vectors because their lengths are different.\n\nIt turns out that the algorithm for n?m\n grid is almost the same. Initially, we are going to bypass two uttermost horizontals almost the same way as above \u0097 (1,1)\n -> (n,m)\n -> (1,2)\n -> (n,m?1)\n -> \u0085\n -> (1,m)\n -> (n,1)\n. One can realize that all vectors are different because they have different dy\n. Note that all of them have |dx|=n?1\n. Then we will jump to (2,1)\n (using (?(n?2),0)\n vector). Now we have a smaller task for (n?2)?m\n grid. One can see that we used only vectors with |dx|?n?2\n, so they don't influence now at all. So the task is fully brought down to a smaller one."
}