{"link": "https://codeforces.com//contest/1668/problem/F", "problemId": "1373079", "problem_idx": "F", "shortId": "1668F", "contest_number": "1668", "problem_submissions": {"E": [154123739, 154125336, 154119851, 154113083, 154126230, 154111025, 154118734, 154118893, 154116518], "D": [154102065, 154111480, 154109461, 154112828, 154127256, 154120568, 154199100, 154098507, 154101292, 154104775, 154103929, 154095552, 154104771, 154104638], "C": [154084164, 154089822, 154082750, 154086924, 154096669, 154097603, 154087733, 154089704, 154084845, 154091220, 154093921, 154082051, 154082528, 154089420, 154085834, 154089820, 154100489, 154080049, 154081283], "B": [154081285, 154084224, 154085663, 154082020, 154152941, 154084489, 154090124, 154084331, 154085985, 154081983, 154085223, 154085348, 154095598, 154087105, 154085147, 154082318, 154081788, 154081908, 154090843, 154084167], "A": [154079113, 154080383, 154079244, 154078891, 154152929, 154079977, 154085842, 154079717, 154081051, 154079292, 154081689, 154080381, 154089065, 154090204, 154080866, 154080201, 154079483, 154080405, 154087751, 154079358], "F": [154125193, 154162167, 154110277, 154120657]}, "name": "F. Edge Elimination", "statement": "You are given a tree (connected, undirected, acyclic graph) with n\r\nvertices. Two edges are adjacent if they share exactly one endpoint. In\r\none move you can remove an arbitrary edge, if that edge is adjacent to\r\nan even number of remaining edges.Remove all of the edges, or determine\r\nthat it is impossible. If there are multiple solutions, print any.\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define MAXN 410000\nusing namespace std;\nint T,n,m;\nint tot,pre[MAXN],to[MAXN],lin[MAXN];\nint deg[MAXN];\nbool vis_edge[MAXN];\nvector<pair<int,int> >ans;\nvector<int> son[MAXN][2],edge[MAXN][2];\n\nvoid init()\n{\n    tot=1;\n    for(int i=1;i<=n;i++)\n    {\n        pre[i]=deg[i]=0;\n        son[i][0].clear();\n        son[i][1].clear();\n        edge[i][0].clear();\n        edge[i][1].clear();\n    }\n    ans.clear();\n}\n\nvoid add(int x,int y)\n{\n    tot++;lin[tot]=pre[x];pre[x]=tot;to[tot]=y;vis_edge[tot]=0;\n}\n\nvoid work(int x)\n{\n    for(int i=pre[x];i;i=lin[i])\n    {\n        if(vis_edge[i])continue;\n        int v=to[i];\n        vis_edge[i]=vis_edge[i^1]=1;\n        ans.push_back(make_pair(x,v));\n        work(v);\n    }\n}\n\nbool dfs(int x,int fa)\n{\n    for(int i=pre[x];i;i=lin[i])\n    {\n        int v=to[i];\n        if(fa == v)continue;\n        if(!dfs(v,x))return 0;\n        son[x][deg[v]].push_back(v);\n        edge[x][deg[v]].push_back(i);\n    }\n    while(son[x][deg[x]].size())\n    {\n        int v = son[x][deg[x]].back() , e = edge[x][deg[x]].back();\n        son[x][deg[x]].pop_back();edge[x][deg[x]].pop_back();\n\n        ans.push_back(make_pair(x,v));\n        vis_edge[e]=vis_edge[e^1]=1;\n\n        work(v);\n\n        deg[x]^=1;\n    }\n    if(son[x][deg[x]^1].size() > 1)return 0;\n    return 1;\n}\n\n\nint main()\n{\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        scanf(\"%d\",&n);\n        init();\n        for(int i=1;i<n;i++)\n        {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            add(x,y);\n            add(y,x);\n            deg[x]^=1;\n            deg[y]^=1;\n        }\n\n        if(!dfs(1,0) || ans.size()<n-1)\n        {\n            printf(\"NO\\n\");\n        }\n        else\n        {\n            printf(\"YES\\n\");\n            for(int i=0;i<ans.size();i++)\n            {\n                printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n            }\n        }\n\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "trees"], "dificulty": "2900", "interactive": false}