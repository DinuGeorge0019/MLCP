{
    "link": "https://codeforces.com//contest/596/problem/A",
    "problemId": "40905",
    "problem_idx": "A",
    "shortId": "596A",
    "contest_number": "596",
    "problem_submissions": {
        "E": [
            14284902,
            14410276,
            14285890,
            14836358
        ],
        "A": [
            14282529,
            14272331,
            14272408,
            14272249,
            14272247,
            14272132,
            14272036,
            14272062,
            14273974,
            14272466,
            14272094,
            14272742,
            14272840,
            14272048,
            14272087,
            14272349,
            14272225,
            14272447,
            14273354,
            14273114
        ],
        "D": [
            14280833,
            14284455,
            14282588,
            14285386,
            14285067,
            14284298,
            14286251,
            14285939,
            14284050,
            14285941,
            14286108,
            14293470,
            14284179
        ],
        "C": [
            14276112,
            14278736,
            14278325,
            14279291,
            14278970,
            14277576,
            14282655,
            14280088,
            14281778,
            14280140,
            14281205,
            14281281,
            14279114,
            14277665,
            14278438,
            14279354,
            14285136,
            14283954,
            14281786
        ],
        "B": [
            14272947,
            14272778,
            14273548,
            14272930,
            14272933,
            14273058,
            14272243,
            14272568,
            14274807,
            14272965,
            14272538,
            14274186,
            14273926,
            14272409,
            14272384,
            14272994,
            14273180,
            14273634,
            14274094,
            14274290
        ]
    },
    "name": "A. Wilbur and Swimming Pool",
    "statement": "After making bad dives into swimming pools, Wilbur wants to build a\r\nswimming pool in the shape of a rectangle in his backyard. He has set up\r\ncoordinate axes, and he wants the sides of the rectangle to be parallel\r\nto them. Of course, the area of the rectangle must be positive. Wilbur\r\nhad all four vertices of the planned pool written on a paper, until his\r\nfriend came along and erased some of the vertices.Now Wilbur is\r\nwondering, if the remaining vertices of the initial rectangle give\r\nenough information to restore the area of the planned swimming pool.\r\n",
    "solutions": [
        "//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nset<int> x, y;\nmap<int, int> cntx, cnty;\n\nvoid ex () {\n    cout << -1 << endl;\n    exit(0);\n}\n\nint32_t main () {\n    ios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        int a, b; cin >> a >> b;\n        cntx[a]++;\n        cnty[b]++;\n        x.insert(a);\n        y.insert(b);    \n    }\n    if ((int) x.size() == 2 && (int) y.size() == 2) {\n        auto it1 = x.begin(); if (cntx[*it1] > 2) ex(); it1++;if (cntx[*it1] > 2) ex();\n        auto it2 = y.begin(); if (cnty[*it2] > 2) ex(); it2++;if (cnty[*it2] > 2) ex();\n        cout << (*it1 - *(x.begin())) * (*it2 - *(y.begin()));\n    } else {\n        cout << -1; \n    }\n        \n            \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Wilbur and Swimming Pool.json",
    "editorial_link": "https://codeforces.com//blog/entry/21599",
    "editorial": "It is a necessary and sufficient condition that we have exactly 2\r\ndistinct values for and . If we have less than 2 distinct values for any\r\nvariable, then there is no way to know the length of that dimension. If\r\nthere are at least 3 distinct values for any variable, then that means\r\nmore than 3 vertices lie on that dimension, which cannot happen since\r\nthere can be at most 2 vertices in a line segment. The area, if it can\r\nbe found, is just the difference of values of the coordinates times the\r\ndifference of values of the coordinates. Complexity: Code: Solution No\r\nmatter what, we make operations to make equal to . Once this is done, .\r\nThen no matter what, we must make operations to make equal to . In\r\ngeneral, to make we need to make operations, so in total we make\r\noperations. Complexity: Code: Solution Note that if there is an integer\r\nso that the number of equal to differs from the number of the given\r\nsquares whose weight equals , then the answer is automatically \"NO\".\r\nThis can be easily checked by using a map for the and the weights of the\r\nsquares and checking if the maps are the same. This step takes time. Let\r\nbe an integer, and let be the set of all so that . Let be the set of all\r\nspecial points so that the weight of is . Note that and have the same\r\nnumber of elements. Suppose that are the elements of . Let if or and .\r\nSuppose that are the elements of . Note that the point has to be labeled\r\nby for . Now, each special point is labeled. It remains to check if this\r\nis a valid labeling. This can be done by taking an array of vectors. The\r\nvector will denote the points with -coordinate . This vector can be\r\neasily made from the points given in time, and since the points are\r\nalready labeled, will denote the label for the point . Now, for all\r\npoints , the point (if it is special) and the point (if it is special)\r\nmust have a greater number than . This step takes a total of time.\r\nComplexity: Code: Solution Bonus: Can you do this problem in time?\r\nComments: This problem was inspired by the representation theory of the\r\ngroup of permutations (Representation theory of the Symmetric Group).\r\nEssential objects in the study of are Young diagrams and standard Young\r\ntableau (Young Tableau). The weight of a point as defined by the problem\r\nis basically the same thing as the content of a square in a standard\r\nYoung tableaux. If you have questions, feel free to message me. Let us\r\nsolve this problem using dynamic programming. First let us reindex the\r\ntrees by sorting them by -coordinate. Let where we would like to\r\nconsider the problem of if we only have trees standing where indicates\r\nthat tree falls right and if it falls left and indicates that tree falls\r\nright and if it falls left. We start with the case that Wilbur chooses\r\nthe left tree and it falls right. The plan is to calculate the expected\r\nlength in this scenario and multiply by the chance of this case\r\noccurring, which is . We can easily calculate what is the farthest right\r\ntree that falls as a result of this and call it . Then if this means the\r\nentire segment falls, from which the length of the ground covered by\r\ntrees in can be calculated. However, be careful when , as there may be\r\noverlapping covered regions when the tree falls right but the tree falls\r\nleft. If only , then we just consider adding the length of ground\r\ncovered by trees falling right and add to the value of the subproblem .\r\nThere is another interesting case where Wilbur chooses the left tree and\r\nit falls left. In this case we calculate the expected length and\r\nmultiply by the chance of this occurring, which is . The expected length\r\nof ground covered by the trees here is just the length contributed by\r\ntree falling left, which we must be careful calculating as there might\r\nbe overlapping covered regions with the th tree falling left and the th\r\ntree falling right. Then we also add the value of subproblem . Doing\r\nthis naively would take time, but this can be lowered to by\r\nprecalculating what happens when tree falls left or right. We should\r\nalso consider the cases that Wilbur chooses the right tree, but these\r\ncases are analogous by symmetry. Complexity: Code: Solution Solution 1:\r\nSuppose that is a string in the query. Reverse and the direction of all\r\nthe moves that can be made on the table. Note that starting at any point\r\nthat is part of a cycle, there is a loop and then edges that go out of\r\nthe loop. So, for every point, it can be checked by dfs whether the can\r\nbe made by starting at that point by storing what is in the cycle.\r\nMoreover, note that in the reversed graph, each point can only be a part\r\nof one cycle. Therefore, the total time for the dfs in a query is . This\r\nis good enough for queries to run in time. Complexity: where is the\r\nnumber of distinct characters in the table, and is the query string for\r\nthe th query. Code: Solution Solution 2 (Actually too slow, see comment\r\nby waterfalls below for more details): For each string , dfs from every\r\nnode that has in degree equal to in the original graph. There will be a\r\npath which leads into a cycle after which anything in the cycle can be\r\nused any number of times in . Only every node with in degree equal to\r\nhas to be checked because every path which leads to a cycle is part of a\r\nlarger path which starts with a vertex of in degree that leads into a\r\ncycle. This solution is slower, but it works in practice since it is\r\nreally hard for a string to match so many times in the table. Each query\r\nwill take time, but it is much faster in practice. Complexity: where is\r\nthe number of distinct characters in the table, and is the query string\r\nof the th query.\r\n",
    "hint": []
}