{
    "link": "https://codeforces.com//contest/2022/problem/C",
    "problemId": "2947276",
    "problem_idx": "C",
    "shortId": "2022C",
    "contest_number": "2022",
    "problem_submissions": {
        "D1": [
            285726010,
            285732443,
            285720467,
            285721725,
            285710598,
            285716496,
            285709185,
            285722223,
            285721840,
            285726265,
            285729782,
            285729870,
            285772115,
            285771713,
            285716249,
            285713460,
            285712248,
            285718533,
            285715843
        ],
        "E2": [
            285719910,
            285720748,
            285735574,
            285735176,
            288055359,
            286524378,
            285733091,
            285771493,
            285770412,
            285770170,
            285769301
        ],
        "E1": [
            285717777,
            285720862,
            285735538,
            285732412,
            285730131,
            285734694,
            285730466,
            285740393,
            285736961,
            285737293,
            285738689,
            285733822,
            285723809
        ],
        "C": [
            285713470,
            285709435,
            285713964,
            285712717,
            285726534,
            285712313,
            285728850,
            285716262,
            285717872,
            285721376,
            285719625,
            285718527,
            285713136,
            285713916,
            285709969,
            285709168,
            285707306,
            285710892,
            285710354
        ],
        "B": [
            285703660,
            285702595,
            285706421,
            285702197,
            285705976,
            285703966,
            285719780,
            285706485,
            285711437,
            285705925,
            285707565,
            285707987,
            285708651,
            285708053,
            285702275,
            285704156,
            285708490,
            285702360,
            285704264
        ],
        "A": [
            285702679,
            285701420,
            285703196,
            285701332,
            285704286,
            285701973,
            285705578,
            285709500,
            285703987,
            285704902,
            285704417,
            285704940,
            285701496,
            285701330,
            285702274,
            285701454,
            285701489,
            285702531
        ],
        "D2": [
            286191597,
            285736183,
            290850953,
            285816124
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135095",
    "editorial": "Step 1We will use dynamic programming to keep track of the maximum\r\nnumber of votes lvaro can secure as we move from column to column (note\r\nthat there are many ways to implement the DP, we will use the easiest to\r\nunderstand). An important observation is that if you use a horizontal\r\npiece in one row, you also have to use it in the other to avoid leaving\r\nholes.\r\n",
    "name": "C. Gerrymandering",
    "statement": "We all steal a little bit. But I have only one hand, while my\r\nadversaries have two. lvaro Obreg n lvaro and Jos are the only\r\ncandidates running for the presidency of Tepito, a rectangular grid of 2\r\nrows and n columns, where each cell represents a house. It is guaranteed\r\nthat n is a multiple of 3.Under the voting system of Tepito, the grid\r\nwill be split into districts, which consist of any 3 houses that are\r\nconnected^{\r\ntext{ }}. Each house will belong to exactly one district.Each district\r\nwill cast a single vote. The district will vote for lvaro or Jos\r\nrespectively if at least 2 houses in that district select them.\r\nTherefore, a total of\r\nfrac{2n}{3} votes will be cast.As lvaro is the current president, he\r\nknows exactly which candidate each house will select. If lvaro divides\r\nthe houses into districts optimally, determine the maximum number of\r\nvotes he can get.^{\r\ntext{ }}A set of cells is connected if there is a path between any 2\r\ncells that requires moving only up, down, left and right through cells\r\nin the set.\r\n",
    "solutions": [
        "#line 1 \"library/Template/template.hpp\"#include <bits/stdc++.h>using namespace std;\u00a0#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin())\u00a0using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff;\u00a0template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));}\u00a0template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << \"P(\" << p.first << \", \" << p.second << \")\";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << \"{\";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");    }    os << \"}\";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << \"{\";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << \"(\" << itr->first << \", \" << itr->second << \")\";        itr++;        if (itr != map_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << \"{\";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << '\\n';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != ',' && a[i] != '\\0'; i++)        cerr << a[i];    cerr << \":\" << b << \" \";    _show(i + 1, a, c...);}#line 2 \"library/Utility/fastio.hpp\"#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf\u00a0uint32_t pil = 0, pir = 0, por = 0;\u00a0struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | '0';                n /= 10;            }        }    }} constexpr pre;\u00a0inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = '\\n';}\u00a0inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;}\u00a0void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));}\u00a0void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));}\u00a0template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);}\u00a0template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < '-');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == '-') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while ('0' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }}\u00a0void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);}\u00a0template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);}\u00a0template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);}\u00a0void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);}\u00a0void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);}\u00a0template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = '-', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | '0';        obuf[por + 1] = (x - q * 10) | '0';        por += 2;    } else        obuf[por++] = x | '0';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;}\u00a0template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);}\u00a0void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);}\u00a0template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(' ');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(' ');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }}\u00a0void print() {    wt('\\n');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(' ');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio\u00a0using fastio::flush;using fastio::print;using fastio::read;\u00a0inline void first(bool i = true) {    print(i ? \"first\" : \"second\");}inline void Alice(bool i = true) {    print(i ? \"Alice\" : \"Bob\");}inline void Takahashi(bool i = true) {    print(i ? \"Takahashi\" : \"Aoki\");}inline void yes(bool i = true) {    print(i ? \"yes\" : \"no\");}inline void Yes(bool i = true) {    print(i ? \"Yes\" : \"No\");}inline void No() {    print(\"No\");}inline void YES(bool i = true) {    print(i ? \"YES\" : \"NO\");}inline void NO() {    print(\"NO\");}inline void Yay(bool i = true) {    print(i ? \"Yay!\" : \":(\");}inline void Possible(bool i = true) {    print(i ? \"Possible\" : \"Impossible\");}inline void POSSIBLE(bool i = true) {    print(i ? \"POSSIBLE\" : \"IMPOSSIBLE\");}\u00a0/** * @brief Fast IO */#line 3 \"sol.cpp\"\u00a0void solve(int _rot) {    // write(\"Case #\"+to_string(_rot)+\": \");    int n;    read(n);    string S, T;    read(S, T);    auto ch = [&](char A, char B, char C) -> int {        int cnt = (A == 'A') + (B == 'A') + (C == 'A');        return cnt >= 2;    };\u00a0    vector dp(n + 1, vector<int>(5, -inf));    dp[0][0] = 0;    rep(i, 0, n) {        // 0        if (i + 2 < n) {            chmax(dp[i + 3][0], dp[i][0] + ch(S[i], S[i + 1], S[i + 2]) +                                    ch(T[i], T[i + 1], T[i + 2]));        }        if (i + 1 < n) {            chmax(dp[i + 1][1], dp[i][0] + ch(S[i], T[i], T[i + 1]));            chmax(dp[i + 1][2], dp[i][0] + ch(T[i], S[i], S[i + 1]));        }        // 1        if (i + 2 < n) {            chmax(dp[i + 1][4], dp[i][1] + ch(S[i], S[i + 1], S[i + 2]));        }        if (i + 1 < n) {            chmax(dp[i + 2][0], dp[i][1] + ch(S[i], S[i + 1], T[i + 1]));        }        // 2        if (i + 2 < n) {            chmax(dp[i + 1][3], dp[i][2] + ch(T[i], T[i + 1], T[i + 2]));        }        if (i + 1 < n) {            chmax(dp[i + 2][0], dp[i][2] + ch(T[i], T[i + 1], S[i + 1]));        }        // 3        if (i + 2 < n) {            chmax(dp[i + 2][2], dp[i][3] + ch(S[i], S[i + 1], S[i + 2]));        }        // 4        if (i + 2 < n) {            chmax(dp[i + 2][1], dp[i][4] + ch(T[i], T[i + 1], T[i + 2]));        }    }    int ret = MAX(dp[n]);    print(ret);}\u00a0int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Gerrymandering.json"
}