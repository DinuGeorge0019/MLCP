{
    "link": "https://codeforces.com//contest/525/problem/A",
    "problemId": "25275",
    "problem_idx": "A",
    "shortId": "525A",
    "contest_number": "525",
    "problem_submissions": {
        "E": [
            10469529,
            10465773,
            10462320,
            10473852,
            10470314,
            10468913,
            10471407,
            10472352,
            10471463,
            10468119,
            10482016
        ],
        "A": [
            10466492,
            10459383,
            10459851,
            10468884,
            10459356,
            10464661,
            10460865,
            10459447,
            10463645,
            10460601,
            10459420,
            10459625,
            10468470,
            10464011,
            10460662,
            10460403,
            10460186,
            10460076,
            10465668,
            10459793
        ],
        "D": [
            10466031,
            10468890,
            10468989,
            10474860,
            10468593,
            10472101,
            10470926,
            10472770,
            10473464,
            10480430,
            10472569,
            10473468,
            10468745,
            10475146
        ],
        "C": [
            10463905,
            10462286,
            10467821,
            10468051,
            10468445,
            10463570,
            10464786,
            10471337,
            10464431,
            10462510,
            10465576,
            10466372,
            10462777,
            10467129,
            10480410,
            10469681,
            10469099,
            10467204
        ],
        "B": [
            10459849,
            10460170,
            10461961,
            10469584,
            10459611,
            10459522,
            10463289,
            10460886,
            10459674,
            10459690,
            10460416,
            10461920,
            10462421,
            10467148,
            10463544,
            10464761,
            10465220,
            10462234,
            10464721,
            10464494
        ]
    },
    "name": "A. Vitaliy and Pie",
    "statement": "After a hard day Vitaly got very hungry and he wants to eat his favorite\r\npotato pie. But it’s not that simple. Vitaly is in the first room of the\r\nhouse with room located in a line and numbered starting from one from\r\nleft to right. You can go from the first room to the second room, from\r\nthe second room to the third room and so on you can go from the ()-th\r\nroom to the -th room. Thus, you can go to room only from room .The\r\npotato pie is located in the -th room and Vitaly needs to go there. Each\r\npair of consecutive rooms has a door between them. In order to go to\r\nroom from room , you need to open the door between the rooms with the\r\ncorresponding key. In total the house has several types of doors\r\n(represented by uppercase Latin letters) and several types of keys\r\n(represented by lowercase Latin letters). The key of type can open the\r\ndoor of type if and only if and are the same letter, written in\r\ndifferent cases. For example, key can open door .Each of the first rooms\r\ncontains exactly one key of some type that Vitaly can use to get to next\r\nrooms. Once the door is open with some key, Vitaly won’t get the key\r\nfrom the keyhole but he will immediately run into the next room. In\r\nother words, each key can open no more than one door.Vitaly realizes\r\nthat he may end up in some room without the key that opens the door to\r\nthe next room. Before the start his run for the potato pie Vitaly can\r\nbuy any number of keys of any type that is guaranteed to get to room\r\n.Given the plan of the house, Vitaly wants to know what is the minimum\r\nnumber of keys he needs to buy to surely get to the room , which has a\r\ndelicious potato pie. Write a program that will help Vitaly find out\r\nthis number.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << \" = \" << ccc << endl;\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tn,s[500];\n\nint main(){\n\tcin >> n;\n\tint\tres = 0;\n\tFP( i,1,n-1 ){\n\t\tchar\ta,b;\n\t\tscanf(\" %c %c\",&a,&b);\n\t\ts[a]++;\n\t\tif( s[b-'A'+'a']==0 )\tres++;\n\t\telse{\t\n\t\t\ts[b-'A'+'a']--;\n\t\t}\n\t}\n\tcout << res << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "hashing",
        "strings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Vitaliy and Pie.json",
    "editorial_link": "https://codeforces.com//blog/entry/17119",
    "editorial": "To solve this problem we need to use array cnt[]. In this array we will store number of keys of every type, which we already found in rooms, but didn't use. Answer will store in variable ans.\n\nNow, we iterate on string. If current element of string si is lowercase letter (key), we make cnt[si]++. Else if current element of string si uppercase letter (door) and cnt[tolower(si)]?>?0, we make cnt[tolower(si)]--, else we make ans++. It remains only to print ans.\n\nAsymptotic behavior of this solution  O(|s|), where |s|  length of string s.",
    "hint": []
}