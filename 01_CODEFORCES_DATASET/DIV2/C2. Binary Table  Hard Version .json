{"link": "https://codeforces.com//contest/1440/problem/C2", "problemId": "798723", "problem_idx": "C2", "shortId": "1440C2", "contest_number": "1440", "problem_submissions": {"E": [98728391, 98730128, 98724308, 98735269, 98730903, 98733313, 98735079, 98720072, 98721791, 98776063, 98776025], "B": [98718215, 98690348, 98694152, 98694066, 98717379, 98694490, 98698050, 98691119, 98694372, 98737100, 98701238, 98693027, 98692019, 98693130, 98694602, 98691874, 98694997, 98690784], "D": [98713473, 98716992, 98721114, 98895168, 98737070], "C1": [98700917, 98704185, 98727324, 98710881, 98711510, 98720805, 98703327, 98773521, 98732444, 98719724, 98704756, 98707436, 98707143, 98709098, 98710542, 98704302, 98708466], "C2": [98700859, 98709321, 98775076, 98710936, 98720737, 98774165, 98704870, 98707384, 98707212, 98709164, 98710454, 98714510, 98708395], "A": [98687569, 98688718, 98687545, 98693499, 98688756, 98688775, 98687763, 98689068, 98687766, 98699186, 98688328, 98687540, 98687537, 98688127, 98688428, 98687491, 98687961]}, "name": "C2. Binary Table  Hard Version ", "statement": "You are given a binary table of size n\r\ntimes m. This table consists of symbols 0 and 1.You can make such\r\noperation: select 3 different cells that belong to one 2\r\ntimes 2 square and change the symbols in these cells (change 0 to 1 and\r\n1 to 0).Your task is to make all symbols in the table equal to 0. You\r\nare allowed to make at most nm operations. It can be proved, that it is\r\nalways possible.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> ans[3];\nint a[100][100];\n\nvoid flip(int i, int j, int id) {\n\tif (id >= 0) ans[id].emplace_back(i+1, j+1);\n\ta[i][j] ^= 1;\n}\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tans[0].clear();\n\tans[1].clear();\n\tans[2].clear();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\ta[i][j] = c - '0';\n\t\t}\n\t}\n\n\tfor (int i = n-1; i >= 2; i--) {\n\t\tfor (int j = m-1; j >= 0; j--) {\n\t\t\tif (a[i][j] == 1) {\n\t\t\t\t// i j, i-1 j, i-1 j-1\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tflip(i, j, 0);\n\t\t\t\t\tflip(i-1, j, 1);\n\t\t\t\t\tflip(i-1, j-1, 2);\n\t\t\t\t} else {\n\t\t\t\t\tflip(i, j, 0);\n\t\t\t\t\tflip(i-1, j, 1);\n\t\t\t\t\tflip(i-1, j+1, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = m-1; j >= 2; j--) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tif (a[i][j] == 1) {\n\t\t\t\tflip(i, j, 0);\n\t\t\t\tflip(i, j-1, 1);\n\t\t\t\tflip(i^1, j-1, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int msk = 0; msk < (1 << 4); msk++) {\n\t\t// flip all\n\t\tint gg = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (msk & (1 << gg)) {\n\t\t\t\t\tflip(i, j, -1);\n\t\t\t\t\tflip(i^1, j, -1);\n\t\t\t\t\tflip(i, j^1, -1);\n\t\t\t\t}\n\t\t\t\tgg++;\n\t\t\t}\n\t\t}\n\n\t\t// is feasible\n\t\tbool is_feasible = 1;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (a[i][j]) is_feasible = 0;\n\t\t\t}\n\t\t}\n\n\t\t// flip back\n\t\tgg = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (msk & (1 << gg)) {\n\t\t\t\t\tflip(i, j, -1);\n\t\t\t\t\tflip(i^1, j, -1);\n\t\t\t\t\tflip(i, j^1, -1);\n\t\t\t\t}\n\t\t\t\tgg++;\n\t\t\t}\n\t\t}\n\n\t\tif (is_feasible) {\n\t\t\t// output\n\t\t\tgg = 0;\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tif (msk & (1 << gg)) {\n\t\t\t\t\t\tflip(i, j, 0);\n\t\t\t\t\t\tflip(i^1, j, 1);\n\t\t\t\t\t\tflip(i, j^1, 2);\n\t\t\t\t\t}\n\t\t\t\t\tgg++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans[0].size() << '\\n';\n\tfor (int i = 0; i < ans[0].size(); i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcout << ans[j][i].first << ' ' << ans[j][i].second << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation"], "dificulty": "1900", "interactive": false}