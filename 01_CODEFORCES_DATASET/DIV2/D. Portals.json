{
    "link": "https://codeforces.com//contest/1271/problem/D",
    "problemId": "495936",
    "problem_idx": "D",
    "shortId": "1271D",
    "contest_number": "1271",
    "problem_submissions": {
        "F": [
            66961825,
            67036286,
            66974278,
            66959941,
            67028258
        ],
        "D": [
            66955004,
            66954300,
            66950258,
            66955211,
            66955727,
            66954986,
            66956735,
            66957222,
            66956606,
            66952705,
            66951493,
            66952458,
            66958655,
            66958760,
            66959470,
            66951305,
            66951037,
            66961080,
            66953125
        ],
        "E": [
            66949374,
            66950284,
            66955194,
            66945323,
            66950426,
            66952357,
            66949869,
            66952893,
            66953188,
            66956256,
            66958878,
            66957745,
            66946179,
            66952300,
            66952751,
            66953634,
            66960610,
            66957983,
            66952356,
            66960241
        ],
        "C": [
            66945489,
            66944768,
            66945892,
            66949422,
            66948266,
            66947645,
            66944925,
            66945427,
            66944821,
            66946803,
            66944977,
            66945954,
            66962107,
            66945691,
            66947213,
            66947154,
            66945982,
            66945961,
            66946143,
            66945702
        ],
        "B": [
            66942838,
            66941728,
            66942682,
            66945965,
            66941748,
            66944405,
            66942218,
            66943112,
            66940283,
            66944697,
            66941782,
            66942898,
            66961125,
            66942570,
            66943103,
            66943908,
            66943600,
            66947332,
            66942421,
            66942779
        ],
        "A": [
            66938999,
            66939105,
            66938928,
            66942646,
            66939987,
            66939135,
            66939726,
            66939564,
            66938824,
            66939325,
            66939118,
            66940343,
            66960484,
            66938913,
            66939541,
            66940419,
            66940083,
            66938911,
            66938937,
            66942932
        ]
    },
    "name": "D. Portals",
    "statement": "You play a strategic video game . In this game you control a large army,\r\nand your goal is to conquer n castles of your opponent.Let\u2019s describe\r\nthe game process in detail. Initially you control an army of k warriors.\r\nYour enemy controls n castles; to conquer the i-th castle, you need at\r\nleast a_i warriors (you are so good at this game that you don\u2019t lose any\r\nwarriors while taking over a castle, so your army stays the same after\r\nthe fight). After you take control over a castle, you recruit new\r\nwarriors into your army formally, after you capture the i-th castle, b_i\r\nwarriors join your army. Furthermore, after capturing a castle (or\r\nlater) you can defend it: if you leave at least one warrior in a castle,\r\nthis castle is considered . Each castle has an importance parameter c_i,\r\nand your total score is the sum of importance values over all defended\r\ncastles. There are two ways to defend a castle: if you are currently in\r\nthe castle i, you may leave one warrior to defend castle i; there are m\r\none-way portals connecting the castles. Each portal is characterised by\r\ntwo numbers of castles u and v . A portal can be used as follows: if you\r\nare currently in the castle u, you may send one warrior to defend castle\r\nv. Obviously, when you order your warrior to defend some castle, he\r\nleaves your army.You capture the castles in fixed order: you have to\r\ncapture the first one, then the second one, and so on. After you capture\r\nthe castle i (but only before capturing castle i + 1) you may recruit\r\nnew warriors from castle i, leave a warrior to defend castle i, and use\r\nany number of portals leading from castle i to other castles having\r\nsmaller numbers. As soon as you capture the next castle, these actions\r\nfor castle i won\u2019t be available to you.If, during some moment in the\r\ngame, you don\u2019t have enough warriors to capture the next castle, you\r\nlose. Your goal is to maximize the sum of importance values over all\r\ndefended castles (note that you may hire new warriors in the last\r\ncastle, defend it and use portals leading from it even after you capture\r\nit your score will be calculated afterwards).Can you determine an\r\noptimal strategy of capturing and defending the castles?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 5050, inF = 1e9 + 100;\n\nint n, m, k, a[N], b[N], c[N], best[N], dp[N][N];\nvector<int> vec[N];\n\nvoid input() {\n\tcin >> n >> m >> k;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i] >> b[i] >> c[i];\n\tiota(best, best + N, 0);\n\twhile (m--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (u > v)\n\t\t\tswap(u, v);\n\t\tbest[u] = max(best[u], v);\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tvec[i].push_back(0);\n\tfor (int i = 1; i <= n; i++)\n\t\tvec[best[i]].push_back(c[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(vec[i].begin() + 1, vec[i].end(), greater<int>());\n\t\tfor (int j = 1; j < vec[i].size(); j++)\n\t\t\tvec[i][j] += vec[i][j - 1];\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tdp[i][j] = -inF;\n\tdp[0][k] = 0;\n}\n\nvoid solve() {\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (dp[i][j] >= 0) {\n\t\t\t\tfor (int cnt = 0; cnt < vec[i].size() && j - cnt >= a[i + 1]; cnt++)\n\t\t\t\t\tdp[i + 1][j - cnt + b[i + 1]] = max(dp[i + 1][j - cnt + b[i + 1]], dp[i][j] + vec[i][cnt]);\n\t\t\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tinput();\n\tsolve();\n\tint ans = *max_element(dp[n + 1], dp[n + 1] + N);\n\tcout << (ans < 0? -1: ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Portals.json",
    "editorial_link": "https://codeforces.com/blog/entry/72247",
    "editorial": "Note, that for every castle there is some list of castles , such that\r\nyou can defend castle standing in the castle .The key observation is\r\nthat it\u00e2\u0080\u0099s always optimal to defend castle (assuming we decided to defend\r\nit) in the latest possible castle. Since it gives you more warriors in\r\nbetween of and (more freedom), it\u00e2\u0080\u0099s always optimal.We will prune all\r\nother \u00e2\u0080\u0099s except for the maximum one.Now our process looks like: Conquer\r\nnext castle, Acquire new warriors, Decide whether or not you you defend\r\nprevious castle , such that the current castle is in terms of the\r\nparagraph above. There might be several such to process for the current\r\ncastle. Since in this process we decide on each castle exactly only\r\nonce, the process can be simulated as a simple dynamic programming with\r\nstates \"number of castles conquered, number of warriors available\", it\u00e2\u0080\u0099s\r\npossible to compute this dp in , where is the total number of\r\nwarriors.Or you can use a greedy approach in . Just maintain the process\r\nabove, defending all the castles you can defend. In case it turns out\r\nyou are lacking few warriors later, just undo several defended castes.\r\nTo do so, just maintain undoable castles in a Heap or .\r\n"
}