{
    "link": "https://codeforces.com//contest/221/problem/D",
    "problemId": "1625",
    "problem_idx": "D",
    "shortId": "221D",
    "contest_number": "221",
    "problem_submissions": {
        "E": [
            3205051,
            2092800,
            2086150,
            2086057,
            2087298,
            2087155,
            2087149,
            2087018,
            2086854,
            2086766,
            2084177,
            85197769
        ],
        "D": [
            2077623,
            2076297,
            2081220,
            2080200,
            2077733,
            2077945,
            2078661,
            2078764,
            2079390,
            2078475,
            2078957,
            2078857,
            2079767,
            2079126,
            2080238,
            2080763,
            2080984
        ],
        "C": [
            2075002,
            2086554,
            2073629,
            2075934,
            2074814,
            2076079,
            2073608,
            2075600,
            2075194,
            2075398,
            2074548,
            2075699,
            2076113,
            2076291,
            2077149,
            2075454,
            2074363,
            2076715
        ],
        "B": [
            2074170,
            2074163,
            2072750,
            2073391,
            2074703,
            2076060,
            2073836,
            2074637,
            2073703,
            2073926,
            2074911,
            2074503,
            2075040,
            2074940,
            2073942,
            2073661,
            2075809
        ],
        "A": [
            2072835,
            2074357,
            2073486,
            2074025,
            2073249,
            2073912,
            2072457,
            2073442,
            2072552,
            2072801,
            2072681,
            2073490,
            2073385,
            2074053,
            2072948,
            2072853,
            2073301
        ]
    },
    "name": "D. Little Elephant and Array",
    "statement": "The Little Elephant loves playing with arrays. He has array , consisting\r\nof positive integers, indexed from 1 to . Let\u2019s denote the number with\r\nindex as . Additionally the Little Elephant has queries to the array,\r\neach query is characterised by a pair of integers and . For each query\r\nthe Little Elephant has to count, how many numbers exist, such that\r\nnumber occurs exactly times among numbers .Help the Little Elephant to\r\ncount the answers to all queries.\r\n",
    "solutions": [
        "#include <vector>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define sz size\n#define re return\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define abs(x) ((x) < 0 ? -(x) : (x))\n#define INF 2000000000\n#define sqr(x) ((x) * (x))\n#define all(x) x.begin(), x.end()\n\nint n, a[111111], b[111111], l, m, res, ll ,rr;\nint c[111111], d[111111], dp[500][111111];\nvector < int > v;\n              \nint main() {\n\n#ifndef ONLINE_JUDGE\t          \n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tb[i] = a[i];\n\t}\n\tsort(b + 1, b + n + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(b[i] != b[i - 1]) ++l;\n\t\tc[l]++;\n\t\td[l] = b[i];\n\t}\n\tfor(int i = 1; i <= l; i++)\n\t\tif(c[i] >= d[i])\n\t\t\tv.pb(d[i]);\n\tfor(int i = 0; i < v.sz(); i++)\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\tif(a[j] == v[i]) dp[i][j]++;\n\t\t}      \n\n\t\n\tfor(int i = 1; i <= m; i++) {\n\t\tcin >> ll >> rr;\n\t\tres = 0;\n\t\tfor(int j = 0; j < v.sz(); j++) {\n\t\t\tif(dp[j][rr] - dp[j][ll - 1] == v[j]) res++;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\t\t\t\n\treturn 0;\n}\n\n\n\t\n\t\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Little Elephant and Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/5177",
    "editorial": "This problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.\n\nWe will solve this problem in offline. For each x (0???x?<?n) we should keep all the queries that end in x. Iterate that x from 0 to n?-?1. Also we need to keep some array D such that for current x Dl?+?Dl?+?1?+?...?+?Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P|???t, you need to add 1 to DP[|P|?-?t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P|?>?t, you need to subtract 2 from DP[|P|?-?t?-?1], in order to close current interval and cancel previous. Finally, if |P|?>?t?+?1, then you need additionally add 1 to DP[|P|?-?t?-?2] to cancel previous close of the interval."
}