{
    "link": "https://codeforces.com//contest/400/problem/E",
    "problemId": "6827",
    "problem_idx": "E",
    "shortId": "400E",
    "contest_number": "400",
    "problem_submissions": {
        "D": [
            5942946,
            5938217,
            5938966,
            5937625,
            5935311,
            5938926,
            5940475,
            5940990,
            5937079,
            5944638,
            5955647,
            5943946,
            5937794,
            5946557,
            5936465,
            5939830,
            5950427,
            5941016
        ],
        "E": [
            5940590,
            5942014,
            5941822,
            5942894,
            5940333,
            5944467,
            5944452,
            5943295,
            5943002,
            5942790,
            5935656,
            5940436,
            5940115,
            5945285,
            5940524,
            5941127,
            5943876,
            5942957
        ],
        "C": [
            5934630,
            5936091,
            5936231,
            5935790,
            5939164,
            5935792,
            5937387,
            5938564,
            5934697,
            5938828,
            5935714,
            5935729,
            5935058,
            5936232,
            5935137,
            5934332,
            5936129,
            5935750,
            5937003
        ],
        "B": [
            5933775,
            5934595,
            5934975,
            5934196,
            5940471,
            5936516,
            5935696,
            5934075,
            5933798,
            5937278,
            5934053,
            5934760,
            5933911,
            5934786,
            5933892,
            5938918,
            5934764,
            5934389,
            5934127
        ],
        "A": [
            5933588,
            5933768,
            5934022,
            5933647,
            5933945,
            5933905,
            5933697,
            5933650,
            5933599,
            5936558,
            5933618,
            5933930,
            5933611,
            5933796,
            5933591,
            5939685,
            5933878,
            5933786,
            5933680
        ]
    },
    "name": "E. Inna and Binary Logic",
    "statement": "Inna is fed up with jokes about female logic. So she started using\r\nbinary logic instead.Inna has an array of elements . Girl likes to train\r\nin her binary logic, so she does an exercise consisting of stages: on\r\nthe first stage Inna writes out all numbers from array , on the -th\r\nstage girl writes all elements of array , which consists of integers;\r\nthe -th integer of array is defined as follows: . Here AND is bit-wise\r\nbinary logical operation.Dima decided to check Inna\u2019s skill. He asks\r\nInna to change array, perform the exercise and say the sum of all\r\nelements she wrote out during the current exercise.Help Inna to answer\r\nthe questions!\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\n\nll Q(pair<int, int> w)\n{\n    ll t=w.second-w.first;\n    return t*(t+1)/2;\n}\n\nstruct S\n{\n    ll s;\n    set<pair<int, int>> a;\n    S() : s(0) {}\n    void init(vector<int> p)\n    {\n        sort(p.begin(), p.end());\n        for (int i=0, j;i<p.size();i=j)\n        {\n            for (j=i+1;j<p.size()&&p[j-1]+1==p[j];++j);\n            auto z=mp(p[i], p[j-1]+1);\n            a.insert(z);\n            s+=Q(z);\n        }\n    }\n    void add(int p)\n    {\n        int L=p, R=p+1;\n        auto il=a.lower_bound(mp(p, int(1e9)));\n        if (il!=a.begin())\n        {\n            --il;\n            if (p<il->second) return;\n            if (il->second==L)\n            {\n                auto z=*il;\n                a.erase(il);\n                s-=Q(z);\n                L=z.first;\n            }\n        }\n        auto ir=a.lower_bound(mp(p+1, int(-1e9)));\n        if (ir!=a.end())\n        {\n            if (p+1==ir->first)\n            {\n                auto z=*ir;\n                a.erase(ir);\n                s-=Q(z);\n                R=z.second;\n            }\n        }\n        a.insert(mp(L, R));\n        s+=Q(mp(L, R));\n    }\n    void del(int p)\n    {\n        auto it=a.lower_bound(mp(p, int(1e9)));\n        if (it==a.begin()) return;\n        --it;\n        if (it->second<=p) return;\n        auto z=*it;\n        a.erase(it);\n        s-=Q(z);\n        if (z.first<p)\n        {\n            a.insert(mp(z.first, p));\n            s+=Q(mp(z.first, p));\n        }\n        if (p+1<z.second)\n        {\n            a.insert(mp(p+1, z.second));\n            s+=Q(mp(p+1, z.second));\n        }\n    }\n} s[17];\nconst int N=10+(1e5);\nint n, m, a[N];\nint main()\n{\n    scanf(\"%d %d\", &n, &m);\n    for (int i=0;i<n;++i) scanf(\"%d\", &a[i]);\n    for (int b=0;b<17;++b)\n    {\n        vector<int> t;\n        for (int i=0;i<n;++i) if (a[i]&(1<<b)) t.push_back(i);\n        s[b].init(t);\n    }\n    for (int i=0;i<m;++i)\n    {\n        int p, v; scanf(\"%d %d\", &p, &v); --p;\n        ll rs=0;\n        for (int b=0;b<17;++b)\n        {\n            if (a[p]&(1<<b)) s[b].del(p);\n            if (v&(1<<b)) s[b].add(p);\n            rs+=s[b].s*(1<<b);\n        }\n        a[p]=v;\n        printf(\"%I64d\\n\", rs);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Inna and Binary Logic.json",
    "editorial_link": "https://codeforces.com//blog/entry/10755",
    "editorial": "Let\u00e2\u0080\u0099s solve this for each bit separately. Fix some bit. Let\u00e2\u0080\u0099s put 1 if\r\nthe number contains bit and 0 otherwise. Now we receive the sequence,\r\nfor example . Now let\u00e2\u0080\u0099s look on sequence of 1 without 0, for this\r\nsequence current bit will be added to the sum on the first stage (with\r\nall numbers single) on the second stage (with all neighbouring pairs) on\r\nthe third stage and so on, the number of appiarence for sequence of\r\nneighbouring 1 is a formula which depends on the length of sequence\r\nonly. The last is to learn how to modificate. For each bit let\u00e2\u0080\u0099s save\r\nthe set of sequence of 1. When the bit is deleted, one sequence is\r\nsepereted on two, or decreases its length by 1. When the bit is added,\r\nnew sequence of length 1 appears, or some sequence increases its lentgh\r\nby 1 or two sequence transform to 1 biger sequence.\r\n"
}