{"link": "https://codeforces.com//contest/527/problem/C", "problemId": "24744", "problem_idx": "C", "shortId": "527C", "contest_number": "527", "problem_submissions": {"D": [10320998, 10323329, 10320418, 10316376, 10320868, 10323389, 10322440, 10320232, 10321604, 10323582, 10321959, 10322883, 10324771, 10323891, 10324342, 10325751, 10316899, 10320622], "C": [10319281, 10317608, 10318719, 10321621, 10319197, 10319745, 10320049, 10325822, 10321996, 10320609, 10320450, 10322500, 10322047, 10318021, 10323195, 10322166, 10322519, 10313548], "B": [10316733, 10315414, 10316286, 10320342, 10316974, 10315178, 10316059, 10315345, 10320022, 10315992, 10316397, 10319742, 10317580, 10315069, 10315584, 10318949, 10318891, 10343112, 10316418], "A": [10313000, 10313055, 10313796, 10312916, 10313836, 10313217, 10312846, 10312806, 10313753, 10312901, 10312783, 10313020, 10313144, 10312917, 10312793, 10312900, 10314293, 10313134], "E": [11345011]}, "name": "C. Glass Carving", "statement": "Leonid wants to become a glass carver (the person who creates beautiful\r\nartworks by cutting the glass). He already has a rectangular mm mm sheet\r\nof glass, a diamond glass cutter and lots of enthusiasm. What he lacks\r\nis understanding of what to carve and how.In order not to waste time, he\r\ndecided to practice the technique of carving. To do this, he makes\r\nvertical and horizontal cuts through the entire sheet. This process\r\nresults in making smaller rectangular fragments of glass. Leonid does\r\nnot move the newly made glass fragments. In particular, a cut divides\r\neach fragment of glass that it goes through into smaller fragments.After\r\neach cut Leonid tries to determine what area the largest of the\r\ncurrently available glass fragments has. Since there appear more and\r\nmore fragments, this question takes him more and more time and distracts\r\nhim from the fascinating process.Leonid offers to divide the labor he\r\nwill cut glass, and you will calculate the area of the maximum fragment\r\nafter each cut. Do you agree?\r\n", "solutions": ["#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <set>\nusing namespace std;\n\ntypedef long long ll;\nint w, h, n;\nset<int> a1, a2;\nmultiset<int> b1, b2;\nset<int>::iterator it1, it2;\nll ans;\n\nchar ch, type;\ninline int read() {\n\twhile (ch = getchar(), ch < '0' || ch > '9');\n\tint res = ch - 48;\n\twhile (ch = getchar(), ch >= '0' && ch <= '9') res = res * 10 + ch - 48;\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\ta1.insert(0); a1.insert(w);\n\ta2.insert(0); a2.insert(h);\n\tb1.insert(w); b2.insert(h);\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (type = getchar(), type != 'H' && type != 'V');\n\t\tint t = read();\n\t\tif (type == 'H') {\n\t\t\tit1 = a2.lower_bound(t);\n\t\t\tit2 = --it1; ++it1;\n\t\t\tint num = *it1 - *it2;\n\t\t\tb2.erase(b2.find(num));\n\t\t\ta2.insert(t);\n\t\t\tb2.insert(t - *it2);\n\t\t\tb2.insert(*it1 - t);\n\t\t}\n\t\telse {\n\t\t\tit1 = a1.lower_bound(t);\n\t\t\tit2 = --it1; ++it1;\n\t\t\tint num = *it1 - *it2;\n\t\t\tb1.erase(b1.find(num));\n\t\t\ta1.insert(t);\n\t\t\tb1.insert(t - *it2);\n\t\t\tb1.insert(*it1 - t);\n\t\t}\n\t\tans = (ll)(*b1.rbegin()) * (*b2.rbegin());\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "implementation"], "dificulty": "1500", "interactive": false}