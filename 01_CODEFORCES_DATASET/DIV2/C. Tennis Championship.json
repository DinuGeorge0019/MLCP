{
    "link": "https://codeforces.com//contest/735/problem/C",
    "problemId": "82048",
    "problem_idx": "C",
    "shortId": "735C",
    "contest_number": "735",
    "problem_submissions": {
        "E": [
            22551909
        ],
        "D": [
            22544646,
            22538932,
            22538494,
            22533130,
            22538839,
            22534703,
            22542520,
            22538073,
            22538552,
            22544184,
            22540518,
            22540226,
            22540566,
            22541948,
            22536512,
            22543846,
            22534272,
            22543891,
            22542284,
            22535111
        ],
        "B": [
            22537273,
            22532854,
            22534320,
            22538199,
            22533929,
            22532194,
            22539115,
            22533382,
            22535165,
            22534258,
            22533972,
            22533579,
            22533796,
            22532602,
            22539678,
            22534871,
            22532255,
            22533784,
            22536534,
            22532104
        ],
        "C": [
            22534384,
            22535405,
            22546614,
            22545073,
            22541931,
            22538563,
            22536243,
            22534983,
            22543290,
            22541842,
            22536128,
            22536857,
            22538655,
            22536562,
            22534861,
            22538350,
            22539201,
            22542576,
            22543288,
            22543269
        ],
        "A": [
            22532849,
            22530580,
            22530636,
            22535838,
            22530703,
            22530451,
            22531034,
            22531009,
            22531797,
            22531370,
            22530550,
            22530672,
            22530851,
            22530651,
            22530865,
            22531281,
            22530612,
            22530842,
            22530502
        ]
    },
    "name": "C. Tennis Championship",
    "statement": "Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap\r\nBender doesn’t want to miss this event. There will be players\r\nparticipating, and the tournament will follow knockout rules from the\r\nvery first game. That means, that if someone loses a game he leaves the\r\ntournament immediately.Organizers are still arranging tournament grid\r\n(i.e. the order games will happen and who is going to play with whom)\r\nbut they have already fixed one rule: two players can play against each\r\nother only if the number of games one of them has already played from\r\nthe number of games the other one has already played. Of course, both\r\nplayers had to win all their games in order to continue participating in\r\nthe tournament.Tournament hasn’t started yet so the audience is a bit\r\nbored. Ostap decided to find out what is the maximum number of games the\r\nwinner of the tournament can take part in (assuming the rule above is\r\nused). However, it is unlikely he can deal with this problem without\r\nyour help.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define task \"DBG\"\n\nusing namespace std;\n\nconst int N = 1001;\n\nlong long dp[N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n  assert(freopen(task\".INP\", \"r\", stdin));\n  assert(freopen(task\".OUT\", \"w\", stdout));\n#endif // ONLINE_JUDGE\n\n  long long n;\n  cin >> n;\n  dp[0] = 1;\n  dp[1] = 2;\n  int i = 1;\n  while (dp[i] <= n) {\n    i++;\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  return cout << i - 1, 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Tennis Championship.json",
    "editorial_link": "https://codeforces.com//blog/entry/48659",
    "editorial": "Let us solve the inverse problem: at least how many competitors should be, if the champion will have n matches. Then there's obvious reccurrent formula: f(n+1)=f(n)+f(n-1) (Let us make the draw in a way, where the champion will play n matches to advance to finals and the runner-up played (n-1) matches to advance the final). So, we have to find the index of maximal fibunacci number which is no more that number in the input.\n",
    "hint": []
}