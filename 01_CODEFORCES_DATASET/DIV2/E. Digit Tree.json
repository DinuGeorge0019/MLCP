{"link": "https://codeforces.com//contest/716/problem/E", "problemId": "71759", "problem_idx": "E", "shortId": "716E", "contest_number": "716", "problem_submissions": {"D": [20744308, 20715273, 20712384, 20698605, 20701478, 20703552, 20702205, 20704228, 20701939, 20707973, 20706457, 20707569, 20706505, 20706746, 20706853, 20708058, 20712985, 20706596, 20702545, 20706258, 20710911, 20710377], "E": [20707330, 20706633, 57471482, 57471318, 20786861, 20925655], "C": [20688634, 20691024, 20700161, 20694588, 20693330, 20695251, 20692209, 20693550, 20695785, 20697429, 20695666, 20696475, 20696500, 20694424, 20694087, 20699957, 20710553, 20698572, 20699352, 20704716], "B": [20685444, 20688304, 20686329, 20686970, 24007938, 20689436, 20687334, 20687385, 20688481, 20689944, 20688816, 20691138, 20689052, 20691817, 20689042, 20688727, 20687466, 20689562, 20689097, 20691531, 20693092], "A": [20683347, 20683430, 20683470, 20683362, 23991578, 20684483, 20684599, 20683578, 20683497, 20684120, 20684147, 20685068, 20683750, 20684470, 20685278, 20683948, 20683393, 20683688, 20684344, 20683813, 20686732]}, "name": "E. Digit Tree", "statement": "ZS the Coder has a large tree. It can be represented as an undirected\r\nconnected graph of vertices numbered from to and edges between them.\r\nThere is a single digit written on each edge.One day, ZS the Coder was\r\nbored and decided to investigate some properties of the tree. He chose a\r\npositive integer , which is to , i.e. .ZS consider an of distinct\r\nvertices when if he would follow the shortest path from vertex to vertex\r\nand write down all the digits he encounters on his path in the same\r\norder, he will get a decimal representaion of an integer divisible by\r\n.Formally, ZS consider an ordered pair of distinct vertices interesting\r\nif the following states true: Let be the sequence of vertices on the\r\nshortest path from to in the order of encountering them; Let () be the\r\ndigit written on the edge between vertices and ; The integer is\r\ndivisible by . Help ZS the Coder find the number of interesting pairs!\r\n", "solutions": ["/*AMETHYSTS*/\n#pragma comment(linker, \"/STACK:1000000000\")\n#include <cstdio>\n#include <iostream>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <climits>\n#include <string>\n#include <queue>\n#include <memory.h>\n#include <unordered_map>\n#include <random>\n\n#define ll long long\n#define ld double\n#define pii pair <int, int>\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define ui unsigned ll\n\nusing namespace std;\n\nconst int maxn = 400010;\nvector <pii> ed[maxn];\nll st[maxn];\nll rst[maxn];\nll m;\nll phi = 0;\nll x[maxn], y[maxn];\nint d[maxn];\nll o;\n\nll my_pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\n\tif (b & 1) {\n\t\treturn (a * my_pow(a, b - 1)) % m;\n\t}\n\n\tll t = my_pow(a, b >> 1);\n\n\treturn (t * t) % m;\n}\n\nvoid make(int v, int p, ll a, ll b, int h) {\n\tx[v] = a;\n\ty[v] = b;\n\td[v] = h;\n\n\tfor (int i = 0; i < (int)ed[v].size(); i++) {\n\t\tint u = ed[v][i].first;\n\t\tint c = ed[v][i].second;\n\n\t\tif (u == p) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmake(u, v, (a + st[h] * c) % m, (b * 10 + c) % m, h + 1);\n\t}\n}\n\nmap <pair <ll, int>, int> now[maxn];\nint pos;\n\nll ans = 0;\n\nint go(int v, int p) {\n\tint it[2];\n\tit[0] = pos++;\n\tnow[it[0]][mp(x[v], 0)]++;\n\tnow[it[0]][mp((y[v] * rst[d[v]]) % m, 1)]++;\n\n\tint f = 1;\n\n\tll g = x[v] + y[v] * st[d[v]];\n\tg %= m;\n\n\tfor (int i = 0; i < (int)ed[v].size(); i++) {\n\t\tint u = ed[v][i].first;\n\n\t\tif (u == p) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tit[f] = go(u, v);\n\n\t\tif (now[it[f]].size() > now[it[f ^ 1]].size()) {\n\t\t\tf ^= 1;\n\t\t}\n\n\t\tfor (auto iter = now[it[f]].begin(); iter != now[it[f]].end(); iter++) {\n\t\t\tif (iter->first.second == 0) {\n\t\t\t\tll gg = (g - iter->first.first) * rst[2 * d[v]];\n\t\t\t\tgg %= m;\n\t\t\t\tif (gg < 0) {\n\t\t\t\t\tgg += m;\n\t\t\t\t}\n\n\t\t\t\tif (now[it[f ^ 1]].count(mp(gg, 1))) {\n\t\t\t\t\tans += (ll)iter->second * now[it[f ^ 1]][mp(gg, 1)];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tll gg = (g - iter->first.first * st[2 * d[v]]);\n\t\t\t\tgg %= m;\n\t\t\t\tif (gg < 0) {\n\t\t\t\t\tgg += m;\n\t\t\t\t}\n\n\t\t\t\tif (now[it[f ^ 1]].count(mp(gg, 0))) {\n\t\t\t\t\tans += (ll)iter->second * now[it[f ^ 1]][mp(gg, 0)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (auto iter = now[it[f]].begin(); iter != now[it[f]].end(); iter++) {\n\t\t\tnow[it[f ^ 1]][iter->first] += iter->second;\n\t\t}\n\n\t\tnow[it[f]].clear();\n\t}\n\n\treturn it[f ^ 1];\n}\n\nint main() {\n\tint n;\n\t\n\tcin >> n >> m;\n\n\tst[0] = 1;\n\n\tfor (int i = 1; i < maxn; i++) {\n\t\tst[i] = st[i - 1] * 10;\n\t\tst[i] %= m;\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint x, y, w;\n\n\t\tscanf(\"%d %d %d\", &x, &y, &w);\n\t\ted[x].push_back(mp(y, w));\n\t\ted[y].push_back(mp(x, w));\n\t}\n\t\n\tif (m == 1) {\n\t\tprintf(\"%lld\\n\", (ll)n * (n - 1));\n\t\treturn 0;\n\t}\n\n\tphi = m;\n\tll now = m;\n\n\tfor (int i = 2; i * i <= now; i++) {\n\t\tif (now % i == 0) {\n\t\t\tphi /= i;\n\t\t\tphi *= i - 1;\n\n\t\t\twhile (now % i == 0) {\n\t\t\t\tnow /= i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (now != 1) {\n\t\tphi /= now;\n\t\tphi *= now - 1;\n\t}\n\n\to = my_pow(10, phi - 1);\n\trst[0] = 1;\n\n\tfor (int i = 1; i < maxn; i++) {\n\t\trst[i] = my_pow(o, i);\n\t}\n\n\tmake(1, 1, 0, 0, 0);\n\n\tgo(1, 1);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "divide and conquer", "trees"], "dificulty": "2700", "interactive": false}