{
    "link": "https://codeforces.com//contest/610/problem/D",
    "problemId": "44289",
    "problem_idx": "D",
    "shortId": "610D",
    "contest_number": "610",
    "problem_submissions": {
        "E": [
            15053499,
            15051695,
            15055517,
            15468537,
            15054746,
            15092595
        ],
        "B": [
            15050877,
            15053921,
            27182434,
            15047165,
            15045211,
            15044820,
            15045928,
            15046116,
            15045542,
            15045130,
            15046665,
            15047371,
            15044370,
            15046773,
            15045049,
            15044516,
            15052695,
            15046983,
            15047646,
            15044510,
            15045948
        ],
        "D": [
            15049809,
            15046533,
            15053385,
            15053873,
            15049276,
            15049759,
            15052914,
            15052461,
            15053191,
            15053905,
            15053030,
            15054321,
            15054255,
            15054811,
            15051818,
            15053392,
            15053677,
            15054046,
            15054704
        ],
        "A": [
            15049788,
            15052508,
            15043466,
            15042823,
            15042879,
            15042700,
            15043682,
            15043766,
            15042783,
            15042798,
            15043007,
            15042601,
            15043336,
            15042897,
            15042861,
            15043393,
            15043051,
            15042935,
            15042657,
            15043356
        ],
        "C": [
            15043384,
            15054209,
            15050445,
            15052911,
            15053221,
            15051863,
            15048319,
            15049540,
            15049193,
            15049080,
            15050593,
            15048004,
            15048429,
            15051082,
            15049084,
            15050509,
            15050531,
            15050981,
            15051132,
            15048269
        ]
    },
    "name": "D. Vika and Segments",
    "statement": "Vika has an infinite sheet of squared paper. Initially all squares are\r\nwhite. She introduced a two-dimensional coordinate system on this sheet\r\nand drew black horizontal and vertical segments parallel to the\r\ncoordinate axes. All segments have width equal to square, that means\r\nevery segment occupy some set of neighbouring squares situated in one\r\nrow or one column.Your task is to calculate the number of painted cells.\r\nIf a cell was painted more than once, it should be calculated exactly\r\nonce.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#define cl(a) memset(a,0,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862;\nvoid gn(int &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nvoid gn(ll &x){\n    int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n    if(c=='-')sg=-1,x=0;else x=c-'0';\n    while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n    x*=sg;\n}\nint mo=1000000007;\nint inf=1061109567;\ndb eps=1e-6;\n//ll inf=1000000000000000000ll;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n#define x1 x192837465\n#define x2 x123456789\n#define y1 y192837465\n#define y2 y123456789\nint n;\nstruct seg{\n    int x1,y1,x2,y2;\n}s[111111];\nseg v[111111],h[111111];\nseg vn[111111];int ntot=0;\nint vtot=0,htot=0;\nint cmpx(const seg&a,const seg&b){\n    if(a.x1==b.x1)return a.y1<b.y1;\n    return a.x1<b.x1;\n}\nint cmpy(const seg&a,const seg&b){\n    if(a.y1==b.y1)return a.x1<b.x1;\n    return a.y1<b.y1;\n}\n\nstruct node{\n    int x,y,sg;\n}tt[222222];int ttot=0;\n\n\n\nint cmpnode(const node&a,const node&b){\n    return a.x<b.x;\n}\nstruct nnode{int ch[2],sz,v,fix;}t[1000005];int ndtot=0;\nint root=0;\nvoid rot(int &x,int f){\n    int y=t[x].ch[!f];\n    t[x].ch[!f]=t[y].ch[f];\n    t[y].ch[f]=x;\n    t[y].sz=t[x].sz;\n    t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz+1;\n    x=y;\n}\nvoid ins(int &x,int v){\n    if(x==0){\n        x=++ndtot;\n        t[x].ch[0]=t[x].ch[1]=0;\n        t[x].sz=1;\n        t[x].fix=rand();\n        t[x].v=v;\n    }else{\n        int f=v>=t[x].v;\n        ins(t[x].ch[f],v);\n        t[x].sz++;\n        if(t[t[x].ch[f]].fix<t[x].fix)rot(x,!f);\n    }\n}\nvoid del(int &x){\n    if(!t[x].ch[0] && !t[x].ch[1])x=0;\n    else{\n        int f=!t[x].ch[0] || t[x].ch[1]&&t[t[x].ch[1]].fix<t[t[x].ch[0]].fix;\n        rot(x,!f);\n        t[x].sz--;\n        del(t[x].ch[!f]);\n    }\n}\nvoid del_num(int &x,int v){\n    if(t[x].v==v)del(x);\n    else{\n        int f=v>=t[x].v;\n        t[x].sz--;\n        del_num(t[x].ch[f],v);\n    }\n}\nint rk(int v){\n    int x=root;int ans=0;\n    while(x){\n        if(t[x].v>=v)x=t[x].ch[0];\n        else{\n            ans+=t[t[x].ch[0]].sz+1;\n            x=t[x].ch[1];\n        }\n    }\n    return ans+1;\n}\nint main()\n{\n    gn(n);\n    for (int i=1;i<=n;i++){\n        gn(s[i].x1);\n        gn(s[i].y1);\n        gn(s[i].x2);\n        gn(s[i].y2);\n        if(s[i].x1>s[i].x2)swap(s[i].x1,s[i].x2);\n        if(s[i].y1>s[i].y2)swap(s[i].y1,s[i].y2);\n        if(s[i].x1==s[i].x2){\n            v[++vtot]=s[i];\n        }else h[++htot]=s[i];\n    }\n    sort(h+1,h+1+htot,cmpy);\n\n    ll sum=0;\n    for (int i=1,j;i<=htot;i=j){\n        for (j=i;j<=htot && h[j].y1==h[i].y1;j++);\n\n        int far=-inf;\n        for (int k=i;k<j;k++){\n            if(h[k].x1>far){\n                if(far!=-inf)tt[++ttot]=(node){far+1,h[i].y1,-1};\n                tt[++ttot]=(node){h[k].x1,h[i].y1,+1};\n                far=max(far,h[k].x2);\n            }else{\n                far=max(far,h[k].x2);\n            }\n        }\n        tt[++ttot]=(node){far+1,h[i].y1,-1};\n    }\n    for (int i=1;i<=ttot;i++)sum-=tt[i].x*tt[i].sg;\n\n    sort(tt+1,tt+1+ttot,cmpnode);\n\n    sort(v+1,v+1+vtot,cmpx);\n\n    for (int i=1,j;i<=vtot;i=j){\n        for (j=i;j<=vtot && v[j].x1==v[i].x1;j++);\n\n        int far=-inf,st=-inf;\n        for (int k=i;k<j;k++){\n            if(v[k].y1>far){\n                if(far!=-inf)vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n                st=v[k].y1;\n                far=max(far,v[k].y2);\n            }else{\n                far=max(far,v[k].y2);\n            }\n        }\n        vn[++ntot]=(seg){v[i].x1,st,v[i].x1,far};\n    }\n\n    sort(vn+1,vn+1+ntot,cmpx);\n\n    int cur=1;\n    for (int i=1;i<=ntot;i++){\n        while(cur<=ttot && tt[cur].x<=vn[i].x1){\n            if(tt[cur].sg==1){\n                ins(root,tt[cur].y);\n            }else{\n                del_num(root,tt[cur].y);\n            }\n            cur++;\n        }\n        int coin = rk(vn[i].y2+1)-rk(vn[i].y1);\n        sum+=vn[i].y2-vn[i].y1+1 - coin;\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "geometry",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Vika and Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/22341",
    "editorial": "At first let's unite all segments which are in same verticals or horizontals. Now the answer to the problem is the sum of lengths of all segments subtract the number of intersections. Let's count the number of intersections. For this let's use the horizontal scan-line from the top to the bottom (is can be done with help of events  vertical segment is open, vertical segment is close and hadle horizontal segment) and in some data structure store the set of x-coordinates of the open segments. For example we can use Fenwick tree with precompression of the coordinates. Now for current horizontal segment we need to take the number of the opened vertical segmetns with value x in the range x1,?x2, where x  vertical where the vertical segment are locating and x1,?x2  the x-coordinates of the current horizontal segment.",
    "hint": []
}