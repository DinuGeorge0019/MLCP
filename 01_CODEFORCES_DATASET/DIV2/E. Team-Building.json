{
    "link": "https://codeforces.com//contest/1445/problem/E",
    "problemId": "781573",
    "problem_idx": "E",
    "shortId": "1445E",
    "contest_number": "1445",
    "problem_submissions": {
        "E": [
            97343040,
            97347277,
            97348912,
            97344656,
            97407907,
            97407463,
            97396524,
            97362947
        ],
        "D": [
            97324855,
            97333286,
            97329900,
            97353075,
            97316397,
            97323647,
            97321827,
            97324812,
            97326864,
            97321949,
            97323009,
            97324550,
            97322776,
            97326841,
            97328860,
            97326229,
            97319935,
            97330188,
            97323548,
            97329039
        ],
        "C": [
            97312030,
            97308145,
            97319441,
            97322210,
            97306404,
            97316438,
            97309851,
            97318138,
            97312463,
            97315342,
            97319473,
            97318075,
            97315769,
            97319997,
            97316782,
            97317725,
            97311982,
            97316093,
            97319226,
            97318708
        ],
        "B": [
            97307314,
            97314537,
            97310817,
            97314466,
            97321532,
            97307574,
            97325592,
            97309083,
            97515487,
            97306672,
            97309337,
            97315410,
            97313589,
            97311259,
            97309216,
            97310018,
            97309275,
            97322041,
            97310083,
            97315384,
            97310291
        ],
        "A": [
            97303713,
            97309415,
            97303791,
            97305897,
            97308405,
            97303339,
            97304268,
            97303286,
            97515476,
            97303210,
            97303136,
            97304841,
            97305580,
            97303766,
            97303232,
            97303901,
            97303416,
            97315951,
            97303601,
            97303529,
            97303495
        ]
    },
    "name": "E. Team-Building",
    "statement": "The new academic year has started, and Berland’s university has n\r\nfirst-year students. They are divided into k academic groups, however,\r\nsome of the groups might be empty. Among the students, there are m pairs\r\nof acquaintances, and each acquaintance pair might be both in a common\r\ngroup or be in two different groups.Alice is the curator of the first\r\nyears, she wants to host an entertaining game to make everyone know each\r\nother. To do that, she will select two different academic groups and\r\nthen divide the students of those groups into two teams. The game\r\nrequires that there are no acquaintance pairs inside each of the\r\nteams.Alice wonders how many pairs of groups she can select, such that\r\nit’ll be possible to play a game after that. All students of the two\r\nselected groups must take part in the game.Please note, that the teams\r\nAlice will form for the game don’t need to coincide with groups the\r\nstudents learn in. Moreover, teams may have different sizes (or even be\r\nempty).\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n#include <cstring>\n#include <sstream>\n#include <numeric>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\n#define int ll\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n\n#define pb push_back\n#define F first\n#define S second\n#define _sz(x) ((int)x.size())\n\nconst int N = 5e5 + 20;\nint n, m, k;\n\nint col[N];\nvector <int> g[N];\n\nstruct edge {\n    int u, v;\n} e[N];\n\nint ans;\n\nint dead[N];\nmap <pii, bool> vis;\nmap <pii, vector <pii>> edges_between;\n\nint par[N], f[N];\nvector <pii> parhistory, fhistory;\n\nint root (int v, bool save_history = 0) {\n    if (par[v] < 0) return v;\n\n    if (save_history) {\n        parhistory.pb({v, par[v]});\n        fhistory.pb({v, f[v]});\n    }\n\n    int res = root(par[v], save_history);\n    f[v] ^= f[par[v]];\n    par[v] = res;\n\n    return res;\n}\n\ninline int merge (int u, int v, bool save_history = 0) {\n    int ru = root(u, save_history), rv = root(v, save_history);\n\n    if (ru == rv) {\n        if (f[u] == f[v]) return -1;\n        return 0;\n    }\n\n    if (save_history) {\n        parhistory.pb({ru, -1});\n        fhistory.pb({ru, 0});\n    }\n\n    if (f[u] == f[v]) f[ru] = 1;\n    else f[ru] = 0;\n\n    par[ru] = rv;\n\n    return 1;\n}\n\nint32_t main()\n{\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n >> m >> k;\n\n    for (int i = 0; i < n; i++) cin >> col[i], col[i]--;\n\n    for (int i = 0; i < m; i++) {\n        cin >> e[i].u >> e[i].v;\n        e[i].u--, e[i].v--;\n\n        g[e[i].u].pb(e[i].v);\n        g[e[i].v].pb(e[i].u);\n    }\n\n    memset(par, -1, sizeof par);\n\n\n    for (int i = 0; i < m; i++) {\n        int u = e[i].u, v = e[i].v;\n\n        if (col[u] == col[v]) {\n            if (merge(u, v) == -1) dead[col[u]] = 1;\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 0; i < k; i++) cnt += (!dead[i]);\n\n    for (int i = 0; i < n; i++) root(i);\n\n    ans = 1ll * cnt * (cnt - 1) / 2;\n\n    for (int i = 0; i < m; i++) {\n        int u = e[i].u, v = e[i].v;\n\n        if (col[u] == col[v]) continue;\n        if (dead[col[u]] || dead[col[v]]) continue;\n\n        int x = col[u], y = col[v];\n        if (x > y) swap(x, y);\n\n        edges_between[{x, y}].pb({u, v});\n            \n        vis[{x, y}] = 1;\n    }\n\n    for (auto p : vis) {\n        int x = p.F.F, y = p.F.S;\n        ans--;\n    \n        bool ok = 1;\n        for (pii ed : edges_between[{x, y}]) {\n            if (merge(ed.F, ed.S, 1) == -1) {\n                ok = 0;\n                break;\n            }\n        }\n\n        while (parhistory.size()) {\n            pii p = parhistory.back();\n            par[p.F] = p.S;\n            parhistory.pop_back();\n        }\n\n        while (fhistory.size()) {\n            pii p = fhistory.back();\n            f[p.F] = p.S;\n            fhistory.pop_back();\n        }\n\n        ans += ok;\n    }\n\n    cout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Team-Building.json",
    "editorial_link": "https://codeforces.com//blog/entry/84248",
    "editorial": "You're given an undirected graph without loops and multiple edges, each vertex has some color from 1\n to k\n. Count the number of pairs of colors such that graph induced by vertices of these two colors will be bipartite.\n\nLet's check for each color whether the graph induced by it is bipartite (for example, using depth-first search). This can be done in O(n+m)\n. We will not use non-bipartite colors further since they can't be in any pairs.\n\nNow let's construct a slow solution that we will make faster later.\n\nConsider some color x\n. There're edges from vertices of this color to vertices of colors y1,y2,,yk\n. Let's check whether the graphs induced by pairs (x,y1),(x,y2),,(x,yk)\n are bipartite (also using depth-first search), thereby finding out which colors cannot be in pair with x\n. The others can. After doing this for each color x\n, we can find the asnwer.\n\nHow fast does this work? Notice that any edge between different colors we will use in DFS only two times. The problem are edges between vertices of the same color, we can use them up to k\n times, and there can be a lot of them.\n\nLet's solve this problem and construct a faster solution.\n\nA graph is bipartite if and only if it doesn't contains odd cycles. Consider some connected bipartite component induced by color x\n. If a cycle goes through this component, it doesn't matter how exactly it does it. If the path of the cycle in this component ends in the same side where it has started, then it has even length, and odd otherwise. This fact lets us compress this component to two vertices (one for each side) connected by one edge. For each color this way we compress all components formed by it.\n\nNow we have the compressed graph, where all connected components are either one vertex or two vertices connected by one edge. Let's do the same process we did in slow solution and check every connected pair of colors whether the graph induced by it is bipartite.\n\nTo check the pair (x,y)\n, for each edge between vertices of colors x\n and y\n in the original graph add a new edge to the compressed graph between corresponding vertices. After that use DFS to check if graph is bipartite, rollback the changes and do the same for all other pairs.\n\nHow long does this work for one pair (x,y)\n?\n\nLet's start DFS only from components that were connected by added edges, since the others do not affect whether the graph is bipartite or not, but there can be a lot of them. This way DFS will use only added edges and some edges between vertices of the same color x\n or y\n. However, there will be at most two times more of the latter than the added, because each added edge connects at most two new components, and each new component has at most one edge. So, we check one pair in the time proportional to amount of edges between its colors, and it sums up to O(m)\n for all pairs.\n\nSo, the whole solution works in O(n+m)\n or O(mlogn)\n, depending on the implementation.",
    "hint": []
}