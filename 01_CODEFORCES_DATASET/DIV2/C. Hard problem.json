{
    "link": "https://codeforces.com//contest/706/problem/C",
    "problemId": "67825",
    "problem_idx": "C",
    "shortId": "706C",
    "contest_number": "706",
    "problem_submissions": {
        "E": [
            19799529,
            19800838,
            19810264,
            19807034,
            19808760,
            19810186,
            19809764,
            19810982,
            42752321,
            19890390
        ],
        "D": [
            19795131,
            19799946,
            19797593,
            19799580,
            19801146,
            19799501,
            19800720,
            19806755,
            19799727,
            19799523,
            19798394,
            19805457,
            19796720,
            19793832,
            19796068,
            19798051,
            19789927,
            19797413,
            19794752
        ],
        "A": [
            19791014,
            19788257,
            19788261,
            19788398,
            19788631,
            19795699,
            19789638,
            19788479,
            19790007,
            19788321,
            22026404,
            19788020,
            19788193,
            19794916,
            19789488,
            19788710,
            19789070,
            19787924,
            19796256,
            19788143,
            19787877
        ],
        "B": [
            19790153,
            19790384,
            19790346,
            19790838,
            19791017,
            19794646,
            19792418,
            19790625,
            19790161,
            19819586,
            19789302,
            19789044,
            19789558,
            19793530,
            19791526,
            19790679,
            19790349,
            19789192,
            19797239,
            19789505,
            19788555
        ],
        "C": [
            19789161,
            19797823,
            19794469,
            19797199,
            19794627,
            19792093,
            19795449,
            19794172,
            19793513,
            19795984,
            19792686,
            19793115,
            19791330,
            19794797,
            19799019,
            19794092,
            19793736,
            19795359,
            19793400,
            19794380
        ]
    },
    "name": "C. Hard problem",
    "statement": "Vasiliy is fond of solving different tasks. Today he found one he wasn\u2019t\r\nable to solve himself, so he asks you to help.Vasiliy is given strings\r\nconsisting of lowercase English letters. He wants them to be sorted in\r\nlexicographical order (as in the dictionary), but he is not allowed to\r\nswap any of them. The only operation he is allowed to do is to reverse\r\nany of them (first character becomes last, second becomes one before\r\nlast and so on).To reverse the -th string Vasiliy has to spent units of\r\nenergy. He is interested in the minimum amount of energy he has to spent\r\nin order to have strings sorted in lexicographical order.String is\r\nlexicographically smaller than string if it is shorter than () and is\r\nits prefix, or if none of them is a prefix of the other and at the first\r\nposition where they differ character in is smaller than the character in\r\n.For the purpose of this problem, two equal strings nearby do not break\r\nthe condition of sequence being sorted lexicographically.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << \"=\" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int , int> pi;\ntypedef pair< int , pi> pii;\n\nconst int INF = ~0U >> 1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n\tint ret = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % Mod)\n\t\tif (x & 1) ret = 1ll * ret * a % Mod;\n\treturn ret;\n}\n\nconst int N = 100000 + 10;\n\nint n, c[N];\nstring t[N], rt[N];\nll dp[N][2], answer;\nchar s[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n + 1) scanf(\"%d\", c + i);\n\trep(i, 1, n + 1) {\n\t\tscanf(\"%s\", s);\n\t\tt[i] = string(s);\n\t\trt[i] = t[i];\n\t\treverse(rt[i].begin(), rt[i].end());\n\t}\n\tdp[1][0] = 0;\n\tdp[1][1] = c[1];\n\trep(i, 2, n + 1) {\n\t\tdp[i][0] = dp[i][1] = 1ll << 60;\n\t\tif (t[i] >= t[i - 1]) dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n\t\tif (t[i] >= rt[i - 1]) dp[i][0] = min(dp[i][0], dp[i - 1][1]);\n\t\tif (rt[i] >= t[i - 1]) dp[i][1] = min(dp[i][1], dp[i - 1][0] + c[i]);\n\t\tif (rt[i] >= rt[i - 1]) dp[i][1] = min(dp[i][1], dp[i - 1][1] + c[i]);\n\t}\n\tanswer = min(dp[n][0], dp[n][1]);\n\tif (answer > 1ll << 50) puts(\"-1\");\n\telse printf(\"%lld\\n\", answer);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Hard problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/46510",
    "editorial": "We will solve the problem with the help of dynamic programming. dp[i][j] is the minimum amount of energy that should be spent to make first i strings sorted in lexicographical order and i-th of them will be reversed if j = 1 and not reversed if j = 0. dp[i][j] is updated by dp[i?-?1][0] and dp[i?-?1][1]. It remains to verify that the i-th string is lexicographically greater than (i?-?1)-th (if j = 1 then we should check reversed i-th string, similar to (i?-?1)-th). Then we update dp[i][j] = min(dp[i][j], dp[i?-?1][0] + c[i] * j), dp[i][j] = min(dp[i][j], dp[i?-?1][1] + j * c[i]). The answer is a minimum of dp[n][0] and dp[n][1].\n"
}