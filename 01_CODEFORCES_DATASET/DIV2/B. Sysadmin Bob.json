{"link": "https://codeforces.com//contest/31/problem/B", "problemId": "145", "problem_idx": "B", "shortId": "31B", "contest_number": "31", "problem_submissions": {"E": [134876, 134644, 134848, 134248, 135579], "D": [134485, 133596, 134295, 134196, 134946, 134425, 134440, 134597, 134581, 134770, 134731, 134788, 134711, 135223, 134329, 136009, 136008, 135064], "C": [134168, 134002, 133803, 133545, 134363, 133957, 133783, 133977, 134075, 133915, 134271, 134272, 134280, 134218, 133534, 134400], "B": [133252, 133258, 133180, 135478, 133631, 133324, 133519, 133415, 134235, 133789, 133861, 134099, 133348, 133444], "A": [132701, 132899, 132718, 132766, 132790, 133118, 132713, 132712, 132770, 953988, 757270, 132738, 133121, 133401, 133529, 132807, 132719, 132830]}, "name": "B. Sysadmin Bob", "statement": "Email address in Berland is a string of the form @, where and are\r\narbitrary strings consisting of small Latin letters. Bob is a system\r\nadministrator in Bersoft company. He keeps a list of email addresses of\r\nthe company\u2019s staff. This list is as a large string, where all addresses\r\nare written in arbitrary order, separated by commas. The same address\r\ncan be written more than once.Suddenly, because of unknown reasons, all\r\ncommas in Bob\u2019s list disappeared. Now Bob has a string, where all\r\naddresses are written one after another without any separators, and\r\nthere is impossible to determine, where the boundaries between addresses\r\nare. Unfortunately, on the same day his chief asked him to bring the\r\ninitial list of addresses. Now Bob wants to disjoin addresses in some\r\nvalid way. Help him to do that.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 220 + 1;\n\nint n;\nchar list[MAXN];\n\ninline bool isValid() {\n\tif (list[0] == '@' || list[n - 1] == '@') return false;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (list[i - 1] == '@' && list[i] == '@') return false;\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t\tif (list[i - 1] == '@' && list[i] != '@' && list[i + 1] == '@') return false;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (list[i] == '@') return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%s\", list);\n\tn = (int)strlen(list);\n\tif (!isValid()) puts(\"No solution\");\n\telse {\n\t\tint first, last;\n\t\tfor (first = 0; first < n; first++) {\n\t\t\tif (list[first] == '@') break;\n\t\t}\n\t\tfor (last = n - 1; last >= 0; last--) {\n\t\t\tif (list[last] == '@') break;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i <= first; i++) putchar(list[i]);\n//printf(\"i = %d\\n\", i);\n\t\twhile (true) {\n\t\t\tif (i >= last) {\n\t\t\t\twhile (i < n) putchar(list[i++]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tputchar(list[i++]);\n\t\t\tputchar(',');\n\t\t\twhile (list[i] != '@') putchar(list[i++]);\n\t\t\tputchar(list[i++]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n"], "input": "", "output": "", "tags": ["greedy", "implementation", "strings"], "dificulty": "1500", "interactive": false}