{"link": "https://codeforces.com//contest/1665/problem/E", "problemId": "1360544", "problem_idx": "E", "shortId": "1665E", "contest_number": "1665", "problem_submissions": {"D": [153098630, 153098612, 153098587, 153037151, 153036976, 153049046, 153046704, 153027496, 153051952, 153041916, 153045199, 153046811, 153048317, 153050713, 153046261, 153034167, 153106751, 153053062, 153052177, 153051012, 153052925, 153054416, 153057375, 153050885], "E": [153055587, 153060115, 153059018, 195378443, 195378396, 195378314, 195378298, 153063815, 153045932, 153058288, 153066247, 153062352, 153266866, 153063806, 153066234, 153061235, 153072107, 153058234, 153106762, 153068678, 153064626, 153063937, 153064996, 153068650, 153068956, 153070050], "C": [153029314, 153030983, 153029810, 153039588, 153033591, 153038708, 153038789, 153043097, 153041313, 153038354, 153048896, 153039781, 153062795, 153106745, 153040131, 153042109, 153052044, 153044977, 153040684, 153044107, 153044428], "B": [153022036, 153024287, 153023835, 153023917, 153026046, 153022977, 153034760, 153031367, 153026945, 153026413, 153027015, 153024144, 153106733, 153028676, 153030247, 153028819, 153029568, 153026498, 153028052, 153025493], "A": [153020368, 153020226, 153020322, 153020992, 153020103, 153020887, 153020140, 153029667, 153026118, 153021963, 153022767, 153020503, 153020639, 153106719, 153021802, 153030757, 153021324, 153023320, 153023010, 153024495, 153021594]}, "name": "E. MinimizOR", "statement": "You are given an array a of n non-negative integers, numbered from 1 to\r\nn.Let\u2019s define the of the array a as\r\ndisplaystyle\r\nmin_{i\r\nneq j} a_i | a_j, where | denotes the bitwise OR operation.There are q\r\nqueries. For each query you are given two integers l and r (l < r). For\r\neach query you should find the cost of the subarray a_{l}, a_{l + 1},\r\nldots, a_{r}.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nconst int inf=(1<<30)-1;\nint a[100005],cntid,rt[100005];\nstruct stree\n{\n\tint ls,rs,cnt;\n}t[7000005];\ninline void build()\n{\n\tt[cntid=1]={0,0,0},rt[0]=1;\n}\ninline void pd(int now)\n{\n\tif(!t[now].ls) t[t[now].ls=++cntid]={0,0,0};\n\tif(!t[now].rs) t[t[now].rs=++cntid]={0,0,0};\n}\ninline void ins(int lst,int now,int l,int r,int p)\n{\n\tif(l==r)\n\t{\n\t\tt[now].cnt=t[lst].cnt+1;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(p<=mid)\n\t{\n\t\tpd(lst);\n\t\tt[now].rs=t[lst].rs;\n\t\tpd(now);\n\t\tins(t[lst].ls,t[now].ls,l,mid,p);\n\t}\n\telse\n\t{\n\t\tpd(lst);\n\t\tt[now].ls=t[lst].ls;\n\t\tpd(now);\n\t\tins(t[lst].rs,t[now].rs,mid+1,r,p);\n\t}\n\tt[now].cnt=t[t[now].ls].cnt+t[t[now].rs].cnt;\n}\ninline int ask(int now,int l,int r,int L,int R)\n{\n\tif(!now) return 0;\n\tif(l==L&&r==R) return t[now].cnt;\n\tint mid=(l+r)>>1;\n\tif(mid>=R) return ask(t[now].ls,l,mid,L,R);\n\tif(mid+1<=L) return ask(t[now].rs,mid+1,r,L,R);\n\treturn ask(t[now].ls,l,mid,L,mid)+ask(t[now].rs,mid+1,r,mid+1,R);\n}\n/*inline int ask(int l,int r,int x)\n{\n\tint ans=0;\n\tfor(int i=l;i<=r;i++)\n\t\tans+=a[i]<=x;\n\treturn ans;\n}*/\ninline int query(int lst,int now,int l,int r,int cnt)\n{\n\tif(l==r) return l;\n\tint mid=(l+r)>>1;\n\tif(t[t[now].ls].cnt-t[t[lst].ls].cnt>=cnt) return query(t[lst].ls,t[now].ls,l,mid,cnt);\n\treturn query(t[lst].rs,t[now].rs,mid+1,r,cnt-t[t[now].ls].cnt+t[t[lst].ls].cnt);\n}\n/*inline int query(int l,int r,int x)\n{\n\tint ans=0;\n\tfor(int i=l;i<=r;i++)\n\t\tif(a[i]<=x) ans=max(ans,a[i]);\n\treturn ans;\n}*/\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tbuild();\n\t\tfor(int i=1;i<=n;i++) \n\t\t{\n\t\t\tcin >> a[i];\n\t\t\trt[i]=++cntid;\n\t\t\tt[rt[i]]={0,0,0};\n\t\t\tins(rt[i-1],rt[i],0,inf,a[i]);\n\t\t}\n\t\tint q;\n\t\tcin >> q;\n\t\twhile(q--)\n\t\t{\n\t\t\tint l,r;\n\t\t\tcin >> l >> r;\n\t\t\tvector <int> v;\n\t\t\tint ans=0;\n\t\t\tfor(int i=29;i>=0;i--)\n\t\t\t{\n\t\t\t\tint x=ask(rt[r],0,inf,ans,ans+(1<<i)-1)-ask(rt[l-1],0,inf,ans,ans+(1<<i)-1);\n\t\t\t\tint X=x;\n\t\t\t\tint qwq=(1<<30)-ans-1;\n\t\t\t\tqwq>>=i,qwq<<=i;\n\t\t\t\tfor(auto t:v) if(!(t&qwq)) ++x;\n\t\t\t\tif(x>=2) continue;\n\t\t\t\tans+=(1<<i);\n\t\t\t\tif(!X) continue; \n\t\t\t\tint nw=query(rt[l-1],rt[r],0,inf,ask(rt[r],0,inf,0,ans-1)-ask(rt[l-1],0,inf,0,ans-1)),flag=0;\n\t\t//\t\tcout << ask(rt[r],0,inf,0,ans-1)-ask(rt[l-1],0,inf,0,ans-1) << \"    \";\n\t\t//\t\tcout << l << \" \" << r << \" \" << ans-1 << \" \" << nw << \"\\n\";\n\t\t\t\tfor(auto t:v)\n\t\t\t\t\tif(t==nw) flag=1;\n\t\t\t\tif(!flag) v.push_back(nw);\n\t\t\t}\n\t\t\tcout << ans << \"\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "data structures", "divide and conquer", "greedy", "implementation", "two pointers"], "dificulty": "2500", "interactive": false}