{
    "link": "https://codeforces.com//contest/550/problem/E",
    "problemId": "28715",
    "problem_idx": "E",
    "shortId": "550E",
    "contest_number": "550",
    "problem_submissions": {
        "E": [
            11427018,
            11429644,
            11432526,
            11430611,
            11432228,
            11432165,
            11489207,
            11427558,
            11432275,
            11429524,
            11432478,
            11432415,
            11430446,
            11486308
        ],
        "D": [
            11423745,
            11423796,
            11427878,
            11431814,
            11429565,
            11429723,
            11427594,
            11427339,
            11431790,
            11428771,
            11426823,
            11429779,
            11429172,
            11429089,
            11430041
        ],
        "C": [
            11421138,
            11416776,
            11423192,
            11422512,
            11424510,
            11421428,
            11421418,
            11420140,
            11434273,
            11422988,
            11421940,
            11421776,
            11433710,
            11424080,
            11421277,
            11423080,
            11425605
        ],
        "B": [
            11420010,
            11420534,
            11419884,
            11420795,
            11419465,
            11418370,
            11419003,
            11418791,
            11421152,
            11420042,
            11419639,
            11419437,
            11420868,
            11422488,
            11419737,
            11424665,
            11422066,
            11422524
        ],
        "A": [
            11417030,
            11416689,
            11417915,
            11416872,
            11429128,
            11417246,
            11416778,
            11416762,
            11416557,
            11416626,
            11434617,
            11421161,
            11417521,
            11420430,
            11419146
        ]
    },
    "name": "E. Brackets in Implications",
    "statement": "Implication is a function of two logical arguments, its value is false\r\nif and only if the value of the first argument is true and the value of\r\nthe second argument is false. Implication is written by using character\r\n\u201d, and the arguments and the result of the implication are written as \u201d\r\n() and \u201d (). According to the definition of the implication: When a\r\nlogical expression contains multiple implications, then when there are\r\nno brackets, it will be calculated from left to fight. For example,.\r\nWhen there are brackets, we first calculate the expression in brackets.\r\nFor example,.For the given logical expression determine if it is\r\npossible to place there brackets so that the value of a logical\r\nexpression is false. If it is possible, your task is to find such an\r\narrangement of brackets.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-9;\nconst int oo = 0x3f3f3f3;\nconst int MAXN = (int)1e5 + 10;\n\nint V[MAXN];\n\nvoid print(int cur, int n)\n{\n    if (n == 0){\n        cout << V[cur];\n    }\n    else{\n        cout << \"(\";\n        cout << V[cur];\n        cout << \"->\";\n        print(cur + 1, n - 1);\n        cout << \")\";\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n\n    int tot = 0;\n\n    for (int i = 0; i < n; ++i){\n        cin >> V[i];\n        if (!V[i]) ++tot;\n    }\n\n    if (n == 1){\n        if (V[0] == 0)\n            cout << \"YES\" << endl << 0 << endl;\n        else\n            cout << \"NO\" << endl;\n        return 0;\n\n    }\n\n    if (V[n - 1] == 1 || (V[n - 2] == 0 && tot == 2)){\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    cout << \"YES\" << endl;\n    print(0, n - 2);\n    cout << \"->0\" << endl;\n\n\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Brackets in Implications.json",
    "editorial_link": "https://codeforces.com/blog/entry/18329",
    "editorial": "Let input consists of , is or for all . Let\u00e2\u0080\u0099s show that there is no\r\nsolution in only two cases: 1) . , for all , and no parentheses can\r\nchange last to . 2) Input has the form or its suffix with at least two\r\narguments. This can be proven by induction. For input there is no\r\nsolution, for longer inputs any attempt to put parentheses will decrease\r\nthe number of s in the beginning by one, or will introduce in the last\r\nposition (which will lead to case one). Let\u00e2\u0080\u0099s construct solution for all\r\nother cases. 1) For input we don\u00e2\u0080\u0099t need to do anything. 2) For input of\r\nthe form we don\u00e2\u0080\u0099t need any parentheses, the value of this expression is\r\nalways 3) Expression in the form (where second missed part consists of\r\nones only). Then . Complexity of the solution is .\r\n"
}