{
    "link": "https://codeforces.com//contest/688/problem/C",
    "problemId": "63907",
    "problem_idx": "C",
    "shortId": "688C",
    "contest_number": "688",
    "problem_submissions": {
        "E": [
            18798101,
            18796724,
            18797231,
            18798974,
            18799540,
            18801395,
            18802783,
            18810711,
            18809719,
            18801431,
            18803825,
            18802677,
            18803257,
            18800733,
            18802066,
            18803323,
            18803755,
            18803508,
            18805435,
            18805332
        ],
        "D": [
            18794251,
            18793642,
            18792480,
            18793770,
            18795849,
            18798326,
            18794352,
            18809463,
            18809360,
            18809030,
            18793977,
            18797699,
            18797400,
            18801049,
            18802910,
            18798453,
            18798000,
            18798601,
            18798398,
            18797731,
            18799630
        ],
        "C": [
            18793128,
            18791291,
            18793167,
            18791852,
            18788953,
            18790786,
            18792131,
            18796089,
            18794724,
            18793607,
            18792460,
            18789743,
            18795539,
            18794192,
            18793703,
            18794069,
            18795590,
            18793984
        ],
        "B": [
            18787495,
            18787231,
            18789682,
            18788356,
            18790758,
            18787367,
            18786760,
            18786756,
            18789463,
            18788573,
            18788713,
            18787120,
            18790658,
            18788353,
            18788699,
            18790793,
            18786776,
            18789835
        ],
        "A": [
            18786938,
            18786787,
            18787620,
            18787066,
            18791713,
            18786819,
            18787191,
            18788288,
            18788193,
            18787025,
            18786883,
            18786790,
            18787732,
            18786915,
            18788140,
            18791164,
            18789687,
            18788126
        ]
    },
    "name": "C. NP-Hard Problem",
    "statement": "Recently, Pari and Arya did some research about NP-Hard problems and\r\nthey found the problem very interesting.Suppose the graph is given.\r\nSubset of its vertices is called a of this graph, if for each edge there\r\nis at least one endpoint of it in this set, i.e. or (or both).Pari and\r\nArya have won a great undirected graph as an award in a team contest.\r\nNow they have to split it in two parts, but both of them want their\r\nparts of the graph to be a vertex cover.They have agreed to give you\r\ntheir graph and you need to find two subsets of its vertices and , such\r\nthat both and are vertex cover or claim itâ€™s impossible. Each vertex\r\nshould be given to no more than one of the friends (or you can even keep\r\nit for yourself).\r\n",
    "solutions": [
        "// VSCF.cpp : Defines the entry point for the console application.\n//\n#include <functional>\n#include <unordered_map>\n#include <iomanip>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <set>\n#include <deque>\n#include <map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SIZE(x) (int)x.size()\n#define ALL(c) c.begin(),c.end()\n\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> graph(n);\n\tREP(i, m) {\n\t\tint t1, t2;\n\t\tcin >> t1 >> t2;\n\t\tt1--; t2--;\n\t\tgraph[t1].push_back(t2);\n\t\tgraph[t2].push_back(t1);\n\t}\n\tvector<int> cols(n);\n\tfunction<void(int, int)> dfs = [&](int w, int color){\n\t\tint nextcolor = color == 1 ? 2 : 1;\n\t\tcols[w] = color;\n\t\tfor (int neigh : graph[w]) {\n\t\t\tif (!cols[neigh]) {\n\t\t\t\tdfs(neigh, nextcolor);\n\t\t\t}\n\t\t}\n\t};\n\tREP(i, n) {\n\t\tif (!cols[i]) {\n\t\t\tdfs(i, 1);\n\t\t}\n\t}\n\tbool bad = false;\n\tvector<int> col[2];\n\tREP(i, n) {\n\t\tint color = cols[i];\n\t\tcol[color - 1].push_back(i);\n\t\tfor (int neigh : graph[i]) {\n\t\t\tif (cols[neigh] == color) {\n\t\t\t\tbad = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (bad) {\n\t\tcout << -1;\n\t} else {\n\t\tREP(i, 2) {\n\t\t\tcout << col[i].size() << \"\\n\";\n\t\t\tfor (int el : col[i]) {\n\t\t\t\tcout << el + 1 << \" \";\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. NP-Hard Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/45770",
    "editorial": "Looking at the two vertex covers in the graph, you see there must be no edge uv that u and v are in the same vertex cover. So the two vertex covers form a bipartition of the graph, so the graph have to be bipartite. And being bipartite is also sufficient, you can use each part as a vertex cover. Bipartition can be found using your favorite graph traversing algorithm(BFS or DFS). Here is a tutorial for bipartition of undirected graphs.\n",
    "hint": []
}