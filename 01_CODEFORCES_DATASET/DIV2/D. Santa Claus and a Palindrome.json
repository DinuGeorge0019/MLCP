{
    "link": "https://codeforces.com//contest/752/problem/D",
    "problemId": "86739",
    "problem_idx": "D",
    "shortId": "752D",
    "contest_number": "752",
    "problem_submissions": {
        "E": [
            23307622,
            23298919,
            23293210,
            23296558,
            23289533,
            23300446,
            23289683,
            23303428,
            23297443,
            23304427,
            23304013,
            23301941,
            23302122,
            23296625,
            23299319,
            23308344,
            23296295,
            23301867,
            23298965
        ],
        "F": [
            23299614,
            23303097,
            23296260,
            23300075,
            23297820,
            23312296,
            23333337,
            23302007,
            23335434,
            23945130
        ],
        "D": [
            23293425,
            23296203,
            23296737,
            23303994,
            23297487,
            23296079,
            23297542,
            23304572,
            23298416,
            23301016,
            23298334,
            23301490,
            23342391,
            23303337,
            23298346,
            23305352,
            23295756,
            23302406
        ],
        "B": [
            23289571,
            23288739,
            23297269,
            23301250,
            23289332,
            23290328,
            23290841,
            23289310,
            23291467,
            23292074,
            23312032,
            23305914,
            23302012,
            23289784,
            23305350
        ],
        "C": [
            23288680,
            23289735,
            23290504,
            23291795,
            23293248,
            23292966,
            23293101,
            23290858,
            23293431,
            23292145,
            23290141,
            23293830,
            23292041,
            23293667,
            23293134,
            23292174,
            23291253,
            23291455,
            23296543,
            23939849,
            23294485
        ],
        "A": [
            23288066,
            23288054,
            23288222,
            23289194,
            23290949,
            23288138,
            23294677,
            23288200,
            23288517,
            23288677,
            23288100,
            23288709,
            23288239,
            23288139,
            23288488,
            23288364,
            23288063,
            23288232,
            23288317,
            23288593
        ]
    },
    "name": "D. Santa Claus and a Palindrome",
    "statement": "Santa Claus likes palindromes very much. There was his birthday\r\nrecently. of his friends came to him to congratulate him, and each of\r\nthem presented to him a string having the same length . We denote the\r\nbeauty of the -th string by . It can happen that is negative that means\r\nthat Santa doesn\u2019t find this string beautiful at all.Santa Claus is\r\ncrazy about palindromes. He is thinking about the following question:\r\nwhat is the maximum possible total beauty of a palindrome which can be\r\nobtained by concatenating some (possibly all) of the strings he has?\r\nEach present can be used at most once. Note that all strings have\r\n.Recall that a palindrome is a string that doesn\u2019t change after one\r\nreverses it.Since the empty string is a palindrome too, the answer can\u2019t\r\nbe negative. Even if all \u2019s are negative, Santa can obtain the empty\r\nstring.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint K, N;\nstring s[100100];\nll m[2]={1000000007ll, 1000000009ll}, k[100100];\nmap<ll, vector<ll>> mp;\nmap<ll, ll> opp;\n\nll mxodd, res;\n\nint main () {\n\tcin >> K >> N;\n\tfo(z, 0, K) {\n\t\tll v;\n\t\tcin >> s[z] >> v;\n\t\tll h[2] = {0ll, 0ll}, g[2] = {0ll, 0ll};\n\t\tfor (char c : s[z]) fo(i, 0, 2) h[i] = (h[i] * 137 + c) % m[i];\n\t\treverse(s[z].begin(), s[z].end());\n\t\tfor (char c : s[z]) fo(i, 0, 2) g[i] = (g[i] * 137 + c) % m[i];\n\n\t\tll H = h[0] * 1000000009ll + h[1];\n\t\tll G = g[0] * 1000000009ll + g[1];\n\n\t\tmp[H].PB(v);\n\t\topp[H] = G;\n\t}\n\n\tfor (auto& i : mp) {\n\t\tsort(i.second.begin(), i.second.end());\n\t}\n\n\tfor (auto& x : mp) {\n\t\tll h = x.first;\n\t\tif (h == opp[h]) {\n\t\t\tvector<ll>& a = x.second;\n\t\t\tll X=-1e18, Y=-1e18;\n\t\t\twhile ((int) a.size() >= 2 && a[(int)a.size()-2] + a[(int)a.size()-1] >= 0) {\n\t\t\t\tres += a.back(), X = a.back(), a.pop_back();\n\t\t\t\tres += a.back(), Y = a.back(), a.pop_back();\n\t\t\t}\n\t\t\tif (X != -1e18) {\n\t\t\t\tmxodd = max(mxodd, -Y);\n\t\t\t}\n\t\t\tif (a.size()) mxodd = max(mxodd, a.back());\n\t\t} else if (h < opp[h]) {\n\t\t\tvector<ll> a = x.second, b = mp[opp[h]];\n\t\t\twhile (a.size() && b.size() && a.back() + b.back() >= 0) {\n\t\t\t\tres += a.back() + b.back();\n\t\t\t\ta.pop_back(), b.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", res + mxodd);\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "hashing",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Santa Claus and a Palindrome.json",
    "editorial_link": "https://codeforces.com//blog/entry/49328",
    "editorial": "Imagine a palindrome split into substrings of equal size (say, n). Here is how it may look like:\n\nABC DEF XYX FED CBA\n\nWe may notice a regular structure: each block, except the middle one, has its pair, which is the same string, but reversed. Here, the first block (ABC) is paired with the last (CBA), the second \u0097 with the first-but-last.\n\nFor now, let's assume that we take an even number of strings, so each string has its pair. Let's split given strings into groups; strings S and rev(S) belong to one group. Clearly, if S is not a palindrome, we must make a pair with the string S with maximum value and the string rev(S) with maximum value, until both strings exist and the sum of their values is nonnegative. If S is a palindrome, we will take two its occurrences with maximum value at a time (of course, again, if there are still at least two occurrences and the sum of values is nonnegative).\n\nThe trickiest part is the central block. Clearly, only the palindromic strings may be at the central block. However, there may be many of them, and we should select the one which gives the maximum value overall. There are several cases. Consider the point when you've taken the last pair from the list of S-s and stopped.\n\nIf the value of the next element is nonnegative (say, x), we may simply take it and say that x is our possible score for S being in the center. We wouldn't make a valuable pair of it anyway. Otherwise we need to split the last taken pair. Denote the values of last taken strings as a and b (a???b). Note that b?<?0, because otherwise it makes no sense to use a separately. If we take a pair, we get score a?+?b. If we take just the first element, we get score a. So, in this case our possible score is ?-?b (while a?+?b is already added to the main answer!)\n\nNow, the central string will be the one with the maximum possible score, and its value should be added to the answer."
}