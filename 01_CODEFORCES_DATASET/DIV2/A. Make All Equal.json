{
    "link": "https://codeforces.com//contest/2001/problem/A",
    "problemId": "2825890",
    "problem_idx": "A",
    "shortId": "2001A",
    "contest_number": "2001",
    "problem_submissions": {
        "B": [
            277398710,
            277337688,
            277333922,
            277337722,
            277337555,
            277331647,
            277331395,
            277333468,
            277348528,
            277341588,
            277340363,
            277333951,
            277333359,
            277338651,
            277333253,
            277332470,
            277333025,
            277335874,
            277338084,
            277338047
        ],
        "A": [
            277396358,
            277332606,
            277324069,
            277328881,
            277324101,
            277323710,
            277325572,
            277324708,
            277342273,
            277324601,
            277327125,
            277324363,
            277324076,
            277325983,
            277324668,
            277323640,
            277324308,
            277324085,
            277329437,
            277324734
        ],
        "C": [
            277393929,
            277349647,
            277343837,
            277347819,
            277349047,
            277345424,
            277478575,
            277341657,
            277342745,
            277358874,
            277352973,
            277356317,
            277345054,
            277358657,
            277349482,
            277354577,
            277354478,
            277341600,
            277373032,
            277357702,
            277354144
        ],
        "D": [
            277386516,
            277362274,
            277363417,
            277423990,
            277364589,
            277362182,
            277363264,
            277481384,
            277378655,
            277372682,
            277373441,
            277372083,
            277373799,
            277371029,
            277376602,
            277374746,
            277374825,
            277383133,
            277374017,
            277362123,
            277383713,
            277376041
        ],
        "E2": [
            277373545,
            283086293,
            277423307,
            278251315,
            278253470
        ],
        "E1": [
            277335505,
            277376073,
            277395747,
            277388497,
            277391499,
            277398952,
            277393530,
            277401516,
            277389370,
            277393752,
            277394666,
            277405095,
            277396023,
            277402006,
            277399147,
            277397663,
            277407033,
            278257931,
            277717643,
            277717625,
            277717605,
            277717578,
            277403586,
            277396025,
            277402066
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132942",
    "editorial": "Let x be one of the most frequent\nelements in a, then the answer must be at least (n -\ntext{frequency of } x), and this lower bound is always achievable by\nkeep erasing a non-x element from a, and we can prove itâs always\npossible to do so.proof:If all elements of a are x, we are done.\nOtherwise, let y denote all the elements that are not x, then a would\nhave some subarray of the form x\nldots x, y\nldots y, x\nldots x. In this subarray, there must exist adjacent elements that\nsatisfy a_i\nleq a_{(i\nbmod m) + 1}, otherwise we would have x > y >\nldots > y > x implying x > x which leads to a contradiction.\n",
    "name": "A. Make All Equal",
    "statement": "You are given a cyclic array a_1, a_2,\r\nldots, a_n.You can perform the following operation on a at most n - 1\r\ntimes: Let m be the current size of a, you can choose any two adjacent\r\nelements where the previous one is no greater than the latter one (In\r\nparticular, a_m and a_1 are adjacent and a_m is the previous one), and\r\ndelete exactly one of them. In other words, choose an integer i (1\r\nleq i\r\nleq m) where a_i\r\nleq a_{(i\r\nbmod m) + 1} holds, and delete exactly one of a_i or a_{(i\r\nbmod m) + 1} from a. Your goal is to find the minimum number of\r\noperations needed to make all elements in a equal.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}void run(){\tint n,x;\tmap<int,int>pp;\tcin>>n;\trep(i,n){\t\tcin>>x;pp[x]++;\t}\tx=0;\tfor(pii i:pp)Mx(x,i.S);\tcout<<n-x<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Make All Equal.json",
    "hint": [
        "Hint 1 What's the most obvious lower bound of the answer?",
        "Hint 2 Is the lower bound achievable?"
    ]
}