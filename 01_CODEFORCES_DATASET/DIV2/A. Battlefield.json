{"link": "https://codeforces.com//contest/182/problem/A", "problemId": "1266", "problem_idx": "A", "shortId": "182A", "contest_number": "182", "problem_submissions": {"C": [1663733, 1663728, 1623940, 1623119, 1624114, 1624504, 1624399, 1622980, 1643406, 10562948], "E": [1624193, 1623067, 1622067, 1624242, 1623079, 1622816, 1625915, 1622385, 1624996, 1622444, 1622634], "D": [1623370, 1620768, 1625829, 1625101, 1620935, 1627627, 1625879, 1620500, 1624702, 1623228, 1623926, 1620648, 1625035, 1621025, 1621358], "B": [1622937, 1621227, 1620887, 1620496, 1621242, 1620438, 1620699, 1620796, 1623576, 1623718, 1620257, 1623264, 1620331, 1620463], "A": [1622661, 1624396, 1623052, 1628460, 1622766, 1623550, 1622930]}, "name": "A. Battlefield", "statement": "Vasya lagged behind at the University and got to the battlefield. Just\r\njoking! He\u2019s simply playing some computer game. The field is a flat\r\nplatform with trenches dug on it. The trenches are segments on a plane\r\nparallel to the coordinate axes. No two trenches intersect.There is a\r\nhuge enemy laser far away from Vasya. The laser charges for seconds, and\r\nthen shoots continuously for seconds. Then, it charges for seconds\r\nagain. Then it shoots continuously for seconds again and so on. Vasya\r\nknows numbers and . He also knows that while the laser is shooting,\r\nVasya must be in the trench, but while the laser is charging, Vasya can\r\nsafely move around the field. The main thing is to have time to hide in\r\nthe trench before the shot. If Vasya reaches the trench exactly at the\r\nmoment when the laser starts shooting, we believe that Vasya managed to\r\nhide. Coincidentally, of any trench in meters numerically .Initially,\r\nVasya is at point . He needs to get to point . Vasya moves at speed 1\r\nmeter per second in either direction. You can get in or out of the\r\ntrench at any its point. Getting in or out of the trench takes no time.\r\nIt is also possible to move in the trench, without leaving it.What is\r\nthe minimum time Vasya needs to get from point to point , if at the\r\ninitial time the laser has just started charging? If Vasya cannot get\r\nfrom point to point , print -1. If Vasya reaches point at the moment\r\nwhen the laser begins to shoot, it is believed that Vasya managed to\r\nreach point .\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\ndouble a[1024][4];\nint aa, bb;\n\ndouble getTime(int i1, int i2)\n{\n    double ret = 1000000000;\n\n    double x11, y11, x12, y12, x21, y21, x22, y22;\n    x11 = a[i1][0]; y11 = a[i1][1]; x12 = a[i1][2]; y12 = a[i1][3];\n    x21 = a[i2][0]; y21 = a[i2][1]; x22 = a[i2][2]; y22 = a[i2][3];\n\n    if (x11 != x12)\n        {\n            swap(x11, y11);\n            swap(x12, y12);\n            swap(x21, y21);\n            swap(x22, y22);\n        }\n\n    ret = min(ret, hypot(x11 - x21, y11 - y21) );\n    ret = min(ret, hypot(x11 - x22, y11 - y22) );\n    ret = min(ret, hypot(x12 - x21, y12 - y21) );\n    ret = min(ret, hypot(x12 - x22, y12 - y22) );\n\n    //cout << x11 << \" \" << y11 << \" \" << x12 << \" \" << y12 << endl;    \n    //cout << x21 << \" \" << y21 << \" \" << x22 << \" \" << y22 << endl;\n    \n    if (x21 != x22)\n        {\n            if (y21 >= min(y11, y12) && y21 <= max(y11, y12))\n                {\n                    ret = min(ret, abs(x11 - x21) );\n                    ret = min(ret, abs(x11 - x22) );\n                }\n            if (x11 >= min(x21, x22) && x11 <= max(x21, x22))\n                {\n                    ret = min(ret, abs(y11 - y21) );\n                    ret = min(ret, abs(y12 - y21) );\n                }\n           }\n    if (x21 == x22 && max(y11, y12) >= min(y21, y22) && max(y21, y22) >= min(y11, y12))\n        {\n            ret = min(ret, abs(x11 - x21));\n        }\n    if (ret <= aa)\n        return ret;\n    return -1;\n}\n\nint main(void)\n{\n    int n, i;\n    double x1, y1, x2, y2;\n    \n    cin >> aa >> bb;\n    cin >> x1 >> y1 >> x2 >> y2;\n    cin >> n;\n    fo(i,n)\n        {\n            cin >> a[i+1][0] >> a[i+1][1] >> a[i+1][2] >> a[i+1][3];\n        }\n    a[0][0] = a[0][2] = x1;\n    a[0][1] = a[0][3] = y1;\n    a[n+1][0] = a[n+1][2] = x2;\n    a[n+1][1] = a[n+1][3] = y2;\n    n += 2;\n\n    //cout << getTime(3,4) << endl;\n    //return 0;\n    \n    double mnTime[1024];\n    double goOut[1024];\n    fo(i,n) mnTime[i] = 1000000000;\n    mnTime[0] = goOut[0] = 0;\n    bool vis[1024];\n    memset(vis, 0, sizeof(vis));\n    priority_queue < pair < double, int > > q;\n    q.push( mp(0, 0) );\n    while(!q.empty())\n        {\n            int ind = q.top().second;\n            q.pop();\n            if (vis[ind]) continue;\n            vis[ind] = true;\n\n            fo(i,n) if (!vis[i])\n                {\n                    double gtm = getTime(ind, i);\n                    //cout << ind << \" \" << i << \" \" << gtm << endl;\n                    if (gtm == -1) continue;                     \n                    if (goOut[ind] + gtm < mnTime[i])\n                        {\n                            mnTime[i] = goOut[ind] + gtm;\n                            goOut[i] = goOut[ind] + (aa + bb);                            \n                            //cout << ind << \" \" << i << \" \" << mnTime[i] << \" \" << goOut[i] <<  endl;\n                            q.push( mp(-mnTime[i], i) );\n                        }\n                }\n        }\n\n    if (mnTime[n-1] == 1000000000)\n        cout << -1 << endl;\n    else\n        printf(\"%.10lf\\n\", mnTime[n-1]);\n}\n"], "input": "", "output": "", "tags": ["geometry", "graphs", "implementation", "shortest paths"], "dificulty": "2200", "interactive": false}