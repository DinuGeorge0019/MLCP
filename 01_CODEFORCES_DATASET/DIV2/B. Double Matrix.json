{
    "link": "https://codeforces.com//contest/1162/problem/B",
    "problemId": "339905",
    "problem_idx": "B",
    "shortId": "1162B",
    "contest_number": "1162",
    "problem_submissions": {
        "F": [
            53760255
        ],
        "E": [
            53755729,
            53755411,
            53755882,
            53754129,
            53757378,
            53756764,
            53757700,
            53758454,
            53758416,
            53754833,
            53757407,
            53756313,
            53758588,
            53756165,
            53758997,
            53756619,
            53758311,
            53759677
        ],
        "D": [
            53752747,
            53753462,
            53754325,
            53757481,
            53752843,
            53755399,
            53755520,
            53755668,
            53754940,
            53755489,
            53758915,
            53755731,
            53754946,
            53755618,
            53759491,
            53755508,
            53758786,
            53755777,
            53756167
        ],
        "C": [
            53749836,
            53750600,
            53751425,
            53750020,
            53750391,
            53752273,
            53751033,
            53751621,
            53752004,
            53752815,
            53754220,
            53751629,
            53753641,
            53751893,
            53752886,
            53751070,
            53756767,
            53753219
        ],
        "B": [
            53748291,
            53748052,
            53748376,
            53747817,
            53748626,
            53748146,
            53748574,
            53749401,
            53805701,
            53749421,
            53749906,
            53748692,
            53758550,
            53750610,
            53749077,
            53749412,
            53749393,
            53748736,
            53751212
        ],
        "A": [
            53746666,
            53746560,
            53746976,
            53746641,
            53746514,
            53746879,
            53746868,
            53747863,
            53805694,
            53747143,
            53747013,
            53746924,
            53746595,
            53746573,
            53747849,
            53746548,
            53747762,
            53747182,
            53748613
        ]
    },
    "name": "B. Double Matrix",
    "statement": "You are given n\r\ntimes m matrices containing integers. A sequence of integers is strictly\r\nincreasing if each next number is greater than the previous one. A row\r\nis strictly increasing if all numbers from left to right are strictly\r\nincreasing. A column is strictly increasing if all numbers from top to\r\nbottom are strictly increasing. A matrix is increasing if all rows are\r\nstrictly increasing all columns are strictly increasing. For example,\r\nthe matrix\r\nbegin{bmatrix} 9&10&11\r\n11&12&14\r\nend{bmatrix} is increasing because each individual row and column is\r\nstrictly increasing. On the other hand, the matrix\r\nbegin{bmatrix} 1&1\r\n2&3\r\nend{bmatrix} is not increasing because the first row is not strictly\r\nincreasing.Let a position in the i-th row (from top) and j-th column\r\n(from left) in a matrix be denoted as (i, j). In one operation, you can\r\nchoose any two numbers i and j and swap the number located in (i, j) in\r\nthe first matrix with the number in (i, j) in the second matrix. In\r\nother words, you can swap two numbers in different matrices if they are\r\nlocated in the corresponding positions.You would like to make both\r\nmatrices increasing by performing some number of operations (possibly\r\nnone). Determine if it is possible to do this. If it is, print \"\",\r\notherwise, print \"\".\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, M;\n    scanf(\"%d%d\", &N, &M);\n    vector<vector<int> > A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n        A[i].resize(M);\n        for (int j = 0; j < M; ++j) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        B[i].resize(M);\n        for (int j = 0; j < M; ++j) {\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (i < N - 1 && (min(A[i][j], B[i][j]) >= min(A[i+1][j], B[i+1][j]))) {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            if (i < N - 1 && (max(A[i][j], B[i][j]) >= max(A[i+1][j], B[i+1][j]))) {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            if (j < M - 1 && (min(A[i][j], B[i][j]) >= min(A[i][j+1], B[i][j+1]))) {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            if (j < M - 1 && (max(A[i][j], B[i][j]) >= max(A[i][j+1], B[i][j+1]))) {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n    printf(\"Possible\\n\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Double Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "There are too many possibilities to try a brute force, and a dp solution\r\nalso might be too slow (e.g. some bitmask dp). There is a solution that\r\nuses 2sat but that is a bit hard to code so I won\u00e2\u0080\u0099t go into details in\r\nthis tutorial. Let\u00e2\u0080\u0099s instead look at a greedy solution.First, let\u00e2\u0080\u0099s swap\r\nwith if . At the end, for every and , we have . We now claim that there\r\nis a solution if and only if this configuration is valid. We can guess\r\nthis intuitively and by trying a few examples, or we can do the proof\r\nbelow.<start of formal proof for why this works>If this configuration is\r\nvalid, then obviously this solution works, so we\u00e2\u0080\u0099re done with this side\r\nof the implication.The other way is to show if there exists a solution,\r\nthen this configuration is also valid. We do this by contradiction. We\r\nshow if this configuration is not valid, then there is no solution. If\r\nthis configuration is not valid, without loss of generality, let . must\r\ngo somewhere in the matrix and it needs to be before either or , but we\r\nhave , so we have nowhere that we can put , thus this shows there is no\r\nsolution. We can also extend this argument to the other cases.<end of\r\nproof for why this works>So, given the above claim, the solution is\r\nsimple. Do the swaps so . Then, check if the two matrices are\r\nincreasing, and print \"Possible\" if so and \"Impossible\" otherwise. The\r\nruntime is to read in the input, do the swaps, then do the checks that\r\nthe matrices are valid.\r\n"
}