{
    "link": "https://codeforces.com//contest/680/problem/E",
    "problemId": "61903",
    "problem_idx": "E",
    "shortId": "680E",
    "contest_number": "680",
    "problem_submissions": {
        "E": [
            18325043,
            18336819,
            18313780,
            18325133,
            18326159,
            91465868,
            91465765,
            18326865,
            18326653,
            18321290,
            18325524
        ],
        "D": [
            18318422,
            18317712,
            18319515,
            18318081,
            18319018,
            18319894,
            18321280,
            18314391,
            18321896,
            18322082,
            18323629,
            18321461
        ],
        "C": [
            18310807,
            18309120,
            18309109,
            18310395,
            18309474,
            18309104,
            18322448,
            18311311,
            18310069,
            18313252,
            93169698,
            91285497,
            20188952,
            18318579,
            18308421,
            18311792,
            18307772,
            18311986,
            18308165,
            18323717,
            18309473,
            18312494
        ],
        "B": [
            18305109,
            18304731,
            18305069,
            18305817,
            18305879,
            18305478,
            18318612,
            18306119,
            18307273,
            18305717,
            54153853,
            54153852,
            54153523,
            54153520,
            18308586,
            18305117,
            18306452,
            18305702,
            18306808,
            18308328,
            18304898,
            18305913,
            18306422
        ],
        "A": [
            18302780,
            18302872,
            18302977,
            18303253,
            18302950,
            18302797,
            18317513,
            18303506,
            18302976,
            18303711,
            54152578,
            54152576,
            54152557,
            54152556,
            18306442,
            18302916,
            18303646,
            18303474,
            18304094,
            18302798,
            18302792,
            18304079,
            18303143
        ]
    },
    "name": "E. Bear and Square Grid",
    "statement": "You have a grid with rows and columns. Each cell is either empty\r\n(denoted by ”) or blocked (denoted by ”).Two empty cells are if they\r\nshare a side. Two cells (located in the row and column ) and are if\r\nthere exists a sequence of empty cells that starts with , finishes with\r\n, and any two consecutive cells in this sequence are directly connected.\r\nA is a set of empty cells such that any two cells in the component are\r\nconnected, and there is no cell in this set that is connected to some\r\ncell not in this set.Your friend Limak is a big grizzly bear. He is able\r\nto destroy any obstacles in some range. More precisely, you can choose a\r\nsquare of size in the grid and Limak will transform all blocked cells\r\nthere to empty ones. However, you can ask Limak to help only once.The\r\nchosen square must be completely inside the grid. It’s possible that\r\nLimak won’t change anything because all cells are empty anyway.You like\r\nbig connected components. After Limak helps you, what is the maximum\r\npossible size of the biggest connected component in the grid?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 505;\nint n , K;\nchar s[N][N];\nint par[N*N] , sz[N*N];\nint id(int x,int y){\n    return x * n + y;\n}\nint getfa(int x){\n    return par[x] == x ? x : par[x] = getfa(par[x]);\n}\nvoid merge(int a,int b){\n    int pa = getfa(a) , pb = getfa(b);\n    if(pa != pb){\n        sz[pa] += sz[pb];\n        par[pb] = pa;\n    }\n}\nint sum[N][N];\nint cnt[N*N];\nint Plus(int x,int y){\n    if(s[x][y] == 'X') return 0;\n    int c = par[id(x , y)];\n    cnt[c]++;\n    if(cnt[c] == 1) return sz[c];\n    return 0;\n}\nint Del(int x,int y){\n    if(s[x][y] == 'X') return 0;\n    int c = par[id(x , y)];\n    cnt[c]--;\n    if(cnt[c] == 0) return sz[c];\n    return 0;\n}\nint Sum(int a,int b,int c,int d){\n    int r = sum[c][d];\n    if(b) r -= sum[c][b-1];\n    if(a) r -= sum[a-1][d];\n    if(a && b) r += sum[a-1][b-1];\n    return r;\n}\nint main(){\n    scanf(\"%d%d\",&n,&K);\n    rep(i,0,n) scanf(\"%s\",s[i]);\n    rep(i,0,n) rep(j,0,n){\n        int k = id(i , j);\n        par[k] = k;\n        sz[k] = s[i][j] == '.';\n        sum[i][j] = s[i][j] == '.';\n    }\n    rep(i,1,n) rep(j,0,n) sum[i][j] += sum[i-1][j];\n    rep(i,0,n) rep(j,1,n) sum[i][j] += sum[i][j-1];\n    //rep(i,0,n) rep(j,0,n) printf(\"%d%c\",sum[i][j] , \" \\n\"[j + 1 == n]);\n    rep(i,0,n) rep(j,0,n) if(s[i][j] == '.'){\n        int c = id(i , j) , nc = 0;\n        if(i != n && s[i+1][j] == '.') nc = id(i + 1 , j) , merge(c , nc);\n        if(j != n && s[i][j+1] == '.') nc = id(i , j + 1) , merge(c , nc);\n    }\n    rep(i,0,n) rep(j,0,n){\n        int c = id(i , j);\n        getfa(c);\n    }\n    int ans = 0;\n    for(int i=0;i+K<=n;++i){\n        fill(cnt , cnt + N * N , 0);\n        int all = 0;\n        rep(k,0,K) rep(t,0,K) all += Plus(k+i , t);\n        int j = 0;\n        if(i != 0) rep(k,0,K) all += Plus(i-1, j+k);\n        if(i+K != n) rep(k,0,K) all += Plus(i+K,j+k);\n        if(j+K != n) rep(k,0,K) all += Plus(i+k,j+K);\n        ans = max(ans , all + K * K - Sum(i , j , i + K - 1 , j + K - 1));\n        for(++j;j+K<=n;++j){\n            if(j-1) rep(k,0,K) all -= Del(i+k,j-2);\n            if(i) all -= Del(i-1,j-1);\n            if(i+K != n) all -= Del(i+K,j-1);\n            if(j+K !=n) rep(k,0,K) all += Plus(i+k,j+K);\n            if(i) all += Plus(i-1,j+K-1);\n            if(i+K != n) all += Plus(i+K,j+K-1);\n            ans = max(ans , all + K * K - Sum(i , j , i + K - 1 , j + K - 1));\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Bear and Square Grid.json",
    "editorial_link": "https://codeforces.com//blog/entry/45310",
    "editorial": null
}