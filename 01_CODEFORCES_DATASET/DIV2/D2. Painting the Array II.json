{"link": "https://codeforces.com//contest/1480/problem/D2", "problemId": "889622", "problem_idx": "D2", "shortId": "1480D2", "contest_number": "1480", "problem_submissions": {"E": [106815202, 106829295, 106831975, 106809004, 106829806, 106819321], "A": [106788901, 106763609, 106753484, 106750112, 106751527, 106754769, 106750125, 106749992, 106750591, 106751832, 106750843, 106752181, 106751591, 106750114, 106751859, 106763776, 106750109, 106751576, 106750047], "B": [106787623, 106771665, 106761993, 106764148, 106756896, 106759373, 106760371, 106757851, 106763699, 106762465, 106762683, 106765834, 106771235, 106765823, 106763977, 106769634, 106760777, 106760996, 106762894], "D2": [106784450, 106807928, 106805609, 106826801, 106798277, 106796852, 106798333, 106810992, 106800784, 106809989, 106808304, 106811925, 106820358, 106815498, 106828841, 106811617, 106816566, 106820373, 106831701], "D1": [106783553, 106789621, 106794420, 106828218, 106785923, 106787471, 106782777, 106790234, 106791782, 106791560, 106802581, 106787920, 106797964, 106789713, 106805344, 106803882, 106796851, 106808232, 106798013], "C": [106763339, 106759660, 106769859, 106771866, 106840559, 106871120, 106772068, 106767886, 106771470, 106778796, 106778516, 106806146, 106779019, 106800993, 106782589, 106787042, 106778247, 106779906, 106777631]}, "name": "D2. Painting the Array II", "statement": "Homer likes arrays a lot. Today he is painting an array a_1, a_2,\r\ndots, a_n with two kinds of colors, and . A painting assignment for a_1,\r\na_2,\r\ndots, a_n is described by an array b_1, b_2,\r\ndots, b_n that b_i indicates the color of a_i (0 for white and 1 for\r\nblack).According to a painting assignment b_1, b_2,\r\ndots, b_n, the array a is split into two new arrays a^{(0)} and a^{(1)},\r\nwhere a^{(0)} is the sub-sequence of all white elements in a and a^{(1)}\r\nis the sub-sequence of all black elements in a. For example, if a =\r\n[1,2,3,4,5,6] and b = [0,1,0,1,0,0], then a^{(0)} = [1,3,5,6] and\r\na^{(1)} = [2,4].The number of segments in an array c_1, c_2,\r\ndots, c_k, denoted\r\nmathit{seg}(c), is the number of elements if we merge all adjacent\r\nelements with the same value in c. For example, the number of segments\r\nin [1,1,2,2,3,3,3,2] is 4, because the array will become [1,2,3,2] after\r\nmerging adjacent elements with the same value. Especially, the number of\r\nsegments in an empty array is 0.Homer wants to find a painting\r\nassignment b, according to which the number of segments in both a^{(0)}\r\nand a^{(1)}, i.e.\r\nmathit{seg}(a^{(0)})+\r\nmathit{seg}(a^{(1)}), is as as possible. Find this number.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nvoid print(vector<int> x){for(int i=0;i<(int)x.size();i++) printf(\"%d%c\",x[i],\" \\n\"[i==(int)x.size()-1]);}\n#define N 100005\nint f[N],a[N],tag,col[N],n;\nmultiset<int> val;\nint getval(int x)\n{\n\tval.erase(val.find(x));\n\tint ans=*val.begin();\n\tval.insert(x);\n\treturn ans;\n}\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++) val.insert(inf),col[i]=inf;\n\tf[0]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint v=min(col[a[i]],getval(col[a[i]])+1);\n\t\tv=min(v,f[0]+1);\n\t\tf[i-1]=v;\n\t\tif(a[i]!=a[i-1]) tag++,f[i-1]--;\n\t\tval.erase(val.find(col[a[i-1]]));\n\t\tcol[a[i-1]]=min(col[a[i-1]],f[i-1]);\n\t\tval.insert(col[a[i-1]]);\n\t}\n\tint ans=inf;\n\tfor(int i=0;i<n;i++) ans=min(ans,f[i]);\n\tcout<<ans+tag<<endl;\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy"], "dificulty": "2100", "interactive": false}