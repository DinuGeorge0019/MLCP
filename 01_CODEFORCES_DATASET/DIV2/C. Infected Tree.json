{
    "link": "https://codeforces.com//contest/1689/problem/C",
    "problemId": "1426170",
    "problem_idx": "C",
    "shortId": "1689C",
    "contest_number": "1689",
    "problem_submissions": {
        "E": [
            160112065,
            160122128,
            160125790,
            160125174,
            160129572,
            160129585,
            160131786,
            160198613,
            160135003,
            160132850,
            160130305,
            160129724,
            160130309,
            160134699,
            160132208,
            160134730,
            160133947,
            160135624,
            160132845
        ],
        "D": [
            160105444,
            160106619,
            160103165,
            160105284,
            160109476,
            160111661,
            160111580,
            160114903,
            160117754,
            160223912,
            160117858,
            160115373,
            160119358,
            160119569,
            160110447,
            160119288,
            160122102,
            160117625,
            160122103
        ],
        "C": [
            160101725,
            160101027,
            160100377,
            160100502,
            160102947,
            160104518,
            160104470,
            160103940,
            160105751,
            160106384,
            160109439,
            160101319,
            160107036,
            160099160,
            160109505,
            160110151,
            160109766,
            160109925
        ],
        "B": [
            160095106,
            160095099,
            160095692,
            160094546,
            160098042,
            160100154,
            160098117,
            160097987,
            160101496,
            160099759,
            160105755,
            160095146,
            160101519,
            160094285,
            160105059,
            160102238,
            160103140,
            160102070
        ],
        "A": [
            160093939,
            160093596,
            160093753,
            160097601,
            160094503,
            160096047,
            160095876,
            160093955,
            160095035,
            160094694,
            160102269,
            160093545,
            160098465,
            160096387,
            160095131,
            160099800,
            160098054,
            160096796
        ]
    },
    "name": "C. Infected Tree",
    "statement": "Misha has found a binary tree with n vertices, numbered from 1 to n. A\r\nbinary tree is an acyclic connected bidirectional graph containing n\r\nvertices and n - 1 edges. Each vertex has a degree at most 3, whereas\r\nthe root is the vertex with the number 1 and it has a degree at most\r\n2.Unfortunately, the root got infected.The following process happens n\r\ntimes: Misha either chooses a non-infected (and not deleted) vertex and\r\ndeletes it with all edges which have an end in this vertex or just does\r\nnothing. Then, the infection spreads to each vertex that is connected by\r\nan edge to an already infected vertex (all already infected vertices\r\nremain infected). As Misha does not have much time to think, please tell\r\nhim what is the maximum number of vertices he can save from the\r\ninfection (note that deleted vertices are not counted as saved).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint T, n;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        vector<vector<int>> adj(n + 1, vector<int>(0));\n        vector<int> siz(n + 1);\n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        function<void(int, int)> dfs = [&](int u, int fa) {\n            siz[u] = 1;\n            for (auto v : adj[u]) {\n                if (v == fa) continue;\n                dfs(v, u); siz[u] += siz[v];\n            }\n        };\n        function<int(int, int)> dfs2 = [&](int u, int fa) {\n            vector<pair<int, int>> s;\n            for (auto v : adj[u]) {\n                if (v == fa) continue;\n                s.emplace_back(siz[v] - 1, dfs2(v, u));\n            }\n            if (s.size() == 0) return 0;\n            if (s.size() == 1) return s[0].first;\n            return max(s[0].first + s[1].second, s[1].first + s[0].second);\n        };\n        dfs(1, 0);\n        cout << dfs2(1, 0) << endl;\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Infected Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/103471",
    "editorial": "SolutionLet be the sequence of removed vertices such that the infection\r\ncannot spread anymore. If vertex was never directly connected to an\r\ninfected vertex, then we could have deleted its parent instead of and we\r\nwould have got a better solution. Hence, we may assume we always delete\r\na vertex directly connected to an infected one. Now, we may use some\r\ndynamic programming ideas. Let be the maximum number of vertices we can\r\nsave in the subtree of vertex if that vertex is infected and we use\r\noperations only in the subtree. We can assume the second as the tree is\r\nbinary and we have two choices save the subtree of one child by deleting\r\nit and infect the other, or the other way around. In each case, the\r\ninfection will be \"active\" in at most one subtree of some vertex. If and\r\nare the children of vertex , the transition is where denotes the number\r\nof vertices in the subtree of .The answer to the problem is . Complexity\r\nis .\r\n"
}