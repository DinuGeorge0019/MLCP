{
    "link": "https://codeforces.com//contest/1665/problem/D",
    "problemId": "1360543",
    "problem_idx": "D",
    "shortId": "1665D",
    "contest_number": "1665",
    "problem_submissions": {
        "D": [
            153098630,
            153098612,
            153098587,
            153037151,
            153036976,
            153049046,
            153046704,
            153027496,
            153051952,
            153041916,
            153045199,
            153046811,
            153048317,
            153050713,
            153046261,
            153034167,
            153106751,
            153053062,
            153052177,
            153051012,
            153052925,
            153054416,
            153057375,
            153050885
        ],
        "E": [
            153055587,
            153060115,
            153059018,
            195378443,
            195378396,
            195378314,
            195378298,
            153063815,
            153045932,
            153058288,
            153066247,
            153062352,
            153266866,
            153063806,
            153066234,
            153061235,
            153072107,
            153058234,
            153106762,
            153068678,
            153064626,
            153063937,
            153064996,
            153068650,
            153068956,
            153070050
        ],
        "C": [
            153029314,
            153030983,
            153029810,
            153039588,
            153033591,
            153038708,
            153038789,
            153043097,
            153041313,
            153038354,
            153048896,
            153039781,
            153062795,
            153106745,
            153040131,
            153042109,
            153052044,
            153044977,
            153040684,
            153044107,
            153044428
        ],
        "B": [
            153022036,
            153024287,
            153023835,
            153023917,
            153026046,
            153022977,
            153034760,
            153031367,
            153026945,
            153026413,
            153027015,
            153024144,
            153106733,
            153028676,
            153030247,
            153028819,
            153029568,
            153026498,
            153028052,
            153025493
        ],
        "A": [
            153020368,
            153020226,
            153020322,
            153020992,
            153020103,
            153020887,
            153020140,
            153029667,
            153026118,
            153021963,
            153022767,
            153020503,
            153020639,
            153106719,
            153021802,
            153030757,
            153021324,
            153023320,
            153023010,
            153024495,
            153021594
        ]
    },
    "name": "D. GCD Guess",
    "statement": "There is a positive integer 1\r\nle x\r\nle 10^9 that you have to guess.In one query you can choose two positive\r\nintegers a\r\nneq b. As an answer to this query you will get\r\ngcd(x + a, x + b), where\r\ngcd(n, m) is the greatest common divisor of the numbers n and m.To guess\r\none hidden number x you are allowed to make no more than 30 queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nconst int TEST=0;\nint x;\ninline int ask(int a,int b)\n{\n\tcout << \"? \" << a << \" \" << b << endl;\n\tint k;\n\tif(!TEST)\n\t{\n\t\tcin >> k;\n\t\treturn k;\n\t}\n\tif(TEST)\n\t{\n\t\tcout << __gcd(x+a,x+b) << endl;\n\t\treturn __gcd(x+a,x+b);\n\t}\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tif(TEST) cin >> x;\n\t\tint now=0;\n\t\tfor(int i=0;i<=29;i++)\n\t\t{\n\t\t\tint a=1<<i,b=(3<<i);\n\t\t\tint x=ask(a-now,b-now);\n\t\t\tif(x%(a+a)==0) now+=a;\n\t\t}\n\t\tcout << \"! \" << now << endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "chinese remainder theorem",
        "constructive algorithms",
        "games",
        "interactive",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. GCD Guess.json",
    "editorial_link": "https://codeforces.com//blog/entry/101663",
    "editorial": "EditorialSolution 1Letâs iteratively find the remainder of each power of\r\n. Initially, we know that . If we know that , then how do we find ? To\r\ndo that letâs ask . If , then else . Using this algorithm we will find\r\nwhich is just . It takes exactly queries.Solution 2Letâs consider a set\r\nof pairwise coprime numbers . Their thatâs why . Letâs find each of\r\nthese numbers. To do that, for each we can ask (the query is ). If the\r\nis a multiple of some number from our set then this number is . After\r\nthat we can use the chinese remainder theorem to find that gives the\r\nsame remainders for numbers from the set. This solution asks only\r\nqueries.Observation 1: Itâs enough to make only queries, because if we\r\ndid not find anything for then we can guarantee that will do.Observation\r\n2: All moduli are small, thatâs why it is possible to use a simplified\r\nCRT (check the implementation).\r\n",
    "hint": []
}