{
    "link": "https://codeforces.com//contest/222/problem/E",
    "problemId": "1640",
    "problem_idx": "E",
    "shortId": "222E",
    "contest_number": "222",
    "problem_submissions": {
        "E": [
            2114302,
            2112427,
            2113769,
            2118198,
            2113138,
            2117211,
            2116587,
            2116925,
            2112376,
            2112549,
            2117600,
            2115393,
            2116550,
            2112090,
            2117599,
            2114599,
            2113354,
            2115001,
            2116489,
            2115394
        ],
        "D": [
            2113640,
            2115490,
            2114107,
            2114475,
            2116493,
            2113562,
            2117592,
            2115503,
            2114322,
            2113844,
            2115759,
            2116789,
            2117762,
            2114698,
            2116546,
            2115578,
            2112252,
            2113514,
            2111962,
            2114392
        ],
        "C": [
            2112582,
            2114175,
            2116212,
            2112540,
            2115296,
            2116020,
            2113930,
            2113022,
            2117883,
            2118828,
            2118364,
            2128042,
            2114721,
            2135487
        ],
        "B": [
            2110124,
            2110976,
            2110362,
            2110813,
            2111132,
            2110340,
            2110934,
            2114259,
            2110860,
            2110665,
            2111315,
            2113871,
            2110626,
            2110122,
            2112637,
            2111026,
            2115073,
            2109978,
            2113250,
            2110096
        ],
        "A": [
            2109295,
            2109423,
            2109374,
            2109339,
            2110128,
            2109729,
            2109986,
            2117404,
            2109976,
            2109443,
            2111894,
            2111710,
            2109696,
            2115927,
            2111503,
            2109885,
            2115483,
            2109309,
            2111536,
            2109416
        ]
    },
    "name": "E. Decoding Genome",
    "statement": "Recently a top secret mission to Mars has taken place. As a result,\r\nscientists managed to obtain some information about the Martian DNA. Now\r\nwe know that any Martian DNA contains at most different nucleotides,\r\nnumbered from to . Special characteristics of the Martian DNA prevent\r\nsome nucleotide pairs from following consecutively in this chain. For\r\nexample, if the nucleotide 1 and nucleotide 2 can not follow\r\nconsecutively in the Martian DNA, then the chain of nucleotides [1, 2]\r\nis not a valid chain of Martian DNA, but the chain of nucleotides [2, 1]\r\ncan be a valid chain (if there is no corresponding restriction). The\r\nnumber of nucleotide pairs that can’t follow in the DNA chain\r\nconsecutively, is . The needs of gene research required information\r\nabout the quantity of correct -long chains of the Martian DNA. Your task\r\nis to write a program that will calculate this value.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nstruct Matrix\n{\n\tlong long a[ 53 ][ 53 ];\n\tint n, m;\n\tMatrix( ) { memset( a, 0, sizeof( a ) ); }\n};\n\nvoid operator *= ( Matrix &a, const Matrix &b )\n{\n\tMatrix c;\n\tint i, j, k;\n\tc.n = a.n; c.m = b.m;\n\tfor ( i = 0; i < a.n; i++ )\n\t\tfor ( j = 0; j < a.m; j++ )\n\t\t\tfor ( k = 0; k < b.m; k++ )\n\t\t\t\tc.a[ i ][ k ] = ( c.a[ i ][ k ] + a.a[ i ][ j ] * b.a[ j ][ k ] ) % 1000000007;\n\ta = c;\n}\n\nint main( )\n{\n\tint m, k, i, j, u, v;\n\tlong long n, p, ans = 0;\n\tchar s[ 3 ];\n\tMatrix a, b, c;\n\tscanf(\"%I64d%d%d\", &n, &m, &k); n--;\n\ta.n = 1; a.m = m;\n\tb.n = b.m = m;\n\tc.n = c.m = m;\n\tfor ( i = 0; i < m; i++ )\n\t{\n\t\ta.a[ 0 ][ i ] = 1;\n\t\tc.a[ i ][ i ] = 1;\n\t\tfor ( j = 0; j < m; j++ )\n\t\t\tb.a[ i ][ j ] = 1;\n\t}\n\tfor ( i = 0; i < k; i++ )\n\t{\n\t\tscanf(\"%s\", s);\n\t\tif ( s[ 0 ] >= 'a' && s[ 0 ] <= 'z' )\n\t\t\tu = s[ 0 ] - 'a';\n\t\telse\n\t\t\tu = s[ 0 ] - 'A' + 26;\n\t\tif ( s[ 1 ] >= 'a' && s[ 1 ] <= 'z' )\n\t\t\tv = s[ 1 ] - 'a';\n\t\telse\n\t\t\tv = s[ 1 ] - 'A' + 26;\n\t\tb.a[ v ][ u ] = 0;\n\t}\n\tp = 1;\n\twhile ( p <= n ) p <<= 1;\n\tp >>= 1;\n\twhile ( p )\n\t{\n\t\tc *= c;\n\t\tif ( p & n ) c *= b;\n\t\tp >>= 1;\n\t}\n\ta *= c;\n\tfor ( i = 0; i < m; i++ )\n\t\tans = ( ans + a.a[ 0 ][ i ] ) % 1000000007;\n\tprintf(\"%I64d\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "matrices"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Decoding Genome.json",
    "editorial_link": "https://codeforces.com//blog/entry/5251",
    "editorial": "1) Solution with complexity O(n*m*m), using the dynamic programming: State  d[n][m]  the number of allowed chains of length n that ends in symbol m. Transition  sort out all possible characters, and check if you can put the symbol k after symbol m.\n\n2) Solution with complexity O(m*m*m*log n): Note that the transition in the first solution is always the same. So we can make the transition matrix A of size MxM. If j-th symbol can follow i-th then A[i][j]=1 else A[i][j]=0. Define a vector of size 1?? b={1,1,,1}. We can see that b * a^(n-1) = answer. Now we can use fast exponentiation for computing a^(n-1). We should consider the case with n=1 separately. The answer is the sum of numbers in the vector ans. Complexity  O(m^3) from matrix multiplication and O(log n) from fast exponentiation.",
    "hint": []
}