{"link": "https://codeforces.com//contest/463/problem/D", "problemId": "13412", "problem_idx": "D", "shortId": "463D", "contest_number": "463", "problem_submissions": {"E": [7638960, 7637193, 7682816, 7638248, 7639853, 7638211, 7637973, 7639823, 7643707, 7637460, 7639583, 7639708, 7646111, 7680392], "D": [7633516, 7634297, 7633801, 7632252, 7635569, 7633746, 7635006, 7633676, 7631296, 7637376, 7629043, 7638633, 7636946, 7634549, 7632611, 7631941, 7635806, 7635047, 7633827], "A": [7632250, 7626691, 7626688, 7627018, 7627107, 7626706, 7644040, 7631576, 7626744, 7634237, 7634275, 7626965, 7627191, 7627423, 7627095, 7627639, 7628035, 7635333], "B": [7630537, 7627110, 7627719, 7627619, 7629633, 7628175, 7631202, 7629983, 7627256, 7633605, 7632837, 7629106, 7628563, 7629250, 7629192, 7628955, 7630266, 7636050], "C": [7628696, 7632900, 7632098, 7629603, 7634187, 7640208, 7633142, 7628662, 7678669, 7631060, 7637636, 7632929, 7631029, 7638701, 7635241, 7632886, 7633425, 7630271]}, "name": "D. Gargari and Permutations", "statement": "Gargari got bored to play with the bishops and now, after solving the\r\nproblem about them, he is trying to do math homework. In a math book he\r\nhave found permutations. Each of them consists of numbers in some order.\r\nNow he should find the length of the longest common subsequence of these\r\npermutations. Can you help Gargari?You can read about longest common\r\nsubsequence there:\r\n", "solutions": ["#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <functional>\n\ntypedef long long lld;\n\nconst int N = 1000 + 5;\n\nint A[6][N],n,m,tmp[N],dp[N],pos[6][N];\n\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    for (int i = 1; i <= m; ++ i) {\n        for (int j = 1; j <= n; ++ j) {\n            scanf(\"%d\",&A[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; ++ i) {\n        tmp[A[1][i]] = i;\n    }\n    for (int i = 2; i <= m; ++ i) {\n        for (int j = 1; j <= n; ++ j) {\n            A[i][j] = tmp[A[i][j]];\n            pos[i][A[i][j]] = j;\n        }\n    }\n    memset(dp,0,sizeof(dp));\n    for (int i = 0; i < n; ++ i) {\n        for (int j = i+1; j <= n; ++ j) {\n            if (dp[j]>=dp[i]+1) continue;\n            bool flag = true;\n            for (int k = 2; k <= m; ++ k) {\n                if (pos[k][i] > pos[k][j]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                dp[j] = dp[i] + 1;\n            }\n        }\n    }\n    int answer = 0;\n    for (int i = 1; i <= n; ++ i) {\n        answer = std::max(answer,dp[i]);\n    }\n    printf(\"%d\\n\",answer);\n    return 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "implementation"], "dificulty": "1900", "interactive": false}