{"link": "https://codeforces.com//contest/255/problem/C", "problemId": "2397", "problem_idx": "C", "shortId": "255C", "contest_number": "255", "problem_submissions": {"E": [2781064, 2782909, 2779985, 2800669, 2783123], "D": [2779503, 2780531, 2779855, 7301531, 2779527, 2780996, 2780563, 2778460, 2780405, 2781582, 2779013, 2778273, 2780817, 2782180, 2778681, 2781974, 2781214, 2779597], "C": [2777137, 2775883, 2776972, 2778713, 2776597, 2777246, 2780722, 2776279, 2776811, 2784598, 2781515, 2781103, 2782432, 2778575, 2778477, 2781231, 2777192, 2777224, 2777892], "B": [2774906, 2775664, 2774618, 2774745, 2774652, 2775712, 2774692, 2774662, 2775040, 2776057, 2774786, 2775382, 2774585, 2775601, 2774197, 2775299, 2777977, 2781298], "A": [2773818, 2774831, 2773771, 2774023, 2773753, 2773918, 2773887, 2773828, 2774266, 2774889, 2773857, 2774596, 2773892, 2774053, 2773684, 2774322, 2773855, 2773670]}, "name": "C. Almost Arithmetical Progression", "statement": "Gena loves sequences of numbers. Recently, he has discovered a new type\r\nof sequences which he called an almost arithmetical progression. A\r\nsequence is an , if its elements can be represented as: , where is some\r\ninteger; , where is some integer. Right now Gena has a piece of paper\r\nwith sequence , consisting of integers. Help Gena, find there the\r\nlongest subsequence of integers that is an almost arithmetical\r\nprogression.Sequence is a subsequence of sequence , if there is such\r\nincreasing sequence of indexes , that . In other words, sequence can be\r\nobtained from by crossing out some elements.\r\n", "solutions": ["#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint n;\nint b[4050];\nint f[4050][4050];\nvector<int> pos[1010101];\n\nint calc(int x,int y){\n    if(~f[x][y])\n        return f[x][y];\n    int p;\n    vector<int>::iterator it=lower_bound(pos[b[x]].begin(),pos[b[x]].end(),y+1);\n    if(it==pos[b[x]].end()) p=-1;\n    else p=(*it);\n    if(p==-1)\n        f[x][y]=2;\n    else\n        f[x][y]=calc(y,p)+1;\n    return f[x][y];\n}\n\nint main(){\n    for(int i=0;i<101010;i++)\n        pos[i].clear();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&b[i]);\n        pos[b[i]].push_back(i);\n    }\n    memset(f,-1,sizeof f);\n    \n    if(n==1){\n        printf(\"1\\n\");\n        return 0;\n    }\n        \n    int res=0;\n    for(int i=0;i<n;i++)\n        for(int j=i+1;j<n;j++)\n            res=max(res,calc(i,j));\n    printf(\"%d\\n\",res);\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dp"], "dificulty": "1500", "interactive": false}