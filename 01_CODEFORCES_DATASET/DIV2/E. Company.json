{
    "link": "https://codeforces.com//contest/1062/problem/E",
    "problemId": "254598",
    "problem_idx": "E",
    "shortId": "1062E",
    "contest_number": "1062",
    "problem_submissions": {
        "E": [
            45734560,
            45726248,
            45732249,
            45733619,
            45730195,
            45731475,
            45731239,
            45726325,
            45734429,
            45732687,
            45728510,
            45736860,
            45736172,
            45733982,
            45737130,
            45738771,
            45733014,
            45736808,
            45722467,
            45738588
        ],
        "D": [
            45726634,
            45730736,
            45724741,
            45725065,
            45723696,
            45724136,
            45725257,
            45730810,
            45727060,
            45726669,
            45731523,
            45727302,
            45728487,
            45722718,
            45726364,
            45726645,
            45723445,
            45727784,
            45736639,
            45727419
        ],
        "C": [
            45721626,
            45717978,
            45722013,
            45722920,
            45725107,
            45723347,
            45723217,
            45731817,
            45722296,
            45725538,
            45721997,
            45722995,
            45721715,
            45726048,
            45722887,
            45716980,
            45725662,
            45723495,
            45730894,
            45720161
        ],
        "B": [
            45719368,
            45728287,
            45719414,
            45719514,
            45718037,
            45718991,
            45720410,
            45716157,
            45718932,
            45720927,
            45719221,
            45719468,
            45718546,
            45719917,
            45718393,
            45721972,
            45719490,
            45718006,
            45726769,
            45717530
        ],
        "A": [
            45714856,
            45714050,
            45715684,
            45718665,
            45717504,
            45716696,
            45714768,
            45714213,
            45714103,
            45715993,
            45714126,
            45714813,
            45714920,
            45732371,
            45714819,
            45723775,
            45732706,
            45719793,
            45724251,
            45714073
        ],
        "F": [
            45751027,
            45989276,
            46585917
        ]
    },
    "name": "E. Company",
    "statement": "The company X has n employees numbered from 1 through n. Each employee u\r\nhas a direct boss p_u (1\r\nle p_u\r\nle n), except for the employee 1 who has no boss. It is guaranteed, that\r\nvalues p_i form a tree. Employee u is said to be of employee v if u is\r\nthe direct boss of v or there is an employee w such that w is in charge\r\nof v and u is the direct boss of w. Also, any employee is considered to\r\nbe in charge of himself.In addition, for each employee u we define it’s\r\nlv(u) as follow: lv(1)=0 lv(u)=lv(p_u)+1 for u\r\nneq 1 In the near future, there are q possible plans for the company to\r\noperate. The i-th plan consists of two integers l_i and r_i, meaning\r\nthat all the employees in the range [l_i, r_i], and only they, are\r\ninvolved in this plan. To operate the plan smoothly, there must be a\r\nproject manager who is an employee in charge of the involved employees.\r\nTo be precise, if an employee u is chosen as the project manager for the\r\ni-th plan then for every employee v\r\nin [l_i, r_i], u must be in charge of v. Note, that u is not necessary\r\nin the range [l_i, r_i]. Also, u is always chosen in such a way that\r\nlv(u) is as large as possible (the higher the level is, the lower the\r\nsalary that the company has to pay the employee).Before any plan is\r\noperated, the company has JATC take a look at their plans. After a\r\nglance, he tells the company that for every plan, it’s possible to\r\nreduce the number of the involved employees by one without affecting the\r\nplan. Being greedy, the company asks JATC which employee they should\r\nkick out of the plan so that the level of the project manager required\r\nis as large as possible. JATC has already figured out the answer and\r\nchallenges you to do the same.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200006;\n\nint pin[N],pout[N];\n\nvector<int> G[N];\nint stamp=0;\nint rev[N];\nint depth[N];\nint right[N];\n\nvoid dfs(int now) {\n\t++stamp;\n\tpin[now] = stamp;\n\trev[stamp] = now;\n\tfor (int i:G[now]) {\n\t\tdepth[i] = depth[now] + 1;\n\t\tdfs(i);\n\t}\n\t++stamp;\n\tpout[now] = stamp;\n\trev[stamp] = now;\n}\n\ntypedef pair<int,int> pii;\n#define F first\n#define S second\n\npii operator+(const pii &p1,const pii &p2) {\n\treturn make_pair(min(p1.F,p2.F),max(p1.S,p2.S));\n}\n\nconst pii ee = make_pair(1000000007,-1000000007);\n\nstruct Node {\n\tNode *lc,*rc;\n\tpii val;\n\tNode():lc(NULL),rc(NULL),val(ee){}\n\tvoid pull() {\n\t\tval = (lc->val + rc->val);\n\t}\n};\n\nNode* Build(int L,int R) {\n\tNode* node = new Node();\n\tif (L == R) {\n\t\tnode->val = make_pair(pin[L],pout[L]);\n\t\treturn node;\n\t}\n\tint mid=(L+R)>>1;\n\tnode->lc = Build(L,mid);\n\tnode->rc = Build(mid+1,R);\n\tnode->pull();\n\treturn node;\n}\n\nvoid modify(Node* node,int L,int R,int pos,pii val) {\n\tif (L==R) {\n\t\tnode->val = val;\n\t\treturn;\n\t}\n\tint mid=(L+R)>>1;\n\tif (pos <= mid) modify(node->lc,L,mid,pos,val);\n\telse modify(node->rc,mid+1,R,pos,val);\n\tnode->pull();\n\treturn;\n}\n\npii query(Node* node,int L,int R,int l,int r) {\n\tif (l>R || L>r) return ee;\n\telse if (l<=L && R<=r) return node->val;\n\tint mid=(L+R)>>1;\n\treturn (query(node->lc,L,mid,l,r) + query(node->rc,mid+1,R,l,r));\n}\nconst int P = 19;\nint lca[P][N];\n\nint Q(int L,int R) {\n\t//return id\n\tint x = rev[L];\n\tif (pin[x] <= L && R <= pout[x]) return depth[x];\n\t// cout << \"ori x = \" << x << endl;\n\tfor (int i=P-1;i>=0;--i) {\n\t\tint y = lca[i][x];\n\t\t// cout << \"y = \" << y << \" , i = \" << i << endl;\n\t\t// cout << \"pin = \" << pin[y] << \" , pout = \" << pout[y] << endl;\n\t\t// cout << \"x = \" << x << endl;\n\t\tif (pin[y] <= L && R <= pout[y]) ;\n\t\telse x = lca[i][x];\n\t}\n\t// cout << \"x = \" << x << endl;\n\treturn depth[lca[0][x]];\n}\n\nint main () {\n\tint n,q;\n\tscanf(\"%d %d\",&n,&q);\n\tmap<pii,int> mp;\n\tlca[0][1] = 1;\n\tfor (int i=2;i<=n;++i) {\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tG[p].push_back(i);\n\t\tlca[0][i] = p;\n\t}\n\tfor (int i=1;i<P;++i) {\n\t\tfor (int j=1;j<=n;++j) {\n\t\t\tlca[i][j] = lca[i-1][ lca[i-1][j] ];\n\t\t}\n\t}\n\tdfs(1);\n\tNode* root = Build(1,n);\n\twhile (q--) {\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tpii ret = query(root,1,n,l,r);\n\t\t// cerr << \"finish query \" << endl;\n\t\t// cerr << \"ret = \" <<ret.F << \" , \" << ret.S << endl;\n\t\tint lvl = Q(ret.F,ret.S), del = l;\n\t\t// cerr << \"lvl = \" << lvl << \" , del = \" << del << endl;\n\t\t//delete with id ret.F\n\t\tint del1 = rev[ret.F];\n\t\tpii ret1 = (query(root,1,n,l,del1-1)+query(root,1,n,del1+1,r));\n\t\tint tmplvl=Q(ret1.F,ret1.S);\n\t\tif (tmplvl > lvl) {\n\t\t\tlvl = tmplvl;\n\t\t\tdel = del1;\n\t\t}\n\t\tint del2 = rev[ret.S];\n\t\t// cerr << \"del1 = \" << del1 << \" , del2 = \" << del2 << endl;\n\t\tpii ret2 = (query(root,1,n,l,del2-1)+query(root,1,n,del2+1,r));\n\t\t// cout << \"ret2 = \" << ret2.F << \" , \" << ret2.S << endl;\n\t\t// cout << \"tmplv; = \" << tmplvl << endl;\n\t\ttmplvl = Q(ret2.F,ret2.S);\n\t\tif (tmplvl > lvl) {\n\t\t\tlvl = tmplvl;\n\t\t\tdel = del2;\n\t\t}\n\t\tprintf(\"%d %d\\n\",del,lvl);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Company.json",
    "editorial_link": "https://codeforces.com/blog/entry/63199",
    "editorial": "Letâs call the time that we reach the node in depth first search and\r\nwhere is a child of . If node is in charge of node ( is an ancestor of )\r\nthen . Suppose we donât have to ignore any node then the answer to each\r\nquery is the LCA of two nodes and (), where and are chosen so that and .\r\nProof: Let be the LCA of and , then . For every node , is an ancestor of\r\n. Therefore, the node that needs to be ignored is either or . Suppose we\r\nignore , the query splits into two halves . We find the LCA to each half\r\nand get the LCA of them. We do similarly for and optimize the\r\nanswer.Complexity: .\r\n",
    "hint": []
}