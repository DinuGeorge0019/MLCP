{
    "link": "https://codeforces.com//contest/490/problem/C",
    "problemId": "17897",
    "problem_idx": "C",
    "shortId": "490C",
    "contest_number": "490",
    "problem_submissions": {
        "F": [
            8817515,
            8819985,
            8842361,
            8817338,
            8817935,
            8817635,
            8855350,
            8819845,
            8823757,
            8823458,
            8821739,
            8820145
        ],
        "E": [
            8815308,
            8814782,
            8815162,
            8819489,
            8815467,
            8822097,
            8817785,
            8817507,
            8817956,
            8818730,
            8821845,
            8820184,
            8819671,
            8820855,
            8817217,
            8822605,
            8820689
        ],
        "D": [
            8813861,
            8818202,
            8817853,
            8814442,
            8820510,
            8816678,
            8814870,
            8815149,
            8814552,
            8815859,
            8816515,
            8814018,
            8816647,
            8817008,
            8816236,
            8820552,
            8814405,
            8814971,
            8817626,
            8817113
        ],
        "C": [
            8812444,
            8815662,
            8813217,
            8812979,
            8814331,
            8811719,
            8813130,
            8812621,
            8821924,
            8813827,
            8814389,
            8812560,
            8812032,
            8814787,
            8814945,
            8814699,
            8813034,
            8813032,
            8813495,
            8815850
        ],
        "B": [
            8811804,
            8812050,
            8811800,
            8811893,
            8812411,
            8813404,
            8812022,
            8811615,
            8813128,
            8812542,
            8812723,
            8811783,
            8814873,
            8813230,
            8813299,
            8812788,
            8811816,
            8811980,
            8812324,
            8813904
        ],
        "A": [
            8810238,
            8810285,
            8810322,
            8810378,
            8810319,
            8812020,
            8810257,
            8810233,
            8811808,
            8810284,
            8810467,
            8810179,
            8810618,
            8811059,
            8810734,
            8811110,
            8810293,
            8810358,
            8810190,
            8811062
        ]
    },
    "name": "C. Hacking Cypher",
    "statement": "Polycarpus participates in a competition for hacking into a new secure\r\nmessenger. Heâ€™s almost won.Having carefully studied the interaction\r\nprotocol, Polycarpus came to the conclusion that the secret key can be\r\nobtained if he properly cuts the public key of the application into two\r\nparts. The public key is a long integer which may consist of even a\r\nmillion digits!Polycarpus needs to find such a way to cut the public key\r\ninto two nonempty parts, that the first (left) part is divisible by as a\r\nseparate number, and the second (right) part is divisible by as a\r\nseparate number. Both parts should be integers that have no leading\r\nzeros. Polycarpus knows values and .Help Polycarpus and find any\r\nsuitable method to cut the public key.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, f[1000001], A, B;\nchar str[1000011];\nbool b[1000001];\n\nint main(){\n    // freopen(\"c.in\", \"r\", stdin);\n    // freopen(\"c.out\", \"w\", stdout);\n     scanf(\"%s\", str + 1);\n     n = strlen(str + 1);\n     if (str[1] == '0')\n     {\n          printf(\"NO\\n\");\n          return 0;\n     }\n     scanf(\"%d%d\", &A, &B); \n     memset(b, false, sizeof(b));\n     for (int i = 1, j = 0; i <= n; i++)\n     {\n          j = (j * 10 + str[i] - '0') % A;\n          if (!j) b[i] = true;\n     }\n     f[0] = 1;\n     for (int i = 1; i <= n; i++) f[i] = f[i - 1] * 10 % B;\n     for (int i = n, j = 0; i > 1; --i)\n     {\n          j += f[n - i] * (str[i] - '0') % B;\n          j %= B;\n          if (!j && str[i] != '0' && b[i - 1])\n          {\n               printf(\"YES\\n\");\n               for (int k = 1; k < i; k++) printf(\"%c\", str[k]);\n               printf(\"\\n\");\n               for (int k = i; k <= n; k++) printf(\"%c\", str[k]);\n               printf(\"\\n\");\n               return 0;\n          }\n     }\n     printf(\"NO\\n\");\n     return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "number theory",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Hacking Cypher.json",
    "editorial_link": "https://codeforces.com//blog/entry/14849",
    "editorial": "At first, let s check all prefixes of specified number do they have\r\nremainder 0 when divided by the ? It can be done with asymptotic\r\nbehavior , where -length of specified number . If we have remainder of\r\ndivision by of prefix, which ends in position , we can count remainder\r\nin position :\r\n",
    "hint": []
}