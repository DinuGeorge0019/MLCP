{
    "link": "https://codeforces.com//contest/869/problem/B",
    "problemId": "126369",
    "problem_idx": "B",
    "shortId": "869B",
    "contest_number": "869",
    "problem_submissions": {
        "D": [
            31079634,
            31141598,
            31145705
        ],
        "E": [
            31075785,
            31069215,
            31080040,
            31081323,
            31074160,
            31082163,
            31082035,
            31082564,
            31082141,
            31081908,
            31081217,
            31081628,
            31082993,
            31083283,
            31083912,
            31087767,
            31084108,
            31078586,
            31084855,
            31083040
        ],
        "A": [
            31067793,
            31073676,
            31074428,
            31068201,
            31086909,
            31079089,
            31067885,
            31068981,
            31068063,
            31067651,
            31070628,
            31074705,
            31084568,
            31078753,
            31067709,
            31067304,
            31161754,
            31073201,
            31081947,
            31075757,
            31070398
        ],
        "B": [
            31073025,
            31075269,
            31070123,
            31075379,
            31070811,
            31071135,
            31069986,
            31068990,
            31069939,
            31070787,
            31070307,
            31076966,
            31068695,
            31068797,
            31070262,
            31082457,
            31069869,
            31072376
        ],
        "C": [
            31072413,
            31073328,
            31078301,
            31083141,
            31075905,
            31078217,
            31077340,
            31075408,
            31078573,
            31078127,
            31076488,
            31075475,
            31078939,
            31081015,
            31078419,
            31081092,
            31079081,
            31082030
        ]
    },
    "name": "B. The Eternal Immortality",
    "statement": "Pile up herbs and incense, and arise again from the flames and ashes of\r\nits predecessor as is known to many, the phoenix does it like this.The\r\nphoenix has a rather long lifespan, and reincarnates itself once every\r\nyears. Here denotes the factorial of integer , that is, . Specifically,\r\n.Koyomi doesn\u2019t care much about this, but before he gets into another\r\nmess with oddities, he is interested in the number of times the phoenix\r\nwill reincarnate in a timespan of years, that is, . Note that when this\r\nvalue is always integer.As the answer can be quite large, it would be\r\nenough for Koyomi just to know . And you\u2019re here to provide Koyomi with\r\nthis knowledge.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint main()\n{\n\tll a,b;\n\tcin>>a>>b;\n\tll f=1;\n\tfor(ll x=b;x>a;--x)\n\t{\n\t\tf=f*(x%10)%10;\n\t\tif(!f) break;\n\t}\n\tprintf(\"%d\\n\",(int)f);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. The Eternal Immortality.json",
    "editorial_link": "https://codeforces.com//blog/entry/55009",
    "editorial": "equals . Consider the multiplicands one by one, and when the last digit\r\nof the product becomes , it stays unchanged from then on.Hence we can\r\nmultiply the integers one by one, only preserving the last digit (take\r\nit modulo whenever possible), and stop when it becomes . It\u00e2\u0080\u0099s obvious\r\nthat at most multiplications are needed before stopping, and it\u00e2\u0080\u0099s not\r\nhard to prove a tighter upper bound of .Take care, integer overflow can\r\nemerge everywhere!\r\n"
}