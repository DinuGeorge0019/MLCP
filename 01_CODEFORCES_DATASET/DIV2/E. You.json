{
    "link": "https://codeforces.com//contest/1554/problem/E",
    "problemId": "1061275",
    "problem_idx": "E",
    "shortId": "1554E",
    "contest_number": "1554",
    "problem_submissions": {
        "E": [
            124159772,
            124162157,
            124167652,
            124165214,
            124231575,
            124169217,
            124380405,
            124171964,
            124171215,
            124172755,
            124172343,
            124148786,
            124173544,
            124173029,
            124172156,
            124722686,
            124178015,
            124181128,
            124171059,
            124379676,
            124174188,
            124167350,
            124176198,
            124182633
        ],
        "C": [
            124139083,
            124143057,
            124140544,
            124149111,
            124145223,
            124380376,
            124143439,
            124145496,
            124139702,
            124142795,
            124144864,
            124142215,
            124143699,
            124149801,
            124722675,
            124143912,
            124138305,
            124142838,
            124379535,
            124143555,
            124137768,
            124156436,
            124140590
        ],
        "D": [
            124138945,
            124146593,
            124147043,
            124143497,
            124147282,
            124380395,
            124147023,
            124143045,
            124146870,
            124147125,
            124165711,
            124147949,
            124154200,
            124153233,
            124722679,
            124147474,
            124150406,
            124141042,
            124379671,
            124146642,
            124143310,
            124148096,
            124148678
        ],
        "B": [
            124134751,
            124135695,
            124133759,
            124135797,
            124133509,
            124380367,
            124137647,
            124131777,
            124134150,
            124255622,
            124137477,
            124153106,
            124136364,
            124136471,
            124137060,
            124722664,
            124134959,
            124141246,
            124133658,
            124379482,
            124138040,
            124170775,
            124151266,
            124133287
        ],
        "A": [
            124132044,
            124128630,
            124128905,
            124135949,
            124129333,
            124380302,
            124134132,
            124133855,
            124129278,
            124128741,
            124153971,
            124131823,
            124130363,
            124130846,
            124722661,
            124128707,
            124142173,
            124128567,
            124379467,
            124129604,
            124168196,
            124139115,
            124128957
        ]
    },
    "name": "E. You",
    "statement": "You are given a tree with n nodes. As a reminder, a tree is a connected\r\nundirected graph without cycles.Let a_1, a_2,\r\nldots, a_n be a sequence of integers. Perform the following operation n\r\ntimes: Select an node u. Assign a_u := number of nodes adjacent to u.\r\nThen, erase the node u along with all edges that have it as an endpoint.\r\nFor each integer k from 1 to n, find the number, modulo 998\r\n,244\r\n,353, of different sequences a_1, a_2,\r\nldots, a_n that satisfy the following conditions: it is possible to\r\nobtain a by performing the aforementioned operations n times in some\r\norder.\r\noperatorname{gcd}(a_1, a_2,\r\nldots, a_n) = k. Here,\r\noperatorname{gcd} means the greatest common divisor of the elements in\r\na.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nconst int MOD=998244353;\nint add(int x,int y){return x+y>=MOD?x+y-MOD:x+y;}\nint sub(int x,int y){return x>=y?x-y:x+MOD-y;}\n\nvector<int> ed[200000];\n\nint sz[200000];\n\nvoid dfs(int u,int f)\n{\n\tsz[u]=1;\n\tfor(int i=0;i<ed[u].size();i++)\n\t{\n\t\tif(ed[u][i]!=f)dfs(ed[u][i],u),sz[u]+=sz[ed[u][i]];\n\t}\n}\n\nint ans[200000],pw2[200000];\n\nvector<int> div[200000];\n\nint main()\n{\n\tpw2[0]=1;for(int i=1;i<=100000;i++)pw2[i]=add(pw2[i-1],pw2[i-1]);\n\tfor(int i=2;i<=100000;i++)\n\t{\n\t\tfor(int j=2;j*i<=100000;j++)div[i*j].push_back(i);\n\t}\n\tint T=0;scanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tint n=0;scanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)ed[i].clear();\n\t\tfor(int i=1,x=0,y=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);ed[x].push_back(y),ed[y].push_back(x);\n\t\t}\n\t\tdfs(1,0);\n\t\tfor(int i=1;i<=n;i++)ans[i]=0;\n\t\tans[1]=pw2[n-1];\n\t\tfor(int i=2;i<n;i++)\n\t\t{\n\t\t\tif((n-1)%i==0)\n\t\t\t{\n\t\t\t\tbool fl=1;\n\t\t\t\tfor(int j=1;j<=n;j++)if(sz[j]%i!=0&&(sz[j]-1)%i!=0){fl=0;break;}\n\t\t\t\tif(fl)ans[i]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=n;i>=2;i--)\n\t\t{\n\t\t\tif(ans[i])\n\t\t\t{\n\t\t\t\tfor(int j=0;j<div[i].size();j++)ans[div[i][j]]=0;ans[1]=sub(ans[1],1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);puts(\"\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. You.json",
    "editorial_link": "https://codeforces.com//blog/entry/93321",
    "editorial": "Let\u00e2\u0080\u0099s find which sequences of are possible to obtain by performing the\r\nmentioned operations exactly times in some order. Consider all\r\ninitially. For each edge , either increase by (assign to ) or increase\r\nby ((assign to ). The final sequences are the only possible sequences\r\nthat can possibly be. You can observe it by noticing that when we select\r\na node and delete it, the existing edges adjacent to the node gets\r\nassigned to it.Notice that, the final sequences are unique. So there are\r\ndistinct sequences possible. That\u00e2\u0080\u0099s because there are edges and for each\r\nedge we have options either assign it to or .Now for each from to , we\r\nhave to find the number of sequences which has gcd equals to . Instead,\r\nlet\u00e2\u0080\u0099s find the number of sequences such that each of its values is\r\ndivisible by . Let it be .For , all sequences are valid. So .Assume .\r\nLet\u00e2\u0080\u0099s construct a sequence such that each is divisible by . First, root\r\nthe tree at node . We will build the array in a bottom-up manner. Let be\r\nthe set of childs of and be the parent of . Assume that we have set the\r\nvalues for each . Now we will set the value of . For each edge such that\r\n, if we have assigned this edge to , then do nothing, otherwise we must\r\nassign it to i.e increase by . After we are done with all the edges, if\r\nis divisible by , then we can\u00e2\u0080\u0099t assign the edge to because will be\r\nincreased by and as is divisible by , will not be divisible by because .\r\nif is not divisible by , then we must assign the edge to and thus\r\nincreasing by . If now is divisible by , then we are done, otherwise we\r\ncan\u00e2\u0080\u0099t make divisible by . So we terminate here. If we can successfully\r\nset the values of for each from to , then will be non-zero. for is\r\neither or . We can say this by observing the building process of that\r\nhas been discussed already.So for each from to , we can find the value\r\nof in by performing a simple dfs. So all can be found in . If doesn\u00e2\u0080\u0099t\r\ndivide , then . Notice that . So for any integer , if each is divisible\r\n, then must divide . Similarly, if doesn\u00e2\u0080\u0099t divide , then each will not\r\nbe divisible by and will be .So we only have to perform a dfs when\r\ndivides . So all can be found in where is the number of divisors of .\r\nLet be the number of sequences which has gcd equals to . We can notice\r\nthat .So we can find for each from to in .\r\n"
}