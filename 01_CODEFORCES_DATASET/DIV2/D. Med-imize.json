{
    "link": "https://codeforces.com//contest/1993/problem/D",
    "problemId": "2795984",
    "problem_idx": "D",
    "shortId": "1993D",
    "contest_number": "1993",
    "problem_submissions": {
        "C": [
            274402188,
            274358757,
            274374996,
            274374747,
            274368652,
            274357644,
            274365562,
            274356432,
            274379356,
            274367132,
            274372055,
            274371076,
            274363983,
            274370693,
            274369864,
            274367679,
            274363345,
            274405366,
            274364436
        ],
        "B": [
            274397223,
            274346884,
            274361191,
            274359127,
            274350863,
            274346370,
            274355668,
            274347298,
            274365588,
            274350765,
            274364310,
            274350846,
            274352824,
            274355191,
            274352816,
            274350915,
            274351222,
            274395841,
            274351441
        ],
        "A": [
            274391220,
            274335769,
            274358967,
            274335712,
            274338856,
            274337195,
            274340094,
            274335737,
            274356689,
            274336110,
            274349520,
            274336792,
            274342378,
            274342208,
            274335539,
            274352863,
            274335926,
            274386754,
            274342173
        ],
        "D": [
            274387898,
            274378476,
            274479687,
            274386087,
            274394516,
            274379793,
            274384145,
            274380644,
            274383004,
            274432739,
            274365274,
            274383568,
            274381874,
            274380805,
            274387445,
            274383605,
            274390133,
            275106936,
            274388789,
            274469604,
            274391022,
            274416385,
            274388682
        ],
        "E": [
            274380482,
            274416572,
            274415942,
            274406977,
            274400748,
            275106863,
            274409594,
            281997956,
            274569827
        ],
        "F2": [
            274361444,
            274397454,
            274414076,
            274417256,
            274415219,
            276095739,
            274383447
        ],
        "F1": [
            274349830,
            274385685,
            274402182,
            274415340,
            274413779,
            274417154,
            274400648,
            274391762,
            274403361,
            274395449,
            274405171,
            274404884,
            274415155,
            274426602,
            274426556,
            274426256,
            274400601,
            274403335,
            274384119,
            274407161
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132185",
    "editorial": "Note: in order to explain this solution easier, weâll suppose\nall arrays are 0-indexed.If , we donât have to remove any segment since\nthe statement only tell us to do it while the length of is greater than\n. That way, the median of is fixed. Letâs find a way to calculate this\nvalue without sorting the array.Given an integer . If is less than or\nequal to the median of , then suppose we sort in increasing order, is\nsomewhat to the left of . That means the number of elements greater than\nor equal to is more than the number of elements less than . Using this\nobservation, we can create another array of the same size as , such that\nif , otherwise . The trick here is if , then the condition is satisfied.\nUsing this trick, we can easily binary search the median of by fixing\nvalue of , checking if and adjusting the value range of .How about . In\nthis case, weâll keep using the same strategy as above. That is: fix the\nvalue of , find a way to delete segments of so that the array has\nlargest sum, check if that sum is greater than and adjust the value\nrange of the answer.Note that each time we delete a segment, the size of\nis reduced by . We do that until . Letâs call the final array after\ndeleting segments . After some calculation, we come up with .Also, it\ncan be seen that the elements (where ) always originate from the\nelements such that . Why?Suppose we want to delete the segment from .\nThis operation shift all the elements from the right by units to the\nleft, which means the indexes are subtracted by units. But if we only\ncare about the indexes modulo before and after deleting the segments,\nshifting units doesnât change their modulos at all.With all above\nobservations, we come up with the following DP formula to find the\noptimal segment deletions: If and , then Otherwise . If then maximize by\nThen, the maximum sum of in the optimal deletions equals to .Time\ncomplexity: .\n",
    "name": "D. Med-imize",
    "statement": "Given two positive integers n and k, and another array a of n\r\nintegers.In one operation, you can select any subarray of size k of a,\r\nthen remove it from the array without changing the order of other\r\nelements. More formally, let (l, r) be an operation on subarray a_l,\r\na_{l+1},\r\nldots, a_r such that r-l+1=k, then performing this operation means\r\nreplacing a with [a_1,\r\nldots, a_{l-1}, a_{r+1},\r\nldots, a_n].For example, if a=[1,2,3,4,5] and we perform operation (3,5)\r\non this array, it will become a=[1,2]. Moreover, operation (2, 4)\r\nresults in a=[1,5], and operation (1,3) results in a=[4,5]. You have to\r\nrepeat the operation while the length of a is greater than k (which\r\nmeans |a|\r\ngt k). What is the largest possible median^\r\ndagger of all remaining elements of the array a after the process?^\r\ndaggerThe median of an array of length n is the element whose index is\r\nleft\r\nlfloor (n+1)/2\r\nright\r\nrfloor after we sort the elements in non-decreasing order. For example:\r\nmedian([2,1,5,4,3]) = 3, median([5]) = 5, and median([6,8,2,4]) = 4.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<\"=\"<<x<<\"\\n\";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+\".in\").c_str(),\"r\",stdin);\tfreopen((s+\".out\").c_str(),\"w\",stdout);}void run(){\tint n,k;\tcin>>n>>k;\tvi a(n);\trep(i,n)cin>>a[i];\tint l=0,r=1100000000;\twhile(l<r){\t\tint mid=(l+r+1)>>1;\t\tvi f(n+1,-INF);\t\tf[0]=0;\t\trep(i,n){\t\t\tint cf=f[i];\t\t\tif(i%k==0)cf=0;\t\t\tint ci=((a[i]>mid)?1:-1);\t\t\tMx(f[i+1],cf+ci);\t\t\tif(i+k<=n)Mx(f[i+k],f[i]);\t\t}//\t\tcout<<\"mid=\"<<mid<<\"\\n\";//\t\trep(i,n+1)cout<<i<<\" \"<<f[i]<<\"\\n\";cout<<\"\\n\\n\";\t\tif(f[n]>0)l=mid;\t\telse r=mid-1;\t}\tcout<<l+1<<\"\\n\";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Med-imize.json",
    "hint": [
        "Hint 1 Is there any method to calculate median without sorting?",
        "Hint 2 Is there any relationship between the original array with the final array?"
    ]
}