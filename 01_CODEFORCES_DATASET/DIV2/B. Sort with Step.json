{"link": "https://codeforces.com//contest/1823/problem/B", "problemId": "1896868", "problem_idx": "B", "shortId": "1823B", "contest_number": "1823", "problem_submissions": {"E": [203705839, 203701788, 203710907, 203711770, 203705371, 203702158, 203705164, 203708687, 203695617, 203698015, 203713863, 203711164, 203711208], "F": [203698273, 203688371, 203699854, 203692525, 203713776, 203706591, 203701681, 203697250, 203707004, 203714464, 203718741, 203709649, 204276537, 203715624], "D": [203690544, 203695164, 203688855, 203701895, 203696407, 203691855, 203694127, 203710546, 203714159, 203700668, 203695441, 203690745, 203703946, 203707611, 203710099, 203694539, 203701580, 203697921, 203699365], "C": [203682587, 203678999, 203681052, 203684144, 203687732, 203680914, 203689997, 203682944, 203686588, 203690248, 203682397, 203683673, 203689305, 203682640, 203682923, 203682065, 203686779, 203685407, 203684445, 203683205], "B": [203677458, 203684522, 203677423, 203681465, 203680710, 203678118, 203686689, 203678181, 203679545, 203680940, 203678605, 203678733, 203683292, 203678419, 203679073, 203679634, 203680902, 203679216, 203679313], "A": [203676393, 203676826, 203676383, 203676665, 203678720, 203676331, 203678496, 203676540, 203676948, 203676909, 203676591, 203676707, 203676528, 203676629, 203676389, 203676483, 203678253, 203677369, 203678056]}, "name": "B. Sort with Step", "statement": "Let\u2019s define a of length n as an array p of length n, which contains\r\nevery number from 1 to n exactly once.You are given a permutation p_1,\r\np_2,\r\ndots, p_n and a number k. You need to sort this permutation in the\r\nascending order. In order to do it, you can repeat the following\r\noperation any number of times (possibly, zero): pick two elements of the\r\npermutation p_i and p_j such that |i - j| = k, and swap them.\r\nUnfortunately, some permutations can\u2019t be sorted with some fixed numbers\r\nk. For example, it\u2019s impossible to sort [2, 4, 3, 1] with k = 2.That\u2019s\r\nwhy, before starting the sorting, you can make at most one : choose any\r\npair p_i and p_j and swap them. Your task is to: check whether is it\r\npossible to sort the permutation any preliminary exchanges, if it\u2019s not,\r\ncheck, whether is it possible to sort the permutation using exactly\r\npreliminary exchange. For example, if k = 2 and permutation is [2, 4, 3,\r\n1], then you can make a preliminary exchange of p_1 and p_4, which will\r\nproduce permutation [1, 4, 3, 2], which is possible to sort with given\r\nk.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    for(int i=0; i<n; ++i) cin >> a[i],a[i]--;\n    int de=0;\n    for(int i=0; i<n; ++i) if(a[i]%k!=i%k) de++;\n    assert(de!=1);\n    if(de==0) cout << \"0\\n\";\n    else if(de==2) cout << \"1\\n\";\n    else cout << \"-1\\n\";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}"], "input": "", "output": "", "tags": ["brute force", "math", "sortings"], "dificulty": "900", "interactive": false}