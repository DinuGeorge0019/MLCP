{
    "link": "https://codeforces.com//contest/940/problem/F",
    "problemId": "159604",
    "problem_idx": "F",
    "shortId": "940F",
    "contest_number": "940",
    "problem_submissions": {
        "F": [
            35642079,
            35639249,
            35741635,
            36062963,
            36289513
        ],
        "E": [
            35635658,
            35633935,
            35631463,
            35633682,
            35625185,
            35633814,
            35633623,
            35626225,
            35634924,
            35632939,
            35633342,
            35637140,
            35635889,
            35635053,
            35634184,
            35633752,
            35646808,
            35646714,
            35632320,
            35632703
        ],
        "C": [
            35629972,
            35623066,
            35624318,
            35625052,
            35625312,
            35628608,
            35627465,
            35626058,
            35629009,
            35622773,
            35623814,
            35626574,
            35624743,
            35624088,
            35624644,
            35624203,
            35626389,
            35626478,
            35625921
        ],
        "A": [
            35626916,
            35619951,
            35619990,
            35620867,
            43064576,
            35620290,
            35621938,
            35620031,
            35620370,
            35620395,
            35619980,
            35620028,
            35620003,
            35619970,
            35620016,
            35620214,
            35619977,
            35620645,
            35623155,
            35620719
        ],
        "B": [
            35625745,
            35621065,
            35621588,
            35622435,
            35622147,
            35624740,
            35624541,
            35622933,
            35622325,
            35621538,
            35621447,
            35624471,
            35622193,
            35621648,
            35621812,
            35621709,
            35623702,
            35624565,
            35622680
        ],
        "D": [
            35623541,
            35626308,
            35627049,
            35628539,
            35628655,
            35631444,
            35629469,
            35628621,
            35633730,
            35625705,
            35628318,
            35630442,
            35631472,
            35627122,
            35630218,
            35630123,
            35629593,
            35629487,
            35628885
        ]
    },
    "name": "F. Machine Learning",
    "statement": "You are given an array . You have to answer the following queries: You\r\nare given two integers and . Let be the number of occurrences of in ,\r\nwhere is the subarray of from -th element to -th inclusive. Find the of\r\nYou are given two integers to . Change to . The of a multiset of numbers\r\nis the smallest non-negative integer the set.Note that in this problem\r\nall elements of are positive, which means that = 0 and is never the\r\nanswer for the query of the second type.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nstruct que{\n\tint l, r, t, id, ans;\n}q[100005];\nstruct modify{\n\tint pos, r, x;\n}mo[100005];\nint n, m, m1, m2;\nint a[100005], tt[100005];\nint tmp[200005], vis[200005], tp;\nint vi2[200005];\nint dk[200005], K;\nint cmp(que x, que y){\n\tif(dk[x.l] != dk[y.l]) return dk[x.l] < dk[y.l];\n\tif(dk[x.r] != dk[y.r]) return dk[x.r] < dk[y.r];\n\treturn x.t < y.t;\n}\nint cmp2(que x, que y){\n\treturn x.id < y.id;\n}\nvoid solve(){\n\tint l = 1, r = 0, t = 0;\n\tfor(int i = 1; i <= m1; i ++){\n\t\twhile(l > q[i].l){\n\t\t\tl--;\n\t\t\tvi2[vis[a[l]]] --;\n\t\t\tvis[a[l]] ++;\n\t\t\tvi2[vis[a[l]]] ++;\n\t\t}\n\t\twhile(r < q[i].r){\n\t\t\tr++;\n\t\t\tvi2[vis[a[r]]] --;\n\t\t\tvis[a[r]] ++;\n\t\t\tvi2[vis[a[r]]] ++;\n\t\t}\n\t\twhile(l < q[i].l){\n\t\t\tvi2[vis[a[l]]] --;\n\t\t\tvis[a[l]] --;\n\t\t\tvi2[vis[a[l]]] ++;\n\t\t\tl++;\n\t\t}\n\t\twhile(r > q[i].r){\n\t\t\tvi2[vis[a[r]]] --;\n\t\t\tvis[a[r]] --;\n\t\t\tvi2[vis[a[r]]] ++;\n\t\t\tr--;\n\t\t}\n\t\twhile(t < q[i].t){\n\t\t\tt++;\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]--;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t\ta[mo[t].pos] = mo[t].x;\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]++;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t}\n\t\twhile(t > q[i].t){\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]--;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t\ta[mo[t].pos] = mo[t].r;\n\t\t\tif(mo[t].pos >= l && mo[t].pos <= r){\n\t\t\t\tvi2[vis[a[mo[t].pos]]]--;\n\t\t\t\tvis[a[mo[t].pos]]++;\n\t\t\t\tvi2[vis[a[mo[t].pos]]]++;\n\t\t\t}\n\t\t\tt--;\n\t\t}\n\t\tq[i].ans = 1;\n\t\twhile(vi2[q[i].ans]) q[i].ans++;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i ++){\n\t\tscanf(\"%d\", &a[i]);\n\t\ttmp[++tp] = a[i];\n\t}\n\tfor(int i = 1; i <= m; i ++){\n\t\tint opt, l, r;\n\t\tscanf(\"%d%d%d\", &opt, &l, &r);\n\t\tif(opt == 1){\n\t\t\tm1++;\n\t\t\tq[m1].l = l; q[m1].r = r; q[m1].t = m2;\n\t\t\tq[m1].id = i;\n\t\t}\n\t\tif(opt == 2){\n\t\t\tm2++;\n\t\t\tmo[m2].pos = l;\n\t\t\tmo[m2].x = r;\n\t\t\ttmp[++tp] = r;\n\t\t}\n\t}\n\tsort(tmp + 1, tmp + tp + 1);\n\tfor(int i = 1; i <= n; i ++){\n\t\ta[i] = lower_bound(tmp + 1, tmp + tp + 1, a[i]) - tmp;\n\t\ttt[i] = a[i];\n\t}\n\tfor(int i = 1; i <= m2; i ++){\n\t\tmo[i].x = lower_bound(tmp + 1, tmp + tp + 1, mo[i].x) - tmp;\n\t\tmo[i].r = tt[mo[i].pos];\n\t\ttt[mo[i].pos] = mo[i].x;\n\t}\n\tK = max(1, min(n, (int)(pow(n, 2.00 / 3.00))));\n\tfor(int i = 1; i <= n; i ++){\n\t\tdk[i] = (i - 1) / K + 1;\n\t}\n\tsort(q + 1, q + m1 + 1, cmp);\n\tsolve();\n\tsort(q + 1, q + m1 + 1, cmp2);\n\tfor(int i = 1; i <= m1; i ++){\n\t\tprintf(\"%d\\n\", q[i].ans);\n\t}\n\treturn 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Machine Learning.json",
    "editorial_link": "https://codeforces.com//blog/entry/58033",
    "editorial": "At first let\u00e2\u0080\u0099s find out minimum length of array, such that answer for it\r\nis . For it on this segment there should be a number that has one\r\noccurrence, some number that has two occurrences, etc. Length of this\r\nsegment will be . That\u00e2\u0080\u0099s why answer won\u00e2\u0080\u0099t exceed for any query.Let\u00e2\u0080\u0099s\r\ncompress numbers in such a way that numbers from array and from queries\r\nwill be in range from to . Obviously this modification won\u00e2\u0080\u0099t change\r\nanswer, but now elements won\u00e2\u0080\u0099t exceed .Suppose for interval we know\r\nnumber of occurrences of each number and number of occurrences of each\r\nnumber of occurrences . Then we can find Mex of this set in . Moreover\r\nit\u00e2\u0080\u0099s easy to update arrays and for segments , , and in time.We will\r\nrepresent each query as tuple of integers where t is a number of change\r\nqueries before this, and segment . It\u00e2\u0080\u0099s easy to see that can also be\r\nchanged by one in time. Because of will replace to in following part of\r\neditorial.Let and let\u00e2\u0080\u0099s sort queries by triples and will answer queries\r\nin this order. Border will be increased by for each sqaure of size sum\r\nof movements of right border is . For each query borders and are moved\r\nby not more than sum of movements is .Solution has time complexity .\r\n"
}