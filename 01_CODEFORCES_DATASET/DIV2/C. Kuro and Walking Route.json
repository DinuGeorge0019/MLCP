{
    "link": "https://codeforces.com//contest/979/problem/C",
    "problemId": "183085",
    "problem_idx": "C",
    "shortId": "979C",
    "contest_number": "979",
    "problem_submissions": {
        "E": [
            38239944,
            38239626,
            38239985,
            38241605
        ],
        "D": [
            38235368,
            38234401,
            38232573,
            38240292,
            38232946,
            38238813,
            38236674,
            38234013,
            38234028,
            38242834,
            38235224,
            38238975,
            38236273,
            38233251,
            38924559,
            38232308,
            38231709
        ],
        "C": [
            38225119,
            38222425,
            38225946,
            38230085,
            38224078,
            38228380,
            38224768,
            38225370,
            38223169,
            38226246,
            38227575,
            38228558,
            38229693,
            38227316,
            38227594,
            38232766,
            38225714,
            38226125
        ],
        "B": [
            38223636,
            38219953,
            38246488,
            38228424,
            38221669,
            38225321,
            38237418,
            38223126,
            38229060,
            38225443,
            38231632,
            38234671,
            38223153,
            38228913,
            38349158,
            38225310
        ],
        "A": [
            38217437,
            38220346,
            38223788,
            38219996,
            38221134,
            38219848,
            38242600,
            38216689,
            38216875,
            38216674,
            38216872,
            38217267,
            38220684,
            38217206,
            38218341,
            38218810,
            38220203,
            38217265
        ]
    },
    "name": "C. Kuro and Walking Route",
    "statement": "Kuro is living in a country called Uberland, consisting of n towns,\r\nnumbered from 1 to n, and n - 1 bidirectional roads connecting these\r\ntowns. It is possible to reach each town from any other. Each road\r\nconnects two towns a and b. Kuro loves walking and he is planning to\r\ntake a walking marathon, in which he will choose a pair of towns (u, v)\r\n(u\r\nneq v) and walk from u using the shortest path to v (note that (u, v) is\r\nconsidered to be different from (v, u)).Oddly, there are 2 special towns\r\nin Uberland named Flowrisa (denoted with the index x) and Beetopia\r\n(denoted with the index y). Flowrisa is a town where there are many\r\nstrong-scent flowers, and Beetopia is another town where many bees live.\r\nIn particular, Kuro will avoid any pair of towns (u, v) if on the path\r\nfrom u to v, he reaches Beetopia after he reached Flowrisa, since the\r\nbees will be attracted with the flower smell on Kuro s body and sting\r\nhim.Kuro wants to know how many pair of city (u, v) he can take as his\r\nroute. Since he s not really bright, he asked you to help him with this\r\nproblem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=3e5+7;\n\nint n, x, y;\nVI gr[N];\n\nvector <LL> mywek;\n\nLL res;\n\nint dfs(int v, int par){\n\tint si=1;\n\tfor(int i : gr[v])\n\t\tif (i!=par)\n\t\t\tsi+=dfs(i,v);\n\tif (v==y)\n\t\tmywek.pb(si);\n\treturn si;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tFOR(i,1,n-1){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgr[a].pb(b);\n\t\tgr[b].pb(a);\n\t}\n\tFOR(i,0,1){\n\t\tswap(x, y);\n\t\tdfs(x, 0);\n\t}\n\tres=(LL)n*(n-1)-mywek[0]*mywek[1];\n\tprintf(\"%lld\\n\", res);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Kuro and Walking Route.json",
    "editorial_link": "https://codeforces.com//blog/entry/59462",
    "editorial": "SolutionWe can consider the city as a graph, in which every town is a\r\nvertex and every road connecting two towns is an edge. Since < , we can\r\ndeduce that this graph is a tree. Now, instead of finding the number of\r\npairs that Kuro can choose, we can find the number of pairs that Kuro\r\ncannot choose. In other words, we must find the number of pairs of\r\nvertices , in which the shortest path from to passes through and then\r\nthrough . But how can we do this?If we take vertex as the root of the\r\ntree, we can see that every pair of vertices that Kuro cannot choose\r\nbegins from any node within the subtree of node , and finishes at any\r\nnode but within the subtree of node , which is a direct child of lying\r\non the shortest path from to . In total, the number of pairs of vertices\r\nthat we are looking for is equal of , which denotes the size of the\r\nsubtree of node . We can implement this using simple DFS.Time\r\ncomplexity: .\r\n",
    "hint": []
}