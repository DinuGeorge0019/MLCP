{
    "link": "https://codeforces.com//contest/1900/problem/F",
    "problemId": "2348163",
    "problem_idx": "F",
    "shortId": "1900F",
    "contest_number": "1900",
    "problem_submissions": {
        "E": [
            234456838,
            234455027,
            234457931,
            234455766,
            234456771,
            234460502,
            234461970,
            234463093,
            234461258,
            234461626,
            235437599,
            234459471,
            234465112,
            234465941,
            234463278,
            234463477,
            234464668,
            234464310,
            234465647,
            234465136
        ],
        "D": [
            234442999,
            234445532,
            234447119,
            234444027,
            234448662,
            234449846,
            234450821,
            234448590,
            234544232,
            234544122,
            234453539,
            234456816,
            234449461,
            234446745,
            234447346,
            234455068,
            234451202,
            234455283,
            234455174,
            234452017,
            234447175
        ],
        "C": [
            234433856,
            234437020,
            234438208,
            234438984,
            234436746,
            234440214,
            234440440,
            234440880,
            234441500,
            234437974,
            234441984,
            234439314,
            234438351,
            234441349,
            234441838,
            234441318,
            234441667,
            234442122,
            234444120
        ],
        "B": [
            234430889,
            234432938,
            234432800,
            234433842,
            234432820,
            234435211,
            234434789,
            234436751,
            234434039,
            234432505,
            234436824,
            234433963,
            234433725,
            234434390,
            234437612,
            234436752,
            234436425,
            234432619,
            234438330
        ],
        "A": [
            234429140,
            234429060,
            234429292,
            234429383,
            234429959,
            234434373,
            234428876,
            234431698,
            234428932,
            234429000,
            234431129,
            234431009,
            234429251,
            234429090,
            234434493,
            234430325,
            234429412,
            234429176,
            234429387
        ],
        "F": [
            234821914,
            234821787
        ]
    },
    "name": "F. Local Deletions",
    "statement": "For an array b_1, b_2,\r\nldots, b_m, for some i (1 < i < m), element b_i is said to be a local\r\nminimum if b_i < b_{i-1} and b_i < b_{i+1}. Element b_1 is said to be a\r\nlocal minimum if b_1 < b_2. Element b_m is said to be a local minimum if\r\nb_m < b_{m-1}.For an array b_1, b_2,\r\nldots, b_m, for some i (1 < i < m), element b_i is said to be a local\r\nmaximum if b_i > b_{i-1} and b_i > b_{i+1}. Element b_1 is said to be a\r\nlocal maximum if b_1 > b_2. Element b_m is said to be a local maximum if\r\nb_m > b_{m-1}.Let x be an array of distinct elements. We define two\r\noperations on it: 1 delete all elements from x that are local minima. 2\r\ndelete all elements from x that are local maxima. Define f(x) as\r\nfollows. Repeat operations 1, 2, 1, 2,\r\nldots in that order until you get only one element left in the array.\r\nReturn that element.For example, take an array [1,3,2]. We will first do\r\ntype 1 operation and get [1, 2]. Then we will perform type 2 operation\r\nand get [2]. Therefore, f([1,3,2]) = 2.You are given a permutation^\r\ndagger a of size n and q queries. Each query consists of two integers l\r\nand r such that 1\r\nle l\r\nle r\r\nle n. The query asks you to compute f([a_l, a_{l+1},\r\nldots, a_r]). ^\r\ndagger A permutation of length n is an array of n distinct integers from\r\n1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation,\r\nbut [1,2,2] is not a permutation (2 appears twice in the array), and\r\n[1,3,4] is also not a permutation (n=3, but there is 4 in the array).\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#define N 101000\n#define VI vector<int>\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-') flag = true; c = getchar(); }\n\twhile (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nint n, q;\ninline int bf(VI &ve, int ptr) {\n\tVI vec[21];\n\tvec[ptr] = ve;\n\twhile (vec[ptr].size() > 1) {\n\t\tfor (unsigned int i = 0; i < vec[ptr].size(); ++i) {\n\t\t\tbool flag;\n\t\t\tif (!(ptr & 1)) {\n\t\t\t\tflag = i == 0 ? true : vec[ptr][i - 1] > vec[ptr][i];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : vec[ptr][i + 1] > vec[ptr][i];\n\t\t\t} else {\n\t\t\t\tflag = i == 0 ? true : vec[ptr][i - 1] < vec[ptr][i];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : vec[ptr][i + 1] < vec[ptr][i];\n\t\t\t}\n\t\t\tif (flag)\tvec[ptr+1].push_back(vec[ptr][i]);\n\t\t}\n\t\t++ptr;\n\t}\n\treturn vec[ptr][0];\n}\nint h[N];\nVI vec[21];\nint vtot;\nvoid init() {\n\tint ptr = 0;\n\twhile (vec[ptr].size() > 1) {\n\t\tfor (unsigned int i = 0; i < vec[ptr].size(); ++i) {\n\t\t\tbool flag;\n\t\t\tif (!(ptr & 1)) {\n\t\t\t\tflag = i == 0 ? true : h[vec[ptr][i - 1]] > h[vec[ptr][i]];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : h[vec[ptr][i + 1]] > h[vec[ptr][i]];\n\t\t\t} else {\n\t\t\t\tflag = i == 0 ? true : h[vec[ptr][i - 1]] < h[vec[ptr][i]];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : h[vec[ptr][i + 1]] < h[vec[ptr][i]];\n\t\t\t}\n\t\t\tif (flag)\tvec[ptr+1].push_back(vec[ptr][i]);\n\t\t}\n\t\t++ptr;\n\t}\n\tvtot = ptr;\n}\nint query(int l, int r) {\n\tconst int up = 6;\n\tif (r - l <= up) {\n\t\tVI ve;\n\t\tfor (int i = l; i <= r; ++i) ve.push_back(h[i]);\n\t\treturn bf(ve, 0);\n\t}\n\tint a = h[l], b = h[r];\n\tint nl = l, nr = r - 2;\n\tint ptr = 0;\n\twhile (1) {\n\t\tbool flag1 = ptr & 1 ? a > h[vec[ptr][nl]] : a < h[vec[ptr][nl]];\n\t\tbool flag;\n\t\tif (ptr & 1) {\n\t\t\tflag = h[vec[ptr][nl]] > a;\n\t\t\tflag &= h[vec[ptr][nl]] > h[vec[ptr][nl+1]];\n\t\t} else {\n\t\t\tflag = h[vec[ptr][nl]] < a;\n\t\t\tflag &= h[vec[ptr][nl]] < h[vec[ptr][nl+1]];\n\t\t}\n\t\tif (flag1) a = a;\n\t\telse if (flag) a = h[vec[ptr][nl]];\n\t\telse a = -1;\n\n\t\tflag1 = ptr & 1 ? b > h[vec[ptr][nr]] : b < h[vec[ptr][nr]];\n\t\tif (ptr & 1) {\n\t\t\tflag = h[vec[ptr][nr]] > b;\n\t\t\tflag &= h[vec[ptr][nr]] > h[vec[ptr][nr-1]];\n\t\t} else {\n\t\t\tflag = h[vec[ptr][nr]] < b;\n\t\t\tflag &= h[vec[ptr][nr]] < h[vec[ptr][nr-1]];\n\t\t}\n\t\tif (flag1) b = b;\n\t\telse if (flag) b = h[vec[ptr][nr]];\n\t\telse b = -1;\n\n\t\tint idl = lower_bound(vec[ptr+1].begin(), vec[ptr+1].end(), vec[ptr][nl]+1) - vec[ptr+1].begin();\n\t\tint idr = upper_bound(vec[ptr+1].begin(), vec[ptr+1].end(), vec[ptr][nr]-1) - vec[ptr+1].begin() - 1;\n\n\t\tif (idr - idl <= up) {\n\t\t\tVI ve;\n\t\t\tif (~a) ve.push_back(a);\n\t\t\tfor (int i = idl; i <= idr; ++i) ve.push_back(h[vec[ptr+1][i]]);\n\t\t\tif (~b) ve.push_back(b);\n\t\t\treturn bf(ve, ptr+1);\n\t\t}\n\t\tif (a == -1) a = h[vec[ptr+1][idl]], ++idl;\n\t\tif (b == -1) b = h[vec[ptr+1][idr]], --idr;\n\t\t++ptr;\n\t\tnl = idl, nr = idr;\n\t}\n\tputs(\"???\");\n\texit(-1);\n\treturn -1;\n}\nint main() {\n\tread(n), read(q);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(h[i]);\n\t\tvec[0].push_back(i);\n\t}\n\tvtot = 1;\n\tinit();\n\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint l, r; read(l), read(r);\n\t\tint res = query(l, r);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Local Deletions.json",
    "editorial_link": "https://codeforces.com//blog/entry/122677",
    "editorial": "SolutionRead the hints.Now we will precompute and store the array after\r\neach operation on the entire permutation. We will call those array\r\nlayers. We can now solve queries in .If a query involves a small number\r\nof elements, we can just brute force it. Otherwise, we do the\r\nfollowing:Now let\u00e2\u0080\u0099s define our queries a bit differently. We are given\r\nsome array , which will be a subarray of some layer, and values, and .\r\nWe will get array by appending to the start of and appending to the end\r\nof . We are interested in the value of (). It is easy to see that all\r\nqueries involving or more elements can be converted into the modified\r\nquery.If is small, we can just brute force it. Otherwise, we can\r\ntransform it into a query on the next layer in constant time, or in\r\n.Now, the first thing to notice is that all elements in that are neither\r\nfirst nor last will be deleted only if they were deleted when we\r\nperformed operations on the whole permutation. That means that they will\r\nrepresent some interval on the next layer, let\u00e2\u0080\u0099s call it . (That\r\ninterval can be found either with binary search or in with\r\nprecomputation) It holds that is around half of . Now, notice that among\r\nand the first element of , there has to be at least one deletion. The\r\nsame goes for the last element of and . So now we have transformed the\r\nquery onto the next level in , or . As we will do at most such\r\ntransformations, the complexity of a single query is either or depending\r\non the way we find the next interval, both of which should be fast\r\nenough to pass.Total time complexity: or . Total memory complexity:\r\n"
}