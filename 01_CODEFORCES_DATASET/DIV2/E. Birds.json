{
    "link": "https://codeforces.com//contest/922/problem/E",
    "problemId": "154242",
    "problem_idx": "E",
    "shortId": "922E",
    "contest_number": "922",
    "problem_submissions": {
        "F": [
            35024389,
            35030878,
            35066050
        ],
        "E": [
            35021772,
            35023531,
            35025088,
            35031161,
            35025975,
            35029014,
            35026988,
            35021941,
            35026997,
            35064591,
            35064474,
            35026191,
            35037602,
            35037396,
            35027845
        ],
        "A": [
            35014429,
            35006326,
            35014914,
            35006731,
            35022340,
            35006627,
            35016513,
            35027286,
            35015985,
            35019424,
            35007052,
            35007949,
            35037576,
            35006680
        ],
        "C": [
            35013242,
            35014688,
            35008675,
            35009771,
            35021848,
            35009735,
            35022809,
            35015286,
            35020018,
            35017726,
            35013353,
            35014808,
            35011448,
            35018270,
            35015187,
            35037555,
            35037421,
            35021338,
            35014321
        ],
        "D": [
            35011345,
            35017477,
            35010376,
            35021949,
            35015604,
            35013771,
            35027504,
            35020183,
            35031518,
            35015008,
            35019185,
            35023414,
            35018029,
            35028830,
            35018141,
            35037411,
            35026479,
            35021278
        ],
        "B": [
            35007623,
            35008516,
            35007719,
            35008074,
            35008746,
            35007399,
            35009873,
            35009915,
            35012055,
            35007990,
            35009015,
            35007912,
            35008304,
            35009458,
            35010175,
            35037430,
            35007761,
            35008509
        ]
    },
    "name": "E. Birds",
    "statement": "Apart from plush toys, Imp is a huge fan of little yellow birds! To\r\nsummon birds, Imp needs strong magic. There are trees in a row on an\r\nalley in a park, there is a nest on each of the trees. In the -th nest\r\nthere are birds; to summon one bird from this nest Imp needs to stay\r\nunder this tree and it costs him points of mana. However, for each bird\r\nsummoned, Imp increases his mana capacity by points. Imp summons birds\r\none by one, he can summon any number from to birds from the -th nest.\r\nInitially Imp stands under the first tree and has points of mana, and\r\nhis mana capacity equals as well. He can only go forward, and each time\r\nhe moves from a tree to the next one, he restores points of mana (but it\r\ncan\u2019t exceed his current mana capacity). Moving only forward, what is\r\nthe maximum number of birds Imp can summon?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e3 + 10;\nconst int MAXK = 1e4 + 10;\n\nint n, W, B, X;\nint c[MAXN], cost[MAXN];\nll d[MAXN][MAXK];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> W >> B >> X;\n\tfor (int i = 0; i < n; i++) cin >> c[i];\n\tfor (int i = 0; i < n; i++) cin >> cost[i];\n\tmemset(d, -1, sizeof(d));\n\td[0][0] = W;\n\tint sm = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int a = 0; a <= sm; a++)\n\t\t\tfor (int b = 0; b <= c[i]; b++){\n\t\t\t\tll x = d[i][a];\n\t\t\t\tx -= 1ll*b*cost[i];\n\t\t\t\tif (x < 0) break;\n\t\t\t\tx += X;\n\t\t\t\tx = min(x, W + 1ll*(a+b)*B);\n\t\t\t\td[i+1][a+b] = max(d[i+1][a+b], x);\n\t\t\t}\n\t\tsm += c[i];\n\t}\n\t\n\tfor (int j = MAXK-1; j >= 0; j--)\n\t\tif (d[n][j] >= 0){\n\t\t\tcout << j << endl;\n\t\t\treturn 0;\n\t\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Birds.json",
    "editorial_link": "https://codeforces.com//blog/entry/57605",
    "editorial": "The problem can be solved by utilizing dynamic programming.Let us denote\r\nby the maximum possible remaining amount mana for the state , where\r\nstands for the number of nests passed by and stands for the number of\r\nbirds summoned.The base is as we have passed by no nests, have summoned\r\nno birds and have mana at our disposal in the beginning. Let us also\r\ninitialize all other states with .The transitions are as follows:\r\nconsider us having walked to the next nest and summoned additional birds\r\nfrom there, therefore proceeding from the state to (of course, it is\r\nreasonable to require that the answer for is not ). After we have\r\nproceeded, units of mana would be replenished (taking summoned birds\r\ninto consideration, the amount of mana at the moment is bounded above by\r\n). The summoning would cost us mana. If after the replenishing and the\r\nsummoning the remaining amount of mana is nonnegative, we update the\r\nanswer for the state : The answer is the maximal among reachable states\r\n(those not equal to ). . Note that the constant in the square is no more\r\nthan .\r\n"
}