{
    "link": "https://codeforces.com//contest/680/problem/C",
    "problemId": "61901",
    "problem_idx": "C",
    "shortId": "680C",
    "contest_number": "680",
    "problem_submissions": {
        "E": [
            18325043,
            18336819,
            18313780,
            18325133,
            18326159,
            91465868,
            91465765,
            18326865,
            18326653,
            18321290,
            18325524
        ],
        "D": [
            18318422,
            18317712,
            18319515,
            18318081,
            18319018,
            18319894,
            18321280,
            18314391,
            18321896,
            18322082,
            18323629,
            18321461
        ],
        "C": [
            18310807,
            18309120,
            18309109,
            18310395,
            18309474,
            18309104,
            18322448,
            18311311,
            18310069,
            18313252,
            93169698,
            91285497,
            20188952,
            18318579,
            18308421,
            18311792,
            18307772,
            18311986,
            18308165,
            18323717,
            18309473,
            18312494
        ],
        "B": [
            18305109,
            18304731,
            18305069,
            18305817,
            18305879,
            18305478,
            18318612,
            18306119,
            18307273,
            18305717,
            54153853,
            54153852,
            54153523,
            54153520,
            18308586,
            18305117,
            18306452,
            18305702,
            18306808,
            18308328,
            18304898,
            18305913,
            18306422
        ],
        "A": [
            18302780,
            18302872,
            18302977,
            18303253,
            18302950,
            18302797,
            18317513,
            18303506,
            18302976,
            18303711,
            54152578,
            54152576,
            54152557,
            54152556,
            18306442,
            18302916,
            18303646,
            18303474,
            18304094,
            18302798,
            18302792,
            18304079,
            18303143
        ]
    },
    "name": "C. Bear and Prime 100",
    "statement": "Bear Limak thinks of some hidden number an integer from interval . Your\r\ntask is to say if the hidden number is prime or composite.Integer is\r\ncalled prime if it has exactly two distinct divisors, and . If integer\r\nis not prime, it’s called composite.You can ask up to queries about\r\ndivisors of the hidden number. In each query you should print an integer\r\nfrom interval . The system will answer \"\" if your integer is a divisor\r\nof the hidden number. Otherwise, the answer will be \"\".For example, if\r\nthe hidden number is then the system will answer \"\" only if you print ,\r\nor .When you are done asking queries, print \"\" or \"\" and terminate your\r\nprogram.You will get the verdict if you ask more than queries, or if you\r\nprint an integer not from the range . Also, you will get the verdict if\r\nthe printed answer isn’t correct.You will get the verdict if you don’t\r\nprint anything (but you should) or if you forget about flushing the\r\noutput (more info below).\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 101;\nint vis[N] , pri[N] , p;\nvi v;\nint main(){\n    for(int i=2;i<N;++i){\n        if(!vis[i]) pri[p++] = i;\n        for(int j=i+i;j<N;j+=i)\n            vis[j] = true;\n    }\n    char s[101];\n    int cnt = 0;\n    for(int i=0;pri[i] <= 50;++i) v.pb(pri[i]);\n    for(int i=0;i<4;++i) v.pb(pri[i] * pri[i]);\n    rep(i,0,sz(v)){\n        printf(\"%d\\n\",v[i]);\n        fflush(stdout);\n        scanf(\"%s\",s);\n        cnt += (s[0] == 'y');\n        if(cnt == 2){\n            printf(\"composite\\n\");\n            fflush(stdout);\n            return 0;\n        }\n    }\n    printf(\"prime\\n\");\n    fflush(stdout);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "math",
        "number theory"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Bear and Prime 100.json",
    "editorial_link": "https://codeforces.com//blog/entry/45310",
    "editorial": "If a number is composite then it's either divisible by p2 for some prime p, or divisible by two distinct primes p and q. To check the first condition, it's enough to check all possible p2 (so, numbers 4, 9, 25, 49). If at least one gives \"yes\" then the hidden number if composite.\n\nIf there are two distinct prime divisors p and q then both of them are at most 50  otherwise the hidden number would be bigger than 100 (because for p???2 and q?>?50 we would get p·q?>?100). So, it's enough to check primes up to 50 (there are 15 of them), and check if at least two of them are divisors.",
    "hint": []
}