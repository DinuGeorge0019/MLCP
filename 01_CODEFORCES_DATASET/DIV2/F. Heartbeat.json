{
    "link": "https://codeforces.com//contest/1988/problem/F",
    "problemId": "2755744",
    "problem_idx": "F",
    "shortId": "1988F",
    "contest_number": "1988",
    "problem_submissions": {
        "E": [
            270685050,
            270705019,
            270700025,
            272334496,
            270690864,
            270707787,
            270701276,
            270700901,
            270718018,
            270707694,
            270712456,
            270717955,
            270717609,
            270717396,
            270722279,
            270721777,
            270713323,
            270726034,
            270728933,
            270723571,
            270713049
        ],
        "D": [
            270667414,
            270666131,
            270678688,
            270697022,
            270684902,
            270684329,
            270689879,
            270679010,
            270680404,
            270690647,
            270675498,
            270681957,
            270688264,
            270682354,
            270685580,
            270691868,
            270688997,
            270685310,
            270682871,
            270686949
        ],
        "A": [
            270656934,
            270657283,
            270646313,
            270648673,
            270647770,
            270646255,
            270646226,
            270646704,
            270646496,
            270646875,
            270646230,
            270646537,
            270649042,
            270647239,
            270646832,
            270647970,
            270646816,
            270646403,
            270647818,
            270690835
        ],
        "B": [
            270653903,
            270658113,
            270648318,
            270659660,
            270651609,
            270649653,
            270649456,
            270651315,
            270648898,
            270652028,
            270649680,
            270649413,
            270659881,
            270651090,
            270653561,
            270652761,
            270651998,
            270650038,
            270651450,
            270654441
        ],
        "C": [
            270647243,
            270657923,
            270653896,
            270669456,
            270664152,
            270658071,
            270658378,
            270659641,
            270660679,
            270663455,
            270660051,
            270666865,
            270671029,
            270662305,
            270672676,
            270661337,
            270662076,
            270660202,
            270665229,
            270662007
        ],
        "F": [
            276883705,
            276879542,
            270840778
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131581",
    "editorial": "We can use dp to calculate the number of permutations of 1?n\n with i\n prefix maximums and j\n ascents, f(n,i,j)\n: consider where 1 is inserted, we will have a O(n3)\n dp that finds f(n,i,j)\n for all suitable (n,i,j)\n-s.\n\nFor suffix maximums, (the number of permutations of 1?n\n with i\n prefix maximums and j\n ascents, g(n,i,j)\n, we can just reverse some dimension of f\n).\n\nTo calculate the answer, consider the position of n\n. Suppose it's p\n. The the answer is\n\n?np=1?p?1i=0?n?pj=0?p?1x=0?n?py=0f(p?1,i,x)g(n?p,j,y)(n?1p?1)ai+1bj+1cx+y+[p>1]\nLet u(x,y)=?if(x,i,y)ai+1\n, v(x,y)=?zg(x,i,y)bi+1\n (both of these are calculated in O(n3)\n), then the answer is\n\n?np=1?p?1x=0?n?py=0u(p?1,x)v(n?p,y)(n?1p?1)cx+y+[p>1]\nBy seeing u\n and v\n as 2D polynomials, this can be calculated with 2D FFT in O(n2logn)\n.",
    "name": "F. Heartbeat",
    "statement": "For an array u_1, u_2,\r\nldots, u_n, define a prefix maximum as an index i such that u_i>u_j for\r\nall j<i; a suffix maximum as an index i such that u_i>u_j for all j>i;\r\nan ascent as an index i (i>1) such that u_i>u_{i-1}. You are given three\r\ncost arrays: [a_1, a_2,\r\nldots, a_n], [b_1, b_2,\r\nldots, b_n], and [c_0, c_1,\r\nldots, c_{n-1}].Define the of an array that has x prefix maximums, y\r\nsuffix maximums, and z ascents as a_x\r\ncdot b_y\r\ncdot c_z.Let the sum of costs of all permutations of 1,2,\r\nldots,n be f(n). Find f(1), f(2), ..., f(n) modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using namespace std; const int O = 7e2 + 5;const int mod = 998244353; int n, a[O], b[O], c[O], p[O], rp[O], fa[O][O], fb[O][O], g[O][O], f[2][O][O]; int exp(int a, int x){    int res = 1;    for (; x; x >>= 1){        if (x & 1) res = 1ll * res * a % mod;        a = 1ll * a * a % mod;    }    return res;} void Add(int &x, int y){    x += y;    if (x >= mod) x -= mod;    if (x < 0) x += mod;} int C(int k, int n){    if (k > n) return 0;    return 1ll * p[n] * rp[k] % mod * rp[n - k] % mod;} main(){    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);    p[0] = rp[0] = 1;    for (int i = 1; i < O; ++ i){        p[i] = 1ll * p[i - 1] * i % mod;        rp[i] = exp(p[i], mod - 2);    }     cin >> n;    for (int i = 1; i <= n; ++ i) cin >> a[i];    for (int i = 1; i <= n; ++ i) cin >> b[i];    for (int i = 0; i < n; ++ i) cin >> c[i];     /// https://mirror.codeforces.com/blog/entry/131567?#comment-1171246    /// so fuking brilliant    f[1][1][0] = 1;     for (int i = 1; i <= n; ++ i){        memset(f[(i & 1) ^ 1], 0, sizeof(f[(i & 1) ^ 1]));        for (int j = 1; j <= i; ++ j){            for (int z = 0; z < i; ++ z){                if (f[i & 1][j][z]){                    Add(f[(i & 1) ^ 1][j + 1][z + 1], f[i & 1][j][z]);                    Add(f[(i & 1) ^ 1][j][z + 1], 1ll * f[i & 1][j][z] * (i - 1 - z) % mod);                    Add(f[(i & 1) ^ 1][j][z], 1ll * f[i & 1][j][z] * z % mod);                    //Add(f[(i & 1) ^ 1][j][z], f[i & 1][j][z]);                }                 //cout << \"check \" << i << \" \" << j << \" \" << z << \" : \" << f[i & 1][j][z] << endl;                Add(fa[i][z], 1ll * a[j] * f[i & 1][j][z] % mod);                Add(fb[i][i - 1 - z], 1ll * b[j] * f[i & 1][j][z] % mod);            }        }    }     for (int i = 1; i <= n; ++ i){        for (int j = 0; j < i; ++ j){            for (int z = 0; z < n - j; ++ z){                Add(g[i][z], 1ll * fb[i][j] * c[j + z] % mod);            }        }    }     for (int i = 1; i <= n; ++ i){        //for (int j = 0; j <= n; ++ j) cout << \"ditconme \" << i << \" \" << j << \" \" << fa[i][j] << endl;    }     //cout << fa[1][0] << endl;    //cout << g[1][0] << endl;    //cout << C(0, 0) << endl;     for (int i = 1; i <= n; ++ i){        int res = 0;        for (int j = 1; j <= i; ++ j){            for (int z = 0; z < j; ++ z){                Add(res, 1ll * fa[j][z] * g[i - j + 1][z] % mod * C(j - 1, i - 1) % mod);            }        }        cout << res << \" \";    } }/**41 1 1 11 1 1 11 1 1 1 **/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Heartbeat.json",
    "hint": []
}