{
    "link": "https://codeforces.com//contest/1891/problem/F",
    "problemId": "2296093",
    "problem_idx": "F",
    "shortId": "1891F",
    "contest_number": "1891",
    "problem_submissions": {
        "E": [
            230546323,
            230549698,
            230546568,
            230560113,
            230535473,
            230555886,
            230556588,
            230572665,
            230562765,
            230571525,
            230577549,
            230577437,
            230577312,
            230576387,
            230568654,
            230542621,
            230562980,
            230569462,
            230570942,
            230569058,
            230570276,
            230567059,
            230568509,
            230570393
        ],
        "D": [
            230534861,
            230532955,
            230530542,
            230539370,
            230549040,
            230536739,
            230534616,
            230532674,
            230544623,
            230533495,
            230543589,
            230549007,
            230547762,
            230544535,
            230536524,
            230537913,
            230537614,
            230536080,
            230540544,
            230539494
        ],
        "F": [
            230528098,
            230541255,
            230552010,
            230529998,
            230540710,
            230542715,
            230590093,
            230590013,
            230545702,
            230538147,
            251594037,
            230535448,
            230545719,
            230533122,
            230519163,
            230533480,
            230536870,
            230548382,
            230551293,
            230550179,
            230543750,
            230553764,
            230541029
        ],
        "C": [
            230517325,
            230519256,
            230521040,
            230519508,
            230552157,
            230529446,
            230519957,
            230521645,
            230529295,
            230521526,
            230527664,
            230555714,
            230523852,
            230528582,
            230522749,
            230531812,
            230530352,
            230518984,
            230520316,
            230536742
        ],
        "A": [
            230515478,
            230512076,
            230512426,
            230512477,
            230513749,
            230513572,
            230511745,
            230511922,
            230513704,
            230511875,
            230512212,
            230559679,
            230512242,
            230513480,
            230512561,
            230512123,
            230512943,
            230547595,
            230512205,
            230518051
        ],
        "B": [
            230513054,
            230513705,
            230515902,
            230515002,
            230527506,
            230517573,
            230513080,
            230513453,
            230518089,
            230513986,
            230515796,
            230558558,
            230539558,
            230516521,
            230515634,
            230516319,
            230517013,
            230552749,
            230513951,
            230522884
        ]
    },
    "name": "F. A Growing Tree",
    "statement": "You are given a rooted tree with the root at vertex 1, initially\r\nconsisting of a single vertex. Each vertex has a numerical value,\r\ninitially set to 0. There are also q queries of two types: The first\r\ntype: add a child vertex with the number sz + 1 to vertex v, where sz is\r\nthe current size of the tree. The numerical value of the new vertex will\r\nbe 0. The second type: add x to the numerical values of all vertices in\r\nthe subtree of vertex v. After all queries, output the numerical value\r\nof all of the vertices in the final tree.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\nusing namespace std;\nint read(){\n\tchar c=getchar();int x=0;bool f=0;\n\twhile(c<48||c>57) f|=(c=='-'),c=getchar();\n\tdo x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\twhile(c>=48&&c<=57);\n\tif(f) return -x;\n\treturn x;\n}\nconst int N=1000003;\ntypedef long long ll;\nvector<int> vec[N];\nint ft[N],sn[N],sz[N],tp[N],dfn[N],num;\nvoid dfs(int u){\n\tsz[u]=1;sn[u]=0;\n\tfor(int v:vec[u]){\n\t\tft[v]=u;\n\t\tdfs(v);\n\t\tsz[u]+=sz[v];\n\t\tif(sz[v]>sz[sn[u]]) sn[u]=v;\n\t}\n}\nvoid split(int u,int tops){\n\ttp[u]=tops;dfn[u]=++num;\n\tif(sn[u]) split(sn[u],tops);\n\tfor(int v:vec[u]){\n\t\tif(v==sn[u]) continue;\n\t\tsplit(v,v);\n\t}\n}\ntypedef long long ll;\nint op[N],val[N],vv[N];\nll tr[N];\nvoid upd(int x,ll v){for(int i=x;i<=num;i+=(i&-i)) tr[i]+=v;}\nll qry(int x){\n\tll res=0;\n\tfor(int i=x;i;i^=(i&-i)) res+=tr[i];\n\treturn res;\n}\nll query(int x){\n\tll res=0;\n\twhile(x){\n\t\tres+=qry(dfn[x])-qry(dfn[tp[x]]-1);\n\t\tx=ft[tp[x]];\n\t}\n\treturn res;\n}\nll res[N];\nvoid calc(int u,ll cur){\n\tcur+=qry(dfn[u])-qry(dfn[u]-1);\n\tres[u]=cur;\n\tfor(int v:vec[u]) calc(v,cur);\n}\nint main(){\n\tint tc=read();\n\twhile(tc--){\n\t\tint q=read();\n\t\tint sz=1;\n\t\tnum=0;\n\t\tfor(int i=1;i<=q;++i){\n\t\t\top[i]=read();\n\t\t\tval[i]=read();\n\t\t\tif(op[i]==1) vec[val[i]].emplace_back(++sz);\n\t\t\telse vv[i]=read();\n\t\t}\n\t\tdfs(1);\n\t\tsplit(1,1);\n\t\tsz=1;\n\t\tfor(int i=1;i<=q;++i)\n\t\t\tif(op[i]==1){\n\t\t\t\t++sz;\n\t\t\t\tupd(dfn[sz],-query(val[i]));\n\t\t\t}\n\t\t\telse upd(dfn[val[i]],vv[i]);\n\t\tcalc(1,0);\n\t\tfor(int i=1;i<=sz;++i) printf(\"%lld \",res[i]);\n\t\tputchar('\\n');\n\t\tfor(int i=1;i<=sz;++i) vec[i].clear(),tr[i]=0;\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. A Growing Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/121876",
    "editorial": "Let\u00e2\u0080\u0099s parse all the queries and build the tree. We can easily support\r\nsubtree addition queries using segment tree on Euler tour of the tree.\r\nAnd when we add new vertex, we just need to set its value to zero. How\r\nto do it? You can get the value in this vertex now (by get query from\r\nthe segment tree), let it be . Then you add to its value. You can also\r\nuse Fenwick tree to handle range add point get queries. Time complexity:\r\n.Bonus: try to find a solution using sqrt decomposition. I hope it will\r\nget TLE, but still.\r\n"
}