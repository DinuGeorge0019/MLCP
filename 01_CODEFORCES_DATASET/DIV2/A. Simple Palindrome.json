{
    "link": "https://codeforces.com//contest/2005/problem/A",
    "problemId": "2874760",
    "problem_idx": "A",
    "shortId": "2005A",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "Full SolutionLetâs define the numbers of vowels by and assume we have\r\nfixed them. Obviously, .At first, letâs not consider the empty string as\r\nit doesnât change anything. Then, the number of palindrome subsequences\r\nwill be at least (every subsequence consisting of the same letter minus\r\nthe five empty strings). Now, notice that if we put the same characters\r\nconsecutively then the answer would be exactly , and that would be the\r\nbest possible answer for that fixed numbers (there cannot be other\r\npalindrome subsequences because if the first and last characters are the\r\nsame, then all the middle part will be the same as well).Now, we need to\r\nfind the best array . To do this, letâs assume there are 2 mumbers and\r\nin the array such that . Then, . This means, that replacing and with and\r\nwill not change the sum of the array but will make the number of\r\npalindrome subsequences smaller. We can do this replacing process until\r\nno two numbers in have difference bigger than . Actually, there is only\r\none such array (not considering its permutations) and it contains only\r\n-s and -s.\r\n",
    "name": "A. Simple Palindrome",
    "statement": "Narek found out that the kids only know the vowels of the English\r\nalphabet (the letters\r\nmathtt{a},\r\nmathtt{e},\r\nmathtt{i},\r\nmathtt{o}, and\r\nmathtt{u}), so Narek needs to make a string that consists of vowels\r\nonly. After making the string, he’ll ask the kids to count the number of\r\nsubsequences that are palindromes. Narek wants to keep it simple, so\r\nhe’s looking for a string such that the amount of palindrome\r\nsubsequences is minimal.Help Narek find a string of length n, consisting\r\nof English (letters\r\nmathtt{a},\r\nmathtt{e},\r\nmathtt{i},\r\nmathtt{o}, and\r\nmathtt{u}), which the amount of in it.^{\r\ndagger} A string is called a palindrome if it reads the same from left\r\nto right and from right to left.^{\r\nddagger} String t is a subsequence of string s if t can be obtained from\r\ns by removing several (possibly, zero or all) characters from s and\r\nconcatenating the remaining ones, without changing their order. For\r\nexample,\r\nmathtt{odocs} is a subsequence of\r\ntexttt{c}{\r\ncolor{red}{\r\ntexttt{od}}}\r\ntexttt{ef}{\r\ncolor{red}{\r\ntexttt{o}}}\r\ntexttt{r}{\r\ncolor{red}{\r\ntexttt{c}}}\r\ntexttt{e}{\r\ncolor{red}{\r\ntexttt{s}}}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; inline void Solve (){    int lungime;    cin >> lungime;     char sir[] = \"aeiou\";    for (int indice = 0 ; indice < 5 ; indice++)    {        for (int ramas = lungime / 5 ; ramas ; ramas--)            { cout << sir[indice]; }         if (indice < lungime % 5)            { cout << sir[indice]; }    }     cout << '\\n';} int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);     int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Simple Palindrome.json",
    "hint": []
}