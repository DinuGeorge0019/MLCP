{
    "link": "https://codeforces.com//contest/1478/problem/E",
    "problemId": "879393",
    "problem_idx": "E",
    "shortId": "1478E",
    "contest_number": "1478",
    "problem_submissions": {
        "F": [
            105745770,
            105755730,
            105740257,
            105759758,
            105734600,
            105755284,
            105756717,
            105766844,
            105793777,
            105757168,
            105755750,
            105751368,
            105774495,
            105749168,
            105760060
        ],
        "E": [
            105741982,
            105745927,
            105765147,
            105765706,
            105765965,
            105763865,
            105754042,
            105761626,
            105739939,
            105721165,
            105766403,
            105749463,
            105750984,
            105763896,
            105756596,
            105752745
        ],
        "D": [
            105701384,
            105722470,
            105753195,
            105738392,
            105746684,
            105720945,
            105734191,
            105749589,
            105715391,
            105733991,
            105751898,
            105743147,
            105712944,
            105730170,
            105705577,
            106043703,
            105747710,
            105704995,
            105736139
        ],
        "C": [
            105694901,
            105704831,
            105695273,
            105720027,
            105742447,
            105744248,
            105740268,
            105734450,
            105693735,
            105690240,
            105751278,
            105716768,
            105739420,
            105702365,
            105732790,
            105719496,
            105717686,
            105735493,
            105713455
        ],
        "B": [
            105686332,
            105685165,
            105684581,
            105689777,
            105689090,
            105695004,
            105684674,
            105704956,
            105686767,
            105697452,
            105714810,
            105690830,
            105686870,
            105681347,
            105686702,
            105690335,
            105688451,
            105684176,
            105689461
        ],
        "A": [
            105679437,
            105677748,
            105676437,
            105679439,
            105676338,
            105678358,
            105795468,
            105681333,
            105678297,
            105686569,
            105679854,
            105679642,
            105677865,
            105676184,
            105678986,
            105680204,
            105677192,
            105687845,
            105679361
        ]
    },
    "name": "E. Nezzar and Binary String",
    "statement": "Nezzar has a binary string s of length n that he wants to share with his\r\nbest friend, Nanako. Nanako will spend q days inspecting the binary\r\nstring. At the same time, Nezzar wants to change the string s into\r\nstring f during these q days, because it looks better.It is known that\r\nNanako loves consistency so much. On the i-th day, Nanako will inspect a\r\nsegment of string s from position l_i to position r_i inclusive. If the\r\nsegment contains both characters ” and ”, Nanako becomes unhappy and\r\nthrows away the string.After this inspection, at the i-th night, Nezzar\r\ncan secretly change than half of the characters in the segment from l_i\r\nto r_i inclusive, otherwise the change will be too obvious.Now Nezzar\r\nwonders, if it is possible to avoid Nanako being unhappy and at the same\r\ntime have the string become equal to the string f at the end of these q\r\ndays and nights.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 200100\n\nint n, q;\nchar s[N], f[N];\n\nint add[N<<2], len[N<<2], cnt[N<<2];\n\nvoid modify(int v, int d) {\n\tadd[v] = d;\n\tcnt[v] = d ? len[v] : 0;\n}\n\nvoid push_dn(int v) {\n\tif (add[v] >= 0) {\n\t\tmodify(v << 1, add[v]);\n\t\tmodify(v << 1 | 1, add[v]);\n\t\tadd[v] = -1;\n\t}\n}\n\nvoid push_up(int v) {\n\tcnt[v] = cnt[v<<1] + cnt[v<<1|1];\n}\n\nvoid build(int v, int vl, int vr) {\n\tcnt[v] = 0;\n\tlen[v] = vr - vl + 1, add[v] = -1;\n\tif (vl == vr) cnt[v] = f[vl];\n\telse {\n\t\tint mi = vl + vr >> 1;\n\t\tbuild(v << 1, vl, mi), build(v << 1 | 1, mi + 1, vr);\n\t\tpush_up(v);\n\t}\n}\n\nvoid modify(int v, int vl, int vr, int l, int r, int d) {\n\tif (vl > r || l > vr) return;\n\tif (l <= vl && vr <= r) modify(v, d);\n\telse {\n\t\tpush_dn(v);\n\t\tint mi = vl + vr >> 1;\n\t\tmodify(v << 1, vl, mi, l, r, d);\n\t\tmodify(v << 1 | 1, mi + 1, vr, l, r, d);\n\t\tpush_up(v);\n\t}\n}\n\nint query(int v, int vl, int vr, int l, int r) {\n\tif (vl > r || l > vr) return 0;\n\tif (l <= vl && vr <= r) return cnt[v];\n\tpush_dn(v);\n\tint mi = vl + vr >> 1;\n\treturn query(v << 1, vl, mi, l, r) + query(v << 1 | 1, mi + 1, vr, l, r);\n}\n\nbool go(int v, int vl, int vr) {\n\tif (vl == vr) return cnt[v] == s[vl];\n\tpush_dn(v);\n\tint mi = vl + vr >> 1;\n\treturn go(v << 1, vl, mi) & go(v << 1 | 1, mi + 1, vr);\n}\n\ntypedef pair <int, int> pii;\nvector <pii> vec;\n\ninline char nc() {\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ntemplate <class T> inline void read(T &x){\n\tchar c=nc(),b=1;\n\tfor (;!(c>='0'&&c<='9'||c==EOF);c=nc()) if (c=='-') b=-b;\n\tfor (x=0;c>='0'&&c<='9';x=x*10+c-'0',c=nc()); x*=b;\n}\ninline void read(char *s){\n\tchar c=nc(); int len=0;\n\tfor (;c==' '||c=='\\t'||c=='\\n';c=nc());\n\tfor (;!(c==' '||c=='\\t'||c=='\\n'||c==EOF);s[len++]=c,c=nc()); s[len]=0;\n}\ntemplate <typename Head, typename... Tail>\ninline void read(Head& H, Tail&... T) {\n    read(H), read(T...);\n}\n\nint main() {\n    int T;\n    read(T);\n    while (T --) {\n\t\tread(n, q); read(s + 1), read(f + 1);\n\t\tfor (int i = 1; i <= n; i ++) s[i] -= '0', f[i] -= '0';\n\t\tbuild(1, 1, n);\n\t\tbool ok = true;\n\t\tvec.clear();\n\t\twhile (q --) {\n\t\t\tint l, r;\n\t\t\tread(l, r);\n\t\t\tvec.emplace_back(l, r);\n\t\t}\n\t\treverse(vec.begin(), vec.end());\n\t\tfor (auto p : vec) {\n\t\t\tint l = p.first, r = p.second;\n\t\t\tint c1 = query(1, 1, n, l, r), c0 = r - l + 1 - c1;\n\t\t\tif (c0 == c1) {ok = false; break;}\n\t\t\telse if (c0 > c1) modify(1, 1, n, l, r, 0);\n\t\t\telse modify(1, 1, n, l, r, 1);\n\t\t}\n\t\tok &= go(1, 1, n);\n\t\tif (ok) puts(\"YES\");\n\t\telse puts(\"NO\");\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Nezzar and Binary String.json",
    "editorial_link": "https://codeforces.com//blog/entry/87294",
    "editorial": "The operations can be described backward:\n\nIterate days in reverse order and start with f\n. In i\n-th day, if there is a strict majority of 0\ns or 1\ns between li\n and ri\n, change ALL element inside the range to be the majority. Otherwise, declare that the operation failed.\nWe can see that the \"backward\" operation is deterministic, so we can compute the source string from destination string alone and check if the source string computed equal to s\n.\n\nTo simulate the operations, We need to support two kind of operations:\n\nrange query on sum, and\nrange assignment\nWhich can be simulated using e.g. lazy segment tree.\n\nTime complexity: O((q+n)logn)",
    "hint": []
}