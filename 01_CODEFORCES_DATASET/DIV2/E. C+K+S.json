{
    "link": "https://codeforces.com//contest/2024/problem/E",
    "problemId": "2964360",
    "problem_idx": "E",
    "shortId": "2024E",
    "contest_number": "2024",
    "problem_submissions": {
        "F": [
            287015023,
            287169223,
            287373673,
            287215917,
            287215736,
            287211292,
            287210539
        ],
        "D": [
            286987175,
            286931903,
            286960958,
            286961825,
            286971656,
            286929566,
            286931351,
            286932695,
            286932954,
            286934298,
            286931628,
            286927969,
            286932481,
            286936758,
            286930518,
            286960977,
            286959072,
            286943034,
            286936933
        ],
        "B": [
            286981623,
            286914966,
            286919282,
            286915114,
            286921371,
            286905134,
            286915552,
            286914323,
            286916482,
            286915957,
            286912577,
            286914600,
            286917409,
            286917069,
            286960523,
            286915841,
            286912540,
            286913505,
            286928405,
            286917057
        ],
        "E": [
            286971252,
            287005601,
            287014904,
            287015860,
            287015861,
            287172897,
            287179171,
            286984012
        ],
        "A": [
            286921784,
            286907603,
            286905627,
            286906243,
            286909098,
            286912198,
            286906985,
            286905683,
            286907292,
            286909521,
            286906250,
            286906979,
            286905397,
            286905452,
            286905213,
            286906731,
            286905626,
            286906240,
            286907336,
            286905986
        ],
        "C": [
            286916369,
            286924618,
            286933885,
            286931704,
            286933058,
            286906288,
            286921833,
            286923843,
            286925202,
            286923774,
            286923641,
            286921029,
            286922676,
            286924091,
            286919391,
            286920408,
            286922209,
            286923637,
            286916167,
            286927200
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Consider a strongly connected graph in which the lengths of all cycles are multiples of k\n. It can be observed that it is always possible to color this graph with k\n colors in such a way that any edge connects a vertex of color color\n to a vertex of color (color+1)modk\n. It turns out that we can add edges to this graph only if they preserve the described color invariant.\n\nLet's make some colorings of the original graphs. With fixed colorings, it is quite easy to check whether the required edges can be added. To do this, we will create corresponding counting arrays for each color and each class of vertices, and then we will compare the elements of the arrays according to the criterion mentioned above. However, we could have initially colored the second graph differently, for example, by adding 1\n to the color of each vertex modulo k\n. It is not difficult to verify that all the values of the counting arrays for the second graph would then shift by 1\n in a cycle. Similarly, depending on the coloring, all values could shift cyclically by an arbitrary amount. To solve this problem, we will construct the initial arrays in such a way that, for fixed colorings, they need to be checked for equality. If equality is achieved for some coloring, it means that one array is a cyclic shift of the other. This condition can be checked, for example, using the Knuth-Morris-Pratt algorithm.",
    "name": "E. C+K+S",
    "statement": "You are given two strongly connected^{\r\ndagger} directed graphs, each with exactly n vertices, but possibly\r\ndifferent numbers of edges. Upon closer inspection, you noticed an\r\nimportant feature the length of any cycle in these graphs is divisible\r\nby k.Each of the 2n vertices belongs to exactly one of two types: or .\r\nFor each vertex, its type is known to you.You need to determine whether\r\nit is possible to draw exactly n directed edges between the source\r\ngraphs such that the following four conditions are met: The ends of any\r\nadded edge lie in different graphs. From each outgoing vertex, exactly\r\none added edge originates. Into each incoming vertex, exactly one added\r\nedge enters. In the resulting graph, the length of any cycle is\r\ndivisible by k. ^{\r\ndagger}A strongly connected graph is a graph in which there is a path\r\nfrom every vertex to every other vertex.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; typedef long long int ll;const ll FOD = 998244353;typedef pair<ll, ll> P;using ull = unsigned long long;template <class T> using V = vector<T>;template <class T> using VV = V<V<T>>;  template <ll MD> struct ModInt {    using M = ModInt;    const static M G;    ll v;    ModInt(ll _v = 0) { set_v(_v % MD + MD); }    M& set_v(ll _v) {        v = (_v < MD) ? _v : _v - MD;        return *this;    }    explicit operator bool() const { return v != 0; }    M operator-() const { return M() - *this; }    M operator+(const M& r) const { return M().set_v(v + r.v); }    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }    M operator*(const M& r) const { return M().set_v(ll(v) * r.v % MD); }    M operator/(const M& r) const { return *this * r.inv(); }    M& operator+=(const M& r) { return *this = *this + r; }    M& operator-=(const M& r) { return *this = *this - r; }    M& operator*=(const M& r) { return *this = *this * r; }    M& operator/=(const M& r) { return *this = *this / r; }    bool operator==(const M& r) const { return v == r.v; }    M pow(ll n) const {        M x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    M inv() const { return pow(MD - 2); }    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }};using Mint = ModInt<998244353>;template<> const Mint Mint::G = Mint(3); template <class Mint> void nft(bool type, V<Mint>& a) {    int n = int(a.size()), s = 0;    while ((1 << s) < n) s++;    assert(1 << s == n);     static V<Mint> ep, iep;    while (int(ep.size()) <= s) {        ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));        iep.push_back(ep.back().inv());    }    V<Mint> b(n);    for (int i = 1; i <= s; i++) {        int w = 1 << (s - i);        Mint base = type ? iep[i] : ep[i], now = 1;        for (int y = 0; y < n / 2; y += w) {            for (int x = 0; x < w; x++) {                auto l = a[y << 1 | x];                auto r = now * a[y << 1 | x | w];                b[y | x] = l + r;                b[y | x | n >> 1] = l - r;            }            now *= base;        }        swap(a, b);    }} template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {    int n = int(a.size()), m = int(b.size());    if (!n || !m) return {};    int lg = 0;    while ((1 << lg) < n + m - 1) lg++;    int z = 1 << lg;    auto a2 = a, b2 = b;    a2.resize(z);    b2.resize(z);    nft(false, a2);    nft(false, b2);    for (int i = 0; i < z; i++) a2[i] *= b2[i];    nft(true, a2);    a2.resize(n + m - 1);    Mint iz = Mint(z).inv();    for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;    return a2;} ll n, k, q, h, w; ll m1, m2;vector<ll> g[200'009 * 2]; vector<ll> a, b; vector<ll> qs[200'009];ll qi = 0;ll sz = 0; Mint mod_pow (Mint l, ll r) {\tif (r == 0) return 1; \treturn mod_pow((l * l), r/2) * ((r%2) ? l : 1);}Mint mod_inv (Mint x) {\treturn mod_pow(x, FOD-2);} ll id[200'009 * 2];void dfs (ll v) {\tfor (ll u : g[v]) {\t\tif (id[u] != -1) continue; \t\tid[u] = (id[v] + 1) % k;\t\tdfs(u);\t}} template<class T>vector<ll> mp (const vector<T> &s) {\tvector<ll> ans(s.size() + 1);\tans[0] = -1;\tll j = -1;\tfor (ll i = 0; i < s.size(); i++) {\t\twhile (j >= 0 && s[i] != s[j]) j = ans[j];\t\tj++;\t\tans[i+1] = j;\t}\treturn ans;} void solve () {\tfor (ll i = 0; i < n*2; i++) {\t\tid[i] = -1;\t}\tid[0] = 0;\tdfs(0);\tid[n+0] = 0;\tdfs(n+0); \tvector<P> sa(k, {0, 0}), sb(k, {0, 0});\tP cnta = {0, 0}, cntb = {0, 0};\tfor (ll i = 0; i < n; i++) {\t\tll key = id[i];\t\tif (a[i] == 0) {\t\t\t// in\t\t\tsa[key].first++;\t\t\tcnta.first++;\t\t} else {\t\t\t// out\t\t\tsa[(key + 1) % k].second++;\t\t\tcnta.second++;\t\t} \t\t// cerr << i << \": \" << key << endl;\t}\tfor (ll i = 0; i < n; i++) {\t\tll key = id[n+i];\t\tif (b[i] == 0) {\t\t\t// in\t\t\tsb[key].second++;\t\t\tcntb.second++;\t\t} else {\t\t\t// out\t\t\tsb[(key + 1) % k].first++;\t\t\tcntb.first++;\t\t}\t\t// cerr << i << \": \" << key << endl;\t} \tvector<P> s;\tfor (ll i = 0; i < k; i++) {\t\t// cerr << \"i <- \" << i << \" \" << sa[i].first << \" \" << sa[i].second << endl;\t\ts.push_back(sa[i]);\t}\ts.push_back({-1,-1});\tfor (ll i = 0; i < k; i++) {\t\t// cerr << \"i <- \" << i << \" \" << sb[i].first << \" \" << sb[i].second << endl;\t\ts.push_back(sb[i]);\t}\tfor (ll i = 0; i < k; i++) {\t\ts.push_back(sb[i]);\t}\t\t// for (ll i = 0; i < s.size(); i++) {\t// \tcerr << \"(\" << s[i].first << \", \" << s[i].second << endl;\t// } \tvector<ll> amp = mp(s);\tbool isok = false;\tfor (ll i = k*2+1; i <= k*3+1; i++) {\t\tif (amp[i] == k) isok = true;\t}\tif (cnta == (P){n, 0} && cntb == (P){n, 0}) isok = true;\tif (cnta == (P){0, n} && cntb == (P){0, n}) isok = true; \tcout << (isok ? \"YES\" : \"NO\") << \"\\n\";} int main (void) {\tcin >> q;\twhile (q--) {\t\tcin >> n >> k;\t\tfor (ll i = 0; i < n; i++) {\t\t\tg[i].clear();\t\t\tg[n+i].clear();\t\t} \t\ta.resize(n);\t\tfor (ll i = 0; i < n; i++) {\t\t\tcin >> a[i];\t\t}\t\tcin >> m1;\t\tfor (ll i = 0; i < m1; i++) {\t\t\tll u, v;\t\t\tcin >> u >> v;\t\t\tu--;\t\t\tv--;\t\t\tg[u].push_back(v);\t\t} \t\tb.resize(n);\t\tfor (ll i = 0; i < n; i++) {\t\t\tcin >> b[i];\t\t}\t\tcin >> m2;\t\tfor (ll i = 0; i < m2; i++) {\t\t\tll u, v;\t\t\tcin >> u >> v;\t\t\tu--;\t\t\tv--;\t\t\tg[n+u].push_back(n+v);\t\t}  \t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "hashing",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. C+K+S.json",
    "hint": []
}