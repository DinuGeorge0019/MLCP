{"link": "https://codeforces.com//contest/478/problem/D", "problemId": "15554", "problem_idx": "D", "shortId": "478D", "contest_number": "478", "problem_submissions": {"A": [8258502, 8254419, 8251763, 8250596, 8251166, 8251074, 8251538, 8250557, 8267487, 8251455, 8249993, 8250816, 8253353, 8256507, 8253825, 8252923, 8250199, 8253750], "B": [8257657, 8256034, 8253891, 8253270, 8254201, 8254146, 8255645, 8254291, 8257611, 8253431, 8256087, 8254278, 8257895, 8254846, 8262457, 8254941, 8253840, 8257315], "C": [8256918, 8252832, 8255659, 8262464, 8255527, 8256746, 8259618, 8256187, 8253772, 8264278, 8254073, 8258612, 8254081, 8257974, 8253554, 8257821, 8258519, 8253921], "D": [8256144, 8262213, 8260763, 8259172, 8260577, 8261702, 8264944, 8264911, 8266406, 8259525, 8262021, 8263999, 8262602, 8263968, 8262169, 8265099, 8266940, 8275344, 8263779]}, "name": "D. Red-Green Towers", "statement": "There are red and green blocks for construction of the tower. tower can\r\nbe built following next rules: Red-green tower is consisting of some\r\nnumber of levels; Let the red-green tower consist of levels, then the\r\nfirst level of this tower should consist of blocks, second level of\r\nblocks, the third one of blocks, and so on the last level of such tower\r\nshould consist of the one block. In other words, each successive level\r\nshould contain one block less than the previous one; Each level of the\r\nred-green tower should contain blocks of the same color. Let be the\r\nmaximum possible number of levels of red-green tower, that can be built\r\nout of red and green blocks meeting the rules above. The task is to\r\ndetermine how many different red-green towers having levels can be built\r\nout of the available blocks.Two red-green towers are considered\r\ndifferent if there exists some level, that consists of red blocks in the\r\none tower and consists of green blocks in the other tower.You are to\r\nwrite a program that will find the number of different red-green towers\r\nof height modulo .\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int maxn=1005;\nconst int mod=(int)1e9+7;\n\nint r,g;\nint f[maxn];\nint dp[400001],vis[400001];\n\nint solve(int x,bool &p){\n    static int i,j;\n    memset(dp,0,sizeof(dp));\n    memset(vis,0,sizeof(vis));\n    dp[0]=1;\n    vis[0]=1;\n    for(i=1;i<=x;i++)\n    for(j=r;j>=i;j--){\n        dp[j]+=dp[j-i];\n        vis[j]|=vis[j-i];\n        if(dp[j]>=mod)dp[j]-=mod;\n    }\n    p=false;\n    int ans=0,sum=(1+x)*x/2;\n    //printf(\"%d(%d):\\n\",x,sum);\n    for(i=0;i<=r;i++){\n        if(sum-i>g)continue;\n        //printf(\"%d:%d %d\\n\",i,vis[i],dp[i]);\n        p|=vis[i];\n        ans+=dp[i];\n        if(ans>=mod)ans-=mod;\n    }\n    return ans;\n}\n\nint main(){\n    int i,x=-1;\n    for(i=0;i<maxn;i++)\n        f[i]=i*(i+1)/2;\n    cin>>r>>g;\n    for(i=0;i<maxn;i++)\n        if(f[i]<=r+g)x=i;\n    bool p;\n    int ans;\n    while(x){\n        ans=solve(x,p);\n        if(p){\n            cout<<ans<<endl;\n            return 0;\n        }\n        x--;\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2000", "interactive": false}