{
    "link": "https://codeforces.com//contest/1513/problem/D",
    "problemId": "954481",
    "problem_idx": "D",
    "shortId": "1513D",
    "contest_number": "1513",
    "problem_submissions": {
        "F": [
            112704242,
            112708449,
            112692430,
            112693367,
            112715319,
            112703491,
            112694811,
            127489679,
            112714894,
            112706130
        ],
        "E": [
            112694829,
            112692532,
            112741611,
            112740521,
            112688817,
            112693970,
            112694924,
            112695544,
            112697383,
            112699670,
            112696818,
            112699923,
            112700793
        ],
        "D": [
            112684276,
            112682550,
            112679745,
            112679949,
            112677500,
            112683697,
            112682474,
            112682520,
            113011471,
            113011359,
            113011120,
            113011016,
            113009370,
            112680944,
            112706307,
            112684078,
            112683480,
            112687888,
            112686211,
            112688484,
            112694241
        ],
        "C": [
            112675074,
            112673956,
            112673377,
            112672093,
            112671463,
            112675182,
            112671664,
            112676030,
            112671692,
            112674449,
            112673953,
            112672990,
            112673437,
            112678260,
            112672998,
            112674969
        ],
        "B": [
            112671476,
            112670228,
            112670172,
            112670205,
            112668144,
            112670061,
            112665513,
            112670183,
            112667846,
            112669295,
            112667797,
            112667641,
            112669249,
            112668199,
            112668800,
            112667109
        ],
        "A": [
            112663904,
            112665049,
            112664695,
            112668785,
            112662814,
            112664430,
            112662730,
            112664013,
            112662970,
            112664151,
            112662873,
            112663063,
            112663560,
            112664683,
            112663477,
            112662816
        ]
    },
    "name": "D. GCD and MST",
    "statement": "You are given an array a of n (n\r\ngeq 2) positive integers and an integer p. Consider an undirected\r\nweighted graph of n vertices numbered from 1 to n for which the edges\r\nbetween the vertices i and j (i<j) are added in the following manner: If\r\ngcd(a_i, a_{i+1}, a_{i+2},\r\ndots, a_{j}) = min(a_i, a_{i+1}, a_{i+2},\r\ndots, a_j), then there is an edge of weight min(a_i, a_{i+1}, a_{i+2},\r\ndots, a_j) between i and j. If i+1=j, then there is an edge of weight p\r\nbetween i and j. Here gcd(x, y,\r\nldots) denotes the greatest common divisor (GCD) of integers x, y,\r\n....Note that there could be multiple edges between i and j if both of\r\nthe above conditions are true, and if both the conditions fail for i and\r\nj, then there is no edge between these vertices.The goal is to find the\r\nweight of the minimum spanning tree of this graph.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int N = 200010;\nconst int M = 200010;\nconst int mod = 1e9 + 7;\n\n\nint a[N];\nbool used[N];\nvoid solve() {\n    int n, p;\n    scanf(\"%d%d\", &n, &p);\n    vector<pii> v;\n    for (int i = 0; i < n; ++i) {\n        used[i] = false;\n        scanf(\"%d\", &a[i]);\n        v.emplace_back(a[i], i);\n    }\n    sort(v.begin(), v.end());\n    vector<int> ans;\n    for (int i = 0; i < v.size(); ++i) {\n        if (v[i].first >= p) break;\n        if (used[v[i].second]) continue;\n        used[v[i].second] = true;\n        int j = v[i].second - 1, st = v[i].second;\n        while (j >= 0 && a[j] % a[st] == 0) {\n            ans.push_back(a[st]);\n            if (used[j]) break;\n            used[j] = true;\n            j--;\n        }\n        j = v[i].second + 1;\n        while (j < n && a[j] % a[st] == 0) {\n            ans.push_back(a[st]);\n            if (used[j]) break;\n            used[j] = true;\n            j++;\n        }\n    }\n    while (ans.size() < n - 1) ans.push_back(p);\n    long long res = 0;\n    for (int i = 0; i < ans.size(); ++i) {\n        res = res + ans[i];\n    }\n    printf(\"%lld\\n\", res);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t;\n    scanf(\"%d\", &t);\n    for (int i = 0; i < t; ++i) solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dsu",
        "graphs",
        "greedy",
        "number theory",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. GCD and MST.json",
    "editorial_link": "https://codeforces.com//blog/entry/89550",
    "editorial": "We will iterate from smallest to largest number like in krushkalâs\r\nalgorithm. By this, we will consider the edges with the smallest weight\r\nfirst.Now, while iterating, we will assume the current value as the gcd\r\nwe want to get, letâs say and we will go left and then right while going\r\nleft/right, if , we will add an edge in the graph between corresponding\r\npositions of and . Also while adding edge we must keep in mind that we\r\nshouldnât create a cycle. If we are forming a cycle, we shouldnât add\r\nthis edge and stop spanning in that direction. We can use a DSU to check\r\nthis but in this particular problem, this is not required. We can simply\r\ncheck previously whether there is any edge connected to . If so, we will\r\nadd this edge and stop spanning further as any further entry forms a\r\ncycle (Think why this is so. This is because we are adding edges in\r\nsegments kind of fashion). Also, we need to stop when the current we are\r\nconsidering is greater than the parameter since we can connect the\r\ncurrently connected components by edges with weight . Thus the number of\r\nedges considered would be , and then the overall complexity of finding\r\nwould be due to sorting.\r\n",
    "hint": []
}