{
    "link": "https://codeforces.com//contest/1875/problem/G",
    "problemId": "2236827",
    "problem_idx": "G",
    "shortId": "1875G",
    "contest_number": "1875",
    "problem_submissions": {
        "E": [
            226007719,
            225981502,
            225997077,
            226024812,
            226185388
        ],
        "G": [
            225993602,
            226090450
        ],
        "F": [
            225971818,
            226006439,
            226020128,
            226050711,
            225991779,
            225996607,
            226001082,
            226008955,
            226036106,
            226011936,
            226022791,
            225995919,
            226047877,
            226038835,
            226042165,
            226041500,
            226073814,
            226044458,
            226057628,
            226055233
        ],
        "D": [
            225942990,
            225945406,
            225967656,
            225971005,
            225948214,
            225965867,
            225965428,
            226166990,
            225970035,
            225966878,
            225985894,
            225988437,
            225968095,
            225971454,
            225977691,
            226097811,
            225987379,
            225979524,
            225966823,
            225974445,
            225980563
        ],
        "C": [
            225939447,
            225939555,
            225947158,
            225965943,
            225943124,
            225946690,
            225948786,
            226166742,
            225977924,
            225959112,
            225979842,
            225969180,
            225983960,
            225947912,
            225967709,
            226097802,
            225947425,
            225963735,
            225961969,
            225959306,
            225971328
        ],
        "B": [
            225926540,
            225961576,
            225976303,
            226005705,
            225926794,
            225939253,
            225942474,
            225938657,
            225940294,
            225948707,
            225962038,
            225978973,
            225941566,
            225960227,
            225968949,
            225945531,
            225926701,
            225941384,
            225964167
        ],
        "A": [
            225922227,
            225921742,
            225921601,
            225922250,
            225922542,
            225921535,
            225921818,
            225921875,
            225922229,
            225922177,
            225923351,
            225970588,
            225921694,
            225925214,
            226097785,
            225924482,
            225921598,
            225921501,
            225922602,
            225947031
        ]
    },
    "name": "G. Jellyfish and Miku",
    "statement": "There are n + 1 cities with numbers from 0 to n, connected by n roads.\r\nThe i-th (1\r\nleq i\r\nleq n) road connects city i-1 and city i bi-directionally. After\r\nJellyfish flew back to city 0, she found out that she had left her Miku\r\nfufu in city n.Each road has a level of . Denote the beauty of the i-th\r\nroad as a_i.Jellyfish is trying to find her fufu. Because of her poor\r\nsense of direction, she doesn\u2019t know which way to go. Every day, she\r\nrandomly chooses a road connected to the city she currently is in and\r\ntraverses it. Let s be the sum of the beauty of the roads connected to\r\nthe current city. For each road connected to the current city, Jellyfish\r\nwill traverse the road with a probability of\r\nfrac x s, where x is the beauty of the road, reaching the city on the\r\nother side of the road.Jellyfish will start at city 0, and she will get\r\nonly her fufu back when she reaches city n.You want to choose the beauty\r\nof the roads such that the expected number of days Jellyfish takes to\r\nfind her fufu will be the minimum possible. However, due to limited\r\nfunding, the sum of beauties of all roads must be less than or equal to\r\nm. Find the minimum expected number of days Jellyfish needs to get her\r\nfufu back if the beauty of the roads is chosen optimally.\r\n",
    "solutions": [
        "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst ll inff = 1e18;\nvoid solve()//cal sum a[i]/a[j](i<=j),sum a[i]=m\n{\n    int n, m; cin >> n >> m; vector<vector<double> >dp(n + 1, vector<double>(m + 1, inff)); dp[0][0] = 0;\n    for (int i = 0; i < n; i++)for (int j = 0; j <= m; j++)for (int k = j + 1,lim=j+(m-j)/(n-i);k<=lim; k++)\n        dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + 1.0 * j / (k - j));\n    printf(\"%.12lf\\n\", dp[n][m] * 2 + n);\n}\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);\n    int t = 1;//cin >> t;\n    while (t--)solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Jellyfish and Miku.json",
    "editorial_link": "https://codeforces.com//blog/entry/120943",
    "editorial": "Let's assume that a\n is given. We can use dynamic programming to solve the problem.\n\nLet's define fi\n as the expected number of days Jellyfish needs to reach city i\n from city 0\n.\n\nWe will have:\n\nf0=0,f1=1\n\n?i>1,fi=fi?1+1+ai?1ai?1+ai\u00d7(fi?fi?2)\n\nLet's make it better:\n\nfi=fi?1+1+ai?1ai\u00d7(fi?1?fi?2+1)\nWhat does this inspire us to do? Let's define gi=fi?fi?1\n, then we will get:\n\ng1=1\n\n?i>1,gi=1+ai?1ai\u00d7(gi?1+1)\n\nBy induction, we will find gi=1+2\u00d7?i?1j=1ajai\n. According to the definition, fn=?ni=1gn=n+2\u00d7?ni=1?i?1j=1ajai\n.\n\nThen we can use dynamic programming to solve the problem itself.\n\nLet's define si=?ij=1aj\n, then fn=n+2\u00d7?ni=1si?1ai\n.\n\nLet's define dpi,x\n as the minimum value of ?ni=1si?1ai\n when si=x\n.\n\nWe transit by enumerating the values of ai+1\n, The transition is: dpi+1,x+y?dpi,x+xy\n.\n\nBut the time complexity is O(nm2)\n, how can it becomes faster?\n\nLet's take a closer look at ?ni=1?i?1j=1ajai\n. If there exists i<n\n satisfying ai>ai+1\n. We can swap ai\n and ai+1\n, the answer will be better! so a\n is a non-decreasing array, which means ai?mn?i+1\n.\n\nBecause ?ni=1ni\n is O(nlogn)\n, so if we only enumerate the possible values of ai\n the time complexity will be O(m2logm)\n.\n\nTime complexity: O(m2logm)\n\nMemory complexity: O(nm)"
}