{
    "link": "https://codeforces.com//contest/1228/problem/D",
    "problemId": "424245",
    "problem_idx": "D",
    "shortId": "1228D",
    "contest_number": "1228",
    "problem_submissions": {
        "F": [
            61496806,
            61502870,
            61502190,
            61505436,
            61526774,
            61501386,
            61506794,
            61506003,
            61507242,
            61528062,
            61506930,
            61504933,
            61527679,
            61758392,
            61506804,
            61501659
        ],
        "E": [
            61487066,
            61484839,
            61491424,
            61489793,
            61526757,
            61494082,
            61491501,
            61493504,
            61494383,
            61528054,
            61491524,
            61495860,
            61488344,
            61491222,
            61486950,
            61487675,
            61498567,
            61492377,
            61492698,
            61509475,
            61488264
        ],
        "D": [
            61485310,
            61482745,
            61489582,
            61486586,
            61526744,
            61490366,
            61487311,
            61489384,
            61491690,
            61528041,
            61498727,
            61505643,
            61485067,
            61484265,
            61490334,
            61491347,
            61491538,
            61486214,
            61487124,
            61487752,
            61482893
        ],
        "C": [
            61480399,
            61479345,
            61481687,
            61481376,
            61526733,
            61486187,
            61481654,
            61482779,
            61486226,
            61528029,
            61481914,
            61486289,
            61481778,
            61480281,
            61475855,
            61480938,
            61484833,
            61479319,
            61482763,
            61482555,
            61495805
        ],
        "B": [
            61476242,
            61476828,
            61478048,
            61477189,
            61526720,
            61483135,
            61479399,
            61477633,
            61477664,
            61528022,
            61483663,
            61478266,
            61477452,
            61477008,
            61479768,
            61476788,
            61509875,
            61476696,
            61478410,
            61478919,
            61476259
        ],
        "A": [
            61473188,
            61476420,
            61473176,
            61473720,
            61526708,
            61477230,
            61473216,
            61473745,
            61473523,
            61528006,
            61479593,
            61475038,
            61472935,
            61473261,
            61477228,
            61473405,
            61476821,
            61473215,
            61474472,
            61475483,
            61474687
        ]
    },
    "name": "D. Complete Tripartite",
    "statement": "You have a simple undirected graph consisting of n vertices and m edges.\r\nThe graph doesn’t contain self-loops, there is at most one edge between\r\na pair of vertices. The given graph can be disconnected.Let’s make a\r\ndefinition.Let v_1 and v_2 be two some nonempty subsets of vertices that\r\ndo not intersect. Let f(v_{1}, v_{2}) be true if and only if all the\r\nconditions are satisfied: There are no edges with both endpoints in\r\nvertex set v_1. There are no edges with both endpoints in vertex set\r\nv_2. For every two vertices x and y such that x is in v_1 and y is in\r\nv_2, there is an edge between x and y. Create three vertex sets (v_{1},\r\nv_{2}, v_{3}) which satisfy the conditions below; All vertex sets should\r\nnot be empty. Each vertex should be assigned to only one vertex set.\r\nf(v_{1}, v_{2}), f(v_{2}, v_{3}), f(v_{3}, v_{1}) are all true. Is it\r\npossible to create such three vertex sets? If it’s possible, print\r\nmatching vertex set for each vertex.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100010, M = 300010;\n\nint n, m;\nint u[M], v[M];\nint color[N];\nset<int> g[N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d%d\", &u[i], &v[i]);\n    g[u[i]].insert(v[i]);\n    g[v[i]].insert(u[i]);\n  }\n  int a = 1, b = -1, c = -1;\n  for (int i = 1; i <= m; ++i)\n    if (u[i] == 1) {\n      color[v[i]] = -1;\n    }\n  for (int i = 1; i <= m; ++i)\n    if (color[u[i]] == -1 && color[v[i]] == -1) {\n      b = u[i];\n      c = v[i];\n      break;\n    }\n#define GG do{puts(\"-1\"); return 0;}while(false)\n  if (b == -1) {\n    GG;\n  }\n  for (int i = 1; i <= n; ++i) {\n    bool fa = g[i].count(a), fb = g[i].count(b), fc = g[i].count(c);\n    if (fa + fb + fc != 2)\n      GG;\n    if (!fa)\n      color[i] = 1;\n    else if (!fb)\n      color[i] = 2;\n    else\n      color[i] = 3;\n  }\n  for (int i = 1; i <= m; ++i)\n    if (color[u[i]] == color[v[i]]) {\n      GG;\n    }\n  int ta= count(color + 1, color + n + 1, 1), tb=count(color + 1, color + n + 1, 2), tc=count(color + 1, color + n + 1, 3);\n  if (m != ta*(ll)tb+tb*(ll)tc+tc*(ll)ta)\n    GG;\n  for (int i = 1; i <= n; ++i)\n    printf(\"%d \", color[i]);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "hashing",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Complete Tripartite.json",
    "editorial_link": "https://codeforces.com//blog/entry/70162",
    "editorial": "You can make answer by following these steps; If two vertices and are in\r\nsame vertex set, there should be no edge between them. Otherwise, there\r\nshould be edge between them. If you choose any as first vertex of\r\nspecific vertex set, then you can simply add all vertices which are not\r\ndirectly connected to in that vertex set. Make vertex sets by doing\r\nsecond step multiple times. If you canât make sets or there is any\r\nvertex which is not in any vertex set, then answer is impossible. If ,\r\nthen answer is impossible. means size of -th vertex set. For all\r\nvertices and from different vertex sets, if there is no direct\r\nconnection between and , then answer is impossible. If you validated all\r\nsteps, then current vertex set assignment is answer. Make sure you are\r\ndoing all steps. If you forget any of these steps, your solution will\r\nprint wrong answer.Time complexity is .\r\n",
    "hint": []
}