{
    "link": "https://codeforces.com//contest/862/problem/F",
    "problemId": "123163",
    "problem_idx": "F",
    "shortId": "862F",
    "contest_number": "862",
    "problem_submissions": {
        "F": [
            30522146
        ],
        "E": [
            30515524,
            30514981,
            30514016,
            30514863,
            30521757,
            30513966,
            30514334,
            30520725,
            30516565,
            30519106,
            30520786,
            30520302,
            30519855,
            30521281,
            30521147,
            30521254,
            30521944,
            30521635,
            30520751
        ],
        "C": [
            30514106,
            30508600,
            30509568,
            30508140,
            30506918,
            30515950,
            30507825,
            30509973,
            30520060,
            30513375,
            30510462,
            30514508,
            30513811,
            30512130,
            30512019,
            30511796,
            30511858,
            30510871,
            30512321
        ],
        "D": [
            30510386,
            30511427,
            30518392,
            30512215,
            30515491,
            30512095,
            30520485,
            30514131,
            30513495,
            30515366,
            30516105,
            30512969,
            30517047,
            30515613,
            30516506,
            30516739,
            30517091,
            30515520
        ],
        "B": [
            30503649,
            30504269,
            30503848,
            30503359,
            30502486,
            30503263,
            30503865,
            30504630,
            30505338,
            30505127,
            30506532,
            30504918,
            30504595,
            30505318,
            30506615,
            30505351,
            30507736,
            30506138,
            30506809
        ],
        "A": [
            30502233,
            30502672,
            30502339,
            30502484,
            30502166,
            30502202,
            30502311,
            30502278,
            30502286,
            30502588,
            30504719,
            30504828,
            30502367,
            30502429,
            30504564,
            30502776,
            30503501,
            30505382
        ]
    },
    "name": "F. Mahmoud and Ehab and the final stage",
    "statement": "Mahmoud and Ehab solved Dr. Evil’s questions so he gave them the\r\npassword of the door of the evil land. When they tried to open the door\r\nusing it, the door gave them a final question to solve before they leave\r\n(yes, the door is digital, Dr. Evil is modern). If they don’t solve it,\r\nall the work will be useless and they won’t leave the evil land forever.\r\nWill you help them?Mahmoud and Ehab are given strings numbered from to\r\nand queries, Each query has one of the following forms: , For all the\r\nintervals where find the maximum value of this expression: where is the\r\nlength of the longest common prefix of the strings . where is a string,\r\nconsisting of lowercase English letters. Change the string at position\r\nto .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nstd::string a[100001];\nint lcp[100001], N, Q;\nstruct node\n{\n\tint ans;\n\tstd::vector < std::pair < int, int > > L, R;\n}\nT[262144];\nnode merge(const node &L, const node &R, int m)\n{\n\t// printf(\"m=%d\\n\", m);\n\tnode res;\n\tres.ans = std::max(L.ans, R.ans);\n\tres.L = L.L;\n\tfor (auto i = L.R.end() - 1, j = R.L.end() - 1; i >= L.R.begin(); i--)\n\t{\n\t\twhile (j > R.L.begin() && j -> first < i -> first)\n\t\t\tj--;\n\t\tif (j -> first < i -> first)\n\t\t\tbreak;\n\t\tres.ans = std::max(res.ans, (j -> second - i -> second + 1) * std::min(lcp[m], i -> first));\n\t\t// printf(\"i=%d,%d j=%d,%d\\n\", i -> first, i -> second, j -> first, j -> second);\n\t}\n\tfor (auto i = R.L.end() - 1, j = L.R.end() - 1; i >= R.L.begin(); i--)\n\t{\n\t\twhile (j > L.R.begin() && j -> first < i -> first)\n\t\t\tj--;\n\t\tif (j -> first < i -> first)\n\t\t\tbreak;\n\t\tres.ans = std::max(res.ans, (i -> second - j -> second + 1) * std::min(lcp[m], i -> first));\n\t\t// printf(\"i=%d,%d j=%d,%d\\n\", i -> first, i -> second, j -> first, j -> second);\n\t}\n\tfor (auto i : R.L)\n\t{\n\t\ti.first = std::min(i.first, lcp[m]);\n\t\tif (i.first >= res.L.back().first)\n\t\t\tres.L.back().second = i.second;\n\t\telse\n\t\t\tres.L.push_back(i);\n\t}\n\tres.R = R.R;\n\tfor (auto i : L.R)\n\t{\n\t\ti.first = std::min(i.first, lcp[m]);\n\t\tif (i.first >= res.R.back().first)\n\t\t\tres.R.back().second = i.second;\n\t\telse\n\t\t\tres.R.push_back(i);\n\t}\n\treturn res;\n}\nvoid build(int p, int l, int r)\n{\n\tif (l == r)\n\t{\n\t\tT[p].ans = a[l].length();\n\t\tT[p].L = T[p].R = { { a[l].length(), l } };\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tbuild(p << 1, l, m);\n\tbuild(p << 1 | 1, m + 1, r);\n\tT[p] = merge(T[p << 1], T[p << 1 | 1], m);\n}\nnode G(int p, int l, int r, int L, int R)\n{\n\tif (L <= l && r <= R)\n\t\treturn T[p];\n\tint m = l + r >> 1;\n\tif (R <= m)\n\t\treturn G(p << 1, l, m, L, R);\n\tif (L > m)\n\t\treturn G(p << 1 | 1, m + 1, r, L, R);\n\treturn merge(G(p << 1, l, m, L, R), G(p << 1 | 1, m + 1, r, L, R), m);\n}\nvoid update(int p, int l, int r, int x)\n{\n\tif (l == r)\n\t{\n\t\tT[p].ans = a[l].length();\n\t\tT[p].L = T[p].R = { { a[l].length(), l } };\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tif (x <= m)\n\t\tupdate(p << 1, l, m, x);\n\tif (x >= m)\n\t\tupdate(p << 1 | 1, m + 1, r, x);\n\tT[p] = merge(T[p << 1], T[p << 1 | 1], m);\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 1; i <= N; i++)\n\t\tstd::cin >> a[i];\n\tfor (int i = 1; i < N; i++)\n\t\twhile (a[i][lcp[i]] == a[i + 1][lcp[i]])\n\t\t\tlcp[i]++;\n\tbuild(1, 1, N);\n\twhile (Q--)\n\t{\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1)\n\t\t{\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", G(1, 1, N, l, r).ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tstd::cin >> a[x];\n\t\t\tif (x > 1)\n\t\t\t{\n\t\t\t\tlcp[x - 1] = 0;\n\t\t\t\twhile (a[x - 1][lcp[x - 1]] == a[x][lcp[x - 1]])\n\t\t\t\t\tlcp[x - 1]++;\n\t\t\t\tupdate(1, 1, N, x - 1);\n\t\t\t}\n\t\t\tif (x < N)\n\t\t\t{\n\t\t\t\tlcp[x] = 0;\n\t\t\t\twhile (a[x][lcp[x]] == a[x + 1][lcp[x]])\n\t\t\t\t\tlcp[x]++;\n\t\t\t\tupdate(1, 1, N, x);\n\t\t\t}\n\t\t\tupdate(1, 1, N, x);\n\t\t}\n\t\t// for (int i = 1; i < N; i++)\n\t\t\t// printf(\"lcp[%d] = %d\\n\", i, lcp[i]);\n\t\t/*\n\t\tfor (int i = 1; i <= 9; i++)\n\t\t{\n\t\t\tprintf(\"node[%d]:\\n\", i);\n\t\t\tprintf(\"\\tans = %d\\n\", T[i].ans);\n\t\t\tprintf(\"\\tL :\\n\");\n\t\t\tfor (auto &j : T[i].L)\n\t\t\t\tprintf(\"\\t\\t%d,%d\\n\", j.first, j.second);\n\t\t\tprintf(\"\\tR :\\n\");\n\t\t\tfor (auto &j : T[i].R)\n\t\t\t\tprintf(\"\\t\\t%d,%d\\n\", j.first, j.second);\n\t\t}\n\t\t*/\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Mahmoud and Ehab and the final stage.json",
    "editorial_link": "https://codeforces.com//blog/entry/54590",
    "editorial": "First, Letâs get rid of the part . observation: , That could make us\r\ntransform the part into a minimization part by making an array where ,\r\nYou could calculate it naively, And when an update happens at index ,\r\nYou should update (If exists) and (If exists) naively . Now the problem\r\nreduces to finding that maximizes the value:- , If we have a histogram\r\nwhere the column has height , The the size of the largest rectangle that\r\nfits in the columns from to is , Thatâs close to our formula not the\r\nsame but itâs not a problem (Youâll see how to fix it later), so to get\r\nrid of finding the and part, We can make that histogram and the answer\r\nfor a query will be the largest rectangle in the subhistogram that\r\ncontains the columns from to , One of the ways to solve it is to try\r\nsome heights and see the maximum width we can achieve if was the height,\r\ncall it , and maximize with , To solve the slight difference in formulas\r\nproblem weâll just maximize with !! Let be a value the weâll choose\r\nlater, We have 2 cases for our largest rectangleâs height , It could be\r\neither or , We will solve both problems separately. For we can maintain\r\nsegment trees, Segment tree number has at index if and otherwise, When\r\nwe query, It should get us the longest subsegment of ones in the query\r\nrange, Letâs see what we need for our merging operation, If we want the\r\nanswer for the longest subsegment of ones in a range , Let , Then the\r\nanswer is the maximum between the answer of , The answer of , And the\r\nmaximum suffix of ones in the range added to the maximum prefix of ones\r\nin the range . So we need to keep all these information in our node and\r\nalso the length of the interval, As itâs a well-known problem I wonât\r\nget into more detail. Back to our problem, We can loop over all , Let\r\nthe answer for the query on range in segment tree number be , The\r\nmaximum width of a rectangle of height in this range is and weâll\r\nmaximize our answer with . For , Letâs call a column of height greater\r\nthan big, The heights weâll try are the heights of the big columns in\r\nthe range, We donât have to try all the heights greater the , There are\r\nat most big columns (Where is the total length of strings in input),\r\nLetâs keep them in a set, When an update happens, You should add the\r\ncolumn to the set or remove it depending on its new height, The setâs\r\nsize canât exceed now, Letâs see how to answer a query, Letâs loop over\r\nthe big columns in range only, If 2 of them arenât consecutive then the\r\ncolumn after the first canât be big and the column before the second\r\neither, Thatâs because if it were big, It would be in our set, So we can\r\nuse this observation by making a new histogram with the big columns in\r\nthe range only, And put a column with height 0 between any\r\nnon-consecutive two, And get the largest rectangle in this histogram by\r\nthe stack way for example in , The stack way will get us the maximum\r\nwidth we can achieve for a rectangle containing column number , Weâll\r\nmaximize with . Also the answer for our main formula can be an interval\r\nof length one, All what I mentioned doesnât cover this, You should\r\nmaintain another segment tree that gets the maximum length of a string\r\nin a range for this . Maximize all what we got, You have the answer, Now\r\nitâs time to choose , Itâs optimal in time to choose near (Reason in\r\ntfgâs comment below) . Optimization: The longest subsegment of ones\r\nproblem is solved by segment trees and each one has 4 integers in each\r\nnode, You can make them 2 integers (max prefix and suffix of ones) and\r\nmake another only one segment tree that has the rest of the integers,\r\nThat would divide the memory by 2 . Time complexity : Thanks to\r\nvintage_Vlad_Makeev for making it harder and more interesting . Solution\r\nlink (vintage_Vlad_Makeev) : https://pastebin.com/vQ4RJqh0 . Solution\r\nlink (mahmoudbadawy) : https://pastebin.com/t3Vetzwf .\r\n",
    "hint": []
}