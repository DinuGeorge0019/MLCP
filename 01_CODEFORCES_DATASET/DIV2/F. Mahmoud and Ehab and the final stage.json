{"link": "https://codeforces.com//contest/862/problem/F", "problemId": "123163", "problem_idx": "F", "shortId": "862F", "contest_number": "862", "problem_submissions": {"F": [30522146], "E": [30515524, 30514981, 30514016, 30514863, 30521757, 30513966, 30514334, 30520725, 30516565, 30519106, 30520786, 30520302, 30519855, 30521281, 30521147, 30521254, 30521944, 30521635, 30520751], "C": [30514106, 30508600, 30509568, 30508140, 30506918, 30515950, 30507825, 30509973, 30520060, 30513375, 30510462, 30514508, 30513811, 30512130, 30512019, 30511796, 30511858, 30510871, 30512321], "D": [30510386, 30511427, 30518392, 30512215, 30515491, 30512095, 30520485, 30514131, 30513495, 30515366, 30516105, 30512969, 30517047, 30515613, 30516506, 30516739, 30517091, 30515520], "B": [30503649, 30504269, 30503848, 30503359, 30502486, 30503263, 30503865, 30504630, 30505338, 30505127, 30506532, 30504918, 30504595, 30505318, 30506615, 30505351, 30507736, 30506138, 30506809], "A": [30502233, 30502672, 30502339, 30502484, 30502166, 30502202, 30502311, 30502278, 30502286, 30502588, 30504719, 30504828, 30502367, 30502429, 30504564, 30502776, 30503501, 30505382]}, "name": "F. Mahmoud and Ehab and the final stage", "statement": "Mahmoud and Ehab solved Dr. Evil\u2019s questions so he gave them the\r\npassword of the door of the evil land. When they tried to open the door\r\nusing it, the door gave them a final question to solve before they leave\r\n(yes, the door is digital, Dr. Evil is modern). If they don\u2019t solve it,\r\nall the work will be useless and they won\u2019t leave the evil land forever.\r\nWill you help them?Mahmoud and Ehab are given strings numbered from to\r\nand queries, Each query has one of the following forms: , For all the\r\nintervals where find the maximum value of this expression: where is the\r\nlength of the longest common prefix of the strings . where is a string,\r\nconsisting of lowercase English letters. Change the string at position\r\nto .\r\n", "solutions": ["#include <cstdio>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nstd::string a[100001];\nint lcp[100001], N, Q;\nstruct node\n{\n\tint ans;\n\tstd::vector < std::pair < int, int > > L, R;\n}\nT[262144];\nnode merge(const node &L, const node &R, int m)\n{\n\t// printf(\"m=%d\\n\", m);\n\tnode res;\n\tres.ans = std::max(L.ans, R.ans);\n\tres.L = L.L;\n\tfor (auto i = L.R.end() - 1, j = R.L.end() - 1; i >= L.R.begin(); i--)\n\t{\n\t\twhile (j > R.L.begin() && j -> first < i -> first)\n\t\t\tj--;\n\t\tif (j -> first < i -> first)\n\t\t\tbreak;\n\t\tres.ans = std::max(res.ans, (j -> second - i -> second + 1) * std::min(lcp[m], i -> first));\n\t\t// printf(\"i=%d,%d j=%d,%d\\n\", i -> first, i -> second, j -> first, j -> second);\n\t}\n\tfor (auto i = R.L.end() - 1, j = L.R.end() - 1; i >= R.L.begin(); i--)\n\t{\n\t\twhile (j > L.R.begin() && j -> first < i -> first)\n\t\t\tj--;\n\t\tif (j -> first < i -> first)\n\t\t\tbreak;\n\t\tres.ans = std::max(res.ans, (i -> second - j -> second + 1) * std::min(lcp[m], i -> first));\n\t\t// printf(\"i=%d,%d j=%d,%d\\n\", i -> first, i -> second, j -> first, j -> second);\n\t}\n\tfor (auto i : R.L)\n\t{\n\t\ti.first = std::min(i.first, lcp[m]);\n\t\tif (i.first >= res.L.back().first)\n\t\t\tres.L.back().second = i.second;\n\t\telse\n\t\t\tres.L.push_back(i);\n\t}\n\tres.R = R.R;\n\tfor (auto i : L.R)\n\t{\n\t\ti.first = std::min(i.first, lcp[m]);\n\t\tif (i.first >= res.R.back().first)\n\t\t\tres.R.back().second = i.second;\n\t\telse\n\t\t\tres.R.push_back(i);\n\t}\n\treturn res;\n}\nvoid build(int p, int l, int r)\n{\n\tif (l == r)\n\t{\n\t\tT[p].ans = a[l].length();\n\t\tT[p].L = T[p].R = { { a[l].length(), l } };\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tbuild(p << 1, l, m);\n\tbuild(p << 1 | 1, m + 1, r);\n\tT[p] = merge(T[p << 1], T[p << 1 | 1], m);\n}\nnode G(int p, int l, int r, int L, int R)\n{\n\tif (L <= l && r <= R)\n\t\treturn T[p];\n\tint m = l + r >> 1;\n\tif (R <= m)\n\t\treturn G(p << 1, l, m, L, R);\n\tif (L > m)\n\t\treturn G(p << 1 | 1, m + 1, r, L, R);\n\treturn merge(G(p << 1, l, m, L, R), G(p << 1 | 1, m + 1, r, L, R), m);\n}\nvoid update(int p, int l, int r, int x)\n{\n\tif (l == r)\n\t{\n\t\tT[p].ans = a[l].length();\n\t\tT[p].L = T[p].R = { { a[l].length(), l } };\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tif (x <= m)\n\t\tupdate(p << 1, l, m, x);\n\tif (x >= m)\n\t\tupdate(p << 1 | 1, m + 1, r, x);\n\tT[p] = merge(T[p << 1], T[p << 1 | 1], m);\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 1; i <= N; i++)\n\t\tstd::cin >> a[i];\n\tfor (int i = 1; i < N; i++)\n\t\twhile (a[i][lcp[i]] == a[i + 1][lcp[i]])\n\t\t\tlcp[i]++;\n\tbuild(1, 1, N);\n\twhile (Q--)\n\t{\n\t\tint ty;\n\t\tscanf(\"%d\", &ty);\n\t\tif (ty == 1)\n\t\t{\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", G(1, 1, N, l, r).ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tstd::cin >> a[x];\n\t\t\tif (x > 1)\n\t\t\t{\n\t\t\t\tlcp[x - 1] = 0;\n\t\t\t\twhile (a[x - 1][lcp[x - 1]] == a[x][lcp[x - 1]])\n\t\t\t\t\tlcp[x - 1]++;\n\t\t\t\tupdate(1, 1, N, x - 1);\n\t\t\t}\n\t\t\tif (x < N)\n\t\t\t{\n\t\t\t\tlcp[x] = 0;\n\t\t\t\twhile (a[x][lcp[x]] == a[x + 1][lcp[x]])\n\t\t\t\t\tlcp[x]++;\n\t\t\t\tupdate(1, 1, N, x);\n\t\t\t}\n\t\t\tupdate(1, 1, N, x);\n\t\t}\n\t\t// for (int i = 1; i < N; i++)\n\t\t\t// printf(\"lcp[%d] = %d\\n\", i, lcp[i]);\n\t\t/*\n\t\tfor (int i = 1; i <= 9; i++)\n\t\t{\n\t\t\tprintf(\"node[%d]:\\n\", i);\n\t\t\tprintf(\"\\tans = %d\\n\", T[i].ans);\n\t\t\tprintf(\"\\tL :\\n\");\n\t\t\tfor (auto &j : T[i].L)\n\t\t\t\tprintf(\"\\t\\t%d,%d\\n\", j.first, j.second);\n\t\t\tprintf(\"\\tR :\\n\");\n\t\t\tfor (auto &j : T[i].R)\n\t\t\t\tprintf(\"\\t\\t%d,%d\\n\", j.first, j.second);\n\t\t}\n\t\t*/\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "strings"], "dificulty": "2900", "interactive": false}