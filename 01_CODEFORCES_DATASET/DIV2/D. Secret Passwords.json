{
    "link": "https://codeforces.com//contest/1263/problem/D",
    "problemId": "483580",
    "problem_idx": "D",
    "shortId": "1263D",
    "contest_number": "1263",
    "problem_submissions": {
        "F": [
            65982966,
            65978661,
            65982743,
            66004105,
            65981403,
            65982906,
            65984527,
            65967209,
            65985700,
            65987420,
            65990597,
            65985690,
            65988080,
            66082681,
            66082661,
            65991200,
            65988308,
            65990381,
            65990481,
            66004842,
            66004759,
            66004719,
            66004190,
            65989038,
            65986432,
            65987559
        ],
        "A": [
            65969521,
            65961098,
            65960714,
            65962476,
            65960820,
            65960894,
            65980138,
            65961073,
            65960873,
            65961438,
            65963263,
            65960772,
            65978824,
            65961157,
            65962102,
            65960839,
            65961853,
            65961109,
            65961702
        ],
        "E": [
            65968592,
            65970858,
            65970511,
            66002882,
            65966227,
            65975131,
            65974148,
            65975198,
            65975184,
            65976510,
            65977397,
            65977245,
            65977807,
            65973180,
            65969025,
            65981150,
            65979864,
            65980298,
            65982044,
            65990889,
            65982753
        ],
        "D": [
            65964312,
            65966149,
            65963758,
            65968928,
            65967814,
            65969772,
            65976755,
            65969893,
            65967529,
            65964864,
            65971947,
            65966055,
            65962087,
            65967297,
            65966037,
            65973690,
            65970452,
            65967218,
            65972623
        ],
        "C": [
            65962585,
            65964625,
            65962104,
            65977080,
            65966153,
            65965608,
            65964949,
            65977661,
            65966317,
            65964823,
            65965028,
            65969369,
            65963751,
            65963273,
            65964947,
            65961279,
            65968926,
            65968185,
            65964802,
            65969882
        ],
        "B": [
            65961580,
            65962530,
            65961425,
            65964286,
            65964464,
            65963229,
            65979595,
            65963832,
            65962737,
            65962077,
            65967269,
            65974357,
            65980348,
            65962893,
            65969125,
            65965548,
            65964171,
            65963429,
            65966476
        ]
    },
    "name": "D. Secret Passwords",
    "statement": "One unknown hacker wants to get the admin’s password of AtForces testing\r\nsystem, to get problems from the next contest. To achieve that, he\r\nsneaked into the administrator’s office and stole a piece of paper with\r\na list of n passwords strings, consists of small Latin letters.Hacker\r\nwent home and started preparing to hack AtForces. He found that the\r\nsystem contains only passwords from the stolen list and that the system\r\ndetermines the equivalence of the passwords a and b as follows: two\r\npasswords a and b are equivalent if there is a letter, that exists in\r\nboth a and b; two passwords a and b are equivalent if there is a\r\npassword c from the list, which is equivalent to both a and b. If a\r\npassword is set in the system and an equivalent one is applied to access\r\nthe system, then the user is accessed into the system.For example, if\r\nthe list contain passwords \"a\", \"b\", \"ab\", \"d\", then passwords \"a\", \"b\",\r\n\"ab\" are equivalent to each other, but the password \"d\" is not\r\nequivalent to any other password from list. In other words, if: admin’s\r\npassword is \"b\", then you can access to system by using any of this\r\npasswords: \"a\", \"b\", \"ab\"; admin’s password is \"d\", then you can access\r\nto system by using only \"d\". password from the list is the admin’s\r\npassword from the testing system. Help hacker to calculate the minimal\r\nnumber of passwords, required to access to the system. Keep in mind that\r\nthe hacker does not know which password is set in the system.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nstruct UF {\n  struct node_t { int parent, size; node_t() : size(1) {} };\n  vector<node_t> nodes;\n\n  UF() { }\n  UF(int size) : nodes(size) {\n    for (int i = 0; i < size; i++) {\n      nodes[i].parent = i;\n    }\n  }\n\n  int find(int index) {\n    int root = index;\n    while (root != nodes[root].parent) {\n      root = nodes[root].parent;\n    }\n    while (root != nodes[index].parent) {\n      int next = nodes[index].parent;\n      nodes[index].parent = root;\n      index = next;\n    }\n    return root;\n  }\n\n  bool merge(int first, int second) {\n    int r1 = find(first);\n    int r2 = find(second);\n    if (r1 == r2) return false;\n    if (nodes[r1].size < nodes[r2].size) swap(r1, r2);\n    nodes[r1].size += nodes[r2].size;\n    nodes[r2].parent = r1;\n    return true;\n  }\n};\n\n\nchar buff[1048576];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  UF uf(26);\n  set<int> used;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%s\", buff);\n    string d = buff;\n    sort(d.begin(), d.end());\n    d.resize(unique(d.begin(), d.end()) - d.begin());\n    for (auto a : d) {\n      used.insert(a - 'a');\n      for (auto b : d) {\n        uf.merge(a - 'a', b - 'a');\n      }\n    }\n  }\n  int ans = 0;\n  for (auto u : used) {\n    if (uf.find(u) == u) ans++;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Secret Passwords.json",
    "editorial_link": "https://codeforces.com/blog/entry/71844?locale=en",
    "editorial": "This problem can be solved in many ways (DSU, bipartite graph, and so\r\non). A solution using a bipartite graph will be described here.Consider\r\na bipartite graph with vertices corresponding to each letter of the\r\nLatin alphabet in the first set and vertices corresponding to each\r\npassword in the second set. Connect each password and the letters that\r\nare part of this password with an edge. From the definition of\r\nequivalence of passwords, it is easy to understand that the answer to\r\nthe problem is the number of connected components in this bipartite\r\ngraph.Total complexity: .\r\n",
    "hint": []
}