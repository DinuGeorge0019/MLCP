{
    "link": "https://codeforces.com//contest/1269/problem/B",
    "problemId": "500237",
    "problem_idx": "B",
    "shortId": "1269B",
    "contest_number": "1269",
    "problem_submissions": {
        "C": [
            67352706,
            67342506,
            67340660,
            67342809,
            67344956,
            67331477,
            67339107,
            67340486,
            67338149,
            67340091,
            67338156,
            67347782,
            67341549,
            67341600,
            67342294,
            67342344,
            67342829,
            67330241
        ],
        "E": [
            67349858,
            67364589,
            67368127,
            67360428,
            67362487,
            67407644,
            67361816,
            68037838
        ],
        "D": [
            67339478,
            67353948,
            67348917,
            67364550,
            67364311,
            67334215,
            67340431,
            67341741,
            67338198,
            67342873,
            67348426,
            67348708,
            67343994,
            67344243,
            67344039,
            67350135,
            67345192,
            67346296,
            67343602
        ],
        "B": [
            67337312,
            67377870,
            67335347,
            67345749,
            67336939,
            67340567,
            67339027,
            67334414,
            67335423,
            67344354,
            67335379,
            67396814,
            67341834,
            67332604,
            67337610,
            67338071,
            67337253,
            67332987,
            67335282,
            67336511,
            67345383
        ],
        "A": [
            67331771,
            67329729,
            67330308,
            67335502,
            67337021,
            67336156,
            67329958,
            67329769,
            67338898,
            67330168,
            67396807,
            67337525,
            67329686,
            67329755,
            67331194,
            67331352,
            67329912,
            67329806,
            67330184,
            67340611
        ]
    },
    "name": "B. Modulo Equality",
    "statement": "You are given a positive integer m and two integer sequence: a=[a_1,\r\na_2,\r\nldots, a_n] and b=[b_1, b_2,\r\nldots, b_n]. Both of these sequence have a length n.Permutation is a\r\nsequence of n different positive integers from 1 to n. For example,\r\nthese sequences are permutations: [1], [1,2], [2,1], [6,7,3,4,1,2,5].\r\nThese are not: [0], [1,1], [2,3].You need to find the non-negative\r\ninteger x, and increase all elements of a_i by x, modulo m (i.e. you\r\nwant to change a_i to (a_i + x)\r\nbmod m), so it would be possible to rearrange elements of a to make it\r\nequal b, among them you need to find the smallest possible x.In other\r\nwords, you need to find the smallest non-negative integer x, for which\r\nit is possible to find some permutation p=[p_1, p_2,\r\nldots, p_n], such that for all 1\r\nleq i\r\nleq n, (a_i + x)\r\nbmod m = b_{p_i}, where y\r\nbmod m remainder of division of y by m.For example, if m=3, a = [0, 0,\r\n2, 1], b = [2, 0, 1, 1], you can choose x=1, and a will be equal to [1,\r\n1, 0, 2] and you can rearrange it to make it equal [2, 0, 1, 1], which\r\nis equal to b.\r\n",
    "solutions": [
        "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define null nullptr\n#define _ <<' '<<\n#define endl '\\n'\n\nusing namespace std;\n\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N = 2e5 + 7;\nconst int M = 1e9 + 7;\n//const int M = 998244353;\nconst int FFTM = 998244353;\n\n\nconst int maxn = 2002;\nconst int inf = 1e9 + 66555;\nint a[maxn];\nint b[maxn];\nint c[maxn];\n\n\nint main()\n{\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif // LOCAL\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i)\n        cin >> a[i];\n    for(int i = 0; i < n; ++i)\n        cin >> b[i];\n    sort(b, b + n);\n    int ans = inf;\n    for(int i = 0; i < n; ++i)\n    {\n        int kek;\n        if (b[i] > a[0]) kek = b[i] - a[0];\n            else         kek = m - a[0] + b[i];\n        for(int j = 0; j < n; ++j)\n            c[j] = (a[j] + kek) % m;\n        sort(c, c + n);\n        bool f = true;\n        for(int j = 0; j < n && f; ++j)\n            if (b[j] != c[j]) f = false;\n        if (f) ans = min(ans, kek);\n    }\n    cout << ans % m;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Modulo Equality.json",
    "editorial_link": "https://codeforces.com//blog/entry/72358",
    "editorial": "There exists some , such that . Let\u00e2\u0080\u0099s enumerate it, then is . Like that\r\nyou can get candidates, each of them can be checked in with sort or in\r\nif you will note that the order is just cyclically shifting.Also, this\r\nproblem can be solved in with some string matching algorithms, I will\r\nleave it as a bonus.\r\n"
}