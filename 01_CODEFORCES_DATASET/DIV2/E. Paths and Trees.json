{
    "link": "https://codeforces.com//contest/545/problem/E",
    "problemId": "28038",
    "problem_idx": "E",
    "shortId": "545E",
    "contest_number": "545",
    "problem_submissions": {
        "E": [
            11152908,
            11157700,
            11157522,
            11156542,
            11161300,
            11156960,
            11158926,
            11159332,
            11158333,
            11161026,
            11158857,
            11159720,
            11174097,
            11173935,
            11160858,
            11161651,
            11159778,
            11161054,
            11160310,
            11161820,
            11163252
        ],
        "C": [
            11150440,
            11147958,
            11150824,
            11150276,
            11148970,
            11148884,
            11153300,
            11153422,
            11152117,
            11151008,
            11151654,
            11153299,
            11155654,
            11152365,
            11152087,
            11153750,
            11154873,
            11151525,
            11151659
        ],
        "D": [
            11148301,
            11149439,
            11148692,
            11151407,
            11150444,
            11147349,
            11150296,
            11170906,
            11151431,
            11154441,
            11153203,
            11155014,
            11154361,
            11150015,
            11154687,
            11154652,
            11154830,
            11154199,
            11153829,
            11150376
        ],
        "B": [
            11147493,
            11152440,
            11147604,
            11147721,
            11147256,
            11149962,
            11148762,
            11149882,
            11149290,
            11148961,
            11148519,
            11150280,
            11148361,
            11149006,
            11149406,
            11151773,
            11147710,
            11148107,
            11147713
        ],
        "A": [
            11146984,
            11151375,
            11147061,
            11147027,
            11146977,
            11151139,
            11147222,
            11147723,
            11147389,
            11147403,
            11160745,
            11149107,
            11147430,
            11147598,
            11148409,
            11148792,
            11148668,
            11147021,
            11147024
        ]
    },
    "name": "E. Paths and Trees",
    "statement": "Little girl Susie accidentally found her elder brother’s notebook. She\r\nhas many things to do, more important than solving problems, but she\r\nfound this problem too interesting, so she wanted to know its solution\r\nand decided to ask you about it. So, the problem statement is as\r\nfollows.Let’s assume that we are given a weighted undirected graph (here\r\nis the set of vertices, is the set of edges). The shortest-path tree\r\nfrom vertex is such graph that is a tree with the set of edges that is\r\nthe subset of the set of edges of the initial graph , and the lengths of\r\nthe shortest paths from to any vertex to and to are the same. You are\r\ngiven a weighted undirected graph and vertex . Your task is to find the\r\nshortest-path tree of the given graph from vertex , the total weight of\r\nwhose edges is minimum possible.\r\n",
    "solutions": [
        "//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1e6 + 9;\ntypedef long long ll;\nconst ll oo = 1e18;\nset<pair<ll,pair<ll,ll> > > st;\nll par[Maxn];\nll dis[Maxn],wei[Maxn],vis[Maxn],len[Maxn];\nvector<pair<ll,ll> > al[Maxn];\nll ans = 0;\nvoid relax(int v){\n\tvis[v] = 1;\n\tfor(int i = 0; i < al[v].size();i++){\n\t\tint u = al[v][i].first,id = al[v][i].second,w = len[id];\n\t\tif(vis[u]) continue;\n\t\tst.erase(make_pair(dis[u],make_pair(wei[u],u)));\n\t\tif(dis[u] > dis[v] + w || dis[u] == dis[v] + w && w < wei[u]){\n\t\t\tpar[u] = id;\n\t\t\twei[u] = w;\n\t\t\tdis[u] = dis[v] + w;\n\t\t}\n\t\tst.insert(make_pair(dis[u],make_pair(wei[u],u)));\n\t}\n\treturn;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tint n,m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n;i++) dis[i] = oo;\n\tfor(int i = 0; i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v >> len[i];\n\t\t--u,--v;\n\t\tal[u].push_back(make_pair(v,i));\n\t\tal[v].push_back(make_pair(u,i));\n\t}\n\tint source;\n\tcin >> source;\n\tsource--;\n\tpar[source] = Maxn;\n\tdis[source] = 0;\n\trelax(source);\n\twhile(st.size()){\n\t\tpair<ll,pair<ll,ll> > cur = *(st.begin());\n\t\tst.erase(cur);\n\t\tll v = cur.second.second,w = cur.second.first;\n\t\tif(vis[v]) continue;\n\t\trelax(v);\n\t\tans += w;\n\t}\n\tcout << ans << endl;\n\tfor(int i = 0; i < n;i++){\n\t\tif(i != source){\n\t\t\tcout << par[i] + 1 << ' ';\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Paths and Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/17982",
    "editorial": "Itâs true, that Dijkstra modification, where in case of equal distances\r\nwe take one with shorter last edge, find an answer. For prove that letâs\r\ndo some transformation with graph. At first, find all shortest paths\r\nfrom to other vertices. Define as the length of shortest path from to .\r\nAfter that, we can delete some edges. Specifically, we can delete an\r\nedge with ends in and and weight if , because it isnât contained in any\r\nshortest path, so it isnât contained in shortest path tree. After that,\r\nwe can direct all edges from vertices with less distance to vertices\r\nwith greater distance (because of all weight are positive). Itâs easy to\r\nprove, that if we take one edge that entering each vertex, we have a\r\nshortest path tree. Then we only need to take for each vertex minimal\r\negde, that entering this vertex. Why? Because we have to take at least\r\none edge, that entering each vertex to make a graph connected. We canât\r\ntake edges with less weights than minimal. And if we take minimal edges,\r\nthat entering each vertex we will have an shortest path tree. So that is\r\nminimal possible total wieght of shortest path tree. You can see, that\r\nDijkstra with modification do exactly the same things. Time complexity\r\n",
    "hint": []
}