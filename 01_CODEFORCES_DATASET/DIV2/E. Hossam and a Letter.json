{
    "link": "https://codeforces.com//contest/1771/problem/E",
    "problemId": "1688881",
    "problem_idx": "E",
    "shortId": "1771E",
    "contest_number": "1771",
    "problem_submissions": {
        "E": [
            184786252,
            184768319,
            184791269,
            184791695,
            184799239,
            184789827,
            184804872,
            184797015,
            184779796,
            184780579,
            184774488,
            184784737,
            184789324,
            184905669
        ],
        "F": [
            184767458,
            184789428,
            184776697,
            184780762,
            184768498,
            184799203,
            184750590,
            184788854,
            184819486,
            184733731,
            184782224,
            184765553,
            184837754,
            184787637,
            184786087,
            184781451,
            186375922,
            184885288,
            184793012
        ],
        "D": [
            184754420,
            184746285,
            184751879,
            184767199,
            184796187,
            184770689,
            184788363,
            184741723,
            184762124,
            184781810,
            184734475,
            184771306,
            184784877,
            184767214,
            184757752,
            184754682,
            184762986,
            184732202,
            184885253,
            184786038
        ],
        "C": [
            184742304,
            184730753,
            184731670,
            184750562,
            184746404,
            184744176,
            184732056,
            186784755,
            186783506,
            185248092,
            184831291,
            184725362,
            184737633,
            184749397,
            184807012,
            184806808,
            184806589,
            184806495,
            184750795,
            184733621,
            184739758,
            184731026,
            184753323,
            184736577,
            184746147,
            184753799,
            184885221,
            184836201,
            184744786,
            184740528
        ],
        "B": [
            184723301,
            184725456,
            184722508,
            184735259,
            184724915,
            184727876,
            184722523,
            184720717,
            184727802,
            184728402,
            184761586,
            184727553,
            184722898,
            184733183,
            184726202,
            184743742,
            184729968,
            184744730,
            184885179,
            184732333
        ],
        "A": [
            184718639,
            184717667,
            184718126,
            184729979,
            184719322,
            184720803,
            184717674,
            184717800,
            184721090,
            184719864,
            184753140,
            184718839,
            184717731,
            184725439,
            184718841,
            184718297,
            184718595,
            184738977,
            184885137,
            184718315
        ]
    },
    "name": "E. Hossam and a Letter",
    "statement": "Hossam bought a new piece of ground with length n and width m, he\r\ndivided it into an n\r\ncdot m grid, each cell being of size 1\r\ntimes1.Since Hossam’s name starts with the letter ”, he decided to draw\r\nthe capital letter ” by building walls of size 1\r\ntimes1 on some squares of the ground. Each square 1\r\ntimes1 on the ground is assigned a quality degree: perfect, medium, or\r\nbad.The process of building walls to form up letter ” has the following\r\nconstraints: The letter must consist of one horizontal and two vertical\r\nlines. The vertical lines must not be in the same or neighboring\r\ncolumns. The vertical lines must start in the same row and end in the\r\nsame row (and thus have the same length). The horizontal line should\r\nconnect the vertical lines, but must not cross them. The horizontal line\r\ncan be in any row between the vertical lines (not only in the middle),\r\nexcept the top and the bottom one. (With the horizontal line in the top\r\nrow the letter looks like ”, and in the bottom row like ”.) It is\r\nforbidden to build walls in cells of bad quality. You can use at most\r\none square of medium quality. You can use any number of squares of\r\nperfect quality. Find the maximum number of walls that can be used to\r\ndraw the letter ”.Check the note for more clarification.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\n\n// вправо, вниз, влево, вверх\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\n// ход конем\n//int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n//int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::system_clock::now().time_since_epoch().count());\nint rndInteger (int l, int r) {\n    return uniform_int_distribution<int> (l, r)(rnd);\n}\n\nconst int MOD = (int) 998244353;\nconst int N = (int) 404;\n\nint n, m;\nstring s[404];\nint pref[3][404][404];\n\nint whattp(char ch) {\n    if(ch == '.') return 0;\n    if(ch == 'm') return 1;\n    return 2;\n}\nint withM[404][N], withoutM[404][N];\nint withHor[404][404];\nint withoutHor[404][404];\n\nint get(int tp, int ax, int ay, int bx, int by) {\n    --ax, --ay;\n    return pref[tp][bx][by] + pref[tp][ax][ay] - pref[tp][ax][by] - pref[tp][bx][ay];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        cin >> s[i];\n        s[i] = '#' + s[i];\n    }\n\n\n    for (int tp = 0; tp < 3; ++tp) {\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                pref[tp][i][j] -= pref[tp][i-1][j-1];\n                pref[tp][i][j] += pref[tp][i-1][j];\n                pref[tp][i][j] += pref[tp][i][j-1];\n                if(tp == whattp(s[i][j])) {\n                    pref[tp][i][j]++;\n                }\n            }\n        }\n    }\n\n    for (int j = 1; j <= m; ++j) {\n        int last = 0;\n        for (int i = 1; i <= n; ++i) {\n            withM[i][j] = withM[i-1][j];\n            withoutM[i][j] = withoutM[i-1][j];\n\n            if(s[i][j] == '#') {\n                withM[i][j] = withoutM[i][j] = i;\n            }\n            if(s[i][j] == 'm') {\n                withoutM[i][j] = i;\n                withM[i][j] = max(withM[i][j], last);\n                last = i;\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 1; i < m - 1; ++i) {\n        for (int j = i + 2; j <= m; ++j) {\n            for (int bottom = 1; bottom <= n; ++bottom) {\n\n                if(s[bottom][i] == '#')\n                    continue;\n                if(s[bottom][j] == '#')\n                    continue;\n\n                //max i does not have m, j has\n                {\n                    int len = bottom - max(withoutM[bottom][i], withM[bottom][j]);\n                    if(len >= 3 && withoutHor[i][j] > bottom - len + 1) {\n                        ans = max(ans, len * 2 + (j - i - 1));\n                    }\n                }\n                //max i have, j does not\n                {\n                    int len = bottom - max(withM[bottom][i], withoutM[bottom][j]);\n                    if(len >= 3 && withoutHor[i][j] > bottom - len + 1) {\n                        ans = max(ans, len * 2 + (j - i - 1));\n                    }\n                }\n                //i does not, j does not\n                {\n                    int len = bottom - max(withoutM[bottom][i], withoutM[bottom][j]);\n                    if(len >= 3 && withHor[i][j] > bottom - len + 1) {\n                        ans = max(ans, len * 2 + (j - i - 1));\n                    }\n                }\n\n                if(get(2, bottom, i + 1, bottom, j - 1) > 0)\n                    continue;\n                if(get(1, bottom, i + 1, bottom, j - 1) > 1)\n                    continue;\n                if(get(1, bottom, i + 1, bottom, j - 1) == 1) {\n                    withHor[i][j] = bottom;\n                    continue;\n                }\n                withHor[i][j] = bottom;\n                withoutHor[i][j] = bottom;\n                \n            }\n        }\n\n    }\n\n    cout << ans << '\\n';\n    \n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Hossam and a Letter.json",
    "editorial_link": "https://codeforces.com//blog/entry/110092",
    "editorial": "Letâs preprocess the following data for each cell.1. first medium cell\r\nabove current cell. 2. first medium cell below current cell. 3. first\r\nbad cell above current cell. 4. first bad cell below current cell.Then\r\nwe will try to solve the problem for each row (i), and 2 columns (j,\r\nk).Now we have a horizontal line in row (i), and we can calculate the\r\nlength of vertical line by the following.There is two cases:In case of\r\nthe horizontal line contains one letter âmâ.For each column (j, k): get\r\nfirst cell above it the donât contain (â or âmâ) and first cell below it\r\nthe donât contain (â or âmâ).In case of the horizontal line doesnât\r\ncontain any letter âmâ.We will try to get the 4 cells as it contains\r\nletter âmâ, but in this case we will 4 trials.for each cell from the 4\r\ncells, we allow to have only one letter âmâ in that line.After getting\r\nabove cells and below cells for each line. the starting cell will be the\r\nmaximum between the two above cells, and the ending cell will be the\r\nminimum between the two below cells.Then we need to check that starting\r\ncell is above the current row (i) to avoid making letter n instead of\r\nHAnd check that ending cell is below the current row (i) to avoid making\r\nletter u instead of H.Since n, m has the same maximum limit 400.Thus,\r\ntime complexity of this solution is .\r\n",
    "hint": []
}