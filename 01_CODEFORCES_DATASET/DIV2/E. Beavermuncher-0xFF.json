{"link": "https://codeforces.com//contest/80/problem/E", "problemId": "411", "problem_idx": "E", "shortId": "80E", "contest_number": "80", "problem_submissions": {"A": [400330, 396561, 396857, 396868, 396610, 396863, 396563, 396888, 397022, 396609, 396782, 396721, 397150, 396677, 396694, 396628, 397115], "B": [400207, 397113, 397221, 397095, 397648, 397040, 397256, 397444, 397310, 397223, 397296, 397841, 397506, 397517, 397933, 397899], "D": [399811, 399415, 399956, 399686, 399529, 399358, 401367, 400092, 399827, 398351, 399049, 399724, 401126, 400821, 400699, 401563, 399710, 399835], "C": [399554, 398434, 398586, 398825, 398638, 400656, 398445, 399359, 398959, 400347, 401515, 397797, 400156, 399555, 399352, 398755, 400890, 400728], "E": [398138, 401335, 401560, 401577, 403016, 401611, 402380, 403062]}, "name": "E. Beavermuncher-0xFF", "statement": "You are given a tree, completely occupied by beavers. A tree is a\r\nconnected undirected graph without cycles. The tree consists of\r\nvertices, the -th vertex contains beavers. \"Beavermuncher-0xFF\" works by\r\nthe following principle: being at some vertex , it can go to the vertex\r\n, if they are connected by an edge, and eat beaver located at the vertex\r\n. It is impossible to move to the vertex if there are no beavers left in\r\n. \"Beavermuncher-0xFF\" just stand at some vertex and eat beavers in it.\r\n\"Beavermuncher-0xFF\" must move without stops.Why does the\r\n\"Beavermuncher-0xFF\" works like this? Because the developers have not\r\nprovided place for the battery in it and eating beavers is necessary for\r\nconverting their mass into pure energy.It is guaranteed that the beavers\r\nwill be shocked by what is happening, which is why they will not be able\r\nto move from a vertex of the tree to another one. As for the\r\n\"Beavermuncher-0xFF\", it can move along each edge in both directions\r\nwhile conditions described above are fulfilled.The root of the tree is\r\nlocated at the vertex . This means that the \"Beavermuncher-0xFF\" begins\r\nits mission at the vertex and it must return there at the end of\r\nexperiment, because no one is going to take it down from a high place.\r\nDetermine the maximum number of beavers \"Beavermuncher-0xFF\" can eat and\r\nreturn to the starting vertex.\r\n", "solutions": ["#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 1000000000\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (c).size()\ntypedef pair<long long, long long> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\ntypedef vector<VI> VVI;\n\nVI a;\nVVI e;\nVI u;\n\nPII go (int x)\n{\n\tif (u[x] || !a[x])\n\t\treturn PII();\n\tu[x] = 1;\n\n\tVPII b;\n\tREP (i, e[x].size ())\n\t{\n\t\tb.pb (go(e[x][i]));\n\t\tif (b.back() == PII())\n\t\t\tb.pop_back();\n\t}\n\n\tPII res;\n\tres.X ++;\n\ta[x]--;\n\n\tSORT(b);\n\tREVERSE(b);\n\n\tREP (i, b.size())\n\t{\n\t\tif (a[x])\n\t\t{\n\t\t\tres.X += b[i].X + 1;\n\t\t\ta[x]--;\n\t\t}\n\t}\n\n\tREP (i, b.size())\n\t{\n\t\tint v = min(a[x], (int)b[i].Y);\n\t\tres.X += v*2;\n\t\ta[x] -= v;\n\t}\n\n\tres.Y = a[x];\n\n\t//cout << x << \" \" << b.size()<< \" \" << res.X << \" \" << res.Y << endl;\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w+\", stdout);\n\n\tint n;\n\tscanf (\"%d\", &n);\n\n\ta.resize(n);\n\te.resize(n);\n\tu.resize(n);\n\n\tREP (i, n)\n\t\tscanf (\"%d\", &a[i]);\n\n\tint x, y;\n\tREP (i, n-1)\n\t{\n\t\tscanf (\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\te[x].pb (y);\n\t\te[y].pb (x);\n\t}\n\n\tint s;\n\tscanf (\"%d\", &s);\n\ts--;\n\n\ta[s]++;\n\n\tPII res = go(s);\n\n\tcout << res.X - 1 << endl;\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2100", "interactive": false}