{
    "link": "https://codeforces.com//contest/1944/problem/C",
    "problemId": "2535051",
    "problem_idx": "C",
    "shortId": "1944C",
    "contest_number": "1944",
    "problem_submissions": {
        "E": [
            251782515,
            251752198,
            251760134,
            251765767,
            251780123,
            251755818,
            251785307,
            251786773,
            251774041,
            251782215,
            251788365,
            251768261,
            251786805,
            251786877
        ],
        "D": [
            251774395,
            251745809,
            251734994,
            251735975,
            251741617,
            251753993,
            251816452,
            251754858,
            251782010,
            251751610,
            251760683,
            251760131,
            251771429,
            251757991,
            251756622,
            251757761,
            251764901,
            251792696,
            251771886,
            251771626
        ],
        "F2": [
            251750838,
            251716813,
            251789175,
            252177387
        ],
        "F1": [
            251747784,
            251709303,
            251789140,
            251765369,
            252064569,
            251778632,
            251783727,
            251776370,
            252190323,
            251778029,
            251787478
        ],
        "C": [
            251727192,
            251748340,
            251720353,
            251717607,
            251744834,
            251719448,
            251721344,
            251728728,
            251723190,
            251722648,
            251720271,
            251715992,
            251711499,
            251727997,
            251722342,
            251754221,
            251727857,
            251727380,
            251734830,
            251734204
        ],
        "B": [
            251714769,
            251743002,
            251717270,
            251713265,
            251751112,
            251715501,
            251712246,
            251715265,
            251717723,
            251714892,
            251714867,
            251712443,
            251720698,
            251717033,
            251737965,
            251714389,
            251717278,
            251719138,
            251727691,
            251724161
        ],
        "A": [
            251705704,
            251744128,
            251703581,
            251703048,
            251747005,
            251704719,
            251705040,
            251701932,
            251706171,
            251701886,
            251705757,
            251701530,
            251704051,
            251712020,
            251711838,
            251705512,
            251702145,
            251704041,
            251711450,
            251703284
        ]
    },
    "name": "C. MEX Game 1",
    "statement": "Alice and Bob play yet another game on an array a of size n. Alice\r\nstarts with an empty array c. Both players take turns playing, with\r\nAlice starting first.On Alice\u2019s turn, she picks one element from a,\r\nappends that element to c, and then deletes it from a.On Bob\u2019s turn, he\r\npicks one element from a, and then deletes it from a. The game ends when\r\nthe array a is empty. Game\u2019s score is defined to be the MEX^\r\ndagger of c. Alice wants to maximize the score while Bob wants to\r\nminimize it. Find game\u2019s final score if both players play optimally.^\r\ndagger The\r\noperatorname{MEX} (minimum excludant) of an array of integers is defined\r\nas the smallest non-negative integer which does not occur in the array.\r\nFor example: The MEX of [2,2,1] is 0, because 0 does not belong to the\r\narray. The MEX of [3,1,0,1] is 2, because 0 and 1 belong to the array,\r\nbut 2 does not. The MEX of [0,3,1,2] is 4, because 0, 1, 2 and 3 belong\r\nto the array, but 4 does not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i=l,i##_e=r;i<=i##_e;++i)\n#define rFor(i,r,l) for(int i=r,i##_e=l;i>=i##_e;--i)\n#define y0 y_zero\n#define y1 y_one\n#define all(a) a.begin(),a.end()\nusing namespace std;\nusing u32=unsigned;\nusing i64=long long;\nusing ll=long long;\nusing u64=unsigned long long;\nusing ull=unsigned long long;\n#if __SIZEOF_POINTER__==8\nusing i128=__int128;\nusing u128=__uint128_t;\n#endif\nusing pii=array<int,2>;\nusing pll=array<ll,2>;\nvoid cmin(auto &a,auto b){a=min(a,b);}\nvoid cmax(auto &a,auto b){a=max(a,b);}\n#define mtc() int T; cin>>T; while(T--) work();\n\n#define with_buffer\n\n#if defined(with_buffer) && defined(EOF) && __cplusplus>=201103L\n\nclass in_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *p2=buf;\n\tFILE *in;\n   public:\n\tin_buffer_t():in(nullptr){}\n\tin_buffer_t(FILE *in):in(in){}\n\tchar getc() {\n\t\tif(p1!=p2 || (p2=buf+fread(p1=buf,1,len,in))!=p1) return *(p1++);\n\t\treturn EOF;\n\t}\n};\nclass out_buffer_t {\n\tstatic constexpr int len=1<<16;\n\tchar buf[len],*p1=buf; const char *const p2=buf+len;\n\tFILE *out;\n   public:\n\tout_buffer_t():out(nullptr){}\n\tout_buffer_t(FILE *out):out(out){}\n\tvoid putc(char x) {\n\t\tif(p1!=p2) { *(p1++)=x; return; }\n\t\tfwrite(p1=buf,len,1,out),*(p1++)=x;\n\t}\n\t~out_buffer_t() { fwrite(buf,p1-buf,1,out); }\n};\nin_buffer_t stdin_buf(stdin);\nout_buffer_t stdout_buf(stdout);\n\n#define istream my_istream\n#define ostream my_ostream\n#define cin my_cin\n#define cout my_cout\nclass istream {\n\tin_buffer_t *const in;\n\ttemplate<class T> void read_uint(T &x)const{\n\t\tchar c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) c=in->getc();\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t}\n\ttemplate<class T> void read_sint(T &x)const{\n\t\tchar m=0,c=0; x=0;\n\t\tfor(;~c && !isdigit(c);) m|=(c=in->getc())==45;\n\t\tif(!~c) return;\n\t\tfor(;isdigit(c);c=in->getc()) x=x*10+(c&15);\n\t\tif(m) x=-x;\n\t}\n   public:\n\tistream():in(nullptr){}\n\tistream(in_buffer_t *const in):in(in){}\n#define doit(T,F)\\\n\tfriend istream operator>>(const istream in,T &x) {\\\n\t\tin.F(x); return in;\\\n\t}\n\tdoit(unsigned,read_uint)\n\tdoit(int,read_sint)\n\tdoit(unsigned long,read_uint)\n\tdoit(long,read_sint)\n\tdoit(unsigned long long,read_uint)\n\tdoit(long long,read_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,read_uint)\n\tdoit(__int128,read_sint)\n#endif\n#undef doit\n\tchar get()const{return in->getc();}\n\tfriend istream operator>>(const istream in,char &x) {\n\t\tfor(x=32;isspace(x);x=in.in->getc()); return in;\n\t}\n\tfriend istream operator>>(const istream in,char *s) {\n\t\tchar c=32;\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) *(s++)=c; *s=0;\n\t\treturn in;\n\t}\n\tfriend istream operator>>(const istream in,string &s) {\n\t\tchar c=32; s.clear();\n\t\tfor(;isspace(c);c=in.in->getc());\n\t\tfor(;~c && !isspace(c);c=in.in->getc()) s.push_back(c);\n\t\treturn in;\n\t}\n\tistream getline(char *s) {\n\t\tfor(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) *(s++)=c; *s=0;\n\t\treturn *this;\n\t}\n\tistream getline(string &s) {\n\t\ts.clear(); for(char c=in->getc();~c && c!=10 && c!=13;c=in->getc()) s.push_back(c);\n\t\treturn *this;\n\t}\n};\nclass ostream {\n\tout_buffer_t *const out;\n\ttemplate<class T> void write_uint(const T x)const{\n\t\tif(x>9) write_uint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n\ttemplate<class T> void write_sint(T x)const{\n\t\tif(x<0) out->putc(45),x=-x;\n\t\tif(x>9) write_sint(x/10);\n\t\tout->putc((x%10)|48);\n\t}\n   public:\n\tostream():out(nullptr){}\n\tostream(out_buffer_t *const out):out(out){}\n#define doit(T,F)\\\n\tfriend ostream operator<<(const ostream out,const T x) {\\\n\t\tout.F(x); return out;\\\n\t}\n\tdoit(unsigned,write_uint)\n\tdoit(int,write_sint)\n\tdoit(unsigned long,write_uint)\n\tdoit(long,write_sint)\n\tdoit(unsigned long long,write_uint)\n\tdoit(long long,write_sint)\n#if __SIZEOF_POINTER__==8\n\tdoit(__uint128_t,write_uint)\n\tdoit(__int128,write_sint)\n#endif\n#undef doit\n\tvoid put(const char c)const{out->putc(c);}\n\tfriend ostream operator<<(const ostream out,const char x) {\n\t\tout.out->putc(x); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const char *s) {\n\t\tfor(;*s;) out.out->putc(*(s++)); return out;\n\t}\n\tfriend ostream operator<<(const ostream out,const string s) {\n\t\tfor(auto x:s) out.out->putc(x); return out;\n\t}\n};\nistream cin(&stdin_buf);\nostream cout(&stdout_buf);\n#define endl '\\n'\n#endif\n#ifndef LOCAL\nstruct empty_cerr_t {\n\tempty_cerr_t& operator<<(auto x) {\n\t\treturn *this;\n\t}\n}empty_cerr;\n#define cerr empty_cerr\n#endif\nconst int N=2e5+10;\nint n,a[N],c[N];\nbool check(int x) {\n\tstatic int b[N];\n\tFor(i,0,x) b[i]=c[i];\n\tsort(b,b+x+1);\n\tif(!b[0]) return 0;\n\tif(b[1]==1) return 0;\n\treturn 1;\n}\nvoid work() {\n\tcin>>n;\n\tFor(i,0,n) c[i]=0;\n\tFor(i,1,n) cin>>a[i],c[a[i]]++;\n\tif(!c[0]) return cout<<0<<endl,void();\n\tint l=0,r=n;\n\twhile(l+1<r) {\n\t\tint m=l+r>>1;\n\t\tif(check(m)) l=m;\n\t\telse r=m;\n\t}\n\tcout<<r<<endl;\n}\nint main() {\n#ifdef LOCAL\n\tfreopen(\".in\",\"r\",stdin);\n\t// freopen(\".out\",\"w\",stdout);\n\t// freopen(\".debug\",\"w\",stderr);\n#endif\n#ifndef with_buffer\n\tios::sync_with_stdio(0); cin.tie(0);\n#endif\n\tmtc();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. MEX Game 1.json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "For any i\n s.t. fi?2\n, whenever Bob chooses to remove an occurence of i\n, on the next move Alice simply chooses i\n herself (if she hasn't already taken i\n before that). Thus, we only focus on fi?1\n now.\n\nThe answer is min(first i\n s.t. f(i)=0\n, second i\n s.t. f(i)=1\n).\n\nObviously, Alice can't do better than the mex of array (first i\n s.t. f(i)=0\n). Further, among f(i)=1\n, Alice can save atmost 1\n i\n after which Bob will remove the smallest f(i)=1\n he can find. This is optimal for Bob as well because he cannot do better when Alice removes the (first i\n s.t. f(i)=1\n) on her first move."
}