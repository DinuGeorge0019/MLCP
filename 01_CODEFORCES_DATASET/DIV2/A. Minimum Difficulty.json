{
    "link": "https://codeforces.com//contest/496/problem/A",
    "problemId": "19576",
    "problem_idx": "A",
    "shortId": "496A",
    "contest_number": "496",
    "problem_submissions": {
        "D": [
            9176843,
            9169490,
            9172648,
            9169938,
            9173192,
            9179837,
            9174502,
            9174977,
            9172607,
            9170640,
            9175019,
            9174412,
            9173755,
            9175240,
            9175102,
            9175021,
            9194689,
            9175370
        ],
        "E": [
            9173226,
            9193133,
            9174734,
            14339417,
            9237849,
            9178765,
            9188533,
            9194680
        ],
        "C": [
            9169367,
            9166605,
            9167404,
            9165048,
            9168057,
            9167727,
            9166806,
            9167081,
            9169029,
            9167067,
            9167500,
            9168857,
            9168096,
            9168403,
            9167842,
            9167765,
            9194690,
            9167905
        ],
        "B": [
            9165977,
            9165371,
            9165516,
            9171586,
            9164457,
            9164520,
            9165537,
            9165229,
            9167890,
            9173609,
            9166677,
            9165999,
            9166755,
            9166602,
            9165952,
            9165871,
            9194688,
            9168604
        ],
        "A": [
            9164610,
            9164035,
            9164187,
            9170696,
            9163931,
            9163962,
            9163896,
            9164249,
            9166611,
            9174109,
            9164186,
            9164233,
            9164281,
            9163978,
            9164264,
            9163934,
            9194687,
            9165603
        ]
    },
    "name": "A. Minimum Difficulty",
    "statement": "Mike is trying rock climbing but he is awful at it. There are holds on\r\nthe wall, -th hold is at height off the ground. Besides, let the\r\nsequence increase, that is, for all from 1 to ; we will call such\r\nsequence a . Mike thinks that the track , ..., has . In other words,\r\ndifficulty equals the maximum distance between two holds that are\r\nadjacent in height.Today Mike decided to cover the track with holds\r\nhanging on heights , ..., . To make the problem harder, Mike decided to\r\nremove one hold, that is, remove one element of the sequence (for\r\nexample, if we take the sequence and remove the third element from it,\r\nwe obtain the sequence ). However, as Mike is awful at climbing, he\r\nwants the final difficulty (i.e. the maximum difference of heights\r\nbetween adjacent holds after removing the hold) to be as small as\r\npossible among all possible options of removing a hold. The first and\r\nlast holds stay at their positions.Help Mike determine the minimum\r\ndifficulty of the track after removing one hold.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nint dis[2000];\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"a.txt\", \"w\", stdout);\n    int n, t, t1, mx = 0;\n    cin >> n;\n    memset(dis, 0, sizeof dis);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> t;\n        if (i>0)    dis[i] = t - t1;\n        if (dis[i] > mx)mx = dis[i];\n        t1 = t;\n    }\n    int mx2 = inf,lo;\n    for (int i = 1; i < n-1; i++)\n    {\n        if (dis[i] + dis[i + 1] < mx2)\n        {\n            mx2 = dis[i] + dis[i + 1];\n            lo = i;\n        }\n    }\n    if (mx2 < mx)cout << mx << endl;\n    else cout << mx2 << endl;\n    //system(\"pause\");\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Minimum Difficulty.json",
    "editorial_link": "https://codeforces.com//blog/entry/15208",
    "editorial": "For every option of removing an element we run through the remaining\r\nelements and find the maximal difference between adjacent ones; print\r\nthe smallest found answer. The solution has complexity . It can be\r\nnoticed that after removing an element the difficulty either stays the\r\nsame or becomes equal to the difference between the neighbours of the\r\nremoved element (whatever is larger); thus, the difficulty for every\r\noption of removing an element can be found in , for the total complexity\r\nof . Any of these solutions (or even less efficient ones) could pass the\r\ntests. Challenge: suppose we now have to remove exactly arbitrary\r\nelements (but the first and the last elements have to stay in their\r\nplaces). How small the maximal difference between adjacent elements can\r\nbecome? Solve this problem assuming the limitations are as follows: , ,\r\n.\r\n",
    "hint": []
}