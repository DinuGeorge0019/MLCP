{
    "link": "https://codeforces.com//contest/1789/problem/D",
    "problemId": "1798640",
    "problem_idx": "D",
    "shortId": "1789D",
    "contest_number": "1789",
    "problem_submissions": {
        "F": [
            194969357,
            195749340,
            195084999,
            195084860,
            195102578,
            194979229,
            194979047,
            194978962,
            194975838,
            194975550,
            194975302,
            194975124,
            194974900,
            194974650,
            194974382
        ],
        "D": [
            194964382,
            194946537,
            194952763,
            194935429,
            194953178,
            194957319,
            194960327,
            194955667,
            194955471,
            194960858,
            194960296,
            194949046,
            194949101,
            194950239,
            194953216,
            194952742,
            194952699,
            194953612
        ],
        "E": [
            194946702,
            194955457,
            194962685,
            194950894,
            194964730,
            194965836,
            229633905,
            194969144,
            194969007,
            194970553,
            194969010,
            194970681,
            194953500,
            194973828,
            198576217,
            194953882
        ],
        "C": [
            194930840,
            194935056,
            194937930,
            194962744,
            194937423,
            194944977,
            194941284,
            194940844,
            194947791,
            194945071,
            194938899,
            194933727,
            194937235,
            194936393,
            194947382,
            194937385,
            194938714,
            194934789,
            194942194,
            194939314
        ],
        "B": [
            194927201,
            194928996,
            194933855,
            194950809,
            194928726,
            194933032,
            194930991,
            194927953,
            194937472,
            194934025,
            194928695,
            194928070,
            194927782,
            194930745,
            194932397,
            194929156,
            194930083,
            194929116,
            194929527,
            194930695
        ],
        "A": [
            194926083,
            194926207,
            194930860,
            194952002,
            194926224,
            194926968,
            194926650,
            194926242,
            194934078,
            194927544,
            194926614,
            194926667,
            194926050,
            194926065,
            194927300,
            194926584,
            194927455,
            194927037,
            194926659,
            194927083
        ]
    },
    "name": "D. Serval and Shift-Shift-Shift",
    "statement": "Serval has two n-bit binary integer numbers a and b. He wants to share\r\nthose numbers with Toxel.Since Toxel likes the number b more, Serval\r\ndecides to change a into b by some (possibly zero) operations. In an\r\noperation, Serval can choose any integer k between 1 and n, and change a\r\ninto one of the following number: a\r\noplus(a\r\nll k) a\r\noplus(a\r\ngg k) In other words, the operation moves every bit of a left or right\r\nby k positions, where the overflowed bits are removed, and the missing\r\nbits are padded with 0. The bitwise XOR of the shift result and the\r\noriginal a is assigned back to a.Serval does not have much time. He\r\nwants to perform n operations to change a into b. Please help him to\r\nfind out an operation sequence, or determine that it is impossible to\r\nchange a into b in at most n operations. You do to minimize the number\r\nof operations. In this problem, x\r\noplus y denotes the bitwise XOR operation of x and y. a\r\nll k and a\r\ngg k denote the logical left shift and logical right shift.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string a, b;\n    cin >> a >> b;\n    if (a == b) {\n        cout << \"0\\n\";\n        return;\n    }\n    if (a == string(n, '0') || b == string(n, '0')) {\n        cout << \"-1\\n\";\n        return;\n    }\n    vector<int> ans;\n    auto Op = [&](int k) {\n        if (k > 0) {\n            for (int i = 0; i + k < n; ++i) {\n                a[i] ^= a[i + k] ^ '0';\n            }\n        } else {\n            for (int i = n - 1; i + k >= 0; --i) {\n                a[i] ^= a[i + k] ^ '0';\n            }\n        }\n        ans.push_back(k);\n    };\n    for (int i = 0; i < n; ++i) {\n        if (a[i] == b[i]) continue;\n        int bit = 0;\n        while (bit < n && a[bit] == '0') bit++;\n        if (i == bit) continue;\n        assert(bit != n);\n        Op(bit - i);\n        assert(a[i] == b[i]);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] == b[i]) continue;\n        int bit = n - 1;\n        while (bit >= 0 && a[bit] == '0') bit--;\n        assert(i != bit);\n        Op(bit - i);\n        assert(a[i] == b[i]);\n    }\n    int diff = 0;\n    for (int i = 0; i < n; ++i) diff += (a[i] != b[i]);\n    assert(diff == 0);\n    cout << ans.size() << '\\n';\n    for (auto &x: ans) cout << x << ' ';\n    cout << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Serval and Shift-Shift-Shift.json",
    "editorial_link": "https://codeforces.com//blog/entry/113246",
    "editorial": "First of all, it could be proven that\nthe answer exists if and only if and are both zero or and are both\nnon-zero.If is zero, it remains zero after any operations. Therefore it\ncannot become if is non-zero. If is non-zero, logical left shift it will\ndefinitely increase its lowest bit or make it zero, thus changing it\ninto a different number. The same applies to logical right shift.\nTherefore, the xor result must be non-zero and there are no possible\noperations if is zero.We will show that it is always possible to change\ninto in the other cases. We denote as the lowest bit of and as the\nhighest bit of . If and are both zero, no operations are needed. If they\nare both non-zero, the construction consists of four steps: If , logical\nleft shift by bits. Then must be equal or greater than . For each bit of\n, if , we may logical right shift by bits to erase it. After that, we\nhave . If , logical right shift by bits. Now it is guaranteed that . For\neach bit of , if , we may logical left shift by bits to erase it. After\nthat, we must have . Step 2 and step 4 require at most operations. We\nmay also note that step 1 and step 3 never appear simultaneously. If\nstep 1 is operated, then is guaranteed after step 2. Thus, we need not\noperate step 3 in this case. In conclusion, we may use no more than\noperations to change into if they are both non-zero.Time Complexity: or\nby using std::bitset.\n",
    "hint": []
}