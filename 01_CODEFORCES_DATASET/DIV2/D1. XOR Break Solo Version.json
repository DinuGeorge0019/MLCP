{
    "link": "https://codeforces.com//contest/1934/problem/D1",
    "problemId": "2505362",
    "problem_idx": "D1",
    "shortId": "1934D1",
    "contest_number": "1934",
    "problem_submissions": {
        "D2": [
            249138861,
            249138286,
            249148347,
            249142453,
            249157574,
            249154795,
            249156400,
            249152916,
            249153265,
            249152468,
            249159235,
            249151373,
            249157739,
            249158790,
            249158719,
            249157715,
            249151531,
            249154568
        ],
        "D1": [
            249125699,
            249128677,
            249134651,
            249133932,
            249131438,
            249132804,
            249141726,
            249142358,
            249133864,
            249137039,
            249209635,
            249137420,
            249137703,
            249134521,
            249138551,
            249144781,
            249136421,
            249139126,
            249137860
        ],
        "C": [
            249115447,
            249119119,
            249121601,
            249125691,
            249121785,
            249119998,
            249118653,
            249123649,
            249122623,
            249127946,
            249126111,
            249128427,
            249128773,
            249122463,
            249117989,
            249122384,
            249127040,
            249126459
        ],
        "B": [
            249103913,
            249106551,
            249108288,
            249115212,
            249104799,
            249109733,
            249104490,
            249108744,
            249111760,
            249108303,
            249108953,
            249111319,
            249106725,
            249111924,
            249107412,
            249112945,
            249107802,
            249115127
        ],
        "A": [
            249100199,
            249101211,
            249103188,
            249100104,
            249099925,
            249108944,
            249100108,
            249104411,
            249104537,
            249100853,
            249102757,
            249099965,
            249100710,
            249100333,
            249102042,
            249101590,
            249101009,
            249100585
        ],
        "E": [
            249308601
        ]
    },
    "name": "D1. XOR Break \u2014 Solo Version",
    "statement": "Given an integer variable x with the initial value of n. A single break\r\noperation consists of the following steps: Choose a value y such that 0\r\nlt y\r\nlt x and 0\r\nlt (x\r\noplus y)\r\nlt x. Update x by either setting x = y or setting x = x\r\noplus y. Determine whether it is possible to transform x into m using a\r\nmaximum of 63 break operations. If it is, provide the sequence of\r\noperations required to achieve x = m.You don\u2019t need to minimize the\r\nnumber of operations.Here\r\noplus denotes the bitwise XOR operation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    IOS;\n\n    int T; cin >> T;\n    while(T--){\n        int n, m; cin >> n >> m;\n\n        if((n ^ m) < n){\n            cout << 1 << endl << n << ' ' << m << endl;\n            continue;\n        }\n\n        int first = 63 - __builtin_clzll(n);\n        if(n == (1ll << first)){\n            cout << -1 << endl;\n            continue;\n        }\n        int second = 63 - __builtin_clzll(n ^ (1ll << first));\n        int chk = (1ll << (second + 1)) - 1;\n        if(chk < m) cout << -1 << endl;\n        else if(chk == m) cout << 1 << endl << n << ' ' << chk << endl;\n        else cout << 2 << endl << n << ' ' << chk << ' ' << m << endl;\n    }\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D1. XOR Break \u2014 Solo Version.json",
    "editorial_link": "https://codeforces.com//blog/entry/126423",
    "editorial": "Let\u00e2\u0080\u0099s determine the achievable values of for a given .If is a\nperfect power of , then it cannot be broken down further, and no is\nachievable. Otherwise, if has at least two set bits, let\u00e2\u0080\u0099s denote the\nmost significant bit as and the second most significant bit as .Fact 1:\nAll values less than are achievable if their most significant bit does\nnot lie between and .Reason: For instance, can be decomposed into and ,\nor and . In either case, we can never flip the or bit.Using the above\nfact, we can break the problem into two cases:Case 1: If the most\nsignificant bit of is at position .Perform the first operation as and (\n-> and in binary form). Then, any submask of can be created in the next\noperation.Case 2: If the most significant bit of is at position .If the\nmost significant bit of is at position , then can be obtained in one\noperation as and , since as given in the question, and has its most\nsignificant bit .\n"
}