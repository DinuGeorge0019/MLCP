{"link": "https://codeforces.com//contest/604/problem/E", "problemId": "42009", "problem_idx": "E", "shortId": "604E", "contest_number": "604", "problem_submissions": {"D": [14596500, 14593346, 14595214, 14597164, 14594625, 14591286, 14596851, 14596627, 14597744, 14595935, 14605132, 14596012, 14596656, 14597363, 14604366], "E": [14595112, 14597709, 14599612, 14601657, 14601583, 14602620, 14601006, 14598712, 14611507, 14600405, 14603271, 14606898, 14598106], "C": [14591727, 14591485, 14590401, 14591803, 14590167, 14598812, 14590931, 14593957, 14594227, 14592838, 14592345, 14591994, 14604053, 14594007, 14591853, 14592988], "B": [14589366, 14588467, 14587631, 14589936, 14596744, 23519332, 14588532, 14589419, 14589534, 14587511, 14588487, 14588973, 14588129, 14588264, 14589189], "A": [14587013, 14586403, 14586260, 14587679, 14595485, 14586765, 14586177, 14586973, 14586715, 14586347, 14586267, 14586259, 14587001, 14586457, 14586288, 14586867]}, "name": "E. Lieges of Legendre", "statement": "Kevin and Nicky Sun have invented a new game called Lieges of Legendre.\r\nIn this game, two players take turns modifying the game state with Kevin\r\nmoving first. Initially, the game is set up so that there are piles of\r\ncows, with the -th pile containing cows. During each player\u2019s turn, that\r\nplayer calls upon the power of Sunlight, and uses it to either: Remove a\r\nsingle cow from a chosen non-empty pile. Choose a pile of cows with even\r\nsize (), and replace it with piles of cows each. The player who removes\r\nthe last cow wins. Given , , and a sequence , help Kevin and Nicky find\r\nthe winner, given that both sides play in optimal way.\r\n", "solutions": ["#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, K, dp[10009];\nmap < int , int > mp;\n\nint sprg (int i)\n{\n    if (i <= 10) return dp[i];\n    if (i & 1) return 0;\n    if (mp.count (i)) return mp[i];\n    ///\n    int val = 1;///1 << dp[i - 1] i - 1 impar deci 0\n    val |= (1 << sprg (i / 2));\n    for (int k=0; k<=10; k++)\n        if ((val & (1 << k)) == 0)\n        {\n            mp[i] = k;\n            return k;\n        }\n}\n\nint sg (int x)\n{\n    if (K % 2 == 0)\n    {\n        if (x == 2) return 2;\n        if (x == 0) return 0;\n        if (x == 1) return 1;\n        if (x & 1) return 0;\n        return 1;\n    }\n    return sprg (x);\n}\n\nint main()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\n///sg[0] = 0\n///daca e impar, sg[x] = 1/0 in functie de x - 1\n///daca e par, pot inlocui i = 2 * x cu k gramezi de x\n///in primul rand, conteaza doar paritatea lui k\n///daca k e par atunci\n\nfor (int i=1; i<=1; i++)\n{\n    dp[0] = 0;\n    for (int j=1; j<=1000; j++)\n    {\n        if (j & 1)\n        {\n            if (dp[j - 1] > 0) dp[j] = 0;\n            else dp[j] = 1;\n        }\n        else\n        {\n            int val = 0;\n            if (i == 0) val |= 1;///K par\n            else val |= (1 << dp[j / 2]);\n            val |= (1 << dp[j - 1]);\n            for (int k=0; k<10; k++)\n                if ((val & (1 << k)) == 0)\n                {\n                    dp[j] = k;\n                    break;\n                }\n        }\n    }\n/*    for (int j=1; j<=1000; j++)\n        if (dp[j] == 2)\n        {\n            printf (\"%d\\n\", j);\n        }*/\n\n/*    for (int j=1; j<=10; j++)\n        printf (\"%d\\n\", dp[j]);\n    printf (\"impar:\\n\\n\\n\\n\");*/\n}\n/*K = 1;\nfor (int j=1; j<=1000; j++)\n    if (dp[j] != sprg (j))\n    {\n        printf (\"rahat %d\\n\", j);\n        return 0;\n    }\nreturn 0;*/\n\nscanf (\"%d %d\", &N, &K);\nint sol = 0;\nfor (int i=1; i<=N; i++)\n{\n    int x;\n    scanf (\"%d\", &x);\n    sol ^= sg (x);\n}\nif (sol) printf (\"Kevin\\n\");\nelse printf (\"Nicky\\n\");\n\nreturn 0;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "2200", "interactive": false}