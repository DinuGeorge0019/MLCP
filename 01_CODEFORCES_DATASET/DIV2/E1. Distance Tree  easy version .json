{"link": "https://codeforces.com//contest/1632/problem/E1", "problemId": "1278699", "problem_idx": "E1", "shortId": "1632E1", "contest_number": "1632", "problem_submissions": {"E1": [144553548, 144546555, 144538505, 144560614, 144555177, 144570181, 144567095, 144564117, 144551128, 144572195, 144551374, 144572612, 144560176, 144549481, 144570313, 144572945, 144573371, 144573243, 144781904, 144570037, 144576051], "E2": [144553397, 144546628, 144538238, 144560696, 144576825, 144570290, 144567223, 144574776, 144578234, 144577114, 144552629, 144572667, 144560118, 144548760, 144782104], "D": [144544326, 144548567, 144544619, 144545949, 144545344, 144546263, 144548360, 144547457, 144566603, 144552042, 144576325, 144552296, 144564979, 144562009, 144548406, 144547745, 144554067, 144547333, 144551486, 144552100], "C": [144532256, 144532333, 144552739, 144539867, 144537184, 144535548, 144541623, 144538433, 144533445, 144536971, 144534634, 144543706, 144539573, 144565645, 144540061, 144544063, 144537135, 144540356, 144543986, 144538265], "B": [144523270, 144523937, 144553855, 144517645, 144517755, 144524308, 144521003, 144519652, 144518659, 144523687, 144526327, 144529945, 144526501, 144567195, 144520516, 144517692, 144524688, 144521488, 144525583, 144520661], "A": [144513769, 144520637, 144555034, 144512533, 144512726, 144517704, 144512723, 144512551, 144512467, 144515604, 144512655, 144515813, 144521079, 144555040, 144512525, 144512590, 144514275, 144515034, 144512507, 144513160]}, "name": "E1. Distance Tree  easy version ", "statement": ".A tree is a connected undirected graph without cycles. A weighted tree\r\nhas a weight assigned to each edge. The distance between two vertices is\r\nthe minimum sum of weights on the path connecting them.You are given a\r\nweighted tree with n vertices, each edge has a weight of 1. Denote d(v)\r\nas the distance between vertex 1 and vertex v.Let f(x) be the minimum\r\npossible value of\r\nmax\r\nlimits_{1\r\nleq v\r\nleq n}\r\n{d(v)} if you can temporarily add an edge with weight x between any two\r\nvertices a and b (1\r\nle a, b\r\nle n). Note that after this operation, the graph is no longer a tree.For\r\neach integer x from 1 to n, find f(x).\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint T, n, d1[303000], rt, d2[303000];\n\nvector<int>G[303000];\n\nvoid dfs(int x,int fff,int *d){\n    if (fff!=0) d[x]=d[fff]+1;\n    else d[x]=0;\n    for (auto y:G[x])\n        if (y!=fff)\n            dfs(y,x,d);\n}\n\nint f[303000];\nvoid U(int &x,int y){\n    x=max(x,y);\n}\n\nbool check(int mid,int x){\n    if (d1[rt]<=mid) return 1;\n    int d=f[mid+1];\n    if (d==0) return x<=mid;\n    return mid>=x+(d+1)/2;\n}\n\nint main(){\n    for (cin>>T;T--;){\n        scanf(\"%d\",&n);\n        for (int i=1;i<=n;++i) G[i].clear();\n        for (int i=1;i<n;++i){\n            int x, y; scanf(\"%d%d\",&x,&y);\n            G[x].push_back(y);\n            G[y].push_back(x);\n        }\n        dfs(1,0,d1);\n        rt=max_element(d1+1,d1+n+1)-d1;\n        dfs(rt,0,d2);\n        for (int i=0;i<=n+1;++i) f[i]=0;\n        for (int i=1;i<=n;++i)\n            U(f[d1[i]],d2[i]);\n        for (int i=n;i>=0;--i){\n            U(f[i],f[i+1]);\n        }\n        for (int i=1;i<=n;++i){\n            int l=1, r=n, ans=n;\n            while (l<=r){\n                int mid=l+r>>1;\n                if (check(mid,i)){\n                    ans=mid; r=mid-1;\n                }else{\n                    l=mid+1;\n                }\n            }\n            printf(\"%d \",ans);\n        }\n        puts(\"\");\n    }\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "graphs", "shortest paths", "trees"], "dificulty": "2400", "interactive": false}