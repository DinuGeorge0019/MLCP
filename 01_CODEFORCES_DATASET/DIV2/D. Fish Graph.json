{"link": "https://codeforces.com//contest/1818/problem/D", "problemId": "1897386", "problem_idx": "D", "shortId": "1818D", "contest_number": "1818", "problem_submissions": {"F": [203954465, 203930910, 203989728, 203950170], "E": [203940713, 203952207, 203954969, 203955944, 204078536, 203944339, 203943920, 203965332, 203957684, 203924512], "D": [203935580, 203930131, 203939536, 203937747, 203926993, 203932798, 203948151, 203919017, 203933133, 203930283, 203939418, 203978791, 203937294, 203949049, 203940699, 203938945, 203937604, 203937271], "C": [203927589, 203919798, 203928628, 203925534, 203931513, 203921512, 203927085, 203928001, 203926317, 203916672, 203923862, 203933925, 203926373, 203934292, 203922244, 203928248, 203928037, 203928918], "B": [203922412, 203918213, 203919638, 203920216, 203917691, 203917420, 203954835, 203921335, 203916143, 203918490, 203937550, 203919150, 203922597, 203918604, 203921444, 203917928, 203921361, 203920046, 203919333], "A": [203919670, 203917474, 203915999, 203915969, 203915149, 203915496, 203915115, 203915794, 203934868, 203916606, 203917417, 203915457, 203960905, 203915626, 203915203, 203915634, 203917495]}, "name": "D. Fish Graph", "statement": "You are given a simple undirected graph with n nodes and m edges. Note\r\nthat the graph is not necessarily connected. The nodes are labeled from\r\n1 to n.We define a graph to be a if it contains a simple cycle with a\r\nspecial node u belonging to the cycle. Apart from the edges in the\r\ncycle, the graph should have exactly 2 extra edges. Both edges should\r\nconnect to node u, but they should not be connected to any other node of\r\nthe cycle. Determine if the graph contains a subgraph that is a Fish\r\nGraph, and if so, find any such subgraph.In this problem, we define a\r\nsubgraph as a graph obtained by taking any subset of the edges of the\r\noriginal graph.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n\nusing ll = long long;\nusing vi = vector <int>;\nusing pii = pair <int, int>;\nusing vpii = vector <pii>;\n\nconst int MX = 2e3 + 10;\n\nint n, m, a[MX], prt[MX];\nvi adj[MX];\nbool vis[MX];\nbool tmp[MX];\nvi pt;\nvpii rlt;\nvi t1, t2;\nint tp[MX];\n\nbool DFS(int u, int p) {\n\tvis[u] = 1;\n\tprt[u] = p;\n\t\n\tfor (auto v : adj[u]) {\n\t\tif (v == p) continue;\n\t\tif (vis[v]) {\n\t\t\trlt.clear();\n\t\t\tpt.clear();\n\t\t\tt1.clear(); \n\t\t\tt2.clear();\n\t\t\t\n\t\t\tint d = u;\n\t\t\twhile (d) {\n\t\t\t\tt1.push_back(d);\n\t\t\t\td = prt[d];\n\t\t\t}\t\n\t\t\td = v;\n\t\t\twhile (d) {\n\t\t\t\tt2.push_back(d);\n\t\t\t\td = prt[d];\n\t\t\t}\n\t\t\treverse(t1.begin(), t1.end());\n\t\t\treverse(t2.begin(), t2.end());\t\n\t\t\tint len = min(t1.size(), t2.size());\n\t\t\tint i;\n\t\t\tfor (i = 0 ; i < len && t1[i] == t2[i] ; i ++);\n\t\t\ti --;\n\t\t\tfill_n(tmp, n + 1, 0);\n\t\t\tfor (int j = i ; j < t1.size() ; j ++) {\n\t\t\t\ttmp[t1[j]] = 1;\n\t\t\t\tpt.push_back(t1[j]);\n\t\t\t}\n\t\t\tfor (int j = i + 1 ; j < t2.size() ; j ++) {\n\t\t\t\ttmp[t2[j]] = 1;\n\t\t\t\tpt.push_back(t2[j]);\n\t\t\t}\n\t\t\trlt.push_back({u, v});\n\t\t\tfor (int j = i ; j < t1.size() - 1 ; j ++) rlt.push_back({t1[j], t1[j + 1]});\n\t\t\tfor (int j = i ; j < t2.size() - 1 ; j ++) rlt.push_back({t2[j], t2[j + 1]});\n\t\t\tint k, c, cnt;\n\t\t\tfor (int j = pt.size() - 1 ; j >= 0 ; j --) {\n\t\t\t\tk = pt[j];\n\t\t\t\tcnt = 0;\n\t\t\t\tfor (int w = adj[k].size() - 1 ; w >= 0 ; w --) {\n\t\t\t\t\tc = adj[k][w];\n\t\t\t\t\tif (tmp[c]) continue;\n\t\t\t\t\ttp[cnt ++] = c;\n\t\t\t\t}\n\t\t\t\tif (cnt >= 2) {\n\t\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\t\tcout << rlt.size() + 2 << endl;\n\t\t\t\t\tcout << k << ' ' << tp[0] << endl;\n\t\t\t\t\tcout << k << ' ' << tp[1] << endl;\n\t\t\t\t\tfor (int i = 0 ; i < rlt.size() ; i ++) {\n\t\t\t\t\t\tcout << rlt[i].first << ' ' << rlt[i].second << endl;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (DFS(v, u)) return true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\t\n\tint Tc; cin >> Tc;\n\twhile (Tc --) {\n\t\tcin >> n >> m;\n\t\tfor (int i = 1 ; i <= n ; i ++) adj[i].clear();\n\t\tfill_n(vis, n + 1, 0);\n\t\tint u, v;\n\t\tfor (int i = 1 ; i <= m ; i ++) {\n\t\t\tcin >> u >> v;\n\t\t\tadj[u].push_back(v);\n\t\t\tadj[v].push_back(u);\n\t\t}\n\t\tbool f = 0;\n\t\tfor (int i = 1 ; i <= n ; i ++) {\n\t\t\tif (vis[i]) continue;\n\t\t\tif (DFS(i, 0)) {\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!f) cout << \"NO\" << endl;\n\t}\t \n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "graphs", "implementation"], "dificulty": "1900", "interactive": false}