{
    "link": "https://codeforces.com//contest/570/problem/D",
    "problemId": "33020",
    "problem_idx": "D",
    "shortId": "570D",
    "contest_number": "570",
    "problem_submissions": {
        "A": [
            12511664,
            12494868,
            12495315,
            12495052,
            12498729,
            12495010,
            12494706,
            12495365,
            12494962,
            12496174,
            12494954,
            12502600,
            12496200,
            12496316,
            12506558,
            12502467,
            12495107,
            12496065,
            12498893,
            12498878
        ],
        "B": [
            12509887,
            12497298,
            12497382,
            12499467,
            12505096,
            12495563,
            12498176,
            12497892,
            12496695,
            12495228,
            12498861,
            12499890,
            12502905,
            12497610,
            12503032,
            12504155,
            12497913,
            12496421
        ],
        "E": [
            12508866,
            12514963,
            12515149,
            12513258,
            12512484,
            12512570,
            12514497,
            12512953,
            12509761,
            12511947,
            12514813
        ],
        "D": [
            12503406,
            12507923,
            12507699,
            12507537,
            12509874,
            12513189,
            12507259,
            12527819,
            12514569,
            12511515,
            12568414,
            12512833
        ],
        "C": [
            12498193,
            12507310,
            12502209,
            12498057,
            12501547,
            12500587,
            12501845,
            12503728,
            12502079,
            12505954,
            12509333,
            12499956,
            12503373,
            12503640,
            12501153,
            12511401,
            12502671,
            12506512,
            12510295,
            12502880
        ]
    },
    "name": "D. Tree Requests",
    "statement": "Roman planted a tree consisting of vertices. Each vertex contains a\r\nlowercase English letter. Vertex is the root of the tree, each of the\r\nremaining vertices has a in the tree. Vertex is connected with its\r\nparent by an edge. The parent of vertex is vertex , the parent index is\r\nalways less than the index of the vertex (i.e., ).The of the vertex is\r\nthe number of nodes on the path from the root to along the edges. In\r\nparticular, the depth of the root is equal to .We say that vertex is in\r\nthe of vertex , if we can get from to , moving from the vertex to the\r\nparent. In particular, vertex is in its subtree.Roma gives you queries,\r\nthe -th of which consists of two numbers , . Letâ€™s consider the vertices\r\nin the subtree located at depth . Determine whether you can use the\r\nletters written at these vertices to make a string that is a . The\r\nletters that are written in the vertexes, can be rearranged in any order\r\nto make a palindrome, but all letters should be used.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#define MAXN 500005\n\nint n,m;\n\nint fa[MAXN];\nint h[MAXN];\nstd::vector<int> childs[MAXN];\n\nint h_cnt[MAXN];\n\nint dfn[MAXN];\nint d2[MAXN];\n\nstruct data {\n\tint cnt[26];\n\tint d;\n};\n\nstd::vector<data> sum[MAXN];\n\nchar a[MAXN];\n\ninline void dfs(int x) {\n\tstatic int dfstot=0;\n\tdfn[x]=++dfstot;\n\tstatic data t;\n\tt=sum[h[x]].back();\n\t++t.cnt[a[x]-'a'];\n\tt.d=dfstot;\n\tsum[h[x]].push_back(t);\n\tfor (auto t : childs[x]) {\n\t\tdfs(t);\n\t}\n\td2[x]=dfstot;\n}\n\ninline int find(const std::vector<data> &A,int l,int r,int d) {\n\twhile (l<r) {\n\t\tint mid=(l+r+1)>>1;\n\t\tif (A[mid].d>d) {\n\t\t\tr=mid-1;\n\t\t} else {\n\t\t\tl=mid;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tint i;\n\th[1]=1;\n\t++h_cnt[1];\n\tfor (i=2;i<=n;i++) {\n\t\tscanf(\"%d\",fa+i);\n\t\tchilds[fa[i]].push_back(i);\n\t\th[i]=h[fa[i]]+1;\n\t\t++h_cnt[h[i]];\n\t}\n\t\n\tscanf(\"%s\",a+1);\n\t\n\tdata x;\n\tmemset(&x,0,sizeof(x));\n\tfor (i=1;i<=n;i++) {\n\t\tsum[i].push_back(x);\n\t}\n\tdfs(1);\n\t\n\tfor (i=1;i<=m;i++) {\n\t\tint x,d;\n\t\tscanf(\"%d%d\",&x,&d);\n\t\tint L=dfn[x],R=d2[x];\n\t\tint id1=find(sum[d],0,sum[d].size()-1,L-1);\n\t\tint id2=find(sum[d],0,sum[d].size()-1,R);\n\t\tdata A=sum[d][id1];\n\t\tdata B=sum[d][id2];\n\t\tint i;\n\t\tint t=0;\n\t\tfor (i=0;i<26;i++) {\n\t\t\tint x=B.cnt[i]-A.cnt[i];\n\t\t\tif (x>0 && x%2==1) ++t;\n\t\t}\n\t\tputs(t>1 ? \"No\" : \"Yes\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Tree Requests.json",
    "editorial_link": "https://codeforces.com//blog/entry/19770",
    "editorial": "We need to write vertices in DFS order and store time of enter/exit of\r\nvertices in DFS. All vertices in subtree represent a segment. Now we can\r\nget all vertices in subtree v on height h as a segment, making two\r\nbinary searches. We can make a palindrome if quantity of uneven entries\r\nof each letter is less than 2. This function can be counted for each\r\nprefix in bypass for each depth. For saving the memory bit compression\r\ncan be used considering that we need only parity and function is xor. D\r\nhad a offline solution too in time and memory Solutions\r\n",
    "hint": []
}