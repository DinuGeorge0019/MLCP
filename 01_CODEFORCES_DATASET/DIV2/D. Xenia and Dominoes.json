{
    "link": "https://codeforces.com//contest/342/problem/D",
    "problemId": "3441",
    "problem_idx": "D",
    "shortId": "342D",
    "contest_number": "342",
    "problem_submissions": {
        "E": [
            4424475,
            4422829,
            4430368,
            4421720,
            4425588,
            4424864,
            7980137,
            4422643,
            4422969,
            33894142,
            33894120,
            12335279
        ],
        "D": [
            4422563,
            4424584,
            4422881,
            4425178,
            4424327
        ],
        "B": [
            4417892,
            4425509,
            4417934,
            4418698,
            4420332,
            4419060,
            4418029,
            4418641,
            4419108,
            4418926,
            4419003,
            4423078,
            4421488,
            4420712,
            4420147,
            4428238,
            4428202,
            4420216,
            4418853,
            4419150,
            4419856
        ],
        "A": [
            4417092,
            4417221,
            4417057,
            4417245,
            4417383,
            4417575,
            4417020,
            4417100,
            4417102,
            4419265,
            4417254,
            4417136,
            4419082,
            4418070,
            4418662,
            4418542,
            4417680,
            4417389,
            4417298
        ],
        "C": [
            4419537,
            4420363,
            4425253,
            4423789,
            4425489,
            4420140,
            4422038,
            4419838,
            4423331,
            4424488,
            4420343,
            4420820,
            4423363
        ]
    },
    "name": "D. Xenia and Dominoes",
    "statement": "Xenia likes puzzles very much. She is especially fond of the puzzles\r\nthat consist of domino pieces. Look at the picture that shows one of\r\nsuch puzzles. A puzzle is a table with forbidden cells (black squares)\r\ncontaining dominoes (colored rectangles on the picture). A puzzle is\r\ncalled if it meets the following conditions: each domino occupies\r\nexactly two non-forbidden cells of the table; no two dominoes occupy the\r\nsame table cell; exactly one non-forbidden cell of the table is\r\nunoccupied by any domino (it is marked by a circle in the picture). To\r\nsolve the puzzle, you need multiple steps to transport an empty cell\r\nfrom the starting position to some specified position. A move is\r\ntransporting a domino to the empty cell, provided that the puzzle stays\r\ncorrect. The picture shows a probable move.Xenia has a table with\r\nforbidden cells and a cell marked with a circle. Also, Xenia has very\r\nmany identical dominoes. Now Xenia is wondering, how many distinct\r\ncorrect puzzles she can make if she puts dominoes on the existing table.\r\nAlso, Xenia wants the circle-marked cell to be empty in the resulting\r\npuzzle. The puzzle must contain at least one move.Help Xenia, count the\r\ndescribed number of puzzles. As the described number can be rather\r\nlarge, print the remainder after dividing it by .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#define lson step << 1\n#define rson step << 1 | 1\n#define lowbit(x) (x & (-x))\n#define Key_value ch[ch[root][1]][0] \nusing namespace std;\ntypedef long long LL;\nconst int N = 10005;\nconst int MOD = 1000000007;\nchar str[3][N];\nint n , sx , sy;\nvector<pair<pair<int ,int> , pair<int , int> > > v;\nint dp[N][1 << 3];\nvoid add (int &a , int b) {\n    a = (a + b) % MOD;\n    a = (a + MOD) % MOD;\n}\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (\"input.txt\" , \"r\" , stdin);\n        // freopen (\"output.txt\" , \"w\" , stdout);\n    #endif\n    cin >> n;\n    int ans = 0;\n    for (int i = 0 ; i < 3 ; i ++) {\n        scanf (\"%s\" , str[i] + 1);\n        for (int j = 1 ; j <= n ; j ++)\n            if (str[i][j] == 'O') {\n                sx = i ; sy = j ;\n            }\n    }\n    if (sx == 0) {\n        if (str[sx + 1][sy] == '.' && str[sx + 2][sy] == '.') {\n            v.push_back (make_pair(make_pair(sx + 1 , sy) , make_pair(sx + 2 , sy)));\n        }\n    }\n    if (sx == 2) {\n        if (str[sx - 1][sy] == '.' && str[sx - 2][sy] == '.') {\n            v.push_back (make_pair(make_pair(sx - 1 , sy) , make_pair(sx - 2 , sy)));\n        }\n    }\n    if (sy > 2) {\n        if (str[sx][sy - 1] == '.' && str[sx][sy - 2] == '.') {\n            v.push_back (make_pair(make_pair(sx , sy - 1) , make_pair(sx, sy - 2)));\n        }\n    }\n    if (sy <= n - 2) {\n        if (str[sx][sy + 1] == '.' && str[sx][sy + 2] == '.') {\n            v.push_back (make_pair(make_pair(sx , sy + 1) , make_pair(sx, sy + 2)));\n        }\n    }\n    int m = v.size();\n    for (int mask = 1 ; mask < (1 << m) ; mask ++) {\n        int cnt = 0;\n        for (int j = 0 ; j < m ; j ++) {\n            if (mask & (1 << j)) {\n                cnt ++;\n                str[v[j].first.first][v[j].first.second] = 'X';\n                str[v[j].second.first][v[j].second.second] = 'X';\n            }\n        }\n            memset (dp , 0 ,sizeof(dp));\n            dp[1][0] = 1;\n            for (int i = 1 ; i <= n ; i ++) {\n                for (int j = 0 ; j < (1 << 3) ; j ++) {\n                    if (dp[i][j] == 0) continue;\n                    int remain = 7 - j;\n                    for (int k = 0 ; k < 3; k  ++)\n                        if ((remain & (1 << k)) && str[k][i] != '.')\n                            remain -= 1 << k;\n                    if (remain == 0) {\n                        add (dp[i + 1][0] , dp[i][j]);\n                    }\n                    for (int k = 0 ; k < 3 ; k ++) {\n                        if ((1 << k) == remain) {\n                            if (str[k][i + 1] == '.') {\n                                add (dp[i + 1][1 << k] , dp[i][j]);\n                            }\n                        }\n                    }\n                    if (remain == 3) {\n                        add (dp[i + 1][0] , dp[i][j]);\n                        if (str[0][i + 1] == '.' && str[1][i + 1] == '.')\n                            add (dp[i + 1][3] , dp[i][j]);\n                    }\n                    if (remain == 6) {\n                        add (dp[i + 1][0] , dp[i][j]);\n                        if (str[2][i + 1] == '.' && str[1][i + 1] == '.')\n                            add (dp[i + 1][6] , dp[i][j]);\n                    }\n                    if (remain == 5) {\n                        if (str[2][i + 1] == '.' && str[0][i + 1] == '.')\n                            add (dp[i + 1][5] , dp[i][j]);\n                    }\n                    if (remain == 7) {\n                        if (str[2][i + 1] == '.' && str[0][i + 1] == '.' && str[1][i + 1] == '.')\n                            add (dp[i + 1][7] , dp[i][j]);\n                        if (str[0][i + 1] == '.')\n                            add (dp[i + 1][1] , dp[i][j]);\n                        if (str[2][i + 1] == '.')\n                            add (dp[i + 1][4] , dp[i][j]);\n                    }\n                }\n            }\n        if (cnt & 1) add (ans , dp[n + 1][0]);\n        else add (ans , -dp[n + 1][0]);\n        for (int j = 0 ; j < m ; j ++) {\n            if (mask & (1 << j)) {\n                str[v[j].first.first][v[j].first.second] = '.';\n                str[v[j].second.first][v[j].second.second] = '.';\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}       \n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Xenia and Dominoes.json",
    "editorial_link": "https://codeforces.com/blog/entry/8800",
    "editorial": "In the problem you can count number of correct puzzles or substract\r\nnumber of incorrect puzzles from number of all puzzles. In any case you\r\nshould count DP, where the state is number of the last full column, mask\r\nof the last column. This problem is equivalent to the well known problem\r\nabout domino tiling or the problem about parquet. To get the solution of\r\nthe whole problem I did the following. I try to attach one domino to\r\neach of 4 directions, then paint all three cells in black and count the\r\nnumber of correct puzzles. But in this case you will count some\r\nsolutions several number of times. So you need to use inclusion\r\nexclusion formula for these 4 directions.\r\n",
    "hint": []
}