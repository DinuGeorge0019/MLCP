{
    "link": "https://codeforces.com//contest/1682/problem/D",
    "problemId": "1407922",
    "problem_idx": "D",
    "shortId": "1682D",
    "contest_number": "1682",
    "problem_submissions": {
        "F": [
            158050798,
            158077786,
            158086685,
            158039286,
            158069961,
            158110252,
            158078476,
            158248901
        ],
        "D": [
            158028363,
            158027200,
            158028814,
            158069864,
            158039569,
            158036346,
            158030046,
            158050282,
            158037974,
            158041123,
            158041068,
            158036998,
            158042298,
            158032953,
            158041526,
            158029661,
            158056637,
            158029667
        ],
        "C": [
            158015824,
            158013904,
            158013129,
            158070941,
            158017154,
            158019512,
            158011476,
            158017137,
            158021257,
            158018627,
            158020682,
            158022180,
            158021471,
            158039652,
            158019776,
            158037446,
            158028182
        ],
        "B": [
            158006894,
            158007821,
            158007318,
            158071816,
            158008119,
            158009978,
            158007984,
            158008572,
            158013225,
            158009923,
            158010666,
            158009973,
            158013386,
            158010013,
            158016214,
            158026210,
            158017588,
            158010270
        ],
        "A": [
            158004280,
            158004512,
            158004427,
            158072894,
            158004570,
            158007124,
            158005591,
            158005462,
            158005647,
            158004983,
            158006433,
            158004812,
            158012816,
            158004216,
            158013837,
            158039471,
            158008517,
            158004710
        ],
        "E": [
            158050246,
            158056393,
            158060063,
            158060073,
            158067774,
            158059309,
            158065396,
            158067467,
            158070762,
            158068042,
            158070815,
            158073429,
            158070617,
            158069678,
            158075426,
            158064743
        ]
    },
    "name": "D. Circular Spanning Tree",
    "statement": "There are n nodes arranged in a circle numbered from 1 to n in the\r\nclockwise order. You are also given a binary string s of length n.Your\r\ntask is to construct a tree on the given n nodes satisfying the two\r\nconditions below or report that there such tree does not exist: For each\r\nnode i (1\r\nle i\r\nle n), the degree of node is even if s_i = 0 and odd if s_i = 1. No two\r\nedges of the tree intersect internally in the circle. The edges are\r\nallowed to intersect on the circumference. Note that all edges are drawn\r\nas straight line segments. For example, edge (u, v) in the tree is drawn\r\nas a line segment connecting u and v on the circle.A tree on n nodes is\r\na connected graph with n - 1 edges.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nchar s[200005];\nint ansu[200005],ansv[200005],tmp;\nint js[200005],cnt;\nbool vis[200005];\nint main()\n{\n\tint t,n,ans=0,ans1=0,tsl,las;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tscanf(\"%s\",s+1);\n\t\ttsl=0;\n\t\tfor(int i=1;i<=n;i++)if(s[i]=='1')tsl++;\n\t\tif(tsl==0||tsl%2==1)\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"YES\\n\");\n\t\ttmp=0;\n\t\tcnt=0;\n\t\tlas=0;\n\t\tfor(int i=1;i<=n;i++)vis[i]=false;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]=='0'&&las!=0)\n\t\t\t{\n\t\t\t\tansu[++tmp]=i;\n\t\t\t\tvis[i]=true;\n\t\t\t\tansv[tmp]=las;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t\tif(s[i]=='1')\n\t\t\t{\n\t\t\t\tif(las!=0)js[++cnt]=las;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]=='0'&&vis[i]==false)\n\t\t\t{\n\t\t\t\tansu[++tmp]=i;\n\t\t\t\tansv[tmp]=las;\n\t\t\t\tvis[i]=true;\n\t\t\t\tlas=i;\n\t\t\t}\n\t\t\tif(s[i]=='1')break;\n\t\t}\n\t\tjs[++cnt]=las;\n\t\t//printf(\"!!!%d\\n\",cnt);\n\t\tfor(int i=2;i<=cnt;i++)\n\t\t{\n\t\t\tansu[++tmp]=js[1];\n\t\t\tansv[tmp]=js[i];\n\t\t}\n\t\tfor(int i=1;i<=tmp;i++)printf(\"%d %d\\n\",ansu[i],ansv[i]);\n\t}\n\treturn 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Circular Spanning Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/103097",
    "editorial": "TutorialLet\u00e2\u0080\u0099s check some cases when it is not possible to construct the\r\nanswer- When all vertices have an even degree, then there is no way to\r\ngenerate a tree because every tree contains at least leaves. When there\r\nare an odd number of vertices with odd degrees, then there is no tree\r\npossible because the sum of degrees must be even. It turns out that it\r\nis always possible to construct a tree if none of the above is true.The\r\nfollowing construction works - Select some vertex such that the previous\r\nvertex of (assumed cyclically) has an odd degree i.e. . Clearly, such a\r\nvertex always exists. Now left rotate , times such that the selected\r\nvertex is now at index . Note that after the rotation will become . Now\r\nwe can see that can be divided into several segments such that each\r\nsegment ends with some vertex having an odd degree. And each segment\r\nshould contain exactly one vertex with an odd degree. So where may\r\nappear times. Connect vertex to the starting vertex of each segment and\r\nconnect adjacent vertices inside each segment. It can be clearly seen\r\nthat edges will never intersect internally. The only thing we need to\r\nverify is the degree constraints. Proof: The degree condition is valid\r\nfor each segment, as each vertex with an even degree is connected with\r\nother vertices and the last vertex with an odd degree will be connected\r\nto only one vertex i.e it\u00e2\u0080\u0099s previous one or vertex if it was only on its\r\nsegment. Let be the number of vertices with odd degree. If , then there\r\nwill be segments which is an odd number, hence vertex will be connected\r\nto odd number of vertices. If , then there will be segments which is an\r\neven number, hence vertex will be connected to even number of vertices.\r\nNote that we renumbered the vertices during rotation which should be\r\nhandled in implementation.The intuition for the above approach comes\r\nfrom the case when all are in which we create a star network.Overall\r\ncomplexity: .\r\n"
}