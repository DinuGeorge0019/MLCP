{
    "link": "https://codeforces.com//contest/2022/problem/E1",
    "problemId": "2947279",
    "problem_idx": "E1",
    "shortId": "2022E1",
    "contest_number": "2022",
    "problem_submissions": {
        "D1": [
            285726010,
            285732443,
            285720467,
            285721725,
            285710598,
            285716496,
            285709185,
            285722223,
            285721840,
            285726265,
            285729782,
            285729870,
            285772115,
            285771713,
            285716249,
            285713460,
            285712248,
            285718533,
            285715843
        ],
        "E2": [
            285719910,
            285720748,
            285735574,
            285735176,
            288055359,
            286524378,
            285733091,
            285771493,
            285770412,
            285770170,
            285769301
        ],
        "E1": [
            285717777,
            285720862,
            285735538,
            285732412,
            285730131,
            285734694,
            285730466,
            285740393,
            285736961,
            285737293,
            285738689,
            285733822,
            285723809
        ],
        "C": [
            285713470,
            285709435,
            285713964,
            285712717,
            285726534,
            285712313,
            285728850,
            285716262,
            285717872,
            285721376,
            285719625,
            285718527,
            285713136,
            285713916,
            285709969,
            285709168,
            285707306,
            285710892,
            285710354
        ],
        "B": [
            285703660,
            285702595,
            285706421,
            285702197,
            285705976,
            285703966,
            285719780,
            285706485,
            285711437,
            285705925,
            285707565,
            285707987,
            285708651,
            285708053,
            285702275,
            285704156,
            285708490,
            285702360,
            285704264
        ],
        "A": [
            285702679,
            285701420,
            285703196,
            285701332,
            285704286,
            285701973,
            285705578,
            285709500,
            285703987,
            285704902,
            285704417,
            285704940,
            285701496,
            285701330,
            285702274,
            285701454,
            285701489,
            285702531
        ],
        "D2": [
            286191597,
            285736183,
            290850953,
            285816124
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135095",
    "editorial": "ProofConsider doing the operation described in hint 4 for every row and\r\nevery column of a full grid that satisfies the condition; That is, for\r\neach row, and each column, fix the first element, and change every value\r\nin that row or column by their xor with the first element. We will be\r\nleft with a grid whose first row and first column are all zeros.But this\r\ngrid also satisfies the condition! So it must hold that , but 3 of this\r\nvalues are zero!We can conclude that must also be zero. This shows that\r\nthere must exist two arrays and , such that , for any valid full grid.\r\n",
    "name": "E1. Billetes MX  Easy Version ",
    "statement": "An integer grid A with p rows and q columns is called if: All elements\r\nof the grid are integers between 0 and 2^{30}-1, and For any subgrid,\r\nthe XOR of the values at the corners is equal to 0. Formally, for any\r\nfour integers i_1, i_2, j_1, j_2 (1\r\nle i_1 < i_2\r\nle p; 1\r\nle j_1 < j_2\r\nle q), A_{i_1, j_1}\r\noplus A_{i_1, j_2}\r\noplus A_{i_2, j_1}\r\noplus A_{i_2, j_2} = 0, where\r\noplus denotes the bitwise XOR operation. There is a partially filled\r\ninteger grid G with n rows and m columns where only k cells are filled.\r\nPolycarp wants to know how many ways he can assign integers to the\r\nunfilled cells so that the grid is beautiful.However, Monocarp thinks\r\nthat this problem is too easy. Therefore, he will perform q updates on\r\nthe grid. In each update, he will choose an unfilled cell and assign an\r\ninteger to it. Note that these updates are . That is, changes made to\r\nthe grid will apply when processing future updates.For each of the q + 1\r\nstates of the grid, the initial state and after each of the q queries,\r\ndetermine the number of ways Polycarp can assign integers to the\r\nunfilled cells so that the grid is beautiful. Since this number can be\r\nvery large, you are only required to output their values modulo 10^9+7.\r\n",
    "solutions": [
        "#line 1 \"library/Template/template.hpp\"#include <bits/stdc++.h>using namespace std; #define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin()) using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff; template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));} template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << \"P(\" << p.first << \", \" << p.second << \")\";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << \"{\";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");    }    os << \"}\";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << \"{\";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << \"(\" << itr->first << \", \" << itr->second << \")\";        itr++;        if (itr != map_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << \"{\";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << \", \";        itr--;    }    os << \"}\";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << '\\n';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != ',' && a[i] != '\\0'; i++)        cerr << a[i];    cerr << \":\" << b << \" \";    _show(i + 1, a, c...);}#line 2 \"library/Utility/fastio.hpp\"#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf uint32_t pil = 0, pir = 0, por = 0; struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | '0';                n /= 10;            }        }    }} constexpr pre; inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = '\\n';} inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;} void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));} void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));} template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);} template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < '-');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == '-') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while ('0' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }} void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);} template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);} template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);} void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);} void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);} template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = '-', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | '0';        obuf[por + 1] = (x - q * 10) | '0';        por += 2;    } else        obuf[por++] = x | '0';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;} template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);} void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);} template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(' ');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(' ');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(' ');        wt(val[i]);    }} void print() {    wt('\\n');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(' ');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio using fastio::flush;using fastio::print;using fastio::read; inline void first(bool i = true) {    print(i ? \"first\" : \"second\");}inline void Alice(bool i = true) {    print(i ? \"Alice\" : \"Bob\");}inline void Takahashi(bool i = true) {    print(i ? \"Takahashi\" : \"Aoki\");}inline void yes(bool i = true) {    print(i ? \"yes\" : \"no\");}inline void Yes(bool i = true) {    print(i ? \"Yes\" : \"No\");}inline void No() {    print(\"No\");}inline void YES(bool i = true) {    print(i ? \"YES\" : \"NO\");}inline void NO() {    print(\"NO\");}inline void Yay(bool i = true) {    print(i ? \"Yay!\" : \":(\");}inline void Possible(bool i = true) {    print(i ? \"Possible\" : \"Impossible\");}inline void POSSIBLE(bool i = true) {    print(i ? \"POSSIBLE\" : \"IMPOSSIBLE\");} /** * @brief Fast IO */#line 3 \"sol.cpp\" #line 2 \"library/Math/modint.hpp\" template <unsigned mod = 1000000007> struct fp {    unsigned v;    static constexpr int get_mod() {        return mod;    }    constexpr unsigned inv() const {        assert(v != 0);        int x = v, y = mod, p = 1, q = 0, t = 0, tmp = 0;        while (y > 0) {            t = x / y;            x -= t * y, p -= t * q;            tmp = x, x = y, y = tmp;            tmp = p, p = q, q = tmp;        }        if (p < 0)            p += mod;        return p;    }    constexpr fp(ll x = 0) : v(x >= 0 ? x % mod : (mod - (-x) % mod) % mod) {}    fp operator-() const {        return fp() - *this;    }    fp pow(ull t) {        fp res = 1, b = *this;        while (t) {            if (t & 1)                res *= b;            b *= b;            t >>= 1;        }        return res;    }    fp &operator+=(const fp &x) {        if ((v += x.v) >= mod)            v -= mod;        return *this;    }    fp &operator-=(const fp &x) {        if ((v += mod - x.v) >= mod)            v -= mod;        return *this;    }    fp &operator*=(const fp &x) {        v = ull(v) * x.v % mod;        return *this;    }    fp &operator/=(const fp &x) {        v = ull(v) * x.inv() % mod;        return *this;    }    fp operator+(const fp &x) const {        return fp(*this) += x;    }    fp operator-(const fp &x) const {        return fp(*this) -= x;    }    fp operator*(const fp &x) const {        return fp(*this) *= x;    }    fp operator/(const fp &x) const {        return fp(*this) /= x;    }    bool operator==(const fp &x) const {        return v == x.v;    }    bool operator!=(const fp &x) const {        return v != x.v;    }    friend istream &operator>>(istream &is, fp &x) {        return is >> x.v;    }    friend ostream &operator<<(ostream &os, const fp &x) {        return os << x.v;    }}; template <unsigned mod> void rd(fp<mod> &x) {    fastio::rd(x.v);}template <unsigned mod> void wt(fp<mod> x) {    fastio::wt(x.v);} /** * @brief Modint */#line 5 \"sol.cpp\"using Fp = fp<>; void solve(int _rot) {    // write(\"Case #\"+to_string(_rot)+\": \");    int n, m, k, q;    read(n, m, k, q);     vector<int> X(k), Y(k), v(k);    rep(i, 0, k) {        read(X[i], Y[i], v[i]);        X[i]--, Y[i]--;    }     Fp ret = 1;    rep(b, 0, 30) {        using P = pair<int, int>;        vector g(n + m, vector<P>());        rep(i, 0, k) {            g[X[i]].push_back({Y[i] + n, (v[i] >> b & 1)});            g[Y[i] + n].push_back({X[i], (v[i] >> b & 1)});        }        vector<int> col(n + m, -1);        bool ch = 1;        auto dfs = [&](auto &dfs, int v) -> void {            for (auto &[to, c] : g[v]) {                if (col[to] == -1) {                    col[to] = col[v] ^ c;                    dfs(dfs, to);                } else if (col[v] != (col[to] ^ c)) {                    ch = 0;                }            }        };        int cnt = 0;        rep(i, 0, n + m) if (col[i] == -1) {            col[i] = 0;            dfs(dfs, i);            cnt++;        }        if (!ch) {            print(0);            return;        }        show(b, cnt);        ret *= Fp(2).pow(cnt - 1);    }    print(ret);} int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "binary search",
        "combinatorics",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E1. Billetes MX  Easy Version .json",
    "hint": [
        "Hint 1 Consider the extremal cases, what is the answer if the grid is empty? What is the answer if the grid is full? What happens if ?",
        "Hint 2 Observe that if , the xor of every column is constant. Can we generalize this idea?",
        "Hint 4 Imagine you have a valid full grid . For each , change to . Observe that the grid still satisfies the condition!",
        "Hint 5 Using the previous idea we can show that for any valid grid, there must exist two arrays and , such that . Proof Consider doing the operation described in hint 4 for every row and every column of a full grid that satisfies the condition; That is, for each row, and each column, fix the first element, and change every value in that row or column by their xor with the first element. We will be left with a grid whose first row and first column are all zeros. But this grid also satisfies the condition! So it must hold that , but 3 of this values are zero! We can conclude that must also be zero. This shows that there must exist two arrays and , such that , for any valid full grid.",
        "Hint 6 Think of each tile of the grid that we know of, as imposing a condition between two elements of arrays and . For each tile added, we lose one degree of freedom right? We could make a bunch of substitutions to determine new values of the grid. How can we best model the problem now?",
        "Hint 7 Think about it as a graph where the nodes are rows and columns, and there is an edge between row and column with weight . Substitutions are now just paths on the graph. If we have a path between the node that represents row and column , the xor of the weights in this path represents the value of . What happens if there's more than one path, and two paths have different values?",
        "Hint 8 To continue hint 7, we can deduce that if there is a cycle with xor of weights distinct to in this graph, there would be a contradiction, and arrays and can't exist. How can we check if this is the case?",
        "Hint 9 So lets assume there is no contradiction, ie, all cycles have xor 0. What would be the answer to the problem? We know that if the graph is connected, there exists a path between any two tiles and all the values of the tiles would be determined. So, in how many ways can we make a graph connected?"
    ]
}