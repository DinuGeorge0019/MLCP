{
    "link": "https://codeforces.com//contest/1788/problem/F",
    "problemId": "1767776",
    "problem_idx": "F",
    "shortId": "1788F",
    "contest_number": "1788",
    "problem_submissions": {
        "F": [
            192929323,
            192944697,
            192947972,
            192947585,
            192932378,
            192933439,
            192954011,
            193003406,
            192956724,
            192960550,
            192961107,
            192951794,
            192975658,
            193004734,
            193000099,
            192953392,
            192971360,
            193157814,
            192925320
        ],
        "E": [
            192914791,
            192927615,
            192927556,
            192934590,
            192889260,
            192914229,
            192917631,
            192924823,
            192930869,
            192943768,
            192931128,
            192903797,
            192921531,
            193004713,
            192925760,
            192927056,
            192925608,
            192917135,
            192939766,
            192904744
        ],
        "D": [
            192905122,
            192919739,
            192914784,
            192910155,
            192955552,
            192927341,
            192930171,
            192916598,
            192938656,
            192928104,
            192958419,
            192917109,
            192914086,
            193004704,
            192914561,
            192936729,
            192911543,
            192926368,
            192906600
        ],
        "C": [
            192896754,
            192903243,
            192891543,
            192895173,
            192914614,
            192879823,
            192902740,
            192906894,
            192909558,
            192922632,
            192887922,
            192904823,
            193004689,
            192890036,
            192896137,
            192904090,
            192893814,
            192946267
        ],
        "B": [
            192885653,
            192880984,
            192883005,
            192891309,
            192902865,
            192884638,
            192883772,
            192879778,
            192880217,
            192885391,
            192892745,
            192885295,
            192888862,
            193004678,
            192878668,
            192883423,
            192882746,
            192889266,
            192878522,
            192940441
        ],
        "A": [
            192874357,
            192874502,
            192872686,
            192876928,
            192873442,
            192872154,
            192872535,
            192873765,
            192873755,
            192872250,
            192873788,
            192879133,
            193004648,
            192872439,
            192874189,
            192873135,
            192877988,
            192872696,
            192938096
        ]
    },
    "name": "F. XOR, Tree, and Queries",
    "statement": "You are given a tree of n vertices. The vertices are numbered from 1 to\r\nn.You will need to assign a weight to each edge. Let the weight of the\r\ni-th edge be a_i (1\r\nleq i\r\nleq n-1). The weight of each edge should be an integer between 0 and\r\n2^{30}-1, inclusive.You are given q conditions. Each condition consists\r\nof three integers u, v, and x. This means that the bitwise XOR of all\r\nedges on the shortest path from u to v should be x.Find out if there\r\nexist a_1, a_2,\r\nldots, a_{n-1} that satisfy the given conditions. If yes, print a\r\nsolution such that a_1\r\noplus a_2\r\noplus\r\nldots\r\noplus a_{n-1} is the . Here,\r\noplus denotes the bitwise XOR operation.If there are multiple solutions\r\nsuch that a_1\r\noplus a_2\r\noplus\r\nldots\r\noplus a_{n-1} is the smallest, print any.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ninline int in(){\n    int x;\n    scanf(\"%d\",&x);\n    return x;\n}\nconst int N=3e5+5;\nint n,q;\nint lx[N],ly[N];\nint fa[N],val[N],d[N];\nint a[N],b[N];\nint gf(int x){\n    if(x==fa[x])return x;\n    int f=fa[x];\n    fa[x]=gf(fa[x]);\n    val[x]^=val[f];\n    return fa[x];    \n}\nint main(){\n    n=in(),q=in();\n    for(int i=1;i<n;i++){\n        lx[i]=in(),ly[i]=in();\n        d[lx[i]]++,d[ly[i]]++;\n    }\n    for(int i=1;i<=n;i++){\n        fa[i]=i,val[i]=0;\n    }\n    while(q--){\n        int x=in(),y=in(),z=in();\n        int p=gf(x),q=gf(y);\n        if(p==q){\n            if(val[x]^val[y]^z){puts(\"No\");return 0;}\n            continue;\n        }\n        fa[p]=q,d[q]+=d[p],val[p]=z^val[x]^val[y];\n    }\n    for(int i=1;i<=n;i++){\n        gf(i),b[i]=val[i];\n    }\n    int sum=0;\n    for(int i=1;i<n;i++)\n        sum^=b[lx[i]]^b[ly[i]];\n    for(int i=1;i<=n;i++){\n        if(gf(i)==i&&d[i]%2==1){\n            val[i]=sum;\n            break;\n        }\n    }\n    for(int i=1;i<=n;i++){\n        gf(i),b[i]=val[i];\n    }\n    puts(\"Yes\");\n    for(int i=1;i<n;i++)\n        printf(\"%d \",b[lx[i]]^b[ly[i]]);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. XOR, Tree, and Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/112584",
    "editorial": "Letâs denote as xor of edges in path from node to node . Edges in path\r\nfrom to is (edges in path from to ) + (edges in path from to ) (edges in\r\npath from to )where denotes the least common ancestor of and . Since xor\r\nof two same number is , we can observe that xor of path from to is . If\r\nwe know every for all , weight of edge connecting and is , so deciding\r\nweight of every edge is equivalent to deciding every for .Let be the\r\noriginal tree graph. Letâs make a undirected weighted graph from the\r\ngiven condition. Condition (, , ) makes an edge connecting and with\r\nweight . This edge means that . Now if and are connected by edges in ,\r\nthis means that (xor of edges in path from to ).First, letâs check if it\r\nis possible to make a graph that satisfies the conditions.If is a\r\nconnected graph, we can solve using dfs from node . For edges not used\r\nin dfs (back edges), we have to check if it is valid with the solved .\r\nSpecifically, if there is an edge (, , ), we need to check if .Now letâs\r\nthink when is not a connected graph. By dividing the graph into\r\nconnected components, we can solve if it is impossible to make a graph\r\nthat satisfies the conditions in a same fashion.Now letâs try to\r\nminimize . For edge in , weight of edge is . By substituting into , can\r\nbe written as xor of where node has odd degree. Let the connected\r\ncomponents of be . Pick any vertex in each component . For every vertex\r\nin , is expressed as (xor of edges in path from to ).Letâs define a set\r\nas { has odd number of odd degree vertices}.By substituting into ( (xor\r\nof edges in path in from to )), we can rewrite \"xor of where node has\r\nodd degree\" into where is a constant.If is empty, the answer is constant\r\nand any solution that satisfy the given conditions will be the answer.If\r\nis not empty, set one of to and other as so that is .We can solve the\r\nproblem in .Fast solution might be accepted, including the solution\r\nwhere you divide the weight of edge by bits.\r\n",
    "hint": [
        "Hint 1 Think in term of digits",
        "Hint 2 Can we divide each digit by 2 and then assign in the two numbers."
    ]
}