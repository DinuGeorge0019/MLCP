{
    "link": "https://codeforces.com//contest/1691/problem/D",
    "problemId": "1416260",
    "problem_idx": "D",
    "shortId": "1691D",
    "contest_number": "1691",
    "problem_submissions": {
        "F": [
            159037796,
            159004862,
            159045351,
            159041486,
            159074626,
            159060003,
            159067904,
            159020729,
            159065774,
            159064237,
            159068264,
            159063969,
            159078050,
            159063182,
            159071648,
            159076943,
            159063472,
            159076016,
            159077857
        ],
        "B": [
            159027507,
            159038230,
            158993583,
            158988023,
            158992996,
            158994717,
            158998069,
            158998926,
            158995615,
            158994699,
            158990804,
            158993808,
            158998565,
            158999263,
            158993130,
            158999935,
            158995666,
            158999458,
            158995141
        ],
        "C": [
            159022549,
            159035573,
            159003255,
            159002225,
            159000529,
            159011268,
            159008002,
            159028212,
            159004618,
            159012184,
            158998251,
            159004574,
            159008883,
            159022667,
            159090832,
            159011554,
            159006572,
            159005346,
            159010957,
            159006486
        ],
        "D": [
            159013958,
            159031555,
            159015433,
            159028094,
            159016632,
            159019611,
            159021146,
            159042470,
            159021759,
            159030292,
            159022623,
            159025372,
            159146607,
            159023715,
            159047830,
            159026170,
            159023572,
            159028563,
            159187233,
            159031404,
            159022310
        ],
        "E": [
            159000396,
            159018557,
            159029594,
            159057177,
            159032015,
            159039937,
            159038189,
            159062074,
            159045617,
            159045245,
            159054013,
            159039162,
            209514948,
            209514832,
            209514807,
            159105644,
            159105615,
            159105572,
            159105377,
            159104884,
            159097312,
            159096514,
            159095571,
            159042066,
            159035791,
            159048242,
            159046117,
            159052677,
            159191233,
            159190974,
            159179554,
            159054650,
            159057264
        ],
        "A": [
            158985679,
            159039068,
            158986800,
            158984482,
            158984538,
            158986015,
            158985132,
            158992280,
            158986339,
            158985193,
            158984622,
            158989832,
            158990669,
            158984543,
            158985817,
            158988085,
            158998809,
            158987967
        ]
    },
    "name": "D. Max GEQ Sum",
    "statement": "You are given an array a of n integers. You are asked to find out if the\r\ninequality\r\nmax(a_i, a_{i + 1},\r\nldots, a_{j - 1}, a_{j})\r\ngeq a_i + a_{i + 1} +\r\ndots + a_{j - 1} + a_{j} holds for all pairs of indices (i, j), where 1\r\nleq i\r\nleq j\r\nleq n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == '-', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, a[N], lg[N];\npii st[20][N];\nbool fl;\n\nstruct node {\n\tll s, pre, suf;\n};\n\npii getmax(int l, int r) {\n\tint k = lg[r - l + 1];\n\treturn max(st[k][l], st[k][r - (1 << k) + 1]);\n}\n\nnode check(int l, int r) {\n\tif(l > r) return node{ 0, 0, 0 };\n\tif(l == r) return (node){ a[l], max(a[l], 0), max(a[l], 0) }; int p = getmax(l, r).se;\n\tnode ls = check(l, p - 1), rs = check(p + 1, r);\n\tnode ret; ret.s = ls.s + rs.s + a[p]; ret.pre = max(ls.pre, ls.s + a[p] + rs.pre); ret.suf = max(rs.suf, rs.s + a[p] + ls.suf);\n\tfl |= ls.suf + rs.pre + a[p] > a[p]; return ret;\n}\n\nvoid solve() {\n\tn = in; rep(i, 1, n) a[i] = in;\n\trep(i, 1, n) st[0][i] = { a[i], i };\n\trep(i, 2, n) lg[i] = lg[i >> 1] + 1;\n\trep(i, 1, lg[n])\n\t\trep(j, 1, n - (1 << i) + 1)\n\t\tst[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);\n\tfl = 0; check(1, n);\n\tputs(fl ? \"NO\" : \"YES\");\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "divide and conquer",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Max GEQ Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/103212",
    "editorial": "Letâs look at the problem from the perspective of each . We want to\r\ncheck whether the sum of the subarrays, where is the maximum element,\r\nexceeds or not.Firstly, we must find out in which subarrays is the\r\nmaximum. This involves finding the previous greater element index and\r\nthe next greater element index of , which can be done for all indices in\r\nusing stacks. Take these indices as , . After computing this for every\r\nindex, weâll know that is max in subarrays with starting index and\r\nending index .Take , which represents the sum of a subarray which starts\r\nat index and ends at index , where , . If , then , giving us . Hence, at\r\nleast one of the subarrays, or has a sum greater than , which implies\r\nthat one of subarrays , has sum greater than , so only checking\r\nsubarrays which start or end at index suffices.Therefore, for an index ,\r\nwe need to check subarrays , and subarrays . Since we just care if any\r\none of them exceed , finding the max of them is enough. This reduces to\r\nmaking a range query over the prefix sums and one over the suffix sums.\r\nThe query on prefix sums would look likeWhere returns the max prefix sum\r\nin the given range. This query can be done using a segment tree in . If\r\nany of the queries is true, then we just have to output \"NO\", else\r\noutput \"YES\".With this we get the time complexity of the solution as .\r\n",
    "hint": [
        "Hint 1 If we have a list of subarrays where the element at index is the max, which subarrays should we check to be sufficient?",
        "Hint 2 Checking subarrays which end or start at index is sufficient, so we can optimize our solution with this observation as the basis."
    ]
}