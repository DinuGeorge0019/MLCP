{
    "link": "https://codeforces.com//contest/1153/problem/E",
    "problemId": "329970",
    "problem_idx": "E",
    "shortId": "1153E",
    "contest_number": "1153",
    "problem_submissions": {
        "F": [
            52702167,
            52706102,
            52706128,
            52712612,
            52712916,
            52713472,
            52705273,
            53020024
        ],
        "B": [
            52696113,
            52686055,
            52686525,
            52695492,
            52689812,
            52686724,
            52686280,
            52688127,
            52685475,
            52701491,
            52686741,
            52698339,
            52691737,
            52687040,
            52687523,
            52688787,
            52686777,
            52686537,
            52688504
        ],
        "E": [
            52693078,
            52699456,
            52700287,
            52698093,
            52707544,
            52707213,
            52699436,
            52799036,
            52699341,
            52698614,
            52704976,
            52690529,
            52703713,
            52700978,
            52703569,
            52699263,
            52702855,
            52704578
        ],
        "C": [
            52688281,
            52690605,
            52689780,
            52702384,
            52693171,
            52696923,
            52689825,
            52696486,
            52688289,
            52687066,
            52689512,
            52696924,
            52687069,
            52688673,
            52691802,
            52692527,
            52691364,
            52690866,
            52691574
        ],
        "D": [
            52686405,
            52692724,
            52692621,
            52691138,
            52695645,
            52702315,
            52692971,
            52694653,
            52693169,
            52691270,
            52695539,
            52695198,
            52699214,
            52692631,
            52695518,
            52703264,
            52696334,
            52697661,
            52695431
        ],
        "A": [
            52684329,
            52684726,
            52684448,
            52687427,
            52684995,
            52684651,
            52684577,
            52684221,
            52684289,
            52684251,
            52684828,
            52699079,
            52689885,
            52684309,
            52684805,
            52684271,
            52684301,
            52684354,
            52684338
        ]
    },
    "name": "E. Serval and Snake",
    "statement": "Now Serval is a senior high school student in Japari Middle School.\r\nHowever, on the way to the school, he must go across a pond, in which\r\nthere is a dangerous snake. The pond can be represented as a n\r\ntimes n grid. The snake has a head and a tail in different cells, and\r\nits body is a series of adjacent cells connecting the head and the tail\r\nwithout self-intersecting. If Serval hits its head or tail, the snake\r\nwill bite him and he will die.Luckily, he has a special device which can\r\nanswer the following question: you can pick a rectangle, it will tell\r\nyou the number of times one needs to cross the border of the rectangle\r\nwalking cell by cell along the snake from the head to the tail. The\r\npictures below show a possible snake and a possible query to it, which\r\nwill get an answer of 4. Today Serval got up too late and only have time\r\nto make 2019 queries. As his best friend, can you help him find the\r\npositions of the head and the tail?Note that two cells are adjacent if\r\nand only if they have a common edge in the grid, and a snake can have a\r\nbody of length 0, that means it only has adjacent head and tail.Also\r\nnote that the snake is sleeping, so it won\u2019t move while Serval using his\r\ndevice. And what\u2019s obvious is that the snake position does not depend on\r\nyour queries.\r\n",
    "solutions": [
        "//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e3;\n\nint n;\nbool sp;\n\nint qry(int x1, int y1, int x2, int y2) {\n\tif(sp) {\n\t\tswap(x1, y1);\n\t\tswap(x2, y2);\n\t}\n\tcout << \"? \" << x1+1 << \" \" << y1+1 << \" \" << x2+1 << \" \" << y2+1 << endl;\n\tint a;\n\tcin >> a;\n\treturn a&1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\tfor(int it=0; it<2;  ++it) {\n\t\tint i1=-1, i2=-1, s=0;\n\t\tfor(int i=0; i<n-1; ++i) {\n\t\t\tint a=qry(i, 0, i, n-1);\n\t\t\tif(a) {\n\t\t\t\tif(~i1)\n\t\t\t\t\ti2=i;\n\t\t\t\telse\n\t\t\t\t\ti1=i;\n\t\t\t}\n\t\t\ts^=a;\n\t\t}\n\t\tif(s)\n\t\t\ti2=n-1;\n\t\tif(~i1) {\n\t\t\tint lb=0, rb=n-1;\n\t\t\twhile(lb<rb) {\n\t\t\t\tint mb=(lb+rb)/2;\n\t\t\t\tif(qry(i1, 0, i1, mb))\n\t\t\t\t\trb=mb;\n\t\t\t\telse\n\t\t\t\t\tlb=mb+1;\n\t\t\t}\n\t\t\tint a1=lb;\n\n\t\t\tlb=0, rb=n-1;\n\t\t\twhile(lb<rb) {\n\t\t\t\tint mb=(lb+rb)/2;\n\t\t\t\tif(qry(i2, 0, i2 ,mb))\n\t\t\t\t\trb=mb;\n\t\t\t\telse\n\t\t\t\t\tlb=mb+1;\n\t\t\t}\n\t\t\tint a2=lb;\n\n\t\t\tif(sp) {\n\t\t\t\tswap(i1, a1);\n\t\t\t\tswap(i2, a2);\n\t\t\t}\n\t\t\tcout << \"! \" << i1+1 << \" \" << a1+1 << \" \" << i2+1 << \" \" << a2+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tsp=true;\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "interactive"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Serval and Snake.json",
    "editorial_link": "https://codeforces.com/blog/entry/66539",
    "editorial": "If the answer to a rectangle\nis odd, there must be exactly one head or tail in that rectangle.\nOtherwise, there must be even number ( or ) of head and tail in the\ngiven rectangle.We make queries for each of the columns except the last\none, then we can know for each column whether there are odd number of\nhead and tails in it or not. Because the sum is even, we can know the\nparity of the last column.If the head and tail are in different columns,\nwe can find two columns with odd answer and get them. Then we can do\nbinary search for each of those two columns separately and get the\nanswer in no more than queries totally. If the head and tail are in the\nsame column, we will get all even answer and know that fact. Then we\napply the same method for rows. Then we can just do binary search for\none of the rows, and use the fact that the other is in the same column\nas this one. In this case, we have made no more than queries.\n"
}