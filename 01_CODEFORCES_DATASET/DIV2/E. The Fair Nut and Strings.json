{
    "link": "https://codeforces.com//contest/1084/problem/E",
    "problemId": "268419",
    "problem_idx": "E",
    "shortId": "1084E",
    "contest_number": "1084",
    "problem_submissions": {
        "E": [
            46871140,
            46872149,
            46875669,
            46875724,
            46874048,
            46872086,
            46872648,
            46877520,
            46878278,
            46874461,
            46878594,
            46878417,
            46876583,
            46878192,
            46874895,
            46876700,
            46877996,
            46876441,
            46873571,
            46873367
        ],
        "D": [
            46865692,
            46866251,
            46867303,
            46864932,
            46866831,
            46870175,
            46871027,
            46867359,
            46864028,
            46867931,
            46867474,
            46868146,
            46871839,
            46871054,
            46866346,
            46870635,
            46870859,
            46868272,
            46870701,
            46867072
        ],
        "C": [
            46862188,
            46862548,
            46862310,
            46864314,
            46859780,
            46865533,
            46863590,
            46862823,
            46859756,
            46864914,
            46865680,
            46864482,
            46863554,
            46862055,
            46865588,
            46867219,
            46865294,
            46862436,
            46861206,
            46862144
        ],
        "B": [
            46860593,
            46860115,
            46860565,
            46859288,
            46868191,
            46861225,
            46861292,
            46860596,
            46860732,
            46863777,
            46862311,
            46860318,
            46861810,
            46860088,
            46859027,
            46862964,
            46862212,
            46860437,
            46875865,
            46882320
        ],
        "A": [
            46860045,
            46859437,
            46859480,
            46861802,
            46870580,
            46859672,
            46860117,
            46859399,
            46861955,
            46862963,
            46861395,
            46859357,
            46859117,
            46859254,
            46859455,
            46860467,
            46859673,
            46859251,
            46859051,
            46859322
        ]
    },
    "name": "E. The Fair Nut and Strings",
    "statement": "Recently, the Fair Nut has written k strings of length n, consisting of\r\nletters \"\" and \"\". He calculated c the number of strings that are\r\nprefixes of at least one of the written strings. .Then, he lost his\r\nsheet with strings. He remembers that all written strings were\r\nlexicographically than string s and than string t. He is interested:\r\nwhat is the maximum value of c that he could get.A string a is\r\nlexicographically smaller than a string b if and only if one of the\r\nfollowing holds: a is a prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    ll n, k; cin >> n >> k;\n    string lo, hi; cin >> lo >> hi;\n\n    vl levels;\n    ll dif = 0;\n    ll sumSF = 0;\n    ll sum = 0;\n    F0R(i, n) {\n        dif = dif * 2;\n        if (lo[i] == 'b') dif--;\n        if (hi[i] == 'b') dif++;\n\n        levels.pb(dif+1-sumSF);\n        sumSF += levels[i];\n        if (k > levels[i]) {\n            sum += (n - i) * levels[i];\n            k -= levels[i];\n        } else {\n            sum += (n - i) * k;\n            k = 0;\n            break;\n        }\n    }\n\n    cout << sum << endl;\n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The Fair Nut and Strings.json",
    "editorial_link": "https://codeforces.com/blog/entry/63753?locale=en",
    "editorial": "If s\n and t\n are equal, answer is n\n.\n\nLet's cut common prefix of s\n and t\n, and increase answer to its length. Now s\n starts from \"a\" and t\n starts from \"b\". Let m\n is new lengths of s\n and t\n. If string s\n weren't written, we can change the lexicographically smallest string to s\n, and c\n will not decrease. We can do the same thing with t\n. Now s\n and t\n are in answer. We can increase answer by 2?m\n, decrease k\n by 2 and don't count strings, which are prefixes of s\n and t\n, while calculating c\n. Let's divide strings in answer into groups 혰 two strings are in one group if and only if their first characters are equal and their largest common prefixes with s\n or t\n (it depends on the first character) are equal. Let length of group be m?lcp\n, where lcp\n 혰 length of this common prefix.\n\nc\n is equal to the number of vertexes in trie on written strings. If we have fixed l\n 혰 number of strings, which will belong to some group, we have to maximize size of set of vertexes, which is union of l\n ways in full binary tree with height h\n, equals to length of group. It can be proved by induction, that the first way increases size of set by h\n, the second by h?1\n, next 2 ways by h?2\n, next 4 ways by h?3\n, etc. We can create array p\n, where pi\n - how many ways increase answer by h?i\n. Note that these values are additive - if we have two independent binary trees and want to distribute some number of ways between them, we can sum their arrays (and it is how prove the previous fact).\n\nWe have O(n)\n independent groups, and we want to sum their arrays fast. Every binary tree increases values on suffix by [1,1,2,4,...]\n. Let's forget about the first 1\n and add it in the end. Then, put 1\n to the second position in suffix, and add 2?ai\n to ai+1\n for 1?i?n?1\n in increasing order, where a\n 혰 array, which we want to get. Note that values in this array could be very big, but if we change values, bigger than k\n, to k\n, answer will not change (because there are only k\n ways).\n\nTo calculate answer, let's take the prefix with sum k\n (if there are no such prefix, we take the first prefix with sum, which is bigger than k\n and decrease last element), fill other elements with 0\n. Answer will be equal sum a[i]?i\n for 1?i?m\n.",
    "hint": []
}