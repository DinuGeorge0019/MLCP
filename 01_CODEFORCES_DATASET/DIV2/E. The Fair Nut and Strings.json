{"link": "https://codeforces.com//contest/1084/problem/E", "problemId": "268419", "problem_idx": "E", "shortId": "1084E", "contest_number": "1084", "problem_submissions": {"E": [46871140, 46872149, 46875669, 46875724, 46874048, 46872086, 46872648, 46877520, 46878278, 46874461, 46878594, 46878417, 46876583, 46878192, 46874895, 46876700, 46877996, 46876441, 46873571, 46873367], "D": [46865692, 46866251, 46867303, 46864932, 46866831, 46870175, 46871027, 46867359, 46864028, 46867931, 46867474, 46868146, 46871839, 46871054, 46866346, 46870635, 46870859, 46868272, 46870701, 46867072], "C": [46862188, 46862548, 46862310, 46864314, 46859780, 46865533, 46863590, 46862823, 46859756, 46864914, 46865680, 46864482, 46863554, 46862055, 46865588, 46867219, 46865294, 46862436, 46861206, 46862144], "B": [46860593, 46860115, 46860565, 46859288, 46868191, 46861225, 46861292, 46860596, 46860732, 46863777, 46862311, 46860318, 46861810, 46860088, 46859027, 46862964, 46862212, 46860437, 46875865, 46882320], "A": [46860045, 46859437, 46859480, 46861802, 46870580, 46859672, 46860117, 46859399, 46861955, 46862963, 46861395, 46859357, 46859117, 46859254, 46859455, 46860467, 46859673, 46859251, 46859051, 46859322]}, "name": "E. The Fair Nut and Strings", "statement": "Recently, the Fair Nut has written k strings of length n, consisting of\r\nletters \"\" and \"\". He calculated c the number of strings that are\r\nprefixes of at least one of the written strings. .Then, he lost his\r\nsheet with strings. He remembers that all written strings were\r\nlexicographically than string s and than string t. He is interested:\r\nwhat is the maximum value of c that he could get.A string a is\r\nlexicographically smaller than a string b if and only if one of the\r\nfollowing holds: a is a prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    ll n, k; cin >> n >> k;\n    string lo, hi; cin >> lo >> hi;\n\n    vl levels;\n    ll dif = 0;\n    ll sumSF = 0;\n    ll sum = 0;\n    F0R(i, n) {\n        dif = dif * 2;\n        if (lo[i] == 'b') dif--;\n        if (hi[i] == 'b') dif++;\n\n        levels.pb(dif+1-sumSF);\n        sumSF += levels[i];\n        if (k > levels[i]) {\n            sum += (n - i) * levels[i];\n            k -= levels[i];\n        } else {\n            sum += (n - i) * k;\n            k = 0;\n            break;\n        }\n    }\n\n    cout << sum << endl;\n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343"], "input": "", "output": "", "tags": ["greedy", "strings"], "dificulty": "2000", "interactive": false}