{
    "link": "https://codeforces.com//contest/1934/problem/D2",
    "problemId": "2505363",
    "problem_idx": "D2",
    "shortId": "1934D2",
    "contest_number": "1934",
    "problem_submissions": {
        "D2": [
            249138861,
            249138286,
            249148347,
            249142453,
            249157574,
            249154795,
            249156400,
            249152916,
            249153265,
            249152468,
            249159235,
            249151373,
            249157739,
            249158790,
            249158719,
            249157715,
            249151531,
            249154568
        ],
        "D1": [
            249125699,
            249128677,
            249134651,
            249133932,
            249131438,
            249132804,
            249141726,
            249142358,
            249133864,
            249137039,
            249209635,
            249137420,
            249137703,
            249134521,
            249138551,
            249144781,
            249136421,
            249139126,
            249137860
        ],
        "C": [
            249115447,
            249119119,
            249121601,
            249125691,
            249121785,
            249119998,
            249118653,
            249123649,
            249122623,
            249127946,
            249126111,
            249128427,
            249128773,
            249122463,
            249117989,
            249122384,
            249127040,
            249126459
        ],
        "B": [
            249103913,
            249106551,
            249108288,
            249115212,
            249104799,
            249109733,
            249104490,
            249108744,
            249111760,
            249108303,
            249108953,
            249111319,
            249106725,
            249111924,
            249107412,
            249112945,
            249107802,
            249115127
        ],
        "A": [
            249100199,
            249101211,
            249103188,
            249100104,
            249099925,
            249108944,
            249100108,
            249104411,
            249104537,
            249100853,
            249102757,
            249099965,
            249100710,
            249100333,
            249102042,
            249101590,
            249101009,
            249100585
        ],
        "E": [
            249308601
        ]
    },
    "name": "D2. XOR Break — Game Version",
    "statement": "Alice and Bob are playing a game. The game starts with a positive\r\ninteger n, with players taking turns. On each turn of the game, the\r\nfollowing sequence of events takes place: The player having the integer\r\np breaks it into two integers p_{1} and p_{2}, where 0\r\nlt p_{1}\r\nlt p, 0\r\nlt p_{2}\r\nlt p and p_{1}\r\noplus p_{2} = p. If no such p_{1}, p_{2} exist, the player loses.\r\nOtherwise, the opponent does either select the integer p_{1} or p_{2}.\r\nThe game continues with the selected integer. The opponent will try to\r\nbreak it. As Alice, your goal is to win. You can execute a maximum of 63\r\nbreak operations. You have the choice to play first or second. The\r\nsystem will act for Bob.Here\r\noplus denotes the bitwise XOR operation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n//#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    //IOS;\n\n\n\n    int T; cin >> T;\n    while(T--){\n        int n; cin >> n;\n        \n        if(__builtin_popcountll(n) % 2){\n            cout << \"second\" << endl;\n            while(1){\n                int ret1, ret2; cin >> ret1 >> ret2;\n                if(ret1 <= 0 && ret2 <= 0) break;\n                int cnt1 = __builtin_popcountll(ret1);\n                int cnt2 = __builtin_popcountll(ret2);\n                if(cnt1 % 2) swap(ret1, ret2);\n                int first = 63 - __builtin_clzll(ret1);\n                cout << (1ll << first) << ' ' << ret1 - (1ll << first) << endl;\n            }\n        }   \n        else{\n            cout << \"first\" << endl;\n            int ffirst = 63 - __builtin_clzll(n);\n            cout << (1ll << ffirst) << ' ' << n - (1ll << ffirst) << endl;\n            while(1){\n                int ret1, ret2; cin >> ret1 >> ret2;\n                if(ret1 <= 0 && ret2 <= 0) break;\n                int cnt1 = __builtin_popcountll(ret1);\n                int cnt2 = __builtin_popcountll(ret2);\n                if(cnt1 % 2) swap(ret1, ret2);\n                int first = 63 - __builtin_clzll(ret1);\n                cout << (1ll << first) << ' ' << ret1 - (1ll << first) << endl;\n            }\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "games",
        "greedy",
        "interactive"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D2. XOR Break — Game Version.json",
    "editorial_link": "https://codeforces.com//blog/entry/126423",
    "editorial": "Fact 1: If p1\n has an odd bit count, then it can only be broken into two numbers such that one has an odd bit count and the other has an even bit count.\n\nFact 2: If either p1\n or p2\n has an even bit count, then this is a winning state.\n\nReason : If either p1\n or p2\n has an even bit count, without loss of generality, assume it's p1\n. Then break it into 2msb of p1\n and p1?2msb of p1\n, where msb\n is the most significant bit.\n\nIf the opponent chooses 2msb of p1\n, they instantly lose (using Hint 1\n), so they are forced to choose the other number with an odd bit count. From Fact 1\n, we can conclude that in the next turn, the state will remain conserved for the current player.\n\nBecause we eliminate the most significant bit in every query, this game will go on for at most 60\n turns for the player who reached this position first. At one point, the player who is at this state will have a number with two set bits.\n\nHence, from Hint 2\n, we can say this player will win. So, as Alice, you will start first if n\n has an even number of bits and start second if it has an odd number of bits. Proceed using the strategy discussed above. So as Alice you have will start first if n\n has even number of bits and start second if it has odd number of bits. Any proceed using the strategy discussed above.",
    "hint": [
        "Hint 1 If both and are perfect powers of , it is a losing state since you cannot perform a break operation on either of those.",
        "Hint 2 If either or has a bit count of , then this is a winning state. Reason You can force your opponent into the state described in Hint using the number which has bitcount."
    ]
}