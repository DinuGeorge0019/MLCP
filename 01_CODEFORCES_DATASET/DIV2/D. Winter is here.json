{"link": "https://codeforces.com//contest/839/problem/D", "problemId": "117995", "problem_idx": "D", "shortId": "839D", "contest_number": "839", "problem_submissions": {"E": [29403824, 29409457, 29402914, 29408405, 29406327, 29410552, 29409014, 29406788, 29421538], "D": [29392016, 29388512, 29406607, 29404686, 29398161, 29392526, 29399719, 29390719, 29400075, 29403406, 29402721, 29399071, 29398521, 29424440, 29406196, 29459720, 29400759, 29408213, 29406118, 29386786, 29408520], "B": [29387404, 29386986, 29393659, 29399860, 29418355, 29403115, 29393756, 29389053, 29386717, 29387372, 29401456, 29401071, 29391332, 29403433, 29397466, 29394616, 29424848, 29400078], "C": [29383480, 29380903, 29399289, 29392182, 29388563, 29393777, 29384539, 29382506, 29387310, 29394730, 29389857, 29391781, 29393376, 29394828, 29384424, 29392243, 29387122, 29397138, 29382174, 29387027], "A": [29379625, 29382369, 29383241, 29383804, 29379670, 29380225, 29381733, 29394107, 29380558, 29383606, 29380710, 29381324, 29380863, 29382906, 29380087, 29384719, 29381302, 29383997, 29392184, 29388770]}, "name": "D. Winter is here", "statement": "Winter is here at the North and the White Walkers are close. John Snow\r\nhas an army consisting of soldiers. While the rest of the world is\r\nfighting for the Iron Throne, he is going to get ready for the attack of\r\nthe White Walkers.He has created a method to know how strong his army\r\nis. Let the -th soldier s strength be . For some he calls a clan if and\r\n. He calls the strength of that clan . Then he defines the strength of\r\nhis army by the sum of strengths of all possible clans.Your task is to\r\nfind the strength of his army. As the number may be very large, you have\r\nto print it modulo ().Greatest common divisor (gcd) of a sequence of\r\nintegers is the maximum possible integer so that each element of the\r\nsequence is divisible by it.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=1000*1007;\nconst int D=1000*1000;\nconst long long MOD=1000*1000*1000+7;\n\nint n;\n\nlong long nad[N];\n\nlong long res;\n\nlong long pot[N];\n\nlong long f(long long v)\n{\n    if (!v)\n        return 0;\n    return (pot[v-1]*v)%MOD;\n}\n\nint main()\n{\n    pot[0]=1;\n    for (int i=1; i<=D; i++)\n        pot[i]=(pot[i-1]*2)%MOD;\n    scanf(\"%d\", &n);\n    for (int i=1; i<=n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        nad[x]++;\n    }\n    for (int i=1; i<=D; i++)\n        for (int j=i*2; j<=D; j+=i)\n            nad[i]+=nad[j];\n    for (int i=1; i<=D; i++)\n    {\n        nad[i]=f(nad[i]);\n    }\n    for (int i=D; i>1; i--)\n    {\n        for (int j=2*i; j<=D; j+=i)\n            nad[i]=(nad[i]+MOD-nad[j])%MOD;\n        //nad[i]=(nad[i]-1+MOD)%MOD;\n        res+=nad[i]*i;\n        res%=MOD;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "math", "number theory"], "dificulty": "2200", "interactive": false}