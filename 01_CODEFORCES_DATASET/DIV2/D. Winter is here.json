{
    "link": "https://codeforces.com//contest/839/problem/D",
    "problemId": "117995",
    "problem_idx": "D",
    "shortId": "839D",
    "contest_number": "839",
    "problem_submissions": {
        "E": [
            29403824,
            29409457,
            29402914,
            29408405,
            29406327,
            29410552,
            29409014,
            29406788,
            29421538
        ],
        "D": [
            29392016,
            29388512,
            29406607,
            29404686,
            29398161,
            29392526,
            29399719,
            29390719,
            29400075,
            29403406,
            29402721,
            29399071,
            29398521,
            29424440,
            29406196,
            29459720,
            29400759,
            29408213,
            29406118,
            29386786,
            29408520
        ],
        "B": [
            29387404,
            29386986,
            29393659,
            29399860,
            29418355,
            29403115,
            29393756,
            29389053,
            29386717,
            29387372,
            29401456,
            29401071,
            29391332,
            29403433,
            29397466,
            29394616,
            29424848,
            29400078
        ],
        "C": [
            29383480,
            29380903,
            29399289,
            29392182,
            29388563,
            29393777,
            29384539,
            29382506,
            29387310,
            29394730,
            29389857,
            29391781,
            29393376,
            29394828,
            29384424,
            29392243,
            29387122,
            29397138,
            29382174,
            29387027
        ],
        "A": [
            29379625,
            29382369,
            29383241,
            29383804,
            29379670,
            29380225,
            29381733,
            29394107,
            29380558,
            29383606,
            29380710,
            29381324,
            29380863,
            29382906,
            29380087,
            29384719,
            29381302,
            29383997,
            29392184,
            29388770
        ]
    },
    "name": "D. Winter is here",
    "statement": "Winter is here at the North and the White Walkers are close. John Snow\r\nhas an army consisting of soldiers. While the rest of the world is\r\nfighting for the Iron Throne, he is going to get ready for the attack of\r\nthe White Walkers.He has created a method to know how strong his army\r\nis. Let the -th soldier s strength be . For some he calls a clan if and\r\n. He calls the strength of that clan . Then he defines the strength of\r\nhis army by the sum of strengths of all possible clans.Your task is to\r\nfind the strength of his army. As the number may be very large, you have\r\nto print it modulo ().Greatest common divisor (gcd) of a sequence of\r\nintegers is the maximum possible integer so that each element of the\r\nsequence is divisible by it.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=1000*1007;\nconst int D=1000*1000;\nconst long long MOD=1000*1000*1000+7;\n\nint n;\n\nlong long nad[N];\n\nlong long res;\n\nlong long pot[N];\n\nlong long f(long long v)\n{\n    if (!v)\n        return 0;\n    return (pot[v-1]*v)%MOD;\n}\n\nint main()\n{\n    pot[0]=1;\n    for (int i=1; i<=D; i++)\n        pot[i]=(pot[i-1]*2)%MOD;\n    scanf(\"%d\", &n);\n    for (int i=1; i<=n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        nad[x]++;\n    }\n    for (int i=1; i<=D; i++)\n        for (int j=i*2; j<=D; j+=i)\n            nad[i]+=nad[j];\n    for (int i=1; i<=D; i++)\n    {\n        nad[i]=f(nad[i]);\n    }\n    for (int i=D; i>1; i--)\n    {\n        for (int j=2*i; j<=D; j+=i)\n            nad[i]=(nad[i]+MOD-nad[j])%MOD;\n        //nad[i]=(nad[i]-1+MOD)%MOD;\n        res+=nad[i]*i;\n        res%=MOD;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Winter is here.json",
    "editorial_link": "https://codeforces.com//blog/entry/53815",
    "editorial": ":Let be the number of such s that is divisible by . Also let be -th\r\nprime number.Let be for an arbitrary set with members(something like the\r\nsum of strengths of all possible subsets, but replace with the of the\r\nsequence)Finally let be the sum of strengths of clans which .Now we can\r\ncalculate by Inclusion exclusion principle :Because includes all\r\npossible clans that their members are all multiples of , not the ones\r\nwith equal to .Now, we can do the above calculation by a foor-loop\r\nthrough the multiples of .So all we have to do , is to calculate very\r\nfast. Actually because ::Let be the number of such s that is divisible\r\nby . Than is count of soliders with strength of . Let be in clans with .\r\nTo find let\u00e2\u0080\u0099s understand, how to find count of people in clans, in which\r\nevery number is divided by . If , it\u00e2\u0080\u0099sLet\u00e2\u0080\u0099s calculate from the end. Then\r\n.Answer for problem\u00e2\u0080\u0099s question is .Asymptotics of solution is , where is\r\nmaximal value of .\r\n"
}