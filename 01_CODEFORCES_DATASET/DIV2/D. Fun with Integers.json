{
    "link": "https://codeforces.com//contest/1062/problem/D",
    "problemId": "254597",
    "problem_idx": "D",
    "shortId": "1062D",
    "contest_number": "1062",
    "problem_submissions": {
        "E": [
            45734560,
            45726248,
            45732249,
            45733619,
            45730195,
            45731475,
            45731239,
            45726325,
            45734429,
            45732687,
            45728510,
            45736860,
            45736172,
            45733982,
            45737130,
            45738771,
            45733014,
            45736808,
            45722467,
            45738588
        ],
        "D": [
            45726634,
            45730736,
            45724741,
            45725065,
            45723696,
            45724136,
            45725257,
            45730810,
            45727060,
            45726669,
            45731523,
            45727302,
            45728487,
            45722718,
            45726364,
            45726645,
            45723445,
            45727784,
            45736639,
            45727419
        ],
        "C": [
            45721626,
            45717978,
            45722013,
            45722920,
            45725107,
            45723347,
            45723217,
            45731817,
            45722296,
            45725538,
            45721997,
            45722995,
            45721715,
            45726048,
            45722887,
            45716980,
            45725662,
            45723495,
            45730894,
            45720161
        ],
        "B": [
            45719368,
            45728287,
            45719414,
            45719514,
            45718037,
            45718991,
            45720410,
            45716157,
            45718932,
            45720927,
            45719221,
            45719468,
            45718546,
            45719917,
            45718393,
            45721972,
            45719490,
            45718006,
            45726769,
            45717530
        ],
        "A": [
            45714856,
            45714050,
            45715684,
            45718665,
            45717504,
            45716696,
            45714768,
            45714213,
            45714103,
            45715993,
            45714126,
            45714813,
            45714920,
            45732371,
            45714819,
            45723775,
            45732706,
            45719793,
            45724251,
            45714073
        ],
        "F": [
            45751027,
            45989276,
            46585917
        ]
    },
    "name": "D. Fun with Integers",
    "statement": "You are given a positive integer n greater or equal to 2. For every pair\r\nof integers a and b (2\r\nle |a|, |b|\r\nle n), you can transform a into b if and only if there exists an integer\r\nx such that 1 < |x| and (a\r\ncdot x = b or b\r\ncdot x = a), where |x| denotes the absolute value of x.After such a\r\ntransformation, your score increases by |x| points and you are to\r\ntransform a into b nor b into a anymore.Initially, you have a score of\r\n0. You can start at any integer and transform it as many times as you\r\nlike. What is the maximum score you can achieve?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main () {\n\tint n;\n\tcin >> n;\n\tll ans=0;\n\tfor (int i=2;i<=n;++i) {\n\t\tll tmp = n/i;\n\t\tans += ((tmp*(tmp+1)/2)-1)*4;\n\t}\n\tcout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Fun with Integers.json",
    "editorial_link": "https://codeforces.com/blog/entry/63199",
    "editorial": "For every integer , let\u00e2\u0080\u0099s call the set of integers that are able to be\r\ntransformed into . As you can see, if could be transformed into then\r\ncould also be transformed into . Therefore is always even. Let\u00e2\u0080\u0099s build a\r\ngraph consists of nodes, numbered through (except for , , and ). There\r\nis an weighted undirected edge between node and if and only if can be\r\ntransformed into . The weight of the edge is the score of the\r\ntransformation. Every node in the graph has an even degree so you can\r\nsplit the graph into some connected components so that each components\r\nis an Euler circuit (a circuit that contains all the edges). Therefore\r\nyou just need to find all those Euler circuits and maximize your score.\r\nMoreover, you can see that, if an integer can be transformed into then\r\nand are in the same component. Proof: Suppose , there exists an integer\r\n. If then it is proved, otherwise there exists an integer . and are in\r\nthe same component so and are also in the same component. Therefore, if\r\nwe ignore all the nodes that have no edges attached to it, the graph\r\nwill be connected. So you need to simply get the sum of all the weights\r\nof the edges.The complexity is since the number of edges can go up to .\r\n"
}