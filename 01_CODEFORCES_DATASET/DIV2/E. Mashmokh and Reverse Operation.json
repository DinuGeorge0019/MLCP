{
    "link": "https://codeforces.com//contest/415/problem/E",
    "problemId": "7965",
    "problem_idx": "E",
    "shortId": "415E",
    "contest_number": "415",
    "problem_submissions": {
        "E": [
            6282751,
            6280846,
            6282282,
            6286487,
            6283817,
            6287156,
            6320994,
            6288671
        ],
        "D": [
            6277177,
            6279173,
            6277815,
            6279500,
            6277505,
            6284116,
            6273626,
            6278251,
            6275629,
            6275462,
            6278986,
            6278820,
            6280628,
            6278665,
            6278315,
            6277966,
            6275621
        ],
        "C": [
            6275857,
            6276048,
            6277243,
            6278598,
            6275040,
            6280098,
            6277360,
            6272901,
            6273971,
            6273350,
            6277335,
            6277637,
            6277238,
            6276999,
            6276910,
            6279279,
            6287788,
            6281779
        ],
        "B": [
            6273086,
            6282657,
            6284373,
            6274868,
            6290846,
            6289241,
            6277166,
            6275333,
            6277241,
            6277862,
            6280443,
            6273390,
            6274929,
            6273119,
            6274638,
            6273877,
            6275440,
            6273227
        ],
        "A": [
            6271671,
            6271735,
            6271691,
            6272218,
            6274049,
            6272011,
            6271909,
            6274777,
            6278932,
            6278324,
            6271746,
            6271789,
            6271676,
            6271709,
            6271686,
            6271841,
            6272117
        ]
    },
    "name": "E. Mashmokh and Reverse Operation",
    "statement": "You have an array of length and queries on it. The -th query is\r\ndescribed by an integer . In order to perform the -th query you must:\r\nsplit the array into parts, where each part is a subarray consisting of\r\nnumbers; the -th subarray should contain the elements ; reverse each of\r\nthe subarrays; join them into a single array in the same order (this\r\narray becomes new array ); output the number of inversions in the new .\r\nGiven initial array and all the queries. Answer all the queries. Please,\r\nnote that the changes from some query is saved for further queries.\r\n",
    "solutions": [
        "#include <stdio.h>\nint n, s, m, a[2000000], at[2000000], q[1000000];\nlong long sum[21], same[21];\nlong long V(int x)\n{\n\treturn (long long)x * (x - 1) / 2;\n}\nlong long Merge(int l, int r, int t)\n{\n\tif(l == r)\n\t\treturn 0;\n\tint mid = (l + r) / 2;\n\tlong long ret = Merge(l, mid, t - 1) + Merge(mid + 1, r, t - 1);\n\tfor(int i = l, j = mid + 1, k = l; i <= mid || j <= r; k++)\n\t{\n\t\tif(i > mid)\n\t\t\tat[k] = a[j++];\n\t\telse if(j > r)\n\t\t\tat[k] = a[i++];\n\t\telse if(a[i] <= a[j])\n\t\t\tat[k] = a[i++];\n\t\telse\n\t\t\tat[k] = a[j++], ret += mid - i + 1;\n\t}\n\tfor(int i = l; i <= r; i++)\n\t\ta[i] = at[i];\n\tfor(int i = l, j = l + 1; i <= r; i = j++)\n\t{\n\t\twhile(j <= r && a[j] == a[i])\n\t\t\tj++;\n\t\tsame[t] += V(j - i);\n\t}\n\tsum[t] += ret;\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\", &n), s = 1 << n;\n\tfor(int i = 0; i < s; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tscanf(\"%d\", &m);\n\tfor(int i = 0; i < m; i++)\n\t\tscanf(\"%d\", &q[i]);\n\tMerge(0, s - 1, n);\n\tfor(int i = 0; i <= n; i++)\n\t\tsame[i] = V(1 << i) * (1 << (n - i)) - same[i];\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tlong long tmp = sum[q[i]];\n\t\tfor(int j = q[i]; j <= n; j++)\n\t\t\tsum[j] += same[q[i]] - tmp * 2;\n\t\tfor(int j = 0; j < q[i]; j++)\n\t\t\tsum[j] = same[j] - sum[j];\n\t\tprintf(\"%I64d\\n\", sum[n]);\n\t}\n\tgetchar(); getchar();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Mashmokh and Reverse Operation.json",
    "editorial_link": "https://codeforces.com//blog/entry/11470",
    "editorial": "Build a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.\n\nFor each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b?+?1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i,?j)(a???i???b???j???c) that ai?>?bj and number of pairs (i,?j)(a???i???b???j???c) that ai?<?bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n ?*? 2n). We'll\n\nInitially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).\n\nInitially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq ?+? n ?*?2n).",
    "hint": []
}