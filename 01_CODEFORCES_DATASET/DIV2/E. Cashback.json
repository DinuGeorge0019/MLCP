{
    "link": "https://codeforces.com//contest/940/problem/E",
    "problemId": "159603",
    "problem_idx": "E",
    "shortId": "940E",
    "contest_number": "940",
    "problem_submissions": {
        "F": [
            35642079,
            35639249,
            35741635,
            36062963,
            36289513
        ],
        "E": [
            35635658,
            35633935,
            35631463,
            35633682,
            35625185,
            35633814,
            35633623,
            35626225,
            35634924,
            35632939,
            35633342,
            35637140,
            35635889,
            35635053,
            35634184,
            35633752,
            35646808,
            35646714,
            35632320,
            35632703
        ],
        "C": [
            35629972,
            35623066,
            35624318,
            35625052,
            35625312,
            35628608,
            35627465,
            35626058,
            35629009,
            35622773,
            35623814,
            35626574,
            35624743,
            35624088,
            35624644,
            35624203,
            35626389,
            35626478,
            35625921
        ],
        "A": [
            35626916,
            35619951,
            35619990,
            35620867,
            43064576,
            35620290,
            35621938,
            35620031,
            35620370,
            35620395,
            35619980,
            35620028,
            35620003,
            35619970,
            35620016,
            35620214,
            35619977,
            35620645,
            35623155,
            35620719
        ],
        "B": [
            35625745,
            35621065,
            35621588,
            35622435,
            35622147,
            35624740,
            35624541,
            35622933,
            35622325,
            35621538,
            35621447,
            35624471,
            35622193,
            35621648,
            35621812,
            35621709,
            35623702,
            35624565,
            35622680
        ],
        "D": [
            35623541,
            35626308,
            35627049,
            35628539,
            35628655,
            35631444,
            35629469,
            35628621,
            35633730,
            35625705,
            35628318,
            35630442,
            35631472,
            35627122,
            35630218,
            35630123,
            35629593,
            35629487,
            35628885
        ]
    },
    "name": "E. Cashback",
    "statement": "You are given an array of length and an integer . The value of some\r\narray of length is the sum of its elements except for the smallest. For\r\nexample, the value of the array with is .Among all possible partitions\r\nof into contiguous subarrays output the smallest possible sum of the\r\nvalues of these subarrays.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint n, m;\nll a[100005], sum[100005], f[100005];\nll q[100005]; int t[100005]; int l, r;\nll q2[100005]; int t2[100005]; int h, w;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i ++){\n\t\tscanf(\"%I64d\", &a[i]);\n\t\tsum[i] = a[i] + sum[i - 1];\n\t}\n\tif(m > n){\n\t\tprintf(\"%I64d\\n\", sum[n]);\n\t\treturn 0;\n\t}\n\tl = 1; r = 0;\n\th = 1; w = 0;\n\tfor(int i = 1; i < m; i ++){\n\t\tf[i] = sum[i];\n\t\twhile(l <= r && a[i] <= q[r]) r--;\n\t\tq[++r] = a[i]; t[r] = i;\n\t\twhile(h <= w && f[i] <= q2[w] + sum[i] - sum[t2[w]]) w--;\n\t\tq2[++w] = f[i]; t2[w] = i;\n\t}\n\tfor(int i = m; i <= n; i ++){\n\t\twhile(l <= r && i - t[l] >= m) l++;\n\t\twhile(l <= r && a[i] <= q[r]) r--;\n\t\tq[++r] = a[i]; t[r] = i;\n\t\tf[i] = f[i - m] + sum[i] - sum[i - m] - q[l];\n\t\tf[i] = min(f[i], f[t2[h]] + sum[i] - sum[t2[h]]);\n\t\twhile(h <= w && i + 1 - t2[h] >= m) h++;\n\t\twhile(h <= w && f[i] <= q2[w] + sum[i] - sum[t2[w]]) w--;\n\t\tq2[++w] = f[i]; t2[w] = i;\n//\t\tprintf(\"%lld %d %lld %d\\n\", q[l], t[l], q2[h], t2[h]);\n\t}\n\tprintf(\"%I64d\\n\", f[n]);\n\treturn 0;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Cashback.json",
    "editorial_link": "https://codeforces.com//blog/entry/58033",
    "editorial": "At first letâs solve this problem with complexity. It can be done using\r\ndynamic programming. Let be minimum cost of splitting prefix with length\r\n., where is a cost of maximums on interval . During finding these values\r\nwe can iterate over from to , storing sum of minimums in some structure\r\nlike std::multiset.The important observation for faster solution is that\r\nitâs always optimal to take segments with lengths or . Suppose we took\r\nsegment with length less than , then its cost doesnât depend on the way,\r\nwe split it and itâs possible to take it using segments with length .\r\nSuppose we took segment with length , , then itâs possible to split it\r\nto some segment with length and split other elements to segments with\r\nlength . Suppose we took a segment with length , then itâs not worse to\r\ntake it as two segments with length . In other cases itâs also possible\r\nto split segment to segments with lengths and without loosing of\r\noptimality.Itâs easy to find cost of segment with length , to find cost\r\nof segment with length , itâs possible to store elements in range in\r\nsome data structure which can find minimum value fast. It can be queue\r\nwith minimum or std::multiset;Complexity is or depending on structure\r\nused.\r\n",
    "hint": []
}