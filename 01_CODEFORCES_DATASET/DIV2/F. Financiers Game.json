{
    "link": "https://codeforces.com//contest/738/problem/F",
    "problemId": "81060",
    "problem_idx": "F",
    "shortId": "738F",
    "contest_number": "738",
    "problem_submissions": {
        "E": [
            22355357,
            22354524,
            22368260,
            22349644,
            22355331,
            22356088,
            22356163,
            22356096,
            22357408,
            22351061,
            22356973,
            22355298,
            22358187,
            22357834,
            22357953,
            22357991,
            22358891,
            22358107,
            22359096,
            22358176,
            22359681
        ],
        "D": [
            22352887,
            22353039,
            22402501,
            22352355,
            22352815,
            22351941,
            22352850,
            22352916,
            22350647,
            22353806,
            22348566,
            22353986,
            22349405,
            22355113,
            22351157,
            22350006,
            22354616,
            22352089,
            22346385,
            22351808,
            22354557
        ],
        "C": [
            22348617,
            22348545,
            22351859,
            22348840,
            22349718,
            22349641,
            22349601,
            22352863,
            22355987,
            22353264,
            22351200,
            22353844,
            22349294,
            22354485,
            22353883,
            22349940,
            22349844,
            22371503,
            22354418,
            22355326,
            22351271
        ],
        "B": [
            22345078,
            22345223,
            22347131,
            22345520,
            22345422,
            22345771,
            22345810,
            22346401,
            22348268,
            22345003,
            22348061,
            22346211,
            22344435,
            22345892,
            22345784,
            22345313,
            22344813,
            22347694,
            22347099,
            22346201
        ],
        "A": [
            22343882,
            22343979,
            22345882,
            22343953,
            22344058,
            22344097,
            22344370,
            22344195,
            22346397,
            22343753,
            22346250,
            22343907,
            22343833,
            22344008,
            22343904,
            22343686,
            22344348,
            22345077
        ],
        "F": [
            22415691,
            22576726,
            22658711,
            22371212,
            22371207,
            22371193,
            22371178,
            22371166,
            22368114,
            22469249,
            22468405,
            22458802
        ]
    },
    "name": "F. Financiers Game",
    "statement": "At evening, Igor and Zhenya the financiers became boring, so they\r\ndecided to play a game. They prepared papers with the income of some\r\ncompany for some time periods. Note that the income can be positive,\r\nzero or negative.Igor and Zhenya placed the papers in a row and decided\r\nto take turns making moves. Igor will take the papers from the left\r\nside, Zhenya will take the papers from the right side. Igor goes first\r\nand takes or (on his choice) papers from the left. Then, on each turn a\r\nplayer can take or papers from his side if the opponent took exactly\r\npapers in the previous turn. Players can’t skip moves. The game ends\r\nwhen there are no papers left, or when some of the players can’t make a\r\nmove.Your task is to determine the difference between the sum of incomes\r\non the papers Igor took and the sum of incomes on the papers Zhenya\r\ntook, assuming both players play optimally. Igor wants to maximize the\r\ndifference, Zhenya wants to minimize it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2010;\nint n, a[2 * maxn], s[2 * maxn], I[maxn][110][110], Z[maxn][110][110];\nbool II[maxn][110][110], ZZ[maxn][110][110];\nint solveI(int p, int d, int k);\nint solveZ(int p, int d, int k);\n\nint solveZ(int p, int d, int k) {\n    if (ZZ[p][d][k]) return Z[p][d][k];\n    ZZ[p][d][k] = 1;\n    Z[p][d][k] = 2e9 + 10;\n    int l, r;\n    r = n - p;\n    l = (p + d) + 1;\n    if (r - l + 1 < k) return Z[p][d][k] = 0;\n    for (int i = k; i < k + 2 && i <= r - l + 1; i++) {\n        /// chon K thang\n        int ns = s[r] - s[r - i];\n        Z[p][d][k] = min(Z[p][d][k], solveI(p + d, i - d, i) - ns);\n    }\n    return Z[p][d][k];\n}\nint solveI(int p, int d, int k) {\n    if (II[p][d][k]) return I[p][d][k];\n    II[p][d][k] = 1;\n    I[p][d][k] = - 2e9 - 10;\n    int l, r;\n    l = p + 1;\n    r = n - (p + d);\n    if (r - l + 1 < k) return I[p][d][k] = 0;\n    for (int i = k; i < k + 2 && i <= r - l + 1; i++) {\n        int ns = s[l + i - 1] - s[l - 1];\n        I[p][d][k] = max(I[p][d][k], solveZ(p + d, i - d, i) + ns);\n    }\n    return I[p][d][k];\n}\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n    cout << solveI(0, 0, 1);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Financiers Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "Let's solve this problem using dynamic programming. We can see that any position in the game can be described with three integers: the left and right bounds of the segment of papers that are still on the table, and the number of papers the previous player took; and who's turn it is. So, let Ilrk be the game result if there were only papers from l to r initially, Igor moved first by taking k or k?+?1 papers. Similarly, let Zlrk be the same but Zhenya moved first. It can be easily seen that in general case\n\n\n\nWe need to carefully proceed the states where a player can't take the needed number of papers. The answer for the problem is I1n1.\n\nAt first sight it seems that this solution runs in O(n3). However, it doesn't. What values can l, r and k be equal to?\n\nFirst,  because if the previous player took k papers then there are at least as  already taken papers. So, k is not greater than .\n\nSecond, let's take a look at the difference between number of papers taken by Zhenya and Igor, i. e. at the value d?=?(n?-?r)?-?(l?-?1). We consider only cases in which both players made the same number of moves, so now it's Igor's move. Then 0???d???k?-?1. Indeed, on each turn Zhenya took as many papers as Igor did, or one paper more, but in the latter case the \"length\" of move increased. The length of move increased by k?-?1 overall, so the difference is at most k?-?1. Thus, we can describe the dynamic programming state with l, d and k, and there are O(n2) states in total. We don't consider states in which it's Zhenya's turn, instead, we try all his possible moves to compute the states. The overall complexity is O(n2). I find it easier to code by the use of recursion and memoization.",
    "hint": []
}