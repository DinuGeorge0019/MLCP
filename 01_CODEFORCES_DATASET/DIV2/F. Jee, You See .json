{
    "link": "https://codeforces.com//contest/1670/problem/F",
    "problemId": "1390326",
    "problem_idx": "F",
    "shortId": "1670F",
    "contest_number": "1670",
    "problem_submissions": {
        "E": [
            156100998,
            156104485,
            156108916,
            156107756,
            156100648,
            156100656,
            156115463,
            156115332,
            156106434,
            156105992,
            156106756,
            156102783,
            156095228,
            156095823,
            156107708,
            156123887
        ],
        "D": [
            156095484,
            156091337,
            156102106,
            156097049,
            156094743,
            156093318,
            156097826,
            156112660,
            156093899,
            156099166,
            156101898,
            156095357,
            156101001,
            156110723,
            156092669,
            156094972,
            156093548,
            156098200
        ],
        "B": [
            156093818,
            156081627,
            156082334,
            156089012,
            156085695,
            156086167,
            156087956,
            156081931,
            156124817,
            156088947,
            156092504,
            156086895,
            156084557,
            156119888,
            156124153,
            156082723,
            156086168,
            156084111,
            156087742
        ],
        "F": [
            156092264,
            156098593,
            156099277,
            156103760,
            156113156,
            156116884,
            156103788,
            156096373,
            156116972,
            156112838,
            156904481,
            156114948,
            156119689,
            156110847,
            156129976,
            156106292,
            156119874,
            156103026,
            156115147,
            156111724,
            156108733
        ],
        "C": [
            156085904,
            156084420,
            156090953,
            156093920,
            156089470,
            156090841,
            156091539,
            156092125,
            156083813,
            156094804,
            156089625,
            156091655,
            156117087,
            156087179,
            156096140,
            156089472,
            156123873,
            156087762,
            156092456
        ],
        "A": [
            156079702,
            156080088,
            156079627,
            156079602,
            158677746,
            156079680,
            156081873,
            156080010,
            156079669,
            156079762,
            156080064,
            156079483,
            156080211,
            156085709,
            156079540,
            156080023,
            156096396,
            156080412,
            156082179
        ]
    },
    "name": "F. Jee, You See ",
    "statement": "You are given 4 integers n, l, r, and z. Count the number of arrays a of\r\nlength n containing non-negative integers such that: l\r\nle a_1+a_2+\r\nldots+a_n\r\nle r, and a_1\r\noplus a_2\r\noplus\r\nldots\r\noplus a_n=z, where\r\noplus denotes the bitwise XOR operation. Since the answer can be large,\r\nprint it modulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint C[1005][1005],dp[70][1005][2],n,z;\ninline int cal(int x)\n{\n\tmemset(dp,0,sizeof dp);\n\tdp[0][0][1]=1;\n\tfor(int i=1;i<=61;i++)\n\t{\n\t\tint X=(x>>i-1)&1;\n\t\tfor(int j=0;j<=1000;j++)\n\t\t{\n\t\t\tif(!dp[i-1][j][0]&&!dp[i-1][j][1]) continue;\n\t\t\tfor(int k=(z>>i-1)%2;k<=1000;k+=2)\n\t\t\t{\n\t\t\t\tint nw=j+k;\n\t\t\t\tif(nw&1)\n\t\t\t\t{\n\t\t\t\t\tif(X==0)\n\t\t\t\t\t\tdp[i][nw/2][0]=((dp[i-1][j][0]+dp[i-1][j][1])*C[n][k]+dp[i][nw/2][0])%mod;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][nw/2][1]=(C[n][k]*dp[i-1][j][1]+dp[i][nw/2][1])%mod;\n\t\t\t\t\t\tdp[i][nw/2][0]=(C[n][k]*dp[i-1][j][0]+dp[i][nw/2][0])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(X==1)\n\t\t\t\t\t\tdp[i][nw/2][1]=((dp[i-1][j][0]+dp[i-1][j][1])*C[n][k]+dp[i][nw/2][1])%mod;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][nw/2][1]=(C[n][k]*dp[i-1][j][1]+dp[i][nw/2][1])%mod;\n\t\t\t\t\t\tdp[i][nw/2][0]=(C[n][k]*dp[i-1][j][0]+dp[i][nw/2][0])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[61][0][1];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor(int i=0;i<=1000;i++)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=0;j<i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint l,r;\n\tcin >> n >> l >> r >> z;\n\tcout << ((cal(r)-cal(l-1)+mod)%mod+mod)%mod ;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Jee, You See .json",
    "editorial_link": "https://codeforces.com//blog/entry/102579",
    "editorial": "Let\u00e2\u0080\u0099s put aside the XOR constraint and only focus on the sum\r\nconstraint.let be the number of ways to construct integers such that\r\ntheir sum is at most .We will construct each bit of the integers at the\r\nsame time, we want to guarantee that the contribution of the sum of the\r\nbits generated at each position plus the sum of the previous bits wont\r\nexceed we only have to know the difference between the previous bits of\r\n(add 1 if the current bit is on) and the sum of the generated\r\nbits.However we know for sure that at each position we can generate at\r\nmost bits which will sum to at most, so for the next position the\r\ndifference will be the * (current difference - the sum of the bits at\r\nthe cur position). we can see that if the current difference has a value\r\nwe can place any number of bits at the remaining positions.Let\u00e2\u0080\u0099s define\r\nas the number of ways to construct the first bits of the integers such\r\nthat their sum doesn\u00e2\u0080\u0099t exceed , where is min between (the difference\r\nbetween the previous bits and ) and .We can have from 0 to ones placed\r\nat the current bit and for each we have ways to distribute them.Formally\r\nwhere is one if the limit have the bit on. For the XOR constraint we\r\nonly have to make sure that count is even if the current bit of Z is 0\r\nor odd if the current bit is 1.The answer of the problem will be .\r\n"
}