{
    "link": "https://codeforces.com//contest/18/problem/E",
    "problemId": "86",
    "problem_idx": "E",
    "shortId": "18E",
    "contest_number": "18",
    "problem_submissions": {
        "E": [
            81065,
            81306,
            80765,
            81264,
            81531,
            81749,
            81052,
            81910,
            82769,
            83595,
            82917,
            82903,
            83429,
            82503,
            82497,
            82370,
            470419
        ],
        "D": [
            80763,
            80489,
            81776,
            80347,
            81284,
            81376,
            81320,
            81622,
            81610
        ],
        "B": [
            80357,
            80881,
            79919,
            80575,
            80236,
            80254,
            80116,
            80063,
            80223,
            83594,
            80352,
            80834,
            80541,
            80588,
            81110,
            80898,
            82232,
            81439
        ],
        "C": [
            79922,
            80066,
            79784,
            80695,
            79953,
            79859,
            80277,
            80229,
            79880,
            79798,
            79989,
            80024,
            79954,
            80323,
            79676,
            79918
        ],
        "A": [
            79794,
            79576,
            79652,
            79640,
            79646,
            79718,
            79820,
            79725,
            79739,
            79651,
            79729,
            79883,
            79745,
            80732,
            80006,
            79782
        ]
    },
    "name": "E. Flag 2",
    "statement": "According to a new ISO standard, a flag of every country should have,\r\nstrangely enough, a chequered field , each square should be wholly\r\npainted one of 26 colours. The following restrictions are set: In each\r\nrow at most two different colours can be used. No two adjacent squares\r\ncan be painted the same colour. Pay attention, please, that in one\r\ncolumn more than two different colours can be used.Berland’s government\r\ntook a decision to introduce changes into their country’s flag in\r\naccordance with the new standard, at the same time they want these\r\nchanges to be minimal. By the given description of Berland’s flag you\r\nshould find out the minimum amount of squares that need to be painted\r\ndifferent colour to make the flag meet the new ISO standard. You are as\r\nwell to build one of the possible variants of the new Berland’s flag.\r\n",
    "solutions": [
        "#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <vector> \n#include <cstring> \n#include <string> \n#include <cctype> \n#include <iostream> \n#include <algorithm> \n#include <set> \n#include <deque> \n#include <sstream> \n#include <cstddef>\n#include <functional>\n#include <queue>\n#include <map>\n\n\n\nusing namespace std; \n\n\nint INF = INT_MAX / 2;\nchar grid[550][550];\nint dp[550][26][26];\nint prev[550][26][26];\n\nvoid output(int res, int height) {\n\tprintf(\"%d\\n\", res);\n\tfor (int i = 0; i < height; ++i) {\n\t\tprintf(\"%s\\n\", grid[i]);\n\t}\n}\n\nint main() {\n\t\t// {\n\t\t// out = new PrintWriter(\"test.in\");\n\t\t// out.println(500 + \" \" + 500);\n\t\t// for (int i = 0; i < 500; ++i) {\n\t\t// for (int j = 0; j < 500; ++j) {\n\t\t// out.print('a');\n\t\t// }\n\t\t// out.println();\n\t\t// }\n\t\t// out.flush();\n\t\t// if (true) {\n\t\t// return;\n\t\t// }\n\t\t// }\n\tint height, width;\n\tscanf(\"%d%d\", &height, &width);\n\t\tfor (int i = 0; i < height; ++i) {\n\t\t\tscanf(\"%s\", grid[i]);\n\t\t}\n\t\tif (width == 1) {\n\t\t\tint res = 0;\n\t\t\tfor (int i = 1; i < height; ++i) {\n\t\t\t\tif (grid[i][0] == grid[i - 1][0]) {\n\t\t\t\t\tchar cur = 'a';\n\t\t\t\t\t++res;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (grid[i - 1][0] == cur) {\n\t\t\t\t\t\t\t++cur;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i + 1 < height && grid[i + 1][0] == cur) {\n\t\t\t\t\t\t\t++cur;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgrid[i][0] = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput(res, height);\n\t\t} else {\n\t\t\tfor (int i = 0; i <= height; ++i) {\n\t\t\t\tfor (int x = 0; x < 26; ++x) {\n\t\t\t\t\tfor (int y = 0; y < 26; ++y) {\n\t\t\t\t\t\tdp[i][x][y] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tdp[0][i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint even[26];\n\t\t\tint odd[26];\n\t\t\tfor (int i = 0; i < height; ++i) {\n\t\t\t\tmemset(even, 0, sizeof(even));\n\t\t\t\tmemset(odd, 0, sizeof(odd));\n\t\t\t\tfor (int j = 0; j < width; ++j) {\n\t\t\t\t\tif ((j & 1) == 0) {\n\t\t\t\t\t\t++even[grid[i][j] - 'a'];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++odd[grid[i][j] - 'a'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int x = 0; x < 26; ++x) {\n\t\t\t\t\tfor (int y = 0; y < 26; ++y) {\n\t\t\t\t\t\tif (dp[i][x][y] != INF) {\n\t\t\t\t\t\t\tfor (int nx = 0; nx < 26; ++nx) {\n\t\t\t\t\t\t\t\tif (x != nx) {\n\t\t\t\t\t\t\t\t\tfor (int ny = 0; ny < 26; ++ny) {\n\t\t\t\t\t\t\t\t\t\tif (y != ny) {\n\t\t\t\t\t\t\t\t\t\t\tif (nx != ny) {\n\t\t\t\t\t\t\t\t\t\t\t\tint val = width - even[nx] - odd[ny] + dp[i][x][y];\n\t\t\t\t\t\t\t\t\t\t\t\tif (val < dp[i + 1][nx][ny]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdp[i + 1][nx][ny] = val;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprev[i + 1][nx][ny] = (x << 8) + y;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bestX = -1;\n\t\t\tint bestY = -1;\n\t\t\tint res = INF;\n\t\t\tfor (int x = 0; x < 26; ++x) {\n\t\t\t\tfor (int y = 0; y < 26; ++y) {\n\t\t\t\t\tif (x != y && dp[height][x][y] < res) {\n\t\t\t\t\t\tres = dp[height][x][y];\n\t\t\t\t\t\tbestX = x;\n\t\t\t\t\t\tbestY = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = height - 1; i >= 0; --i) {\n\t\t\t\tfor (int j = 0; j < width; ++j) {\n\t\t\t\t\tif ((j & 1) == 0) {\n\t\t\t\t\t\tgrid[i][j] = (char) (bestX + 'a');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgrid[i][j] = (char) (bestY + 'a');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint px = prev[i + 1][bestX][bestY] >> 8;\n\t\t\t\tint py = prev[i + 1][bestX][bestY] & ((1 << 8) - 1);\n\t\t\t\tbestX = px;\n\t\t\t\tbestY = py;\n\t\t\t}\n\t\t\toutput(res, height);\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Flag 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/463",
    "editorial": "In this problem one should use dynamic programming. Consider the function DP(level, A, B) (where A and B are the numbers of colors, from 0 to 25), which returns the minimal number of repaintings required to repaint the first level rows. The last row will be like ABABAB...\n\nConsider recalculating of this function. First, calculate the number of repaintings required for row level to be like ABABAB... (let D will be this number). Obviously, the row can be painted so if the color of the first element of the previous row is not \"A\" and the second one - not \"B\" (it's a condition of adjacent cells not to have the same color) or it should be the first row. So DP(level, A, B) = min(DP(level-1, i, j)) + D , i = 0..25, j = 0..25, i != j, i != B, j != A.\n\nEstimate the run time of our program: O(N*26*26*(M+26*26)), this value is smaller than 4*108",
    "hint": []
}