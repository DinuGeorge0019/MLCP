{"link": "https://codeforces.com//contest/1152/problem/E", "problemId": "335384", "problem_idx": "E", "shortId": "1152E", "contest_number": "1152", "problem_submissions": {"C": [53244845, 53230927, 53233766, 53235808, 53234198, 53234839, 53238158, 53233895, 53244428, 53238661, 53245124, 53237428, 53241947, 53255111, 53240873, 53232261, 53233767, 53232829], "E": [53239734, 53245640, 53249082, 53237299, 53252319, 53253962, 53269982, 53253449, 53252636, 53255804, 53252841, 53252353, 53235804, 53253519, 53250724, 53255613, 53476482], "D": [53233906, 53239025, 53240632, 53250831, 53239012, 53242704, 53250969, 53239158, 53239278, 53243068, 53249440, 53254093, 53239872, 53249862, 53242480, 53247260, 53236086, 53237628, 53240315], "B": [53229253, 53234506, 53230572, 53231304, 53231144, 53231405, 53233565, 53231636, 53233110, 53231852, 53233634, 53233426, 53232376, 53236011, 53235559, 53230731, 53230129, 53231640, 53230247], "A": [53226242, 53226637, 53226146, 53227612, 53226534, 53227116, 53228309, 53228363, 53226234, 53226947, 53228169, 53229011, 53227021, 53226493, 53226176, 53226318, 53226306, 53226785], "F2": [53255434, 139447309], "F1": [53255396]}, "name": "E. Neko and Flashback", "statement": "A of length k is a sequence of k integers from 1 to k containing each\r\ninteger exactly once. For example, the sequence [3, 1, 2] is a\r\npermutation of length 3.When Neko was five, he thought of an array a of\r\nn positive integers and a permutation p of length n - 1. Then, he\r\nperformed the following: Constructed an array b of length n-1, where b_i\r\n=\r\nmin(a_i, a_{i+1}). Constructed an array c of length n-1, where c_i =\r\nmax(a_i, a_{i+1}). Constructed an array b\u2019 of length n-1, where b\u2019_i =\r\nb_{p_i}. Constructed an array c\u2019 of length n-1, where c\u2019_i = c_{p_i}.\r\nFor example, if the array a was [3, 4, 6, 5, 7] and permutation p was\r\n[2, 4, 1, 3], then Neko would have constructed the following arrays: b =\r\n[3, 4, 5, 5] c = [4, 6, 6, 7] b\u2019 = [4, 5, 3, 5] c\u2019 = [6, 7, 4, 6] Then,\r\nhe wrote two arrays b\u2019 and c\u2019 on a piece of paper and forgot about it.\r\n14 years later, when he was cleaning up his room, he discovered this old\r\npiece of paper with two arrays b\u2019 and c\u2019 written on it. However he can\u2019t\r\nremember the array a and permutation p he used.In case Neko made a\r\nmistake and there is no array a and permutation p resulting in such b\u2019\r\nand c\u2019, print . Otherwise, help him recover any possible array a.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000000007 \n#define N 200005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nint n,cnt;\nint val[N];\nmap<int,int> mp;\nint vis[N];\nstack<int> s;\nmultiset<int> v[N];\n\nvoid dfs(int node) {\n\n\tvis[node]=1;\n\n\twhile(sz(v[node])) {\n\n\t\tint go=*v[node].begin();\n\n\t\tv[node].erase(v[node].begin());\n\n\t\tv[go].erase(v[go].find(node));\n\n\t\tdfs(go);\n\n\t}\n\n\ts.push(node);\n\n}\n\nint main() {\n\n\tscanf(\"%d\",&n);\n\n\tvector<int> a(n+1),b(n+1);\n\n\tfor(int i=1;i<n;i++) {\n\n\t\tscanf(\"%d\",&a[i]);\n\n\t\tif(!mp[a[i]]) {\n\n\t\t\tmp[a[i]]=++cnt;\n\n\t\t\tval[cnt]=a[i];\n\n\t\t}\n\n\t}\n\n\tfor(int i=1;i<n;i++) {\n\n\t\tscanf(\"%d\",&b[i]);\n\n\t\tif(!mp[b[i]]) {\n\n\t\t\tmp[b[i]]=++cnt;\n\n\t\t\tval[cnt]=b[i];\n\n\t\t}\n\n\t\tif(b[i]<a[i]) {\n\n\t\t\tprintf(\"-1\");\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tv[mp[a[i]]].insert(mp[b[i]]);\n\t\tv[mp[b[i]]].insert(mp[a[i]]);\n\n\t}\n\n\tvector<int> odd;\n\n\tfor(int i=1;i<=cnt;i++) {\n\n\t\tif(sz(v[i])&1) odd.pb(i);\n \n\t}\n\n\tif(sz(odd)>2) {\n\n\t\tprintf(\"-1\");\n\n\t\treturn 0;\n\n\t}\n\n\tif(!sz(odd)) odd.pb(1);\n\n\tdfs(odd[0]);\n\n\tfor(int i=1;i<=cnt;i++) {\n\n\t\tif(!vis[i]) {\n\n\t\t\tprintf(\"-1\");\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\twhile(sz(s)) {\n\n\t\tprintf(\"%d \",val[s.top()]);\n\n\t\ts.pop();\n\n\t}\n\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs"], "dificulty": "2400", "interactive": false}