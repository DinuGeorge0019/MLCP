{
    "link": "https://codeforces.com//contest/1269/problem/D",
    "problemId": "499890",
    "problem_idx": "D",
    "shortId": "1269D",
    "contest_number": "1269",
    "problem_submissions": {
        "C": [
            67352706,
            67342506,
            67340660,
            67342809,
            67344956,
            67331477,
            67339107,
            67340486,
            67338149,
            67340091,
            67338156,
            67347782,
            67341549,
            67341600,
            67342294,
            67342344,
            67342829,
            67330241
        ],
        "E": [
            67349858,
            67364589,
            67368127,
            67360428,
            67362487,
            67407644,
            67361816,
            68037838
        ],
        "D": [
            67339478,
            67353948,
            67348917,
            67364550,
            67364311,
            67334215,
            67340431,
            67341741,
            67338198,
            67342873,
            67348426,
            67348708,
            67343994,
            67344243,
            67344039,
            67350135,
            67345192,
            67346296,
            67343602
        ],
        "B": [
            67337312,
            67377870,
            67335347,
            67345749,
            67336939,
            67340567,
            67339027,
            67334414,
            67335423,
            67344354,
            67335379,
            67396814,
            67341834,
            67332604,
            67337610,
            67338071,
            67337253,
            67332987,
            67335282,
            67336511,
            67345383
        ],
        "A": [
            67331771,
            67329729,
            67330308,
            67335502,
            67337021,
            67336156,
            67329958,
            67329769,
            67338898,
            67330168,
            67396807,
            67337525,
            67329686,
            67329755,
            67331194,
            67331352,
            67329912,
            67329806,
            67330184,
            67340611
        ]
    },
    "name": "D. Domino for Young",
    "statement": "You are given a Young diagram. Given diagram is a histogram with n\r\ncolumns of lengths a_1, a_2,\r\nldots, a_n (a_1\r\ngeq a_2\r\ngeq\r\nldots\r\ngeq a_n\r\ngeq 1). Your goal is to find the largest number of non-overlapping\r\ndominos that you can draw inside of this histogram, a domino is a 1\r\ntimes 2 or 2\r\ntimes 1 rectangle.\r\n",
    "solutions": [
        "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define null nullptr\n#define _ <<' '<<\n#define endl '\\n'\n\nusing namespace std;\n\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N = 3e5 + 7;\nconst int M = 1e9 + 7;\n//const int M = 998244353;\nconst int FFTM = 998244353;\n\nll n, x[N], A, B;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif // LOCAL\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x[i];\n        ll a = (x[i] + 1)/2;\n        ll b = (x[i] - a);\n        if (i&1) A += a, B += b;\n        else A += b, B += a;\n    }\n    cout << min(A, B);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Domino for Young.json",
    "editorial_link": "https://codeforces.com//blog/entry/72358",
    "editorial": "Letâs color diagram into two colors as a chessboard.I claim that the\r\nYoung diagram can be partitioned into domino if and only if the number\r\nof white cells inside it is equal to the number of black cells inside\r\nit.If the Young diagram has two equal rows (or columns) you can delete\r\none domino, and the diagram will still have an equal number of white and\r\nblack cells. If all rows and columns are different, it means that the\r\nYoung diagram is a \"basic\" diagram, i.e have lengths of columns . But in\r\na \"basic\" diagram the number of white and black cells is different! So,\r\nwe have a contradiction!But what if the number of black and white cells\r\nare not the same? I claim that the answer is the number of white cells,\r\nthe number of black cells .Just because if you have more white cells\r\n(case with more black case is symmetrical), and there are no equal rows\r\nand columns, you can take the first column with more white cells than\r\nblack cells and delete the last cell of this column, in the end, you\r\nwill have a Young diagram with an equal number of black and white cells,\r\nso you can find the answer by algorithm described below.\r\n",
    "hint": []
}