{
    "link": "https://codeforces.com//contest/902/problem/B",
    "problemId": "139718",
    "problem_idx": "B",
    "shortId": "902B",
    "contest_number": "902",
    "problem_submissions": {
        "E": [
            33432769,
            33432692,
            33431724,
            33432880,
            33433143,
            33425800,
            33479713,
            33434507
        ],
        "C": [
            33418857,
            33421216,
            33418092,
            33421721,
            33425094,
            33420634,
            33423702,
            33423018,
            33420334,
            33420303,
            33419836,
            33430662,
            33420269,
            33422420,
            33422328,
            33423548,
            33420458,
            33425360
        ],
        "B": [
            33414393,
            33416891,
            33413564,
            33416982,
            33418778,
            33415144,
            33420150,
            33416950,
            33420947,
            33415271,
            33415194,
            33431642,
            33414521,
            33417866,
            33416627,
            33417427,
            33416186,
            33419760
        ],
        "A": [
            33412979,
            33413298,
            33412683,
            33414789,
            33412988,
            33412835,
            33415972,
            33412736,
            33422119,
            33413143,
            33413263,
            33432089,
            33412738,
            33412994,
            33413252,
            33413078,
            33413621,
            33413563
        ],
        "D": [
            33425081,
            33422286,
            33426122,
            33429053,
            33429776,
            33430153,
            33430663,
            33428168,
            33429601,
            33428402,
            33429733
        ]
    },
    "name": "B. Coloring a Tree",
    "statement": "You are given a rooted tree with vertices. The vertices are numbered\r\nfrom to , the root is the vertex number .Each vertex has a color, letâ€™s\r\ndenote the color of vertex by . Initially .You have to color the tree\r\ninto the given colors using the smallest possible number of steps. On\r\neach step you can choose a vertex and a color , and then color all\r\nvectices in the subtree of (including itself) in color . In other words,\r\nfor every vertex , such that the path from root to passes through , set\r\n.It is guaranteed that you have to color each vertex in a color\r\ndifferent from .You can learn what a rooted tree is using the link:\r\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory).\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\n\n\n\n\ntemplate <class T>\nvoid upd(T&a,T b) {\n    a = max(a,b);\n}\n\nvector<int>son[100010];\nint n,c[100010];\nint ans = 0;\nvoid dfs(int cur,int color = 0){\n    if(c[cur]!=color){\n        ans++;\n        color = c[cur];\n    }\n    for(auto i:son[cur]){\n        dfs(i,color);\n    }\n}\nint main(){\n    in(n);\n    REP(i,2,n+1){\n        int p;in(p);\n        son[p].PB(i);\n    }\n    REP(i,1,n+1){\n        in(c[i]);\n    }\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "greedy"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Coloring a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/56478",
    "editorial": "Consider the process from the end, we will \"delete\" any subtree from the\r\ntree, whose color of the ancestor of the highest vertex differs from the\r\ncolor of the highest vertex and the colors of all vertices in the\r\nsubtree are the same. Thus, we can show that the answer is the number of\r\nedges whose ends have different colors + 1.\r\n",
    "hint": []
}