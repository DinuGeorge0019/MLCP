{
    "link": "https://codeforces.com//contest/1935/problem/B",
    "problemId": "2510286",
    "problem_idx": "B",
    "shortId": "1935B",
    "contest_number": "1935",
    "problem_submissions": {
        "F": [
            249811158,
            249879664,
            249914146,
            253436865,
            253436779,
            249829995,
            249883407,
            250140723,
            250140588
        ],
        "E": [
            249795863,
            249806897,
            249806016,
            249798150,
            249809204,
            249810510,
            249813605,
            249811376,
            249815627,
            249812083,
            249809741,
            249806184,
            249812511,
            249817539,
            249815136,
            249812113,
            249814837,
            249819842
        ],
        "B": [
            249781740,
            249751689,
            249753292,
            249765548,
            249748977,
            249751802,
            249753680,
            249757222,
            249771661,
            249760318,
            249763328,
            249766386,
            249759882,
            249765172,
            249756443,
            249760201,
            249770177,
            249763394,
            249755331
        ],
        "C": [
            249775741,
            249762276,
            249765158,
            249776179,
            249761477,
            249764700,
            249766485,
            249776568,
            249788464,
            249770693,
            249776753,
            249780744,
            249769798,
            249778919,
            249777602,
            249777662,
            249785568,
            249777744,
            249769139
        ],
        "D": [
            249754703,
            249774116,
            249776894,
            249784670,
            249778866,
            249776850,
            249778167,
            249792030,
            249756994,
            249781860,
            249794874,
            249794304,
            249791400,
            249793376,
            249789336,
            249797727,
            249794804,
            249793568,
            249791344
        ],
        "A": [
            249745747,
            249745965,
            249747700,
            249754230,
            249752123,
            249745614,
            249941865,
            249747635,
            249746024,
            249765018,
            249751275,
            249749292,
            249756879,
            249748862,
            249749602,
            249746174,
            249751494,
            249751493,
            249747948,
            249747369
        ]
    },
    "name": "B. Informatics in MAC",
    "statement": "In the Masterâ€™s Assistance Center, Nyam-Nyam was given a homework\r\nassignment in informatics.There is an array a of length n, and you want\r\nto divide it into k > 1 subsegments^{\r\ndagger} in such a way that the\r\noperatorname{MEX} ^{\r\nddagger} on each subsegment is equal to the same integer.Help Nyam-Nyam\r\nfind any suitable division, or determine that it does not exist.^{\r\ndagger}A division of an array into k subsegments is defined as k pairs\r\nof integers (l_1, r_1), (l_2, r_2),\r\nldots, (l_k, r_k) such that l_i\r\nle r_i and for each 1\r\nle j\r\nle k - 1, l_{j + 1} = r_j + 1, and also l_1 = 1 and r_k = n. These pairs\r\nrepresent the subsegments themselves.^{\r\nddagger}\r\noperatorname{MEX} of an array is the smallest non-negative integer that\r\ndoes not belong to the array.For example:\r\noperatorname{MEX} of the array [2, 2, 1] is 0, because 0 does not belong\r\nto the array.\r\noperatorname{MEX} of the array [3, 1, 0, 1] is 2, because 0 and 1 belong\r\nto the array, but 2 does not.\r\noperatorname{MEX} of the array [0, 3, 1, 2] is 4, because 0, 1, 2, and 3\r\nbelong to the array, but 4 does not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)\n#define cln cerr<<\"Line:   \"<<__LINE__<<\"    \"\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]='\\n';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,n,m,a[N],b[N],p[N],q[N],bt,ans;\nbitset<N>vs;\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(x=0;x<=n;++x)vs[x]=0;\n        for(i=1;i<=n;++i)cin>>a[i],vs[a[i]]=1;\n        for(k=0;vs[k];++k);\n        if(!k){\n            puts(\"2\");\n            puts(\"1 1\");\n            printf(\"2 %d\\n\",n);\n            continue;\n        }\n        for(i=0;i<k;++i)vs[i]=0;\n        for(r=z=0;z<k;)\n            if(a[++r]<k&&!vs[a[r]])z+=vs[a[r]]=1;\n        for(i=0;i<k;++i)vs[i]=0;\n        for(i=r+1,z=0;i<=n;++i)\n            if(a[i]<k&&!vs[a[i]])z+=vs[a[i]]=1;\n        if(z<k)puts(\"-1\");\n        else{\n            puts(\"2\");\n            printf(\"%d %d\\n%d %d\\n\",1,r,r+1,n);\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Informatics in MAC.json",
    "editorial_link": "https://codeforces.com//blog/entry/126662",
    "editorial": "TutorialSuppose we correctly divided the array into segments . Then,\r\nnote that we can merge first two subsegments, as the numbers from 0 to\r\nare encountered in these two segments and the number is not encountered\r\nin them. Therefore, if there is a division into segments, then there is\r\nalso for segments.Therefore, it is sufficient to check whether there is\r\na division of the array into segments, which can be done in by\r\nprecalcing on the prefixes and suffixes, then we need to find some for\r\nwhich .\r\n",
    "hint": [
        "Hint 1 What is the minimum that can be in a division?",
        "Hint 2 Suppose , what can be said about ?"
    ]
}