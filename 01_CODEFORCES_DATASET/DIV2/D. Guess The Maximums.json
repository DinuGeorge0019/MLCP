{
    "link": "https://codeforces.com//contest/1363/problem/D",
    "problemId": "636626",
    "problem_idx": "D",
    "shortId": "1363D",
    "contest_number": "1363",
    "problem_submissions": {
        "F": [
            82106115,
            82133417,
            82134663,
            82148859,
            82187672,
            82151422,
            82129291
        ],
        "B": [
            82089340,
            82061810,
            82102257,
            82051813,
            82052193,
            82054432,
            82059773,
            82050390,
            82052570,
            82057688,
            82062819,
            82061181,
            82063108,
            82056815,
            82052221,
            82048933,
            82053424,
            82060016
        ],
        "E": [
            82084929,
            82115560,
            82118841,
            82083744,
            82094219,
            82095201,
            82085310,
            82078785,
            82104191,
            82087813,
            82091268,
            82109972,
            82093877,
            82089726,
            82112505,
            82091430,
            82097365,
            82091233
        ],
        "D": [
            82073363,
            82098128,
            82116891,
            82105976,
            82086712,
            82108911,
            82113962,
            82100776,
            82093305,
            82115209,
            82090000,
            82113643,
            82117922,
            82095216,
            82114310,
            82120048,
            82118359
        ],
        "C": [
            82058814,
            82072569,
            82099263,
            82066157,
            82070197,
            82067166,
            82068534,
            82108126,
            82064962,
            82108652,
            82074021,
            82067732,
            82075440,
            82064472,
            82071898,
            82069396,
            82075513,
            82072756
        ],
        "A": [
            82051846,
            82136588,
            82081640,
            82048308,
            82048940,
            82048236,
            82052695,
            82047806,
            82048669,
            82057495,
            82055772,
            82048991,
            82055132,
            82048772,
            82048248,
            82057801,
            82048473,
            82052285
        ]
    },
    "name": "D. Guess The Maximums",
    "statement": "Ayush devised a new scheme to set the password of his lock. The lock has\r\nk slots where each slot can hold integers from 1 to n. The password P is\r\na sequence of k integers each in the range [1, n], i-th element of which\r\ngoes into the i-th slot of the lock.To set the password of his lock,\r\nAyush comes up with an array A of n integers each in the range [1, n]\r\n(not necessarily distinct). He then picks k subsets of indices S_1, S_2,\r\n..., S_k (S_i\r\nunderset{i\r\nneq j}\r\ncap S_j =\r\nemptyset) and sets his password as P_i =\r\nmax\r\nlimits_{j\r\nnotin S_i} A[j]. In other words, the i-th integer in the password is\r\nequal to the maximum over all elements of A whose indices do not belong\r\nto S_i.You are given the subsets of indices chosen by Ayush. You need to\r\nguess the password. To make a query, you can choose a non-empty subset\r\nof indices of the array and ask the maximum of all elements of the array\r\nwith index in this subset. .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 1e3 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nint Ask(int i){\n\tcout << \"? \" << i;\n\tfor(int j = 1; j <= i; j++) cout << \" \" << j;\n\tcout << endl;\n\tint res;\n\tcin >> res;\n\treturn res;\n}\n\nvector<int> V[N];\n\nint ans[N];\nint Main(){\n\tint n, k, sz, v;\n\tcin >> n >> k;\n\tfor(int i = 1; i <= k; i++){\n\t\tcin >> sz;\n\t\tV[i].clear();\n\t\tfor(int j = 0; j < sz; j++){\n\t\t\tcin >> v;\n\t\t\tV[i].pb(v);\n\t\t}\n\t}\n\tint mx = Ask(n);\n\tint L = 0, R = n, mid;\n\t\n\twhile(L + 1 < R){\n\t\tmid = (L + R) >> 1;\n\t\tif(Ask(mid) == mx) R = mid;\n\t\telse L = mid;\n\t}\n\tfor(int i = 1; i <= k; i++){\n\t\tint flg = false;\n\t\tfor(auto x : V[i]) if(x == R) flg = true;\n\t\tif(!flg){\n\t\t\tans[i] = mx;\n\t\t\tcontinue;\n\t\t}\n\t\tmap<ll, ll> mp;\n\t\tfor(auto x : V[i]) mp[x] = 1;\n\t\tcout << \"? \" << n - V[i].size();\n\t\tfor(int j = 1; j <= n; j++) if(!mp[j]) cout << \" \" << j;\n\t\tcout << endl;\n\t\tcin >> ans[i];\n\t}\n\n\tcout << \"!\";\n\tfor(int i = 1; i <= k; i++) cout << \" \" << ans[i];\n\tcout << endl;\n\tstr rs;\n\tcin >> rs;\n\treturn 0;\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint tc;\n\tcin >> tc;\n\twhile(tc --) Main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "implementation",
        "interactive",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Guess The Maximums.json",
    "editorial_link": "https://codeforces.com//blog/entry/78202",
    "editorial": "The maximum of the array is the password integer for all except atmost\nposition. We find the subset (if the maximum is in a subset) in which\nthe maximum exists using binary search, and then query the answer for\nthis subset seperately. (For all the subsets, the answer is the maximum\nfor the whole array).: I will be working with an example in this\nexplanation; let the array be , and array of length , and let there be\nsubsets, with first subset being , second being , etc (every index\nexcept is a subset). Thus, , etc.First, let us query the maximum of the\nwhole array using query. This gives as the output in our case.Now, we\ncheck if the maximum is present in the subsets. We do this in the\nfollowing manner: we query the first half of the subsets. If the value\nreturned here is not the maximum, then we search in the second half -\nelse, we know that the maximum must be in the first half of subsets.\nHence, we binary search in the first half itself. To proceed with our\nexample, we query the maximum from subsets to , which turns out to be .\nThus, must be present in subsets to . Then we will query to , which will\nreturn the value - thus, the maximum may be present in subset , or .\nThus, we query subset and find that it does not contain the maximum.\nThis step will require at most queries, and we will get a subset which\n(may or may not) contain the maximum element (remember, it is possible\nthat the maximum element was not in any subset!)Thus, in our final query\nwe ask about the maximum over all indices other than the canditate\nsubset we found above. In our example, We query every index except those\nin subset using query, which gives us the answer as . Hence, the\npassword is .Note: The bound of queries is tight.:\n"
}