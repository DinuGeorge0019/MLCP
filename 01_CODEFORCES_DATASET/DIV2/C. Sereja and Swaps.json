{
    "link": "https://codeforces.com//contest/426/problem/C",
    "problemId": "8914",
    "problem_idx": "C",
    "shortId": "426C",
    "contest_number": "426",
    "problem_submissions": {
        "E": [
            6493538,
            6491838,
            6493027,
            6494051,
            6499920,
            6504072
        ],
        "D": [
            6491367,
            6511214,
            6496120,
            6499841,
            6499642
        ],
        "C": [
            6488726,
            6487305,
            6488549,
            6488977,
            6490807,
            6486792,
            6488066,
            6488017,
            6488383,
            6488717,
            6486820,
            6488841,
            6488907,
            6489033,
            6488862,
            6489617,
            6488025,
            6489534
        ],
        "B": [
            6486631,
            6485614,
            6486926,
            6487002,
            6486070,
            6488206,
            6486378,
            6487321,
            6486952,
            6486486,
            6488476,
            6486755,
            6486672,
            6486770,
            6487441,
            6489108,
            6486423
        ],
        "A": [
            6485786,
            6485054,
            6485467,
            6485286,
            6485150,
            6488483,
            6485397,
            6485449,
            6485299,
            6485065,
            6487774,
            6485399,
            6485100,
            6485470,
            6485640,
            6485878,
            6485186
        ]
    },
    "name": "C. Sereja and Swaps",
    "statement": "As usual, Sereja has array , its elements are integers: . Let\u2019s\r\nintroduce notation:A swap operation is the following sequence of\r\nactions: choose two indexes ; perform assignments . What maximum value\r\nof function can Sereja get if he is allowed to perform at most swap\r\noperations?\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n\nusing namespace::std;\n\ntypedef pair<int,int> pii;\n\nint n,k,ans=-2140000000;\nint a[1005];\nbool chk[1005];\n\nint main(){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&a[i]);\n    }\n    for(int i=1;i<=n;i++){\n        int sum=0;\n        priority_queue<int> pq;\n        priority_queue<pii> pq1;\n        for(int j=1;j<=n;j++) pq1.push(pii(a[j],j)),chk[j]=false;\n        for(int j=i;j<=n;j++){\n            sum+=a[j];\n            int change=0;\n            pq.push(-a[j]);\n            vector<int> buf;\n            vector<pii> buf1;\n            chk[j]=true;\n            while(!pq1.empty() && chk[pq1.top().second]) pq1.pop();\n\n            int k1=min((int)min(n-pq.size(),pq.size()),k);\n            ans=max(ans,sum+change);\n            for(int l=0;l<k1;l++){\n                buf.push_back(pq.top());\n                change+=pq.top();\n                pq.pop();\n                buf1.push_back(pq1.top());\n                change+=pq1.top().first;\n                pq1.pop();\n                while(!pq1.empty() && chk[pq1.top().second]) pq1.pop();\n                ans=max(ans,sum+change);\n            }\n            for(int l=0;l<buf1.size();l++) pq1.push(buf1[l]);\n            for(int l=0;l<buf.size();l++) pq.push(buf[l]);\n\n        }\n    }\n    printf(\"%d\",ans);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Sereja and Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/11998",
    "editorial": "Lets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3\u00b7log(n)).\n"
}