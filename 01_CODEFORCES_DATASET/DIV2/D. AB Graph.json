{
    "link": "https://codeforces.com//contest/1481/problem/D",
    "problemId": "888834",
    "problem_idx": "D",
    "shortId": "1481D",
    "contest_number": "1481",
    "problem_submissions": {
        "E": [
            106575657,
            106580122,
            106571072,
            106587922,
            106596561,
            106601300,
            106598150,
            106588203,
            106555230,
            106601691,
            106603323,
            106598805,
            106606116,
            106598692,
            106597406,
            106601560,
            106559099,
            106600288,
            106602866
        ],
        "D": [
            106568002,
            106573123,
            106565784,
            106576955,
            106573210,
            106578133,
            106576417,
            106596842,
            106581404,
            106583159,
            106580270,
            106581784,
            106581178,
            106589786,
            106588485,
            106598470,
            106585012,
            106578937,
            106593218
        ],
        "C": [
            106554240,
            106561563,
            106587826,
            106564449,
            106557128,
            106554455,
            106561081,
            106556949,
            106593975,
            106567836,
            106563207,
            106566579,
            106560187,
            106560571,
            106563380,
            106553575,
            106571925,
            106575164,
            106574000
        ],
        "B": [
            106545453,
            106545635,
            106575045,
            106557114,
            106546143,
            106544431,
            106547512,
            106547628,
            106600777,
            106555535,
            106546768,
            106552994,
            106545917,
            106549686,
            106553008,
            106544154,
            106594934,
            106546830,
            106553782
        ],
        "A": [
            106540084,
            106539696,
            106539972,
            106539768,
            106541130,
            106540757,
            106539872,
            106540973,
            106602935,
            106540095,
            106541018,
            106540813,
            106540248,
            106541459,
            106539556,
            106539597,
            106547797,
            106540934,
            106542940
        ],
        "F": [
            106632220,
            111955794,
            218518749,
            218505572
        ]
    },
    "name": "D. AB Graph",
    "statement": "Your friend Salem is Warawreh’s brother and only loves math and geometry\r\nproblems. He has solved plenty of such problems, but according to\r\nWarawreh, in order to graduate from university he has to solve more\r\ngraph problems. Since Salem is not good with graphs he asked your help\r\nwith the following problem. You are given a complete directed graph with\r\nn vertices without self-loops. In other words, you have n vertices and\r\neach pair of vertices u and v (u\r\nneq v) has both directed edges (u, v) and (v, u).Every directed edge of\r\nthe graph is labeled with a single character: either ” or ” (edges (u,\r\nv) and (v, u) may have different labels).You are also given an integer\r\nm > 0. You should find a path of length m such that the string obtained\r\nby writing out edges’ labels when going along the path is a . The length\r\nof the path is the number of edges in it..\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint a[1009][1009];\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++){\n        string s;\n        cin >>s;\n        for(int j = 1; j <= n; j++){\n            if(s[j-1] == 'a') a[i][j] = 1;\n            if(s[j-1] == 'b') a[i][j] = 2;\n        }\n    }\n    if(m % 2 == 1){\n        cout<<\"YES\"<<endl;\n        for(int i = 1; i <= m + 1; i++)\n            cout << i%2+1<<\" \";\n            cout<<endl;\n        return;\n    }\n    if(n == 2 && a[1][2] != a[2][1]){\n         cout<<\"NO\"<<endl;\n         return;\n    }\n    cout <<\"YES\"<<endl;\n    for(int i = 1; i <= n; i++){\n        for(int j = i+1; j <= n; j++){\n            if(a[i][j] == a[j][i]){\n                for(int x = 1; x <= m+1; x++){\n                    cout << (x % 2 ? i : j) <<\" \";\n                }\n                cout<<endl;\n                return;\n            }\n        }\n    }\n    int x,y,z;\n    if(a[1][2] == a[2][3]) x=1,y=2,z=3;\n    if(a[2][3] == a[3][1]) x=2,y=3,z=1;\n    if(a[3][1] == a[1][2]) x=3,y=1,z=2;\n    if(m % 4 == 2){\n    \n        for(int i = 1; i <= m/4; i++)\n            cout<<x<<\" \"<<y<<\" \"<<z<<\" \"<<y<<\" \";\n        cout<<x<<\" \"<<y<<\" \"<<z<<endl;\n    }\n    else{\n        cout<<y<<\" \";\n          for(int i = 1; i <= m/4; i++)\n            cout<<x<<\" \"<<y<<\" \"<<z<<\" \"<<y<<\" \";\n        cout<<endl;\n    }\n    \n}\nmain(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. AB Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/87523",
    "editorial": "If you can find any two nodes , such that the edge going from to has the\r\nsame value as the edge going from to , then the answer is obviously .If\r\nnot, if is odd you can just choose any two nodes and and keep going\r\nuntil you have a string with length , because any alternating string of\r\nodd length is a palindrome. If is even than you should check if there is\r\ntwo consecutive edges with the same value, that is you need to find\r\nthree different nodes , and such that the edge has the same value as the\r\nedge . Otherwise any string you can get will be an alternating string\r\nand any alternating string with even length is not a palindrome (note\r\nthat for it is always possible to find these three nodes).After finding\r\nnodes , a way that guarantees you can generate a palindrome string is:if\r\nis odd just keep moving until you have a string of length .The string\r\nwill look like which is palindrome.if is even then keep moving until you\r\nhave a string of length .The string will look like which is\r\npalindrome.Complexity .\r\n",
    "hint": []
}