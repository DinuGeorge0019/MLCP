{"link": "https://codeforces.com//contest/1882/problem/E2", "problemId": "2227519", "problem_idx": "E2", "shortId": "1882E2", "contest_number": "1882", "problem_submissions": {"E2": [225204189, 225160002, 225202768, 225477016, 225476880, 225475232, 225472626], "E1": [225123936, 225133746, 225140131, 225133665, 225132240, 225138063, 225142760, 225139602, 225142422, 225147512, 225146106, 225142740, 225141291, 225138856, 225144845, 225148151, 225478094, 225148992, 225162295, 225152100, 225152337, 225148869], "D": [225106356, 225113280, 225112999, 225122785, 225103764, 225119012, 225120043, 225120508, 225110063, 225117734, 225117249, 225125156, 225114397, 225121683, 225123705, 225117693, 225627016, 225115870, 225118591, 225116324, 225122541], "C": [225101844, 225106102, 225108446, 225110739, 225110971, 225110665, 225111630, 225111292, 225113490, 225109057, 225111482, 225110667, 225107121, 225115756, 225110831, 225108821, 225109177, 225108521, 225104527, 225107759], "B": [225097300, 225100132, 225102630, 225101761, 225116077, 225104479, 225103013, 225101827, 225105709, 225102804, 225106906, 225101186, 225121302, 225101604, 225099036, 225100746, 225104002, 225103297, 225100386, 225100570], "A": [225093910, 225094018, 225094163, 225094069, 225115330, 225094938, 225094567, 225094063, 225094790, 225097756, 225096481, 225094301, 225094479, 225093976, 225093977, 225093952, 225104147, 225094178, 225095571, 225096872]}, "name": "E2. Two Permutations  Hard Version ", "statement": "You have two permutations^{\r\ndagger} p_{1}, p_{2},\r\nldots, p_{n} (of integers 1 to n) and q_{1}, q_{2},\r\nldots, q_{m} (of integers 1 to m). Initially p_{i}=a_{i} for i=1, 2,\r\nldots, n, and q_{j} = b_{j} for j = 1, 2,\r\nldots, m. You can apply the following operation on the permutations\r\nseveral (possibly, zero) times.In one operation, p and q will change\r\naccording to the following three steps: You choose integers i, j which\r\nsatisfy 1\r\nle i\r\nle n and 1\r\nle j\r\nle m. Permutation p is partitioned into three parts using p_i as a\r\npivot: the left part is formed by elements p_1, p_2,\r\nldots, p_{i-1} (this part may be empty), the middle part is the single\r\nelement p_i, and the right part is p_{i+1}, p_{i+2},\r\nldots, p_n (this part may be empty). To proceed, swap the left and the\r\nright parts of this partition. Formally, after this step, p will become\r\np_{i+1}, p_{i+2},\r\nldots, p_{n}, p_{i}, p_{1}, p_{2},\r\nldots, p_{i-1}. The elements of the newly formed p will be reindexed\r\nstarting from 1. Perform the same transformation on q with index j.\r\nFormally, after this step, q will become q_{j+1}, q_{j+2},\r\nldots, q_{m}, q_{j}, q_{1}, q_{2},\r\nldots, q_{j-1}. The elements of the newly formed q will be reindexed\r\nstarting from 1. Your goal is to simultaneously make p_{i}=i for i=1, 2,\r\nldots, n, and q_{j} = j for j = 1, 2,\r\nldots, m.Find any way to achieve the goal , or say that none exists.\r\nPlease note that you minimize the number of operations.^{\r\ndagger} A permutation of length k is an array consisting of k distinct\r\nintegers from 1 to k in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (k=3 but there is 4 in the\r\narray).\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2505;\nint n,m,T;\nint a[maxn],b[maxn],c[maxn],d[maxn],t[maxn],vis[maxn],hav[2][2];\nvector<int>ans[2][2];\nvector< pair<int,int> >res;\nvoid opt(int n,int p){\n\tint ds=0;\n\tfor(int i=p+1;i<=n;i++)\n\t\td[++ds]=c[i];\n\td[++ds]=c[p];\n\tfor(int i=1;i<=p-1;i++)\n\t\td[++ds]=c[i];\n\tfor(int i=1;i<=n;i++)\n\t\tc[i]=d[i];\n}\nvoid solve(int n,int o){\n//\tprintf(\"solve n=%d o=%d\\n\",n,o);\n\tfor(int s=0;s<=n;s++){\n\t\tint pos=-1;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tc[i]=t[(i+s)%(n+1)];\n//\t\t\tprintf(\"%d%c\",c[i],i==n? '\\n':' ');\n\t\t\tif(c[i]==0)\n\t\t\t\tpos=i;\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvector<int>V;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tif(vis[i]==0){\n\t\t\t\tif(c[i]==i){\n\t\t\t\t\tvis[i]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvector<int>W;\n\t\t\t\tfor(int j=i;vis[j]==0;j=c[j])\n\t\t\t\t\tvis[j]=1,W.emplace_back(j);\n\t\t\t\tif(i==0)\n\t\t\t\t\tfor(int j=W.size()-2;j>=0;j--)\n\t\t\t\t\t\tV.emplace_back((W[j]-pos+(n+1)-1)%(n+1)+1),pos=W[j];\n\t\t\t\telse{\n\t\t\t\t\tint rec=pos;\n\t\t\t\t\tfor(int j=W.size()-1;j>=0;j--)\n\t\t\t\t\t\tV.emplace_back((W[j]-pos+(n+1)-1)%(n+1)+1),pos=W[j];\n\t\t\t\t\tV.emplace_back((rec-pos+(n+1)-1)%(n+1)+1),pos=rec;\n\t\t\t\t}\n\t\t\t}\n//\t\tprintf(\"V.size()=%d\\n\",V.size());\n//\t\tfor(int i=0;i<V.size();i++)\n//\t\t\tprintf(\"%d%c\",V[i],i==V.size()-1? '\\n':' ');\n\t\tif(hav[o][V.size()&1]==0||(ans[o][V.size()&1].size()>V.size()))\n\t\t\thav[o][V.size()&1]=1,ans[o][V.size()&1]=V;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tmemcpy(t,a,sizeof(t)),solve(n,0),memcpy(t,b,sizeof(t)),solve(m,1);\n\tint ok=0;\n\tfor(int o=0;o<=1;o++)\n\t\tif(hav[0][o]&&hav[1][o]){\n\t\t\tvector< pair<int,int> >V(max(ans[0][o].size(),ans[1][o].size()));\n//\t\t\tprintf(\"o=%d %d %d\\n\",o,ans[0][o].size(),ans[1][o].size());\n\t\t\tfor(int i=0,p=0,q=0;i<V.size();i++){\n\t\t\t\tint u,v;\n\t\t\t\tif(i<ans[0][o].size())\n\t\t\t\t\tu=ans[0][o][i];\n\t\t\t\telse u=p==0? 1:n,p^=1;\n\t\t\t\tif(i<ans[1][o].size())\n\t\t\t\t\tv=ans[1][o][i];\n\t\t\t\telse v=q==0? 1:m,q^=1;\n\t\t\t\tV[i]=make_pair(u,v);\n\t\t\t}\n\t\t\tif(ok==0||(V.size()<res.size()))\n\t\t\t\tres=V,ok=1;\n\t\t}\n\tif(ok==0){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",res.size());\n\tfor(int i=0;i<res.size();i++)\n\t\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\t/*memcpy(c,a,sizeof(c));\n\tfor(int i=0;i<res.size();i++)\n\t\topt(n,res[i].first);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d%c\",c[i],i==n? '\\n':' '),assert(c[i]==i);\n\tmemcpy(c,b,sizeof(c));\n\tfor(int i=0;i<res.size();i++)\n\t\topt(m,res[i].second);\n\tfor(int i=1;i<=m;i++)\n\t\tprintf(\"%d%c\",c[i],i==m? '\\n':' '),assert(c[i]==i);*/\n\treturn 0;\n}\n//n n-1 ... 2 1: dis=(n/2)*3-2\n//1 n n-1 ... 2: dis=(n/2)*3-3\n//1 2 n n-1 ...: dis=(n/2)*3-3\n//2 1 n n-1 ...: dis=(n/2)*3-4\n//1 2 3 n n-1 ...:  n=5(3) n=6(3) n=7(6) n=8(6) n=9(8)"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "3100", "interactive": false}