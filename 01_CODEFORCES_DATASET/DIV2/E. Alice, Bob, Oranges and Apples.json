{
    "link": "https://codeforces.com//contest/586/problem/E",
    "problemId": "37962",
    "problem_idx": "E",
    "shortId": "586E",
    "contest_number": "586",
    "problem_submissions": {
        "E": [
            13567845,
            13568877,
            13567853,
            13571593,
            13562355,
            13570559,
            13579749,
            13567129,
            13570139
        ],
        "D": [
            13563971,
            13564646,
            13563820,
            13563849,
            13568951,
            13565926,
            13563286,
            13563128,
            13565918,
            13569000,
            13562593,
            13568454,
            13565954,
            13567393,
            13563819,
            13565909,
            13564075,
            13560941,
            13564537
        ],
        "B": [
            13561164,
            13559370,
            13561077,
            13558098,
            13558769,
            13558957,
            13558122,
            13557083,
            13558517,
            13557741,
            13558248,
            13560292,
            13558220,
            13559476,
            13561469,
            13562240,
            13557548,
            13564661,
            13557987
        ],
        "C": [
            13559947,
            13561510,
            13560077,
            13560242,
            13565430,
            13561001,
            13561323,
            13561803,
            13560466,
            13563719,
            13560353,
            13561394,
            13595712,
            13558752,
            13585345,
            13584852
        ],
        "A": [
            13555951,
            13556306,
            13555953,
            13556124,
            13556417,
            13555955,
            13556118,
            13555916,
            13556066,
            13556106,
            13556370,
            13556409,
            13556782,
            13556040,
            13560781,
            13556168,
            13565723,
            13556286
        ],
        "F": [
            13577881,
            13572057,
            13572184,
            13570880,
            13588219,
            13595048,
            13570334,
            13571136,
            13601061
        ]
    },
    "name": "E. Alice, Bob, Oranges and Apples",
    "statement": "Alice and Bob decided to eat some fruit. In the kitchen they found a\r\nlarge bag of oranges and apples. Alice immediately took an orange for\r\nherself, Bob took an apple. To make the process of sharing the remaining\r\nfruit more fun, the friends decided to play a game. They put multiple\r\ncards and on each one they wrote a letter, either \u201d, or the letter \u201d.\r\nThen they began to remove the cards one by one from left to right, every\r\ntime they removed a card with the letter \u201d, Alice gave Bob all the\r\nfruits she had at that moment and took out of the bag as many apples and\r\nas many oranges as she had before. Thus the number of oranges and apples\r\nAlice had, did not change. If the card had written letter \u201d, then Bob\r\ndid the same, that is, he gave Alice all the fruit that he had, and took\r\nfrom the bag the same set of fruit. After the last card way removed, all\r\nthe fruit in the bag were over.You know how many oranges and apples was\r\nin the bag at first. Your task is to find any sequence of cards that\r\nAlice and Bob could have played with.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n\n#ifdef WIN32\n\t#define LL \"%I64d\"\n#else\n\t#define LL \"%lld\"\n#endif\n\nconst char s[] = \"AB\";\n\nlong long x, y;\n\nlong long gcd(long long a, long long b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nvoid gcd(long long x, long long y, char a, char b) {\n\twhile (!(x == 1 && y == 1)) {\n\t\tif (x < y) {\n\t\t\tstd::swap(x, y);\n\t\t\tstd::swap(a, b);\n\t\t}\n\t\tprintf(LL \"%c\", (x - 1) / y, a);\n\t\tlong long ox = x, oy = y;\n\t\tx = ox - (ox - 1) / oy * oy;\n\t\ty = oy;\n\t}\n}\n\nint main() {\n\tscanf(LL LL, &x, &y);\n\tif (gcd(x, y) != 1ll) return puts(\"Impossible\"), 0;\n\telse{\n\t\tgcd(x, y, 'A', 'B');\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Alice, Bob, Oranges and Apples.json",
    "editorial_link": "https://codeforces.com//blog/entry/20898",
    "editorial": "Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x,?y) with letters  and , he would get the Stern\u0096Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x,?y) pair is the fraction we are searching.\n\nThis means that if , (x,?y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x?>?y, we should firstly go in the right subtree. Moreover, we could then consider we are searching  from the root. If x?<?y, we should go left and next consider  from the root. This gives us Euclidian algorithm, which could be realized to work in  complexity."
}