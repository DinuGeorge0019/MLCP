{
    "link": "https://codeforces.com//contest/1735/problem/C",
    "problemId": "1564417",
    "problem_idx": "C",
    "shortId": "1735C",
    "contest_number": "1735",
    "problem_submissions": {
        "B": [
            177889662,
            177889589,
            174382271,
            174383359,
            174378958,
            174381714,
            174380678,
            174381284,
            174379449,
            174381236,
            174383409,
            174380794,
            174386997,
            174380696,
            174383029,
            174388681,
            174388918,
            174381361,
            174381492,
            174380657
        ],
        "C": [
            177889461,
            174387237,
            174388475,
            174385426,
            174386634,
            174386940,
            174388812,
            174387047,
            174386729,
            174389951,
            174392206,
            174395309,
            174395650,
            174392066,
            174399201,
            174396076,
            174396038,
            174408989,
            174396383
        ],
        "D": [
            177889264,
            177889136,
            174395610,
            174396308,
            174396251,
            174394725,
            174402042,
            174395692,
            174394285,
            174419012,
            174399212,
            175815897,
            174399788,
            174408325,
            174404931,
            174401396,
            174409441,
            174402400,
            174412649,
            174401383,
            174405540
        ],
        "E": [
            177889081,
            174408134,
            174405644,
            174412472,
            174412292,
            174413019,
            174414458,
            174417521,
            174411011,
            174419212,
            175815464,
            174463147,
            174421324,
            174420863,
            174423975,
            174427537,
            174420606,
            174423899,
            174420778,
            174422936,
            174422611
        ],
        "F": [
            177888879,
            174528121,
            174463614,
            174586382
        ],
        "A": [
            177888485,
            174377614,
            174378788,
            174377462,
            174377792,
            174377956,
            174378462,
            174377717,
            174377806,
            174378861,
            174382247,
            174379109,
            174377781,
            174377528,
            174379924,
            174379851,
            174378283,
            174383584,
            174377997
        ]
    },
    "name": "C. Phase Shift",
    "statement": "There was a string s which was supposed to be encrypted. For this\r\nreason, all 26 lowercase English letters were arranged in a circle in\r\nsome order, afterwards, each letter in s was replaced with the one that\r\nfollows in clockwise order, in that way the string t was obtained. You\r\nare given a string t. Determine the lexicographically smallest string s\r\nthat could be a prototype of the given string t.A string a is\r\nlexicographically smaller than a string b of the same length if and only\r\nif: in the first position where a and b differ, the string a has a\r\nletter, that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n",
    "solutions": [
        "// LUOGU_RID: 91547491\n//author: HugeWide\n/*rating:\nCodeforces: 2028,Candidate Master\nAtcoder: 2025,1Dan\nLuogu: 312=100+52+0+100+60\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\n\ninline ll read() {\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-') f=-f;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>=10) write(x/10);\n\tputchar(x%10+'0');\n}\n#define writesp(x) write(x),putchar(' ')\n#define writeln(x) write(x),putchar('\\n')\n\n#define rep(x,l,r) for(int x=l;x<=r;x++)\n#define per(x,r,l) for(int x=r;x>=l;x--)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nconst int N=100100;\n\nint n;\nchar s[N];\nint a[N];\n\nint nxt[N];\nbool vis[N];\nint C;\n\nint fa[N];\nint find(int x) {\n\tif(fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nvoid merge(int x,int y) {\n\tx=find(x),y=find(y);\n\tif(x==y) return;\n\tfa[y]=x;\n}\n\nvoid solve() {\n\tn=read(); scanf(\"%s\",s+1);\n\trep(i,1,n) a[i]=s[i]-'a';\n\trep(i,0,25) nxt[i]=-1,vis[i]=0;\n\trep(i,0,25) fa[i]=i; C=0;\n\trep(i,1,n) {\n\t\tif(nxt[a[i]]==-1) {\n\t\t\tint k=-1;\n\t\t\trep(j,0,25) if(j!=a[i]) {\n\t\t\t\tif(!vis[j]) {\n\t\t\t\t\tif(find(a[i])==find(j)) {\n\t\t\t\t\t\tif(C<25) continue;\n\t\t\t\t\t}\n\t\t\t\t\tk=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnxt[a[i]]=k,vis[k]=1; C++;\n\t\t\tmerge(a[i],k);\n\t\t}\n\t}\n\trep(i,1,n) putchar(nxt[a[i]]+'a');\n\tputchar('\\n');\n}\n\nint main() {\n\tint t=read(); while(t--) solve();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Phase Shift.json",
    "editorial_link": "https://codeforces.com//blog/entry/107533",
    "editorial": "SolutionFirst of all, the encryption process is reversible. If we\r\nobtained from using the circle , we can obtain from using the same cycle\r\n, but reversed.So, letâs think in terms of encryption of\r\n.Lexicographical order itself is a greedy thing. So, we can create a\r\ngreedy algorithm.Letâs go from left to right and generate the result\r\nletter by letter. We have to choose the best possible option at each\r\nstep. Letâs describe the options we have. If the current letter was used\r\nearlier, we already know the replacement we need to choose. Otherwise,\r\nwe would like to choose the minimum possible option. We need to maintain\r\nsome structure to know what is acceptable. Letâs keep the circle that is\r\nalready generated(itâs a graph). For each letter we have one incoming\r\nedge and one outgoing edge in the end. Letâs keep them for every letter:\r\narrays , .When we want to generate an outgoing edge at some step(letâs\r\ndefine the letter on this step as ), we have to choose the minimum\r\nletter that doesnât have an incoming edge yet. With one exception: if\r\ncreating the edge using this rule creates a circle of size less than .\r\nIt would mean that we wouldnât have a full circle in the end. Itâs easy\r\nto see that there is no more than one such letter, as this letter is\r\njust the end of a chain starting in .To check that a small circle wasnât\r\ngenerated, we can go along an outgoing edge times, starting at . If we\r\nend up in or there was no edge at some step then everything is ok, we\r\ncan create this edge.Complexity is , that is, .\r\n",
    "hint": [
        "Hint1 What is the first letter in the answer?",
        "Hint2 Ask the same question as Hint1 for each position.",
        "Hint3 When we can't choose the minimum unused letter?"
    ]
}