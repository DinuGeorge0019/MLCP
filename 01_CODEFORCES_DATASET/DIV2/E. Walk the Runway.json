{"link": "https://codeforces.com//contest/1826/problem/E", "problemId": "1909269", "problem_idx": "E", "shortId": "1826E", "contest_number": "1826", "problem_submissions": {"E": [204602017, 204700967, 204596765, 204613109, 204610329, 204611748, 204612296, 204613897, 204618004, 204612275, 204613205, 204624231, 204661971, 204617315, 204616794, 204621809, 204612737, 204608182, 204614402, 204623261, 204628297, 204657040, 204656984, 204620172], "D": [204582402, 204585260, 204585742, 204589825, 204587542, 204586441, 204588591, 204588717, 204601344, 204595957, 204585944, 204587666, 204590835, 204583319, 204595885, 204598399, 204596824, 204590840, 204586792, 204595240], "C": [204575229, 204577835, 204576798, 204582977, 204581863, 204581888, 204584053, 204580950, 204583799, 204579525, 204580707, 204583107, 204584404, 204580743, 204585996, 204593307, 204588423, 204580589, 204579635, 204588957], "B": [204572809, 204580324, 204572676, 204573618, 204574774, 204576010, 204578782, 204574513, 204577548, 204573291, 204574259, 204574305, 204578256, 204586331, 204580048, 204581387, 204580847, 204576280, 204573990, 204577086], "A": [204572057, 204576972, 204571963, 204571901, 204572576, 204573728, 204575534, 204572534, 204574691, 204572015, 204572728, 204572787, 204573859, 204573619, 204575569, 204576295, 204576573, 204576421, 204572686, 204573646], "F": [204650095, 204649588, 204792576, 204790910, 204785582, 204784675, 204782497, 204779284, 205142563]}, "name": "E. Walk the Runway", "statement": "A fashion tour consists of m identical runway shows in different cities.\r\nThere are n models willing to participate in the tour, numbered from 1\r\nto n. People in different cities have different views on the fashion\r\nindustry, so they rate each model differently. In particular, people in\r\ncity i rate model j with rating r_{i, j}.You are to choose some number\r\nof k models, and their order, let the chosen models have indices j_1,\r\nj_2,\r\ndots, j_k in the chosen order. In each city, these k models will walk\r\nthe runway one after another in this order. To make the show exciting,\r\nin each city, the ratings of models should be strictly increasing in the\r\norder of their performance. More formally, for any city i and index t (2\r\nleq t\r\nleq k), the ratings must satisfy r_{i,j_{t - 1}} < r_{i,j_t}. After all,\r\nthe fashion industry is all about money, so choosing model j to\r\nparticipate in the tour profits you p_j money. Compute the maximum total\r\nprofit you can make by choosing the models and their order while\r\nsatisfying all the requirements.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nconst int N = 5005;\nbitset<N> cant[N];\nint reward[N];\n\nint a[N][N];\nint n, m;\n\nll dp[N];\nint order[N];\n\nvoid solve(){\n    cin >> m >> n;\n    for(int i=1;i<=n;i++) cin >> reward[i];\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            cin >> a[i][j];\n        }\n    }\n    for(int r=1;r<=m;r++){\n        vector<pii> models;\n        for(int i=1;i<=n;i++){\n            models.pb(mp(a[r][i], i));\n        }\n        sort(models.begin(), models.end());\n        bitset<N> was;\n        for(int i=0;i<n;i++){\n            int j = i;\n            while(j + 1 < n && models[j + 1].st == models[j].st) j++;\n            for(int k=i;k<=j;k++){\n                was[models[k].nd] = true;\n            }\n            for(int k=i;k<=j;k++){\n                cant[models[k].nd] |= was;\n            }\n            i = j;\n        }\n    }\n    const ll inf = 1e18;\n    for(int i=1;i<=n;i++) dp[i] = -inf;\n    vector<pii> ord;\n    for(int i=1;i<=n;i++) ord.pb(mp(a[1][i], i));\n    sort(ord.begin(), ord.end());\n    for(int i=1;i<=n;i++) order[i] = ord[i - 1].nd;\n    ll ans = 0;\n    for(int i=1;i<=n;i++){\n        dp[i] = reward[order[i]];\n        ans = max(ans, dp[i]);\n    }\n    for(int i=1;i<n;i++){\n        int who = order[i];\n        for(int j=i+1;j<=n;j++){\n            if(!cant[who][order[j]]){\n                dp[j] = max(dp[j], dp[i] + reward[order[j]]);\n                ans = max(ans, dp[j]);\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    // cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "data structures", "dp", "graphs", "implementation", "sortings"], "dificulty": "2400", "interactive": false}