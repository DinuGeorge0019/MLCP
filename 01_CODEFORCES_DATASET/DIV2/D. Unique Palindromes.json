{"link": "https://codeforces.com//contest/1823/problem/D", "problemId": "1896870", "problem_idx": "D", "shortId": "1823D", "contest_number": "1823", "problem_submissions": {"E": [203705839, 203701788, 203710907, 203711770, 203705371, 203702158, 203705164, 203708687, 203695617, 203698015, 203713863, 203711164, 203711208], "F": [203698273, 203688371, 203699854, 203692525, 203713776, 203706591, 203701681, 203697250, 203707004, 203714464, 203718741, 203709649, 204276537, 203715624], "D": [203690544, 203695164, 203688855, 203701895, 203696407, 203691855, 203694127, 203710546, 203714159, 203700668, 203695441, 203690745, 203703946, 203707611, 203710099, 203694539, 203701580, 203697921, 203699365], "C": [203682587, 203678999, 203681052, 203684144, 203687732, 203680914, 203689997, 203682944, 203686588, 203690248, 203682397, 203683673, 203689305, 203682640, 203682923, 203682065, 203686779, 203685407, 203684445, 203683205], "B": [203677458, 203684522, 203677423, 203681465, 203680710, 203678118, 203686689, 203678181, 203679545, 203680940, 203678605, 203678733, 203683292, 203678419, 203679073, 203679634, 203680902, 203679216, 203679313], "A": [203676393, 203676826, 203676383, 203676665, 203678720, 203676331, 203678496, 203676540, 203676948, 203676909, 203676591, 203676707, 203676528, 203676629, 203676389, 203676483, 203678253, 203677369, 203678056]}, "name": "D. Unique Palindromes", "statement": "A is a string that reads the same backwards as forwards. For example,\r\nthe string is palindrome, while the string is not.Let p(t) be the number\r\nof of string t, i. e. the number of substrings t[l\r\ndots r] that are palindromes themselves. Even if some substring occurs\r\nin t several times, it\u2019s counted exactly once. (The whole string t is\r\nalso counted as a substring of t).For example, string t = has p(t) = 6\r\nunique palindromic substrings: , , , , and .Now, let\u2019s define p(s, m) =\r\np(t) where t = s[1\r\ndots m]. In other words, p(s, m) is the number of palindromic substrings\r\nin the prefix of s of length m. For example, p(, 5) = p() = 5.You are\r\ngiven an integer n and k \"conditions\" (k\r\nle 20). Let\u2019s say that string s, consisting of n lowercase Latin\r\nletters, is if all k conditions are satisfied . A condition is a pair\r\n(x_i, c_i) and have the following meaning: p(s, x_i) = c_i, i. e. a\r\nprefix of s of length x_i contains exactly c_i unique palindromic\r\nsubstrings. Find a good string s or report that such s doesn\u2019t\r\nexist.Look in Notes if you need further clarifications.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N],b[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    a[0]=b[0]=0;\n    for(int i=1; i<=k; ++i) cin >> a[i];\n    for(int i=1; i<=k; ++i) cin >> b[i];\n    for(int i=0; i<k; ++i) if(b[i+1]-b[i]>a[i+1]-a[i]){\n        cout << \"NO\\n\";\n        return;\n    }\n    string res;\n    int cur=-1,cur2=-1;\n    for(int i=0; i<k; ++i){\n        int cnt=b[i+1]-b[i];\n        bool flag=0;\n        for(int j=a[i]; j<a[i+1]; ++j){\n            if(j<3){\n                cur++;\n                res+='a'+cur,cnt--;\n            }\n            else if(!flag&&b[i+1]-b[i]>0){\n                cur++;\n                res+='a'+cur,cnt--;\n            }\n            else if(cnt==0){\n                cur2++;\n                if(cur2==3) cur2=0;\n                res+='a'+cur2;\n            }\n            else res+='a'+cur,cnt--;\n            flag=1;\n        }\n    }\n    cout << \"YES\\n\" << res << \"\\n\";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "math", "strings"], "dificulty": "1900", "interactive": false}