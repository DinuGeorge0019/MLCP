{
    "link": "https://codeforces.com//contest/1823/problem/D",
    "problemId": "1896870",
    "problem_idx": "D",
    "shortId": "1823D",
    "contest_number": "1823",
    "problem_submissions": {
        "E": [
            203705839,
            203701788,
            203710907,
            203711770,
            203705371,
            203702158,
            203705164,
            203708687,
            203695617,
            203698015,
            203713863,
            203711164,
            203711208
        ],
        "F": [
            203698273,
            203688371,
            203699854,
            203692525,
            203713776,
            203706591,
            203701681,
            203697250,
            203707004,
            203714464,
            203718741,
            203709649,
            204276537,
            203715624
        ],
        "D": [
            203690544,
            203695164,
            203688855,
            203701895,
            203696407,
            203691855,
            203694127,
            203710546,
            203714159,
            203700668,
            203695441,
            203690745,
            203703946,
            203707611,
            203710099,
            203694539,
            203701580,
            203697921,
            203699365
        ],
        "C": [
            203682587,
            203678999,
            203681052,
            203684144,
            203687732,
            203680914,
            203689997,
            203682944,
            203686588,
            203690248,
            203682397,
            203683673,
            203689305,
            203682640,
            203682923,
            203682065,
            203686779,
            203685407,
            203684445,
            203683205
        ],
        "B": [
            203677458,
            203684522,
            203677423,
            203681465,
            203680710,
            203678118,
            203686689,
            203678181,
            203679545,
            203680940,
            203678605,
            203678733,
            203683292,
            203678419,
            203679073,
            203679634,
            203680902,
            203679216,
            203679313
        ],
        "A": [
            203676393,
            203676826,
            203676383,
            203676665,
            203678720,
            203676331,
            203678496,
            203676540,
            203676948,
            203676909,
            203676591,
            203676707,
            203676528,
            203676629,
            203676389,
            203676483,
            203678253,
            203677369,
            203678056
        ]
    },
    "name": "D. Unique Palindromes",
    "statement": "A is a string that reads the same backwards as forwards. For example,\r\nthe string is palindrome, while the string is not.Let p(t) be the number\r\nof of string t, i. e. the number of substrings t[l\r\ndots r] that are palindromes themselves. Even if some substring occurs\r\nin t several times, it\u2019s counted exactly once. (The whole string t is\r\nalso counted as a substring of t).For example, string t = has p(t) = 6\r\nunique palindromic substrings: , , , , and .Now, let\u2019s define p(s, m) =\r\np(t) where t = s[1\r\ndots m]. In other words, p(s, m) is the number of palindromic substrings\r\nin the prefix of s of length m. For example, p(, 5) = p() = 5.You are\r\ngiven an integer n and k \"conditions\" (k\r\nle 20). Let\u2019s say that string s, consisting of n lowercase Latin\r\nletters, is if all k conditions are satisfied . A condition is a pair\r\n(x_i, c_i) and have the following meaning: p(s, x_i) = c_i, i. e. a\r\nprefix of s of length x_i contains exactly c_i unique palindromic\r\nsubstrings. Find a good string s or report that such s doesn\u2019t\r\nexist.Look in Notes if you need further clarifications.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N],b[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    a[0]=b[0]=0;\n    for(int i=1; i<=k; ++i) cin >> a[i];\n    for(int i=1; i<=k; ++i) cin >> b[i];\n    for(int i=0; i<k; ++i) if(b[i+1]-b[i]>a[i+1]-a[i]){\n        cout << \"NO\\n\";\n        return;\n    }\n    string res;\n    int cur=-1,cur2=-1;\n    for(int i=0; i<k; ++i){\n        int cnt=b[i+1]-b[i];\n        bool flag=0;\n        for(int j=a[i]; j<a[i+1]; ++j){\n            if(j<3){\n                cur++;\n                res+='a'+cur,cnt--;\n            }\n            else if(!flag&&b[i+1]-b[i]>0){\n                cur++;\n                res+='a'+cur,cnt--;\n            }\n            else if(cnt==0){\n                cur2++;\n                if(cur2==3) cur2=0;\n                res+='a'+cur2;\n            }\n            else res+='a'+cur,cnt--;\n            flag=1;\n        }\n    }\n    cout << \"YES\\n\" << res << \"\\n\";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Unique Palindromes.json",
    "editorial_link": "https://codeforces.com//blog/entry/115465",
    "editorial": "Let us estimate the possible number of unique palindromes : for : ; for\r\n: (in both cases: if symbols are equal and if not); for : . Any\r\ncombination of the first three characters gives . If you add a character\r\nto the string, will increase by either or . This can be proven by\r\ncontradiction. Assume . Choose of any new palindromes. The shorter one\r\nis both a suffix and a prefix of the larger one (since both are\r\npalindromes), but we\u00e2\u0080\u0099ve added all the palindromes. So the smaller one\r\nwas added earlier. An example of a string with : . An example of a\r\nstring with : . For solving the task for only one condition , let\u00e2\u0080\u0099s\r\ncombine the ideas: let\u00e2\u0080\u0099s build a string By choosing the prefix of\r\nappropriate length that consists of characters, we can achieve all the\r\nvalues of . Print characters and then characters until the end of the\r\nstring.Let solve the initial task for conditions. Firstly, we build the\r\nanswer for the first condition. After that, assume we have answer for\r\nfirst conditions. If , then we can\u00e2\u0080\u0099t build an answer by lemma.\r\nOtherwise, we can do the following: take a symbol, that wasn\u00e2\u0080\u0099t used and\r\nappend it times to answer; then append symbols . The final string will\r\nlook as following, where symbol shows conditions boundaries: Note that,\r\nin order not to create unnecessary palindromes, if we finished the\r\nprevious block with some character (for example, ), the next block\r\nshould start with the next character ().\r\n"
}