{
    "link": "https://codeforces.com//contest/1816/problem/B",
    "problemId": "1871423",
    "problem_idx": "B",
    "shortId": "1816B",
    "contest_number": "1816",
    "problem_submissions": {
        "F": [
            201571165,
            201575603
        ],
        "E": [
            201540535,
            201521580,
            201552172,
            201540274,
            201551497,
            201560232,
            201559664,
            201557564,
            201560804,
            201563162,
            201561880,
            201537774,
            201526707,
            201515322,
            201535371,
            201540257,
            201545215
        ],
        "D": [
            201526272,
            201555297,
            201531457,
            201549839,
            201530007,
            201538289,
            201538409,
            201545276,
            201541091,
            201540016,
            201546751,
            201561431
        ],
        "C": [
            201502393,
            201505622,
            201493541,
            201488761,
            201501981,
            201485106,
            201492364,
            201508062,
            201504590,
            201507370,
            201512800,
            201550313,
            201501935,
            201545685,
            201512228,
            201507426,
            201505339
        ],
        "B": [
            201495797,
            201498113,
            201488843,
            201489011,
            201486184,
            201503986,
            201518658,
            201489822,
            201495126,
            201490303,
            201498690,
            201494781,
            201494291,
            201504455,
            201496973,
            201494497,
            201495296
        ],
        "A": [
            201482599,
            201481556,
            201482965,
            201480957,
            201481143,
            201486345,
            201502905,
            201481407,
            201481488,
            201481674,
            201480959,
            201483748,
            201481910,
            201493735,
            201483634,
            201482175,
            201488121
        ]
    },
    "name": "B. Grid Reconstruction",
    "statement": "Consider a 2\r\ntimes n grid, where n is an integer. You may place the integers 1, 2,\r\nldots, 2n on the grid, using each integer .A is a sequence of cells\r\nachieved by starting at (1, 1), then repeatedly walking either downwards\r\nor to the right, and stopping when (2, n) is reached. The path should\r\nnot extend beyond the grid.The of a path is the alternating sum of the\r\nnumbers written on the cells in a path. That is, let the numbers written\r\non the cells be a_1, a_2,\r\nldots, a_k (in the order that it is visited), the cost of the path is\r\na_1 - a_2 + a_3 - a_4 +\r\nldots =\r\nsum_{i=1}^k a_i\r\ncdot (-1)^{i+1}.Construct a way to place the integers 1, 2,\r\nldots, 2n on the grid, such that the minimum cost over all paths from\r\n(1, 1) to (2, n) is maximized. If there are multiple such grids that\r\nresult in the maximum value, output any of them.\r\n",
    "solutions": [
        "//\n//  main.cpp\n//  B\n//\n//  Created by Thomas Guo on 2023-04-09.\n//\n\n#include <iostream>\n#define maxn 100002\nusing namespace std;\nint grid[maxn][2];\nint main(){\n    int t;cin>>t;\n    while(t--){\n        int n;cin>>n;\n        grid[0][0] = 2*n;\n        grid[n-1][1] = 2*n-1;\n        int lo = 1, hi = 2*n-2;\n        for(int i=0; i<n-1; i++){\n            if(i%2 == 0){\n                grid[i][1] = lo;\n                grid[i+1][0] = lo+1;\n                lo += 2;\n            }\n            else{\n                grid[i][1] = hi-1;\n                grid[i+1][0] = hi;\n                hi -= 2;\n            }\n        }\n        for(int i=0; i<2; i++){\n            for(int j=0; j<n; j++){\n                cout<<grid[j][i]<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Grid Reconstruction.json",
    "editorial_link": "https://codeforces.com//blog/entry/114899",
    "editorial": "EditorialObserve that will be added if is even, and will be subtracted\r\notherwise. This forms a checkered pattern.Obviously, it is optimal for\r\nall values that will be added to be strictly larger than all values that\r\nwill be subtracted. Also, the difference between the value of adjacent\r\ngrids should be almost equal (by some definition of almost).We construct\r\narray as follows: and For and is even, and For and is odd, and For\r\nexample, when , the output will be Insights on how to find the\r\nconstruction(This is a very informal proof. See \"Proof\" below for a\r\nformal proof.)First of all, due to the checkered pattern, should be\r\nfilled with , and should be filled with . In particular, and should be\r\nand .Next, as we are trying to maximise the minimum, the difference\r\nbetween paths shouldn\u00e2\u0080\u0099t be large (since the minimum path will be smaller\r\nif the difference is larger). Notice that a path consists of a prefix of\r\nand a suffix of , and the difference between adjacent paths is Unable to\r\nparse markup [type=CF_MATHJAX] (depending on the parity of ). It is\r\noptimal for the difference to be as small as possible (which is\r\n).Finally, it is optimal that stays constant in the whole array. If they\r\nare different, the difference between paths (not adjacent) will be\r\nlarger than , which is suboptimal. ProofConsider the cost of the top\r\nright path and bottom left path.The cost of the top right path is .The\r\ncost of the bottom right path is .Summing both values, we getwhich is\r\nequal toThis value attains maximum when , , and , which is .Therefore,\r\nthe upper bound for the maximum cost is . We will now show that the\r\nconstruction above meets the upper bound.Let be the cost of the path\r\n.Observe that , as the paths differ by exactly grids and (from the above\r\nconstruction).Calculating ,Therefore, , which achieves the upper bound.\r\n"
}