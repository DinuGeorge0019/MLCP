{
    "link": "https://codeforces.com//contest/1166/problem/E",
    "problemId": "345555",
    "problem_idx": "E",
    "shortId": "1166E",
    "contest_number": "1166",
    "problem_submissions": {
        "F": [
            54316652,
            54307224,
            54305584,
            54310646,
            54378086,
            54313232,
            54308575
        ],
        "E": [
            54298891,
            54300156,
            54304094,
            54294518,
            54300338,
            54303194,
            54301468,
            54302857,
            54297877,
            54295582,
            54302504,
            54299216,
            54297435,
            54297855,
            54304772,
            54304820,
            54295745,
            54296534
        ],
        "D": [
            54296262,
            54291838,
            54301051,
            54302058,
            54297357,
            54294897,
            54294795,
            54298322,
            54305898,
            54305908,
            54298392,
            54300155,
            54304713,
            54305703,
            54307005,
            54301062,
            54300346,
            54307391,
            54309804
        ],
        "C": [
            54289104,
            54297291,
            54291974,
            54290534,
            54287551,
            54289613,
            54287736,
            54292153,
            54290078,
            54292325,
            54290260,
            54291592,
            54291908,
            54293597,
            54292202,
            54290296,
            54292002,
            54299709,
            54289976
        ],
        "B": [
            54286717,
            54295090,
            54286733,
            54287427,
            54290240,
            54285781,
            54285576,
            54288042,
            54287483,
            54286749,
            54287663,
            54286685,
            54286479,
            54286327,
            54288426,
            54286838,
            54288503,
            54286890,
            54287732
        ],
        "A": [
            54284453,
            54292968,
            54284797,
            54284966,
            54291534,
            54284478,
            54284450,
            54284940,
            54284548,
            54284402,
            54284377,
            54284696,
            54284645,
            54284386,
            54285929,
            54284902,
            54285432,
            54284438,
            54284725
        ]
    },
    "name": "E. The LCMs Must be Large",
    "statement": "Dora the explorer has decided to use her money after several years of\r\njuicy royalties to go shopping. What better place to shop than\r\nNlogonia?There are n stores numbered from 1 to n in Nlogonia. The i-th\r\nof these stores offers a a_i.Each day among the last m days Dora bought\r\na single integer from some of the stores. The same day, Swiper the fox\r\nbought a single integer from all the stores that Dora did not buy an\r\ninteger from on that day.Dora considers Swiper to be her rival, and she\r\nconsiders that she beat Swiper on day i if and only if the least common\r\nmultiple of the numbers she bought on day i is strictly greater than the\r\nleast common multiple of the numbers that Swiper bought on day i.The\r\nleast common multiple (LCM) of a collection of integers is the smallest\r\npositive integer that is divisible by all the integers in the\r\ncollection.However, Dora forgot the values of a_i. Help Dora find out if\r\nthere are positive integer values of a_i such that she beat Swiper on\r\nday. You don\u2019t need to find what are the possible values of a_i\r\nthough.Note that it is possible for some values of a_i to coincide in a\r\nsolution.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define y0 holdtheflower\n#define y1 enjoythecolorandscent\n#define yn walkthroughthesoulgarden\n#define j1 feelthewarmbreathofkindnessandsalvation\n\n#define endl '\\n'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint m, n;\nvector<vector<bool>> Dora, Swiper;\n\nbool contains(vector<bool> &a, vector<bool> &b) {\n\tfor (int i=0; i<a.size(); i++) {\n\t\tif (!a[i]) continue;\n\t\tif (b[i]) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid Input() {\n\tcin >> m >> n; Dora.resize(m); Swiper.resize(m);\n\tfor (int i=0; i<m; i++) {\n\t\tDora[i].resize(n, false); Swiper[i].resize(n, true);\n\t\tint s; cin >> s;\n\t\tfor (int x=0; x<s; x++) {\n\t\t\tint z; cin >> z; z--;\n\t\t\tDora[i][z] = true; Swiper[i][z] = false;\n\t\t}\n\t}\n}\n\nvoid Solve() {\n\tfor (int i=0; i<m; i++) {\n\t\tfor (int j=0; j<m; j++) {\n\t\t\tif (contains(Dora[i], Swiper[j])) {\n\t\t\t\tcout << \"impossible\\n\"; return;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"possible\\n\";\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}\n\n/******************************************\\\n *  Thuy-Trang Tran, #Team4T's Leader     *\n *  #Team4T Primary Flagship - Salvation  *\n\\******************************************/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. The LCMs Must be Large.json",
    "editorial_link": "https://codeforces.com//blog/entry/67081",
    "editorial": "We denote by\ntextrm{lcm}\n; A the\ntextrm{lcm} of all elements in a collection A. Also, denote by D_i and\nS_i the collections that Dora and Swiper bought on day i,\nrespectively.First, when can we say for sure that the values of a_i\ncannot exist? Well, suppose that D_i = S_j for some i and j. Then we\nalso have D_j = S_i, so if the condition were true we would have\ntextrm{lcm}\n; D_i >\ntextrm{lcm}\n; S_i =\ntextrm{lcm}\n; D_j >\ntextrm{lcm}\n; S_j =\ntextrm{lcm}\n; D_iWhich is of course impossible. What now? We can actually make our\nimpossibility condition a bit stronger by noticing that\ntextrm{lcm}\n; B\nle\ntextrm{lcm}\n; A whenever B is a collection contained in A, which happens because\ntextrm{lcm}\n; B actually divides\ntextrm{lcm}\n; A. Then, if the stores Dora bought from on day i are completely\ndisjoint from the stores Dora bought from on day j, then D_j would be\ncompletely contained in S_i and vice-versa, so\ntextrm{lcm}\n; D_i >\ntextrm{lcm}\n; S_i\ngeq\ntextrm{lcm}\n; D_j >\ntextrm{lcm}\n; S_j\ngeq\ntextrm{lcm}\n; D_iWhich is again a contradiction.Ok, any two days must have a common\nstore for the statement to be possible, so what? The remarkable fact\nhere is that this is the only condition we need to check: i.e., the\nsolution exists if and only if the sets of stores that Dora visited on\ndays i and j intersect for all i and j.How do we get a valid solution?\nWe will take m different prime numbers p_1, p_2,\ndots, p_m and set a_i to be the product of p_j for all the j\u00e2\u0080\u0099s such that\nDora visited store i on day j. Then p_j is a divisor of a_i if and only\nif Dora visited store i on day j.Now proving that this works is easy: We\nknow that on day i, Dora bought an integer from a store that she also\nvisited on day j, and this number must be a multiple of p_j. So\ntextrm{lcm}\n; D_i = p_1p_2\ndots p_m for all i. On the other hand, S_i contains no multiples of p_i,\nbecause they are all in D_i. So the\ntextrm{lcm} of S_i is strictly smaller.Now we just need to check that\nany two days have a common store, which can be done in\nmathcal{O}(nm^2) by checking each pair of days and determining for each\ni whether Dora visited both stores on day i in\nmathcal{O}(n). You can achieve a slight speedup if you check this using\na bitset, but this wasn\u00e2\u0080\u0099t necessary to solve the problem.Complexity:\nmathcal{O}(nm^2).\n"
}