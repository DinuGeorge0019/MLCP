{"link": "https://codeforces.com//contest/369/problem/D", "problemId": "4126", "problem_idx": "D", "shortId": "369D", "contest_number": "369", "problem_submissions": {"D": [5305237, 5312782, 5302575, 5302522, 5304036, 5303475, 5298828, 5304364, 5302322, 5304435, 5307669, 5304261, 5348610], "E": [5299924, 5300916, 5302442, 5306132, 5309865, 5324849, 5304462, 5346294, 5312977, 5302205, 5302615], "C": [5297353, 5298610, 5300018, 5298007, 5298088, 5296130, 5300828, 5301779, 5300657, 5301152, 5298538, 5299357, 5297721, 5300161, 5297375, 5299374, 5298853], "B": [5295698, 5301934, 5295966, 5296687, 5296491, 5297164, 5297880, 5302888, 5299175, 5297625, 5304937, 5296913, 5307548, 5298564, 5304878, 5301724, 5298054], "A": [5294961, 5295577, 5296970, 5295370, 5295286, 5297542, 5295335, 5303463, 5295020, 5295091, 5295149, 5295306, 5295147, 5295682, 5295086, 5295265, 5294962]}, "name": "D. Valera and Fools", "statement": "One fine morning, fools lined up in a row. After that, they numbered\r\neach other with numbers from to , inclusive. Each fool got a unique\r\nnumber. The fools decided not to change their numbers before the end of\r\nthe fun.Every fool has exactly bullets and a pistol. In addition, the\r\nfool number has probability of (in percent) that he kills the fool he\r\nshoots at.The fools decided to have several rounds of the fun. Each\r\nround of the fun looks like this: each currently living fool shoots at\r\nanother living fool with the smallest number (a fool is not stupid\r\nenough to shoot at himself). All shots of the round are perfomed at one\r\ntime (simultaneously). If there is exactly one living fool, he does not\r\nshoot.Let\u2019s define a as the set of numbers of all the living fools at\r\nthe some time. We say that a situation is if for some integer number ()\r\nthere is a nonzero probability that after rounds of the fun this\r\nsituation will occur.Valera knows numbers and . Help Valera determine\r\nthe number of distinct .\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#define lowbit(x) ((x) & (-(x)))\nusing namespace std;\ntypedef long long LL;\nconst int N = 3005;\nint dp[N][N] = {0} , n , k , p[N] , a[N] , b[N];\nqueue <pair <int , int> > q[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (\"input.txt\" , \"r\" , stdin);\n    #endif\n    scanf (\"%d %d\" , &n , &k);\n    if (n == 1) {\n        puts (\"1\");\n        return 0;\n    }\n    a[n + 1] = b[n + 1] = 0;\n    for (int i = 1 ; i <= n ; i ++) {\n        scanf (\"%d\" , &p[i]);\n        a[i] = a[i + 1] + (p[i] != 0);\n        b[i] = b[i + 1] + (p[i] == 100);\n    }\n    for (int i = n ; i >= 1 ; i --) {\n\n        a[i] = a[i + 1] + (p[i] != 0);\n        b[i] = b[i + 1] + (p[i] == 100);\n    }\n    int ans = 1;\n    q[0].push (make_pair (1 , 2));\n    for (int i = 0 ; i < k ; i ++) {\n        while (!q[i].empty ()) {\n            pair <int , int> u = q[i].front ();\n            // cout << u.first << \" \" << u.second << endl;\n            q[i].pop ();\n            if (u.second > n) continue;\n            if (p[u.first] == 100) {\n                if (b[u.second]) {\n                    int x = u.second + 1 , y = min (u.second + 2 , n + 1);\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else if (a[u.second] == 0) {\n                    int x = u.first , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else {\n                    int x = u.second + 1 , y = min (u.second + 2 , n + 1);\n                    // cout << x << \" \" << y << endl;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.first;y = u.second + 1;\n                    // cout << x << \" \" << y << endl;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n            }\n            else if (p[u.first] == 0) {\n                if (b[u.second]) {\n                    int x = u.second , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else if (a[u.second] == 0) {\n                    ;\n                }\n                else {\n                    int x = u.second , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n            }\n            else {\n                if (b[u.second]) {\n                    int x = u.second , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.second + 1 ; y = min (u.second + 2 , n + 1);\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else if (a[u.second] == 0) {\n                    int x = u.first , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n                else {\n                    int x = u.first , y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.second + 1 ; y = min (u.second + 2 , n + 1);\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                    x = u.second ; y = u.second + 1;\n                    if (dp[x][y] == 0) {\n                        ans ++;\n                        dp[x][y] = 1;\n                        q[i + 1].push (make_pair (x , y));\n                    }\n                }\n            }\n        }\n    }\n    printf (\"%d\\n\" , ans);\n    return 0;  \n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "shortest paths"], "dificulty": "2200", "interactive": false}