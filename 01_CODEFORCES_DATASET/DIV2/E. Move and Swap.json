{"link": "https://codeforces.com//contest/1485/problem/E", "problemId": "893888", "problem_idx": "E", "shortId": "1485E", "contest_number": "1485", "problem_submissions": {"F": [107209277, 107219103, 108814340, 107211258, 107197599, 107216697, 107217119, 107223985, 107214681, 107225337, 107211172, 107212087, 107214541, 107225911, 107220634, 107211306, 107210013, 107218638, 107648531, 107215873, 107226560], "E": [107206284, 107213007, 108814429, 107225053, 107217938, 107209463, 107222855, 107215802, 107226662, 107217485, 107225279, 107225123, 107220161, 107219375, 107225854, 107230167, 107219696, 107215124], "C": [107199370, 107197518, 107195894, 107212349, 107194668, 107198452, 107203154, 107405885, 107204141, 107200897, 107195457, 107204332, 107206480, 107202401, 107199135, 107196987, 107201461, 107206165, 107648559, 107207854, 107199515], "D": [107198594, 107202657, 108814890, 107201144, 107221310, 107222056, 107207281, 107209220, 107207652, 107242764, 107209063, 107227592, 107218419, 107224633, 107210347, 107214905, 107204658, 107199967, 107648549, 107199904, 107235149], "B": [107193807, 107194488, 107194267, 107201652, 107196319, 107195681, 107197432, 107195701, 107196325, 107193269, 107196934, 107197687, 107195885, 107193973, 107195238, 107214292, 107194216, 107202326, 107195370], "A": [107192260, 107192259, 107192294, 107199267, 107192201, 107192549, 107194901, 107192510, 107192573, 107192159, 107193301, 107195540, 107193638, 107192240, 107193340, 107196993, 107192336, 107193653, 107192814]}, "name": "E. Move and Swap", "statement": "You are given n - 1 integers a_2,\r\ndots, a_n and a tree with n vertices rooted at vertex 1. The leaves are\r\nall at the same distance d from the root. Recall that a tree is a\r\nconnected undirected graph without cycles. The distance between two\r\nvertices is the number of edges on the simple path between them. All\r\nnon-root vertices with degree 1 are leaves. If vertices s and f are\r\nconnected by an edge and the distance of f from the root is greater than\r\nthe distance of s from the root, then f is called a child of\r\ns.Initially, there are a red coin and a blue coin on the vertex 1. Let r\r\nbe the vertex where the red coin is and let b be the vertex where the\r\nblue coin is. You should make d moves. A move consists of three steps:\r\nMove the red coin to any child of r. Move the blue coin to any vertex b\u2019\r\nsuch that dist(1, b\u2019) = dist(1, b) + 1. Here dist(x, y) indicates the\r\nlength of the simple path between x and y. Note that b and b\u2019 are not\r\nnecessarily connected by an edge. You can optionally swap the two coins\r\n(or skip this step). Note that r and b can be equal at any time, and\r\nthere is no number written on the root.After each move, you gain |a_r -\r\na_b| points. What\u2019s the maximum number of points you can gain after d\r\nmoves?\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint T,n,a[200005],d[200005],mxd,l[200005],r[200005];\nll f[200005];\nvector<int> v[200005],D[200005];\nvoid dfs(int x,int y){\n\tD[d[x]=d[y]+1].pb(x);\n\tif(d[x]>mxd)mxd=d[x];\n\tl[d[x]]=min(l[d[x]],a[x]);\n\tr[d[x]]=max(r[d[x]],a[x]);\n\tfor(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;++i)v[i].clear(),D[i].clear(),l[i]=orz,r[i]=-orz;\n\t\tmxd=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].pb(i),v[i].pb(x);\n\t\t}\n\t\tfor(int i=2;i<=n;++i)scanf(\"%d\",a+i);\n\t\tdfs(1,0);\n\t\tfor(int i=0;i<D[mxd].size();++i){\n\t\t\tint x=D[mxd][i];\n\t\t\tf[x]=max(r[mxd]-a[x],a[x]-l[mxd]);\n\t\t}\n\t\tfor(int k=mxd-1;k;--k){\n\t\t\tll L=-orz*1ll*orz,R=-orz*1ll*orz;\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=-orz*1ll*orz;\n\t\t\t\tfor(int j=0;j<v[x].size();++j){\n\t\t\t\t\tint y=v[x][j];\n\t\t\t\t\tif(d[y]<d[x]) continue;\n\t\t\t\t\tf[x]=max(f[x],f[y]);\n\t\t\t\t}\n\t\t\t\tL=max(L,f[x]-a[x]);\n\t\t\t\tR=max(R,f[x]+a[x]);\n\t\t\t\tf[x]+=max(r[k]-a[x],a[x]-l[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=max(f[x],max(L+a[x],R-a[x]));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%I64d\\n\",f[1]);\n\t}\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "trees"], "dificulty": "2500", "interactive": false}