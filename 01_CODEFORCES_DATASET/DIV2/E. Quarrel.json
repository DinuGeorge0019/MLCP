{"link": "https://codeforces.com//contest/29/problem/E", "problemId": "138", "problem_idx": "E", "shortId": "29E", "contest_number": "29", "problem_submissions": {"E": [125241, 126330, 126155, 125733, 125865, 126658, 126234, 126231, 126226, 126224, 126223, 126222, 126220, 126219], "D": [125034, 124977, 125137, 124955, 126167, 124975, 125121, 125117, 125144, 125139, 125163, 125118, 125874, 125298, 126655, 125218, 125109, 125229, 124650, 125349, 125423], "C": [124653, 124641, 124557, 124552, 126791, 126165, 124733, 124669, 124678, 124726, 124730, 124571, 124765, 125873, 124728, 124502, 124723, 124476, 125051, 124748, 124750, 124948], "B": [124462, 124483, 124414, 124342, 126163, 124350, 124353, 124357, 124449, 124332, 124258, 124938, 125871, 124444, 124711, 124767, 124895, 125182, 124519, 124630], "A": [124199, 124174, 124196, 124170, 126162, 124168, 124167, 124166, 124172, 124158, 124163, 124217, 125867, 124218, 124863, 124230, 124176, 125258, 124181, 124231]}, "name": "E. Quarrel", "statement": "Friends Alex and Bob live in Bertown. In this town there are crossroads,\r\nsome of them are connected by bidirectional roads of equal length. Bob\r\nlives in a house at the crossroads number , Alex in a house at the\r\ncrossroads number .One day Alex and Bob had a big quarrel, and they\r\nrefused to see each other. It occurred that today Bob needs to get from\r\nhis house to the crossroads and Alex needs to get from his house to the\r\ncrossroads . And they don\u2019t want to meet at any of the crossroads, but\r\nthey can meet in the middle of the street, when passing it in opposite\r\ndirections. Alex and Bob asked you, as their mutual friend, to help them\r\nwith this difficult task.Find for Alex and Bob such routes with equal\r\nnumber of streets that the guys can follow these routes and never appear\r\nat the same crossroads at the same time. They are allowed to meet in the\r\nmiddle of the street when moving toward each other (see Sample 1). Among\r\nall possible routes, select such that the number of streets in it is the\r\nleast possible. Until both guys reach their destinations, none of them\r\ncan stay without moving. The guys are moving simultaneously with equal\r\nspeeds, i.e. it is possible that when one of them reaches some of the\r\ncrossroads, the other one leaves it. For example, Alex can move from\r\ncrossroad to crossroad , while Bob moves from crossroad to crossroad .If\r\nthe required routes don\u2019t exist, your program should output .\r\n", "solutions": ["/*\nID: espr1t\nLANG: C++\nTASK: Demo\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 512\n\nusing namespace std;\nFILE *in; FILE *out;\n\nstruct State\n{\n\tint idx1, idx2;\n\tint who, moves;\n};\n\nint vis[MAX][MAX][2];\nint lst[MAX][MAX][2];\nqueue <State> q;\n\nint n, m;\nvector <int> v[MAX];\n\nvoid bfs()\n{\n\tState cur, next;\n\tmemset(lst, -1, sizeof(lst));\n\tmemset(vis, +0, sizeof(vis));\n\twhile (!q.empty()) q.pop();\n\t\n\tnext.moves = 0; next.who = 0;\n\tnext.idx1 = 1; next.idx2 = n;\n\tq.push(next); vis[next.idx1][next.idx2][next.who] = 1;\n\t\n\twhile (!q.empty())\n\t{\n\t\tcur = q.front(); q.pop();\n\t\tif (cur.idx1 == n && cur.idx2 == 1 && cur.who == 0)\n\t\t\tbreak;\n\t\t\n\t\tif (cur.who == 0)\n\t\t{\n\t\t\tnext.idx2 = cur.idx2;\n\t\t\tnext.moves = cur.moves + 1; next.who = 1;\n\t\t\tfor (int i = 0; i < (int)v[cur.idx1].size(); i++)\n\t\t\t{\n\t\t\t\tnext.idx1 = v[cur.idx1][i];\n\t\t\t\tif (!vis[next.idx1][next.idx2][next.who])\n\t\t\t\t{\n\t\t\t\t\tvis[next.idx1][next.idx2][next.who] = 1;\n\t\t\t\t\tlst[next.idx1][next.idx2][next.who] = cur.idx1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnext.idx1 = cur.idx1;\n\t\t\tnext.moves = cur.moves; next.who = 0;\n\t\t\tfor (int i = 0; i < (int)v[cur.idx2].size(); i++)\n\t\t\t{\n\t\t\t\tnext.idx2 = v[cur.idx2][i];\n\t\t\t\tif (next.idx1 == next.idx2) continue;\n\t\t\t\tif (!vis[next.idx1][next.idx2][next.who])\n\t\t\t\t{\n\t\t\t\t\tvis[next.idx1][next.idx2][next.who] = 1;\n\t\t\t\t\tlst[next.idx1][next.idx2][next.who] = cur.idx2;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.idx1 != n || cur.idx2 != 1 || cur.who != 0)\n\t\tfprintf(out, \"-1\\n\");\n\telse\n\t{\n\t\tint pathLen = cur.moves;\n\t\tfprintf(out, \"%d\\n\", pathLen);\n\n\t\tvector <int> p1, p2;\n\t\tfor (int i = 0; i < pathLen * 2 + 2; i++)\n\t\t{\n\t\t\tif (cur.who == 0)\n\t\t\t{\n\t\t\t\tp2.push_back(cur.idx2);\n\t\t\t\tcur.idx2 = lst[cur.idx1][cur.idx2][cur.who];\n\t\t\t\tcur.who = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp1.push_back(cur.idx1);\n\t\t\t\tcur.idx1 = lst[cur.idx1][cur.idx2][cur.who];\n\t\t\t\tcur.who = 0;\n\t\t\t}\n\t\t}\n\t\treverse(p1.begin(), p1.end());\n\t\treverse(p2.begin(), p2.end());\n\t\tfor (int i = 0; i < (int)p1.size(); i++)\n\t\t\tfprintf(out, \"%d%c\", p1[i], i + 1 == (int)p1.size() ? '\\n' : ' ');\n\t\tfor (int i = 0; i < (int)p2.size(); i++)\n\t\t\tfprintf(out, \"%d%c\", p2[i], i + 1 == (int)p2.size() ? '\\n' : ' ');\n\t}\n}\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(\"E.in\", \"rt\"); out = fopen(\"E.out\", \"wt\");\n\t\n\tfscanf(in, \"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint n1, n2;\n\t\tfscanf(in, \"%d %d\", &n1, &n2);\n\t\tv[n1].push_back(n2);\n\t\tv[n2].push_back(n1);\n\t}\n\tbfs();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "shortest paths"], "dificulty": "2400", "interactive": false}