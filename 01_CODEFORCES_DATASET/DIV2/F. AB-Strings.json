{
    "link": "https://codeforces.com//contest/1013/problem/F",
    "problemId": "203190",
    "problem_idx": "F",
    "shortId": "1013F",
    "contest_number": "1013",
    "problem_submissions": {
        "E": [
            40956112,
            40954604,
            40952959,
            40954177,
            40956704,
            40954852,
            40958592,
            40955861,
            40956957,
            40959161,
            40962228,
            40958309,
            40954877,
            40961226,
            40962426,
            40963172,
            40959599,
            40960095,
            40962704,
            40960316
        ],
        "D": [
            40947895,
            40949235,
            40948190,
            40942963,
            40949230,
            40956987,
            40949637,
            40959376,
            40954303,
            40954900,
            40949703,
            40954385,
            40960744,
            40953417,
            40949714,
            40950014,
            40955109,
            40955161,
            40948236,
            40957040
        ],
        "C": [
            40945093,
            40946094,
            40946460,
            40948959,
            40947981,
            40948222,
            40950831,
            40945123,
            40948645,
            40944950,
            40947268,
            40951753,
            40947430,
            40945326,
            40946788,
            40945079,
            40948090,
            40945103,
            40952740,
            40948559
        ],
        "B": [
            40941603,
            40943452,
            40942391,
            40945819,
            40943517,
            40942695,
            40945308,
            40942798,
            40941517,
            40942505,
            40944306,
            40945361,
            40944304,
            40947125,
            40945606,
            40951205,
            40942971,
            40942106,
            40951005,
            40945032
        ],
        "A": [
            40939736,
            40940294,
            40939785,
            40944381,
            40940232,
            40940059,
            40941218,
            40939821,
            40939967,
            40940115,
            40940253,
            40940672,
            40939837,
            40940000,
            40940214,
            40942500,
            40940832,
            40939878,
            40942490,
            40940286
        ],
        "F": [
            82478981,
            40991650
        ]
    },
    "name": "F. AB-Strings",
    "statement": "There are two strings and , consisting only of letters and . You can\r\nmake the following operation several times: choose a prefix of , a\r\nprefix of and swap them. Prefixes , also a prefix can coincide with a\r\nwhole string. Your task is to find a sequence of operations after which\r\none of the strings consists only of letters and the other consists only\r\nof letters. The number of operations should be .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,ns,nt;\nchar s[400005],t[400005],ts[400005],tt[400005];\npii ps[400005],pt[400005];\nvector<pii> ans;\n\nvoid perform(int x,int y){\n\tfor(int i=y+1;i<=n-x+y;i++) ts[i]=s[i+x-y];\n\tfor(int i=x+1;i<=m-y+x;i++) tt[i]=t[i+y-x];\n\tfor(int i=1;i<=x;i++) tt[i]=s[i];\n\tfor(int i=1;i<=y;i++) ts[i]=t[i];\n\tswap(s,ts),swap(t,tt);\n\tint tn=n-x+y,tm=m+x-y;\n\tn=tn,m=tm;\n//\tcout<<\"perform \"<<x<<' '<<y<<endl;\n//\tfor(int i=1;i<=n;i++) cout<<s[i];\n//\tcout<<endl;\n//\tfor(int i=1;i<=m;i++) cout<<t[i];\n//\tcout<<endl;\n}\n\nvoid init(){\n\tns=nt=0;\n\tfor(int i=2;i<=n;i++) if(s[i]!=s[i-1]) ps[++ns]=mp(i-1,s[i-1]-'a');\n\tps[++ns]=mp(n,s[n]-'a');\n\tfor(int i=2;i<=m;i++) if(t[i]!=t[i-1]) pt[++nt]=mp(i-1,t[i-1]-'a');\n\tpt[++nt]=mp(m,t[m]-'a');\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%s\",t+1);\n\tn=strlen(s+1),m=strlen(t+1);\n\tint as=s[1]-'a',at=t[1]-'a';\n\tinit();\n\tif(ns==1&&as==at&&nt%2==0&&(nt/2&1)){\n\t\tint l=nt/2;\n\t\tans.pb(mp(0,pt[l].fi));\n\t\tperform(0,pt[l].fi);\n\t\tinit();\n\t}\n\telse if(nt==1&&as==at&&ns%2==0&&(ns/2&1)){\n\t\tint l=ns/2;\n\t\tans.pb(mp(ps[l].fi,0));\n\t\tperform(ps[l].fi,0);\n\t\tinit();\n\t}\n\tif(abs(ns-nt)>2){\n\t\tif(ns<nt){\n\t\t\tint tmp=(nt-ns+1)/2;\n\t\t\tif((tmp^(as==at))&1) tmp--;\n\t\t\tans.pb(mp(ps[1].fi,pt[tmp+1].fi));\n\t\t\tperform(ps[1].fi,pt[tmp+1].fi);\n\t\t\tinit();\n\t\t}\n\t\telse{\n\t\t\tint tmp=(ns-nt+1)/2;\n\t\t\tif((tmp^(as==at))&1) tmp--;\n\t\t\tans.pb(mp(ps[tmp+1].fi,pt[1].fi));\n\t\t\tperform(ps[tmp+1].fi,pt[1].fi);\n\t\t\tinit();\n\t\t}\n\t}\n//\tcout<<\"ps \";\n//\tfor(int i=1;i<=ns;i++) cout<<ps[i].fi<<' ';\n//\tcout<<endl;\n//\tcout<<\"pt \";\n//\tfor(int i=1;i<=nt;i++) cout<<pt[i].fi<<' ';\n//\tcout<<endl;\n\tif(ns>=nt&&s[1]==t[1]){\n\t\tans.pb(mp(ps[1].fi,0));\n\t\tperform(ps[1].fi,0);\n\t\tinit();\n\t}\n\telse if(ns<nt&&s[1]==t[1]){\n\t\tans.pb(mp(0,pt[1].fi));\n\t\tperform(0,pt[1].fi);\n\t\tinit();\n\t}\n\tint vals=0,valt=0;\n\tfor(int i=1;i<min(ns,nt)+(abs(ns-nt)==2);i++){\n\t\tans.pb(mp(ps[i].fi+vals,pt[i].fi+valt));\n//\t\tperform(ps[i].fi+vals,pt[i].fi+valt);\n\t\tint tmp=pt[i].fi+valt-ps[i].fi-vals;\n\t\tvals+=tmp,valt-=tmp;\n\t}\n\tif(ns<nt) ans.pb(mp(ps[ns].fi+vals,pt[nt-1].fi+valt));\n\telse if(ns>nt) ans.pb(mp(ps[ns-1].fi+vals,pt[nt].fi+valt));\n\tprintf(\"%d\\n\",ans.size());\n\tfor(auto x:ans) printf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. AB-Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/60920",
    "editorial": "The solution is basically like following:\n\nNote that we can compress equal adjacent letters.\n\nNow we can do a dynamic programming with params (first letter of s, length of s, first letter of t, length of t).\n\nHowever, the amount of transactions and even states is too large. But we can write a slow, but surely correct solution, and examine the transactions, which are made in dp.\n\nBasically, the most typical transaction is to just make a swap of first group in s with first group in t. However there special cases, like when the first letters are the same or when the lengths are very small.\n\nRunning a slow dynamic programming helps to get all the cases for the solution.\n\nFormally, the correctness of this algorithm can be proven by induction and the large cases analyses, which we skip for clarity.\n\nAnother approach is to consider different first operations, and then go a greedy after it algorithm. See the second solution for the details. We don't prove it.",
    "hint": []
}