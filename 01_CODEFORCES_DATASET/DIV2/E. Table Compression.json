{"link": "https://codeforces.com//contest/651/problem/E", "problemId": "50871", "problem_idx": "E", "shortId": "651E", "contest_number": "651", "problem_submissions": {"E": [16577901, 16576105, 16577885, 16579030, 16577600, 16579254, 16583684, 16612963, 16634108, 16579601, 16597899, 16582932, 16628107, 16578759], "D": [16573047, 16572719, 16574678, 16571901, 16569773, 16573081, 16571528, 16576891, 16571074, 16608055, 16590874, 16572871, 16572832, 16576303, 16574260, 16573986, 16574407, 16572633, 16573717, 16573769, 16572434], "C": [16565876, 16566691, 16563105, 16566656, 16570973, 16568950, 16566771, 16566951, 16566152, 16563979, 16567340, 16568555, 16569181, 16568020, 16565103, 16569049, 16566497, 16567339, 16568697, 16567246], "B": [16564324, 16569482, 16564950, 16565243, 16571584, 16566683, 16565016, 16565556, 16564840, 16565123, 16565306, 16566113, 16563647, 16564785, 16567065, 16568003, 16562805, 16566201, 16565282], "A": [16563044, 16565248, 16566177, 16563187, 16572713, 16564825, 16563775, 16564326, 16563005, 16562965, 16563558, 16563677, 16562755, 16562903, 16565600, 16564448, 16566878, 16565167, 16563473]}, "name": "E. Table Compression", "statement": "Little Petya is now fond of data compression algorithms. He has already\r\nstudied , , algorithms and many others. Inspired by the new knowledge,\r\nPetya is now developing the new compression algorithm which he wants to\r\nname .Petya decided to compress tables. He is given a table consisting\r\nof rows and columns that is filled with positive integers. He wants to\r\nbuild the table consisting of positive integers such that the relative\r\norder of the elements in each row and each column remains the same. That\r\nis, if in some row of the initial table , then in the resulting table ,\r\nand if then . Similarly, if in some column of the initial table then in\r\ncompressed table and if then . Because large values require more space\r\nto store them, the maximum value in should be as small as possible.Petya\r\nis good in theory, however, he needs your help to implement the\r\nalgorithm.\r\n", "solutions": ["# include <iostream>\n# include <algorithm>\n# include <cstdio>\n# include <cstdlib>\n# include <ctime>\n# include <cmath>\n# include <set>\n# include <vector>\n# include <map>\n# include <queue>\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n\n#define N 1111111\n\nusing namespace std;\n\nint p[N];\nint sz[N];\nint n, m;\n\nvector<pair<int, int> > a;\nint * b[N];\n\n\nint get(int i) {\n\treturn i == p[i] ? i : p[i] = get(p[i]);\n}\n\nvoid uni(int u, int v) {\n\tu = get(u); v = get(v);\n\tif(sz[u] < sz[v]) {\n\t\tswap(u,v);\n\t}\n\tp[v] = u;\n\tsz[u] += sz[v];\n}\n\nint nc[N];\nint nr[N];\n\nint e[N];\n\nint main () {\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; ++i) {\n\t\tb[i] = new int[m];\n\t}\n\tfor(int i = 0; i < n * m; ++i) {\n\t\tp[i] = i;\n\t\tsz[i] = 1;\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tcin >> b[i][j];\n\t\t\t//cout << b[i][j] << ' ';\n\t\t\ta.pb(mp(b[i][j], i * m + j));\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tmap<int, int> M;\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tif(M.count(b[i][j])) {\n\t\t\t\tuni(i * m + j, M[b[i][j]]);\n\t\t\t}\n\t\t\tM[b[i][j]] = i * m + j;\n\t\t}\n\t}\n\n\tfor(int j = 0; j < m; ++j) {\n\t\tmap<int, int> M;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(M.count(b[i][j])) {\n\t\t\t\tuni(i * m + j, M[b[i][j]]);\n\t\t\t}\n\t\t\tM[b[i][j]] = i * m + j;\n\t\t}\n\t}\n\n\tsort(a.begin(), a.end());\n\tvector<int> buf;\n\tfor(int i = 0; i < a.size(); ++i) {\n\t\t//cout << a[i].F << ' ' ;\n\t\tint ps = a[i].S;\n\t\tint should = nr[ps / m];\n\t\tshould = max(should, nc[ps % m]);\n\n\t\tshould++;\n\t\t\n\t\t//cout << a[i].F << ' ' << should << endl;\n\n\t\te[get(ps)] = max(e[get(ps)], should);\n\t\tbuf.pb(ps);\n\t\tif(i == a.size() - 1 || a[i].F != a[i + 1].F) {\n\t\t\tfor(int j = 0; j < buf.size(); ++j) {\n\t\t\t\tint x = buf[j];\n\t\t\t\tnr[x / m] = e[get(x)];\n\t\t\t\tnc[x % m] = e[get(x)];\n\t\t\t}\n\t\t\tbuf.clear();\n\t\t}\n\t}\n\t//cout << endl;\n\t\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tcout << e[get(i * m + j)] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n\n\n\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dsu", "graphs", "greedy"], "dificulty": "2200", "interactive": false}