{
    "link": "https://codeforces.com//contest/228/problem/D",
    "problemId": "1858",
    "problem_idx": "D",
    "shortId": "228D",
    "contest_number": "228",
    "problem_submissions": {
        "D": [
            2261902,
            2260756,
            2262084,
            2263037,
            2262295,
            2262513,
            2267122
        ],
        "E": [
            2260963,
            2258057,
            2257897,
            2258974,
            2259887,
            2261215,
            2260752,
            2260117,
            2260870,
            2262062,
            2262069,
            2259543,
            2261908,
            2259655,
            2259999,
            2259991,
            2260321,
            2260196,
            2260295
        ],
        "C": [
            2260163,
            2263333,
            2260878,
            2261707,
            2259668,
            2261949,
            2262461,
            2260423,
            2262627,
            2261069,
            2261515,
            2272185
        ],
        "B": [
            2257986,
            2258545,
            2258475,
            2257641,
            2258627,
            2257501,
            2258104,
            2259075,
            2257831,
            2258346,
            2258655,
            2258262,
            2258816,
            2257667,
            2258656,
            2258407,
            2259171,
            2258869
        ],
        "A": [
            2256975,
            2258646,
            2256552,
            2256842,
            2256376,
            2256560,
            2257820,
            2256816,
            2256677,
            2257146,
            2256648,
            2257004,
            2256374,
            2256749,
            2256802,
            2257128,
            2257247,
            2257318
        ]
    },
    "name": "D. Zigzag",
    "statement": "The court wizard Zigzag wants to become a famous mathematician. For\r\nthat, he needs his own theorem, like the Cauchy theorem, or his sum,\r\nlike the Minkowski sum. But most of all he wants to have his sequence,\r\nlike the Fibonacci sequence, and his function, like the Euler’s totient\r\nfunction.The Zigag’s sequence with the zigzag factor z is an infinite\r\nsequence , that is determined as follows: , when ; , when ; , when .\r\nOperation means taking the remainder from dividing number by number .\r\nFor example, the beginning of sequence (zigzag factor 3) looks as\r\nfollows: 1, 2, 3, 2, 1, 2, 3, 2, 1.Let’s assume that we are given an\r\narray , consisting of integers. Let’s define element number of the array\r\nas . The Zigzag function is function , where satisfy the inequalities ,\r\n.To become better acquainted with the Zigzag sequence and the Zigzag\r\nfunction, the wizard offers you to implement the following operations on\r\nthe given array . The assignment operation. The operation parameters are\r\n. The operation denotes assigning value to the -th array element. After\r\nthe operation is applied, the value of the array element equals . The\r\nZigzag operation. The operation parameters are . The operation denotes\r\ncalculating the Zigzag function . Explore the magical powers of zigzags,\r\nimplement the described operations.\r\n",
    "solutions": [
        "// AntiFate\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define fab(i,a,b) for(int i=(a);i<=(b);++i)\n#define fba(i,b,a) for(int i=(b);i>=(a);--i)\n#define clr(a) memset(a,0,sizeof(a))\n#define fec(i,a) for(__typeof((a).end())i=(a).begin();i!=(a).end();++i)\n#define fpc(i,j,v) for(int i=a[v],j;j=to[i],i;i=nx[i])\n\n#define N 111111\n\nint n, a[N];\n\nll s[7][13][N];\n\n\nvoid add(int x, ll y)\n{\n    fab(i,2,6)\n        rep(j,2*(i-1))\n        {\n            int zd = (x+2*(i-1)-j) % (2*(i-1));\n\n            if (zd == 0)\n                zd = 2; else\n            if (zd > i)\n                zd = 2*i-zd;\n            \n            for (int t=x;t<N;t+=t-(t&(t-1)))\n                s[i][j][t] += y*zd;\n        }\n}\n\nll ask(int x, int z, int d)\n{\n    ll ret = 0;\n    for(;x;x&=x-1)\n        ret += s[z][d][x];\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    fab(i,1,n)\n    {\n        scanf(\"%d\", a+i);\n        add(i,a[i]);\n    }\n    int q;\n    scanf(\"%d\", &q);\n\n    rep(qq,q)\n    {\n        int t,x,y,z;\n        scanf(\"%d\", &t);\n        if (t == 1)\n        {\n            scanf(\"%d%d\", &x, &y);\n            add(x,-a[x]);\n            a[x]=y;\n            add(x,a[x]);\n        }\n        else\n        {\n            scanf(\"%d%d%d\", &x, &y, &z);\n            int m = 2*(z-1);\n            int j;\n            rep(jj,m)\n            {\n                int zd = (x+m-jj) % m;\n                if (zd == 0)\n                    zd = 2; else\n                if (zd > z)\n                    zd = 2*z-zd;\n                if (zd == 1)\n                {\n                    j=jj;\n                    break;\n                }\n            }\n            printf(\"%I64d\\n\", ask(y, z, j) - ask(x-1, z, j));\n        }\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Zigzag.json",
    "editorial_link": "https://codeforces.com//blog/entry/5404",
    "editorial": "In this problem we will use that sequence is cyclic because of its\r\nstructure. Also, it is important that . For every we will write the\r\nsequence and note that its period is . So, for every and modulo we will\r\nbuild separate segment tree or Fenwick tree. You should be careful with\r\nmemory, it needs of memory. So, if the query is to update some value, we\r\nshould update values of trees with correct modules. If the query is to\r\nfind sum, we should consider every modules, count the sum and multiply\r\nby correct coefficient from sequence . The complexity is .\r\n",
    "hint": []
}