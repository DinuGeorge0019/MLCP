{
    "link": "https://codeforces.com//contest/1567/problem/E",
    "problemId": "1099177",
    "problem_idx": "E",
    "shortId": "1567E",
    "contest_number": "1567",
    "problem_submissions": {
        "C": [
            127974564,
            127939959,
            127954581,
            127964000,
            127952919,
            127944623,
            127939332,
            127964327,
            127943124,
            127968891,
            127947814,
            127940553,
            127945813,
            127964268,
            127942609,
            127947600,
            127945820,
            127938032,
            127948426,
            127964716
        ],
        "A": [
            127964852,
            127922278,
            127932015,
            127955526,
            127943035,
            127922628,
            127923688,
            127926840,
            127922694,
            127925712,
            127924423,
            127923731,
            127922858,
            127922205,
            127926705,
            127927113,
            127928956,
            127922373,
            127923105,
            127922692
        ],
        "B": [
            127964231,
            127928229,
            127928104,
            127960707,
            127944459,
            127929761,
            127931746,
            127932290,
            127933652,
            127938027,
            127928958,
            127942519,
            127932981,
            127927891,
            127934499,
            127937493,
            127935529,
            127926955,
            127935971,
            127930754
        ],
        "D": [
            127962995,
            127955193,
            127945755,
            127969042,
            127959015,
            127952114,
            127951882,
            127957740,
            127965163,
            127957338,
            127967067,
            128042803,
            127957487,
            127961796,
            127954276,
            127956523,
            127952133,
            127952975,
            127957557,
            127953745
        ],
        "E": [
            127956967,
            127950306,
            127967160,
            127953453,
            128966040,
            127974173,
            128003977,
            127960229,
            127963530,
            127951320,
            127958948,
            128021683,
            127976249,
            127963411,
            127950253,
            128042735,
            127964337,
            127947637,
            127967826,
            127965391,
            128541587,
            127968997,
            127966309,
            127964418,
            127961161
        ],
        "F": [
            127951988,
            127980467,
            127976901,
            127981608,
            127980938,
            128003888,
            128003811,
            128049440,
            127960253,
            128042163
        ]
    },
    "name": "E. Non-Decreasing Dilemma",
    "statement": "Alice has recently received an array a_1, a_2,\r\ndots, a_n for her birthday! She is very proud of her array, and when she\r\nshowed her friend Bob the array, he was very happy with her present\r\ntoo!However, soon Bob became curious, and as any sane friend would do,\r\nasked Alice to perform q operations of two types on her array: 1 x y:\r\nupdate the element a_x to y (set a_x = y). 2 l r: calculate how many\r\nnon-decreasing subarrays exist within the subarray [a_l, a_{l+1},\r\ndots, a_r]. More formally, count the number of pairs of integers (p,q)\r\nsuch that l\r\nle p\r\nle q\r\nle r and a_p\r\nle a_{p+1}\r\nle\r\ndots\r\nle a_{q-1}\r\nle a_q. Help Alice answer Bob\u2019s queries!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 222222;\nint n, q, a[maxN];\nstruct info {\n\tint l, r, fl, fr, sz;\n\tlong long tot;\n} d[maxN * 4];\n\ninfo operator + (info a, info b) {\n\tinfo c;\n\tc.l = a.l;\n\tc.r = b.r;\n\tc.sz = a.sz + b.sz;\n\tc.fl = (a.fl == a.sz && a.r <= b.l) ? (a.fl + b.fl) : a.fl;\n\tc.fr = (b.fr == b.sz && a.r <= b.l) ? (b.fr + a.fr) : b.fr;\n\tc.tot = a.tot + b.tot + ((a.r <= b.l) ? (1ll * a.fr * b.fl) : 0);\n\treturn c;\n}\n\nvoid bd(int k, int l, int r) {\n\tif (l == r) {\n\t\td[k] = (info) {a[l], a[l], 1, 1, 1, 1ll};\n\t} else {\n\t\tint mid = (l + r) / 2;\n\t\tbd(k * 2, l, mid);\n\t\tbd(k * 2 + 1, mid + 1, r);\n\t\td[k] = d[k * 2] + d[k * 2 + 1];\n\t}\n}\n\nvoid mdf(int k, int l, int r, int x) {\n\tif (l == r) {\n\t\td[k] = (info) {a[l], a[l], 1, 1, 1, 1ll};\n\t} else {\n\t\tint mid = (l + r) / 2;\n\t\tif (x <= mid) mdf(k * 2, l, mid, x);\n\t\telse mdf(k * 2 + 1, mid + 1, r, x);\n\t\td[k] = d[k * 2] + d[k * 2 + 1];\n\t}\n}\n\ninfo qry(int k, int l, int r, int x, int y) {\n\tif (l == x && r == y) {\n\t\treturn d[k];\n\t} else {\n\t\tint mid = (l + r) / 2;\n\t\tif (y <= mid) return qry(k * 2, l, mid, x, y);\n\t\telse if (x > mid) return qry(k * 2 + 1, mid + 1, r, x, y);\n\t\telse return qry(k * 2, l, mid, x, mid) + qry(k * 2 + 1, mid + 1, r, mid + 1, y);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tbd(1, 1, n);\n\tfor (int i = 0; i < q; i++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d%d%d\", &t, &x, &y);\n\t\tif (t == 1) {\n\t\t\ta[x] = y;\n\t\t\tmdf(1, 1, n, x);\n\t\t} else {\n\t\t\tauto ans = qry(1, 1, n, x, y);\n\t\t\tprintf(\"%lld\\n\", ans.tot);\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Non-Decreasing Dilemma.json",
    "editorial_link": "https://codeforces.com//blog/entry/94581",
    "editorial": "Note that if there exists a non-decreasing array of length , then it\r\ncontains non-decreasing subarrays. Therefore, we can break our solution\r\ndown to counting the lengths of the non-decreasing \"chains\" within the\r\nqueried subarray.We can solve this problem using a data structure called\r\na segment tree. On each node of this segment tree, we shall maintain\r\nfour pieces of information: the length of the longest non-decreasing\r\nprefix. the length of the longest non-decreasing suffix. a boolean flag\r\ndenoting if the entire segment is non-decreasing. the total number of\r\nnondecreasing subarrays not part of the longest prefix or suffix.I won\u00e2\u0080\u0099t\r\nexplain the merging process here (you can examine the implementation\r\nbelow), but it is not too complex.Using this, we can traverse the\r\nsegment tree, from the left of our queried range to the right, while\r\nmaintaining the number of non-decreasing subarrays in the prefix of the\r\nrange and the length of the outgoing non-decreasing suffix to get our\r\nanswer.Time complexity: .\r\n"
}