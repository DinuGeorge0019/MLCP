{
    "link": "https://codeforces.com//contest/1087/problem/C",
    "problemId": "273647",
    "problem_idx": "C",
    "shortId": "1087C",
    "contest_number": "1087",
    "problem_submissions": {
        "E": [
            58252522,
            47419404,
            47425055,
            47427281,
            47427199,
            47427772,
            47427175,
            47429424,
            47427691,
            47428203,
            47426678,
            47429553,
            47424066,
            47442342,
            47431388
        ],
        "F": [
            47420077,
            47423866,
            47885139,
            47468746,
            47429059,
            47443089
        ],
        "D": [
            47418729,
            47408054,
            47412096,
            47414267,
            47413772,
            47414393,
            47411787,
            47412026,
            47410837,
            47416228,
            47416942,
            47404060,
            47424226,
            47415168,
            47411121,
            47421101,
            47407066,
            47410268,
            47411462,
            47409719
        ],
        "C": [
            47405054,
            47411233,
            47407822,
            47412155,
            47406359,
            47410875,
            47413841,
            47406249,
            47409638,
            47412893,
            47414989,
            47429784,
            47418255,
            47431334,
            47431242,
            47407433,
            47430615,
            47412255,
            47405671,
            47407818,
            47406818
        ],
        "B": [
            47401231,
            47412385,
            47401723,
            47403755,
            47401975,
            47403962,
            47406414,
            47402530,
            47402488,
            47401578,
            47406978,
            47400393,
            47407454,
            47402895,
            47400789,
            47403406,
            47402600,
            47400687,
            47402493,
            47402234
        ],
        "A": [
            47400159,
            47405287,
            47400196,
            47400342,
            47400796,
            47401502,
            47401673,
            47400758,
            47400490,
            47400180,
            47403017,
            47409819,
            47408382,
            47400648,
            47400053,
            47400839,
            47400496,
            47400902,
            47400447,
            47400696
        ]
    },
    "name": "C. Connect Three",
    "statement": "The Squareland national forest is divided into equal 1\r\ntimes 1 square plots aligned with north-south and east-west directions.\r\nEach plot can be uniquely described by integer Cartesian coordinates (x,\r\ny) of its south-west corner.Three friends, Alice, Bob, and Charlie are\r\ngoing to buy three distinct plots of land A, B, C in the forest.\r\nInitially, all plots in the forest (including the plots A, B, C) are\r\ncovered by trees. The friends want to visit each other, so they want to\r\nclean some of the plots from trees. After cleaning, one should be able\r\nto reach any of the plots A, B, C from any other one of those by moving\r\nthrough adjacent cleared plots. Two plots are adjacent if they share a\r\nside. Of course, the friends don\u2019t want to strain too much. Help them\r\nfind out the smallest number of plots they need to clean from trees.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define ff first\n#define ss second\n#define all(X) begin(X), end(X)\nvector<vector<int>>dp,s;\nvector<pair<int,int>>ans;\nsigned main(){\n\tint ax,ay,bx,by,cx,cy;\n\tcin >> ax >> ay >> bx >> by >> cx >> cy;\n\tif(ax>bx)swap(ax,bx),swap(ay,by);\n\tif(bx>cx)swap(bx,cx),swap(by,cy);\n\tif(ax>bx)swap(ax,bx),swap(ay,by);\n\tfor(int i = min({ay,by,cy}); i <= max({ay,by,cy}); i++)\n\t\tans.pb({bx,i});\n\tfor(int i = ax; i < bx; i++)\n\t\tans.pb({i,ay});\n\tfor(int i = bx+1; i <= cx; i++)\n\t\tans.pb({i,cy});\n\tcout << ans.size() << endl;\n\tfor(auto i:ans)cout << i.ff << \" \" << i.ss << endl;\n} \n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Connect Three.json",
    "editorial_link": "https://codeforces.com//blog/entry/64078",
    "editorial": "The smallest possible number of plots required to connect all three plots is at least ?x+?y+1\n, where ?x=xmax?xmin\n and ?y=ymax?ymin\n (here xmin\n, xmaxn\n, ymin\n, ymax\n are extreme coordinate values among the three given plots). It now suffices to find any suitable collection of plots of this size.\n\nLet xm\n and ym\n be the median values of (xA,xB,xC)\n and (yA,yB,yC)\n. For each of the plots A\n, B\n, C\n connect it with the plot (xm,ym)\n with any shortest path (if one of A\n, B\n, C\n coincides with (xm,ym)\n, just do nothing). One can check that the resulting collection has size exactly ?x+?y+1\n, and it clearly connects A\n, B\n and C\n together.\n\nThe above solution has complexity O(C)\n, where C\n is the largest coordinate value. Given that C\n is quite small, one could go with slower solutions, for instance, instead of (xm,ym)\n try all C2\n plots as the connecting plot."
}