{
    "link": "https://codeforces.com//contest/1602/problem/F",
    "problemId": "1157775",
    "problem_idx": "F",
    "shortId": "1602F",
    "contest_number": "1602",
    "problem_submissions": {
        "E": [
            133032006,
            133003754,
            133004259,
            133007498,
            133009354,
            133008986,
            133015586,
            133014296,
            133019189,
            133016251,
            133023043,
            133017173,
            133017654,
            133031118,
            133031771,
            133023126,
            133023444,
            133026607,
            133071046,
            133071006,
            133023246,
            133026124
        ],
        "F": [
            133014631,
            133053467,
            133059590,
            133053314,
            133051962,
            133051828,
            133051273,
            133051246,
            133050986,
            133051444,
            133058927,
            154906935,
            133202717
        ],
        "D": [
            133005341,
            132997744,
            132998965,
            133002435,
            132995700,
            132999302,
            133001008,
            133003621,
            133003659,
            132999008,
            132999274,
            133007130,
            133055379,
            133006665,
            133001448,
            133002893,
            133007904,
            133005768,
            133005590,
            133006243,
            133009816
        ],
        "C": [
            132998504,
            132991987,
            132994038,
            132995401,
            132990761,
            132993753,
            132991630,
            132994468,
            132994573,
            133000658,
            132992001,
            132996442,
            132999119,
            132991525,
            132995757,
            132998190,
            132996165,
            132996191,
            132994329,
            132993830
        ],
        "B": [
            132991874,
            132990242,
            132989322,
            132992468,
            132988801,
            132988045,
            132989355,
            132992898,
            148604097,
            132990867,
            133003212,
            132988289,
            133227165,
            132993306,
            133064818,
            132995361,
            132995328,
            132993153,
            132995379,
            132997555,
            132991609,
            132992280,
            132992140
        ],
        "A": [
            132986686,
            132984939,
            132985573,
            132990670,
            132984472,
            132986995,
            132984659,
            132987933,
            148604079,
            132986349,
            132985981,
            132984656,
            133227226,
            132987663,
            132991514,
            132988125,
            132988425,
            132989208,
            132984538,
            132986551,
            132985450,
            132984595
        ]
    },
    "name": "F. Difficult Mountain",
    "statement": "A group of n alpinists has just reached the foot of the mountain. The\r\ninitial difficulty of climbing this mountain can be described as an\r\ninteger d.Each alpinist can be described by two integers s and a, where\r\ns is his skill of climbing mountains and a is his neatness.An alpinist\r\nof skill level s is able to climb a mountain of difficulty p only if p\r\nleq s. As an alpinist climbs a mountain, they affect the path and thus\r\nmay change mountain difficulty. Specifically, if an alpinist of neatness\r\na climbs a mountain of difficulty p the difficulty of this mountain\r\nbecomes\r\nmax(p, a). Alpinists will climb the mountain one by one. And before the\r\nstart, they wonder, what is the maximum number of alpinists who will be\r\nable to climb the mountain if they choose the right order. As you are\r\nthe only person in the group who does programming, you are to answer the\r\nquestion.Note that after the order is chosen, each alpinist who can\r\nclimb the mountain, must climb the mountain at that time.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tint ret=0;char c=getchar();\n\twhile(c>'9'||c<'0')c=getchar();\n\twhile(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();\n\treturn ret;\n}\nconst int maxn=5e5+5;\nint n,d;\nstruct point\n{\n\tint a,b,w;\n\tconst bool operator <(const point &x)const{return a+b<x.a+x.b;}\n}p[maxn];\nint num[maxn<<1],cnt;\nvoid discrete()\n{\n\tnum[++cnt]=d;\n\tfor(int i=1;i<=n;i++)num[++cnt]=p[i].a,num[++cnt]=p[i].b;\n\tsort(num+1,num+cnt+1);cnt=unique(num+1,num+cnt+1)-(num+1);\n\tfor(int i=1;i<=n;i++)p[i].a=lower_bound(num+1,num+cnt+1,p[i].a)-num,p[i].b=lower_bound(num+1,num+cnt+1,p[i].b)-num;\n\td=lower_bound(num+1,num+cnt+1,d)-num;\n}\nstruct segmemt\n{\n\t#define L(u) u<<1\n\t#define R(u) u<<1|1\n\tstruct node{ll mx,tag;}t[maxn<<3];\n\tvoid update(int u){t[u].mx=max(t[L(u)].mx,t[R(u)].mx);}\n\tvoid pushdown(int u)\n\t{\n\t\tif(t[u].tag)\n\t\t{\n\t\t\tt[L(u)].tag+=t[u].tag;t[L(u)].mx+=t[u].tag;\n\t\t\tt[R(u)].tag+=t[u].tag;t[R(u)].mx+=t[u].tag;\n\t\t\tt[u].tag=0;\n\t\t}\n\t}\n\tvoid change(int u,int l,int r,int nl,int nr,ll x)\n\t{\n\t\tif(l>=nl&&r<=nr){t[u].mx+=x;t[u].tag+=x;return;}\n\t\tpushdown(u);int mid=(l+r)>>1;\n\t\tif(mid>=nl)change(L(u),l,mid,nl,nr,x);\n\t\tif(mid+1<=nr)change(R(u),mid+1,r,nl,nr,x);\n\t\tupdate(u);\n\t}\n\tll query(int u,int l,int r,int nl,int nr)\n\t{\n\t\tif(nl>nr)return 0;\n\t\tif(l>=nl&&r<=nr)return t[u].mx;\n\t\tpushdown(u);int mid=(l+r)>>1;ll ret=0;\n\t\tif(mid>=nl)ret=max(ret,query(L(u),l,mid,nl,nr));\n\t\tif(mid+1<=nr)ret=max(ret,query(R(u),mid+1,r,nl,nr));\n\t\treturn ret;\n\t}\n}tr;\nint main()\n{\n\tn=read();d=read();\n\tfor(int i=1;i<=n;i++)p[i].b=read(),p[i].a=max(d,read()),p[i].w=1;\n\tdiscrete();\n\tsort(p+1,p+n+1);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(p[i].b<d)continue;\n\t\tif(p[i].a<=p[i].b)tr.change(1,1,cnt,p[i].a,p[i].b,p[i].w);\n\t\tll mx=tr.query(1,1,cnt,max(p[i].a,p[i].b+1),cnt);\n\t\tll bv=tr.query(1,1,cnt,p[i].b,p[i].b);\n\t\tif(mx+p[i].w>bv)tr.change(1,1,cnt,p[i].b,p[i].b,mx+p[i].w-bv);\n\t}\n\tprintf(\"%lld\",tr.t[1].mx);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Difficult Mountain.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "First, discard all i\n such that si<d\n\nInstead of climbers, we will consider pairs (si,ai)\n, and also say that the set of pairs is correct if there is a permutation p1pn\n such that for every i:max(d,ap1,api?1)?spi\n, which means that there is an order in which all climbers can climb.\n\nWe will call a pair of indices i,j\n incompatible if i?j\n and sj<ai\n and si<aj\n. - this means that the i\n-th climber cannot climb after the j\n-th and vice versa. Note that if the set does not have an incompatible pair of indices, then it is correct. The suitable order for pairs (si,ai)\n can be reached by sorting them in increasing order of pairs min(si,ai),max(si,ai)\n. After sorting either i\n-th climber can go after (i?1)\n-th or the pair (i?1),i\n is incompatible.\n\n Let's solve the problem with an additional restriction first, namely: for each i:si<ai\n, In this case, you can use the following greedy solution:\n\nLet D=d\n, find among the pairs (si,ai)\n such that D?si\n, and among such pairs - the pair with the smallest ai\n - it will be the next in our order. Replace D\n by ai\n, increase the answer by 1 and repeat the algorithm. If the pair with D?si\n does not exist, terminate the algorithm. The correctness of such an algorithm is proved by induction.\n\nTo effectively implement this solution, let's sort all the pairs (si,ai)\n in increasing order of ai\n\nLet's go through the indices i\n from 1 to n\n\n If D?si\n, then add 1 to the answer and replace D\n with ai\n.\n\n Let's get back to the main problem:\n\nConsider a pair of indices i,j\n such that si<aj?sj<ai\n\nSuch a pair of indices is incompatible, and if the optimal answer contains i\n, then it can be replaced with j\n and the sequence will not break.\n\n si<sj?\n for any value of D\n that matches i\n it matches j\n.  aj<ai?\n for any D:max(D,aj)?max(D,ai)\n\nTherefore, for any such pair i,j\n, the i\n-th can be excluded from the set of climbers and the answer will not worsen.\n\n To effectively remove all such (si,ai)\n pairs, we use the two-pointer method:\n\nLet's take out all such pairs that ai?si\n into the b\n array. Let the remaining pairs be in the c\n array. Let's sort the array b\n in increasing order of ai\n and the array c\n in increasing order of si\n. Let's create an ordered set M\n, which can store the pairs (si,ai)\n in decreasing order of ai\n. Let's create a pointer j=0\n.\n\nLet's go through the elements of the b\n array with index i.\n\n For this item:\n\n While cj.s<bi.a\n we will add cj\n to the set M\n\n Now while bi.s<M1.a\n we will delete the first element M.\n\nAmong the elements of the b\n array, the M\n set and the remaining elements in the c\n array, there are no more required pairs.\n\nNote that among the remaining pairs (si,ai)\n, any pair of indices i,j\n such that ai?si\n or aj?sj\n is not incompatible.\n\nNow, if we find the maximum correct subset of the pairs (si,ai)\n, such that si<ai\n and combine it with the set of pairs (si,ai)\n, such that ai?si\n, we get the correct set, moreover, for obvious reasons  it has maximum size. Therefore, we will get the answer to the problem.",
    "hint": []
}