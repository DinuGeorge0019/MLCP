{
    "link": "https://codeforces.com//contest/895/problem/B",
    "problemId": "136055",
    "problem_idx": "B",
    "shortId": "895B",
    "contest_number": "895",
    "problem_submissions": {
        "B": [
            32688468,
            32699862,
            32678233,
            32693050,
            32686509,
            32685665,
            32686167,
            32677480,
            32679593,
            32679598,
            32678660,
            32679991,
            32682934,
            32679855,
            32677931,
            32686786,
            32693881,
            32679230,
            32679053
        ],
        "A": [
            32686687,
            32676253,
            32692247,
            32687355,
            32675778,
            32681798,
            32679509,
            32675934,
            32676147,
            32676898,
            32676014,
            32676714,
            32676536,
            32676059,
            32675756,
            32675820,
            32681275,
            32675999,
            32675924,
            32676186
        ],
        "E": [
            32685470,
            32693933,
            32688720,
            32686566,
            32794358,
            32794273,
            32732458,
            32681330,
            34740059,
            32691274,
            32699769,
            32720207,
            32720179,
            32720088,
            32698361,
            32698258,
            32698305
        ],
        "D": [
            32681888,
            32681308,
            32690694,
            32686236,
            32685937,
            32689479,
            32691053,
            32781770,
            32686848,
            32691934,
            32691134,
            32690110,
            32688741,
            32690589,
            32685060,
            32692013
        ],
        "C": [
            32678196,
            32689081,
            32683426,
            32681542,
            32680606,
            32690938,
            32678815,
            32682493,
            32687456,
            32690603,
            32685722,
            32686946,
            32686892,
            32689317,
            32680568,
            32678934,
            32808410,
            32685463,
            32687263,
            32681038
        ]
    },
    "name": "B. XK Segments",
    "statement": "While Vasya finished eating his piece of pizza, the lesson has already\r\nstarted. For being late for the lesson, the teacher suggested Vasya to\r\nsolve one interesting problem. Vasya has an array and integer . He\r\nshould find the number of different ordered pairs of indexes such that\r\nand there are exactly integers such that and is divisible by .In this\r\nproblem it is meant that pair is equal to only if is equal to . For\r\nexample pair is not the same as .\r\n",
    "solutions": [
        "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,k;\n\nll A[maxn];\n\nmap<int,int> has;\n\nint main(){\n\tread(n,x,k);\n\tREP(i,1,n)read(A[i]);\n\tsort(A+1,A+n+1);\n\tll ans=0;\n\tREP(i,1,n){\n\t\tint t=(A[i]-1)/x;\n\t\tt+=k;\n\t\tll l=1ll*t*x,r=1ll*t*x+x-1;\n\t\tl=max(l,(ll)A[i]);\n\t\tans+=upper_bound(A+1,A+n+1,r)-lower_bound(A+1,A+n+1,l);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. XK Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/56028",
    "editorial": "First, we need to understand how to find the number of integers in\r\nsegment which are divisible by . It is . After that we should sort array\r\nin ascending order. For each left boundary of the segment we need to\r\nfind minimal and maximal index of good right boundaries. All right\r\nboundaries should satisfy the following condition . We already know , is\r\nincreasing while increases. So we can do binary search on sorted array\r\nto find minimal/maximal index of good right boundaries and that mean we\r\ncan find the number of good right boundaries. Time complexity . Solution\r\n"
}