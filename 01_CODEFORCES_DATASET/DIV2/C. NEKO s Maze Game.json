{
    "link": "https://codeforces.com//contest/1293/problem/C",
    "problemId": "519784",
    "problem_idx": "C",
    "shortId": "1293C",
    "contest_number": "1293",
    "problem_submissions": {
        "F": [
            69144490
        ],
        "E": [
            69128562,
            69139795,
            69142024,
            69131945,
            69142296,
            69141087,
            69144888,
            69145848,
            69164707
        ],
        "D": [
            69110626,
            69117551,
            69124060,
            69120174,
            69127386,
            69126155,
            69129595,
            69130299,
            69114746,
            69117610,
            69118282,
            69119817,
            69121032,
            69120169,
            69124854,
            69120660,
            69119364,
            69123969,
            69120677
        ],
        "C": [
            69102974,
            69108977,
            69107084,
            69104834,
            69114459,
            69118062,
            69106027,
            69117297,
            69105999,
            69106862,
            69108959,
            69111194,
            69109221,
            69111162,
            69107446,
            69109831,
            69111539,
            69110537,
            69100793
        ],
        "B": [
            69100602,
            69105372,
            69103818,
            69141041,
            69106215,
            69103881,
            69107978,
            69109703,
            69102030,
            69102659,
            69103831,
            69103631,
            69104162,
            69106217,
            69102105,
            69103438,
            69103183,
            69102839,
            69102420
        ],
        "A": [
            69100208,
            69103403,
            69101074,
            69134161,
            69102156,
            69101452,
            69101459,
            69101593,
            69100449,
            69100351,
            69100975,
            69100577,
            69100919,
            69101698,
            69100184,
            69100301,
            69100964,
            69100796,
            69109424
        ]
    },
    "name": "C. NEKO s Maze Game",
    "statement": "NEKO has just got a new maze game on her PC!The game\u2019s main puzzle is a\r\nmaze, in the forms of a 2\r\ntimes n rectangle grid. NEKO\u2019s task is to lead a Nekomimi girl from cell\r\n(1, 1) to the gate at (2, n) and escape the maze. The girl can only move\r\nbetween cells sharing a common side.However, at some moments during the\r\ngame, some cells may change their state: either from normal ground to\r\nlava (which forbids movement into that cell), or vice versa (which makes\r\nthat cell passable again). Initially all cells are of the ground\r\ntype.After hours of streaming, NEKO finally figured out there are only q\r\nsuch moments: the i-th moment toggles the state of cell (r_i, c_i)\r\n(either from ground to lava or vice versa).Knowing this, NEKO wonders,\r\nafter each of the q moments, whether it is still possible to move from\r\ncell (1, 1) to cell (2, n) without going through any lava cells.Although\r\nNEKO is a great streamer and gamer, she still can\u2019t get through quizzes\r\nand problems requiring large amount of Brain Power. Can you help her?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, q;\nint ok[3][100005];\nint conf;\n\nvoid upd(int x, int y) {\n    int sgn = ok[x][y] ? -1 : 1;\n    conf += sgn * (ok[3-x][y-1] + ok[3-x][y] + ok[3-x][y+1]);\n    ok[x][y] ^= 1;\n}\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cin >> n >> q;\n    while (q--) {\n        int x, y;\n        cin >> x >> y;\n        upd(x, y);\n        cout << (conf ? \"No\" : \"Yes\") << '\\n';\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. NEKO s Maze Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/73051",
    "editorial": "The main observation is that, it is possible to travel from (1,1)\n to (2,n)\n if and only if there exist no pair of forbidden cell (1,a)\n and (2,b)\n such that |a?b|?1\n.\n\nTherefore, to answer the query quickly, for every d\n from ?1\n to 1\n, one should keep track of the number of pair (a,b)\n such that:\n\n(1,a)\n and (2,b)\n are both forbidden.\na?b=d\n.\nOne of the methods to do this is: after a cell (x,y)\n has been swapped, check for all cells (3?x,y?1)\n, (3?x,y)\n, (3?x,y+1)\n and update the number of pairs based on the status of those cells and new status of (x,y)\n. Since n?105\n, the status of all cells can be easily kept in a 2D boolean array, and accessed in O(1)\n time complexity.\n\nTotal complexity: O(n+q)\n."
}