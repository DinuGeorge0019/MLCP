{"link": "https://codeforces.com//contest/1114/problem/B", "problemId": "295524", "problem_idx": "B", "shortId": "1114B", "contest_number": "1114", "problem_submissions": {"E": [49723158, 49715728, 49717586, 49715673, 49722801, 49716158, 49718191, 49719573, 49752574, 49752490, 49731134, 49732179, 49723266, 49731088, 49731791, 49709398, 49709699, 49747930, 49752856, 49752305, 49752243, 49751661, 49717020, 49711667, 49716380], "D": [49715413, 49709860, 49711770, 49711237, 49709601, 49710358, 49712973, 49713792, 49713441, 49727466, 49728830, 49707199, 49710354, 49729290, 49706402, 49726434, 49712605, 49711462, 49713489, 49710031], "F": [49712180, 49727873, 49729579, 49729533, 49726481, 49727101, 49727851, 49731205, 49722332, 49708876, 49721497, 49732987, 49730916, 49722816, 49711859, 49722110, 49737560, 49795547], "B": [49703429, 49701684, 49702412, 49706794, 49704297, 49702841, 49708341, 49704456, 49705411, 49718896, 49701034, 49703871, 49704671, 49716920, 49700530, 49704223, 49704334, 49707941, 49702883, 49701403], "C": [49701343, 49703467, 49706082, 49704226, 49698909, 49708135, 49709609, 49709215, 49708563, 49712949, 49704721, 49705449, 49707404, 49724763, 49703776, 49705794, 49710442, 49704405, 49704935, 49704203], "A": [49696863, 49696786, 49698271, 49697340, 49701634, 49697080, 49706366, 49697215, 49702348, 49720550, 49696844, 49696791, 49698691, 49696775, 49697211, 49696953, 49699702, 49696860, 49697429, 49697130]}, "name": "B. Yet Another Array Partitioning Task", "statement": "An array b is called to be a of a if it forms a continuous subsequence\r\nof a, that is, if it is equal to a_l, a_{l + 1},\r\nldots, a_r for some l, r.Suppose m is some known constant. For any\r\narray, having m or more elements, let\u2019s define it\u2019s as the sum of m\r\nlargest elements of that array. For example: For array x = [4, 3, 1, 5,\r\n2] and m = 3, the 3 largest elements of x are 5, 4 and 3, so the beauty\r\nof x is 5 + 4 + 3 = 12. For array x = [10, 10, 10] and m = 2, the beauty\r\nof x is 10 + 10 = 20.You are given an array a_1, a_2,\r\nldots, a_n, the value of the said constant m and an integer k. Your need\r\nto split the array a into exactly k subarrays such that: Each element\r\nfrom a belongs to exactly one subarray. Each subarray has at least m\r\nelements. The sum of all beauties of k subarrays is maximum possible.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 1000500;\nconst int MOD = 1000000007;\n\nvoid bad() {\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<pair<int, int>> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i].first;\n    a[i].second = i;\n  }\n  sort(a.begin(), a.end(), greater<pair<int,int>>());\n  long long res = 0;\n  vector<int> result;\n  for (int i = 0; i < m * k; ++i) {\n    res += a[i].first;\n    result.push_back(a[i].second);\n  }\n  sort(result.begin(), result.end());\n\n  cout << res << endl;\n  for (int i = 0; i < k - 1; ++i) {\n    cout << result[(i + 1) * m - 1] + 1 << ' ';\n  }\n  return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings"], "dificulty": "1500", "interactive": false}