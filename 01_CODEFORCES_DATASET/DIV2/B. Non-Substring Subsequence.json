{
    "link": "https://codeforces.com//contest/1451/problem/B",
    "problemId": "804298",
    "problem_idx": "B",
    "shortId": "1451B",
    "contest_number": "1451",
    "problem_submissions": {
        "E2": [
            99164666,
            99162733,
            99165925,
            99161646,
            99162275,
            99166708,
            99177844,
            99187045,
            99171193,
            99180740,
            99166779,
            99593065,
            99167139,
            99212094,
            99180750,
            99167382,
            99164289,
            99170306,
            99166489,
            99174952,
            99170046
        ],
        "F": [
            99157323,
            99174334,
            99172211,
            99171897,
            99169968,
            99159796,
            99185696,
            99185913,
            99161260,
            99186126,
            101852088,
            99331616,
            99277099,
            99194656
        ],
        "E1": [
            99152747,
            99148819,
            99166585,
            99161270,
            99161762,
            99166831,
            99177296,
            99186671,
            99171561,
            99180543,
            99167295,
            99166954,
            99212099,
            99162460,
            99166940,
            99164739,
            99169616,
            99166777,
            99174556,
            99160048
        ],
        "B": [
            99139927,
            99129712,
            99127148,
            99131588,
            99133196,
            99173277,
            99136243,
            99144900,
            99179324,
            99132526,
            99124656,
            99134309,
            99211443,
            99138683,
            99129420,
            99135350,
            99127140,
            99142430,
            99125493,
            99136003
        ],
        "C": [
            99137455,
            99134588,
            99132257,
            99139076,
            99140138,
            99171814,
            99145789,
            99142052,
            99183664,
            99140696,
            99133474,
            99140223,
            99211399,
            99130542,
            99135361,
            99140699,
            99137433,
            99148880,
            99132285,
            99139620
        ],
        "D": [
            99133620,
            99140832,
            99142901,
            99155332,
            99185292,
            99169795,
            99166634,
            99139104,
            99176250,
            99168173,
            99147779,
            99144152,
            99212069,
            99141953,
            99149299,
            99150791,
            99154805,
            99153259,
            99147140,
            99162814
        ],
        "A": [
            99120654,
            99120423,
            99121791,
            99121810,
            99124507,
            99174166,
            99122054,
            99147895,
            99180245,
            99124534,
            99120454,
            99123326,
            99211324,
            99120847,
            99120693,
            99131959,
            99121501,
            99120866,
            99121109,
            99120621
        ]
    },
    "name": "B. Non-Substring Subsequence",
    "statement": "Hr0d1y has q queries on a binary string s of length n. A binary string\r\nis a string containing only characters \u201d and \u201d.A query is described by a\r\npair of integers l_i, r_i (1\r\nleq l_i\r\nlt r_i\r\nleq n). For each query, he has to determine whether there exists a good\r\nsubsequence in s that is equal to the substring s[l_i\r\nldots r_i]. A substring s[i\r\nldots j] of a string s is the string formed by characters s_i s_{i+1}\r\nldots s_j. String a is said to be a subsequence of string b if a can be\r\nobtained from b by deleting some characters without changing the order\r\nof the remaining characters. A subsequence is said to be if it is not\r\ncontiguous and has length\r\nge 2. For example, if s is \"\", then the subsequences s_1s_2s_4 (\"\") and\r\ns_1s_5s_7 (\"\") are good, while s_1s_2s_3 (\"\") is not good. Can you help\r\nHr0d1y answer each query?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tint n,q; cin>>n>>q;\n\t\tstring s; cin>>s;\n\t\tfor(int z=0;z<q;z++)\n\t\t{\n\t\t\tint l,r; cin>>l>>r; l--; r--;\n\t\t\tint pos=0;\n\t\t\tfor(int i=0;i<l;i++)\n\t\t\t{\n\t\t\t\tif(s[i]==s[l]) pos=1;\n\t\t\t}\n\t\t\tfor(int i=r+1;i<n;i++)\n\t\t\t{\n\t\t\t\tif(s[i]==s[r]) pos=1;\n\t\t\t}\n\t\t\tif(pos) cout<<\"YES\\n\";\n\t\t\telse cout<<\"NO\\n\";\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Non-Substring Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/84885",
    "editorial": "In each query, the answer is YES iff the first character of the given\r\nsubstring is not the first occurence of that character or the last\r\ncharacter of the given substring is not the last occurrence of that\r\ncharacter in the string.The condition stated above is both necessary and\r\nsufficient.Proof that it is necessary:Assume that a non-contiguous\r\nsubsequence exists when the condition is false. If the first character\r\nof the substring is the first occurrence of its kind, then the\r\nsubsequence cannot start before it. Similarly, if the last character of\r\nthe substring is the last occurrence of its kind, then the subsequence\r\ncannot end after it. In such a case, the only subsequence that is of the\r\nsame length as the given substring and equal to it, is the substring\r\nitself. However, this subsequence is contiguous which is a\r\ncontradiction.Thus, it is a necessary condition.Proof that it is\r\nsufficient:If the first character of the substring occurs at some index\r\n, then the subsequence is good.If the last character of the substring\r\noccurs at some index , then the subsequence is good.Thus it is\r\nsufficient.Time complexity: or for each case depending on\r\nimplementation.\r\n"
}