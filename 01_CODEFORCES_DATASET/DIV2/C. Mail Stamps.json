{"link": "https://codeforces.com//contest/29/problem/C", "problemId": "136", "problem_idx": "C", "shortId": "29C", "contest_number": "29", "problem_submissions": {"E": [125241, 126330, 126155, 125733, 125865, 126658, 126234, 126231, 126226, 126224, 126223, 126222, 126220, 126219], "D": [125034, 124977, 125137, 124955, 126167, 124975, 125121, 125117, 125144, 125139, 125163, 125118, 125874, 125298, 126655, 125218, 125109, 125229, 124650, 125349, 125423], "C": [124653, 124641, 124557, 124552, 126791, 126165, 124733, 124669, 124678, 124726, 124730, 124571, 124765, 125873, 124728, 124502, 124723, 124476, 125051, 124748, 124750, 124948], "B": [124462, 124483, 124414, 124342, 126163, 124350, 124353, 124357, 124449, 124332, 124258, 124938, 125871, 124444, 124711, 124767, 124895, 125182, 124519, 124630], "A": [124199, 124174, 124196, 124170, 126162, 124168, 124167, 124166, 124172, 124158, 124163, 124217, 125867, 124218, 124863, 124230, 124176, 125258, 124181, 124231]}, "name": "C. Mail Stamps", "statement": "One day Bob got a letter in an envelope. Bob knows that when Berland\u2019s\r\npost officers send a letter directly from city to city , they stamp it\r\nwith , or . Unfortunately, often it is impossible to send a letter\r\ndirectly from the city of the sender to the city of the receiver, that\u2019s\r\nwhy the letter is sent via some intermediate cities. Post officers never\r\nsend a letter in such a way that the route of this letter contains some\r\ncity more than once. Bob is sure that the post officers stamp the\r\nletters accurately.There are stamps on the envelope of Bob\u2019s letter. He\r\nunderstands that the possible routes of this letter are only two. But\r\nthe stamps are numerous, and Bob can\u2019t determine himself none of these\r\nroutes. That\u2019s why he asks you to help him. Find one of the possible\r\nroutes of the letter.\r\n", "solutions": ["/*\nID: espr1t\nLANG: C++\nTASK: Demo\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 131072\n\nusing namespace std;\nFILE *in; FILE *out;\n\nint n;\nmap <int, vector <int> > v;\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(\"C.in\", \"rt\"); out = fopen(\"C.out\", \"wt\");\n\t\n\tfscanf(in, \"%d\", &n);\n\tint n1, n2;\n\tvector <int> indc;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfscanf(in, \"%d %d\", &n1, &n2);\n\t\tv[n1].push_back(n2); v[n2].push_back(n1);\n\t}\n\tint cur = -1, last;\n\tfor (map <int, vector <int> > :: iterator it = v.begin(); it != v.end(); it++)\n\t\tif (it->second.size() == 1) {cur = it->first; break;}\n\t\n\tvector <int> ans;\n\tans.push_back(cur); last = cur; cur = v[cur][0];\n\twhile (v[cur].size() != 1)\n\t{\n\t\tans.push_back(cur);\n\t\tint next;\n\t\tfor (int i = 0; i < (int)v[cur].size(); i++)\n\t\t\tif (v[cur][i] != last) next = v[cur][i];\n\t\tlast = cur; cur = next;\n\t}\n\tans.push_back(cur);\n\tfor (int i = 0; i < (int)ans.size(); i++)\n\t\tfprintf(out, \"%d%c\", ans[i], i + 1 == (int)ans.size() ? '\\n' : ' ');\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "implementation"], "dificulty": "1700", "interactive": false}