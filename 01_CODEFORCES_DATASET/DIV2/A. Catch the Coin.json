{
    "link": "https://codeforces.com//contest/1989/problem/A",
    "problemId": "2721694",
    "problem_idx": "A",
    "shortId": "1989A",
    "contest_number": "1989",
    "problem_submissions": {
        "F": [
            267852420,
            267715974,
            267712917,
            267719491,
            267734751,
            267735803,
            267741899,
            267747574,
            267768221,
            267767174,
            267766869,
            267748546,
            267750041,
            267754842,
            267760865,
            267768505,
            267763937,
            267766037,
            267765066,
            267764999,
            267764810
        ],
        "E": [
            267696430,
            267693533,
            267711891,
            267704153,
            267703845,
            267698823,
            267707139,
            267719026,
            267719849,
            267686019,
            267704171,
            267710707,
            267716623,
            267703403,
            267709172,
            267702509,
            267704995,
            267705649,
            267709118
        ],
        "D": [
            267685825,
            267682182,
            267696815,
            267692972,
            267693652,
            267703361,
            267692957,
            267722874,
            267708867,
            267680276,
            267687696,
            267691183,
            267686958,
            267692334,
            267690676,
            267692452,
            267695564,
            267692758,
            267700297
        ],
        "C": [
            267675529,
            267714300,
            267687642,
            267680264,
            267681105,
            267674205,
            267682216,
            267688126,
            267695068,
            267674713,
            267675536,
            267677226,
            267678584,
            267680860,
            267675171,
            267678912,
            267682170,
            267685177,
            267679841
        ],
        "B": [
            267671283,
            267671757,
            267674622,
            267674567,
            267676014,
            267669993,
            267681783,
            267674853,
            267678346,
            267669871,
            267670383,
            267672053,
            267670683,
            267671626,
            267671697,
            267674321,
            267674468,
            267673455,
            267671951
        ],
        "A": [
            267669443,
            267669849,
            267669717,
            267672060,
            267669107,
            267669168,
            267670166,
            267670012,
            267669413,
            267669118,
            267669169,
            267669489,
            267669101,
            267669245,
            267670092,
            267669875,
            267671315,
            267671181,
            267669241
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/130988",
    "editorial": "At first glance, it's not very convenient that the move consists of two parts: first the character moves, then the coin. Let's try to combine these steps. Since the coin moves down by 1\n each time, we can add this change in the y\n coordinate to the change in the character's y\n coordinate. That is, the character can now change its y\n coordinate not by ?1,0\n, or 1\n, but by 0,1\n, or 2\n. And the coins will always be in their initial positions.\n\nNow it is easy to see that all coins with y?0\n can be picked up. For example, you can first align with the coin in terms of the x\n coordinate, and then move up to it.\n\nHowever, in the example, it can be seen that Monocarp can pick up the coin (?2,?1)\n. This happens because the move still consists of two parts. Since the character moves first, and then the coin, we can align with the x\n coordinate again, and then have the time to move down to it.\n\nThus, all coins with y??1\n can be picked up.",
    "name": "A. Catch the Coin",
    "statement": "Monocarp visited a retro arcade club with arcade cabinets. There got\r\ncurious about the \"Catch the Coin\" cabinet.The game is pretty simple.\r\nThe screen represents a coordinate grid such that: the X-axis is\r\ndirected from left to right; the Y-axis is directed from bottom to top;\r\nthe center of the screen has coordinates (0, 0). At the beginning of the\r\ngame, the character is located in the center, and n coins appear on the\r\nscreen the i-th coin is at coordinates (x_i, y_i). The coordinates of\r\nall coins are different and not equal to (0, 0).In one second, Monocarp\r\ncan move the character in one of eight directions. If the character is\r\nat coordinates (x, y), then it can end up at any of the coordinates (x,\r\ny + 1), (x + 1, y + 1), (x + 1, y), (x + 1, y - 1), (x, y - 1), (x - 1,\r\ny - 1), (x - 1, y), (x - 1, y + 1).If the character ends up at the\r\ncoordinates with a coin, then Monocarp collects that coin.After Monocarp\r\nmakes a move, all coins fall down by 1, that is, they move from (x, y)\r\nto (x, y - 1). You can assume that the game field is infinite in all\r\ndirections.Monocarp wants to collect at least one coin, but cannot\r\ndecide which coin to go for. Help him determine, for each coin, whether\r\nhe can collect it.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;\u00a0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\u00a0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\u00a0using pii=pair<int,int>;using pll=pair<ll,ll>;\u00a0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\u00a0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\u00a0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\u00a0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\u00a0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\u00a0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\u00a0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\u00a0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\u00a0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;}\u00a0#ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif\u00a0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\u00a0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\u00a0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\u00a0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\u00a0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\u00a0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\u00a0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\u00a0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\u00a0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\u00a0//#include<atcoder/all>//using namespace atcoder;\u00a0//using mint=modint998244353;//using mint=modint1000000007;\u00a0void ahcorz(){    int a,b; cin >> a >> b;    print(b>=-1?\"YES\":\"NO\");}\u00a0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\A. Catch the Coin.json"
}