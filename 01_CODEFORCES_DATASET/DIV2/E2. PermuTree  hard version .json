{
    "link": "https://codeforces.com//contest/1856/problem/E2",
    "problemId": "2145357",
    "problem_idx": "E2",
    "shortId": "1856E2",
    "contest_number": "1856",
    "problem_submissions": {
        "E2": [
            217327108,
            217341724,
            217337731,
            217337437,
            217412216,
            217338400,
            217336393,
            217345459,
            217391033,
            217321012,
            217492472,
            217488570,
            217325278,
            217439292,
            217437989,
            217363475,
            217446369,
            217445127,
            217406790
        ],
        "D": [
            217299783,
            217294842,
            217318244,
            217319013,
            217306383,
            217302272,
            217316304,
            217332681,
            217344634,
            217306374,
            217314009,
            217314765,
            217312837,
            217302425,
            217303810,
            217314415,
            217312870,
            217318456,
            217300443,
            217400494,
            217316669
        ],
        "E1": [
            217289515,
            217306137,
            217300615,
            217308752,
            217314014,
            217319703,
            217297854,
            217321288,
            217321307,
            217290094,
            217290570,
            217296889,
            217296429,
            217312238,
            217311348,
            217286339,
            217297816,
            217298120,
            217312665,
            217400516,
            217300470
        ],
        "C": [
            217279950,
            217281231,
            217291934,
            217287003,
            217296034,
            217283292,
            217292390,
            217290232,
            217308894,
            217275596,
            217275048,
            217281202,
            217279491,
            217289317,
            217288630,
            217298170,
            217285184,
            217287913,
            217284586,
            217400474,
            217290893
        ],
        "B": [
            217269320,
            217271397,
            217269501,
            217272164,
            217281399,
            217274759,
            217266730,
            217267264,
            217269590,
            217284481,
            217268556,
            217268444,
            217267764,
            217270460,
            217268264,
            217272318,
            217272448,
            217269161,
            217271865,
            217400507,
            217272774
        ],
        "A": [
            217264730,
            217266241,
            217264910,
            217266955,
            217265330,
            217267424,
            217264736,
            217264718,
            217265900,
            217267758,
            217264795,
            217265478,
            217264842,
            217265458,
            217264741,
            217264735,
            217265053,
            217264661,
            217265267,
            217400456,
            217266136
        ]
    },
    "name": "E2. PermuTree  hard version ",
    "statement": "You are given a tree with n vertices rooted at vertex 1.For some\r\npermutation^\r\ndagger a of length n, let f(a) be the number of pairs of vertices (u, v)\r\nsuch that a_u < a_{\r\noperatorname{lca}(u, v)} < a_v. Here,\r\noperatorname{lca}(u,v) denotes the lowest common ancestor of vertices u\r\nand v.Find the maximum possible value of f(a) over all permutations a of\r\nlength n.^\r\ndagger A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (2 appears twice in the\r\narray), and [1,3,4] is also not a permutation (n=3 but there is 4 in the\r\narray).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define ld long double\n#define ll long long int\n#define st first\n#define nd second\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n\nusing namespace std;\n\nconst int N = 1e6 + 5;\nvector<int> adj[N];\nint sz[N];\nll ans = 0;\nint n;\nbitset<N> dp;\n\npriority_queue<int> Q;\nvector<int> its;\nstack<int> now;\n\nconst int TR2 = 6666;\nconst int TR3 = 155;\n\nbitset<TR2> dp2;\nint tot;\n\nll brute(){\n    dp2.reset();\n    dp2[0] = true;\n    for(int x : its){\n        dp2 |= (dp2 << x);\n    }\n    ll mx = 0;\n    for(int i=0;i<=tot-1;i++){\n        if(dp2[i]) mx = max(mx, 1LL * i * (tot - 1 - i));\n    }\n    return mx;\n}\n\nbitset<TR3> dp3;\n\nll brute2(){\n    dp3.reset();\n    dp3[0] = true;\n    for(int x : its){\n        dp3 |= (dp3 << x);\n    }\n    ll mx = 0;\n    for(int i=0;i<=tot-1;i++){\n        if(dp3[i]) mx = max(mx, 1LL * i * (tot - 1 - i));\n    }\n    return mx;\n\n}\n\nvoid clr(){\n    while(!Q.empty()) Q.pop();\n    while(!now.empty()) now.pop();\n    its.clear();\n}\n\nvector<int> childs[N];\n\n\nvoid ev(int v){\n    int big = 0;\n    sz[v] = 1;\n    for(int x : childs[v]){\n\n\n            sz[v] += sz[x];\n            big = max(big, sz[x]);\n\n    }\n\n    if(big >= (sz[v] - 1) / 2){\n        ll one = big;\n        ll two = sz[v] - 1 - one;\n        ans += one * two;\n        return;\n    }\n\n    clr();\n    for(int x : childs[v]){\n        Q.push(-sz[x]);\n    }\n\n    while(Q.size()){\n        int cur = Q.top();\n        while(!Q.empty() && Q.top() == cur){\n            Q.pop();\n            now.push(-cur);\n        }\n        while((int)now.size() > 2){\n            int cur = now.top();\n            now.pop();\n            now.pop();\n            Q.push(-cur * 2);\n        }\n        while(!now.empty()){\n            its.pb(now.top());\n            now.pop();\n        }\n    }\n    if(sz[v] < TR3){\n        tot = sz[v];\n        ans += brute2();\n        return;\n    }\n    if(sz[v] < TR2){\n        tot = sz[v];\n        ans += brute();\n        return;\n    }\n    // its sorted\n    dp.reset();\n    dp[0] = true;\n    for(int x : its){\n        dp |= (dp << x);\n    }\n    ll mx = 0;\n    for(int i=0;i<=sz[v]-1;i++){\n        if(dp[i]) mx = max(mx, 1LL * i * (sz[v] - 1 - i));\n    }\n    ans += mx;\n}\n\nvoid gogo(){\n    vector<int> ord;\n    ord.pb(1);\n    int p = 0;\n    while(p < (int)ord.size()){\n        int cur = ord[p++];\n        for(int x : childs[cur]) ord.pb(x);\n    }\n    reverse(ord.begin(), ord.end());\n    for(int x : ord){\n        ev(x);\n    }\n}\n\nvoid solve(){\n   cin >> n;\n\n    for(int i=2;i<=n;i++){\n        int x; cin >> x;\n        childs[x].pb(i);\n        //adj[x].pb(i);\n        //adj[i].pb(x);\n    }\n    gogo();\n    cout << ans << \"\\n\";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int tt = 1;\n    // cin >> tt;\n    while(tt--) solve();\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dp",
        "fft",
        "greedy",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E2. PermuTree  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/119058",
    "editorial": "First of all, the most important takeaways from the editorial for the\r\neasy version: For each from to , you can solve independent subproblems\r\nof maximizing the number of suitable pairs for a fixed value of , and\r\nthen add up the results to get the final answer. For each subproblem,\r\nthe number of suitable pairs of vertices can be calculate based on the\r\nsizes of all the child subtrees and the number of vertices with in each\r\nof them, which we will call . Consider the subproblem for some . Let be\r\nthe number of child subtrees of vertex . Suppose some optimal values of\r\nthat maximize the number of suitable pairs are respectively.Claim: there\r\nexists an optimal solution where or for all from to .Proof: letâs\r\nconsider some optimal solution where for some . Suppose is the number of\r\nsuitable pairs of vertices such that both and donât lie in the -th\r\nchildâs subtree. Then, the total number of suitable pairs is equal to:\r\nIf we define and , we get an even simpler formula: The values of , , and\r\ndonât depend on the value of , so we can freely change it to anything\r\nfrom to maximize the value of the formula. So: If , the value of the\r\nformula will not decrease if we set to . If , the value of the formula\r\nwill not decrease if we set to . Since at least one of this conditions\r\nhas to be true, we can always take some optimal solution with indices\r\nsuch that and get an optimal solution with such indices. We repeat this\r\nprocess until becomes , which means that or for all from to , as was\r\nstated in the claim. Consider an optimal solution where is equal to\r\neither or . Let be the sum of over all such that and be the sum of over\r\nall such that . Then, the number of suitable pairs is equal to: If we\r\ndefine as , we can see that is equal to , so we are actually maximizing\r\nthe value of: To do this, we can iterate from to , find if it is\r\npossible to choose some subset of indices such that , and update the\r\ncurrent best answer if such a set exists.Doing this efficiently is known\r\nas the subset sum problem (or some variation of it). One of the simplest\r\nways to solve it in this particular case with a dynamic programming\r\nsolution: is equal to if there exists a set of indices such that and is\r\nequal to otherwise. We will proceed to optimize it.The first standard\r\noptimization will bring the complexity down to , you can read about it\r\nin Section 3 of this Codeforces blog or in the \"Subset Sum Speedup 1\"\r\nsection of this Codeforces blog.Since we are trying to maximize the\r\nvalue of , the optimal choice will also minimize the value of .Claim:\r\ndenote as . If , the smallest possible value of is achieved with or\r\n.Proof: it is clearly possible to get . Suppose it is possible to get\r\nsome value of in the segment . Then, did not contribute to the sum , and\r\nso canât exceed . But , so we get a contradiction, hence it is not\r\npossible to get some .So if we have , we actually donât have to run the\r\ndynamic programming part. We will now analyze the complexity of the\r\nsolution with this optimization.Letâs now define as . Letâs also call a\r\nvertex heavy if and light otherwise. Suppose that vertex has light\r\nancestors on itâs path to the root: Every subtree of a light vertex has\r\nat most vertices in it. Every subtree of a heavy vertex has at most\r\nvertices in it. Since there are light ancestors, we can conclude that\r\n.For each from to , let be the set of light vertices with exactly light\r\nancestors (a vertex doesnât count as itâs own ancestor): Note that if\r\ntwo light vertices and are in the same set , one canât be the ancestor\r\nof the other. So, the sum does not exceed . for all . For some , letâs\r\ncalculate the total number of \"operations\" taken in the dynamic\r\nprogramming part for all . To do that, we: Iterate over the number of\r\nvertices in the set , letâs call it , from to . Let be the sizes of the\r\nsubtrees of vertices in . Then we need to maximize the value of: over\r\nall such that and . You might have noticed that the above process can be\r\nsimplified by allowing to be equal to . In that case, the number of\r\nvertices is equal to the number of positive integers in , and we need to\r\nmaximize:over all integer such that and .Let . Weâll assume , otherwise,\r\nis equal to for all and the sum is always equal to .Lemma 1: it is\r\noptimal to have .Proof: if we can increase some , it is clearly optimal\r\nto do so.Lemma 2: suppose the maximum is achieved on the set of values .\r\nThen there does not exist a pair of indices and such that .Proof: define\r\n. Note that is a monotonically increasing function for all . You can\r\nprove it by, for example, analyzing itâs derivative: . If we decrease by\r\nand increase by , the sum changes by: By doing this, we havenât broken\r\nany constraints on the values of , but have increased the total sum, so\r\nthe previous values of couldnât have been optimal.This lemma gives us\r\nthe nice property that the optimal values of look something like ; where\r\n.With this we can conclude that the total number of \"operations\"\r\nperformed for all vertices in is at most: Adding this up over all with ,\r\nwe get: We can notice that the sum in the brackets in bounded by the sum\r\nof an infinite geometric progression with a sum of , so the total sum\r\nis: Finally, we will also use bitsets to speed up our dynamic\r\nprogramming part and bring the complexity down to , where is the word\r\nsize, usually or .You can learn about bitsets in this Codeforces blog.\r\nTo get a simple variable length bitset in C++, refer to this\r\ncomment.Complexity: .\r\n",
    "hint": [
        "Hint 0 Read hints for the easy version.",
        "Hint 1 For each , we actually need to do subset sum on the subtree sizes.",
        "Hint 2 If there is a very subtree that is bigger than the sum of the sizes of the other subtrees, you don't have to do subset sum.",
        "Hint 3 Optimize subset sum to , where s is the sum of the sizes of the subtrees for some fixed .",
        "Hint 4 Use bitset to optimize subset sum even more.",
        "Hint 1 For every we actually need to do Knapsack on the subtree sizes."
    ]
}