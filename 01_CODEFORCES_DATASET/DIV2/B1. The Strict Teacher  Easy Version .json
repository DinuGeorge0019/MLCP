{
    "link": "https://codeforces.com//contest/2005/problem/B1",
    "problemId": "2874761",
    "problem_idx": "B1",
    "shortId": "2005B1",
    "contest_number": "2005",
    "problem_submissions": {
        "D": [
            281235653,
            281227144,
            281213796,
            281208378,
            281200216,
            281210661,
            281229125,
            281218901,
            281212535,
            281243866,
            281350064,
            281350034,
            281349836,
            281237949,
            281234174,
            281333026,
            281241673,
            281234895,
            281296853,
            281392724,
            281392690,
            281390698,
            281222053,
            281226405
        ],
        "E1": [
            281205887,
            281155079,
            281234070,
            281226477,
            281216705,
            281235212,
            281205331,
            281199518,
            281203018,
            281232678,
            281243730,
            281206762,
            281221617,
            281212135,
            281211097,
            281244210,
            281168056,
            281215476,
            281238723,
            281242094
        ],
        "E2": [
            281204742,
            281184010,
            281246880,
            281250832,
            281257196,
            281227631,
            281224421,
            281358152,
            281367297,
            281223410,
            281233931
        ],
        "A": [
            281164039,
            281207460,
            281140596,
            281137242,
            281136929,
            281139795,
            281140415,
            281137198,
            281141021,
            281139668,
            281139628,
            281147187,
            281141192,
            281140604,
            281139734,
            281142096,
            281145579,
            281142356
        ],
        "C": [
            281160355,
            281201042,
            281183655,
            281193050,
            281164715,
            281187878,
            281173957,
            281177930,
            281184031,
            281188476,
            281187130,
            281170696,
            281175121,
            281184097,
            281174240,
            281175117,
            281195983,
            281182012,
            281199232,
            281194476
        ],
        "B1": [
            281144574,
            281205694,
            281155464,
            281146115,
            281148469,
            281157812,
            281152325,
            281156606,
            281157252,
            281159142,
            281158472,
            281156353,
            281163937,
            281156241,
            281152111,
            281152521,
            281167116,
            281156822,
            281160647
        ],
        "B2": [
            281143694,
            281205362,
            281154775,
            281147352,
            281149038,
            281157058,
            281152845,
            281156903,
            281156460,
            281159520,
            281157889,
            281155572,
            281164430,
            281155566,
            281152797,
            281152721,
            281166374,
            281160753,
            281161736
        ]
    },
    "editorial_link": "https://codeforces.com/blog/entry/133869",
    "editorial": "For the easy version, there are three cases and they can be considered separately.\n\nCase 1: David is in the left of both teachers. In this case, it is obvious that he needs to go as far left as possible, which is cell 1\n. Then, the time needed to catch David will be b1?1\n.\n\nCase 2: David is in the right of both teachers. In this case, similarly, David needs to go as far right as possible, which is cell n\n. Then, the time needed to catch David will be n?b2\n.\n\nCase 3: David is between the two teachers. In this case, David needs to stay in the middle (if there are two middle cells, it doesn't matter which one is picked as the middle) of two teachers, so they both have to come closer to him simultaneously. So, they will need the same amount of time, which will be (b2?b1)/2\n. Notice, that David can always go to the middle cell not depending on his cell number.",
    "name": "B1. The Strict Teacher  Easy Version ",
    "statement": "Narek and Tsovak were busy preparing this round, so they have not\r\nmanaged to do their homework and decided to steal David\u2019s homework.\r\nTheir strict teacher noticed that David has no homework and now wants to\r\npunish him. She hires other teachers to help her catch David. And now m\r\nteachers together are chasing him. Luckily, the classroom is big, so\r\nDavid has many places to hide.The classroom can be represented as a\r\none-dimensional line with cells from 1 to n, inclusive.At the start, all\r\nm teachers and David are in cells. Then they make moves. During each\r\nmove David goes to an adjacent cell or stays at the current one. Then,\r\neach of the m teachers simultaneously goes to an adjacent cell or stays\r\nat the current one. This continues until David is caught. David is\r\ncaught if any of the teachers (possibly more than one) is located in the\r\nsame cell as David. Your task is to find how many moves it will take for\r\nthe teachers to catch David if they all act optimally.Acting optimally\r\nmeans the student makes his moves in a way that maximizes the number of\r\nmoves the teachers need to catch him; and the teachers coordinate with\r\neach other to make their moves in a way that minimizes the number of\r\nmoves they need to catch the student.Also, as Narek and Tsovak think\r\nthis task is easy, they decided to give you q queries on David\u2019s\r\nposition. this is the easy version, and you are given .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0int sir[100001];\u00a0inline void Solve (){    int limita , lungime , numar_intrebari;    cin >> limita >> lungime >> numar_intrebari;\u00a0    for (int indice = 1 ; indice <= lungime ; indice++)        { cin >> sir[indice]; }\u00a0    sort(sir + 1 , sir + lungime + 1);\u00a0    while (numar_intrebari--)    {        int locatie;        cin >> locatie;\u00a0        if (locatie < sir[1])            { cout << sir[1] - 1 << '\\n'; continue; }\u00a0        if (locatie > sir[lungime])            { cout << limita - sir[lungime] << '\\n'; continue; }\u00a0        int pozitie = 0;        for (int putere = 65536 ; putere ; putere >>= 1) {            if ((pozitie | putere) <= lungime && sir[pozitie | putere] < locatie)                { pozitie |= putere; }        }\u00a0        cout << (sir[pozitie + 1] + sir[pozitie]) / 2 - sir[pozitie] << '\\n';    }   }\u00a0int main (){    ios :: sync_with_stdio(false);    cin.tie(NULL); cout.tie(NULL);\u00a0    int numar_teste = 1;    cin >> numar_teste;    while (numar_teste--)        { Solve(); }\u00a0    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B1. The Strict Teacher  Easy Version .json"
}