{
    "link": "https://codeforces.com//contest/861/problem/F",
    "problemId": "122874",
    "problem_idx": "F",
    "shortId": "861F",
    "contest_number": "861",
    "problem_submissions": {
        "B": [
            30441262,
            30424376,
            30427161,
            30427960,
            30424359,
            30424926,
            30425840,
            30430094,
            30424319,
            30428309,
            30428624,
            30440366,
            30437511,
            30435804,
            30427921,
            30432832,
            30423882
        ],
        "F": [
            30440095,
            30439628,
            30440266,
            30439498,
            30441670,
            30441500,
            30452319,
            30437084
        ],
        "E": [
            30436514,
            30436701,
            30441404,
            30443472,
            30442827,
            30445184,
            30445314,
            30443353,
            30443911
        ],
        "D": [
            30428168,
            30427382,
            30423887,
            30433533,
            30430871,
            30432293,
            30434646,
            30433520,
            30433941,
            30433630,
            30434459,
            30436865,
            30433644,
            30426019,
            30432738,
            30434925,
            30433542,
            30432317,
            30434703
        ],
        "A": [
            30424689,
            30422095,
            30427679,
            30422354,
            30422107,
            30422516,
            30422863,
            30426215,
            30422101,
            30424813,
            30422256,
            30425576,
            30489148,
            30430836,
            30422849,
            30423019,
            30422141,
            30422002
        ],
        "C": [
            30423987,
            30425801,
            30429852,
            30426800,
            30428131,
            30429744,
            30425472,
            30430400,
            30430892,
            30431289,
            30440032,
            30431284,
            30432065,
            30432412,
            30435482,
            30426919
        ]
    },
    "name": "F. Wizard s Tour",
    "statement": "All Berland residents are waiting for an unprecedented tour of wizard in\r\nhis Blue Helicopter over the cities of Berland!It is well-known that\r\nthere are cities in Berland, some pairs of which are connected by\r\nbidirectional roads. Each pair of cities is connected by no more than\r\none road. It is not guaranteed that the road network is , i.e. it is\r\npossible that you can\u2019t reach some city from some other.The tour will\r\ncontain several episodes. In each of the episodes: the wizard will\r\ndisembark at some city from the Helicopter; he will give a performance\r\nand show a movie for free at the city ; he will drive to some\r\nneighboring city using a road; he will give a performance and show a\r\nmovie for free at the city ; he will drive to some neighboring to city ;\r\nhe will give a performance and show a movie for free at the city ; he\r\nwill embark the Helicopter and fly away from the city . It is known that\r\nthe wizard doesn\u2019t like to use roads, so he agrees to use each road at\r\nmost once (regardless of direction). In other words, for road between\r\nand he only can drive once from to , or drive once from to , or do not\r\nuse this road at all.The wizards wants to plan as many episodes as\r\npossible without violation the above rules. Help the wizard!Please note\r\nthat the wizard can visit the same city multiple times, the restriction\r\nis on roads only.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(\"%d\",&num1)\n#define sll(num1) scanf(\"%lld\",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define TRACE\n \n//FILE *fin = freopen(\"in\",\"cc\",stdin);\n//FILE *fout = freopen(\"out\",\"s2numx\",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << \": \" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << \": \" << numx << \" | \" << #to << \": \" << to << \" | \" << #nn3 << \": \" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << endl;\n#define trace5(num1, bin, ch, d, txx)    cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #txx << \": \" << txx << endl;\n#define trace6(num1, bin, ch, d, txx, det) cerr << #num1 << \": \" << num1 << \" | \" << #bin << \": \" << bin << \" | \" << #ch << \": \" << ch << \" | \" << #d << \": \" << d << \" | \" << #txx << \": \" << txx << \" | \" << #det << \": \" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, txx)\n#define trace6(num1, bin, ch, d, txx, det)\n \n#endif\n\n#define pi(numx) printf(\"%d\\num1\",numx)\n#define ff first\n#define ss second\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n#define fast ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define ll long long\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n\n#define lb lower_bound\n#define ub upper_bound\n\nusing namespace std;\n VI v1, v2, v3;\nvector<bool> ff1;\nvector< VI > vecc;\nmap<PII, bool> mp1;\n\n \nint depth(int nn1, int flag){\n\tint present = -1;\n\tif(ff1[nn1]){\n\t\tif(mp1[mp(flag, nn1)]) return -1;\n\t\treturn nn1;\t\n\t} \n\tff1[nn1] = true;\n\tfor(int i=0; i<vecc[nn1].size(); i++){\n\t\tif(vecc[nn1][i] == flag) continue;\n \n\t\tint zoo = depth(vecc[nn1][i], nn1);\n\t\tif(zoo==-1) continue;\n\t\tif(present == -1) {\n\t\t\tpresent = zoo;\n\t\t\tcontinue;\n\t\t}\n\t\tv1.pb(present);\n\t\tv2.pb(nn1);\n\t\tv3.pb(zoo);\n\t\tmp1[mp(present, nn1)] = true;\n\t\tmp1[mp(nn1, zoo)] = true;\n\t\tmp1[mp(nn1, present)] = true;\n\t\tmp1[mp(zoo, nn1)] = true;\n\t\tpresent = -1;\n\t}\n\tif(present!=-1){\n\t\tif(flag!=-1){\n\t\t\tv1.pb(present);\n\t\t\tv2.pb(nn1);\n\t\t\tv3.pb(flag);\n\t\t\tmp1[mp(nn1, flag)] = true;\n\t\t\tmp1[mp(present, nn1)] = true;\n\t\t\t\n\t\t\t\n\t\t\tmp1[mp(flag, nn1)] = true;\n\t\t\tmp1[mp(nn1, present)] = true;\n\t\t}\n\t\treturn -1;\n\t}\n\treturn nn1;\n}\n \nint main() {\n    \tint nn1, mp1;\n\tcin >> nn1 >> mp1;\n \n\tfor(int i=0; i<nn1; i++){\n\t\tVI vve;\n\t\tvecc.pb(vve);\t\n\t}\n\tfor(int i=0; i<mp1; i++){\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\tvecc[from-1].pb(to-1);\n\t\tvecc[to-1].pb(from-1);\n\t}\n\tfor(int i=0; i<nn1; i++){\n\t\tff1.pb(false);\n\t}\n\tfor(int i=0; i<nn1; i++){\n\t\tif(!ff1[i]) {\n\t\t    depth(i, -1);\n\t\t}\n\t}\n\tcout << v1.size() << endl;\n\tfor(int i=0; i<v1.size(); i++){\n\t\tcout << v1[i]+1 << \" \" << v2[i]+1 << \" \" << v3[i]+1 << endl;\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Wizard s Tour.json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "Obviously the task can be solved independently for each component.\n\nHere is the algorithm that allows you to reach exactly  tours, where m is the number of edges in the component. Let's take arbitrary tree built by depth-first search. While exiting vertex v, we can process all the edges to the vertices with greater height and the edge connecting vertex v to its parent in the tree (if v isn't a root). If the number of edges to the lower vertices is even then we can split then into pairs. Otherwise let's add the edge from the parent to this splitting and not handle it for the parent itself.\n\nThis algorithm will find the pair to every edge for all the vertices but the root. There will be at most one edge without the pair so the answer is maximal."
}