{
    "link": "https://codeforces.com//contest/1358/problem/F",
    "problemId": "630280",
    "problem_idx": "F",
    "shortId": "1358F",
    "contest_number": "1358",
    "problem_submissions": {
        "A": [
            81620245,
            81480420,
            81480612,
            81480397,
            81480359,
            81480467,
            81482408,
            81480978,
            81483693,
            81481176,
            81481249,
            81480468,
            81481050,
            81480725,
            81480917,
            81482628,
            81486951,
            92936660,
            81490429,
            81481121,
            81482901
        ],
        "B": [
            81620220,
            81482491,
            81492096,
            81483797,
            81489848,
            81487033,
            81486874,
            81486697,
            81490338,
            81487051,
            81486247,
            81483724,
            81497864,
            81487382,
            81488926,
            81493163,
            81491431,
            81489879,
            81485018,
            81495301
        ],
        "C": [
            81620191,
            81486723,
            81496245,
            81493700,
            81488612,
            81493172,
            81499005,
            81495501,
            81496996,
            81496974,
            81500972,
            81490527,
            81490630,
            81502941,
            81499388,
            81501230,
            81498487,
            81501924,
            81492445,
            81488275
        ],
        "D": [
            81620172,
            81495934,
            81509733,
            81505892,
            81500534,
            81507831,
            81509665,
            81506130,
            81511830,
            81510707,
            81513684,
            81511927,
            81510294,
            81510451,
            81513883,
            81514506,
            81510412,
            81512029,
            81504276,
            81514742
        ],
        "E": [
            81620156,
            81517050,
            81519733,
            81518214,
            81524639,
            164155905,
            81522702,
            81522902,
            81522151,
            81525693,
            81527065,
            81524408,
            81527151,
            81529704,
            81528088,
            81526351,
            81527385,
            81530473,
            81528982,
            81538269,
            81532727
        ],
        "F": [
            81620132,
            81539358,
            81693390,
            81570956,
            81570691,
            81537746,
            81550859,
            164160232,
            81580050,
            81553047
        ]
    },
    "name": "F. Tasty Cookie",
    "statement": "Oh, no!The coronavirus has caught you, and now you\u2019re sitting in a dark\r\ncellar, with tied legs (but not hands). You have a delicious cookie, a\r\nlaptop in front of you, and your ideal development environment is open.\r\nThe coronavirus convinces you to solve the following problem.You are\r\ngiven two arrays A and B of size n. You can do operations of two types\r\nwith array A: Reverse array A. That is the array [A_1,\r\nA_2,\r\nldots,\r\nA_n] transformes into [A_n,\r\nA_{n-1},\r\nldots,\r\nA_1]. Replace A with an array of its prefix sums. That is, the array\r\n[A_1,\r\nA_2,\r\nldots,\r\nA_n] goes to [A_1,\r\n(A_1+A_2),\r\nldots,\r\n(A_1+A_2+\r\nldots+A_n)]. You need to understand if you can get an array B from the\r\narray A. If it is possible, you will have to restore the order of these\r\noperations by minimizing the number of operations of the second type.\r\nFortunately, the coronavirus is good today, so he has allowed you not to\r\nrestore actions if the minimum number of second type operations is more\r\nthan 2\r\ncdot 10^5. But coronavirus resents you, so if you restore the answer,\r\nthe total number of operations should not exceed 5\r\ncdot 10^5.Solve this problem and get the cookie, or the coronavirus will\r\nextend the quarantine for five years and make the whole economy\r\ncollapse!\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n \ntypedef long long LL;\nconst int MN = 200005, MS = 10000005;\n \nint N;\nLL A[MN], B[MN];\nLL Ans[MS]; int C;\n \ninline void check() {\n\tint ok1 = 1, ok2 = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (A[i] != B[i]) ok1 = 0;\n\t\tif (A[i] != B[N - i + 1]) ok2 = 0;\n\t}\n\tif (!ok1 && ok2) ok1 = 1, Ans[++C] = -1;\n\tif (ok1) {\n\t\tLL tot1 = 0, tot2 = 0;\n\t\tfor (int i = 1; i <= C; ++i)\n\t\t\ttot1 += Ans[i] == -1 ? 1 : Ans[i],\n\t\t\ttot2 += Ans[i] == -1 ? 0 : Ans[i];\n\t\tif (tot2 > 200000) printf(\"BIG\\n%lld\\n\", tot2);\n\t\telse {\n\t\t\tprintf(\"SMALL\\n%lld\\n\", tot1);\n\t\t\tfor (int i = C; i >= 1; --i) {\n\t\t\t\tif (Ans[i] == -1) putchar('R');\n\t\t\t\telse {\n\t\t\t\t\tint x = Ans[i];\n\t\t\t\t\twhile (x) putchar('P'), --x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\texit(0);\n\t}\n}\n \nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &A[i]);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &B[i]);\n\tcheck();\n\tif (N == 1) {\n\t\tif (A[1] == B[1]) puts(\"SMALL\\n0\\n\");\n\t\telse puts(\"IMPOSSIBLE\");\n\t\treturn 0;\n\t}\n\tif (N == 2) {\n\t\tif (B[1] == B[2]) return puts(\"IMPOSSIBLE\"), 0;\n\t\twhile (1) {\n//\t\t\tprintf(\"(%lld, %lld)\\n\", B[1], B[2]);\n\t\t\tif (B[1] > B[2]) std::swap(B[1], B[2]), Ans[++C] = -1;\n\t\t\tif (A[1] == B[1]) {\n\t\t\t\tLL diff = B[2] - A[2];\n\t\t\t\tif (diff < 0 || diff % B[1] != 0) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\t\tAns[++C] = diff / B[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (A[2] == B[1]) {\n\t\t\t\tLL diff = B[2] - A[1];\n\t\t\t\tif (diff < 0 || diff % B[1] != 0) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\t\tAns[++C] = diff / B[1];\n\t\t\t\tAns[++C] = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (B[2] % B[1] == 0) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\tAns[++C] = B[2] / B[1];\n\t\t\tB[2] %= B[1];\n\t\t}\n\t\tLL tot1 = 0, tot2 = 0;\n\t\tfor (int i = 1; i <= C; ++i)\n\t\t\ttot1 += Ans[i] == -1 ? 1 : Ans[i],\n\t\t\ttot2 += Ans[i] == -1 ? 0 : Ans[i];\n\t\tif (tot2 > 200000) printf(\"BIG\\n%lld\\n\\n\", tot2);\n\t\telse {\n\t\t\tprintf(\"SMALL\\n%lld\\n\", tot1);\n\t\t\tfor (int i = C; i >= 1; --i) {\n\t\t\t\tif (Ans[i] == -1) putchar('R');\n\t\t\t\telse {\n\t\t\t\t\tint x = Ans[i];\n\t\t\t\t\twhile (x) putchar('P'), --x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (B[1] == B[N]) return puts(\"IMPOSSIBLE\"), 0;\n\t\tif (B[1] > B[N]) {\n\t\t\tstd::reverse(B + 1, B + N + 1), Ans[++C] = -1;\n\t\t} else {\n\t\t\tint ok = 1;\n\t\t\tfor (int i = 2; i <= N; ++i)\n\t\t\t\tif (B[i - 1] >= B[i]) ok = 0;\n\t\t\tif (!ok) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\tfor (int i = N; i >= 2; --i)\n\t\t\t\tB[i] -= B[i - 1];\n\t\t\tAns[++C] = 1;\n\t\t}\n//\t\tprintf(\"\\t\\t\\t\"); for (int i = 1; i <= N; ++i) printf(\"%lld, \", B[i]); puts(\"\");\n\t\tcheck();\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Tasty Cookie.json",
    "editorial_link": "https://codeforces.com//blog/entry/77869",
    "editorial": "Let\u00e2\u0080\u0099s define a few operations and constants: replace an array with its\r\nprefix sums array reverse an array restore the original array from a\r\nprefix sums array the array values upper bound First, we can prove that\r\nis unambiguosly defined for strictly increasing arrays. Consider an\r\narray . Let be the prefix sums array of . Notice that , (for ). Thus we\r\ncan restore from . Note that if we apply to an array for which doesn\u00e2\u0080\u0099t\r\nhold, the resulting array will have a non-positive element which is\r\nforbidden by the statements.Now let\u00e2\u0080\u0099s analyze how many operations can\r\ntheoretically be applied for arrays of different lengths (let\u00e2\u0080\u0099s call\r\ntheir count ) (We can do that by applying to array while all numbers are\r\nbelow ):It\u00e2\u0080\u0099s obvious that we\u00e2\u0080\u0099ll need no more than s for an array of\r\nlength . It can also be proved that .Let\u00e2\u0080\u0099s restore the array in steps.\r\nOne each step we have several cases: If equals or , we know how to get\r\nfrom . If is strictly increasing, apply . If is strictly decreasing,\r\napply . Otherwise, the answer is \"\". This solution will run infinitely\r\nwhen and , so the case when has to be handled separately.The asymptotic\r\nof this solution is . Notice that because we can\u00e2\u0080\u0099t have two operations\r\nin a row. It means this solution will fit into TL for , but we need a\r\nseparate solution for .Consider an array . If we it while , the array\r\nwill be transformed into . It means we can several iterations at\r\nonce.So, the solution for is: First sort and so that they both increase\r\n(and take this into account when printing answer) Now start the loop: If\r\n, we can break the loop if , otherwise the answer is \"\". If , we can\r\ncalculate how many operations we should apply to transform into , modify\r\nthe answer accordingly and jump to the next iteration for (after\r\napplying one operation). This algorithm is very similar to the\r\nEuclidian\u00e2\u0080\u0099s algorithm, and that\u00e2\u0080\u0099s how we can prove there will be s.The\r\noverall complexity is for ; for .\r\n"
}