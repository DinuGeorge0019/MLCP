{"link": "https://codeforces.com//contest/1358/problem/F", "problemId": "630280", "problem_idx": "F", "shortId": "1358F", "contest_number": "1358", "problem_submissions": {"A": [81620245, 81480420, 81480612, 81480397, 81480359, 81480467, 81482408, 81480978, 81483693, 81481176, 81481249, 81480468, 81481050, 81480725, 81480917, 81482628, 81486951, 92936660, 81490429, 81481121, 81482901], "B": [81620220, 81482491, 81492096, 81483797, 81489848, 81487033, 81486874, 81486697, 81490338, 81487051, 81486247, 81483724, 81497864, 81487382, 81488926, 81493163, 81491431, 81489879, 81485018, 81495301], "C": [81620191, 81486723, 81496245, 81493700, 81488612, 81493172, 81499005, 81495501, 81496996, 81496974, 81500972, 81490527, 81490630, 81502941, 81499388, 81501230, 81498487, 81501924, 81492445, 81488275], "D": [81620172, 81495934, 81509733, 81505892, 81500534, 81507831, 81509665, 81506130, 81511830, 81510707, 81513684, 81511927, 81510294, 81510451, 81513883, 81514506, 81510412, 81512029, 81504276, 81514742], "E": [81620156, 81517050, 81519733, 81518214, 81524639, 164155905, 81522702, 81522902, 81522151, 81525693, 81527065, 81524408, 81527151, 81529704, 81528088, 81526351, 81527385, 81530473, 81528982, 81538269, 81532727], "F": [81620132, 81539358, 81693390, 81570956, 81570691, 81537746, 81550859, 164160232, 81580050, 81553047]}, "name": "F. Tasty Cookie", "statement": "Oh, no!The coronavirus has caught you, and now you\u2019re sitting in a dark\r\ncellar, with tied legs (but not hands). You have a delicious cookie, a\r\nlaptop in front of you, and your ideal development environment is open.\r\nThe coronavirus convinces you to solve the following problem.You are\r\ngiven two arrays A and B of size n. You can do operations of two types\r\nwith array A: Reverse array A. That is the array [A_1,\r\nA_2,\r\nldots,\r\nA_n] transformes into [A_n,\r\nA_{n-1},\r\nldots,\r\nA_1]. Replace A with an array of its prefix sums. That is, the array\r\n[A_1,\r\nA_2,\r\nldots,\r\nA_n] goes to [A_1,\r\n(A_1+A_2),\r\nldots,\r\n(A_1+A_2+\r\nldots+A_n)]. You need to understand if you can get an array B from the\r\narray A. If it is possible, you will have to restore the order of these\r\noperations by minimizing the number of operations of the second type.\r\nFortunately, the coronavirus is good today, so he has allowed you not to\r\nrestore actions if the minimum number of second type operations is more\r\nthan 2\r\ncdot 10^5. But coronavirus resents you, so if you restore the answer,\r\nthe total number of operations should not exceed 5\r\ncdot 10^5.Solve this problem and get the cookie, or the coronavirus will\r\nextend the quarantine for five years and make the whole economy\r\ncollapse!\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n \ntypedef long long LL;\nconst int MN = 200005, MS = 10000005;\n \nint N;\nLL A[MN], B[MN];\nLL Ans[MS]; int C;\n \ninline void check() {\n\tint ok1 = 1, ok2 = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (A[i] != B[i]) ok1 = 0;\n\t\tif (A[i] != B[N - i + 1]) ok2 = 0;\n\t}\n\tif (!ok1 && ok2) ok1 = 1, Ans[++C] = -1;\n\tif (ok1) {\n\t\tLL tot1 = 0, tot2 = 0;\n\t\tfor (int i = 1; i <= C; ++i)\n\t\t\ttot1 += Ans[i] == -1 ? 1 : Ans[i],\n\t\t\ttot2 += Ans[i] == -1 ? 0 : Ans[i];\n\t\tif (tot2 > 200000) printf(\"BIG\\n%lld\\n\", tot2);\n\t\telse {\n\t\t\tprintf(\"SMALL\\n%lld\\n\", tot1);\n\t\t\tfor (int i = C; i >= 1; --i) {\n\t\t\t\tif (Ans[i] == -1) putchar('R');\n\t\t\t\telse {\n\t\t\t\t\tint x = Ans[i];\n\t\t\t\t\twhile (x) putchar('P'), --x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\texit(0);\n\t}\n}\n \nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &A[i]);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &B[i]);\n\tcheck();\n\tif (N == 1) {\n\t\tif (A[1] == B[1]) puts(\"SMALL\\n0\\n\");\n\t\telse puts(\"IMPOSSIBLE\");\n\t\treturn 0;\n\t}\n\tif (N == 2) {\n\t\tif (B[1] == B[2]) return puts(\"IMPOSSIBLE\"), 0;\n\t\twhile (1) {\n//\t\t\tprintf(\"(%lld, %lld)\\n\", B[1], B[2]);\n\t\t\tif (B[1] > B[2]) std::swap(B[1], B[2]), Ans[++C] = -1;\n\t\t\tif (A[1] == B[1]) {\n\t\t\t\tLL diff = B[2] - A[2];\n\t\t\t\tif (diff < 0 || diff % B[1] != 0) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\t\tAns[++C] = diff / B[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (A[2] == B[1]) {\n\t\t\t\tLL diff = B[2] - A[1];\n\t\t\t\tif (diff < 0 || diff % B[1] != 0) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\t\tAns[++C] = diff / B[1];\n\t\t\t\tAns[++C] = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (B[2] % B[1] == 0) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\tAns[++C] = B[2] / B[1];\n\t\t\tB[2] %= B[1];\n\t\t}\n\t\tLL tot1 = 0, tot2 = 0;\n\t\tfor (int i = 1; i <= C; ++i)\n\t\t\ttot1 += Ans[i] == -1 ? 1 : Ans[i],\n\t\t\ttot2 += Ans[i] == -1 ? 0 : Ans[i];\n\t\tif (tot2 > 200000) printf(\"BIG\\n%lld\\n\\n\", tot2);\n\t\telse {\n\t\t\tprintf(\"SMALL\\n%lld\\n\", tot1);\n\t\t\tfor (int i = C; i >= 1; --i) {\n\t\t\t\tif (Ans[i] == -1) putchar('R');\n\t\t\t\telse {\n\t\t\t\t\tint x = Ans[i];\n\t\t\t\t\twhile (x) putchar('P'), --x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (B[1] == B[N]) return puts(\"IMPOSSIBLE\"), 0;\n\t\tif (B[1] > B[N]) {\n\t\t\tstd::reverse(B + 1, B + N + 1), Ans[++C] = -1;\n\t\t} else {\n\t\t\tint ok = 1;\n\t\t\tfor (int i = 2; i <= N; ++i)\n\t\t\t\tif (B[i - 1] >= B[i]) ok = 0;\n\t\t\tif (!ok) return puts(\"IMPOSSIBLE\"), 0;\n\t\t\tfor (int i = N; i >= 2; --i)\n\t\t\t\tB[i] -= B[i - 1];\n\t\t\tAns[++C] = 1;\n\t\t}\n//\t\tprintf(\"\\t\\t\\t\"); for (int i = 1; i <= N; ++i) printf(\"%lld, \", B[i]); puts(\"\");\n\t\tcheck();\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "greedy", "implementation"], "dificulty": "2700", "interactive": false}