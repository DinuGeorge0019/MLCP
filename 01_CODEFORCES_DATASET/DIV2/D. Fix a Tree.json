{"link": "https://codeforces.com//contest/699/problem/D", "problemId": "65785", "problem_idx": "D", "shortId": "699D", "contest_number": "699", "problem_submissions": {"F": [19254979], "D": [19246128, 19238145, 19243994, 19244671, 19244055, 19240256, 19244440, 19243946, 19242445, 19244114, 19244888, 19248232, 19245369, 19243420, 19242965, 19246841, 19244016, 19246279, 19245771, 19248614], "C": [19238575, 19234685, 19237143, 19235854, 19236952, 19235501, 19237560, 19233107, 19236256, 19238050, 19237219, 19240071, 19233148, 19236181, 19237922, 19238682, 19238483, 19238795, 19237556, 19239587], "B": [19235764, 19233222, 19235273, 19233766, 19234773, 19233727, 19234737, 19236748, 19232804, 19234744, 19234328, 19236200, 19240174, 19238029, 19236795, 19234746, 19234487, 19234011, 19235700, 19235759], "A": [19233122, 19232168, 19232143, 19232104, 19232384, 19232378, 19232697, 19238171, 19232180, 19232809, 19232842, 19233530, 19236710, 19232307, 19233403, 19232204, 19232321, 19232485, 19232270, 19233389]}, "name": "D. Fix a Tree", "statement": "A tree is an undirected connected graph without cycles.Let\u2019s consider a\r\nrooted undirected tree with vertices, numbered through . There are many\r\nways to represent such a tree. One way is to create an array with\r\nintegers , where denotes a parent of vertex (here, for convenience a\r\nroot is considered its own parent). Given a sequence , one is able to\r\nrestore a tree: There must be exactly one index that . A vertex is a\r\nroot of the tree. For all other vertices , there is an edge between\r\nvertex and vertex . A sequence is called valid if the described\r\nprocedure generates some (any) rooted tree. For example, for sequences ,\r\nand valid.You are given a sequence , not necessarily valid. Your task is\r\nto change the minimum number of elements, in order to get a valid\r\nsequence. Print the minimum number of changes and an example of a valid\r\nsequence after that number of changes. If there are many valid sequences\r\nachievable in the minimum number of changes, print any of them.\r\n", "solutions": ["#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#define bll long long\n#define dou double\n#define For(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define Rof(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define rep(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define rek(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define Cpy(a,b) memcpy(a,b,sizeof(b))\n//__builtin_popcountll\n\nconst int maxn=200000+100;\nint root,o[maxn],N,Ans,p[maxn],ls[maxn];\nvector <int> E[maxn];\nbool vis[maxn];\n\nvoid bfs(int x)\n{\n    int h=0,t=0;\n    int s=x;\n    o[h]=x; vis[x]=1; ls[x]=0;\n    bool flag=0;\n    bool circle=0;\n    for (; h<=t; h++)\n    {\n        x=o[h];\n        if (x==root) flag=1;\n//printf(\"! %d\\n\",x);\n        For(i,0,E[x].size()-1)\n        {\n            int y=E[x][i];\n            if (vis[y] && y!=ls[x] && !circle)\n            {\n//printf(\"%d %d %d %d\\n\",x,y,ls[x],o[h+1]);\n                circle=1;\n                if (root==-1) root=x;\n//printf(\"- - %d %d\\n\",x,y);\n                p[x]=root;\n                Ans++;\n                flag=1;\n            }\n            if (vis[y]) continue;\n            o[++t]=y;\n            vis[y]=1;\n            ls[y]=x;\n        }\n    }\n    if (flag==0) Ans++,p[s]=root;\n}\n\nint main(int argc, char* argv[])\n{\n    for (; scanf(\"%d\",&N)!=EOF; )\n    {\n        For(i,1,N) E[i].clear();\n        For(i,1,N)\n        {\n            scanf(\"%d\",&p[i]);\n            if (i==p[i]) continue;\n            E[i].push_back(p[i]);\n            E[p[i]].push_back(i);\n        }\n        root=-1;\n        Ans=0;\n        For(i,1,N)\n            if (p[i]==i) { root=i; break; }\n//printf(\"%d\\n\",root);\n        For(i,1,N) vis[i]=0;\n        For(i,1,N)\n            if (!vis[i] && p[i]==i) bfs(i);\n        For(i,1,N)\n            if (!vis[i]) bfs(i);\n        printf(\"%d\\n\",Ans);\n        For(i,1,N) printf(\"%d \",p[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "dsu", "graphs", "trees"], "dificulty": "1700", "interactive": false}