{
    "link": "https://codeforces.com//contest/699/problem/D",
    "problemId": "65785",
    "problem_idx": "D",
    "shortId": "699D",
    "contest_number": "699",
    "problem_submissions": {
        "F": [
            19254979
        ],
        "D": [
            19246128,
            19238145,
            19243994,
            19244671,
            19244055,
            19240256,
            19244440,
            19243946,
            19242445,
            19244114,
            19244888,
            19248232,
            19245369,
            19243420,
            19242965,
            19246841,
            19244016,
            19246279,
            19245771,
            19248614
        ],
        "C": [
            19238575,
            19234685,
            19237143,
            19235854,
            19236952,
            19235501,
            19237560,
            19233107,
            19236256,
            19238050,
            19237219,
            19240071,
            19233148,
            19236181,
            19237922,
            19238682,
            19238483,
            19238795,
            19237556,
            19239587
        ],
        "B": [
            19235764,
            19233222,
            19235273,
            19233766,
            19234773,
            19233727,
            19234737,
            19236748,
            19232804,
            19234744,
            19234328,
            19236200,
            19240174,
            19238029,
            19236795,
            19234746,
            19234487,
            19234011,
            19235700,
            19235759
        ],
        "A": [
            19233122,
            19232168,
            19232143,
            19232104,
            19232384,
            19232378,
            19232697,
            19238171,
            19232180,
            19232809,
            19232842,
            19233530,
            19236710,
            19232307,
            19233403,
            19232204,
            19232321,
            19232485,
            19232270,
            19233389
        ]
    },
    "name": "D. Fix a Tree",
    "statement": "A tree is an undirected connected graph without cycles.Let\u2019s consider a\r\nrooted undirected tree with vertices, numbered through . There are many\r\nways to represent such a tree. One way is to create an array with\r\nintegers , where denotes a parent of vertex (here, for convenience a\r\nroot is considered its own parent). Given a sequence , one is able to\r\nrestore a tree: There must be exactly one index that . A vertex is a\r\nroot of the tree. For all other vertices , there is an edge between\r\nvertex and vertex . A sequence is called valid if the described\r\nprocedure generates some (any) rooted tree. For example, for sequences ,\r\nand valid.You are given a sequence , not necessarily valid. Your task is\r\nto change the minimum number of elements, in order to get a valid\r\nsequence. Print the minimum number of changes and an example of a valid\r\nsequence after that number of changes. If there are many valid sequences\r\nachievable in the minimum number of changes, print any of them.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#define bll long long\n#define dou double\n#define For(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define Rof(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define rep(i,a,b) for (int i=(a),_##i=(b); i<=_##i; i++)\n#define rek(i,a,b) for (int i=(a),_##i=(b); i>=_##i; i--)\n#define Mem(a,b) memset(a,b,sizeof(a))\n#define Cpy(a,b) memcpy(a,b,sizeof(b))\n//__builtin_popcountll\n\nconst int maxn=200000+100;\nint root,o[maxn],N,Ans,p[maxn],ls[maxn];\nvector <int> E[maxn];\nbool vis[maxn];\n\nvoid bfs(int x)\n{\n    int h=0,t=0;\n    int s=x;\n    o[h]=x; vis[x]=1; ls[x]=0;\n    bool flag=0;\n    bool circle=0;\n    for (; h<=t; h++)\n    {\n        x=o[h];\n        if (x==root) flag=1;\n//printf(\"! %d\\n\",x);\n        For(i,0,E[x].size()-1)\n        {\n            int y=E[x][i];\n            if (vis[y] && y!=ls[x] && !circle)\n            {\n//printf(\"%d %d %d %d\\n\",x,y,ls[x],o[h+1]);\n                circle=1;\n                if (root==-1) root=x;\n//printf(\"- - %d %d\\n\",x,y);\n                p[x]=root;\n                Ans++;\n                flag=1;\n            }\n            if (vis[y]) continue;\n            o[++t]=y;\n            vis[y]=1;\n            ls[y]=x;\n        }\n    }\n    if (flag==0) Ans++,p[s]=root;\n}\n\nint main(int argc, char* argv[])\n{\n    for (; scanf(\"%d\",&N)!=EOF; )\n    {\n        For(i,1,N) E[i].clear();\n        For(i,1,N)\n        {\n            scanf(\"%d\",&p[i]);\n            if (i==p[i]) continue;\n            E[i].push_back(p[i]);\n            E[p[i]].push_back(i);\n        }\n        root=-1;\n        Ans=0;\n        For(i,1,N)\n            if (p[i]==i) { root=i; break; }\n//printf(\"%d\\n\",root);\n        For(i,1,N) vis[i]=0;\n        For(i,1,N)\n            if (!vis[i] && p[i]==i) bfs(i);\n        For(i,1,N)\n            if (!vis[i]) bfs(i);\n        printf(\"%d\\n\",Ans);\n        For(i,1,N) printf(\"%d \",p[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Fix a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/46148",
    "editorial": "One can easily see that given sequence describes a functional graph,\r\nthus a directed graph with edges going from to for every . This graph\r\nrepresents a set of cycles and each cycle vertex is a root of its own\r\ntree (possibly consisting of one vertex). Picture above shows an example\r\nof a functional graph. It consists of two cycles and . Vertex is the\r\nroot of the tree consisting of vertices , , and , vertex roots the tree\r\nof vertices and , vertex root of tree of vertices and and vertex forms a\r\ntree of only one vertex.In terms of functional graph, our goal is to\r\nmake the graph consisting of exactly one cycle of exactly one vertex\r\nlooped to itself.Operation of change is equivalent to removing some\r\noutgoing edge and adding a new one, going to somewhat else vertex. Let\u00e2\u0080\u0099s\r\nfirstly make our graph containing only one cycle. To do so, one can\r\nchoose any of initially presented cycles and say that it will be the\r\nonly one. Then one should consider every other cycle, remove any of its\r\nin-cycle edges and replace it with an edge going to any of the chosen\r\ncycle\u00e2\u0080\u0099s vertices. Thus the cycle will be broken and its vertices (along\r\nwith tree ones) will be connected to the only chosen cycle. One will\r\nneed to do exactly such operations. Note that the removing of any\r\nnon-cycle edge does not make sense, because it does not break any\r\ncycle.The next thing is to make the cycle length be equal to . That\r\nmight be already satisfied, if one will choose a cycle of minimal length\r\nand this length equals . Thus, if the initial graph contains any cycle\r\nof length , we are done with operations. Otherwise, the cycle contains\r\nmore than one vertex. It can be fixed with exactly one operation one\r\njust need to break any of in-cycle edges, say from to , and add an edge\r\nfrom to . The graph will remain consisting of one cycle, but consisting\r\nof one self-looped vertex. In that case, we are done with operations.To\r\ndo all the operations above, one can use DSU structure, or just a series\r\nof DFS. Note that there is no need in realisation of edge removing and\r\ncreating, one just needs to analyze initial graph.\r\n"
}