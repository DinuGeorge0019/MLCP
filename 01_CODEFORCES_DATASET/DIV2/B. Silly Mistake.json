{"link": "https://codeforces.com//contest/1253/problem/B", "problemId": "472859", "problem_idx": "B", "shortId": "1253B", "contest_number": "1253", "problem_submissions": {"F": [65199103, 65190951, 65202217, 65200176, 65205791, 65198288, 65206369, 65202224, 65204185, 65198880, 71343526, 65209779, 69242445], "E": [65190374, 65200198, 65189404, 65179572, 65189474, 65203687, 65210511, 65176917, 65203722, 65186844, 65188534, 65195069, 65199233, 65190702, 65194167, 65189184, 65189079, 65566785, 65194999, 65197237], "D": [65185415, 65178485, 65180601, 65183049, 65178022, 65187686, 65195445, 65178632, 65179619, 65180170, 65183967, 65181658, 65188561, 65181701, 65182069, 65187758, 65183529, 65182372, 65181324], "C": [65180957, 65172664, 65176866, 65185425, 65173509, 65180180, 65194567, 65173458, 65200178, 65176131, 65179441, 65175878, 65184305, 65178007, 65179468, 65178975, 65179727, 65177898, 65176250], "B": [65175476, 65202574, 65174599, 65188764, 65185456, 65176094, 65186553, 65183630, 65196117, 65172495, 65173857, 65173178, 65174792, 65174898, 65174679, 65176409, 65176161, 65176165, 65172853], "A": [65171088, 65170116, 65170656, 65190482, 65180567, 65170231, 65180099, 65170284, 65170843, 65169770, 65169894, 65169914, 65170943, 65169881, 65172675, 65172008, 65171211, 65169945, 65169720]}, "name": "B. Silly Mistake", "statement": "The Central Company has an office with a sophisticated security system.\r\nThere are 10^6 employees, numbered from 1 to 10^6.The security system\r\nlogs entrances and departures. The entrance of the i-th employee is\r\ndenoted by the integer i, while the departure of the i-th employee is\r\ndenoted by the integer -i.The company has some strict rules about access\r\nto its office: An employee can enter the office once per day. He\r\nobviously can\u2019t leave the office if he didn\u2019t enter it earlier that day.\r\nIn the beginning and at the end of every day, the office is empty\r\n(employees can\u2019t stay at night). Any array of events satisfying these\r\nconditions is called a .Some examples of valid or invalid days: [1, 7,\r\n-7, 3, -1, -3] is a valid day (1 enters, 7 enters, 7 leaves, 3 enters, 1\r\nleaves, 3 leaves). [2, -2, 3, -3] is also a valid day. [2, 5, -5, 5, -5,\r\n-2] is a valid day, because 5 entered the office twice during the same\r\nday. [-4, 4] is a valid day, because 4 left the office without being in\r\nit. [4] is a valid day, because 4 entered the office and didn\u2019t leave it\r\nbefore the end of the day. There are n events a_1, a_2,\r\nldots, a_n, in the order they occurred. This array corresponds to one or\r\nmore consecutive days. The system administrator erased the dates of\r\nevents by mistake, but he didn\u2019t change the order of the events.You must\r\npartition (to cut) the array a of events into , which must represent\r\nnon-empty valid days (or say that it\u2019s impossible). Each array element\r\nshould belong to exactly one contiguous subarray of a partition. Each\r\ncontiguous subarray of a partition should be a .For example, if n=8 and\r\na=[1, -1, 1, 2, -1, -2, 3, -3] then he can partition it into two\r\ncontiguous subarrays which are valid days: a = [1, -1\u00a0\r\nboldsymbol{|}\u00a0 1, 2, -1, -2, 3, -3].Help the administrator to partition\r\nthe given array a in the required way or report that it is impossible to\r\ndo. Find any required partition, you should not minimize or maximize the\r\nnumber of parts.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nint n,tc;\nint A[100005], B[100005];\nint E[1000005], O[1000005];\nset < int > S;\n\nint main(){\n\n\tbool cannot = false;\n\tint event = 0;\n\tvector < int > days;\n\tscanf(\"%d\",&n);\n\tfor ( int i = 0; i < n; i++ ){\n\t\tscanf(\"%d\",&A[i]);\n\t}\n\n\tfor ( int i = 0; i < n; i++ ){\n\t\tif ( A[i] < 0 ){\n\t\t\tif ( !E[-A[i]] || S.find(A[i]) != S.end()){\n\t\t\t\tcannot = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tE[-A[i]] = false;\n\t\t\tS.insert(-A[i]);\n\t\t\tevent--;\n\t\t\tif ( event == 0 ){\n\t\t\t\tdays.push_back(S.size() * 2);\n\t\t\t\tS.clear();\n\t\t\t}\n\t\t} else {\n\t\t\tif ( E[A[i]] || S.find(A[i]) != S.end() ){\n\t\t\t\tcannot = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tE[A[i]] = true;\n\t\t\tevent++;\n\t\t}\n\t}\n\tif ( event != 0 || S.size() > 0 ) cannot = true;\n\tif ( cannot ) printf(\"-1\\n\");\n\telse {\n\t\tprintf(\"%d\\n\",days.size());\n\t\tfor ( int i = 0; i < days.size(); i++ ){\n\t\t\tif ( i ) printf(\" \");\n\t\t\tprintf(\"%d\",days[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["greedy", "implementation"], "dificulty": "1400", "interactive": false}