{
    "link": "https://codeforces.com//contest/706/problem/E",
    "problemId": "67827",
    "problem_idx": "E",
    "shortId": "706E",
    "contest_number": "706",
    "problem_submissions": {
        "E": [
            19799529,
            19800838,
            19810264,
            19807034,
            19808760,
            19810186,
            19809764,
            19810982,
            42752321,
            19890390
        ],
        "D": [
            19795131,
            19799946,
            19797593,
            19799580,
            19801146,
            19799501,
            19800720,
            19806755,
            19799727,
            19799523,
            19798394,
            19805457,
            19796720,
            19793832,
            19796068,
            19798051,
            19789927,
            19797413,
            19794752
        ],
        "A": [
            19791014,
            19788257,
            19788261,
            19788398,
            19788631,
            19795699,
            19789638,
            19788479,
            19790007,
            19788321,
            22026404,
            19788020,
            19788193,
            19794916,
            19789488,
            19788710,
            19789070,
            19787924,
            19796256,
            19788143,
            19787877
        ],
        "B": [
            19790153,
            19790384,
            19790346,
            19790838,
            19791017,
            19794646,
            19792418,
            19790625,
            19790161,
            19819586,
            19789302,
            19789044,
            19789558,
            19793530,
            19791526,
            19790679,
            19790349,
            19789192,
            19797239,
            19789505,
            19788555
        ],
        "C": [
            19789161,
            19797823,
            19794469,
            19797199,
            19794627,
            19792093,
            19795449,
            19794172,
            19793513,
            19795984,
            19792686,
            19793115,
            19791330,
            19794797,
            19799019,
            19794092,
            19793736,
            19795359,
            19793400,
            19794380
        ]
    },
    "name": "E. Working routine",
    "statement": "Vasiliy finally got to work, where there is a huge amount of tasks\r\nwaiting for him. Vasiliy is given a matrix consisting of rows and\r\ncolumns and tasks. Each task is to swap two submatrices of the given\r\nmatrix.For each task Vasiliy knows six integers , , , , , , where is the\r\nindex of the row where the top-left corner of the first rectangle is\r\nlocated, is the index of its column, is the index of the row of the\r\ntop-left corner of the second rectangle, is the index of its column, is\r\nthe height of the rectangle and is its width.Itâ€™s guaranteed that two\r\nrectangles in one query do not overlap and do not touch, that is, no\r\ncell belongs to both rectangles, and no two cells belonging to different\r\nrectangles . However, rectangles are allowed to share an angle.Vasiliy\r\nwants to know how the matrix will look like after all tasks are\r\nperformed.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << \"=\" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int , int> pi;\ntypedef pair< int , pi> pii;\n\nconst int INF = ~0U >> 1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n\tint ret = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % Mod)\n\t\tif (x & 1) ret = 1ll * ret * a % Mod;\n\treturn ret;\n}\n\nconst int N = 1000 + 10, M = 1100000;\nint id[N][N], l[M], r[M], u[M], d[M], val[M];\nint l1[N], l2[N], r1[N], r2[N], u1[N], u2[N], d1[N], d2[N];\nint n, m, q, tot, a, b, c, e, h, w;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &q);\n\trep(i, 0, n + 2) rep(j, 0, m + 2) id[i][j] = tot++;\n\trep(i, 0, n + 2) rep(j, 0, m + 1)\n\t\tr[id[i][j]] = id[i][j + 1],\n\t\tl[id[i][j + 1]] = id[i][j];\n\trep(i, 0, n + 1) rep(j, 0, m + 2)\n\t\td[id[i][j]] = id[i + 1][j],\n\t\tu[id[i + 1][j]] = id[i][j];\n\trep(i, 1, n + 1) rep(j, 1, m + 1) scanf(\"%d\", val + id[i][j]);\n\trep(i, 0, q) {\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &e);\n\t\tint x = id[0][0], y = id[0][0];\n\t\trep(j, 0, a) x = d[x];\n\t\trep(j, 0, b) x = r[x];\n\t\trep(j, 0, c) y = d[y];\n\t\trep(j, 0, e) y = r[y];\n\t\tscanf(\"%d%d\", &h, &w);\n\t\tint z = x, v = y;\n\t\trep(j, 0, h) {\n\t\t\tl1[j] = z; l2[j] = v;\n\t\t\tz = d[z]; v = d[v];\n\t\t}\n\t\tz = u[z]; v = u[v];\n\t\trep(j, 0, w) {\n\t\t\td1[j] = z; d2[j] = v;\n\t\t\tz = r[z]; v = r[v];\n\t\t}\n\t\tz = x, v = y;\n\t\trep(j, 0, w) {\n\t\t\tu1[j] = z; u2[j] = v;\n\t\t\tz = r[z]; v = r[v];\n\t\t}\n\t\tz = l[z]; v = l[v];\n\t\trep(j, 0, h) {\n\t\t\tr1[j] = z; r2[j] = v;\n\t\t\tz = d[z]; v = d[v];\n\t\t}\n\t\trep(j, 0, h) {\n\t\t\tswap(r[l[l1[j]]], r[l[l2[j]]]);\n\t\t\tswap(l[l1[j]], l[l2[j]]);\n\t\t\tswap(l[r[r1[j]]], l[r[r2[j]]]);\n\t\t\tswap(r[r1[j]], r[r2[j]]);\n\t\t}\n\t\trep(j, 0, w) {\n\t\t\tswap(d[u[u1[j]]], d[u[u2[j]]]);\n\t\t\tswap(u[u1[j]], u[u2[j]]);\n\t\t\tswap(u[d[d1[j]]], u[d[d2[j]]]);\n\t\t\tswap(d[d1[j]], d[d2[j]]);\n\t\t}\n\t}\n\tint u = id[0][0];\n\trep(i, 1, n + 1) {\n\t\tu = d[u];\n\t\tint v = u;\n\t\trep(j, 1, m + 1) {\n\t\t\tv = r[v];\n\t\t\tprintf(\"%d \", val[v]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\E. Working routine.json",
    "editorial_link": "https://codeforces.com//blog/entry/46510",
    "editorial": "Let's surround the matrix with the frame of elements. In each element of the matrix, and frame we need to store value, the number of the right element and the number of down element. When a request comes we should change only values of the elements along the perimeter of rectangles.\n",
    "hint": []
}