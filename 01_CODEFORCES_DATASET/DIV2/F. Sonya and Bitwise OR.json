{"link": "https://codeforces.com//contest/1004/problem/F", "problemId": "195382", "problem_idx": "F", "shortId": "1004F", "contest_number": "1004", "problem_submissions": {"D": [40003970, 40002114, 40006190, 40065552, 40018246, 40318920, 39996575, 39998916, 39999974, 40000249, 40000299], "E": [40002484, 40005119, 40002116, 39999883, 39999448, 40001703, 40001918, 40001172, 40000650, 40002637, 40008283, 40003263, 40002856, 40003509, 40018331, 40018260, 40018197, 40017976, 40019825], "F": [40001175, 40176983, 40353564, 40007502, 40003848], "C": [39997306, 39993584, 39996423, 39991994, 39992348, 39992627, 39992610, 39994247, 39996536, 39995648, 39993270, 39993344, 39994504, 39995916, 39993496, 39993165, 39993772, 39993747, 39997604], "B": [39994165, 39991785, 39998844, 39994058, 39994368, 39991334, 39991006, 39993012, 39992174, 39992714, 39991428, 39991267, 39992520, 39993434, 39991814, 39991327, 39991886, 39991449, 39996736], "A": [39992007, 39990327, 39997320, 39990328, 39990314, 39990627, 39990358, 39990498, 39990516, 39991224, 39990460, 39990569, 39990938, 39991677, 39990538, 39990378, 39990592, 39990535, 39995891]}, "name": "F. Sonya and Bitwise OR", "statement": "Sonya has an array a_1, a_2,\r\nldots, a_n consisting of n integers and also one non-negative integer x.\r\nShe has to perform m queries of two types: 1 i y: replace i-th element\r\nby value y, i.e. to perform an operation a_{i} y; 2 l r: find the number\r\nof pairs (L, R) that l\r\nleq L\r\nleq R\r\nleq r and bitwise OR of all integers in the range [L, R] is at least x\r\n(note that x is a constant for all queries). Can you help Sonya perform\r\nall her queries?Bitwise OR is a binary operation on a pair of\r\nnon-negative integers. To calculate the bitwise OR of two numbers, you\r\nneed to write both numbers in binary notation. The result is a number,\r\nin binary, which contains a one in each digit if there is a one in the\r\nbinary notation of at least one of the two numbers. For example, 10 19 =\r\n1010_2 10011_2 = 11011_2 = 27.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PA;\ntypedef long long LL;\n\n#define MAXN 100001\n#define MAXL 21\n#define FST first\n#define SCD second\n\nint n, m, x;\nstruct Segment {\n\tint cL, cR;\n\tPA vL[MAXL], vR[MAXL];\n\tLL sum;\n} seg[MAXN << 1 | 1];\n\nvoid seg_up(Segment &rt, Segment &lft, Segment &rht) {\n\trt.cL = lft.cL;\n\tmemcpy(rt.vL, lft.vL, rt.cL * sizeof(PA));\n\tfor(int i = 0; i < rht.cL; ++i) {\n\t\tPA pre = rt.vL[rt.cL - 1];\n\t\tPA cur = rht.vL[i];\n\t\tcur.FST |= pre.FST;\n\t\tif(pre.FST < cur.FST)\n\t\t\trt.vL[rt.cL++] = cur;\n\t}\n\trt.cR = rht.cR;\n\tmemcpy(rt.vR, rht.vR, rt.cR * sizeof(PA));\n\tfor(int i = 0; i < lft.cR; ++i) {\n\t\tPA pre = rt.vR[rt.cR - 1];\n\t\tPA cur = lft.vR[i];\n\t\tcur.FST |= pre.FST;\n\t\tif(pre.FST < cur.FST)\n\t\t\trt.vR[rt.cR++] = cur;\n\t}\n\trt.sum = lft.sum + rht.sum;\n\tfor(int i = lft.cR - 1, j = 0; i >= 0; --i) {\n\t\tfor( ; j < rht.cL && (lft.vR[i].FST | rht.vL[j].FST) < x; ++j);\n\t\tif(j < rht.cL)\n\t\t\trt.sum += (lft.vR[i].SCD - (i + 1 < lft.cR ? lft.vR[i + 1].SCD : lft.vL[0].SCD - 1)) * (rht.vR[0].SCD - rht.vL[j].SCD + 1LL);\n\t}\n}\n\ninline int seg_idx(int L, int R) {\n\treturn (L + R) | (L < R);\n}\n\nvoid seg_build(int L, int R) {\n\tSegment &rt = seg[seg_idx(L, R)];\n\tif(L == R) {\n\t\tint val; \n\t\tscanf(\"%d\", &val);\n\t\trt.cL = rt.cR = 1;\n\t\trt.vL[0] = rt.vR[0] = (PA){val, L};\n\t\trt.sum = val >= x;\n\t} else {\n\t\tint M = (L + R) >> 1;\n\t\tseg_build(L, M);\n\t\tseg_build(M + 1, R);\n\t\tseg_up(rt, seg[seg_idx(L, M)], seg[seg_idx(M + 1, R)]);\n\t}\n}\n\nvoid seg_upd(int L, int R, int u, int v) {\n\tSegment &rt = seg[seg_idx(L, R)];\n\tif(L == R) {\n\t\trt.cL = rt.cR = 1;\n\t\trt.vL[0] = rt.vR[0] = (PA){v, L};\n\t\trt.sum = v >= x;\n\t} else {\n\t\tint M = (L + R) >> 1;\n\t\tif(u <= M)\n\t\t\tseg_upd(L, M, u, v);\n\t\telse\n\t\t\tseg_upd(M + 1, R, u, v);\n\t\tseg_up(rt, seg[seg_idx(L, M)], seg[seg_idx(M + 1, R)]);\n\t}\n}\n\nSegment seg_que(int L, int R, int u, int v) {\n\tSegment ret = {};\n\tif(u <= L && R <= v) {\n\t\tret = seg[seg_idx(L, R)];\n\t} else {\n\t\tint M = (L + R) >> 1;\n\t\tif(v <= M) {\n\t\t\tret = seg_que(L, M, u, v);\n\t\t} else if(u > M) {\n\t\t\tret = seg_que(M + 1, R, u, v);\n\t\t} else {\n\t\t\tSegment lft = seg_que(L, M, u, v);\n\t\t\tSegment rht = seg_que(M + 1, R, u, v);\n\t\t\tseg_up(ret, lft, rht);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t#endif\n\tscanf(\"%d%d%d\", &n, &m, &x);\n\tseg_build(1, n);\n\twhile(m--) {\n\t\tint typ, x, y;\n\t\tscanf(\"%d%d%d\", &typ, &x, &y);\n\t\tif(typ == 1) {\n\t\t\tseg_upd(1, n, x, y);\n\t\t} else {\n\t\t\tSegment res = seg_que(1, n, x, y);\n\t\t\tprintf(\"%lld\\n\", res.sum);\n\t\t}\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "data structures", "divide and conquer"], "dificulty": "2600", "interactive": false}