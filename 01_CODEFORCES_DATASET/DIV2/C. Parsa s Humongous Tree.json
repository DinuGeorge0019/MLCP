{
    "link": "https://codeforces.com//contest/1529/problem/C",
    "problemId": "994170",
    "problem_idx": "C",
    "shortId": "1529C",
    "contest_number": "1529",
    "problem_submissions": {
        "E": [
            117241256,
            117224077,
            117234541,
            117233577,
            117569320,
            117237517,
            117242490,
            117246187,
            117240165,
            117245259,
            117241507,
            117250798,
            117245729,
            117250742,
            117250857,
            117218644
        ],
        "D": [
            117230306,
            117212621,
            117202664,
            117207279,
            117225346,
            117220644,
            117216468,
            117216196,
            117213173,
            117222042,
            117220584,
            117225498,
            117227881,
            117216922,
            117220354,
            117229060,
            117222399,
            117222507,
            117238884
        ],
        "C": [
            117214605,
            117199641,
            117194393,
            117203572,
            117194679,
            117202937,
            117207535,
            117193168,
            117200629,
            117205705,
            117207405,
            117200109,
            117211977,
            117207102,
            117207383,
            117205160,
            117202511,
            117210501,
            117233461
        ],
        "B": [
            117211463,
            117191644,
            117208208,
            117195752,
            117203773,
            117196989,
            117200392,
            117204712,
            117192618,
            117194128,
            117187965,
            117194040,
            117204576,
            117200157,
            117198432,
            117201536,
            117194899,
            117196661,
            117225707
        ],
        "A": [
            117204278,
            117182610,
            117191375,
            117182552,
            117181735,
            117183060,
            117186706,
            117181614,
            117182779,
            117184006,
            117181468,
            117181785,
            117189122,
            117193871,
            117183062,
            117182596,
            117181449,
            117183504,
            117220486
        ],
        "F": [
            117202382,
            117258211,
            117241820,
            117455126,
            117572881,
            117239369,
            117247608,
            117266116,
            117251683,
            117256888,
            117254087
        ]
    },
    "name": "C. Parsa s Humongous Tree",
    "statement": "Parsa has a humongous tree on n vertices.On each vertex v he has written\r\ntwo integers l_v and r_v.To make Parsa\u2019s tree look even more majestic,\r\nNima wants to assign a number a_v (l_v\r\nle a_v\r\nle r_v) to each vertex v such that the beauty of Parsa\u2019s tree is\r\nmaximized.Nima\u2019s sense of the beauty is rather bizarre. He defines the\r\nbeauty of the tree as the sum of |a_u - a_v| over all edges (u, v) of\r\nthe tree.Since Parsa\u2019s tree is too large, Nima can\u2019t maximize its beauty\r\non his own. Your task is to find the possible beauty for Parsa\u2019s tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100005;\n\nint n;\nint a[maxn][2];\nvector<int> g[maxn];\nlong long f[maxn][2];\n\nvoid dfs_solve(int v, int p) {\n    for(int s : g[v]) if (s != p) {\n        dfs_solve(s, v);\n        f[v][0] += max(f[s][0] + abs(a[s][0] - a[v][0]), f[s][1] + abs(a[s][1] - a[v][0]));\n        f[v][1] += max(f[s][0] + abs(a[s][0] - a[v][1]), f[s][1] + abs(a[s][1] - a[v][1]));\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n    int ntest; cin >> ntest;\n    while(ntest--) {\n        cin >> n;\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i][0] >> a[i][1];\n        }\n\n        for(int i = 0; i + 1 < n; ++i) {\n            int u, v; cin >> u >> v;\n            --u; --v;\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n            \n        dfs_solve(0, -1);\n        cout << max(f[0][0], f[0][1]) << endl;\n\n        for(int i = 0; i < n; ++i) {\n            g[i].clear();\n            f[i][0] = f[i][1] = 0;\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Parsa s Humongous Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "The solution is based on the fact that an optimal assignment for a\n exists such that for each vertex v\n, av?lv,rv\n.\n\nProving this fact isn't hard, pick any assignment for a\n. Assume v\n is a vertex in this assignment such that av?lv,rv\n.\n\nLet p\n be the number of vertices u\n adjacent to v\n such that au>av\n.\n\nLet q\n be the number of vertices u\n adjacent to v\n such that au<av\n.\n\nConsider the following cases:\n\np>q\n: In this case we can decrease av\n to lv\n and get a better result.\np<q\n: In this case we can increase av\n to rv\n and get a better result.\np=q\n: In this case changing av\n to lv\n or rv\n will either increase or not change the beauty of the tree.\nBased on this fact, we can use dynamic programming to find the answer.\n\nDefine dpv,0\n as the maximum beauty of v\n's subtree if av\n is equal to lv\n.\n\nSimilarly, define dpv,1\n as the maximum beauty of v\n's subtree if av\n is equal to rv\n.\n\ndpv,j\n is calculated based on v\n's children, for each of v\n's children such as u\n, we add u\n's contribution to dpv,j\n.\n\nThe transitions are:\n\ndpv,0+=max(dpu,0+|lv?lu|,dpu,1+|lv?ru|)\ndpv,1+=max(dpu,0+|rv?lu|,dpu,1+|rv?ru|)\nIt's clear that the answer is equal to max(dpv,0,dpv,1)\n.\n\ncomplexity: O(n)"
}