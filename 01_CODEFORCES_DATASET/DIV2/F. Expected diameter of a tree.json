{
    "link": "https://codeforces.com//contest/805/problem/F",
    "problemId": "105171",
    "problem_idx": "F",
    "shortId": "805F",
    "contest_number": "805",
    "problem_submissions": {
        "E": [
            26857780,
            26856750,
            26858111,
            26857063,
            26859139,
            26856888,
            26859899,
            26860928,
            26861436,
            26860967,
            26859459,
            26858902,
            26861950,
            26859019,
            26862819,
            26861493
        ],
        "D": [
            26844331,
            26843852,
            26846709,
            26847271,
            26843712,
            26849970,
            26845256,
            26850183,
            26849852,
            26846814,
            26846907,
            26847537,
            26851958,
            26850830,
            26850561,
            26852120,
            26848761,
            26850340,
            26852553,
            26854400
        ],
        "C": [
            26841586,
            26841442,
            26843378,
            26841793,
            26849729,
            26843226,
            26842851,
            26847163,
            26844593,
            26844046,
            26842105,
            26844673,
            26843379,
            26843951,
            26848871,
            26841493,
            26842855,
            26845699,
            26846895,
            26847872
        ],
        "B": [
            26839792,
            26840934,
            26840059,
            26841075,
            26840279,
            26839383,
            26840491,
            26847999,
            26841324,
            26839809,
            26839811,
            26839925,
            26840626,
            26839840,
            26840234,
            26839411,
            26840270,
            26846558,
            26843910,
            26843501
        ],
        "A": [
            26837425,
            26838400,
            26837402,
            26838568,
            26837965,
            26837187,
            26849788,
            26839799,
            26839327,
            26837458,
            26837278,
            26846404,
            26837755,
            26840946,
            26838306,
            26837294,
            26837665,
            26859742,
            26839927,
            26841184
        ],
        "F": [
            26862002,
            26862152,
            27206248,
            35743638,
            26862813,
            26870973,
            26870602
        ]
    },
    "name": "F. Expected diameter of a tree",
    "statement": "Pasha is a good student and one of MoJaK’s best friends. He always have\r\na problem to think about. Today they had a talk about the following\r\nproblem.We have a forest (acyclic undirected graph) with vertices and\r\nedges. There are queries we should answer. In each query two vertices\r\nand are given. Let be the set of vertices in the connected component of\r\nthe graph that contains , and be the set of vertices in the connected\r\ncomponent of the graph that contains . Let’s add an edge between some\r\nvertex and some vertex in and compute the value of the resulting\r\ncomponent. If the resulting component is a tree, the value is the of the\r\ncomponent, and it is equal to otherwise. What is the expected value of ,\r\nif we choose vertices and from the sets uniformly at random?Can you help\r\nPasha to solve this problem?The of the component is the maximum among\r\nsome pair of vertices in the component. The between two vertices is the\r\nminimum number of edges on some path between the two vertices.Note that\r\nqueries don’t add edges to the initial forest.\r\n",
    "solutions": [
        "#include <vector>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <iomanip>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 100020;\ntypedef long long LL;\n\nint par[N], sz[N];\nvector<int> g[N];\n\nint n, m, q;\n\nint find(int x) {\n    if(par[x] != x) par[x] = find(par[x]);\n    return par[x];\n}\nint dp[N][3], G[N], mx[N];\nvector<int> d[N];\nvector<LL> sum[N];\nbool cmake_pair(int i, int j) {\n    return i > j;\n}\nvoid dfs_main(int u, int p) {\n    for(auto v: g[u]) {\n        if(v == p) continue;\n        dfs_main(v, u);\n        dp[u][2] = dp[v][0] + 1;\n        sort(dp[u], dp[u] + 3, cmake_pair);\n    }\n}\nvoid dfs_slave(int u, int p) {\n    for(auto v: g[u]) {\n        if(v == p) continue;\n        int t;\n        if(dp[u][0] == dp[v][0] + 1) t = dp[u][1];\n        else t = dp[u][0];\n        G[v] = max(G[u] + 1, t + 1);\n        dfs_slave(v, u);\n    }\n}\nvoid solve(){\n    for(int i = 1; i <= n; ++i) {\n        if(par[i] == i) {\n            dfs_main(i, 0);\n        }\n    }\n    for(int i = 1; i <= n; ++i) {\n        if(par[i] == i) dfs_slave(i, 0);\n    }\n    for(int i = 1; i <= n; ++i) {\n        d[i].push_back(0);\n        sum[i].push_back(0);\n    }\n    for(int i = 1; i <= n; ++i) {\n        int x = find(i);\n        mx[x] = max(mx[x], max(dp[i][0], G[i]));\n        int t = max(dp[i][0], G[i]);\n        d[x].push_back(t);\n        sum[x].push_back(0);\n    }\n    for(int i = 1; i <= n; ++i) {\n        sort(d[i].begin(), d[i].end());\n        if(par[i] == i) {\n            for(int j = 1; j < sum[i].size(); ++j) {\n                sum[i][j] = sum[i][j - 1] + d[i][j];\n            }\n        }\n        \n    }\n    map<pair<int,int> , double> ans;\n    \n    while(q--) {\n        int xx, yy;\n        cin >> xx >> yy;\n        xx = find(xx), yy = find(yy);\n        if(xx == yy) {\n            puts(\"-1\");\n            continue;\n        }\n        if(sz[xx] > sz[yy]) swap(xx, yy);\n        if(ans.count(make_pair(xx, yy))) {\n            printf(\"%.10lf\\n\", ans[make_pair(xx, yy)]);\n            continue;\n        }\n        LL res = 0;\n        int k = max(mx[xx], mx[yy]);\n        bool fst = 1;\n        for(auto v: d[xx]) {\n            if(fst) {\n                fst = 0;\n                continue;\n            }\n            int p = lower_bound(d[yy].begin(), d[yy].end(), k - 1 - v) - d[yy].begin();\n            p = max(p, 1);\n            res += sum[yy][sum[yy].size() - 1] - sum[yy][p - 1] + 1LL * (v + 1) * (sum[yy].size() - p);\n            res += 1LL * (p - 1) * k;\n        }\n        double res2 = res * 1.0 / sz[xx] / sz[yy];\n        ans[make_pair(xx, yy)] = res2;\n        cout << fixed << setprecision(12) << res2 << endl;\n    }\n    \n}\nint main() {\n    cin >> n >> m >> q;\n    for(int i = 1; i <= n; ++i) {\n        par[i] = i;\n        sz[i] = 1;\n    }\n    for(int i = 1; i <= m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n        sz[find(v)] += sz[find(u)];\n        par[find(u)] = find(v);\n    }\n    solve();\n    \n    \n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "probabilities",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Expected diameter of a tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/51846",
    "editorial": "Letâs solve the problem for two trees. Define as diameter of -th tree\r\nand as the maximum path starting from -th vertex of -th tree, for all\r\nvalid and , assume that the edge is between them and find the diameter\r\nwith . The answer will be: .Letâs improve the solution to .Letâs sort\r\nthe arrays and decreasingly and make two partial sums of them, and ,\r\nsuch that . Iterate on , in step , we will check all of the valid edges\r\nwhich -th vertex is an endpoint of that: Consider the first element in\r\nas such that , by binary search, according to the previous solution for\r\n-th step, we should add it to the answer: Letâs prove if in each query,\r\nwe choose , the smaller tree, the solution will be accepted.There is two\r\nsimple modes we should consider:- If : The time complexity will be per\r\nquery. - If : Number of trees with is at last . If we donât calculate\r\nthe answer for two same pairs of vertices by memoization, at last time\r\nwe need to these bigger trees, so it yields .\r\n",
    "hint": [
        "hint1 Let's solve the problem for just two tree. Trivail solution is diameter of -th tree and is the maximum path starting from vertex , for all valid and , assume that the edge is between them and find the diameter with . consider this trivial solution and try to improve it to .",
        "hint2 Actually seems SQRT. How? For every new query, try to do it with the complexity of , which means size of the components of -th vertex. Prove its complexity is .",
        "hint1 You can prove, we need even number of swaps to reach the same permutation. So and the answer for and is -1.",
        "hint2 The solution almost is constructive. Try to solve it for n = 4 And then solve by .",
        "hint3 Let's partition numbers to classes, each class contains a consecutive numbers. And when there is a class with consecutive numbers.",
        "hint1 The problem consists two parts, the first part is to find and , the minimum and the maximum score -th vertex may get after the score distribution. The second part is to finding the answer and all your need to solve this part is those two arrays. It is trivial is number of real bullion of golds in -th vertex.",
        "hint2 Let's find the scores for two vertices and , have a directed edge to . u -> v If -th element from -th vertex was painted and -th element from -th vertex was unpainted such that then -th element from -th vertex will be painted quickly. For two vertex, we can do it in complexity .",
        "hint3 If we have this directed walk , you should affect on how I said in the previous hint with . What about strogly connected components. In this components if -th element from -th vertex was painted then for all of such that , -th element from all vertices will be painted quickly. For this components, we can do it with complexity . In the main problem, we can suppose all of a strongly conected component a vertex with size in this way and we can calculate with answer of its component's vertex multiplied by .",
        "hint4 SCC of the tournament yields a Hamiltonian path of strongly connected components( if we consider each component a vertex ). The problem decreased to solve this path. we can solve the path with the complexity of sum of vertices' sizes.",
        "hint5 Now, for every vertex we have minimum and maximum score it may get. For B known vertices, to check if they can be the wanted set, we can assume their score be maximum possible and the other scores be minimum possible. If they were top, then they can be a sample of the wanted set.",
        "hint6 Consider a sorted sequence of combination of two array and . For every vertex, consider the number of ways it(with its maximum score) can be the minimum score of the set of B vertices."
    ]
}