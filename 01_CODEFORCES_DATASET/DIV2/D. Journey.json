{"link": "https://codeforces.com//contest/43/problem/D", "problemId": "236", "problem_idx": "D", "shortId": "43D", "contest_number": "43", "problem_submissions": {"E": [204317, 203248, 205791, 203440, 204491, 203255, 203285, 204569], "D": [203414, 203389, 202746, 203128, 205117, 206004, 203089, 203486, 203882, 203224, 203555], "C": [201375, 201638, 201982, 201685, 201620, 201614, 201651, 201740, 201970, 202162, 202501, 202461, 202160], "B": [201164, 201219, 201274, 201224, 201377, 201223, 201446, 201422, 201870, 202173, 202210], "A": [200779, 200849, 200855, 200871, 200780, 205116, 205993, 200960, 200899, 201559, 201421, 201154]}, "name": "D. Journey", "statement": "The territory of Berland is represented by a rectangular field in size.\r\nThe king of Berland lives in the capital, located on the upper left\r\nsquare . The lower right square has coordinates . One day the king\r\ndecided to travel through the whole country and return back to the\r\ncapital, having visited every square (except the capital) exactly one\r\ntime. The king must visit the capital exactly two times, at the very\r\nbeginning and at the very end of his journey. The king can only move to\r\nthe side-neighboring squares. However, the royal advise said that the\r\nKing possibly will not be able to do it. But there is a way out one can\r\nbuild the system of one way teleporters between some squares so that the\r\nking could fulfill his plan. No more than one teleporter can be\r\ninstalled on one square, every teleporter can be used any number of\r\ntimes, however every time it is used, it transports to the same given\r\nfor any single teleporter square. When the king reaches a square with an\r\ninstalled teleporter he chooses himself whether he is or is not going to\r\nuse the teleport. What minimum number of teleporters should be installed\r\nfor the king to complete the journey? You should also compose the\r\njourney path route for the king.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std; \n\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FOR2(i, a, b) for (int i = (a); i > (b); --i)\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\nconst int INF = 1<<29;\ntypedef long long ll;\n\ninline int two(int n) { return 1 << n; }\ninline int test(int n, int b) { return n & two(b); }\ninline void set_bit(int & n, int b) { n |= two(b); }\ninline void unset_bit(int & n, int b) { n &= ~two(b); }\ninline int last_bit(int n) { return n & (-n); }\ninline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; }\n\ntemplate<class T> void chmax(T & a, const T & b) { a = max(a, b); }\ntemplate<class T> void chmin(T & a, const T & b) { a = min(a, b); }\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main()\n{\n\tint R, C;\n\tcin >> R >> C;\n\n\tif (R % 2 && C % 2)\n\t{\n\t\tcout << 1 << endl;\n\t\tcout << R << \" \" << C << \" \" << 1 << \" \" << 1 << endl;\n\t\tFOR(i, 0, R)\n\t\t\tFOR(j, 0, C)\n\t\t\tcout << i+1 << \" \" << (i%2==0?j+1:C-j) << endl;\n\t\tcout << 1 << \" \" << 1 << endl;\n\t}\n\telse if (R == 1 || C == 1)\n\t{\n\t\tbool swapped = false;\n\t\tif (C == 1)\n\t\t{\n\t\t\tswap(R, C);\n\t\t\tswapped = true;\n\t\t}\n\n\t\tif (C == 2)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 1 << \" \" << 1 << endl;\n\t\t\tif (swapped) cout << 2 << \" \" << 1 << endl;\n\t\t\telse cout << 1 << \" \" << 2 << endl;\n\t\t\tcout << 1 << \" \" << 1 << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 1 << endl;\n\t\t\tif (swapped) cout << C << \" \" << R << \" \" << 1 << \" \" << 1 << endl;\n\t\t\telse cout << R << \" \" << C << \" \" << 1 << \" \" << 1 << endl;\n\t\t\tFOR(i, 0, C)\n\t\t\t{\n\t\t\t\tif (swapped) cout << i+1 << \" \" << 1 << endl;\n\t\t\t\telse cout << 1 << \" \" << i+1 << endl;\n\t\t\t}\n\t\t\tcout << 1 << \" \" << 1 << endl;\n\t\t}\n\t}\n\telse\n\t{\n\t\tcout << 0 << endl;\n\n\t\tbool swapped = false;\n\t\tif (R % 2)\n\t\t{\n\t\t\tswap(R, C);\n\t\t\tswapped = true;\n\t\t}\n\n\t\tcout << 1 << \" \" << 1 << endl;\n\t\tFOR(i, 0, R)\n\t\t\tFOR(j, 0, C-1)\n\t\t{\n\t\t\tif (swapped) cout << (i%2==0?j+2:C-j) << \" \" << i+1 << endl;\n\t\t\telse cout << i+1 << \" \" << (i%2==0?j+2:C-j) << endl;\n\t\t}\n\t\tFOR2(i, R, 0)\n\t\t{\n\t\t\tif (swapped) cout << 1 << \" \" << i << endl;\n\t\t\telse cout << i << \" \" << 1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "implementation"], "dificulty": "2000", "interactive": false}