{
    "link": "https://codeforces.com//contest/1180/problem/C",
    "problemId": "361551",
    "problem_idx": "C",
    "shortId": "1180C",
    "contest_number": "1180",
    "problem_submissions": {
        "E": [
            55893859,
            55894752,
            55901354,
            55899227,
            55899601,
            55901958,
            55925264,
            55926068,
            55925665,
            55901489,
            233719923,
            56137984
        ],
        "D": [
            55886120,
            55888146,
            55895366,
            55891739,
            55901351,
            55888912,
            55886961,
            55887441,
            55889700,
            55885693,
            55885046,
            55888982,
            55895413,
            55887827,
            55888865,
            55887449,
            55890050,
            55889347,
            55889337,
            55889598
        ],
        "B": [
            55883680,
            55881669,
            55882390,
            55902887,
            55885746,
            55928231,
            55877920,
            55878680,
            55879245,
            55879265,
            55878648,
            55878842,
            55880598,
            55879213,
            55878902,
            55880179,
            55880226,
            55880939,
            55879031,
            55878699
        ],
        "C": [
            55881632,
            55883944,
            55885637,
            55882803,
            55884870,
            55882898,
            55883039,
            55882359,
            55884046,
            55883397,
            55882537,
            55907439,
            55883279,
            55883175,
            55884337,
            55884299,
            55883318,
            55885078,
            55882396,
            55882286
        ],
        "A": [
            55875261,
            55875247,
            55875638,
            55875332,
            55875345,
            55875222,
            55875465,
            55875376,
            55875312,
            55875276,
            55875257,
            55875199,
            55876007,
            55875234,
            55875346,
            55875606,
            55877781,
            55876574,
            55875619,
            55875756
        ]
    },
    "name": "C. Valeriy and Deque",
    "statement": "Recently, on the course of algorithms and data structures, Valeriy\r\nlearned how to use a deque. He built a deque filled with n elements. The\r\ni-th element is a_i (i = 1, 2,\r\nldots, n). He gradually takes the first two leftmost elements from the\r\ndeque (letâ€™s call them A and B, respectively), and then does the\r\nfollowing: if A > B, he writes A to the beginning and writes B to the\r\nend of the deque, otherwise, he writes to the beginning B, and A writes\r\nto the end of the deque. We call this sequence of actions an\r\noperation.For example, if deque was [2, 3, 4, 5, 1], on the operation he\r\nwill write B=3 to the beginning and A=2 to the end, so he will get [3,\r\n4, 5, 1, 2].The teacher of the course, seeing Valeriy, who was\r\npassionate about his work, approached him and gave him q queries. Each\r\nquery consists of the singular number m_j (j = 1, 2,\r\nldots, q). It is required for each query to answer which two elements he\r\nwill pull out on the m_j-th operation.Note that and for each query the\r\nnumbers A and B should be . is a data structure representing a list of\r\nelements where insertion of new elements or deletion of existing\r\nelements can be made from both sides.\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\n\nnamespace SOLVE {\n    ll a[1000010];\n    int l,r,n,q;\n    PLL ans[100010];\n    void main(){\n        in(n);\n        l = 0,r = n;\n        in(q);\n\n        REP(i,l,r)in(a[i]);\n        REP(i,1,100010){\n            ll A = a[l],B = a[l+1];\n            l++;\n            ans[i] = MP(A,B);\n            if(A<B)swap(A,B);\n            a[l] = A;\n            a[r++] = B;\n        }\n        while (q--) {\n            ll i;in(i);\n            if(i<100010){\n                printf(\"%lld %lld\\n\",ans[i].fi,ans[i].se);\n            }else{\n                i-=100009;\n                i%=n-1;\n                if(i == 0)i = n-1;\n                printf(\"%lld %lld\\n\",a[l],a[l+i]);\n            }\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. Valeriy and Deque.json",
    "editorial_link": "https://codeforces.com//blog/entry/67891",
    "editorial": "It can be noted that if the deque has the largest element of the deque in the first position, then during the next operations it will remain in the first position, and the second one will be written to the end each time, that is, all the elements of the deque starting from the second will move cyclically left.\n\nLet's go over the deque and find the largest element by value. We will perform the operation described in the statements until the maximum position is in the first position and save the elements in the first and second positions by the operation number. In order to pre-calculate all pairs until the moment when the maximum position is found, it is enough to make no more than one pass through the deque, since in the worst case, the maximum element can be located at the end of the deque.\n\nDenote as maxIndex\n the position of the maximum element. Then if mj<maxIndex\n, simply return a pair of numbers from the pre-calculated array, otherwise A\n is equal to the maximum element, and B\n is equal to the deque element with the index (mj?(maxIndex+1))%(n?1)+1\n in 0\n-indexing (since we performed the operations until the moment when the maximum position is in the first position, this maximum element is now recorded in the first position).",
    "hint": []
}