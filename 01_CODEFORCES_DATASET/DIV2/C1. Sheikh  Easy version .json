{
    "link": "https://codeforces.com//contest/1732/problem/C1",
    "problemId": "1601556",
    "problem_idx": "C1",
    "shortId": "1732C1",
    "contest_number": "1732",
    "problem_submissions": {
        "A": [
            177780757,
            177610358,
            177608551,
            177606643,
            177607169,
            177610084,
            177606577,
            177608412,
            177606634,
            177606927,
            177606608,
            177607362,
            177606772,
            177606726,
            177606713,
            177607069,
            177607097,
            177611108,
            177606918,
            177704415,
            177608226,
            177608992
        ],
        "E": [
            177657016,
            177656202,
            177633902,
            177640667,
            177803227,
            177634482,
            219606714,
            177713292,
            205728264
        ],
        "D2": [
            177641910,
            177631345,
            177624639,
            177622507,
            177657720,
            177627306,
            177634600,
            177636897,
            177705044,
            177639536,
            177633383,
            177633472,
            177633356,
            177632157,
            177640421,
            177640870,
            177713072,
            177632770,
            177633150,
            177631372,
            177704515,
            177639496,
            177628055
        ],
        "C2": [
            177632291,
            177641962,
            177622438,
            177615256,
            177628405,
            177620951,
            177620108,
            177616118,
            177614696,
            177620919,
            177623972,
            177616635,
            177637052,
            177635166,
            177620867,
            178222629,
            177623840,
            177623959,
            177628626,
            177704465,
            177632045,
            177631184
        ],
        "D1": [
            177621374,
            177621523,
            177609368,
            177617748,
            177635005,
            177615122,
            177622111,
            177619777,
            177625112,
            177625655,
            177620912,
            177619034,
            177613806,
            177616102,
            177629698,
            177628519,
            177632466,
            177625833,
            177704487,
            177616074,
            177626081
        ],
        "C1": [
            177616773,
            177634647,
            177613208,
            177615318,
            177628507,
            177619693,
            177620176,
            177616207,
            177614603,
            177613000,
            177624015,
            177616698,
            177626783,
            177614045,
            177620826,
            177623767,
            177623763,
            177621443,
            177704454,
            177618806,
            177621758
        ],
        "B": [
            177611173,
            177612224,
            177608250,
            177608561,
            177614708,
            177608123,
            177608457,
            177614546,
            177608888,
            177607945,
            177608753,
            177607801,
            177610965,
            177607589,
            177608533,
            177609886,
            177611017,
            177610279,
            177704436,
            177611009,
            177609323
        ]
    },
    "name": "C1. Sheikh  Easy version ",
    "statement": "You are given an array of integers a_1, a_2,\r\nldots, a_n.The cost of a subsegment of the array [l, r], 1\r\nleq l\r\nleq r\r\nleq n, is the value f(l, r) =\r\noperatorname{sum}(l, r) -\r\noperatorname{xor}(l, r), where\r\noperatorname{sum}(l, r) = a_l + a_{l+1} +\r\nldots + a_r, and\r\noperatorname{xor}(l, r) = a_l\r\noplus a_{l+1}\r\noplus\r\nldots\r\noplus a_r (\r\noplus stands for bitwise XOR).You will have q = 1 query. Each query is\r\ngiven by a pair of numbers L_i, R_i, where 1\r\nleq L_i\r\nleq R_i\r\nleq n. You need to find the subsegment [l, r], L_i\r\nleq l\r\nleq r\r\nleq R_i, with maximum value f(l, r). If there are several answers, then\r\namong them you need to find a subsegment with the minimum length, that\r\nis, the minimum value of r - l + 1.\r\n",
    "solutions": [
        "#include<cmath>\n#include<cstdio>\n#include<bitset>\n#include<iostream>\n#include<algorithm>\n#include<queue> \n#include<cstring>\n#include<set>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<unordered_map>\nusing namespace std;\n#define LL long long\n#define pp pair<int,int>\n#define ull unsigned long long\nnamespace IO{\n\tconst int sz=1<<22;\n\tchar a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];\n\tinline char gc(){\n\t//\treturn p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;\n\t\treturn getchar();\n\t}\n\ttemplate<class T> void gi(T& x){\n\t\tx=0; int f=1;char c=gc();\n\t\tif(c=='-')f=-1;\n\t\tfor(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=gc())\n\t\t\tx=x*10+(c-'0');\n\t\tx=x*f;\n\t}\n\tinline void flush(){fwrite(b,1,t-b,stdout),t=b; }\n\tinline void pc(char x){*t++=x; if(t-b==sz) flush(); }\n\ttemplate<class T> void pi(T x,char c='\\n'){\n\t\tif(x<0)pc('-'),x=-x;\n\t\tif(x==0) pc('0'); int t=0;\n\t\tfor(;x;x/=10) p[++t]=x%10+'0';\n\t\tfor(;t;--t) pc(p[t]); pc(c);\n\t}\n\tstruct F{~F(){flush();}}f; \n}\nusing IO::gi;\nusing IO::pi;\nusing IO::pc;\nconst int mod=998244353;\ninline int add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\ninline int dec(int x,int y){\n\treturn x-y<0?x-y+mod:x-y;\n}\nint qkpow(int a,int b){\n\tint ans=1,base=a%mod;\n\twhile(b){\n\t\tif(b&1)ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint fac[10000005],inv[10000005],Invn[600005];\ninline int C(int n,int m){\n\tif(n<m||m<0)return 0;\n\treturn 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid init_C(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod; \n\tinv[0]=1;\n\tinv[n]=qkpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tInvn[0]=Invn[1]=1;\n\tfor(int i=1;i<=200000;i++)Invn[i]=(LL)(mod-mod/i)*Invn[mod%i]%mod;\n}  \nint t,n,q,a[100005];\nLL s[100005],s2[100005];\nsigned main(){\n\tsrand(time(0));\n\tgi(t);\n\twhile(t--){\n\t\tgi(n),gi(q);\n\t\tfor(int i=1;i<=n;i++)gi(a[i]),s[i]=s[i-1]^a[i],s2[i]=s2[i-1]+a[i];\n\t\twhile(q--){\n\t\t\tint L,R;\n\t\t\tgi(L),gi(R);\n\t\t\tint ansl=-1,ansr=-1;\n\t\t\tLL mx=s2[R]-s2[L-1]-(s[R]^s[L-1]);\n\t\t\tfor(int i=L;i<=R;i++){\n\t\t\t\tint l=i,r=R,ans=-1;\n\t\t\t\twhile(l<=r){\n\t\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\t\tLL val=s2[mid]-s2[i-1]-(s[mid]^s[i-1]);\n\t\t\t\t\tif(val==mx)ans=mid,r=mid-1;\n\t\t\t\t\telse l=mid+1;\n\t\t\t\t}\n\t\t\t\tif(ans!=-1){\n\t\t\t\t\tif(ansl==-1)ansl=i,ansr=ans;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(ans-i+1<ansr-ansl+1)\n\t\t\t\t\t\t\tansl=i,ansr=ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpi(ansl,' ');\n\t\t\tpi(ansr,'\\n');\n\t\t}\n\t}\n\treturn 0;\n} \n/*\n\u9519\u8bef\u7684\uff0c\u504f\u6fc0\u7684\uff0c\u6781\u53f3\u7ffc\u7684\uff0c\u975e\u9a6c\u6069\u4e3b\u4e49\u7684\uff0c\u5973\u6743\u7684\uff0c\u5931\u8d25\u7684\uff0c\u4eba\u6c11\u65e5\u62a5\u7684\uff0c\u4e50\u7684\uff01 \n\u6587\u660e\u4e4b\u7f8e\u770b\u4e1c\u65b9\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C1. Sheikh  Easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108327",
    "editorial": "Note that . To prove this fact, let\u00e2\u0080\u0099s see how the sum and xor change\r\nwhen the element is added. The sum will increase by , but cannot\r\nincrease by more than .Then it was possible to use two pointers or\r\nbinary search to solve the problem. If you solve the problem in the\r\nsecond way, then you iterate over the right boundary of the answer and\r\nlook for the optimal left boundary for it by binary search. You will\r\nneed to find the sum on the segment and xor on the segment. To do this,\r\nyou can use prefix sums and prefix xor.\r\n"
}