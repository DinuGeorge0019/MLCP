{
    "link": "https://codeforces.com//contest/1100/problem/B",
    "problemId": "281740",
    "problem_idx": "B",
    "shortId": "1100B",
    "contest_number": "1100",
    "problem_submissions": {
        "D": [
            48353320,
            48357025,
            48358665,
            48352439,
            48485627,
            48356511,
            48354584,
            48367255,
            48355872,
            48356938,
            48418676,
            48367598,
            48366911,
            48360912
        ],
        "E": [
            48350143,
            48346134,
            48343035,
            48344468,
            48345510,
            48344044,
            48355215,
            48356334,
            48347647,
            48367496,
            48345429,
            48350647,
            48345628,
            48345908,
            48337155,
            48369088,
            48368217,
            48368175,
            48346637
        ],
        "F": [
            48345973,
            48351415,
            48352189,
            48350710,
            48349016,
            48346778,
            48348725,
            48353766,
            48349571,
            58874033,
            48356957,
            48346827,
            48367535,
            48349001
        ],
        "C": [
            48336896,
            48335321,
            48334130,
            48334390,
            48335310,
            48344018,
            48335734,
            48342199,
            48338272,
            48337047,
            48341951,
            48335611,
            48336047,
            48332446,
            48337175,
            48367539,
            48338679,
            48338717
        ],
        "B": [
            48334048,
            48332782,
            48332647,
            48331840,
            48351673,
            48332494,
            48337726,
            48333602,
            48340544,
            48335461,
            48333231,
            48335841,
            48335239,
            48333836,
            48331660,
            48334686,
            48373723,
            48367780,
            48340073,
            48333386
        ],
        "A": [
            48332192,
            48331699,
            48331636,
            48331355,
            48331447,
            48334124,
            48331785,
            48335827,
            48332710,
            48331483,
            48333294,
            48331582,
            48332077,
            48331359,
            48331604,
            48367585,
            48333354,
            48331926
        ]
    },
    "name": "B. Build a Contest",
    "statement": "Arkady coordinates rounds on some not really famous competitive\r\nprogramming platform. Each round features n problems of distinct\r\ndifficulty, the difficulties are numbered from 1 to n.To hold a round\r\nArkady needs n new (not used previously) problems, one for each\r\ndifficulty. As for now, Arkady creates all the problems himself, but\r\nunfortunately, he can’t just create a problem of a desired difficulty.\r\nInstead, when he creates a problem, he evaluates its difficulty from 1\r\nto n and puts it into the problems pool.At each moment when Arkady can\r\nchoose a set of n new problems of distinct difficulties from the pool,\r\nhe holds a round with these problems and removes them from the pool.\r\nArkady always creates one problem at a time, so if he can hold a round\r\nafter creating a problem, he immediately does it.You are given a\r\nsequence of problems’ difficulties in the order Arkady created them. For\r\neach problem, determine whether Arkady held the round right after\r\ncreating this problem, or not. Initially the problems pool is empty.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m,x,a[MAXN],ans[MAXN];\nmultiset<int> s;\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    memset(a,0,sizeof(a));\n    for(int i=1;i<=n;i++) s.insert(0);\n    int cnt=0;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d\",&x);\n        s.erase(s.find(a[x]));\n        a[x]++;\n        s.insert(a[x]);\n        if(*s.begin()>cnt)\n        {\n            cnt++;\n            ans[i]=1;\n        }\n        else ans[i]=0;\n    }\n    for(int i=1;i<=m;i++) printf(\"%d\",ans[i]);\n    puts(\"\");\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Build a Contest.json",
    "editorial_link": "https://codeforces.com//blog/entry/64545",
    "editorial": "We will keep the arrays, how many problems are created for each specific\r\ncomplexity and how many problems have been created for the round . Then\r\nif we create a task with complexity , we will recalculate , . Suppose we\r\nhave already given rounds. Then, after adding the next task, we only\r\nneed to check that , in this case we can held the next round, otherwise\r\nnot.The complexity is .\r\n",
    "hint": []
}