{
    "link": "https://codeforces.com//contest/721/problem/D",
    "problemId": "73870",
    "problem_idx": "D",
    "shortId": "721D",
    "contest_number": "721",
    "problem_submissions": {
        "E": [
            21042234,
            21104290,
            21041800,
            21039130,
            21182080
        ],
        "D": [
            21029644,
            21033019,
            21030262,
            21053351,
            21030654,
            21028935,
            21032532,
            21032446,
            21031468,
            21029821,
            21033557,
            21036571,
            21034746,
            21031908,
            21028774,
            21033067,
            21034309,
            21035655,
            21033370,
            21035759
        ],
        "C": [
            21024340,
            21029695,
            21023653,
            21025311,
            21023065,
            21023920,
            21023708,
            21027694,
            21026337,
            21025612,
            21024290,
            21025832,
            21026823,
            21026753,
            21033393,
            21026369,
            21027659,
            21024234,
            21028054,
            21028402
        ],
        "B": [
            21020547,
            21023831,
            21019117,
            21020848,
            21020236,
            21018793,
            21019630,
            21018806,
            21021097,
            21020368,
            21019611,
            21018664,
            21023267,
            21021687,
            21020531,
            21019677,
            21021078,
            21019653,
            21021642,
            21022060
        ],
        "A": [
            21016747,
            21016854,
            21016383,
            21017669,
            21020192,
            21016357,
            21016892,
            21016594,
            21016893,
            21016724,
            21016524,
            21016663,
            21017641,
            21017121,
            21017001,
            21016623,
            21017723,
            21016907,
            21017349,
            21018497
        ]
    },
    "name": "D. Maxim and Array",
    "statement": "Recently Maxim has found an array of integers, needed by no one. He\r\nimmediately come up with idea of changing it: he invented positive\r\ninteger and decided to add or subtract it from arbitrary array elements.\r\nFormally, by applying single operation Maxim chooses integer () and\r\nreplaces the -th element of array either with or with . Please note that\r\nthe operation may be applied more than once to the same position.Maxim\r\nis a curious minimalis, thus he wants to know what is the minimum value\r\nthat the product of all array elements (i.e. ) can reach, if Maxim would\r\napply no more than operations to it. Please help him in that.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define N 200005\nusing namespace std;\n\nint n,m,x;\nstruct node{\n\tll x; int y,z;\n}a[N];\nbool operator <(node u,node v){ return u.x>v.x; }\nbool cmp(node u,node v){ return u.y<v.y; }\npriority_queue<node> q;\nint read(){\n\tint x=0; char cr=getchar(); bool flag=0;\n\twhile (cr<'0' || cr>'9'){ if (cr=='-') flag=1; cr=getchar(); }\n\twhile (cr>='0' && cr<='9'){ x=x*10+cr-'0'; cr=getchar(); }\n\treturn (flag)?-x:x;\n}\nvoid opt(){\n\tint i;\n\tfor (i=1; i<=n; i++){\n\t\tif ((a[i].z<0) && (a[i].x!=0)) putchar('-');\n\t\tprintf(\"%lld \",a[i].x);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tint i,j,k; bool flag=0,flag2=0;\n\tfor (i=1; i<=n; i++){\n\t\ta[i].x=read(); if (a[i].x<0) flag=!flag;\n\t\t\tif (!a[i].x) flag2=1; a[i].y=i; a[i].z=((a[i].x)<0)?-1:1;\n\t}\n\tif (flag2){\n\t\tfor (i=1; i<=n; i++) if (!a[i].x){\n\t\t\tif (!flag) a[i].z=-1; break;\n\t\t}\n\t\tflag=1;\n\t}\n\tfor (i=1; i<=n; i++) a[i].x=abs(a[i].x);\n\tif (!flag){\n\t\tfor (i=2,k=1; i<=n; i++)\n\t\t\tif (a[i].x<a[k].x) k=i;\n\t\tif (a[k].x>=(ll)m*x){\n\t\t\ta[k].x-=(ll)m*x;\n\t\t\topt();return 0;\n\t\t} else{\n\t\t\t//puts(\"233\");\n\t\t\tj=(a[k].x/x+1); m-=j;\n\t\t\ta[k].x-=(ll)j*x;\n\t\t\ta[k].z=-a[k].z; a[k].x=-a[k].x;\n\t\t\t//cout<<k<<' '<<a[k].z<<endl;\n\t\t}\n\t}\n\tfor (i=1; i<=n; i++) q.push(a[i]);\n\twhile (m--){\n\t\tnode u=q.top(); q.pop();\n\t\tu.x+=x; q.push(u);\n\t}\n\tn=0;\n\twhile (!q.empty()){ a[++n]=q.top(); q.pop(); }\n\tsort(a+1,a+n+1,cmp);\n\topt();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\D. Maxim and Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/47457",
    "editorial": "Main idea: we act greedily, trying to make the best possible answer\r\nevery action (each time we choose an action with minimum possible\r\nproduct after it).Detailed explanation: While we have zeroes in our\r\narray, we have to get rid of them, changing each of them exactly one\r\ntime. Also we keep the quantity of negative numbers we need it to make\r\nthe product negative after changing the last zero. Let be the number of\r\nzeroes in the array. If , then we cannot make the product negative or\r\npositive (it will always be equal to ), so any sequence of operations\r\nwill lead to a correct answer. However, if , then we are able to come to\r\nnegative product (if the number of negative elements was even, then we\r\nsubtract from one zero and add it to all other zeroes; if the number of\r\nnegative elements was odd, then we can just add to all zeroes). If\r\ncurrent product is still positive, then we want to change the sign of\r\nexactly one element. Its absolute value has to be minimal: suppose we\r\nhave two elements and , ; let\u00e2\u0080\u0099s prove that if we change \u00e2\u0080\u0099s sign, then\r\nour answer is wrong. Let be the minimum number of operations required to\r\nchange \u00e2\u0080\u0099s sign. If we perform operations with , then the absolute value\r\nof won\u00e2\u0080\u0099t change, and absolute value of will become . If, on the other\r\nhand, we perform operations with (this may not be optimal, but now we\r\nneed to prove that if we change , then the result will be worse), then\r\nthe absolute value of will become , the absolute value of won\u00e2\u0080\u0099t change.\r\nThe product becomes negative, so we need to maximize the product of\r\nabsolute values. And then and , so if we change , then the product of\r\nabsolute values will be less than if we change . Now, until we have\r\nperformed operations, we choose a number with minimum absolute value and\r\nenlarge it (add if this number if positive, subtract if negative). Let\u00e2\u0080\u0099s\r\nprove that the answer will be optimal. Suppose that this algorithm\r\nchooses on some iteration, but we can\u00e2\u0080\u0099t get optimal answer if we change\r\n. This means that we can\u00e2\u0080\u0099t change after this iteration at all (we can\r\nreorder our operations in an arbitrary way, and the answer won\u00e2\u0080\u0099t\r\nchange). Suppose we have to change instead, and . Let\u00e2\u0080\u0099s consider the\r\nsequence of operations leading to the optimal answer when we choose ,\r\nand replace change of with change of , and let the product of all\r\nremaining numbers (the whole array excluding and after all operations)\r\nbe . If we change , the total product will be , and if we change , we\r\nget ( is the number of times we change ). Now , so , so the absolute\r\nvalue of total product will be greater if we change . This proves that\r\nwe won\u00e2\u0080\u0099t come to unoptimal answer if we change .Time complexity: if we\r\nuse a data structure similar to or to get the number with minimal\r\nabsolute value. Memory complexity: .\r\n"
}