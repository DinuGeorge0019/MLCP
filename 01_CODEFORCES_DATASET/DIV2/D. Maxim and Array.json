{"link": "https://codeforces.com//contest/721/problem/D", "problemId": "73870", "problem_idx": "D", "shortId": "721D", "contest_number": "721", "problem_submissions": {"E": [21042234, 21104290, 21041800, 21039130, 21182080], "D": [21029644, 21033019, 21030262, 21053351, 21030654, 21028935, 21032532, 21032446, 21031468, 21029821, 21033557, 21036571, 21034746, 21031908, 21028774, 21033067, 21034309, 21035655, 21033370, 21035759], "C": [21024340, 21029695, 21023653, 21025311, 21023065, 21023920, 21023708, 21027694, 21026337, 21025612, 21024290, 21025832, 21026823, 21026753, 21033393, 21026369, 21027659, 21024234, 21028054, 21028402], "B": [21020547, 21023831, 21019117, 21020848, 21020236, 21018793, 21019630, 21018806, 21021097, 21020368, 21019611, 21018664, 21023267, 21021687, 21020531, 21019677, 21021078, 21019653, 21021642, 21022060], "A": [21016747, 21016854, 21016383, 21017669, 21020192, 21016357, 21016892, 21016594, 21016893, 21016724, 21016524, 21016663, 21017641, 21017121, 21017001, 21016623, 21017723, 21016907, 21017349, 21018497]}, "name": "D. Maxim and Array", "statement": "Recently Maxim has found an array of integers, needed by no one. He\r\nimmediately come up with idea of changing it: he invented positive\r\ninteger and decided to add or subtract it from arbitrary array elements.\r\nFormally, by applying single operation Maxim chooses integer () and\r\nreplaces the -th element of array either with or with . Please note that\r\nthe operation may be applied more than once to the same position.Maxim\r\nis a curious minimalis, thus he wants to know what is the minimum value\r\nthat the product of all array elements (i.e. ) can reach, if Maxim would\r\napply no more than operations to it. Please help him in that.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define ll long long\n#define N 200005\nusing namespace std;\n\nint n,m,x;\nstruct node{\n\tll x; int y,z;\n}a[N];\nbool operator <(node u,node v){ return u.x>v.x; }\nbool cmp(node u,node v){ return u.y<v.y; }\npriority_queue<node> q;\nint read(){\n\tint x=0; char cr=getchar(); bool flag=0;\n\twhile (cr<'0' || cr>'9'){ if (cr=='-') flag=1; cr=getchar(); }\n\twhile (cr>='0' && cr<='9'){ x=x*10+cr-'0'; cr=getchar(); }\n\treturn (flag)?-x:x;\n}\nvoid opt(){\n\tint i;\n\tfor (i=1; i<=n; i++){\n\t\tif ((a[i].z<0) && (a[i].x!=0)) putchar('-');\n\t\tprintf(\"%lld \",a[i].x);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&x);\n\tint i,j,k; bool flag=0,flag2=0;\n\tfor (i=1; i<=n; i++){\n\t\ta[i].x=read(); if (a[i].x<0) flag=!flag;\n\t\t\tif (!a[i].x) flag2=1; a[i].y=i; a[i].z=((a[i].x)<0)?-1:1;\n\t}\n\tif (flag2){\n\t\tfor (i=1; i<=n; i++) if (!a[i].x){\n\t\t\tif (!flag) a[i].z=-1; break;\n\t\t}\n\t\tflag=1;\n\t}\n\tfor (i=1; i<=n; i++) a[i].x=abs(a[i].x);\n\tif (!flag){\n\t\tfor (i=2,k=1; i<=n; i++)\n\t\t\tif (a[i].x<a[k].x) k=i;\n\t\tif (a[k].x>=(ll)m*x){\n\t\t\ta[k].x-=(ll)m*x;\n\t\t\topt();return 0;\n\t\t} else{\n\t\t\t//puts(\"233\");\n\t\t\tj=(a[k].x/x+1); m-=j;\n\t\t\ta[k].x-=(ll)j*x;\n\t\t\ta[k].z=-a[k].z; a[k].x=-a[k].x;\n\t\t\t//cout<<k<<' '<<a[k].z<<endl;\n\t\t}\n\t}\n\tfor (i=1; i<=n; i++) q.push(a[i]);\n\twhile (m--){\n\t\tnode u=q.top(); q.pop();\n\t\tu.x+=x; q.push(u);\n\t}\n\tn=0;\n\twhile (!q.empty()){ a[++n]=q.top(); q.pop(); }\n\tsort(a+1,a+n+1,cmp);\n\topt();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "greedy", "math"], "dificulty": "2000", "interactive": false}