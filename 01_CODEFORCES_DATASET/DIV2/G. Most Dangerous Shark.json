{
    "link": "https://codeforces.com//contest/1131/problem/G",
    "problemId": "302314",
    "problem_idx": "G",
    "shortId": "1131G",
    "contest_number": "1131",
    "problem_submissions": {
        "G": [
            50392574,
            50483553,
            50483191,
            50597351
        ],
        "E": [
            50370230,
            50377398,
            50376874,
            50374805,
            50370023,
            50374639,
            50376085,
            50370141,
            59337133,
            50372624,
            50376988,
            50380444,
            51393637,
            50379092,
            50379324,
            50375235,
            50378370,
            50376960,
            50378218,
            50375618,
            50380739,
            50377794
        ],
        "D": [
            50363533,
            50363627,
            50365255,
            50374692,
            50360365,
            50367830,
            50371553,
            50364690,
            59336364,
            50377671,
            50371391,
            50369645,
            51393629,
            50371580,
            50368694,
            50364122,
            50370641,
            50367474,
            50370633,
            50364697,
            50370324,
            50391827,
            50367431
        ],
        "F": [
            50359710,
            50366576,
            50362359,
            50363609,
            50372028,
            50364108,
            54391189,
            54391158,
            54391141,
            50775614,
            50775596,
            50775586,
            50775566,
            50775556,
            50366322,
            50374409,
            59338739,
            50364318,
            50366547,
            50364869,
            51393655,
            50365763,
            50362358,
            50366172,
            50366229,
            50370184,
            50365915,
            50363686,
            50365490,
            50370524
        ],
        "C": [
            50357039,
            50359567,
            50360582,
            50355123,
            50364439,
            50361693,
            50361183,
            50360745,
            50361372,
            50363542,
            50360374,
            50363293,
            50355730,
            50368491,
            50363309,
            50362385,
            50362421,
            50365348,
            50362731,
            50360623
        ],
        "B": [
            50355578,
            50356862,
            50357573,
            50357717,
            50364015,
            50361039,
            50356264,
            50358549,
            50359269,
            50359561,
            50357291,
            50358021,
            50372318,
            50359218,
            50357829,
            50359757,
            50364553,
            50364635,
            50358492,
            50357639
        ],
        "A": [
            50354897,
            50355112,
            50355078,
            50360224,
            50354946,
            50354851,
            50362936,
            50355762,
            50355563,
            50355186,
            50355036,
            50355259,
            50369979,
            50355032,
            50355231,
            50355565,
            50355478,
            50359515,
            50355346,
            50355260
        ]
    },
    "name": "G. Most Dangerous Shark",
    "statement": "Semyon participates in the most prestigious competition of the world\r\nocean for the title of the most dangerous shark. During this competition\r\nsharks compete in different subjects: speed swimming, masking, map\r\nnavigation and many others. Now Semyon is taking part in destruction\r\ncontest.During it, m dominoes are placed in front of the shark. All\r\ndominoes are on the same line, but the height of the dominoes may vary.\r\nThe distance between adjacent dominoes is 1. Moreover, each Domino has\r\nits own cost value, expressed as an integer. The goal is to drop all the\r\ndominoes. To do this, the shark can push any domino to the left or to\r\nthe right, and it will begin falling in this direction. If during the\r\nfall the domino touches other dominoes, they will also start falling in\r\nthe same direction in which the original domino is falling, thus\r\nbeginning a chain reaction, as a result of which many dominoes can fall.\r\nA falling domino touches another one, if and only if the distance\r\nbetween them the height of the falling domino, the dominoes do not\r\nnecessarily have to be adjacent.Of course, any shark can easily drop all\r\nthe dominoes in this way, so the goal is not to drop all the dominoes,\r\nbut do it with a minimum cost. The cost of the destruction is the sum of\r\nthe costs of dominoes that the shark needs to push to make all the\r\ndominoes fall.Simon has already won in the previous subjects, but is not\r\nsmart enough to win in this one. Help Semyon and determine the minimum\r\ntotal cost of the dominoes he will have to push to make all the dominoes\r\nfall.\r\n",
    "solutions": [
        "/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,\"r\",stdin);\n#define fpo(x) freopen(x,\"w\",stdout);\n#define fprio fpi(\"in.txt\");fpo(\"out.txt\");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==' ');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes(\"\");}\ninline void writei(int x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n//#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<\"No\";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 1000000000\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n#define dp a\n#define fr fl\n/*************************************************/\nint n,m,q,i,j,fl[10000005],seq1[10000005],seq2[10000005],bk,x,y,l1,r1;\nlong long c[10000005],a[10000005];\nvector<int> va[250005],vc[250005];\nint gfl(int x){if (fl[x]==x) return x;return fl[x]=gfl(fl[x]);}\nint gfr(int x){if (fr[x]==x) return x;return fr[x]=gfr(fr[x]);}\npriority_queue<pair<ll,int> > pq;\nvoid mergel(int x,int y)\n{\n\tint i;\n\tfor (i=gfl(x);i>0&&i+y>=x;i--)\n\t{\n\t\ti=gfl(i);\n\t\tfl[gfl(x)]=i; \n\t}\n}\nvoid merger(int x,int y)\n{\n\tint i;\n\tfor (i=gfr(x);i<=m&&i-y<=x;i++)\n\t{\n\t\ti=gfr(i);\n\t\tfr[gfr(x)]=i;\n\t}\n}\nvoid upd(int x,ll y)\n{\n\tpq.push(make_pair(-y,x));\n}\nll qry(int x)\n{\n\twhile (!pq.empty())\n\t{\n\t\tif (pq.top().se<x) {pq.pop();continue;}\n\t\treturn -pq.top().fi;\n\t}\n\treturn -1;\n}\nint main()\n{\n\tread(n);read(m);\n\trep(i,n)\n\t{\n\t\tread(x);\n\t\trep(j,x)\n\t\t{\n\t\t\tread(y);\n\t\t\tva[i].pb(y);\n\t\t}\n\t\trep(j,x)\n\t\t{\n\t\t\tread(y);\n\t\t\tvc[i].pb(y);\n\t\t}\n\t}\n\tbk=0;\n\tread(q);\n\trep(i,q)\n\t{\n\t\tread(x);read(y);\n\t\tfor (j=0;j<va[x].size();j++)\n\t\t{\n\t\t\ta[++bk]=va[x][j];\n\t\t\tc[bk]=1ll*y*vc[x][j];\n\t\t}\n\t}\n\trep(i,n)\n\t{\n\t\tva[i].clear();\n\t\tvc[i].clear();\n\t}\n\trep(i,m)\n\t{\n\t\tfl[i]=i;\n\t\tmergel(i,a[i]-1);\n\t\tseq2[i]=gfl(i);\n\t}\n\trepd(i,m)\n\t{\n\t\tfr[i]=i;\n\t\tmerger(i,a[i]-1);\n\t\tseq1[i]=gfr(i);\n\t}\n\tl1=1;r1=0;\n\tforup(i,0,m)\n\t{\n\t\tif (i==0) dp[i]=0; else dp[i]=qry(i);\n\t\tif (i>=1)\n\t\t{\n\t\t\tll t=dp[seq2[i]-1]+c[i];\n\t\t\tif (dp[i]==-1||t<dp[i])\n\t\t\t{\n\t\t\t\tdp[i]=t;\n\t\t\t}\n\t\t}\n\t\tif (i<m)\n\t\t{\n\t\t\tupd(seq1[i+1],dp[i]+c[i+1]);\n\t\t}\n\t}\n\tcout<<dp[m]<<endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\G. Most Dangerous Shark.json",
    "editorial_link": "https://codeforces.com//blog/entry/65487",
    "editorial": "This problem can be solved using dynamic programming technique.Let be\r\nminimum cost to fall first dominoes. If -th domino was dropped to the\r\nright over such that dropped -th domino will fall all dominoes from to .\r\nOtherwise, some other domino was dropped to the right and fell domino .\r\nThen other such , that -th domino dropped to the right will fall -th\r\ndomino. Such solution works in .We need to speed up this solution. We\r\nneed to find possible for each faster. At first letâs notice, that\r\npossible âs forms subsegments, so we need just find most right . This\r\ncan be done using stack technique like finding nearest element greater\r\nthan current.Another part of the solution, we need to optimize is taking\r\nrange minimum query of âs. That can be easily done using segment tree\r\ntechnique or fenwick tree technique, however it requires time per query\r\nwhich is too slow. To make it faster we can use stack technique again!\r\nLetâs maintain stack of increasing values of (or , depending on case).\r\nBecause segments on which we are taking minimum are nested or\r\nnon-intersecting we can always drop all values after the optimum for\r\neach query. Using amortized analysis technique, we can see that such\r\nsolution works in .\r\n",
    "hint": []
}