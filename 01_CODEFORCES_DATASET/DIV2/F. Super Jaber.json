{
    "link": "https://codeforces.com//contest/1301/problem/F",
    "problemId": "538759",
    "problem_idx": "F",
    "shortId": "1301F",
    "contest_number": "1301",
    "problem_submissions": {
        "F": [
            71000973,
            71002227,
            71047404,
            71220694,
            70998932,
            71051995,
            71028699,
            71013382,
            71013182,
            71012775,
            71025862,
            71001305
        ],
        "E": [
            70990356,
            70991049,
            70989982,
            70995000,
            71228853,
            70994471,
            70996484,
            70997616,
            70993985,
            71001983,
            71006041,
            71000752,
            71000762,
            71000295,
            71036031,
            71006895,
            71006710,
            71008245,
            71004278,
            71001868,
            71010122
        ],
        "D": [
            70978990,
            70984686,
            70977541,
            70983758,
            70979628,
            70981590,
            70982372,
            70984362,
            70996505,
            70984162,
            70979443,
            70993040,
            70987583,
            70989615,
            70984290,
            70988249,
            70992550,
            70989175,
            70990934,
            70988497
        ],
        "C": [
            70971830,
            70973831,
            70972391,
            70970695,
            70971864,
            70969581,
            70970083,
            70974438,
            70974283,
            70973307,
            70972668,
            70972796,
            70978912,
            70982981,
            70973415,
            70972561,
            70970139,
            70973814,
            70975653,
            70976409
        ],
        "B": [
            70968569,
            70967678,
            70969977,
            70968275,
            70967585,
            70973366,
            70967417,
            70968730,
            70968327,
            70969402,
            70969851,
            70968467,
            70975325,
            70966853,
            70969894,
            70969422,
            70967771,
            70969867,
            70971492,
            70969502
        ],
        "A": [
            70962789,
            70962641,
            70962787,
            70964181,
            70962880,
            70962945,
            70962791,
            70962672,
            70962738,
            70962693,
            70965581,
            70963729,
            70962976,
            70962686,
            70963227,
            70964391,
            70962619,
            70962496,
            70966796,
            70962378
        ]
    },
    "name": "F. Super Jaber",
    "statement": "Jaber is a superhero in a large country that can be described as a grid\r\nwith n rows and m columns, where every cell in that grid contains a\r\ndifferent city.Jaber gave every city in that country a specific color\r\nbetween 1 and k. In one second he can go from the current city to any of\r\nthe cities adjacent by the side or to any city with the same color as\r\nthe current city color.Jaber has to do q missions. In every mission he\r\nwill be in the city at row r_1 and column c_1, and he should help\r\nsomeone in the city at row r_2 and column c_2.Jaber wants your help to\r\ntell him the minimum possible time to go from the starting city to the\r\nfinishing city for every mission.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ninline int read() {\n    char c; int x; for (c = getchar(); !isdigit(c); c = getchar());\n    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return x;\n}\n\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\n\nconst int N = 1e3 + 5, C = 42;\n\nint n, m, q, cc, ans, a[N][N], e[C][C], dis[C][C];\nshort f[C][N][N];\n\nint main() {\n    n = read(); m = read(); cc = read();\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            a[i][j] = read();\n        }\n    }\n    for (int u = 1; u <= cc; u++) {\n        for (int v = 1; v <= cc; v++) {\n            dis[u][v] = e[u][v] = 1e9;\n            if (u == v) {\n                dis[u][v] = e[u][v] = 0;\n            }\n        }\n    }\n    for (int c = 1; c <= cc; c++) {\n        std::queue<std::pair<int, int>> que;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (a[i][j] == c) {\n                    f[c][i][j] = 0;\n                    que.push({i, j});\n                } else {\n                    f[c][i][j] = -1;\n                }\n            }\n        }\n        for (; !que.empty(); que.pop()) {\n            int i = que.front().first, j = que.front().second;\n            for (int k = 0; k < 4; k++) {\n                int x = i + dx[k], y = j + dy[k];\n                if (x >= 1 && y >= 1 && x <= n && y <= m) {\n                    if (f[c][x][y] != -1) { continue; }\n                    f[c][x][y] = f[c][i][j] + 1;\n                    que.push({x, y});\n                }\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (f[c][i][j] != -1) {\n                    e[c][a[i][j]] = std::min(e[c][a[i][j]], (int) f[c][i][j]);\n                }\n            }\n        }\n    }\n    for (int u = 1; u <= cc; u++) {\n        for (int v = 1; v <= cc; v++) {\n            dis[u][v] = std::min(dis[u][v], e[u][v] + 1);\n        }\n    }\n    for (int w = 1; w <= cc; w++) {\n        for (int u = 1; u <= cc; u++) {\n            for (int v = 1; v <= cc; v++) {\n                dis[u][v] = std::min(dis[u][v], dis[u][w] + dis[w][v]);\n            }\n        }\n    }\n    q = read();\n    for (int _ = 0; _ < q; _++) {\n        int i = read(), j = read(), x = read(), y = read();\n        ans = std::abs(i - x) + std::abs(j - y);\n        for (int u = 1; u <= cc; u++) {\n            if (f[u][i][j] == -1) { continue; }\n            for (int v = 1; v <= cc; v++) {\n                if (f[v][x][y] == -1) { continue; }\n                ans = std::min(ans, f[u][i][j] + f[v][x][y] + dis[u][v] + 1);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\F. Super Jaber.json",
    "editorial_link": "https://codeforces.com//blog/entry/73877",
    "editorial": "In the shortest path between any two cells, you may use an edge that\r\ngoes from a cell to another one with the same color at least once, or\r\nyou may not.If you didnât use an edge that goes from a cell to another\r\none with the same color then the distance will be the Manhattan\r\ndistance.Otherwise you should find the best color that you will use that\r\nedge in it, the cost will be (the minimum cost between any cell of that\r\ncolor with first cell + the minimum cost between any cell of that color\r\nwith the second cell + 1).In order to find the minimum cost from every\r\ncolor to each cell, we can run multi-source BFS for every color.But\r\nvisiting all other cells that has the same color every time is too slow,\r\nso we can only visit these cells when we reach the first cell from every\r\ncolor.Complexity is .code:https://ideone.com/emv9dj\r\n",
    "hint": []
}