{
    "link": "https://codeforces.com//contest/1492/problem/B",
    "problemId": "905857",
    "problem_idx": "B",
    "shortId": "1492B",
    "contest_number": "1492",
    "problem_submissions": {
        "E": [
            108275392,
            108337957,
            108337929,
            108337897,
            108337869,
            108337530,
            108336584,
            108280929,
            108279892,
            108283262,
            108283717,
            108289278,
            108287786,
            108268660,
            108390482,
            108288687,
            108282322,
            108287306,
            108280347,
            108291576,
            108288062,
            108373037,
            108293277,
            129805186,
            108287644,
            108300980,
            108299703,
            108393370
        ],
        "D": [
            108260382,
            108258893,
            108270014,
            108263349,
            108264609,
            108252892,
            108264793,
            108287598,
            108390440,
            108271913,
            108257825,
            108266386,
            108268610,
            108279786,
            108409580,
            108293329,
            108289857,
            108251059,
            108267145,
            108268232,
            108256122,
            108256138
        ],
        "C": [
            108249862,
            108249847,
            108251625,
            108254267,
            108251919,
            108258077,
            108250178,
            108246037,
            108390405,
            108300472,
            108250750,
            108280684,
            108253606,
            108267184,
            108256872,
            108409648,
            108265283,
            108263373,
            108244223,
            108254346,
            108334110,
            108246220,
            108249150
        ],
        "B": [
            108245129,
            108245447,
            108247395,
            108247985,
            108246834,
            108246031,
            108256869,
            108242298,
            108390120,
            108243502,
            108256163,
            108245585,
            108255038,
            108249056,
            108252947,
            108246277,
            108240957,
            108244517,
            108243521,
            108242960,
            108244326
        ],
        "A": [
            108239344,
            108239466,
            108239941,
            108241103,
            108239731,
            108245369,
            108243343,
            108239512,
            108390047,
            108239332,
            108245439,
            108239555,
            108241591,
            108245013,
            108409613,
            108242749,
            108239786,
            108239373,
            108240879,
            108239525,
            108239590,
            108239428
        ]
    },
    "name": "B. Card Deck",
    "statement": "You have a deck of n cards, and you’d like to reorder it to a new\r\none.Each card has a value between 1 and n equal to p_i. All p_i are\r\npairwise distinct. Cards in a deck are numbered from bottom to top, i.\r\ne. p_1 stands for the bottom card, p_n is the top card. In each step you\r\npick some integer k > 0, take the top k cards from the original deck and\r\nplace them, in the order they are now, on top of the new deck. You\r\nperform this operation until the original deck is empty. (Refer to the\r\nnotes section for the better understanding.)Let’s define an as\r\nsum\r\nlimits_{i = 1}^{n}{n^{n - i}\r\ncdot p_i}.Given the original deck, output the deck with maximum possible\r\norder you can make using the operation above.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n\nll MOD = (ll)1000000007;\nvector<ll> nums;\nvector<bool> taken;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t, m, n;\n    ll k, ans = 0, a, b, c, j;\n    string s1, s2;\n    bool sad = false;\n    cin >> t;\n    while(t--) {\n        cin >> n;\n        nums.resize(n);\n        taken.resize(n+1);\n        for(int i = 0; i < n; i++) {\n            cin >> nums[i];\n        }\n        k = n; j = n;\n        for(int i = n-1; i >= 0; i--) {\n            taken[nums[i]] = true;\n            if(nums[i] == k) {\n                for(int z = i; z < j; z++) cout << nums[z] << ' ';\n                j = i;\n            }\n            for(k; k > 0; k--) {\n                if(!taken[k]) break;\n            }\n        }\n        cout << '\\n';\n        vector<ll>().swap(nums);\n        vector<bool>().swap(taken);\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\B. Card Deck.json",
    "editorial_link": "https://codeforces.com//blog/entry/87792",
    "editorial": "Itâs easy to prove that order of a deck differs for different\r\npermutations. And more than that order of permutation is greater than\r\norder of permutation if and only if is lexicographically greater than\r\n.Since we need to build a lexicographic maximum permutation, at each\r\npoint of time we need to choose such that -th element from the top of\r\nthe original deck is the maximum element in this deck. Total complexity\r\nis or (depending on the implementation).\r\n",
    "hint": []
}