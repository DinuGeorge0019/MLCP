{
    "link": "https://codeforces.com//contest/1369/problem/C",
    "problemId": "651257",
    "problem_idx": "C",
    "shortId": "1369C",
    "contest_number": "1369",
    "problem_submissions": {
        "F": [
            84805615,
            84815422,
            84821788,
            84848209,
            84808586,
            84845078,
            84819664,
            84809525
        ],
        "E": [
            84783653,
            84794541,
            84777094,
            84792178,
            84796407,
            84799473,
            84847985,
            84794191,
            84802657,
            84799608,
            84843231,
            84798901,
            84802992,
            84803891,
            84799522,
            84803293,
            84803734,
            84801605
        ],
        "D": [
            84774757,
            84783341,
            84767385,
            84777566,
            84781335,
            84780403,
            84783178,
            84780507,
            84786495,
            84784013,
            84784219,
            84785925,
            84784946,
            84790889,
            84787139,
            84785887,
            84796956,
            84790843
        ],
        "C": [
            84764211,
            84776491,
            85764231,
            85764174,
            84784880,
            84769031,
            84773069,
            84769214,
            84772926,
            84766954,
            84773427,
            84767072,
            84773264,
            84775000,
            84772759,
            84772359,
            84919485,
            84776351,
            84771759,
            84772941,
            84776880
        ],
        "B": [
            84758680,
            84760470,
            84777367,
            84762433,
            84762003,
            84761770,
            84766923,
            84760439,
            84763340,
            84761080,
            84766453,
            84765969,
            84767231,
            84765006,
            84759974,
            84762031,
            84767553,
            84769489
        ],
        "A": [
            84750967,
            84766185,
            84750778,
            84752543,
            84752490,
            84752217,
            84767956,
            84750544,
            84755659,
            84751856,
            84756195,
            84753655,
            84751015,
            84749918,
            84749358,
            84749254,
            84751162,
            84756777
        ]
    },
    "name": "C. RationalLee",
    "statement": "Lee has n integers a_1, a_2,\r\nldots, a_n in his backpack and he has k friends. Lee would like to\r\ndistribute integers in his backpack between his friends, such that the\r\ni-th friend will get exactly w_i integers and each integer will be\r\nhanded over to exactly one friend.Let\u2019s define the of a friend as the\r\nsum of the maximum and the minimum integer he\u2019ll get.Lee would like to\r\nmake his friends as happy as possible, in other words, he\u2019d like to\r\nmaximize the sum of friends\u2019 happiness. Now he asks you to calculate the\r\nmaximum sum of friends\u2019 happiness.\r\n",
    "solutions": [
        "// You may love a girl deeply\n// but you can't express in it more than 7-8 inches...\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(ass) ass.begin(), ass.end()\nusing namespace std;\n\ntypedef long long ll;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007;\nconst ll N = 2e5 + 85;\nconst ll Inf = 1e18;\nconst ll Log = 69;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++){\n\t\tll n, k;\n\t\tcin >> n >> k;\n\t\tvector<ll> A, B;\n\t\tll x;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x;\n\t\t\tA.pb(x);\n\t\t}\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tcin >> x;\n\t\t\tB.pb(x);\n\t\t}\n\t\tsort(all(A));\n\t\tsort(all(B));\n\t\treverse(all(B));\n\n\t\tll po = 0;\n\t\tll po2 = n - k;\n\t\tll ans = 0;\n\t\tfor(auto x : B){\n\t\t\tans += A[po2];\n\t\t\tif(x == 1) ans += A[po2];\n\t\t\telse ans += A[po];\n\t\t\tpo2 ++;\n\t\t\tpo += x - 1;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV2\\C. RationalLee.json",
    "editorial_link": "https://codeforces.com//blog/entry/79235",
    "editorial": ":First if for some , then assign the greatest element to -th friends,\r\nit\u00e2\u0080\u0099s always better obviously.Sort the elements in non-descending order\r\nand sort the friends in non-ascending order of . Define the set of\r\nindices of elements to give to -th friend. Also define the minimum\r\nelement to give to -th friend and the maximum element to give to -th\r\nfriend, and define .Now it\u00e2\u0080\u0099s easy to see that the first element of (the\r\nsmallest element) is always equal to for some , Indeed it\u00e2\u0080\u0099s better to\r\nhave the rest of equal to a small number except one of them, which\r\nshould be equal to a very large number. So we can greedily assign , ...\r\nto , and then assign to it, also it\u00e2\u0080\u0099s better to have . One can prove\r\nthat there exist an optimal distributing such that the set() is equal to\r\none of -s(proof is blow). So add to the answer for remaining elements of\r\n(excluding the set) and remaining friends(excluding one of the friends\r\nwith maximum ) and so, it will be optimal.Look at an optimal\r\ndistributing (which maximizes sum of happiness), first element of is in\r\nfor example, we want to prove that in at least one of the optimal\r\ndistributings smallest elements of are in (including the first element),\r\nproof by contradiction:If at least one of the smallest elements is not\r\nin , then call the smallest of them , lets say it\u00e2\u0080\u0099s in , now add to (and\r\nerase it from ), instead add a greater number than in to (it\u00e2\u0080\u0099s at least\r\ntwo of them, and one of them is , so there exist another one, erase it\r\nfrom and add it to ), it\u00e2\u0080\u0099s easy to see that sum of happiness won\u00e2\u0080\u0099t\r\ndecrease that way, continue the process until all smallest elements are\r\nin , so we have an optimal answer which has all smallest elements in ,\r\ncontradiction!As we proved above, we have an optimal distributing such\r\nthat all smallest elements are in (for some ), now we want to prove that\r\nthe greatest element is in in at least one of the optimal distributings,\r\nagain proof by contradiction.Lets say it\u00e2\u0080\u0099s not that way, so look at an\r\noptimal distributing such that first elements are in and is not equal to\r\nthe greatest element(for some ), if there exist such that , then swap\r\nand , the resulting distributing has the same happiness, continue it\r\nuntil no such exist, now lets say the greatest element of is in for some\r\n, also we know that is equal to the greatest element of and (if then the\r\nprocess of swapping is not finished, which is contradiction). So now we\r\ncan swap and , again the resulting distributing has happiness greater\r\nthan or equal to the happiness of the optimal distributing(the one we\r\nchose in the beginning), and so, its also an optimal distributing, and\r\nis equal to the greatest element, we have found an optimal distributing\r\nsuch that first elements of and are in (for some ), contradiction!Now we\r\nhave proved that there exist an optimal distributing such that first\r\nelements of and are in (for some ), call such optimal distributing , and\r\nnow the only remaining part is to prove that there exist an optimal\r\ndistributing such that first elements of and are in (for some ). See the\r\nwhole algorithm, its like \"we choose a permutation of friends then we do\r\nthat greedy assignment to them one by one from left to right\", now we\r\nwant to prove that there exist an optimal distributing such that it\u00e2\u0080\u0099s\r\nand it\u00e2\u0080\u0099s permutation is sorted in non-descending order of , call them\r\ndistributings. Again, proof by contradiction :Choose a distributing such\r\nthat it\u00e2\u0080\u0099s a , it\u00e2\u0080\u0099s permutation(called ) is not sorted in non-descending\r\norder of (otherwise it\u00e2\u0080\u0099s a distributing, contradiction!), so there exist\r\nan such that , now swap them(i. e. swap and and then do the same greedy\r\nassignment using the modified permutation of friends), it\u00e2\u0080\u0099s easy to see\r\nthat happiness of friends after in permutation wont change, also\r\nhappiness of friends before in the permutation wont change as well.Now\r\nlook at the happiness of and , you can realize that sum of happiness\r\nwill increase.You really don\u00e2\u0080\u0099t need to prove it like that, it\u00e2\u0080\u0099s not time\r\nfriendly at all. ^-^\r\n"
}